With timestamps:

00:00 - improve your go programming skills by
00:02 - developing three different projects in
00:04 - this go course experience developer Akil
00:07 - Sharma will teach you how to build a
00:09 - website Health Checker a program to
00:11 - encrypt text and a program to encrypt
00:14 - files hey guys in this video we're
00:17 - building three awesome projects with
00:19 - goang now these are beginner friendly
00:21 - projects and awesome additions to your
00:23 - portfolio in case you're applying for a
00:25 - goang job in the first project we're
00:27 - going to be building a goang health
00:30 - Checker where we'll check the health of
00:31 - a website so you'll just have to enter
00:33 - the domain name of a website and you'll
00:35 - come to know if it's live or it's down
00:37 - the second project is about encrypting
00:39 - files so we'll start with the PNG file
00:41 - and we'll encrypt it we'll try to access
00:43 - it without the password and then we'll
00:45 - access it with the password to see how
00:47 - encryption works the third project is
00:49 - about encrypting a string with goang so
00:52 - all these three projects you learn quite
00:53 - a bit a lot of goang so if you have
00:55 - basic goang skills you'll be able to
00:57 - refine your skills and build on top of
00:59 - that not knowledge so let's get started
01:02 - hey guys welcome back in today's video
01:05 - we're building a very simple project
01:07 - we're going to build a goang project
01:09 - which checks if a website is running or
01:12 - it's down and accordingly we'll show the
01:14 - appropriate message in the terminal
01:16 - saying the website is up or running or
01:19 - it's down or not running right and
01:22 - you'll find these kind of projects uh
01:24 - very easily on Google if you go and if
01:26 - you check if the is the website on there
01:28 - many projects like these and they
01:30 - basically run it free of cost but then
01:32 - they show ads so if you want to do that
01:34 - you can do that as well but it's just a
01:36 - great project to build and to basically
01:39 - practice your goang skills right uh now
01:42 - this project is going to be a part of
01:44 - the uh goang playlist goang Project
01:47 - Playlist so in my YouTube If you go to
01:50 - the playlist there's a goang playlist it
01:53 - right now it has 46 projects so I have
01:55 - called it the 46 killer goang projects
01:57 - playlist but then the number keeps Chang
01:59 - changing so once I put this video it'll
02:01 - be like 47 goang projects right so
02:05 - depending on when you watch this video
02:07 - the number would have changed but then
02:09 - you know it's important to know that
02:10 - that playlist exists and you can and
02:13 - what I'm trying to do is I'm trying to
02:14 - arrange those projects in the increasing
02:16 - level of difficulty and this project
02:18 - since it's very small and very simple
02:20 - we'll place it towards the beginning of
02:23 - that playlist even though I'm releasing
02:25 - it quite at the end but I'm going to
02:27 - actually position it towards the
02:29 - beginning of of the playlist okay so
02:31 - with that out of the way we can get
02:33 - started I'll show you a couple of
02:35 - diagrams just to help you visualize what
02:37 - your building uh and then we'll just go
02:40 - ahead and build it all right now just
02:42 - before we get started I just want to
02:44 - tell you that a very common name for
02:45 - this project that we're building is
02:47 - called the health Checker right so for
02:49 - any project that you're building you
02:50 - might also want to create a health
02:53 - Checker microservice in case you don't
02:55 - want to launch this as your own project
02:57 - on the internet completely fine uh but
03:00 - you can but usually when people build
03:02 - let's say a project and then they
03:03 - usually build a microservice which
03:04 - checks health of their own
03:06 - project so with with the project that we
03:09 - building you could do that like check
03:10 - the health of your own project or you
03:11 - could check the health of any website
03:13 - that's up or down you can check that
03:15 - state status of that website all right
03:18 - now we can get started so now I think
03:21 - you can see my
03:22 - screen here uh we've just represented
03:25 - what we'll be doing in our code so we'll
03:28 - have a main.go file which will have the
03:30 - main function and all we doing is
03:33 - importing the CLI package so it could be
03:35 - any CLI package like you could be using
03:37 - something like uh Cobra or something
03:39 - like that but I'll be using something
03:40 - very small and basic in this project
03:42 - because this project is small right and
03:45 - um we'll be passing two things we'll be
03:48 - making use of two things one is Flags so
03:50 - we'll set two flags which is the domain
03:51 - and the port and the action for the CLI
03:55 - tool tool would be to call the check
03:57 - function okay the check function is is
03:59 - going to be defined in a file called
04:01 - check. go it's going to accept
04:03 - destination and Port because that's what
04:04 - we'll send from here to this function
04:06 - destination and port and the whole
04:09 - business logic here or the Crux of the
04:11 - entire program is the dial timeout
04:13 - function this function you get in this
04:16 - package called net the net package very
04:18 - popular package to work with uh web web
04:20 - related things in goang right so we'll
04:22 - use D dial time out package and finally
04:26 - we will return the status of the website
04:28 - whether it's up or down so that's the
04:31 - entire business logic here in the in the
04:33 - project so now let's go ahead create a
04:36 - new project and get
04:37 - started all right so now we'll start
04:40 - building our project everything that
04:42 - I'll be showing you in this video is
04:44 - already there in my GitHub account so
04:47 - make sure you check out Akil Sharma 90
04:48 - which is my username on GitHub all the
04:51 - projects are there check out the code in
04:53 - case you get stuck somewhere we just
04:55 - create a new directory called go health
04:59 - check
05:00 - YT so we'll CD into
05:03 - it and what we'll do is we will um go
05:08 - mod in
05:09 - it and I'll just give it my
05:14 - username go health check right okay so
05:20 - now you can see the go mod file already
05:22 - has been created and we will just open
05:26 - up our vs fold and check out that yeah
05:29 - everything looks all right now I have
05:31 - decided upon the uh package that I'll be
05:35 - using it's CLI version two and I found
05:39 - it on this uh project on this profile
05:42 - called yourf This is a common package
05:44 - it's very very light so if you're not
05:47 - building something huge like a proper CI
05:49 - tool I recommend using something like
05:51 - this something very light like this
05:53 - there thousands of packages like these
05:54 - by the way but if you're building
05:56 - something serious then obviously Cobra
05:58 - CLI is is the way to go anyways now
06:01 - we'll create two files as you know one
06:03 - is the main.go
06:04 - file and the other is our check. go file
06:08 - okay in the main. go
06:10 - file we will do the regular stuff
06:14 - package name import the import
06:17 - statements and all of that and in the
06:19 - import I want to put this package so
06:22 - that it's clear that we're going to use
06:26 - it and then you have your fun
06:29 - main that's how you start that's the
06:33 - most important part in your main main.
06:35 - go file obviously and I'm going to go
06:38 - ahead and create an uh create app which
06:41 - is basically C.A right CLI being the
06:44 - package that I'm
06:46 - using and this helps to create a
06:48 - complete CLI tool where I can give it a
06:50 - name I can show how the tool is used I
06:53 - can give in the flags we've already
06:55 - talked about the flags and I can talk
06:57 - about the action it's supposed to have
06:59 - happen when
07:01 - the you know the right commands are or
07:06 - the right yeah the right commands are
07:08 - given what's the action that's supposed
07:10 - to
07:11 - happen all
07:15 - right
07:16 - [Music]
07:20 - so yeah now for for the name what we'll
07:24 - say is we'll say let's call
07:26 - it health checker
07:30 - and the usage let's usage basically
07:32 - basic text of how this product is going
07:34 - to be useful say tiny
07:36 - tool that
07:40 - checks whether a
07:42 - website is running or it's
07:47 - down and then there are the flags so CLI
07:51 - do
07:58 - flag
08:06 - okay and here you have the name which is
08:13 - domain
08:17 - aliases
08:18 - [Music]
08:20 - string
08:22 - D and the usage which is the this is
08:26 - where you'll enter the domain name like
08:27 - for example google.com that's the domain
08:29 - name to check whether it's up or down so
08:32 - that's domain and it's obviously it's
08:34 - required so we say required is true
08:36 - without this there's no point of the app
08:38 - if if you don't have this
08:40 - right all right so uh in the flags
08:43 - there's one more flag that we going to
08:45 - have which is the c. string flag it's
08:49 - going to be name will
08:51 - be
08:53 - Port Al
08:57 - s's string
09:02 - B
09:04 - Visage port number to
09:09 - check and
09:12 - required
09:17 - false
09:19 - right now for the
09:25 - action you're going to have c.
09:28 - context
09:35 - and we might return an
09:38 - error and let's define the port which is
09:41 - C do
09:44 - string and the
09:46 - port and if c.
09:49 - string and
09:52 - Port is null which is
09:55 - empty then the port will be 80 right so
09:58 - what's happening here which is standard
10:00 - basically whenever you check anything
10:02 - you're checking on Port 80 which is like
10:03 - the most common Port right where the uh
10:06 - the hand check would happen anyways but
10:09 - let's say um you but you can you can say
10:13 - any port you can mention any port here
10:15 - but if you have not mentioned any port
10:17 - here the default Port which is 80 which
10:20 - is the one that that's always checked
10:21 - that's the one that will be um set right
10:26 - for the port variable and then you have
10:30 - status is equal to check so this is the
10:32 - check function I was talking about which
10:34 - which we will create in the other file
10:36 - called the check.of file and you are
10:38 - checking the domain and the port so we
10:41 - sending two things to the check function
10:43 - which is domain and the port which is
10:44 - what I had shown you in the
10:45 - diagram
10:48 - and we're going to print the
10:51 - status and return ma for the error if
10:55 - everything go
10:58 - well here we'll say
11:02 - error equal to app.
11:07 - run okay so you say app which you just
11:11 - created the whole app using the CLI uh
11:14 - package and you're going to say app.run
11:16 - passing in the OS arguments and you're
11:19 - also handling the error so if there is
11:22 - an error you can do something about it
11:24 - if the error is not equal to n that
11:26 - means the error is there it's say log
11:28 - dot fatal and you'll print out the
11:34 - error all
11:37 - right and now we can work on the other
11:42 - file which is check. go so now we're
11:45 - going to go ahead and create the check.
11:47 - go file before that what I'll do is I'll
11:51 - just say go mod Ty just to create the go
11:55 - s
11:56 - file there seems to be some problem
11:58 - we'll fix fix it no
12:00 - problem so right now let's just create
12:02 - the check. go file okay so say package
12:05 - main also this part of package main only
12:09 - not creating a separate
12:11 - package and
12:14 - here uh there are a few more packages
12:17 - that I've used actually like fmt and all
12:20 - those and somehow they've not come up so
12:23 - usually when I save the files they come
12:25 - up like my plugins are not working I
12:27 - think right now I'll just copy and paste
12:29 - them on my own
12:31 - anyways all right so here also I'll need
12:34 - some packages I'll just say fmt time and
12:38 - net the most important one obviously
12:40 - here is the net package you know that
12:42 - because the net package has the um dial
12:47 - timeout function that we'll use to
12:49 - actually check the status of the website
12:51 - so we'll say fun
12:53 - check
12:56 - destination it's a string and Port which
12:59 - is a string and return the string string
13:03 - being the status so we return the status
13:05 - from the check
13:08 - function so here we'll say
13:14 - address equal
13:16 - to
13:18 - destination
13:23 - Plus Port right destination being the
13:26 - domain name and Port being the port that
13:28 - you pass in or or
13:31 - even um Port 80 which is the default
13:36 - right so we'll say for the duration
13:39 - of 5
13:43 - Seconds is a time
13:46 - out so within 5 seconds if you get a
13:49 - response back from the website that
13:51 - means the website is on otherwise it's
13:56 - not okay this is the main part which is
13:59 - we're using the net package and the dial
14:02 - timeout
14:05 - function we need to send in the address
14:08 - which is basically the destination the
14:09 - port both combined with the timeout
14:12 - which is 5 seconds in our
14:14 - case and let's create a variable called
14:18 - status which is the one that we're going
14:19 - to return from this
14:21 - function and here this error that we
14:24 - have which
14:25 - is we're checking we'll have to now
14:27 - check for that error so we'll say if
14:29 - error is not equal to nil means there is
14:33 - some error then we'll say status would
14:35 - be fmt dot Sprint
14:42 - F
14:44 - down website is not reachable so to
14:47 - print out the name of the website star V
14:49 - sorry percentage V is unreachable the
14:52 - website is not
14:54 - reachable and you
14:56 - can print out the error for percentage
15:02 - three and here the actual variables
15:05 - which is destination
15:09 - and the error all
15:12 - right
15:14 - else we will say status we FMP do
15:21 - printf and we
15:24 - say
15:27 - up
15:29 - percentage V
15:32 - that's the basically
15:35 - the website is
15:39 - reachable and then we'll print out
15:43 - from which address we
15:47 - tried
15:49 - to which
15:53 - address that means the
15:57 - destination comma
16:00 - [Music]
16:04 - connection
16:07 - dot local address right so your
16:10 - connection variable will have a copy of
16:13 - local address the address at your end
16:15 - which is making the conect the the
16:17 - request and the remote address basically
16:19 - the website and the port that you had
16:23 - mentioned just above and
16:27 - finally when your the status okay so all
16:32 - okay here I
16:35 - think to get rid of the error just
16:38 - remove this quickly and let goang do it
16:42 - for you so just say go mod tid it'll get
16:46 - all the
16:49 - packages right that you're supposed to
16:52 - have and it'll also generate the go. sum
16:54 - file for you here in the main. go file
16:56 - there's an issue because there's a small
16:58 - spelling mistake it should have been
17:02 - adss and uh but I see one more error so
17:06 - me quickly
17:08 - check yeah the other thing is that
17:11 - there's another spelling mistake here
17:12 - it's
17:14 - CLI all right so
17:17 - hopefully everything should be fine now
17:19 - but I still see one more
17:22 - error all right
17:25 - so uh yeah that's one more issue which
17:29 - is spelling of name is wrong I'll just
17:32 - save it everything seems fine now to
17:37 - me uh here so by flag you know what you
17:42 - mean by flag is that when we run this uh
17:46 - tool now we'll have
17:49 - to pass the flag so let me actually show
17:53 - you how to do it so we'll say go run do
17:57 - minus minus domain which which is the
17:58 - flag now in our case and it could be
18:01 - tel.com
18:02 - so it's saying it's reachable right so
18:05 - if you
18:07 - say
18:11 - google.com
18:14 - and
18:16 - amazon.com yeah so all the websites are
18:19 - up at the moment all of them are
18:20 - reachable all right so that was our
18:24 - simple yet effective tool that we've
18:27 - built
18:29 - and we've done we've done quite a bit in
18:32 - this
18:33 - tutorial uh it's a very very tiny tool
18:36 - but then a lot of Concepts have been
18:38 - used here so I hope you've learned quite
18:41 - a bit thank you so much for watching do
18:42 - make sure you watch all the other
18:44 - projects in this series because there so
18:46 - much to learn right and thank you so
18:49 - much for watching and do subscribe hey
18:52 - hey hey in today's video we are
18:54 - encrypting files with goang so in my
18:57 - root directory of this project I have
19:00 - the img.png file which I'm going to now
19:04 - encrypt so as you can see I can I can
19:06 - see the file now right but if I encrypt
19:08 - it so I'll say go
19:10 - run
19:13 - encrypt uh and I'll say img.png which is
19:16 - the name of the file I want to encrypt
19:18 - and I'll enter some password it'll
19:20 - confirm the password and it'll encrypt
19:21 - it for me and say it'll say file
19:24 - successfully protected and now as you
19:26 - can see I can't see it anymore I can't
19:29 - see the file anymore but now if I go and
19:32 - if I just decrypt the same
19:34 - file it will ask me to enter the
19:37 - password it will say file successfully
19:38 - decrypted and now again sorry now again
19:42 - I can see the image awesome
19:46 - right so how is this happening so let me
19:50 - let me take you through it so in the
19:52 - beginning what will happen is we will
19:55 - accept the um r arguments from user
19:59 - which is uh the basically the file the
20:03 - path to the file or the file name we'll
20:05 - validate if the file even exists or not
20:07 - and we'll also ask the user for the
20:09 - password and we'll validate the password
20:12 - in the sense if both the passwords match
20:13 - this is for the encryption part right
20:15 - we'll check if both the passwords match
20:17 - password one and password two then we'll
20:20 - encrypt the file and then for decrypt
20:22 - we'll again check the password after
20:24 - getting the password we check the
20:25 - password okay so it's really
20:27 - straightforward for for from a 10,000 ft
20:29 - perspective this is what's happening
20:30 - just getting arguments from the user
20:32 - validating the file getting the password
20:34 - from the user and cing the file by
20:36 - validating the password and then
20:37 - decrypting the file with the same
20:39 - password that's what's happening but if
20:41 - you look uh more if you look a bit
20:43 - deeper then you have two parts
20:46 - encryption and decryption in the
20:47 - encryption part uh we follow multiple
20:50 - steps so we first check for the source
20:52 - file we open that source file the one
20:54 - with the plain text which was our
20:56 - img.png and and then we'll re read that
20:59 - plain text now it could be the data from
21:01 - the PNG or it could be a text file right
21:03 - whatever it is it's basically plain data
21:05 - from the source file then we'll create
21:08 - an empty uh variable called a nuns this
21:10 - will be 12 bits or 12 bytes in our in
21:13 - our case and we'll create we'll
21:15 - randomize it so we'll create a random
21:16 - basically 12 byte uh variable we because
21:20 - we want to use it later on so firstly
21:23 - you have the password that we'll use to
21:24 - encrypt the file right so the the
21:26 - password and then there's something
21:27 - called as the length in the sense what
21:29 - do you want to get after running a
21:31 - derivation function so we'll basically
21:33 - be running a password based derivation
21:35 - function I'll talk more about it the
21:37 - first thing you need is a password the
21:38 - next thing you need is the bip length in
21:40 - our case will be 32 then the algorithm
21:42 - with which we want to encrypt it and the
21:45 - number of iterations in our case it will
21:46 - be like some somewhere around 4,000
21:48 - iterations iterations basically make it
21:50 - more difficult for the party that wants
21:52 - to uh hack this or or break the
21:55 - encryption just makes it more difficult
21:57 - for them okay okay so uh with the
21:59 - password based key derivation function
22:01 - this is a function in which a key will
22:03 - be generated from the password so we'll
22:04 - take in the password and we'll add in a
22:06 - few different things as you can see and
22:08 - we'll get a key and this can be used as
22:11 - an encryption key or the hash value so
22:13 - we basically just hashing the password
22:14 - now this is very similar to how you um
22:18 - take the users's password you hash it
22:19 - and then you store in the database right
22:21 - because you don't want to store the
22:22 - passwords directly in the database
22:23 - because otherwise people can steal or
22:26 - get access to the database steal all the
22:27 - password right so you always hash the
22:30 - passwords with some salt and that's
22:31 - what's happening here right so uh this
22:35 - is the salt in this case the nuns so
22:38 - with the password based key dation
22:39 - function you get something called as a
22:41 - derived key now the derived key we'll
22:43 - run it past uh AES or Advanced
22:46 - encryption standard this will give us
22:48 - some solid encryption abilities after
22:51 - after getting the key from the password
22:53 - and we'll and this by by running it
22:55 - through the a a cipher we'll get
22:57 - something called as a cyer for block and
22:59 - that again we'll run from uh through
23:02 - something called as the uh galwa counter
23:05 - mode now this is spelled as g l o i s
23:08 - but I think this is like a French word
23:10 - so you say gal galwa or something like
23:12 - that I'm not French so I have no idea so
23:15 - it's the GCM I call it the GCM galwa
23:18 - cter whatever blah blah blah but GCM
23:20 - basically right and GCM gives you more
23:22 - encryption with data Integrity checks
23:24 - now GCM generates a tag which is
23:27 - appended to the C Cipher text at the end
23:29 - and this tag is used to verify the
23:30 - Integrity upon data encryption now you
23:32 - had some data you encrypted it but then
23:34 - how do you know that the data that you
23:36 - got back is actually the correct data
23:38 - and that's why we using GCM because that
23:40 - gives us the tag to verify the Integrity
23:43 - of of the data upon decryption and GCM
23:46 - uses AES so we as as you know we have
23:47 - already used AES before it uses AES to
23:49 - encrypt the plain text this operates in
23:51 - a counter mode and hence the name and
23:53 - and generates a stream of encrypted
23:56 - blocks that's what GCM does finally we
23:58 - use this uh function called AES GCM
24:01 - which AES GCM is what you get so you
24:03 - already had the AES Cipher which is the
24:05 - ciper block then you run it through GCM
24:08 - you get AES GCM and you run this
24:10 - function called AES GCM do seal this is
24:12 - the main function now this is uh just to
24:15 - use this function we had to do all of
24:17 - this basically all of this part because
24:19 - we wanted to run this function called
24:20 - the seal function and the seal function
24:22 - is what takes the plain text from our
24:24 - file from our IMG file or any other file
24:27 - and convert it into Cipher text and it
24:29 - then creates a source file for encrypted
24:31 - data and we write Cipher text to the new
24:34 - source file so the the file in our case
24:37 - Remains the Same but then again we have
24:38 - to create the source file for the
24:40 - incryptor and write the cipher text
24:41 - Cipher text is basically text that we
24:43 - can't then access right so that'll be
24:45 - written to the source file so that's the
24:47 - encryption now let's go over the
24:49 - decryption for the decryption it's very
24:51 - very similar uh we'll check for the
24:53 - encrypted file so here we were checking
24:55 - for the source file that had to be
24:57 - encrypted and now we'll be checking for
24:58 - the encrypted file because uh to our
25:00 - program we will be saying that hey this
25:02 - is the encrypted file please decrypt it
25:04 - for me so we'll check for the encrypted
25:05 - file we'll open that file we'll read the
25:07 - cipher text from the enced file right
25:11 - the text that we can't open in our IDE
25:13 - but it still can be read from our
25:14 - function now to convert the cipher text
25:17 - into uh regular plane text we have to
25:21 - again run the password based key
25:23 - activation function so we'll have to
25:25 - have the same password which we used to
25:27 - enp we you have to have the same
25:28 - password to decrypt uh decrypt it as
25:30 - well same bite length same algorithm sh
25:33 - one and the number of itation should
25:35 - also be the same and then the nuns uh as
25:38 - you remember we created a nuns here a
25:40 - randomized nuns and uh the the GCM
25:42 - basically uh appended the nuns to the
25:45 - cipher text and exactly that's what we
25:47 - want we want to get the nuns from here
25:49 - uh which will be at the end so the the
25:51 - last 12 digits of the encrypted file
25:53 - will have the nuns you want access to
25:55 - that so all of these uh five things
25:58 - we'll pass to the password based key
26:01 - derivation function we'll get the
26:02 - derived key again the same thing as
26:05 - Cipher we'll get the cipher block GCM
26:07 - you'll get a GCM now we did again we did
26:10 - all of this so this was important
26:12 - obviously you know that you have to use
26:13 - SOL to Hash the password this is perfect
26:16 - but these extra steps we only did
26:17 - because we wanted to use this aesg cm.
26:19 - openen function which takes in the
26:22 - cipher text to this function without the
26:24 - NS obviously and gets you back the plain
26:26 - text now the pl text is what you will
26:28 - write again to a file which will have
26:31 - the decrypted data or the other PL text
26:33 - and that's the one that you will write
26:35 - back to the file and that's how you'll
26:36 - be able to read the file again so that's
26:38 - what's happening in your encryption and
26:40 - decryption so in our program in the code
26:42 - what we'll need to have is we'll need to
26:44 - um do all of this like the whole entire
26:47 - Logic for the encrypt function and the
26:50 - entire Logic for the decryption function
26:51 - and I'll keep opening this diagram again
26:53 - and again in between just so that we
26:55 - able to refer it while we are writing
26:57 - the code but the program also needs to
26:59 - do all of this so we'll the way I'm
27:01 - thinking of it is that I'll need one
27:03 - file which will have the encryption
27:04 - decryption functions and I'll need one
27:06 - file which is the main.go file which
27:07 - will will have all of this thing which
27:09 - will print out stuff to the terminal and
27:11 - accept uh values from the user from the
27:13 - terminal so all of that logic I'll put
27:15 - in main.go file okay so now we can start
27:18 - writing our code now before we start
27:20 - writing our code just want to tell you
27:21 - that um on my channel this particular
27:25 - video that we creating right now will
27:27 - show up in the 48 killer goang project
27:30 - Series so this is a playlist which
27:33 - basically is uh which has 48 projects
27:35 - now but I'll add this one so it'll be 49
27:38 - projects and um this playlist right is
27:43 - in the order of difficulty so we have
27:46 - smaller uh simpler programs earlier and
27:48 - then more difficult programs later on
27:50 - this will be somewhere in the middle
27:51 - it's not or somewhere towards the end
27:53 - but not at the complete end because this
27:55 - is not very difficult to build what we
27:57 - building today today uh so um just make
28:00 - sure you you go through all the videos
28:01 - in this playlist and you build them one
28:04 - by one and once you've done that you
28:05 - will no goang better than more better
28:08 - than 90% of the people or 99% of the
28:10 - people actually out there because I mean
28:13 - uh how many people do you know who build
28:15 - like 50 50 projects with goang right not
28:18 - many so this will seriously give you an
28:20 - edge if you build all the projects in
28:22 - this playlist all
28:24 - right and and uh I also wanted to tell
28:26 - you one more thing that if you go to my
28:29 - channel uh you get access to this
28:32 - Discord link here as you can see this is
28:34 - the Discord link for this community out
28:37 - here which is uh where we discuss a lot
28:40 - of stuff around golang and we share our
28:43 - learnings what we've been learning today
28:45 - uh we have a lot of um like forums where
28:48 - we uh discuss issues uh that we that
28:51 - you're facing blah blah blah so lot lot
28:53 - of stuff here so uh a lot of cool
28:55 - discussions happening so make sure sure
28:57 - you join this because uh I mean if you
29:00 - want to learn if you want to learn goang
29:01 - this is the right place to be this is
29:03 - the right Community to be at all right
29:05 - because I'm here quite a lot as you can
29:07 - see it's always open on my browser these
29:09 - days so I'm always there replying to
29:11 - messages all right so uh I have now
29:14 - talked through all the things that I
29:15 - wanted to talk through so now is the
29:18 - time to start building the project what
29:22 - I'll now do is I'll create a
29:25 - new uh directory
29:28 - called go file
29:32 - encryption by the way this program this
29:35 - project already exists on my GitHub so
29:38 - in case uh you are are already following
29:43 - me on GitHub uh you will see this
29:45 - program there the F encryption one um in
29:48 - case I don't put the link to this
29:50 - project in my description of this video
29:53 - please know that my GitHub is Akil
29:55 - Sharma 90 ail s RMA 90 the project is
29:59 - there in case you get stuck somewhere um
30:02 - you can access the code you can look at
30:04 - the code and build along with me all
30:06 - right so here I will CD into it I will
30:09 - CD into go file encryption and we will
30:13 - say go mod in
30:15 - it
30:17 - github.com
30:20 - sharma9
30:22 - SL code file
30:26 - encryption
30:28 - this creates a um go. mod file for us
30:32 - which will have the list of all our
30:33 - dependencies and I'll just go ahead and
30:36 - open this up in my code
30:41 - infl here I'll just create a um main.go
30:46 - file and I'll create a folder for file
30:53 - Crypt and there will be a file called
31:00 - filecrypt okay now I told you that I'll
31:04 - divide the logic into two different
31:05 - parts one will be the uh interfacing
31:08 - with the user part and the other will be
31:10 - the actual encryption and decryption so
31:14 - let's talk about the part where we'll
31:17 - accept user values so we first start
31:20 - with sorry package main not M we start
31:24 - with package main all right and there
31:27 - will obviously be Funk main which is
31:30 - from so main is the most important file
31:32 - main. go is the most important file
31:33 - which is obviously the main package
31:35 - again and then it has the main function
31:37 - which is where the uh program begins
31:39 - from or Origins everything starts from
31:41 - here and then this is why from this
31:43 - function we have to call all the other
31:44 - functions this is like the root or the
31:46 - source of everything then there will be
31:48 - an import statement here and I'll import
31:51 - multiple um packages in a while so
31:56 - firstly I want to check if the length of
32:00 - the arguments now to to work with
32:02 - arguments to print out messages to the
32:04 - CLI we could use something like Cobra
32:07 - which is a CLI tool and I have and I
32:09 - already have uh projects with that I
32:13 - think uh that's very commonly used in
32:16 - goang as you know Cobra uh we're not
32:19 - using it here because we have like very
32:20 - few operations and we can do that uh on
32:22 - our own we don't need to import a
32:25 - complete Library just to print out stuff
32:27 - to the terminal and to work with some
32:29 - arguments right and uh here we're just
32:32 - checking of the length of the arguments
32:35 - is less than two if it is less than two
32:37 - then we'll print
32:41 - help and print help will basically print
32:44 - out uh so there's a function called
32:46 - print help it's print help which
32:50 - basically tells the user and how to
32:52 - actually use this uh project so if he's
32:56 - not if the user user is not uh entering
32:58 - let's say encrypt or decrypt and the
33:00 - name of the file that means it doesn't
33:02 - know how to use this function right so
33:03 - you'll just print help out in that
33:10 - scenario and the other thing is function
33:14 - equal to OS do ARS
33:19 - one and we'll
33:22 - switch
33:24 - function so what do you want to do so do
33:26 - you want
33:30 - help if you want help we'll just print
33:32 - help we'll just call the print help
33:33 - function if you want to
33:39 - encrypt we will call the encrypt handle
33:44 - function if you want to
33:49 - decrypt you will call the
33:53 - decrypt handle
33:55 - function and then there is
34:00 - a
34:02 - default which
34:06 - is run
34:10 - encrypt to encrypt a file and TP to TP
34:17 - right just telling the user that hey
34:20 - please run encrypt to encrypt the file
34:22 - and decrypt to decrypt the
34:25 - file okay
34:27 - so that is our main function now as you
34:30 - know we're calling three functions from
34:31 - the main function which is the print
34:32 - help encrypt handle and decrypt handle
34:33 - so we're going to call we create all
34:35 - those
34:36 - functions uh so we have the we'll have
34:40 - the
34:42 - encrypt handle
34:45 - function and we have
34:48 - the
34:50 - decrypt hand
34:55 - function
34:58 - there are three more functions that
34:59 - we'll need in the encrypt handle there
35:01 - is the um get
35:07 - password to get the password from the
35:09 - user and then we have the
35:12 - validate
35:15 - uh so we have the get password function
35:18 - we have the validate file and validate
35:21 - password
35:23 - functions so let me create
35:25 - those
35:39 - password and
35:41 - frun
35:45 - validate validate
35:50 - file okay so and the print help print
35:52 - help is going to be very straightforward
35:54 - so I'll just go ahead and copy and paste
35:56 - actually don't have to write this whole
35:58 - thing on your own so this is basically
35:59 - saying file encryption simple file
36:01 - encryption for your day-to-day needs uh
36:04 - which is the name of the program and
36:05 - then what it does and then showing you
36:07 - usage that you can go run and uh when we
36:12 - say dot basically means it runs all the
36:14 - files in uh at the root which is our
36:16 - main.go and also our file. cp. go uh
36:20 - folder package and it'll basically uh
36:23 - you want to pass the path to your file
36:25 - in our case we'll just say img.png which
36:27 - will be a file that I'll copy and paste
36:29 - here you can copy and paste any file
36:31 - here I'm just using this apple file here
36:34 - and then you have the commands the
36:36 - commands like encrypt decrypt and help
36:38 - you'll have three commands encrypt will
36:39 - encrypt a file with a given password
36:41 - decrypt tries to decp a file using a
36:43 - password and help which displays the
36:45 - help text which is uh this particular
36:49 - function gets called
36:51 - there now for the encrypt handle which
36:54 - is the most important one uh sorry the
36:57 - encrypt and decrypt actually are both uh
36:59 - really important because that's the
37:00 - logic main logic so here we'll check if
37:03 - OS do if
37:05 - the length of os. ARS is less than three
37:11 - that means uh you have written you have
37:14 - written that uh you want to run the
37:19 - program and you want to encrypt but
37:22 - you've not passed
37:24 - the uh
37:27 - the pass the file right so it's argument
37:30 - sesson three then you will print
37:34 - Ln you will print
37:37 - out missing the part to
37:44 - five for more info
37:48 - run
37:53 - um so encrypt we say from the help
37:56 - command
37:57 - all right and
38:00 - os. exit
38:07 - Z if everything is all right then what
38:10 - you want to do is you want to get the
38:13 - arguments or which is basically the uh
38:16 - arguments at the second index which is
38:18 - the third
38:20 - argument uh which in our case is the
38:22 - part of the file you want to get it in
38:24 - this variable called file and you want
38:26 - to Val validate so if not validate
38:30 - file and you pass the file
38:33 - there and we'll just
38:37 - Panic file not
38:43 - found so what happens in the validate
38:46 - file function and this gets called it
38:48 - basically it takes in the file which is
38:51 - string and it passes back Boolean which
38:55 - is that's how we checking it it here you
38:56 - know true or false this exclamation
38:59 - helps us check that so if it's not uh
39:02 - valid then we say file not found okay
39:05 - and how does it return the Boolean it's
39:07 - basically using the os. stat function on
39:11 - the
39:14 - file and saying
39:18 - if ederal
39:21 - to OS do is
39:24 - not exist
39:28 - return false if it doesn't exist return
39:31 - false if it exists return
39:34 - true that's how we're checking for it
39:36 - out here so for the encrypt part we have
39:40 - checked
39:41 - um the validity of the file and not
39:44 - found now the next step is to ask for
39:46 - the password so we'll say password is
39:49 - equal to
39:51 - get password right so we already have
39:54 - the get password function so what is do
39:56 - it do it
39:59 - Returns the
40:01 - password which is a slice of
40:05 - bites and how does it accept the
40:07 - password it says first it prints out
40:11 - enter
40:14 - password then it's going to use the
40:16 - terminal terminal package to
40:19 - read the
40:22 - password and going to capture that
40:25 - in the
40:27 - password
40:35 - variable so when you if you remember
40:38 - when we were encrypting the file we
40:39 - didn't only just accept the password we
40:41 - also asked the user for the confirm
40:44 - password as in confirm this password so
40:46 - you want to print that out as well so
40:48 - you're going to
40:53 - say
40:55 - sln
41:00 - confirm
41:04 - password and we want to
41:07 - again read the
41:09 - password okay and this will be password
41:18 - to and here is where we will validate if
41:21 - the password one and password two are
41:23 - the same they're matching so we'll say
41:26 - if not
41:27 - validate password which will will pass
41:31 - password one and password two basically
41:34 - this function the validate password
41:36 - function should return back to us a
41:38 - Boolean and here we say fmt do
41:44 - print
41:51 - passwords do not match pleas try again
41:59 - turn get password if the password don't
42:02 - match we want this function the get
42:04 - password function to be called again and
42:06 - again Ask the pass uh the user password
42:08 - so if everything went well we just want
42:09 - to return the password from here which
42:12 - is a slice of bites okay now in the
42:14 - validate password function let's come
42:16 - here so it's going to accept something
42:19 - called as password one which is a slice
42:23 - of bites and password two which is again
42:28 - a slash of ptes return back a
42:33 - bilion and in here you want to check if
42:37 - the bytes are equal if everything is
42:40 - equal in password one and password
42:45 - two it's not equal
42:48 - return false if it's equal return
42:55 - true that that's our return uh validate
42:58 - password function which got called here
43:00 - and we'll go back now to our encrypt
43:02 - handle so after
43:04 - calling the uh the get password
43:09 - function we
43:12 - will say fmt do print Len and inform the
43:16 - user that hey we've started
43:19 - encrypting the file so we say
43:24 - encrypting and we'll use the file Crypt
43:27 - package the file Crypt package is our
43:29 - own we'll create the file Crypt package
43:31 - out here so we say file Crypt do encrypt
43:34 - because we'll have the encrypt function
43:36 - we'll pass it the file and the password
43:39 - and we'll print out FM do print Len
43:42 - you'll
43:45 - say file
43:49 - success
43:51 - detected so that's our encrypt handy
43:54 - function now in the decrypt handle
43:59 - function we will again check the same
44:02 - thing which is this like has he given us
44:06 - the file uh the part of the file if not
44:09 - we want to exit and we want to then
44:13 - validate the file
44:17 - again and we want to ask the user for
44:20 - this password so we say do
44:25 - print enter
44:31 - password and we want to say
44:43 - password terminal. read
44:49 - password and after taking the password
44:52 - we'll just print out instead of
44:54 - encrypting we'll just print out
44:59 - decrypting and instead of encrypt file
45:04 - the uh function encrypt function we'll
45:06 - just call the decrypt function passing
45:09 - the file and password and here instead
45:12 - of protected we'll just say
45:16 - decrypted so we have the encrypt handle
45:19 - and decrypt handle functions perfect
45:20 - clearly get password validate password
45:23 - validate file and CP handle print help
45:26 - and name now in the import statement we
45:29 - should have
45:32 - um all
45:35 - the
45:38 - files which file Crypt is my own package
45:41 - which I'll get from here the xterm
45:44 - package is the one that we're using here
45:47 - term uh the one that we're getting to to
45:49 - using to read the password and then we
45:51 - have byes fmtn okay so that's how it is
45:54 - now I can already see some issues and
45:56 - errors and some of them should go away
45:58 - once I've completed my file crypt.of
46:00 - file but then there will be many others
46:03 - that we fixed not a
46:05 - problem and now let's go ahead and start
46:08 - working on our file crypt.of file so
46:10 - starting with the filecrypt
46:13 - Dogo this package is going to be called
46:19 - filecrypt and we'll import some packages
46:22 - of
46:22 - course then we have two functions one is
46:25 - the encrypt function as you
46:28 - know and the other is going to the
46:31 - decrypt
46:39 - function
46:40 - okay because from here we are calling
46:44 - the encrypt and the decrypt
46:50 - functions so in the encrypt handle and
46:52 - decrypt handle respectively you call the
46:55 - encrypt function from file Crypt and the
46:58 - decrypt function from filecrypt those
47:00 - are the ones that we working on at the
47:02 - moment so in the E encrypt function you
47:04 - take in the source which is string and
47:08 - the password which
47:10 - is
47:13 - bite it's a slice of
47:17 - bytes
47:20 - okay so now this uh Source in our case
47:24 - is the file
47:26 - right because if you check here we're
47:28 - sending the file and the password so
47:30 - file and the password right so for the
47:32 - file we want to
47:34 - check if the
47:38 - file let me actually open up the browser
47:42 - and show you the diagram again and we'll
47:45 - follow the exact same
47:49 - steps so here it is we'll check for the
47:53 - source open the source file read read PL
47:56 - text from the source file create an
47:58 - empty nuns randomize nuns Let's do let's
48:01 - do those
48:04 - steps so first is os. stat
48:08 - then the
48:14 - source. is not
48:18 - exist and if it doesn't exist we are
48:21 - just going to return an
48:23 - [Music]
48:24 - error
48:30 - so first we checked for the
48:33 - file now we'll open up that file so
48:36 - we'll say os.
48:38 - open
48:41 - source and we'll capture that or store
48:44 - that in source
48:48 - file and if error is not equal to
48:52 - n
48:54 - panic
49:04 - errors at the end of this program when
49:06 - this function stops running we want to
49:08 - also close that source file so that's
49:11 - why we'll say differ Source file.
49:14 - flows now we'll read all the plain
49:18 - text from the source file so to read the
49:21 - pl text from the source file we'll use
49:22 - io. read all and source
49:27 - file what you get back is plain
49:35 - text and now we'll handle the error also
49:38 - error is not equal to
49:40 - n
49:46 - banic now the password that you have you
49:48 - want to store it in a variable because
49:50 - we want to work with it so we'll say key
49:51 - is equal to
49:54 - password and and now we'll create an
49:56 - empty nuns this is an empty nuns make
49:59 - and it's a slice of bite and of 12
50:03 - so it's going to look something like
50:05 - this it'll be 0 comma 0 comma 0 right 0
50:09 - 0 0 till 12 so 12 different values all
50:13 - of them zero that's what you create with
50:15 - this now and now we will randomize the
50:17 - nuns okay so we have created the empty
50:20 - DS now we'll randomize it we'll put
50:22 - random values in it and the way to do
50:24 - that is we'll
50:28 - say IO do
50:33 - read full random.
50:38 - reader so fill it with random values and
50:42 - error is not equal to
50:47 - nil Panic error
50:52 - dot
50:54 - awesome what's the next step now so on
50:57 - my screen the next step is we pass all
51:01 - these values to create into the password
51:03 - based deration key derivation function
51:06 - okay so the password based key
51:08 - derivation function is available to us
51:11 - in a package of the same name P key PB
51:14 - KD F2 and that function we pass the key
51:18 - the nuns 4096 as the number of
51:21 - iterations 32 as a length and sha 1. new
51:25 - as the
51:26 - algorithm so if you look here we passing
51:29 - the password to encrypt the file the
51:31 - nuns the number of iterations sha one
51:34 - and the B length which is 32 in our case
51:36 - and this is the number of
51:38 - vibrations what you get back from his
51:40 - this is called as the derived key DK so
51:44 - we just in short it's
51:46 - DK this package that we're getting
51:49 - everything from
51:54 - is
51:58 - is this package pbkdf2
52:06 - so now we have the derived key now we
52:09 - will
52:13 - create we
52:15 - will run it past by the advanced
52:18 - encryption standard so we'll say a. new
52:21 - Cipher
52:23 - DK and we'll get the
52:30 - block and we'll handle the error
52:33 - also so let say if error is not equal to
52:40 - n
52:44 - Panic
52:46 - error okay so we have this now the
52:49 - cipher block and now we want to use the
52:53 - galwa whatever ever it is you know GCM
52:56 - I'll call it GCM so it's the new GCM
52:59 - function so I'll say cipher. new GCM
53:03 - function and I'll pass in the block and
53:06 - what you get back is AES
53:14 - GCM if error is not equal to nil Panic
53:17 - error dot
53:24 - error
53:28 - okay so as as you know we did all these
53:31 - steps to to be able to run the seal
53:34 - function here which is what creates the
53:36 - which is is what converts the pain text
53:37 - to Cipher text so coming back here let
53:41 - us use the AES
53:45 - GCM do seal
53:47 - [Music]
53:49 - function this is what's going to take
53:51 - the plain text for
53:53 - us and
53:55 - send back the cipher
54:00 - text and
54:03 - you uh append the
54:06 - nuns so there is one thing that I have
54:09 - not drawn here but I have actually
54:10 - talked about it here is that we add the
54:13 - 12 by nuns at the end of the encrypted
54:16 - file so we want to do that now we want
54:18 - to append
54:20 - the nuns to the cipher
54:24 - text
54:28 - and store that in the cipher text
54:31 - itself so now we have the complete cyer
54:34 - text now we want to create a
54:41 - file source file for the encrypt data
54:43 - and want to write the data to the source
54:46 - file so what you'll do now is we'll call
54:49 - it the destination
54:52 - file.
54:54 - create create that
54:58 - file handle the error also here
55:04 - panic and at the end of this function
55:07 - when this function uh has done
55:10 - processing you want to close this file
55:13 - as
55:15 - well so you have created the file now
55:17 - you just want to write Cipher text into
55:19 - that file so write the cipher text into
55:22 - the file but this is the de file you'll
55:25 - say destination file. light and you
55:31 - will get the error if
55:34 - any if error is not equal to
55:41 - n
55:44 - Panic
55:45 - error
55:47 - okay so this was our encrypt function so
55:50 - far so good and as soon as I uh hit uh
55:54 - save it got me all the packages that I
55:58 - needed and now we want to work for the
56:01 - decrypt uh function the decrypt function
56:05 - is very similar it takes in
56:08 - the the the the path of the file and the
56:12 - password with the help of which we
56:14 - will decrypt
56:19 - this and first things first you want to
56:22 - check if the file that to be decrypted
56:25 - the the request that's coming for
56:27 - decryption if the file even exists or
56:28 - not so do the same thing
56:31 - .at
56:33 - Source this do is not
56:38 - exist error and here you
56:44 - will this is the error you're handling
56:46 - here and you're just saying
56:50 - Panic error okay and actually some of
56:54 - the part from here is going to be
56:56 - similar so I will just um copy this
57:01 - part all of this part till here I'll
57:05 - just copy
57:07 - it uh once
57:09 - again after
57:14 - this so here you will have uh SRC file
57:18 - where you'll open that source file and
57:22 - at the end you will close it also and
57:24 - here instead of plain text you'll just
57:26 - have Cipher text because that's what is
57:29 - in the file now because you have already
57:32 - encrypted the file and you're passing
57:33 - the encrypted file to this decrypt
57:35 - function and that's why whatever is
57:36 - there in the file is now Cipher text so
57:39 - we have done in the decryption part we
57:41 - we're done with this check for the
57:42 - encrypted file open the encryp file and
57:44 - read the text Cipher text from the
57:45 - encrypted
57:46 - file all of this is
57:50 - done okay so the password that you will
57:53 - receive in this function will again be
57:55 - stored in the variable key then we'll
57:58 - have a variable called salt which will
57:59 - basically have Cipher text and length of
58:03 - Cypher so without
58:05 - the last
58:09 - 12 okay
58:15 - and x dot and code to
58:20 - string the salt which is basically the
58:22 - nuns the last 12 is the nuns right
58:25 - you'll have it inall in Sal and we will
58:28 - use the hex package to decode this
58:39 - string and we'll store that in Str
58:47 - [Music]
58:49 - Str sorry this will be NS
58:53 - now
59:14 - okay okay so what do you pass again in
59:16 - that function the password based key
59:19 - derivation function for decryption you
59:21 - pass the same password to to that will
59:24 - be used to decrypt the bite length 32
59:26 - chart 1 iterations 4096 and the NS that
59:29 - we got from the last 12 uh digits of the
59:32 - cipher
59:35 - text and the same thing you do here you
59:37 - say new Cipher
59:41 - sorry new yeah a. new Cipher and you
59:45 - pass the derivation key derivative key
59:48 - and you'll again get the
59:52 - block and again you can have handle the
59:55 - error if error not error not equal to
60:00 - nil and then you want to pass that block
60:03 - to uh the
60:06 - cipher AES Cipher so what I'll do is
60:15 - I'll yeah we've already done that and
60:17 - now we want to pass it through the
60:22 - CGM GCM sorry
60:29 - yeah so the same thing that we done
60:32 - there we're doing it here and now
60:34 - there's only one little difference uh
60:36 - which is that instead of using the as
60:39 - GCM
60:40 - do
60:42 - um seal function we'll just use
60:48 - a
60:51 - GCM do open
60:53 - function so here we'll have the nuns the
60:56 - cipher
60:57 - text which
61:01 - is everything apart from those
61:05 - last um
61:16 - 12 and what you get back from this is
61:18 - the plain
61:20 - text okay so what you're seeing now is
61:23 - uh step by step we're just looking at
61:25 - the
61:26 - diagram and we are uh converting the
61:29 - diagram into code okay so our flowchart
61:33 - into
61:35 - code again let's handle the error
61:39 - here and then we'll again create the
61:45 - file like we did last time the
61:46 - destination
61:48 - file so I'll copy and paste that part
61:52 - Here and Now we will write plain text to
61:56 - this file so instead here we wrote the
61:57 - cipher text to the file and now we will
62:00 - write the plain text which we have
62:05 - received to the file so here what was
62:08 - happening in the encrypt function what
62:10 - was happening is that you ran that
62:12 - function called uh the seal function
62:15 - which gave you the cipher text to run
62:17 - the seal function as GCM seal function
62:19 - you had to uh do all of these steps
62:21 - which is get the plain text and then
62:24 - create your nuns have your password
62:26 - ready uh create a derived key with PB
62:29 - kdf function use Advanced encription
62:32 - standard new Cipher create a block
62:34 - Cipher block pass the cipher block uh
62:36 - with GCM and get AES GCM and then you
62:39 - were able to call the seal function to
62:41 - get the cipher text with all those
62:42 - values here exactly the same things you
62:46 - just had to call the as GCM do open
62:48 - function because this will give us the
62:50 - plain text from the cipher text Cipher
62:52 - text is everything apart from those 12
62:54 - last digits which actually was the nuns
62:57 - in our case for nuns right the salt
63:00 - which we can convert into nuns here and
63:03 - uh then finally just like we did in the
63:05 - encryption file we created a file and
63:07 - then we wrote plain text back into that
63:09 - file and now when we open up this file
63:11 - we'll be able to access it right so as
63:14 - you can see I have a lot of errors and
63:16 - I'm not at all scared because now when I
63:18 - go ahead and run this program uh I
63:23 - will come to know what the issues are so
63:26 - I'll say go
63:28 - run
63:31 - encrypt
63:34 - PNG and here I see all of these issues
63:37 - it says uh file Crypt to add file Crypt
63:41 - and yeah so xterm and file CPT are not
63:44 - there that means I need to say go mod
63:47 - tidy so first I'll get these
63:53 - packages
64:00 - let's I can see some issue there but
64:02 - let's see if it still
64:04 - works yeah still the same issues I'm
64:07 - getting so let's try to fix
64:09 - it now one issue out here obviously is
64:13 - this part which is I've copied the link
64:16 - from my previous project now this is
64:19 - obviously my GitHub and this should be
64:21 - the name of the project right and I'm
64:23 - and I'm calling file Crypt package but
64:25 - the name of the project is wrong that I
64:27 - have to go and get from go mod so the
64:29 - name of the project is actually go file
64:30 - encryption in this case and I have to go
64:32 - ahead and get it here and this issue
64:35 - will go away uh now what we'll do is
64:38 - we'll
64:39 - again go and
64:42 - run go run
64:45 - encrypt IMG or PNG and now we'll get a
64:48 - list of issues okay so now uh on line 68
64:52 - file Crypt line 68 file
64:56 - Crypt as I can see it's should have been
65:00 - error okay now let me check out line um
65:05 - 83 line 83 key is not used yes because I
65:08 - was supposed to use key here by mistake
65:10 - I've written name and here also I can
65:13 - see one more issue it's key should have
65:17 - been key right uh now the other thing I
65:19 - can
65:21 - see is um
65:24 - 88 which is undefined yeah it's the same
65:27 - thing this one the issue 988 all right
65:30 - so that's solved but now I can still see
65:33 - four issues in main. go so what we'll do
65:37 - is we'll go ahead and run this
65:39 - again uh
65:41 - here now we can see some issues from
65:43 - main.go file and the um first one is on
65:51 - 50 okay
65:55 - and then online
66:01 - 66 and then on line
66:06 - 87
66:09 - print line uh
66:14 - 102 right so what I'm trying to show you
66:17 - here is with if you're working with
66:18 - Technologies like goang and rust you
66:21 - don't have to worry at all about making
66:23 - mistakes the code so don't depend too
66:26 - much on extensions right so many people
66:28 - would tell you get extensions that help
66:30 - you uh not make any mistakes in the code
66:33 - while writing the code uh for spelling
66:35 - and for for uh you know goang so don't I
66:39 - would suggest don't don't depend too
66:41 - much on that as you can see I I wrote
66:42 - everything
66:43 - myself and uh I just depended on the on
66:47 - the goang compiler to tell me the issues
66:49 - and I just solve them one by one so just
66:52 - just depend on Goan compiler because
66:54 - when you're in an interview when you're
66:56 - giving the interview for some company uh
66:58 - you're not sure what kind of environment
67:00 - you'll get to write the code with mostly
67:02 - it's an online environment right and you
67:03 - have somebody on a call you have an
67:05 - online environment and you have to write
67:06 - the code in that online environment that
67:08 - won't have the extensions that you want
67:10 - and that you work with so it's highly
67:12 - recommended that you don't depend on
67:13 - extensions I've had many of my friends
67:16 - get into a lot of trouble because of
67:17 - that um but but know how to work with
67:21 - the goang compiler a lot like get very
67:24 - very good at debugging code okay so uh
67:28 - now things should work so it says ask me
67:32 - to enter the
67:33 - password and I will enter the password
67:36 - it will ask me to confirm the password
67:38 - I'll confirm the password it say file
67:40 - successfully protected try to open up
67:41 - the file I'm not able to okay and now
67:44 - what I'll do is I'll just run this um
67:47 - again with instead of encrypt it be
67:50 - decrypt and I'll just enter the password
67:53 - I had Ed earlier and now as you can see
67:55 - I can check out the file I can look at
67:58 - the file okay so this was our project
68:01 - everything works perfectly fine thank
68:03 - you so much for watching uh this I would
68:06 - say is is an intermediate level project
68:08 - it's not very Advanced it's not very
68:10 - simple uh like it's not a beginner level
68:12 - project probably and it's not an
68:14 - advanced project also somewhere uh in
68:17 - the middle but I hope you learned a lot
68:19 - thank you so much for watching if you
68:21 - haven't subscribed to this channel make
68:22 - sure you subscribe I'll come up with
68:24 - awesome content like this in the future
68:26 - thank you so much we're building
68:28 - something really interesting in today's
68:29 - video what we'll do is we'll just take
68:31 - some plain text encrypt it we'll get the
68:34 - encrypted text we'll then run it through
68:37 - a decryption function and then we'll get
68:39 - the decrypted text so it's quite
68:43 - straightforward it's something we
68:44 - haven't done before on this channel
68:46 - right it's uh working with encryption
68:49 - algorithms so we using a very simple
68:51 - encryption algorithm called the C are
68:54 - Cipher in this project and let me give
68:56 - you a quick demo on how this works so if
69:00 - I run go run main.
69:03 - go my plain text that I had given to the
69:06 - program was hello world and I get the
69:08 - encrypted text which is c z g g jrj mg Y
69:14 - and when we decrypt it again we get
69:16 - Hello World back right and in the
69:18 - program itself you can uh give it some
69:21 - text that it will encrypt and decrypt
69:23 - you can also build a CLI on top of it to
69:26 - accept the text from the user I haven't
69:29 - done that because in this project I want
69:31 - us to focus only on the encryption and
69:32 - decryption part we don't want to focus
69:34 - on the CLI part because I've already
69:36 - done that in many other projects okay so
69:40 - how this is working is we first take
69:43 - some text hello world right and by the
69:46 - way uh this is very quick visual
69:49 - programming visual planning that we'll
69:50 - do before we actually start programming
69:52 - so that we know exactly where we going
69:54 - and this is just a quick demo to show
69:55 - you how and uh how we're going to build
69:58 - it and what exactly uh is it that we're
70:00 - doing so we have our text hello world
70:02 - that you saw in the demo and we give
70:04 - this a key five so this key can change
70:07 - could be seven could be 10 whatever but
70:09 - in my case I'd given it the key five
70:11 - okay and I'll I'll tell you what that
70:13 - key
70:14 - means so with Caesar Cipher what what
70:16 - what happens is you pass in let's say
70:19 - all the uh alphabets so in my case in my
70:23 - program I had passed it all the
70:24 - alphabets you can also pass in numbers
70:28 - to this program and you can also give it
70:30 - special characters and what we want to
70:32 - do is with CES Cipher we want to replace
70:34 - uh this text with some
70:37 - other uh alphabets from the alphabets
70:40 - that we we have given it right so this
70:42 - one is going to be called as the
70:44 - original
70:46 - text because from this we will
70:50 - select uh some
70:52 - other
70:54 - characters that will basically replace
70:56 - this text of powers right so in the in
70:57 - the end you get something like this is
70:59 - CZ e jrj mg Y which is the encrypted
71:03 - text which nobody can understand but
71:04 - when you decrypt it the person who's
71:06 - supposed to uh receive this will get
71:09 - Hello World back
71:10 - okay and by the way uh in the beginning
71:13 - of computation this is how many
71:15 - encryption algorithms worked and now you
71:17 - have obviously much more advanced
71:19 - algorithms and that's what you see when
71:21 - you see WhatsApp saying it's end to end
71:24 - encrypted they're basically encrypting
71:25 - all the text that you're sending and
71:27 - you're getting back uh the user is
71:29 - getting back the actual text but then
71:31 - there's some encryption happening in
71:32 - between so that nobody can intercept
71:34 - those messages and read the meaning or
71:36 - read those messages basically so um the
71:40 - way this is working is first we'll take
71:42 - 26 which is the length of all of these
71:46 - uh all of the basically characters that
71:48 - we have sent the original text length is
71:51 - 26 and then we'll subtract the key which
71:54 - is five from that okay and then we'll
71:57 - create two different uh versions of this
72:00 - original text one is from 0 to 21
72:02 - because if you subtract 26 from 25 you
72:05 - get the number 21 so from 0 to 21 you'll
72:08 - separate that into a different bucket
72:11 - and from 21 to 26 you'll separate that
72:13 - into a different bucket right and then
72:14 - what you do is you attach this in front
72:16 - of uh this part right so the one from 21
72:20 - to 26 you attach that in front of this
72:23 - these remaining uh digits or the
72:25 - remaining uh alphabets or letters and
72:28 - you get something like this this is
72:30 - something called as the hash
72:34 - text hash text and essentially what you
72:37 - have to do now is you have to take H and
72:40 - find a uh corresponding or an equivalent
72:46 - um letter from here that will basically
72:47 - replace H okay so how do you do that
72:50 - first what you do is you find the index
72:52 - of H in the the original letters so you
72:54 - go to the original letters which is the
72:56 - original text and you find the index of
72:58 - H so it's a b c d e f g h this H this is
73:01 - H here it's the number is seven so
73:03 - that's the index of H in original
73:05 - letters which is seven and then you
73:07 - apply this formula this formula
73:08 - basically gives you the uh this this
73:12 - formula will give you the result of the
73:14 - index of the uh the
73:17 - corresponding uh alphabet that you have
73:19 - to pick up from this particular text the
73:22 - hash textt right so so you get i'll
73:24 - repeat again you get the
73:27 - um the position or the index of uh that
73:31 - number that you want to encrypt from the
73:33 - original text and then you run a formula
73:35 - and you get this is the main formula for
73:37 - cyer Cipher uh Cipher algorithm and then
73:40 - you get the position or the index of the
73:44 - uh alphabet in the hash text and that's
73:46 - the one that you want to replace this
73:48 - with so uh in the hash text right so
73:51 - firstly let's run the formula so the
73:53 - formula basically says the position in
73:55 - the original uh text of H which is 7
73:59 - plus the length of the original letters
74:00 - which is 26 and uh modulus with the
74:04 - length of the original letters which is
74:06 - again 26 and the answer that you get
74:08 - here is basically uh 7even so uh in in
74:12 - our case uh the index of H and original
74:15 - letter of seven and the index of uh uh
74:19 - the the index from the formula that we
74:21 - got by running the formula is again 7 so
74:23 - we have to look for the seventh alphabet
74:26 - in the hash text so it's like 1 2 3 4 5
74:29 - 6 and then 7 7 is B in our case right as
74:32 - you can see B so we replace H by B and
74:36 - similarly you can run e which is hello
74:38 - world right that's the text we want to
74:40 - encrypt so e you take e and then you do
74:42 - the same same thing and what you get is
74:45 - e will be replaced by Z right so Z is
74:48 - and how that happens is because in the
74:50 - original text uh e is the fifth digit
74:53 - right so when you when you run this
74:54 - formula again you'll get five here and
74:57 - when you uh go to the fifth digit here 1
75:00 - 2 3 4 5 Z is the fifth one so that's why
75:03 - you say five and now you don't even have
75:05 - to run the formula you can just get all
75:07 - the other digits very easily because L
75:09 - is the 12th right so if you go to the
75:11 - original text so L is the 12th so it's 1
75:14 - 2 3 4 5 6 7 8 9 10 11 12 L is the 12th
75:19 - and that's why in the hash text also you
75:20 - will also look at the 12th uh alphabet
75:23 - or the 12th letter so it's 5 6 7 8 9 10
75:27 - 11 12 which is in our case it's G so
75:30 - that's why both the L's have been shown
75:32 - as G out here okay then you can get the
75:35 - others also really easily and this is
75:38 - how basically this entire um algorithm
75:41 - is working now this is very predictable
75:43 - like uh if you give this to somebody and
75:45 - they figure out uh like the
75:47 - corresponding of H and E for example in
75:50 - this they can easily figure out all the
75:52 - other letters and this is a very very
75:54 - simple uh encryption to break it doesn't
75:58 - take a lot of brains to uh to break this
76:00 - encryption so that's why this is like
76:02 - the simplest simplest encryption uh that
76:03 - I wanted to show you and then you've
76:05 - seen my other videos on on the
76:06 - blockchains and how we've used Shard 256
76:09 - right to encrypt and they those uh more
76:13 - advanced algorithms have more advanced
76:15 - properties you have the Avalanche effect
76:17 - and you have uh uh what's the other term
76:20 - I'm forgetting the term it's basically
76:22 - but but the property is that
76:24 - no particular letter corresponds to
76:26 - another letter another letter right so
76:28 - that property is called something I'm
76:29 - forgetting the name right now but the
76:31 - Avalanche effect again is that if you
76:33 - change one thing in that encryption
76:35 - everything uh the complete uh signature
76:38 - changes so you have those Advanced
76:40 - properties that you get with Advanced
76:41 - algorithms you you don't have any
76:43 - properties with this is like very
76:44 - straightforward uh this this has existed
76:47 - from the time of Caesar I think that's
76:48 - why it's called Caesar Cipher it's like
76:50 - Way Beyond way before um
76:53 - the the invention of computers but it's
76:56 - a great algorithm to know it's it's
76:57 - great to get started with it encryption
76:59 - and it's a great project to build with
77:00 - goang because we'll work with uh this
77:04 - this little algorithm but we'll also get
77:06 - to apply our goang Concepts and that's
77:08 - what what will make us a better goang
77:10 - developer okay so with this out of the
77:12 - way let's get started now before we get
77:14 - started I just want to tell you that
77:16 - this particular uh video will be part of
77:19 - the 47 killer goang projects CD so I
77:22 - have this playlist on my uh channnel it
77:25 - has 47 projects in goang so in case you
77:28 - didn't know that you want to check you
77:29 - might want to check them out uh so this
77:31 - 47 will now become 48 because this video
77:33 - will will be there in that and what I'm
77:35 - trying to do is I'm trying to arrange
77:36 - these videos in the level of difficulty
77:39 - where some some of them I've not still
77:40 - not arranged them in the right order but
77:42 - I will do that and then eventually they
77:44 - will be in the right order of difficulty
77:45 - and you want to start from the beginning
77:47 - and start building projects uh one by
77:48 - one all right that's how you want to go
77:50 - about these now the next thing I want to
77:52 - tell you is is that we have this Discord
77:54 - server for my YouTube and everyone is
77:57 - allowed here and we discuss really
77:59 - awesome stuff uh like you know what
78:01 - we're learning today and we're having a
78:03 - lot of discussions so like let's say if
78:04 - you have any goang issues you can come
78:06 - here and post the issues um and we we're
78:11 - discussing about any issues about goang
78:13 - you know I I help quite a bit on this
78:15 - community so if you if you want you can
78:16 - join it all you have to do is the the
78:18 - link I think is out here so you have to
78:20 - just go here and this is I think the
78:23 - link for joining the community if you're
78:25 - not able to join it let me know I'll uh
78:28 - I'll make sure I'll send the new link
78:30 - with you okay so that's one more thing I
78:33 - want to share with you and the code for
78:36 - this particular project and all the
78:37 - other projects is on my GitHub so in
78:39 - case I don't share my GitHub link with
78:40 - you you have to know it's Akil Sharma 90
78:42 - on GitHub and you'll find almost all of
78:44 - the projects here this is the one that
78:45 - we're building today sorry not this one
78:47 - this is the one that we're building
78:48 - today simple encryption decryption with
78:50 - goang using Cesar Cipher right so the
78:52 - code is already there uh all you have to
78:54 - do is just come here and uh in case you
78:56 - get stuck you just have to refer to that
78:58 - code all right so everything is uh clear
79:00 - now now what we have to do is we have to
79:06 - um I will
79:08 - just go back to my
79:13 - um the the place where I keep all my
79:15 - goang projects and I will just create a
79:17 - new directory I'll just say go um
79:21 - encryption YT
79:24 - okay and I
79:26 - will CD into it and here we will go mod
79:32 - in
79:32 - it and I'll just github.com
79:36 - [Music]
79:38 - ail Sharma
79:40 - 90
79:42 - SLO
79:44 - encryption
79:46 - y so what this does for for us is it
79:48 - creates a go. mod file which will have
79:50 - the list of all the modules that we use
79:53 - in this particular project we're not
79:55 - using uh any third party modules I think
79:59 - mostly so you don't need to worry too
80:01 - much about it but still we'll just have
80:03 - it uh in any case here I'll just create
80:05 - the main.go
80:07 - file and this is a very small
80:09 - straightforward project there's not a
80:11 - lot of uh Engineering in this but uh
80:14 - it's it's small and straightforward like
80:16 - I said and uh it's a great project to
80:18 - build like great uh beginner level
80:21 - project to build so in my main go file
80:23 - I'll just say package main which is the
80:25 - first thing you write anyways in your
80:27 - main. go file and then I'll have some
80:31 - import related stuff right so I'll have
80:34 - I'll just write import here and
80:36 - accordingly I'll import the stuff that I
80:37 - want to import I'll have uh the main
80:41 - function obviously Funk
80:44 - Main and here is where I will Define my
80:48 - plain
80:50 - text which in my case is hello world you
80:55 - can change it
80:56 - also and then I'm going to print it out
80:59 - I'm going to print out the plain text as
81:01 - it happened in our demo also right same
81:04 - way plain text and we print we print out
81:07 - plain text then we have our
81:11 - encrypted text which is uh what we're
81:15 - going to get when we call our encrypt
81:17 - function that we will create now so
81:18 - we'll create an encrypt function it will
81:20 - take in the key in my case will be five
81:23 - and the plain text right so this means
81:26 - that here up here somewhere will be our
81:29 - encrypt function so it'll say funk
81:32 - encrypt and it will take the key which
81:34 - is the integer and the plain text sorry
81:39 - PL text which will be string and this
81:42 - will return to us the result which will
81:45 - be the string the encrypted text
81:47 - obviously right and then obviously uh
81:50 - apart from the encryption function if we
81:51 - have an inun function we also need the
81:53 - decryption function this will again take
81:56 - in the key the
82:00 - encrypted text
82:03 - and it's going to return back to result
82:06 - which is the string so once you've
82:08 - encrypted it you have this uh in this
82:11 - variable called encrypted and we will
82:15 - print it out first so we say I can do a
82:19 - print
82:20 - Len and encrypted text will be
82:26 - encrypted and then we have decrypted is
82:30 - equal
82:32 - topt five
82:35 - comma
82:41 - um and then we'll print it
82:48 - out
82:51 - decrypted
82:53 - come on
82:55 - decrypt so to the decrypted decrypt
82:58 - function you are passing the key and the
82:59 - encrypted text and you'll get that in
83:01 - the decrypted uh variable and then we'll
83:04 - just print that out so that's it that's
83:06 - all our Funk name is doing okay at the
83:10 - top I will say my
83:14 - original letter will have all the 26 a b
83:18 - c d e f g h j k l m n p q r s t u v x y
83:26 - z
83:29 - okay so original will have all of this
83:32 - original letter basically
83:34 - means this the original text this has
83:37 - all of the uh letters this is the plain
83:40 - text and this is the key five which
83:41 - we've passed okay now we want the hash
83:44 - text so for the hash text we need
83:47 - another function let's call
83:48 - it frun hash letter
83:55 - function takes in the key takes in the
83:59 - uh original letter it'll take in the
84:01 - original letter and we'll say result and
84:06 - string okay now here the first function
84:10 - that's called is the encrypt function so
84:12 - we'll start building upon the encrypt
84:18 - function so as you remember in the
84:20 - encryption part the first thing we do is
84:22 - is we first want this right and then
84:26 - we'll find the index of H the first
84:28 - letter we'll start we'll start letter by
84:30 - letter the first letter which is H we'll
84:32 - find the position of H in the original
84:34 - text but we also want this right you
84:37 - want the hash text because after we run
84:39 - our formula we want to find the uh that
84:42 - particular index what's the value at
84:44 - that index in our hash
84:47 - text so that's why we need this also
84:49 - first so well we'll call the hash letter
84:53 - function so we'll say
84:54 - hash letter function we'll pass it the
84:59 - key and the original letter original
85:02 - letter being
85:03 - this we'll just pass it
85:08 - there and to start with we'll say V hash
85:12 - string isal to empty now hash string is
85:16 - what you want to return from here so
85:18 - there this result that we sending back
85:19 - is the hash string and one by one you
85:22 - will keep adding to this uh empty string
85:25 - some values so for example for H the
85:28 - first value in our case as you saw here
85:31 - uh we'll get C right so whatever we get
85:33 - here C and z and G so one by when we'll
85:36 - keep adding values to it we'll run
85:38 - things through a loop and we'll keep
85:40 - appending things to this hash string uh
85:43 - and that's why first we'll start with
85:44 - this being empty and then we will run
85:49 - um actually at the end here we will will
85:52 - have this function called strings. map
85:55 - and we say find one comma plane text so
86:01 - strings. map what this does is it takes
86:03 - in uh the plane text
86:07 - okay in our case the plain text is
86:09 - actually hello world so it takes in
86:11 - hello world and one by one it'll send it
86:14 - and call this function called find one
86:16 - so it'll take uh H first and then e e
86:19 - next L lse we'll take all these things
86:21 - one by one strings. and then call the
86:23 - find one uh you know function so what is
86:29 - find one so find
86:32 - one is equal to a function it's a
86:37 - function which takes in r as a rune and
86:41 - returns a rune now what does that mean
86:44 - so
86:45 - Rune help so runes basically help you um
86:49 - with unicodes so what we're saying here
86:51 - is that um a run represents a single uni
86:54 - code character okay so for example a the
86:58 - value of a is 65 so you get the ask2
87:00 - value and now you can uh work with the
87:04 - letters in a much more flexible way so
87:06 - you get separation between all these
87:08 - letters so for example A B C D E F
87:11 - because you're sending them one by one
87:12 - but then with run you're able to work
87:14 - with them in like much more easily uh
87:17 - because
87:19 - here what we have not covered is is that
87:23 - the runes that you'll
87:25 - get here also you'll use Rune to be able
87:29 - to work with that so we'll be using run
87:31 - basically all throughout to be able to
87:34 - uh iterate over all these letters and
87:36 - work with those letters uh and then
87:38 - perform operations on that so it'll take
87:41 - in our run so for each uh letter like H
87:47 - we take each letter from the pr text
87:50 - which is like the hello world right so H
87:52 - we take that and we send it to find one
87:55 - and then what the find one function is
87:56 - doing is it's taking in that H and
87:59 - returning us to us the equivalent letter
88:02 - uh in the in the encrypted text so in
88:04 - our case it will be C now how do we get
88:07 - from H to C let's take a
88:10 - look so uh first I think I'll just build
88:13 - the hash letter function because
88:14 - otherwise there will be just confusions
88:15 - because you know I wanted to explain the
88:17 - Run Part before we wrote Rune here
88:20 - because we using it in the hash function
88:22 - so I didn't do that uh my bad but I
88:25 - think I'll just build this function
88:26 - before we work more on the encrypt
88:27 - function so that it just makes more
88:30 - sense so this hash letter function right
88:33 - all it's supposed to do is it's supposed
88:34 - to um take in this key and then divide
88:39 - this into from a to Zu and from V to Z
88:42 - divide uh the original text into these
88:45 - two parts and then also put this in
88:47 - front of this and then return that part
88:49 - that's so we want to return the hash
88:51 - text from this function so we'll say
88:53 - last
88:55 - letter key equal to
89:00 - string
89:01 - runes length of letter letter being
89:06 - original letter in our case so from here
89:07 - to here the length is obviously 26 so
89:10 - we'll say length of letter minus key to
89:14 - length of letter so this is Runes
89:18 - of 21 is to 26 so from 21 to 26 what are
89:23 - the things which is in our case v sorry
89:27 - 2126 v
89:29 - w now x y z so these five things will
89:35 - basically come in the last letter key
89:38 - and then we'll say the left over letters
89:41 - left left
89:44 - over letters letter is equal
89:50 - to
89:52 - string
89:58 - runes and
90:02 - zero length of
90:06 - letter
90:10 - minus okay so 0 to 21 so this is length
90:14 - of letter which is 26 minus ke which is
90:17 - key is 5 so it becomes 21 so 0 to 21
90:20 - will come in
90:22 - uh one place like I said and 21 to 26
90:25 - will come in another place so this has 0
90:27 - to 21 and this has 21 to 26 so last
90:30 - letter three and the left over letters
90:32 - now all we have to do is we have to
90:35 - return I told you right we'll return
90:39 - This plus this so we'll return the uh
90:42 - last
90:43 - letter and followed by the leftover
90:46 - letters so let's do that so we'll say
90:49 - FMP
90:50 - Dot
90:52 - Sprint
90:55 - F here let's say percentage s and
90:58 - percentage
91:04 - s comma last
91:07 - letter two comma left
91:12 - over
91:14 - letters so we able to return what we
91:17 - promised from this function which is the
91:18 - string which is the hashed uh
91:23 - the hash text from this
91:25 - function so in the encrypt function we
91:27 - were now in the find one function and
91:31 - here we will first start with the
91:36 - positional strings. index why the
91:39 - position uh if you remember I had told
91:43 - you that what we'll do is we'll find the
91:45 - index of H or the position of H and the
91:47 - original letters That's How we'll get
91:48 - seven right so this is the original text
91:51 - and we have to Now find the index of H
91:53 - there since strings. index and the
91:56 - original letter comma string and that
92:00 - there will be uh
92:02 - run
92:05 - R and now we'll get the position of that
92:07 - letter now uh if what if the original
92:10 - text that we passed original letter text
92:12 - that we passed somehow we forgot to
92:15 - write there was a type of we forgot to
92:16 - write H
92:17 - there right then Position will basically
92:21 - become min-1 and that's what we want to
92:23 - check for so we want to check if
92:24 - position is not equal to minus1 that
92:26 - means the letter that you want to
92:28 - encrypt is actually existing in the
92:30 - original letter you want to find the
92:32 - position if it's not equal to minus one
92:34 - then we can do something about it
92:35 - otherwise it's a problem right other you
92:38 - just want to return the same thing
92:40 - return
92:41 - R um and finally from here we want to
92:45 - return the hashed string as you know
92:49 - hash string which is now empty we want
92:50 - want to fill it up so if everything is
92:52 - all right and it's not uh minus one then
92:54 - we'll say
92:57 - letter
92:59 - position is equal
93:02 - to position plus
93:10 - length original
93:13 - letter percentage length of orig
93:19 - letter and hash
93:22 - string
93:25 - Hash Hash
93:27 - string plus
93:30 - string hash
93:33 - letter letter position okay so what's
93:35 - happening here
93:36 - is we first find the position and then
93:40 - we uh run our modulus function so if you
93:42 - remember I told you the function or the
93:44 - formula looks something like this where
93:46 - we add the position plus the length of
93:49 - the original letters and we mod we run
93:51 - mod modul which is length of position
93:53 - dat so in our case be 7 + 26 modulus of
93:56 - 26 you get 7 right so that's what we're
94:00 - doing here so you get the letter of the
94:02 - position uh which is seven and now the
94:04 - next step would be to look for that uh
94:06 - letter which is at the seventh position
94:08 - in the hashed text and that's what we're
94:10 - doing
94:11 - so we're looking in the hash letter that
94:14 - we have hash letter hash text we passing
94:18 - this letter position and getting that
94:20 - particular value converting into string
94:22 - and adding that to Hash string so each
94:25 - each of these values from the plain text
94:28 - one by one because of the help of
94:30 - strings. map one by one we'll take it
94:32 - like H and e and l and O and then we'll
94:35 - pass it to find one find one is
94:37 - accepting it as a rune and also
94:38 - returning a rune in our case and then
94:41 - it's
94:43 - um adding everything to hashed string
94:46 - that's what's happening adding
94:48 - everything to Hash
94:50 - string finally we'll have as string that
94:53 - that's what we'll return from this
94:54 - function okay now the decrypt function
94:57 - is going to be the exact opposite of
94:59 - this the decrypt function is going to
95:01 - basically um have
95:05 - same method which is calling the hash
95:08 - letter
95:09 - function and we'll capture that value in
95:14 - a variable
95:17 - called hash letter so the hash function
95:20 - will pass the key and the original
95:24 - letter and again you'll start with the
95:28 - hash string which is
95:31 - entty so with the with the
95:34 - decryption we have to uh find
95:39 - again you know that value in the
95:45 - um in the hash letter index so let's so
95:48 - this is what we'll start with okay in
95:49 - the beginning and we we'll find the
95:53 - value of let's say
95:56 - C so in in the in the encryption we
95:59 - started with the original text now we'll
96:00 - start with the hash text so let me write
96:04 - it here this is
96:07 - decryption
96:12 - sorry you start with the hash text and
96:16 - you see that the uh hge right is of
96:20 - particular value
96:23 - and
96:27 - um and this is the original text
96:31 - here yeah so like I was saying this will
96:34 - happen before so we'll first check the
96:37 - value of that uh you know letter here
96:41 - let's say in our case C right so we'll
96:43 - notice the value is 5 6 7 uh 8 1 2 3 4 5
96:48 - 6 7 8 so this will be eight in our case
96:50 - right and then then that eight we have
96:52 - to find in the uh in the hashed text
96:56 - sorry the sorry in the in the original
96:59 - text so the original text is different
97:01 - right
97:03 - it's so decryption will exactly be the
97:06 - opposite of encryption so an encryption
97:09 - we first found the position of the value
97:11 - in the original text and then found an
97:13 - equivalent in the hash text and
97:15 - decryption will be completely opposite
97:17 - we'll first find the position of that
97:19 - particular um
97:21 - so C for example we'll first find the
97:24 - value of that letter in our hash text in
97:27 - this case C and then with that position
97:29 - we'll run that formula again and we'll
97:32 - get some value and then that value we
97:33 - have to pick from the original text and
97:35 - that's how we'll get back uh hello world
97:38 - from this text so that's the entire
97:42 - method that we have to follow now okay
97:44 - so let's do that so for encryption for
97:46 - decryption we say hash string is
97:49 - completely empty and then we say find
97:51 - find
97:52 - one and who's going to call find one
97:55 - um out here we'll just say strings.
97:59 - maap find one comma encrypted
98:04 - text and
98:07 - return hash Str right so the other thing
98:11 - that's changing here is that with uh
98:13 - with encrypt we sent the plain text to
98:15 - our find one but in decryption uh we're
98:17 - passing the encrypted text to our find
98:19 - one function and then find the F final
98:21 - function we'll say funk R Rune and Rune
98:26 - okay so that that was one change which
98:27 - is passing plain text versus passing
98:28 - enry text the other change which I was
98:30 - showing you in the diagram was that we
98:33 - will find the position of the uh of the
98:39 - the the word in this hashed letters so
98:43 - earlier we found it in the original
98:44 - letters right the first position now
98:46 - we'll find it in the hash letter and
98:48 - we'll say
98:50 - string
98:51 - run
99:04 - R and again we'll check for the same
99:06 - thing position uh is not equal to minus
99:10 - one check for the same
99:14 - thing from here we'll go
99:17 - R yeah this if you remember we checking
99:20 - because that that uh particular value
99:22 - that's coming in here needs to be there
99:24 - in the hashed text right so not the
99:26 - original letter in this case is the hash
99:28 - letter so it has to be there in the hash
99:29 - letter the position otherwise will be
99:31 - one minus one so only if it's not minus
99:33 - one we can uh proceed and this is how
99:36 - we'll proceed so we'll say
99:38 - letter
99:39 - [Music]
99:40 - position equal to You'll again apply the
99:44 - formula plus length of original
99:50 - letter
99:53 - percentage length
99:55 - of original
99:58 - letter which is mod modular and then
100:02 - origal letter and we'll say hashed
100:05 - string equal to Hash
100:08 - string plus string and original
100:14 - letter letter
100:17 - sorry letter
100:19 - position
100:32 - forgot the return are
100:36 - here
100:39 - okay right so uh main main differences
100:42 - in decrypt and encrypt is like I said
100:44 - we're passing the encrypted text here
100:46 - we're passing the plane text there and
100:49 - here we check cheing for the position in
100:52 - the hash letter hash letter being this
100:55 - one and here uh in the encryption we
100:58 - were checking for the letter position
101:00 - the original original text original
101:02 - letter here for finding the letter
101:04 - position formula we again we use the
101:06 - length of original letter only that's
101:08 - not that's not different that's the same
101:09 - thing and finding the hash string
101:13 - finally at the end we found here from
101:16 - the the hash letter we found the
101:18 - equivalent text and now to Crypt it back
101:21 - we finding it from the original letter
101:23 - the equivalent uh you know letter so
101:26 - here we'll get the back to decrypt
101:28 - decrypted
101:31 - text now uh I don't see any issues and
101:35 - or any errors here in the in the code so
101:37 - what I'll do is I'll just go here and
101:39 - I'll just say go run main. for so if
101:42 - there are any errors we'll get them here
101:44 - but there were not any errors luckily so
101:46 - we had our PL text we got the encrypted
101:49 - text and we got the decrypted text okay
101:51 - so I'll just quickly go over it again in
101:53 - case you missed anything uh we started
101:56 - with our plain
101:57 - text we uh got the encrypted
102:00 - text which is this we sent it to the
102:03 - decryption function got the decrypted
102:04 - text started with Hello World text we
102:06 - want to replace each single letter uh
102:09 - with with different alphabet the key
102:13 - that we passed was five and the original
102:14 - text we pass was this so this can have
102:16 - numbers this can have small characters
102:18 - also this can have special characters
102:20 - also
102:21 - and when we pass the key as five we run
102:24 - this through the original text through a
102:26 - hash hash function which basically
102:29 - subtracts five from the length of the
102:31 - original text so we get 21 so we divide
102:34 - the original text into two different
102:35 - parts one is from 0 to 21 and from 21 to
102:37 - 26 then we pass the hash text back so
102:40 - which is this uh before the uh before
102:43 - this text and we pass this back to the
102:46 - function in the encryption function the
102:48 - first thing we do is we find the index
102:50 - of the first letter which is H in the
102:54 - original uh text so in this case we get
102:57 - seven now we run our formula which is
102:59 - position plus length of original letters
103:02 - percentage or modul length of original
103:04 - letters and then we get again uh 7even
103:07 - and we find seven in the hashed text
103:11 - because we want to convert from original
103:12 - to the hash or the enry encrypted we'll
103:15 - find an or uh like a like a
103:17 - corresponding uh digit or letter from
103:20 - here
103:21 - and B so we found that H is equal to B
103:25 - Because B is on the seventh position
103:27 - after we ran this formula and that's how
103:29 - from Hello World we actually got this in
103:31 - this description it works the completely
103:33 - opposite because you find the position
103:35 - of
103:36 - C
103:39 - in first in the hash text and then we
103:43 - get that position and then we basically
103:45 - run it through the formula and then we
103:47 - get the original uh text
103:51 - sorry and and yeah and we get the
103:52 - position in the original text of that
103:54 - corresponding letter in this case it
103:56 - will be H now guys uh there's one thing
103:59 - that I have uh you know made a small
104:02 - mistake in right and I want you to to uh
104:05 - find that out in case you haven't
104:07 - figured out in the whole program one
104:10 - thing that I've been missing or and
104:11 - messing up with uh just so so that you
104:14 - know uh in case youve understood it
104:16 - please let me know where I've made that
104:18 - mistake uh there'll be basically ensure
104:21 - so if you if you go through the video
104:23 - again look for the mistake things will
104:25 - become much clearer to you and you'll be
104:27 - able to um completely understand this
104:30 - concept right so let me know if you
104:33 - found that
104:35 - mistake uh I'm going to tell you the
104:37 - answer anyways if if in case if you have
104:39 - not found it so the mistake is that the
104:42 - value uh the actual position of H is not
104:45 - seven it's 1 2 3 4 5 6 7 8 it's actually
104:49 - eight not seven
104:51 - so that's why you have to write here
104:53 - eight and you have to write
104:55 - here8 you have to write here
104:58 - eight then have write here
105:02 - 8 and should have in C right H should be
105:05 - equal to C and not
105:08 - b and that's how you get C right here
105:11 - right so I made that
105:13 - mistake um and now you can actually go
105:16 - and run the actual values and you'll see
105:18 - everything is consistent all right so
105:20 - that's
105:21 - perfect I hope you were paying attention
105:23 - now when you looked at the mistake uh
105:26 - everything will make
105:28 - sense right so
105:32 - um so what I want you to do is I want
105:34 - you to uh run through uh the entire code
105:38 - once again and run through those values
105:40 - once again so that you basically
105:42 - internalize whatever I've taught you uh
105:45 - try try to put different values here
105:47 - like smaller text and then special text
105:49 - characters all of that try and and see
105:53 - uh how that works and thank you so much
105:55 - for watching this video uh I hope you
105:58 - will join our community on Discord where
106:00 - we'll get to hang out and you'll watch
106:03 - all the other videos in this
106:06 - um in the uh in the in the goang
106:08 - playlist all right so thank you so much
106:10 - and I'll see you in the next video

Cleaned transcript:

improve your go programming skills by developing three different projects in this go course experience developer Akil Sharma will teach you how to build a website Health Checker a program to encrypt text and a program to encrypt files hey guys in this video we're building three awesome projects with goang now these are beginner friendly projects and awesome additions to your portfolio in case you're applying for a goang job in the first project we're going to be building a goang health Checker where we'll check the health of a website so you'll just have to enter the domain name of a website and you'll come to know if it's live or it's down the second project is about encrypting files so we'll start with the PNG file and we'll encrypt it we'll try to access it without the password and then we'll access it with the password to see how encryption works the third project is about encrypting a string with goang so all these three projects you learn quite a bit a lot of goang so if you have basic goang skills you'll be able to refine your skills and build on top of that not knowledge so let's get started hey guys welcome back in today's video we're building a very simple project we're going to build a goang project which checks if a website is running or it's down and accordingly we'll show the appropriate message in the terminal saying the website is up or running or it's down or not running right and you'll find these kind of projects uh very easily on Google if you go and if you check if the is the website on there many projects like these and they basically run it free of cost but then they show ads so if you want to do that you can do that as well but it's just a great project to build and to basically practice your goang skills right uh now this project is going to be a part of the uh goang playlist goang Project Playlist so in my YouTube If you go to the playlist there's a goang playlist it right now it has 46 projects so I have called it the 46 killer goang projects playlist but then the number keeps Chang changing so once I put this video it'll be like 47 goang projects right so depending on when you watch this video the number would have changed but then you know it's important to know that that playlist exists and you can and what I'm trying to do is I'm trying to arrange those projects in the increasing level of difficulty and this project since it's very small and very simple we'll place it towards the beginning of that playlist even though I'm releasing it quite at the end but I'm going to actually position it towards the beginning of of the playlist okay so with that out of the way we can get started I'll show you a couple of diagrams just to help you visualize what your building uh and then we'll just go ahead and build it all right now just before we get started I just want to tell you that a very common name for this project that we're building is called the health Checker right so for any project that you're building you might also want to create a health Checker microservice in case you don't want to launch this as your own project on the internet completely fine uh but you can but usually when people build let's say a project and then they usually build a microservice which checks health of their own project so with with the project that we building you could do that like check the health of your own project or you could check the health of any website that's up or down you can check that state status of that website all right now we can get started so now I think you can see my screen here uh we've just represented what we'll be doing in our code so we'll have a main.go file which will have the main function and all we doing is importing the CLI package so it could be any CLI package like you could be using something like uh Cobra or something like that but I'll be using something very small and basic in this project because this project is small right and um we'll be passing two things we'll be making use of two things one is Flags so we'll set two flags which is the domain and the port and the action for the CLI tool tool would be to call the check function okay the check function is is going to be defined in a file called check. go it's going to accept destination and Port because that's what we'll send from here to this function destination and port and the whole business logic here or the Crux of the entire program is the dial timeout function this function you get in this package called net the net package very popular package to work with uh web web related things in goang right so we'll use D dial time out package and finally we will return the status of the website whether it's up or down so that's the entire business logic here in the in the project so now let's go ahead create a new project and get started all right so now we'll start building our project everything that I'll be showing you in this video is already there in my GitHub account so make sure you check out Akil Sharma 90 which is my username on GitHub all the projects are there check out the code in case you get stuck somewhere we just create a new directory called go health check YT so we'll CD into it and what we'll do is we will um go mod in it and I'll just give it my username go health check right okay so now you can see the go mod file already has been created and we will just open up our vs fold and check out that yeah everything looks all right now I have decided upon the uh package that I'll be using it's CLI version two and I found it on this uh project on this profile called yourf This is a common package it's very very light so if you're not building something huge like a proper CI tool I recommend using something like this something very light like this there thousands of packages like these by the way but if you're building something serious then obviously Cobra CLI is is the way to go anyways now we'll create two files as you know one is the main.go file and the other is our check. go file okay in the main. go file we will do the regular stuff package name import the import statements and all of that and in the import I want to put this package so that it's clear that we're going to use it and then you have your fun main that's how you start that's the most important part in your main main. go file obviously and I'm going to go ahead and create an uh create app which is basically C.A right CLI being the package that I'm using and this helps to create a complete CLI tool where I can give it a name I can show how the tool is used I can give in the flags we've already talked about the flags and I can talk about the action it's supposed to have happen when the you know the right commands are or the right yeah the right commands are given what's the action that's supposed to happen all right so yeah now for for the name what we'll say is we'll say let's call it health checker and the usage let's usage basically basic text of how this product is going to be useful say tiny tool that checks whether a website is running or it's down and then there are the flags so CLI do flag okay and here you have the name which is domain aliases string D and the usage which is the this is where you'll enter the domain name like for example google.com that's the domain name to check whether it's up or down so that's domain and it's obviously it's required so we say required is true without this there's no point of the app if if you don't have this right all right so uh in the flags there's one more flag that we going to have which is the c. string flag it's going to be name will be Port Al s's string B Visage port number to check and required false right now for the action you're going to have c. context and we might return an error and let's define the port which is C do string and the port and if c. string and Port is null which is empty then the port will be 80 right so what's happening here which is standard basically whenever you check anything you're checking on Port 80 which is like the most common Port right where the uh the hand check would happen anyways but let's say um you but you can you can say any port you can mention any port here but if you have not mentioned any port here the default Port which is 80 which is the one that that's always checked that's the one that will be um set right for the port variable and then you have status is equal to check so this is the check function I was talking about which which we will create in the other file called the check.of file and you are checking the domain and the port so we sending two things to the check function which is domain and the port which is what I had shown you in the diagram and we're going to print the status and return ma for the error if everything go well here we'll say error equal to app. run okay so you say app which you just created the whole app using the CLI uh package and you're going to say app.run passing in the OS arguments and you're also handling the error so if there is an error you can do something about it if the error is not equal to n that means the error is there it's say log dot fatal and you'll print out the error all right and now we can work on the other file which is check. go so now we're going to go ahead and create the check. go file before that what I'll do is I'll just say go mod Ty just to create the go s file there seems to be some problem we'll fix fix it no problem so right now let's just create the check. go file okay so say package main also this part of package main only not creating a separate package and here uh there are a few more packages that I've used actually like fmt and all those and somehow they've not come up so usually when I save the files they come up like my plugins are not working I think right now I'll just copy and paste them on my own anyways all right so here also I'll need some packages I'll just say fmt time and net the most important one obviously here is the net package you know that because the net package has the um dial timeout function that we'll use to actually check the status of the website so we'll say fun check destination it's a string and Port which is a string and return the string string being the status so we return the status from the check function so here we'll say address equal to destination Plus Port right destination being the domain name and Port being the port that you pass in or or even um Port 80 which is the default right so we'll say for the duration of 5 Seconds is a time out so within 5 seconds if you get a response back from the website that means the website is on otherwise it's not okay this is the main part which is we're using the net package and the dial timeout function we need to send in the address which is basically the destination the port both combined with the timeout which is 5 seconds in our case and let's create a variable called status which is the one that we're going to return from this function and here this error that we have which is we're checking we'll have to now check for that error so we'll say if error is not equal to nil means there is some error then we'll say status would be fmt dot Sprint F down website is not reachable so to print out the name of the website star V sorry percentage V is unreachable the website is not reachable and you can print out the error for percentage three and here the actual variables which is destination and the error all right else we will say status we FMP do printf and we say up percentage V that's the basically the website is reachable and then we'll print out from which address we tried to which address that means the destination comma connection dot local address right so your connection variable will have a copy of local address the address at your end which is making the conect the the request and the remote address basically the website and the port that you had mentioned just above and finally when your the status okay so all okay here I think to get rid of the error just remove this quickly and let goang do it for you so just say go mod tid it'll get all the packages right that you're supposed to have and it'll also generate the go. sum file for you here in the main. go file there's an issue because there's a small spelling mistake it should have been adss and uh but I see one more error so me quickly check yeah the other thing is that there's another spelling mistake here it's CLI all right so hopefully everything should be fine now but I still see one more error all right so uh yeah that's one more issue which is spelling of name is wrong I'll just save it everything seems fine now to me uh here so by flag you know what you mean by flag is that when we run this uh tool now we'll have to pass the flag so let me actually show you how to do it so we'll say go run do minus minus domain which which is the flag now in our case and it could be tel.com so it's saying it's reachable right so if you say google.com and amazon.com yeah so all the websites are up at the moment all of them are reachable all right so that was our simple yet effective tool that we've built and we've done we've done quite a bit in this tutorial uh it's a very very tiny tool but then a lot of Concepts have been used here so I hope you've learned quite a bit thank you so much for watching do make sure you watch all the other projects in this series because there so much to learn right and thank you so much for watching and do subscribe hey hey hey in today's video we are encrypting files with goang so in my root directory of this project I have the img.png file which I'm going to now encrypt so as you can see I can I can see the file now right but if I encrypt it so I'll say go run encrypt uh and I'll say img.png which is the name of the file I want to encrypt and I'll enter some password it'll confirm the password and it'll encrypt it for me and say it'll say file successfully protected and now as you can see I can't see it anymore I can't see the file anymore but now if I go and if I just decrypt the same file it will ask me to enter the password it will say file successfully decrypted and now again sorry now again I can see the image awesome right so how is this happening so let me let me take you through it so in the beginning what will happen is we will accept the um r arguments from user which is uh the basically the file the path to the file or the file name we'll validate if the file even exists or not and we'll also ask the user for the password and we'll validate the password in the sense if both the passwords match this is for the encryption part right we'll check if both the passwords match password one and password two then we'll encrypt the file and then for decrypt we'll again check the password after getting the password we check the password okay so it's really straightforward for for from a 10,000 ft perspective this is what's happening just getting arguments from the user validating the file getting the password from the user and cing the file by validating the password and then decrypting the file with the same password that's what's happening but if you look uh more if you look a bit deeper then you have two parts encryption and decryption in the encryption part uh we follow multiple steps so we first check for the source file we open that source file the one with the plain text which was our img.png and and then we'll re read that plain text now it could be the data from the PNG or it could be a text file right whatever it is it's basically plain data from the source file then we'll create an empty uh variable called a nuns this will be 12 bits or 12 bytes in our in our case and we'll create we'll randomize it so we'll create a random basically 12 byte uh variable we because we want to use it later on so firstly you have the password that we'll use to encrypt the file right so the the password and then there's something called as the length in the sense what do you want to get after running a derivation function so we'll basically be running a password based derivation function I'll talk more about it the first thing you need is a password the next thing you need is the bip length in our case will be 32 then the algorithm with which we want to encrypt it and the number of iterations in our case it will be like some somewhere around 4,000 iterations iterations basically make it more difficult for the party that wants to uh hack this or or break the encryption just makes it more difficult for them okay okay so uh with the password based key derivation function this is a function in which a key will be generated from the password so we'll take in the password and we'll add in a few different things as you can see and we'll get a key and this can be used as an encryption key or the hash value so we basically just hashing the password now this is very similar to how you um take the users's password you hash it and then you store in the database right because you don't want to store the passwords directly in the database because otherwise people can steal or get access to the database steal all the password right so you always hash the passwords with some salt and that's what's happening here right so uh this is the salt in this case the nuns so with the password based key dation function you get something called as a derived key now the derived key we'll run it past uh AES or Advanced encryption standard this will give us some solid encryption abilities after after getting the key from the password and we'll and this by by running it through the a a cipher we'll get something called as a cyer for block and that again we'll run from uh through something called as the uh galwa counter mode now this is spelled as g l o i s but I think this is like a French word so you say gal galwa or something like that I'm not French so I have no idea so it's the GCM I call it the GCM galwa cter whatever blah blah blah but GCM basically right and GCM gives you more encryption with data Integrity checks now GCM generates a tag which is appended to the C Cipher text at the end and this tag is used to verify the Integrity upon data encryption now you had some data you encrypted it but then how do you know that the data that you got back is actually the correct data and that's why we using GCM because that gives us the tag to verify the Integrity of of the data upon decryption and GCM uses AES so we as as you know we have already used AES before it uses AES to encrypt the plain text this operates in a counter mode and hence the name and and generates a stream of encrypted blocks that's what GCM does finally we use this uh function called AES GCM which AES GCM is what you get so you already had the AES Cipher which is the ciper block then you run it through GCM you get AES GCM and you run this function called AES GCM do seal this is the main function now this is uh just to use this function we had to do all of this basically all of this part because we wanted to run this function called the seal function and the seal function is what takes the plain text from our file from our IMG file or any other file and convert it into Cipher text and it then creates a source file for encrypted data and we write Cipher text to the new source file so the the file in our case Remains the Same but then again we have to create the source file for the incryptor and write the cipher text Cipher text is basically text that we can't then access right so that'll be written to the source file so that's the encryption now let's go over the decryption for the decryption it's very very similar uh we'll check for the encrypted file so here we were checking for the source file that had to be encrypted and now we'll be checking for the encrypted file because uh to our program we will be saying that hey this is the encrypted file please decrypt it for me so we'll check for the encrypted file we'll open that file we'll read the cipher text from the enced file right the text that we can't open in our IDE but it still can be read from our function now to convert the cipher text into uh regular plane text we have to again run the password based key activation function so we'll have to have the same password which we used to enp we you have to have the same password to decrypt uh decrypt it as well same bite length same algorithm sh one and the number of itation should also be the same and then the nuns uh as you remember we created a nuns here a randomized nuns and uh the the GCM basically uh appended the nuns to the cipher text and exactly that's what we want we want to get the nuns from here uh which will be at the end so the the last 12 digits of the encrypted file will have the nuns you want access to that so all of these uh five things we'll pass to the password based key derivation function we'll get the derived key again the same thing as Cipher we'll get the cipher block GCM you'll get a GCM now we did again we did all of this so this was important obviously you know that you have to use SOL to Hash the password this is perfect but these extra steps we only did because we wanted to use this aesg cm. openen function which takes in the cipher text to this function without the NS obviously and gets you back the plain text now the pl text is what you will write again to a file which will have the decrypted data or the other PL text and that's the one that you will write back to the file and that's how you'll be able to read the file again so that's what's happening in your encryption and decryption so in our program in the code what we'll need to have is we'll need to um do all of this like the whole entire Logic for the encrypt function and the entire Logic for the decryption function and I'll keep opening this diagram again and again in between just so that we able to refer it while we are writing the code but the program also needs to do all of this so we'll the way I'm thinking of it is that I'll need one file which will have the encryption decryption functions and I'll need one file which is the main.go file which will will have all of this thing which will print out stuff to the terminal and accept uh values from the user from the terminal so all of that logic I'll put in main.go file okay so now we can start writing our code now before we start writing our code just want to tell you that um on my channel this particular video that we creating right now will show up in the 48 killer goang project Series so this is a playlist which basically is uh which has 48 projects now but I'll add this one so it'll be 49 projects and um this playlist right is in the order of difficulty so we have smaller uh simpler programs earlier and then more difficult programs later on this will be somewhere in the middle it's not or somewhere towards the end but not at the complete end because this is not very difficult to build what we building today today uh so um just make sure you you go through all the videos in this playlist and you build them one by one and once you've done that you will no goang better than more better than 90% of the people or 99% of the people actually out there because I mean uh how many people do you know who build like 50 50 projects with goang right not many so this will seriously give you an edge if you build all the projects in this playlist all right and and uh I also wanted to tell you one more thing that if you go to my channel uh you get access to this Discord link here as you can see this is the Discord link for this community out here which is uh where we discuss a lot of stuff around golang and we share our learnings what we've been learning today uh we have a lot of um like forums where we uh discuss issues uh that we that you're facing blah blah blah so lot lot of stuff here so uh a lot of cool discussions happening so make sure sure you join this because uh I mean if you want to learn if you want to learn goang this is the right place to be this is the right Community to be at all right because I'm here quite a lot as you can see it's always open on my browser these days so I'm always there replying to messages all right so uh I have now talked through all the things that I wanted to talk through so now is the time to start building the project what I'll now do is I'll create a new uh directory called go file encryption by the way this program this project already exists on my GitHub so in case uh you are are already following me on GitHub uh you will see this program there the F encryption one um in case I don't put the link to this project in my description of this video please know that my GitHub is Akil Sharma 90 ail s RMA 90 the project is there in case you get stuck somewhere um you can access the code you can look at the code and build along with me all right so here I will CD into it I will CD into go file encryption and we will say go mod in it github.com sharma9 SL code file encryption this creates a um go. mod file for us which will have the list of all our dependencies and I'll just go ahead and open this up in my code infl here I'll just create a um main.go file and I'll create a folder for file Crypt and there will be a file called filecrypt okay now I told you that I'll divide the logic into two different parts one will be the uh interfacing with the user part and the other will be the actual encryption and decryption so let's talk about the part where we'll accept user values so we first start with sorry package main not M we start with package main all right and there will obviously be Funk main which is from so main is the most important file main. go is the most important file which is obviously the main package again and then it has the main function which is where the uh program begins from or Origins everything starts from here and then this is why from this function we have to call all the other functions this is like the root or the source of everything then there will be an import statement here and I'll import multiple um packages in a while so firstly I want to check if the length of the arguments now to to work with arguments to print out messages to the CLI we could use something like Cobra which is a CLI tool and I have and I already have uh projects with that I think uh that's very commonly used in goang as you know Cobra uh we're not using it here because we have like very few operations and we can do that uh on our own we don't need to import a complete Library just to print out stuff to the terminal and to work with some arguments right and uh here we're just checking of the length of the arguments is less than two if it is less than two then we'll print help and print help will basically print out uh so there's a function called print help it's print help which basically tells the user and how to actually use this uh project so if he's not if the user user is not uh entering let's say encrypt or decrypt and the name of the file that means it doesn't know how to use this function right so you'll just print help out in that scenario and the other thing is function equal to OS do ARS one and we'll switch function so what do you want to do so do you want help if you want help we'll just print help we'll just call the print help function if you want to encrypt we will call the encrypt handle function if you want to decrypt you will call the decrypt handle function and then there is a default which is run encrypt to encrypt a file and TP to TP right just telling the user that hey please run encrypt to encrypt the file and decrypt to decrypt the file okay so that is our main function now as you know we're calling three functions from the main function which is the print help encrypt handle and decrypt handle so we're going to call we create all those functions uh so we have the we'll have the encrypt handle function and we have the decrypt hand function there are three more functions that we'll need in the encrypt handle there is the um get password to get the password from the user and then we have the validate uh so we have the get password function we have the validate file and validate password functions so let me create those password and frun validate validate file okay so and the print help print help is going to be very straightforward so I'll just go ahead and copy and paste actually don't have to write this whole thing on your own so this is basically saying file encryption simple file encryption for your daytoday needs uh which is the name of the program and then what it does and then showing you usage that you can go run and uh when we say dot basically means it runs all the files in uh at the root which is our main.go and also our file. cp. go uh folder package and it'll basically uh you want to pass the path to your file in our case we'll just say img.png which will be a file that I'll copy and paste here you can copy and paste any file here I'm just using this apple file here and then you have the commands the commands like encrypt decrypt and help you'll have three commands encrypt will encrypt a file with a given password decrypt tries to decp a file using a password and help which displays the help text which is uh this particular function gets called there now for the encrypt handle which is the most important one uh sorry the encrypt and decrypt actually are both uh really important because that's the logic main logic so here we'll check if OS do if the length of os. ARS is less than three that means uh you have written you have written that uh you want to run the program and you want to encrypt but you've not passed the uh the pass the file right so it's argument sesson three then you will print Ln you will print out missing the part to five for more info run um so encrypt we say from the help command all right and os. exit Z if everything is all right then what you want to do is you want to get the arguments or which is basically the uh arguments at the second index which is the third argument uh which in our case is the part of the file you want to get it in this variable called file and you want to Val validate so if not validate file and you pass the file there and we'll just Panic file not found so what happens in the validate file function and this gets called it basically it takes in the file which is string and it passes back Boolean which is that's how we checking it it here you know true or false this exclamation helps us check that so if it's not uh valid then we say file not found okay and how does it return the Boolean it's basically using the os. stat function on the file and saying if ederal to OS do is not exist return false if it doesn't exist return false if it exists return true that's how we're checking for it out here so for the encrypt part we have checked um the validity of the file and not found now the next step is to ask for the password so we'll say password is equal to get password right so we already have the get password function so what is do it do it Returns the password which is a slice of bites and how does it accept the password it says first it prints out enter password then it's going to use the terminal terminal package to read the password and going to capture that in the password variable so when you if you remember when we were encrypting the file we didn't only just accept the password we also asked the user for the confirm password as in confirm this password so you want to print that out as well so you're going to say sln confirm password and we want to again read the password okay and this will be password to and here is where we will validate if the password one and password two are the same they're matching so we'll say if not validate password which will will pass password one and password two basically this function the validate password function should return back to us a Boolean and here we say fmt do print passwords do not match pleas try again turn get password if the password don't match we want this function the get password function to be called again and again Ask the pass uh the user password so if everything went well we just want to return the password from here which is a slice of bites okay now in the validate password function let's come here so it's going to accept something called as password one which is a slice of bites and password two which is again a slash of ptes return back a bilion and in here you want to check if the bytes are equal if everything is equal in password one and password two it's not equal return false if it's equal return true that that's our return uh validate password function which got called here and we'll go back now to our encrypt handle so after calling the uh the get password function we will say fmt do print Len and inform the user that hey we've started encrypting the file so we say encrypting and we'll use the file Crypt package the file Crypt package is our own we'll create the file Crypt package out here so we say file Crypt do encrypt because we'll have the encrypt function we'll pass it the file and the password and we'll print out FM do print Len you'll say file success detected so that's our encrypt handy function now in the decrypt handle function we will again check the same thing which is this like has he given us the file uh the part of the file if not we want to exit and we want to then validate the file again and we want to ask the user for this password so we say do print enter password and we want to say password terminal. read password and after taking the password we'll just print out instead of encrypting we'll just print out decrypting and instead of encrypt file the uh function encrypt function we'll just call the decrypt function passing the file and password and here instead of protected we'll just say decrypted so we have the encrypt handle and decrypt handle functions perfect clearly get password validate password validate file and CP handle print help and name now in the import statement we should have um all the files which file Crypt is my own package which I'll get from here the xterm package is the one that we're using here term uh the one that we're getting to to using to read the password and then we have byes fmtn okay so that's how it is now I can already see some issues and errors and some of them should go away once I've completed my file crypt.of file but then there will be many others that we fixed not a problem and now let's go ahead and start working on our file crypt.of file so starting with the filecrypt Dogo this package is going to be called filecrypt and we'll import some packages of course then we have two functions one is the encrypt function as you know and the other is going to the decrypt function okay because from here we are calling the encrypt and the decrypt functions so in the encrypt handle and decrypt handle respectively you call the encrypt function from file Crypt and the decrypt function from filecrypt those are the ones that we working on at the moment so in the E encrypt function you take in the source which is string and the password which is bite it's a slice of bytes okay so now this uh Source in our case is the file right because if you check here we're sending the file and the password so file and the password right so for the file we want to check if the file let me actually open up the browser and show you the diagram again and we'll follow the exact same steps so here it is we'll check for the source open the source file read read PL text from the source file create an empty nuns randomize nuns Let's do let's do those steps so first is os. stat then the source. is not exist and if it doesn't exist we are just going to return an error so first we checked for the file now we'll open up that file so we'll say os. open source and we'll capture that or store that in source file and if error is not equal to n panic errors at the end of this program when this function stops running we want to also close that source file so that's why we'll say differ Source file. flows now we'll read all the plain text from the source file so to read the pl text from the source file we'll use io. read all and source file what you get back is plain text and now we'll handle the error also error is not equal to n banic now the password that you have you want to store it in a variable because we want to work with it so we'll say key is equal to password and and now we'll create an empty nuns this is an empty nuns make and it's a slice of bite and of 12 so it's going to look something like this it'll be 0 comma 0 comma 0 right 0 0 0 till 12 so 12 different values all of them zero that's what you create with this now and now we will randomize the nuns okay so we have created the empty DS now we'll randomize it we'll put random values in it and the way to do that is we'll say IO do read full random. reader so fill it with random values and error is not equal to nil Panic error dot awesome what's the next step now so on my screen the next step is we pass all these values to create into the password based deration key derivation function okay so the password based key derivation function is available to us in a package of the same name P key PB KD F2 and that function we pass the key the nuns 4096 as the number of iterations 32 as a length and sha 1. new as the algorithm so if you look here we passing the password to encrypt the file the nuns the number of iterations sha one and the B length which is 32 in our case and this is the number of vibrations what you get back from his this is called as the derived key DK so we just in short it's DK this package that we're getting everything from is is this package pbkdf2 so now we have the derived key now we will create we will run it past by the advanced encryption standard so we'll say a. new Cipher DK and we'll get the block and we'll handle the error also so let say if error is not equal to n Panic error okay so we have this now the cipher block and now we want to use the galwa whatever ever it is you know GCM I'll call it GCM so it's the new GCM function so I'll say cipher. new GCM function and I'll pass in the block and what you get back is AES GCM if error is not equal to nil Panic error dot error okay so as as you know we did all these steps to to be able to run the seal function here which is what creates the which is is what converts the pain text to Cipher text so coming back here let us use the AES GCM do seal function this is what's going to take the plain text for us and send back the cipher text and you uh append the nuns so there is one thing that I have not drawn here but I have actually talked about it here is that we add the 12 by nuns at the end of the encrypted file so we want to do that now we want to append the nuns to the cipher text and store that in the cipher text itself so now we have the complete cyer text now we want to create a file source file for the encrypt data and want to write the data to the source file so what you'll do now is we'll call it the destination file. create create that file handle the error also here panic and at the end of this function when this function uh has done processing you want to close this file as well so you have created the file now you just want to write Cipher text into that file so write the cipher text into the file but this is the de file you'll say destination file. light and you will get the error if any if error is not equal to n Panic error okay so this was our encrypt function so far so good and as soon as I uh hit uh save it got me all the packages that I needed and now we want to work for the decrypt uh function the decrypt function is very similar it takes in the the the the path of the file and the password with the help of which we will decrypt this and first things first you want to check if the file that to be decrypted the the request that's coming for decryption if the file even exists or not so do the same thing .at Source this do is not exist error and here you will this is the error you're handling here and you're just saying Panic error okay and actually some of the part from here is going to be similar so I will just um copy this part all of this part till here I'll just copy it uh once again after this so here you will have uh SRC file where you'll open that source file and at the end you will close it also and here instead of plain text you'll just have Cipher text because that's what is in the file now because you have already encrypted the file and you're passing the encrypted file to this decrypt function and that's why whatever is there in the file is now Cipher text so we have done in the decryption part we we're done with this check for the encrypted file open the encryp file and read the text Cipher text from the encrypted file all of this is done okay so the password that you will receive in this function will again be stored in the variable key then we'll have a variable called salt which will basically have Cipher text and length of Cypher so without the last 12 okay and x dot and code to string the salt which is basically the nuns the last 12 is the nuns right you'll have it inall in Sal and we will use the hex package to decode this string and we'll store that in Str Str sorry this will be NS now okay okay so what do you pass again in that function the password based key derivation function for decryption you pass the same password to to that will be used to decrypt the bite length 32 chart 1 iterations 4096 and the NS that we got from the last 12 uh digits of the cipher text and the same thing you do here you say new Cipher sorry new yeah a. new Cipher and you pass the derivation key derivative key and you'll again get the block and again you can have handle the error if error not error not equal to nil and then you want to pass that block to uh the cipher AES Cipher so what I'll do is I'll yeah we've already done that and now we want to pass it through the CGM GCM sorry yeah so the same thing that we done there we're doing it here and now there's only one little difference uh which is that instead of using the as GCM do um seal function we'll just use a GCM do open function so here we'll have the nuns the cipher text which is everything apart from those last um 12 and what you get back from this is the plain text okay so what you're seeing now is uh step by step we're just looking at the diagram and we are uh converting the diagram into code okay so our flowchart into code again let's handle the error here and then we'll again create the file like we did last time the destination file so I'll copy and paste that part Here and Now we will write plain text to this file so instead here we wrote the cipher text to the file and now we will write the plain text which we have received to the file so here what was happening in the encrypt function what was happening is that you ran that function called uh the seal function which gave you the cipher text to run the seal function as GCM seal function you had to uh do all of these steps which is get the plain text and then create your nuns have your password ready uh create a derived key with PB kdf function use Advanced encription standard new Cipher create a block Cipher block pass the cipher block uh with GCM and get AES GCM and then you were able to call the seal function to get the cipher text with all those values here exactly the same things you just had to call the as GCM do open function because this will give us the plain text from the cipher text Cipher text is everything apart from those 12 last digits which actually was the nuns in our case for nuns right the salt which we can convert into nuns here and uh then finally just like we did in the encryption file we created a file and then we wrote plain text back into that file and now when we open up this file we'll be able to access it right so as you can see I have a lot of errors and I'm not at all scared because now when I go ahead and run this program uh I will come to know what the issues are so I'll say go run encrypt PNG and here I see all of these issues it says uh file Crypt to add file Crypt and yeah so xterm and file CPT are not there that means I need to say go mod tidy so first I'll get these packages let's I can see some issue there but let's see if it still works yeah still the same issues I'm getting so let's try to fix it now one issue out here obviously is this part which is I've copied the link from my previous project now this is obviously my GitHub and this should be the name of the project right and I'm and I'm calling file Crypt package but the name of the project is wrong that I have to go and get from go mod so the name of the project is actually go file encryption in this case and I have to go ahead and get it here and this issue will go away uh now what we'll do is we'll again go and run go run encrypt IMG or PNG and now we'll get a list of issues okay so now uh on line 68 file Crypt line 68 file Crypt as I can see it's should have been error okay now let me check out line um 83 line 83 key is not used yes because I was supposed to use key here by mistake I've written name and here also I can see one more issue it's key should have been key right uh now the other thing I can see is um 88 which is undefined yeah it's the same thing this one the issue 988 all right so that's solved but now I can still see four issues in main. go so what we'll do is we'll go ahead and run this again uh here now we can see some issues from main.go file and the um first one is on 50 okay and then online 66 and then on line 87 print line uh 102 right so what I'm trying to show you here is with if you're working with Technologies like goang and rust you don't have to worry at all about making mistakes the code so don't depend too much on extensions right so many people would tell you get extensions that help you uh not make any mistakes in the code while writing the code uh for spelling and for for uh you know goang so don't I would suggest don't don't depend too much on that as you can see I I wrote everything myself and uh I just depended on the on the goang compiler to tell me the issues and I just solve them one by one so just just depend on Goan compiler because when you're in an interview when you're giving the interview for some company uh you're not sure what kind of environment you'll get to write the code with mostly it's an online environment right and you have somebody on a call you have an online environment and you have to write the code in that online environment that won't have the extensions that you want and that you work with so it's highly recommended that you don't depend on extensions I've had many of my friends get into a lot of trouble because of that um but but know how to work with the goang compiler a lot like get very very good at debugging code okay so uh now things should work so it says ask me to enter the password and I will enter the password it will ask me to confirm the password I'll confirm the password it say file successfully protected try to open up the file I'm not able to okay and now what I'll do is I'll just run this um again with instead of encrypt it be decrypt and I'll just enter the password I had Ed earlier and now as you can see I can check out the file I can look at the file okay so this was our project everything works perfectly fine thank you so much for watching uh this I would say is is an intermediate level project it's not very Advanced it's not very simple uh like it's not a beginner level project probably and it's not an advanced project also somewhere uh in the middle but I hope you learned a lot thank you so much for watching if you haven't subscribed to this channel make sure you subscribe I'll come up with awesome content like this in the future thank you so much we're building something really interesting in today's video what we'll do is we'll just take some plain text encrypt it we'll get the encrypted text we'll then run it through a decryption function and then we'll get the decrypted text so it's quite straightforward it's something we haven't done before on this channel right it's uh working with encryption algorithms so we using a very simple encryption algorithm called the C are Cipher in this project and let me give you a quick demo on how this works so if I run go run main. go my plain text that I had given to the program was hello world and I get the encrypted text which is c z g g jrj mg Y and when we decrypt it again we get Hello World back right and in the program itself you can uh give it some text that it will encrypt and decrypt you can also build a CLI on top of it to accept the text from the user I haven't done that because in this project I want us to focus only on the encryption and decryption part we don't want to focus on the CLI part because I've already done that in many other projects okay so how this is working is we first take some text hello world right and by the way uh this is very quick visual programming visual planning that we'll do before we actually start programming so that we know exactly where we going and this is just a quick demo to show you how and uh how we're going to build it and what exactly uh is it that we're doing so we have our text hello world that you saw in the demo and we give this a key five so this key can change could be seven could be 10 whatever but in my case I'd given it the key five okay and I'll I'll tell you what that key means so with Caesar Cipher what what what happens is you pass in let's say all the uh alphabets so in my case in my program I had passed it all the alphabets you can also pass in numbers to this program and you can also give it special characters and what we want to do is with CES Cipher we want to replace uh this text with some other uh alphabets from the alphabets that we we have given it right so this one is going to be called as the original text because from this we will select uh some other characters that will basically replace this text of powers right so in the in the end you get something like this is CZ e jrj mg Y which is the encrypted text which nobody can understand but when you decrypt it the person who's supposed to uh receive this will get Hello World back okay and by the way uh in the beginning of computation this is how many encryption algorithms worked and now you have obviously much more advanced algorithms and that's what you see when you see WhatsApp saying it's end to end encrypted they're basically encrypting all the text that you're sending and you're getting back uh the user is getting back the actual text but then there's some encryption happening in between so that nobody can intercept those messages and read the meaning or read those messages basically so um the way this is working is first we'll take 26 which is the length of all of these uh all of the basically characters that we have sent the original text length is 26 and then we'll subtract the key which is five from that okay and then we'll create two different uh versions of this original text one is from 0 to 21 because if you subtract 26 from 25 you get the number 21 so from 0 to 21 you'll separate that into a different bucket and from 21 to 26 you'll separate that into a different bucket right and then what you do is you attach this in front of uh this part right so the one from 21 to 26 you attach that in front of this these remaining uh digits or the remaining uh alphabets or letters and you get something like this this is something called as the hash text hash text and essentially what you have to do now is you have to take H and find a uh corresponding or an equivalent um letter from here that will basically replace H okay so how do you do that first what you do is you find the index of H in the the original letters so you go to the original letters which is the original text and you find the index of H so it's a b c d e f g h this H this is H here it's the number is seven so that's the index of H in original letters which is seven and then you apply this formula this formula basically gives you the uh this this formula will give you the result of the index of the uh the corresponding uh alphabet that you have to pick up from this particular text the hash textt right so so you get i'll repeat again you get the um the position or the index of uh that number that you want to encrypt from the original text and then you run a formula and you get this is the main formula for cyer Cipher uh Cipher algorithm and then you get the position or the index of the uh alphabet in the hash text and that's the one that you want to replace this with so uh in the hash text right so firstly let's run the formula so the formula basically says the position in the original uh text of H which is 7 plus the length of the original letters which is 26 and uh modulus with the length of the original letters which is again 26 and the answer that you get here is basically uh 7even so uh in in our case uh the index of H and original letter of seven and the index of uh uh the the index from the formula that we got by running the formula is again 7 so we have to look for the seventh alphabet in the hash text so it's like 1 2 3 4 5 6 and then 7 7 is B in our case right as you can see B so we replace H by B and similarly you can run e which is hello world right that's the text we want to encrypt so e you take e and then you do the same same thing and what you get is e will be replaced by Z right so Z is and how that happens is because in the original text uh e is the fifth digit right so when you when you run this formula again you'll get five here and when you uh go to the fifth digit here 1 2 3 4 5 Z is the fifth one so that's why you say five and now you don't even have to run the formula you can just get all the other digits very easily because L is the 12th right so if you go to the original text so L is the 12th so it's 1 2 3 4 5 6 7 8 9 10 11 12 L is the 12th and that's why in the hash text also you will also look at the 12th uh alphabet or the 12th letter so it's 5 6 7 8 9 10 11 12 which is in our case it's G so that's why both the L's have been shown as G out here okay then you can get the others also really easily and this is how basically this entire um algorithm is working now this is very predictable like uh if you give this to somebody and they figure out uh like the corresponding of H and E for example in this they can easily figure out all the other letters and this is a very very simple uh encryption to break it doesn't take a lot of brains to uh to break this encryption so that's why this is like the simplest simplest encryption uh that I wanted to show you and then you've seen my other videos on on the blockchains and how we've used Shard 256 right to encrypt and they those uh more advanced algorithms have more advanced properties you have the Avalanche effect and you have uh uh what's the other term I'm forgetting the term it's basically but but the property is that no particular letter corresponds to another letter another letter right so that property is called something I'm forgetting the name right now but the Avalanche effect again is that if you change one thing in that encryption everything uh the complete uh signature changes so you have those Advanced properties that you get with Advanced algorithms you you don't have any properties with this is like very straightforward uh this this has existed from the time of Caesar I think that's why it's called Caesar Cipher it's like Way Beyond way before um the the invention of computers but it's a great algorithm to know it's it's great to get started with it encryption and it's a great project to build with goang because we'll work with uh this this little algorithm but we'll also get to apply our goang Concepts and that's what what will make us a better goang developer okay so with this out of the way let's get started now before we get started I just want to tell you that this particular uh video will be part of the 47 killer goang projects CD so I have this playlist on my uh channnel it has 47 projects in goang so in case you didn't know that you want to check you might want to check them out uh so this 47 will now become 48 because this video will will be there in that and what I'm trying to do is I'm trying to arrange these videos in the level of difficulty where some some of them I've not still not arranged them in the right order but I will do that and then eventually they will be in the right order of difficulty and you want to start from the beginning and start building projects uh one by one all right that's how you want to go about these now the next thing I want to tell you is is that we have this Discord server for my YouTube and everyone is allowed here and we discuss really awesome stuff uh like you know what we're learning today and we're having a lot of discussions so like let's say if you have any goang issues you can come here and post the issues um and we we're discussing about any issues about goang you know I I help quite a bit on this community so if you if you want you can join it all you have to do is the the link I think is out here so you have to just go here and this is I think the link for joining the community if you're not able to join it let me know I'll uh I'll make sure I'll send the new link with you okay so that's one more thing I want to share with you and the code for this particular project and all the other projects is on my GitHub so in case I don't share my GitHub link with you you have to know it's Akil Sharma 90 on GitHub and you'll find almost all of the projects here this is the one that we're building today sorry not this one this is the one that we're building today simple encryption decryption with goang using Cesar Cipher right so the code is already there uh all you have to do is just come here and uh in case you get stuck you just have to refer to that code all right so everything is uh clear now now what we have to do is we have to um I will just go back to my um the the place where I keep all my goang projects and I will just create a new directory I'll just say go um encryption YT okay and I will CD into it and here we will go mod in it and I'll just github.com ail Sharma 90 SLO encryption y so what this does for for us is it creates a go. mod file which will have the list of all the modules that we use in this particular project we're not using uh any third party modules I think mostly so you don't need to worry too much about it but still we'll just have it uh in any case here I'll just create the main.go file and this is a very small straightforward project there's not a lot of uh Engineering in this but uh it's it's small and straightforward like I said and uh it's a great project to build like great uh beginner level project to build so in my main go file I'll just say package main which is the first thing you write anyways in your main. go file and then I'll have some import related stuff right so I'll have I'll just write import here and accordingly I'll import the stuff that I want to import I'll have uh the main function obviously Funk Main and here is where I will Define my plain text which in my case is hello world you can change it also and then I'm going to print it out I'm going to print out the plain text as it happened in our demo also right same way plain text and we print we print out plain text then we have our encrypted text which is uh what we're going to get when we call our encrypt function that we will create now so we'll create an encrypt function it will take in the key in my case will be five and the plain text right so this means that here up here somewhere will be our encrypt function so it'll say funk encrypt and it will take the key which is the integer and the plain text sorry PL text which will be string and this will return to us the result which will be the string the encrypted text obviously right and then obviously uh apart from the encryption function if we have an inun function we also need the decryption function this will again take in the key the encrypted text and it's going to return back to result which is the string so once you've encrypted it you have this uh in this variable called encrypted and we will print it out first so we say I can do a print Len and encrypted text will be encrypted and then we have decrypted is equal topt five comma um and then we'll print it out decrypted come on decrypt so to the decrypted decrypt function you are passing the key and the encrypted text and you'll get that in the decrypted uh variable and then we'll just print that out so that's it that's all our Funk name is doing okay at the top I will say my original letter will have all the 26 a b c d e f g h j k l m n p q r s t u v x y z okay so original will have all of this original letter basically means this the original text this has all of the uh letters this is the plain text and this is the key five which we've passed okay now we want the hash text so for the hash text we need another function let's call it frun hash letter function takes in the key takes in the uh original letter it'll take in the original letter and we'll say result and string okay now here the first function that's called is the encrypt function so we'll start building upon the encrypt function so as you remember in the encryption part the first thing we do is is we first want this right and then we'll find the index of H the first letter we'll start we'll start letter by letter the first letter which is H we'll find the position of H in the original text but we also want this right you want the hash text because after we run our formula we want to find the uh that particular index what's the value at that index in our hash text so that's why we need this also first so well we'll call the hash letter function so we'll say hash letter function we'll pass it the key and the original letter original letter being this we'll just pass it there and to start with we'll say V hash string isal to empty now hash string is what you want to return from here so there this result that we sending back is the hash string and one by one you will keep adding to this uh empty string some values so for example for H the first value in our case as you saw here uh we'll get C right so whatever we get here C and z and G so one by when we'll keep adding values to it we'll run things through a loop and we'll keep appending things to this hash string uh and that's why first we'll start with this being empty and then we will run um actually at the end here we will will have this function called strings. map and we say find one comma plane text so strings. map what this does is it takes in uh the plane text okay in our case the plain text is actually hello world so it takes in hello world and one by one it'll send it and call this function called find one so it'll take uh H first and then e e next L lse we'll take all these things one by one strings. and then call the find one uh you know function so what is find one so find one is equal to a function it's a function which takes in r as a rune and returns a rune now what does that mean so Rune help so runes basically help you um with unicodes so what we're saying here is that um a run represents a single uni code character okay so for example a the value of a is 65 so you get the ask2 value and now you can uh work with the letters in a much more flexible way so you get separation between all these letters so for example A B C D E F because you're sending them one by one but then with run you're able to work with them in like much more easily uh because here what we have not covered is is that the runes that you'll get here also you'll use Rune to be able to work with that so we'll be using run basically all throughout to be able to uh iterate over all these letters and work with those letters uh and then perform operations on that so it'll take in our run so for each uh letter like H we take each letter from the pr text which is like the hello world right so H we take that and we send it to find one and then what the find one function is doing is it's taking in that H and returning us to us the equivalent letter uh in the in the encrypted text so in our case it will be C now how do we get from H to C let's take a look so uh first I think I'll just build the hash letter function because otherwise there will be just confusions because you know I wanted to explain the Run Part before we wrote Rune here because we using it in the hash function so I didn't do that uh my bad but I think I'll just build this function before we work more on the encrypt function so that it just makes more sense so this hash letter function right all it's supposed to do is it's supposed to um take in this key and then divide this into from a to Zu and from V to Z divide uh the original text into these two parts and then also put this in front of this and then return that part that's so we want to return the hash text from this function so we'll say last letter key equal to string runes length of letter letter being original letter in our case so from here to here the length is obviously 26 so we'll say length of letter minus key to length of letter so this is Runes of 21 is to 26 so from 21 to 26 what are the things which is in our case v sorry 2126 v w now x y z so these five things will basically come in the last letter key and then we'll say the left over letters left left over letters letter is equal to string runes and zero length of letter minus okay so 0 to 21 so this is length of letter which is 26 minus ke which is key is 5 so it becomes 21 so 0 to 21 will come in uh one place like I said and 21 to 26 will come in another place so this has 0 to 21 and this has 21 to 26 so last letter three and the left over letters now all we have to do is we have to return I told you right we'll return This plus this so we'll return the uh last letter and followed by the leftover letters so let's do that so we'll say FMP Dot Sprint F here let's say percentage s and percentage s comma last letter two comma left over letters so we able to return what we promised from this function which is the string which is the hashed uh the hash text from this function so in the encrypt function we were now in the find one function and here we will first start with the positional strings. index why the position uh if you remember I had told you that what we'll do is we'll find the index of H or the position of H and the original letters That's How we'll get seven right so this is the original text and we have to Now find the index of H there since strings. index and the original letter comma string and that there will be uh run R and now we'll get the position of that letter now uh if what if the original text that we passed original letter text that we passed somehow we forgot to write there was a type of we forgot to write H there right then Position will basically become min1 and that's what we want to check for so we want to check if position is not equal to minus1 that means the letter that you want to encrypt is actually existing in the original letter you want to find the position if it's not equal to minus one then we can do something about it otherwise it's a problem right other you just want to return the same thing return R um and finally from here we want to return the hashed string as you know hash string which is now empty we want want to fill it up so if everything is all right and it's not uh minus one then we'll say letter position is equal to position plus length original letter percentage length of orig letter and hash string Hash Hash string plus string hash letter letter position okay so what's happening here is we first find the position and then we uh run our modulus function so if you remember I told you the function or the formula looks something like this where we add the position plus the length of the original letters and we mod we run mod modul which is length of position dat so in our case be 7 + 26 modulus of 26 you get 7 right so that's what we're doing here so you get the letter of the position uh which is seven and now the next step would be to look for that uh letter which is at the seventh position in the hashed text and that's what we're doing so we're looking in the hash letter that we have hash letter hash text we passing this letter position and getting that particular value converting into string and adding that to Hash string so each each of these values from the plain text one by one because of the help of strings. map one by one we'll take it like H and e and l and O and then we'll pass it to find one find one is accepting it as a rune and also returning a rune in our case and then it's um adding everything to hashed string that's what's happening adding everything to Hash string finally we'll have as string that that's what we'll return from this function okay now the decrypt function is going to be the exact opposite of this the decrypt function is going to basically um have same method which is calling the hash letter function and we'll capture that value in a variable called hash letter so the hash function will pass the key and the original letter and again you'll start with the hash string which is entty so with the with the decryption we have to uh find again you know that value in the um in the hash letter index so let's so this is what we'll start with okay in the beginning and we we'll find the value of let's say C so in in the in the encryption we started with the original text now we'll start with the hash text so let me write it here this is decryption sorry you start with the hash text and you see that the uh hge right is of particular value and um and this is the original text here yeah so like I was saying this will happen before so we'll first check the value of that uh you know letter here let's say in our case C right so we'll notice the value is 5 6 7 uh 8 1 2 3 4 5 6 7 8 so this will be eight in our case right and then then that eight we have to find in the uh in the hashed text sorry the sorry in the in the original text so the original text is different right it's so decryption will exactly be the opposite of encryption so an encryption we first found the position of the value in the original text and then found an equivalent in the hash text and decryption will be completely opposite we'll first find the position of that particular um so C for example we'll first find the value of that letter in our hash text in this case C and then with that position we'll run that formula again and we'll get some value and then that value we have to pick from the original text and that's how we'll get back uh hello world from this text so that's the entire method that we have to follow now okay so let's do that so for encryption for decryption we say hash string is completely empty and then we say find find one and who's going to call find one um out here we'll just say strings. maap find one comma encrypted text and return hash Str right so the other thing that's changing here is that with uh with encrypt we sent the plain text to our find one but in decryption uh we're passing the encrypted text to our find one function and then find the F final function we'll say funk R Rune and Rune okay so that that was one change which is passing plain text versus passing enry text the other change which I was showing you in the diagram was that we will find the position of the uh of the the the word in this hashed letters so earlier we found it in the original letters right the first position now we'll find it in the hash letter and we'll say string run R and again we'll check for the same thing position uh is not equal to minus one check for the same thing from here we'll go R yeah this if you remember we checking because that that uh particular value that's coming in here needs to be there in the hashed text right so not the original letter in this case is the hash letter so it has to be there in the hash letter the position otherwise will be one minus one so only if it's not minus one we can uh proceed and this is how we'll proceed so we'll say letter position equal to You'll again apply the formula plus length of original letter percentage length of original letter which is mod modular and then origal letter and we'll say hashed string equal to Hash string plus string and original letter letter sorry letter position forgot the return are here okay right so uh main main differences in decrypt and encrypt is like I said we're passing the encrypted text here we're passing the plane text there and here we check cheing for the position in the hash letter hash letter being this one and here uh in the encryption we were checking for the letter position the original original text original letter here for finding the letter position formula we again we use the length of original letter only that's not that's not different that's the same thing and finding the hash string finally at the end we found here from the the hash letter we found the equivalent text and now to Crypt it back we finding it from the original letter the equivalent uh you know letter so here we'll get the back to decrypt decrypted text now uh I don't see any issues and or any errors here in the in the code so what I'll do is I'll just go here and I'll just say go run main. for so if there are any errors we'll get them here but there were not any errors luckily so we had our PL text we got the encrypted text and we got the decrypted text okay so I'll just quickly go over it again in case you missed anything uh we started with our plain text we uh got the encrypted text which is this we sent it to the decryption function got the decrypted text started with Hello World text we want to replace each single letter uh with with different alphabet the key that we passed was five and the original text we pass was this so this can have numbers this can have small characters also this can have special characters also and when we pass the key as five we run this through the original text through a hash hash function which basically subtracts five from the length of the original text so we get 21 so we divide the original text into two different parts one is from 0 to 21 and from 21 to 26 then we pass the hash text back so which is this uh before the uh before this text and we pass this back to the function in the encryption function the first thing we do is we find the index of the first letter which is H in the original uh text so in this case we get seven now we run our formula which is position plus length of original letters percentage or modul length of original letters and then we get again uh 7even and we find seven in the hashed text because we want to convert from original to the hash or the enry encrypted we'll find an or uh like a like a corresponding uh digit or letter from here and B so we found that H is equal to B Because B is on the seventh position after we ran this formula and that's how from Hello World we actually got this in this description it works the completely opposite because you find the position of C in first in the hash text and then we get that position and then we basically run it through the formula and then we get the original uh text sorry and and yeah and we get the position in the original text of that corresponding letter in this case it will be H now guys uh there's one thing that I have uh you know made a small mistake in right and I want you to to uh find that out in case you haven't figured out in the whole program one thing that I've been missing or and messing up with uh just so so that you know uh in case youve understood it please let me know where I've made that mistake uh there'll be basically ensure so if you if you go through the video again look for the mistake things will become much clearer to you and you'll be able to um completely understand this concept right so let me know if you found that mistake uh I'm going to tell you the answer anyways if if in case if you have not found it so the mistake is that the value uh the actual position of H is not seven it's 1 2 3 4 5 6 7 8 it's actually eight not seven so that's why you have to write here eight and you have to write here8 you have to write here eight then have write here 8 and should have in C right H should be equal to C and not b and that's how you get C right here right so I made that mistake um and now you can actually go and run the actual values and you'll see everything is consistent all right so that's perfect I hope you were paying attention now when you looked at the mistake uh everything will make sense right so um so what I want you to do is I want you to uh run through uh the entire code once again and run through those values once again so that you basically internalize whatever I've taught you uh try try to put different values here like smaller text and then special text characters all of that try and and see uh how that works and thank you so much for watching this video uh I hope you will join our community on Discord where we'll get to hang out and you'll watch all the other videos in this um in the uh in the in the goang playlist all right so thank you so much and I'll see you in the next video
