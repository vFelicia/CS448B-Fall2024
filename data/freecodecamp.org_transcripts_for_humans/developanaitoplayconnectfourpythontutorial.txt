With timestamps:

00:02 - how's it going everyone and welcome back
00:04 - to another video
00:05 - this video is long overdue but today we
00:07 - will be programming an expert level
00:10 - connect for ai which is gonna be a lot
00:12 - of fun if you haven't already i
00:13 - recommend you check out the video i did
00:15 - before like a while ago on i guess just
00:18 - programming the connect four game and
00:20 - what we're gonna be doing today is
00:21 - building off of that and actually
00:23 - implementing the ai
00:25 - um if you don't wanna like go through
00:27 - all the effort of what like programming
00:29 - the game from scratch
00:31 - you also can just go to my github page
00:33 - and
00:34 - i'll link to this in the description but
00:37 - there's this file connect for
00:39 - py so if you just click on the raw there
00:43 - and just copy all of this
00:46 - [Music]
00:49 - this is going to be the starting point
00:51 - from this video
00:52 - i'm going to be programming in python 3
00:54 - and i'm using sublime text
00:56 - as my editor so i'm just gonna call this
00:59 - connect4original.py
01:03 - also if you haven't seen it already i
01:05 - really recommend you watch my video that
01:07 - i did called like how does a board game
01:09 - ai work because basically what we're
01:11 - going to be doing in this video is
01:12 - following along kind of the
01:14 - steps that i
01:16 - go through in that video on the theory
01:18 - behind a connect4ai
01:20 - so it really will help you with the
01:22 - background information on like how
01:23 - everything works because it can be a
01:25 - little bit complicated at times
01:28 - once you have the file locally just make
01:29 - sure real quick that it runs properly so
01:31 - when you run this original file
01:34 - you should ah why is it not running
01:36 - you should get a screen that pops up
01:38 - looks like connect four board and you
01:40 - just take turns being the yellow and red
01:42 - player
01:43 - dropping pieces
01:44 - i'll finish this up real quick
01:47 - and it should do something like that
01:49 - when you you win uh you don't have any
01:52 - errors to start off so just make sure
01:53 - that everything's working properly
01:54 - before we actually get into the ai and
01:57 - with this ai we're going to start off
01:59 - just like i did in the how does a board
02:01 - game ai
02:02 - video work with the simplest approach we
02:05 - can think of for the ai so we're just
02:07 - gonna have it
02:08 - the player two just drop a piece
02:10 - randomly
02:12 - somewhere on the screen so that's what
02:13 - we're gonna start out with before we
02:15 - begin take a second to review the code
02:17 - and make sure you kind of understand how
02:19 - all the pieces fit together because as
02:21 - we go through the steps of the ai if you
02:22 - don't really understand how the game is
02:24 - working it's going to be kind of
02:25 - confusing the steps that we're
02:27 - implementing
02:29 - and to start off we are implementing the
02:31 - random dropped
02:33 - piece ai so we're gonna have to go down
02:35 - to our game loop which is here
02:38 - and in the initial game we were
02:41 - checking for the mouse button down event
02:43 - and then based on whose turn it was so
02:46 - turn equals zero was the red piece i
02:48 - think and then the else statement was
02:50 - player 2 and that was the yellow piece
02:53 - we are making the drops based off of
02:55 - that
02:56 - in this random ai situation we are now
02:59 - not going to have player 2
03:01 - drop when a mouse click happens is gonna
03:04 - just
03:04 - we'll have player two drop whenever
03:07 - um right after
03:09 - player one has made the move so
03:12 - once player one makes the move that
03:13 - should trigger player two to make the
03:15 - move and to kind of make some of this
03:17 - clear i don't like having like turn
03:19 - equals equals zero popping up in the
03:21 - code all over the place these are called
03:22 - magic numbers
03:24 - so what i'm going to do real quick is
03:25 - just to make things a little bit more
03:27 - clear is i'm going to go up here and
03:28 - define a static variable
03:31 - player which equals zero and i'm going
03:33 - to have a static variable or kind of
03:36 - just a yeah
03:38 - a variable called a i
03:40 - equal to one and i'll just
03:43 - when i making these variables will make
03:45 - it a little bit easier for me to
03:48 - read the code and also as we implement
03:50 - some of these functions with the ai
03:52 - it'll make it a little bit easier for us
03:54 - to understand how to implement it so
03:57 - now turn equals equals 0 is turn equals
04:00 - equals player
04:02 - and then for this
04:04 - we don't want it in the
04:06 - let me make this a little bit smaller
04:08 - just for a sec oh this can be too small
04:09 - i'll make it bigger but we don't want it
04:11 - to be in the if statement if mouse
04:13 - button down anymore we want it to be
04:15 - outside of this for loop because it
04:16 - shouldn't depend on event should just
04:18 - depend on when this
04:21 - i guess happens which we can store
04:24 - separately
04:25 - so we're going to move this back a few
04:32 - okay so that now should be
04:35 - in line with the
04:36 - 4 event
04:38 - and instead of an else we can't have an
04:39 - else without an if above it so what
04:41 - we're going to do now
04:43 - is we're going to do if turn
04:46 - equals equals a i
04:48 - and i guess we'll also do and not
04:51 - game over
04:52 - because we don't want this a piece to
04:54 - drop after the game has already been
04:56 - finished
04:57 - so if journey equals equals ai and not
04:59 - game over
05:01 - then we have
05:02 - the
05:02 - [Music]
05:05 - random ai making the decision
05:07 - and let's see there might be some other
05:09 - changes we have to make now that we did
05:10 - that
05:12 - one thing we might want to do is
05:14 - throw the print board somewhere
05:15 - differently actually it's good right
05:17 - here
05:19 - and let's see where else it was
05:21 - i didn't actually move it
05:23 - okay
05:24 - so i'm gonna move this stuff outside of
05:26 - the loop too
05:28 - let's see okay i'm thinking about this
05:30 - okay if game over that should be in the
05:32 - loop the turn what we're gonna do with
05:34 - the turns now is only have them change
05:37 - when a valid location was
05:40 - chosen
05:42 - so here the turn is changing
05:45 - and same thing for
05:48 - the
05:50 - player turn so if
05:53 - valid location then we'll change the
05:54 - turn
05:58 - okay
05:59 - uh no not that one less so inside the
06:03 - is valid
06:04 - location okay so now we what we have
06:07 - just done we haven't really done don't
06:09 - worry too much about the i guess
06:14 - logistics of what we're doing but
06:16 - basically we're setting it up so that we
06:17 - can
06:18 - pick a random spot to drop a piece we're
06:21 - just kind of having to do some
06:23 - i guess
06:24 - extra work to clean up the code and set
06:26 - it up for what we're trying to do so if
06:29 - turn equals ai and not game over cool
06:32 - and so now what we want to do
06:35 - is that initially
06:37 - right here
06:38 - we this was
06:40 - looking at where our mouse was and
06:42 - picking the column based off of that
06:44 - what we want to do instead is now just
06:46 - pick a random column so i'm going to do
06:49 - column equals random
06:51 - dot rand int
06:54 - 0 which is the farthest to the left
06:56 - column
06:57 - and
06:58 - we have
07:00 - column count columns right
07:02 - but
07:03 - indexing is
07:05 - gonna put that off by one so we're gonna
07:07 - do a column count minus one that'll pick
07:09 - a random number
07:11 - uh between zero and i guess
07:14 - six
07:15 - uh inclusive
07:17 - to drop our piece in
07:19 - and i have to i did not import random so
07:22 - i have to do that real quick
07:24 - all right i feel like i screwed
07:25 - something up and maybe we'll get
07:27 - some simple ai right here
07:32 - okay
07:32 - it seems to be working but it's
07:34 - immediate and that's kind of annoying
07:36 - but that's a good uh we're doing well so
07:38 - far
07:40 - oh and it's screwed up
07:42 - i just dropped a piece in a winning
07:44 - location and it screwed up there too so
07:47 - we have some things we need to do
07:49 - so the first thing i noticed that was
07:51 - really annoying was right when we
07:52 - dropped our piece the ai dropped their
07:55 - piece and that just doesn't seem very
07:57 - like
07:58 - it's not a good user experience so the
08:01 - first thing i'm going we're going to add
08:03 - is
08:04 - some
08:05 - time delay for the ai piece
08:07 - so down here we have the ai move and so
08:12 - basically what we're going to do is once
08:14 - this column
08:16 - has been
08:17 - selected and is a valid location so if
08:21 - it selects a column that's like
08:23 - not valid like already filled up or
08:25 - something it will run the loop again
08:27 - like nothing will have changed the turn
08:29 - won't have changed or anything
08:31 - and it will find a column that's
08:33 - valid
08:34 - and so in the is valid location we're
08:36 - going to add a
08:39 - a delay so i'm gonna do
08:41 - pygame.time.weight500 and this is
08:43 - similar to what we did
08:44 - before
08:46 - um
08:47 - when we ended the game just to like hold
08:50 - the player one wins on the screen so
08:53 - just like we did there so we're gonna
08:54 - add that
08:55 - and so let's see how it looks now
08:58 - quickly
09:00 - what the heck
09:03 - okay so i noticed another issue so i
09:05 - think it's working but what's not
09:07 - happening is the
09:09 - board is not getting
09:11 - re-printed after the
09:14 - we select our piece
09:16 - so
09:17 - the delay was there but it was being
09:19 - weird because it wasn't actually drawing
09:20 - the the board again
09:22 - so what we're going to do here is
09:26 - once we
09:27 - select like a is valid location
09:30 - we should update the board because it
09:32 - will have dropped a piece
09:34 - so i'm going to add this here
09:39 - see what it looks like now
09:42 - yay that looks pretty good
09:44 - and
09:45 - it's moving around okay it seems random
09:48 - but obviously as i mentioned or as
09:51 - yeah as i mentioned in the how does a
09:53 - board game ai work
09:56 - it's when you just select a random
09:58 - column it is such a stupid ai and it
10:00 - will not block my obvious three in a row
10:03 - so i can easily win right now also real
10:05 - quick while i'm thinking about it i
10:07 - don't know if you noticed this but
10:09 - right now
10:12 - i always get to go first
10:15 - so we probably would
10:16 - want it to be random who gets to go
10:18 - first
10:20 - it just makes it a little bit more
10:21 - realistic and we don't want to
10:24 - we want the code to work if the ai goes
10:26 - first so we can really easily
10:29 - add some logic that will allow us to
10:32 - initial randomly initialize who goes
10:35 - first and all i'm going to do is turn
10:38 - equals
10:39 - random.randint01
10:42 - or i guess we could even do player
10:45 - ai which is going to be zero to one as
10:47 - well
10:49 - so what will happen now is
10:51 - instead of turn where was turn
10:54 - initialized
10:55 - somewhere in here
10:57 - turn equals zero
10:59 - now
11:00 - turn is going to be either
11:02 - one or zero and the reason we can do
11:04 - this just fine is because
11:06 - the only place
11:07 - turn can change
11:08 - is after a valid piece has been dropped
11:11 - so basically what's going to happen now
11:13 - is we're gonna end we're gonna skip over
11:15 - this event
11:17 - this code right here on the first
11:18 - iteration if we get one
11:20 - in that initialization step
11:23 - and then the ai will drop a piece
11:26 - it will switch to the player's turn and
11:28 - then we'll start back up at the top of
11:30 - the loop and we'll wait until the user
11:33 - clicks and then
11:35 - run the code so let's just see if that
11:37 - worked
11:41 - oh shoot yeah it looks like it worked
11:44 - i'll run it one more time just to make
11:45 - sure
11:48 - it's kind of weird that it's starting
11:50 - yellow it's a little bit laggy or
11:51 - something but it is working and i want
11:53 - to just make sure that i can get a
11:59 - i should be able to go first at some
12:01 - point too
12:03 - okay yeah so after three tries we
12:06 - initialized the zero and i get to go
12:08 - first as before one more thing before we
12:11 - move on to the slightly more advanced ai
12:15 - is that when i was running this one
12:17 - thing that i found that was annoying
12:19 - is come on run dude i have to click
12:21 - first
12:24 - is when the yellow piece is first
12:28 - so you see how when the yellow piece is
12:30 - first the yellow block
12:32 - popped up top here it draws the yellow
12:34 - block up here i don't really want that
12:36 - to happen now that only
12:39 - we're always red
12:41 - so i'm going to change this to turn
12:43 - equals player and then i'm going to
12:44 - actually get rid of this
12:46 - drawing the yellow circle on the mouse
12:48 - motion event
12:49 - so let's see what happens now
12:54 - yeah so now it just pops up immediately
12:57 - and i could add another delay but i'm
12:58 - fine with this
13:00 - cool
13:05 - yay all right let's move on to something
13:07 - smarter and actually start implementing
13:08 - the scoring heuristic for our board so
13:11 - what we're going to be doing is
13:12 - evaluating whether or not a board state
13:14 - is good or bad based on you know
13:16 - how many two in rows there are how many
13:18 - three in a rows there are
13:20 - whether or not you're playing in the
13:21 - center column
13:23 - and you know vice versa for the opponent
13:25 - having three in rows two rows etc
13:28 - and so this is exactly what we did in
13:30 - the how does a board game ai
13:32 - work video
13:34 - except the one difference is that a lot
13:36 - of the
13:37 - scores i think i was going through
13:40 - in that video were relative to the piece
13:42 - you dropped
13:43 - so like you'd only look at the three in
13:46 - a rows created or the two in rows
13:47 - created from the specific piece you
13:50 - dropped that turn what we're gonna have
13:51 - to do when we're implementing that
13:54 - so that we can use the minimax algorithm
13:56 - is
13:57 - do that
13:59 - relative
14:00 - the score will be
14:02 - not
14:03 - it will be independent from
14:06 - which piece was just most recently
14:08 - dropped so you'll kind of look at all of
14:10 - the board and count how many three in a
14:12 - rows how many two in rows etc let's
14:14 - define a function called score position
14:17 - which will give the we'll assign the
14:19 - score to
14:20 - our board
14:21 - so i'm going to define this right under
14:23 - the winning move function so score
14:26 - position
14:27 - and if we're scoring position we're
14:28 - going to need to take in two things uh
14:30 - in my opinion we're gonna have to take
14:32 - in the board obviously we'll also want
14:34 - to take in a piece so we have to know
14:36 - whether it's red or yellow going whether
14:38 - it's the player or the ai
14:41 - um okay
14:42 - cool and this is going to be pretty
14:45 - similar to
14:46 - how
14:47 - we did winning move or in a way
14:50 - basically what we're going to check is
14:51 - look at the whole entire board
14:53 - and basically be counting the number of
14:55 - twos and rows three in a rows etc i
14:58 - think to start off and make things
14:59 - easier let's just count
15:01 - whether you win or
15:03 - whether uh you win or lose
15:05 - so we'll just be looking at four in a
15:07 - rows
15:08 - and we'll start off with just horizontal
15:11 - so horizontal
15:13 - or score horizontal i'll say
15:18 - and let's see
15:20 - one thing i want to do real quick just
15:21 - it's on my mind is
15:23 - pieces defined as one or two so one is
15:25 - the player's piece value and two is the
15:28 - ai's piece value
15:30 - and that's another like magic number
15:33 - so i'm gonna just try to like i'm gonna
15:35 - define
15:36 - two more variables player
15:38 - piece and ai piece
15:42 - player piece equals
15:44 - one and this will just probably make our
15:46 - code a little bit easier to read again
15:48 - and aips equals two
15:50 - so let me just go through and try to
15:53 - switch things out so
15:55 - this would be player piece here
15:59 - this is
16:00 - ai piece
16:04 - defined in several locations
16:06 - go down player piece
16:08 - right here drop piece this would be
16:10 - player
16:11 - piece
16:12 - winning move this would be
16:15 - player
16:16 - piece
16:18 - i think this one is something different
16:20 - here
16:21 - let's see what else we have
16:23 - down here would be a eyepiece
16:26 - and i think down here would also be aips
16:29 - i think that might have been it not
16:31 - positive but just cleans up the code a
16:33 - little bit
16:34 - okay so we want to score the horizontal
16:36 - locations
16:37 - the way that i think we should do this
16:40 - is
16:42 - basically what we're going to do is it
16:44 - we could do it the exact same way we did
16:48 - winning move but it gets kind of tough
16:51 - with these if statements to count
16:52 - whether or not like you have two in a
16:55 - row exactly
16:56 - or three in a row exactly because
16:59 - then you'd have to like you have to
17:00 - factor in all the different ways you can
17:02 - have three in a row so what we're gonna
17:04 - do is i'll run the game real quick
17:07 - oh no what did i do
17:09 - sorry
17:10 - i just need to pass this function real
17:12 - quick
17:14 - what we are gonna do instead
17:16 - of
17:17 - that is basically
17:18 - imagine so look at my mouse down here in
17:21 - the corner
17:22 - we're gonna look at with horizontal
17:24 - starting we're gonna look at window
17:25 - sizes of four
17:27 - and just basically in those window sizes
17:29 - of four count how many empty squares and
17:32 - how many filled in squares there are and
17:35 - we'll basically be able to count then
17:37 - the lines of two lines of three lines of
17:39 - four from that
17:41 - so this is how it's going to work
17:43 - so
17:45 - we have our board and that's you know
17:46 - the matrix the row of rows and columns
17:50 - so what we're going to say is for r in
17:52 - range
17:54 - row count
17:55 - so for each row we're going to want to
17:57 - do this
17:58 - and then what we're going to do is
18:01 - we are going to
18:03 - define this row array
18:08 - and yes row array the best way yeah row
18:10 - array so this is going to be all of the
18:12 - pieces so if we're looking at a single
18:13 - row this is just going to be the seven
18:16 - tiles but just in a single list so it's
18:19 - easier
18:20 - and we're going to define that as row
18:22 - array equals
18:24 - into i
18:27 - for i in list
18:29 - board
18:31 - and then so we want the specific row
18:33 - we're on so it's going to be board index
18:35 - of row but then we want
18:37 - all the
18:40 - all the column positions for that row so
18:43 - that's why we use this colon right here
18:45 - i think that's what we want let me just
18:47 - see and the inta is just to make sure
18:49 - that we're always getting something
18:51 - that's can be indexed into the
18:54 - um
18:56 - okay ah so what am i saying sorry
18:58 - and i i think i just added this just to
19:00 - be
19:01 - cautious that we didn't try to index
19:03 - something with a float value or
19:05 - something so that's our row array
19:08 - and so then
19:10 - what we're going to do is
19:12 - get
19:14 - if this is like let's say we looked at
19:16 - the board down here the row array would
19:18 - be like this single list in here what
19:20 - we're going to do is
19:23 - look at all the
19:25 - pairs of all the
19:27 - window sizes of four
19:30 - so to do that we will do
19:32 - for c
19:34 - in
19:35 - range
19:36 - column count
19:39 - minus three and the reason we do minus
19:41 - three is because the last one we want to
19:42 - look at
19:44 - is this so we don't look it like we
19:46 - don't start with these last three as the
19:49 - farthest to the left if that makes sense
19:51 - i'm highlighting great in this area if
19:53 - you missed that
19:54 - okay
19:57 - so we're getting the horizontal windows
19:59 - and
20:00 - so the window then will be a four will
20:03 - be
20:05 - the row array
20:08 - and we're going to index that from our
20:10 - starting position so that's going to be
20:11 - from c
20:13 - to
20:14 - c plus i guess
20:18 - 4 would it be four or three i'm trying
20:20 - to think
20:22 - it's gonna be four yeah c plus four
20:25 - and we can actually make
20:27 - this a variable two just so you know
20:29 - where that four is coming from i'm just
20:30 - gonna call this window
20:32 - length so window length equals four
20:39 - so
20:40 - window length
20:42 - so we're getting four at a time and then
20:44 - what we're going to want to do with that
20:46 - is count the number of
20:49 - ones and twos so ai pieces and you know
20:52 - player pieces what not so what we're
20:54 - going to do with this window is there's
20:55 - a built-in function of lists in python
20:59 - dot count
21:00 - so what i'm going to do is count the
21:03 - piece
21:04 - that we're passing into the score
21:05 - position
21:06 - function and if that equals equals 4 so
21:09 - that would be we win
21:11 - so i guess if
21:13 - window dot count piece equals equals
21:15 - four
21:17 - let's say we have a score that we're
21:19 - defining
21:20 - so score is
21:22 - zero initially
21:24 - we'll say score
21:26 - plus equals
21:28 - like a hundred right so if we ever find
21:30 - four in a row on the board that's a
21:32 - really good board obviously
21:34 - um and so we should try to get that move
21:38 - okay so we have score plus equals 100
21:42 - and then once we're done we're just
21:43 - going to do horizontal for now and i'll
21:45 - fill in we'll fill in the diagonal and
21:48 - vertical later turn score
21:51 - okay
21:52 - so now we have this score position
21:54 - function that looks at a single board
21:56 - state and
21:57 - gives the score of a hundred if it is a
21:59 - connect four
22:01 - and
22:02 - gives
22:03 - zero otherwise
22:06 - and i guess for the sake of this let's
22:09 - also
22:10 - preference uh three in a rows why not or
22:13 - maybe yeah three in a row so
22:16 - if
22:18 - i'll define this above
22:22 - or i'll define it below
22:25 - lf
22:26 - window.count
22:28 - piece
22:30 - equals equals three
22:32 - and
22:33 - window.count
22:35 - of zero so we should define this as a
22:37 - piece too so empty
22:39 - equals zero this is just how we are
22:42 - storing the values behind the scenes we
22:44 - know that count of empty
22:47 - equals equals one
22:49 - then let's add i don't know
22:52 - 10 to our score
22:55 - so this is three in rows this is four in
22:58 - rows right
22:59 - and then we need to find one more
23:01 - function
23:02 - and that is
23:04 - just like
23:06 - pick best move
23:08 - and that will give taking a board
23:10 - what else does this need to take in
23:15 - i'll start with just the board
23:18 - potentially i guess the piece too
23:21 - yeah why not
23:22 - pick best move so what we're going to do
23:24 - with this
23:25 - is
23:26 - we need to look at all the different
23:28 - columns we can make the move and then
23:29 - basically run the score position
23:32 - on all those columns and then pick the
23:34 - highest score that is returned
23:36 - so we will write that
23:39 - as follows
23:43 - so
23:44 - we have a function called i think valid
23:46 - locations if i'm not mistaken
23:48 - okay no we don't
23:53 - but we can find a function called valid
23:54 - locations real quick
23:57 - so i'm going to do that
23:59 - def valid load or let's just call it get
24:02 - valid locations
24:04 - so this will show us which columns we
24:06 - can actually drop it in and then
24:07 - evaluate from there that is a board
24:10 - we don't need to actually have a piece
24:12 - to figure out if it's a valid location
24:13 - or not and so valid locations is an
24:16 - empty list to begin
24:18 - and for
24:20 - column and range
24:22 - column count
24:24 - we don't have to do the minus one here
24:26 - because this is exclusive
24:28 - that that last value
24:32 - if is valid location
24:35 - of board and column
24:37 - then we want to append that specific
24:40 - column because that is a valid location
24:41 - this is just getting us a list of where
24:43 - we can drop
24:44 - just because we'll be doing a lot this a
24:46 - lot so it's going to abstract it into a
24:48 - function
24:49 - valid locations dot append
24:52 - column
24:54 - and then finally when we're done
24:56 - we'll want to return the valid locations
24:59 - okay so now we have
25:00 - valid occasions so in our
25:02 - pick best move we'll need to use this
25:05 - so
25:06 - valid locations equals get
25:09 - valid locations of the board
25:13 - and let's think what else
25:15 - uh we need to do so what we're going to
25:16 - want to do is for
25:18 - column in valid locations we want to
25:22 - figure out
25:23 - what the row so basically what we're
25:25 - going to do is
25:27 - to make our life easier is we're going
25:29 - to pretty much simulate dropping a piece
25:32 - and then have this new board that
25:34 - actually gets passed into the score
25:35 - position because we actually just taken
25:37 - a board object there so we have to kind
25:39 - of simulate each move to actually
25:41 - evaluate using that function
25:43 - so we're going to do is use our function
25:46 - get
25:47 - next open row and that takes in the
25:49 - board and
25:51 - the column
25:53 - and
25:54 - then this is something that's tricky and
25:56 - not intuitive
25:58 - is we can't just drop the piece into our
26:00 - current board
26:02 - and or we can't even do something like
26:04 - this we can't say like
26:06 - temp board equals board
26:09 - and then say okay
26:10 - let's uh drop
26:14 - drop piece
26:16 - in
26:17 - the temp board
26:19 - and row column and
26:22 - i guess peace
26:25 - we can't
26:26 - use this temp board
26:29 - to simulate the drop piece because what
26:31 - actually happens with the numpy objects
26:33 - that we're using to store all the values
26:36 - is that this temp board ends up pointing
26:38 - to the same exact memory location
26:41 - as the original board
26:43 - so what we actually need to do is make a
26:45 - copy of this board so this is creating a
26:48 - new
26:48 - memory location where our board is
26:50 - sitting and what we're doing is
26:52 - passing that new
26:54 - memory location
26:56 - into our drop piece function so any
26:58 - modifications don't modify our original
27:00 - board
27:02 - hopefully that made sense
27:04 - so drop piece
27:06 - um and then we want to
27:09 - basically find the score of the new
27:10 - board so
27:12 - i guess what happens is
27:15 - this drop piece automatically modifies
27:17 - temp board
27:19 - so we can
27:20 - just go ahead and do
27:22 - score
27:24 - equals
27:26 - score position
27:30 - of the temp board
27:32 - and whatever piece that we dropped
27:35 - and then what we'll want to do is
27:37 - basically keep track of a
27:42 - best score so we'll say
27:47 - best score and we'll set that to zero
27:49 - initially and we'll have best column
27:52 - and that'll just be like
27:57 - we'll just put it as a random
28:01 - choice of the valid locations
28:05 - and i defined valid locations below this
28:07 - so i'm going to just move these
28:09 - remove that
28:10 - down here
28:12 - okay so we have our best score and our
28:15 - best column
28:16 - best score is initially zero best column
28:18 - is just random but what we can do is
28:21 - if this score that we scored with this
28:23 - new board
28:24 - is greater than if score is greater than
28:28 - best score
28:30 - then we can set
28:32 - our new best score to score
28:36 - and we can set the new best column
28:39 - to whatever column we were checking when
28:42 - we got this new score
28:46 - okay does that make sense and then
28:48 - finally once we
28:50 - do this we'll do return
28:54 - best
28:56 - column i think that looks right
29:01 - all right let's try that out real quick
29:06 - so all we should see here is we didn't
29:08 - add that anything too complex we just
29:10 - made it preference winning horizontally
29:13 - and getting three in a rows horizontally
29:15 - so we shouldn't be looking at any sort
29:17 - of vertical
29:18 - maneuver
29:20 - okay so instead of the
29:22 - random location here i'm going to
29:24 - comment this out and do
29:27 - column
29:28 - equals
29:29 - pick best move
29:32 - of the board and i guess we're the ai
29:36 - here so i need to pass in
29:39 - the ai piece
29:42 - come on moment of truth
29:48 - i mean let's just stack on top of
29:51 - okay so now we should see it connect
29:53 - three in a row that's what we're hoping
29:54 - for
29:56 - and it did it cool so i'm going to just
29:58 - stack a top again
30:00 - the way we scored it too it should now
30:01 - preference
30:03 - filling this in after i drop
30:05 - which it did
30:06 - we got something a little bit smarter
30:08 - okay now that we have the score working
30:09 - for the horizontal moves we can kind of
30:12 - expand upon this and make it work for
30:15 - diagonal and vertical as well also do a
30:17 - little probably a little bit of cleaning
30:18 - so it
30:20 - ah where where where's the code
30:26 - okay pick us move
30:28 - struggling
30:30 - okay yeah so
30:32 - this is horizontal so we need to also do
30:36 - vertical vertical is also easy so score
30:39 - vertical do next
30:41 - so that would be force
30:43 - column
30:44 - and range
30:46 - column count
30:48 - the ones that are tricky are the
30:49 - diagonals so we're doing the exact same
30:51 - thing we did with horizontal
30:53 - uh but we're going to do it with
30:55 - vertical and then once we have it for
30:57 - each one we'll actually probably improve
31:00 - how we're actually scoring this make it
31:02 - more like i did in the we did in the
31:04 - other video
31:06 - all right for c and range column count
31:08 - let's see what else we should do we
31:10 - should then get the column array
31:14 - ray which is going to be
31:16 - similar to the last time it's going to
31:18 - be int
31:19 - i
31:21 - for
31:22 - i
31:24 - in list
31:25 - so this time we
31:27 - have the
31:28 - we want to get every
31:30 - row position for a specific column so we
31:34 - can do it like this i believe
31:37 - i think that's what we want
31:39 - and then we'll want to iterate through
31:40 - the windows
31:41 - just like we did last time but now we
31:43 - have to iterate through the the row
31:45 - window so for r in range
31:48 - row count
31:50 - minus three
31:53 - window
31:54 - equals row array
31:57 - c or r to r plus window length
32:04 - and we can copy this once we now that we
32:06 - have the window this code is oh shoot i
32:09 - didn't want to delete it this code is
32:11 - the exact same so i can just add this
32:13 - code and what we're going to ultimately
32:14 - do is abstract away
32:16 - this window counting stuff to its own
32:19 - function
32:20 - so
32:21 - okay
32:22 - so now it should if we run this again
32:26 - it should preference vertical as well
32:29 - so i'm going to block the horizontal
32:34 - and it's still stupid and it's oh it
32:36 - actually did block me that's interesting
32:38 - but i'm going to let it get
32:40 - okay so now it has two verticals in a
32:41 - row it should preference making the move
32:44 - right on top of it next
32:46 - if we did this right and it didn't so
32:47 - i'm guessing we did something screwy
32:50 - it's weird
32:53 - this is weird
32:55 - maybe it's just getting lucky
32:58 - okay it should hopefully win vertically
33:00 - let's see
33:02 - i don't know we did something wrong
33:04 - window count piece
33:08 - score plus equals hundred
33:13 - what did i do wrong here
33:16 - oh shoot i grabbed a row array this
33:19 - needs to now be column array okay sorry
33:21 - about that
33:24 - and also
33:26 - for r and range row count yeah okay that
33:28 - should be good hopefully let's see if it
33:30 - preferences vertical moves now too so
33:32 - i'm blocking the horizontal
33:35 - and now basically once it stacks oh
33:38 - shoot i'm going to block the horizontal
33:39 - again
33:41 - but
33:42 - come on
33:43 - okay
33:46 - let me play it again so you can see
33:47 - exactly what i was trying to show you
33:49 - right so it goes i'm going to block the
33:51 - horizontal
33:53 - and hopefully it stacks on top okay now
33:54 - that it's stacked on top we should
33:56 - because it doesn't have any sort of
33:57 - horizontal options it should stack
34:01 - again
34:02 - and it does and so it now should win
34:04 - vertically
34:05 - okay cool so that we kind of mainly
34:07 - validated that it was getting these
34:09 - windows correctly for the vertical
34:12 - okay
34:13 - so this was getting if we think about
34:15 - the same
34:16 - graph it was looking
34:18 - at like the sliver if we just cut off
34:21 - this one
34:24 - column it it was making a list out of
34:26 - these
34:28 - ah sorry these numbers zero
34:31 - zero two two two two
34:36 - okay
34:39 - now let's do diagonals diagonals are a
34:42 - little bit weird
34:44 - um so we'll start with the positively
34:46 - sloped diagonals so the ones that are
34:49 - low on the left side and rise up to the
34:51 - right side
34:52 - so score
34:54 - positive sloped
34:56 - diagonal
34:59 - all right so let's just run the game
35:01 - real quick just to see that how we're
35:03 - going to do this so basically if you
35:05 - look at my mouse
35:07 - we're going to look at all the possible
35:10 - ways we can do this
35:12 - diagonal slope so we can do like this we
35:16 - can move over do this move over do this
35:19 - move over do this and then rise up one
35:23 - row and do the same thing so basically
35:25 - now we have to
35:27 - um
35:29 - go from like row count minus three as
35:30 - well as column count minus three and do
35:32 - a little bit of
35:33 - manipulating like that and it's a little
35:35 - bit weird to get our windows but it
35:36 - shouldn't be too too bad so let's start
35:39 - with this so
35:41 - we're gonna iterate starting with the
35:43 - rows so for row
35:45 - r and range
35:47 - row count
35:48 - minus three because we're
35:51 - going to be cut off
35:53 - at the top because we're going up each
35:54 - time once
35:56 - and then for
35:57 - c and range
35:59 - column count
36:03 - count
36:04 - minus three
36:06 - because we can't just have a okay so
36:09 - and that's because we're going
36:11 - to the right each time four so we have
36:12 - to cut off early for that as well
36:15 - and then
36:16 - what we need to do is our window is
36:18 - going to now be
36:21 - we're going to do a little list
36:22 - comprehension to do this
36:23 - it's going to be the board
36:25 - at the row position
36:27 - and then at the column position
36:31 - and
36:32 - what we're going to do is we're going to
36:33 - have to add a little bit of
36:35 - value each time so it should start with
36:37 - 0 so we're going to we're going to just
36:38 - add some i
36:40 - plus i
36:42 - and that's going to be for i and range
36:46 - window length
36:47 - so basically what's happening is if you
36:48 - think about what i takes on if window
36:51 - length is 4
36:52 - i is going to start out at zero so
36:54 - that's going to be just
36:55 - the arth
36:57 - the
36:58 - position at r
36:59 - comma c
37:01 - but then we're gonna
37:02 - this is gonna become one so we're gonna
37:04 - increase positively one
37:06 - and one so we're going to go up and
37:09 - across
37:10 - and that will continue and we'll
37:11 - actually get our
37:12 - window
37:14 - in the proper
37:16 - um
37:17 - we'll get we'll get a windows has a 4
37:20 - that is a diagonal and this will repeat
37:24 - this window right here we'll repeat
37:26 - for all of these values so we'll end up
37:28 - getting all of the positively sloped
37:30 - diagonals
37:31 - and so
37:32 - we're going to just you can just copy
37:34 - this code here
37:40 - and we can do the same for negatively
37:42 - sloped diagonals so for r and range
37:45 - we'll do the exact same thing oh my gosh
37:47 - stop texting me
37:49 - ah
37:50 - sorry
37:51 - for c in
37:53 - range column count
37:55 - minus three and this is a little bit
37:57 - trickier because now we need to stop
37:59 - start at the top and go downwards
38:02 - so to do that
38:04 - bear with me
38:06 - we're going to want our window to be
38:07 - equal to we'll do a list comprehension
38:09 - again board
38:11 - r so this is going to be the same exact
38:14 - as before
38:15 - but now
38:17 - oh my gosh this is annoying
38:21 - wow
38:23 - i've never
38:24 - what is this crap
38:29 - sorry
38:30 - i'm gonna turn off the volume
38:32 - there we go
38:34 - okay so what i was saying was now the
38:37 - first thing we check
38:39 - is
38:40 - up here
38:42 - so that's gonna be the row
38:44 - plus one plus two plus three
38:47 - to get that position
38:52 - so that's going to be
38:55 - rho
38:56 - plus three
39:00 - and then the c i think will stay the
39:02 - same i know we're going to be going
39:03 - downwards so that's going to be c plus 3
39:06 - as well
39:08 - to get the
39:09 - [Music]
39:12 - position we're looking for because we're
39:13 - going downwards so c plus three
39:16 - do we want c plus three uh
39:21 - yeah that should work
39:25 - sorry i'm just confusing myself
39:29 - now i guess the c stays the same
39:33 - so c is normal
39:36 - and rho plus 3 and then we'll minus i
39:41 - and we will in this case we will
39:44 - plus i
39:47 - for i in range
39:49 - window length
39:53 - i think that should work let's think
39:56 - so
39:57 - if we think about all the different
39:59 - combinations
40:04 - start with this position that's the sear
40:07 - the zeroth column that's good then we go
40:10 - down one the row decreased but the
40:11 - column increased
40:13 - down again row increase but the column
40:15 - decreased down again row increase or row
40:19 - decreases but column increases so i
40:21 - think what we did here is good
40:24 - and we can score that just like we
40:26 - scored the other ones
40:28 - it's a little bit tougher to test so
40:30 - what we'll do to test
40:32 - these is we'll temporarily comment out
40:36 - the horizontal and vertical
40:38 - and just see if it
40:40 - when it has the option and sees the
40:41 - diagonal that it preferences it
40:44 - so i'll
40:46 - make it easier for it
40:48 - so if it puts it here or here we should
40:50 - see on the next time it
40:52 - putting a three in a row
40:54 - okay yep it did i made the moves a
40:57 - little bit quick
40:58 - but as we can continue
41:01 - basically oh shoot don't make that
41:04 - if i put it right here it should if we
41:06 - implemented these diagonals properly
41:08 - connect it
41:10 - yay
41:11 - we can go ahead and uncomment all this
41:13 - now that we've checked that diagonal i
41:15 - guess we should ideally check positively
41:17 - sloped two but
41:18 - i'm pretty sure we're good there
41:20 - okay and now what i recommend we do is
41:23 - we're going to add a couple more
41:24 - different ways we can score this and
41:26 - just so we don't copy all this into each
41:29 - one of these individually let's
41:31 - abstract out a new function called like
41:34 - i don't know
41:36 - uh
41:37 - find it called window evaluate window
41:39 - how about evaluate window
41:42 - and we'll take in the board
41:45 - and the piece to that or i guess not the
41:48 - board we just need the window and i
41:49 - guess the piece
41:51 - for that
41:52 - so this is going to be the exact same
41:54 - thing as we did before so
41:56 - if window dot count
41:58 - piece
42:00 - equals equals four
42:02 - score plus equals
42:05 - 100
42:06 - alif
42:08 - window.count
42:10 - piece
42:12 - equals equals three
42:14 - and window dot count
42:17 - is empty
42:19 - equals equals one
42:20 - score
42:22 - plus c equals ten
42:23 - let's think what else we should have
42:25 - should also have an lf for window dot
42:28 - count piece
42:31 - equals equals two
42:33 - i guess we it doesn't really matter if
42:35 - we use if or l if i don't think here and
42:37 - window dot count
42:39 - empty
42:40 - actually it does
42:41 - oh no it doesn't i don't think it does
42:44 - empty
42:45 - equals equals two
42:47 - reduced score plus equals five and these
42:50 - values these are kind of arbitrary and
42:53 - i'm fine leaving them as kind of
42:54 - arbitrary guys i don't really need to
42:56 - extract these out into their own
42:57 - variables i guess i could if i wanted to
42:59 - but basically these are the type of
43:01 - values you play around with as you kind
43:02 - of tune and try to make your ai better
43:05 - let's see what else we could do we could
43:07 - also have like
43:10 - i guess
43:11 - inverse
43:12 - piece
43:13 - so this would be the opponent piece so i
43:14 - can just call it
43:16 - component piece
43:19 - equals
43:22 - we'll just say
43:26 - player piece
43:28 - opponent piece equals player piece
43:30 - and if
43:32 - piece
43:33 - equals equals
43:35 - player piece then we just need to switch
43:36 - it so that would be then opponent piece
43:40 - would be
43:42 - equal to ai piece
43:44 - if that made sense what i did i just was
43:46 - saying that okay let's assume we're the
43:47 - ai and set the opponent piece to be
43:50 - player piece but if we're not the ai and
43:52 - we're the player and we're adding the
43:54 - window then the opponent piece should be
43:56 - aips so we could also do is something
43:58 - like if window
44:01 - dot count
44:02 - opponent
44:03 - piece
44:06 - equals equals three and window count
44:10 - dot opponent or win account empty
44:14 - equals equals one and then that means
44:16 - the opponent has a three in a row and we
44:18 - could do like score
44:20 - minus equals eight let's say
44:23 - so it's like we weigh us getting a three
44:25 - in a row more than we weigh
44:27 - the opponent getting a three in a row
44:29 - okay just to finish up this function
44:32 - we should initialize score equals zero
44:35 - we'll return score at the end and this
44:37 - is just going to be so then when we
44:39 - actually go into the score position we
44:41 - can delete these lines and what we'll
44:43 - actually do is do score plus equals
44:46 - evaluate
44:47 - window
44:49 - of
44:50 - window
44:51 - [Music]
44:53 - piece
44:54 - and we just copy this line here for each
44:56 - of the other locations that we added
44:58 - these logic
45:01 - cool
45:04 - cool
45:06 - cool all right let's see what happens
45:13 - oh no
45:14 - plus equals
45:16 - none type
45:18 - oh yeah should probably return the score
45:24 - okay so
45:25 - we should be seeing some preference
45:29 - so it should probably want to get this
45:30 - three in a row
45:33 - yep
45:34 - okay
45:42 - will it block me
45:43 - so it doesn't seem to be blocking me
45:45 - let's see if it preferences diagonal
45:47 - downwards
45:50 - i guess it's diagonal that way let's see
45:52 - if it preferences diagonal downwards now
45:55 - cool it's looking pretty good
45:57 - however it's not blocking me so that is
45:59 - an issue
46:08 - so it's not blocking me and the reason
46:09 - it's not blocking me i just realized is
46:11 - if we look at this
46:13 - if we think about how this evaluate
46:15 - window is working we're only calling it
46:16 - for the ai
46:18 - so if the ai ever sees the opponent has
46:21 - three and the window count is one
46:24 - empty is one then the opponent already
46:27 - has three so would be able to win in the
46:29 - next case so in this case it would be
46:31 - preferencing putting three in a row over
46:34 - blocking the opponent so watch what
46:35 - happens if i make this like
46:37 - negative 80. now it's going to
46:40 - preference and i also will have to we'll
46:42 - have to
46:44 - change the best score to be some sort of
46:45 - low negative number to start
46:47 - just so it doesn't screw up if we get
46:50 - a negative here
46:52 - now it should block
46:53 - always block
46:55 - if i ever get
46:56 - three in a row
46:59 - yeah see that cool
47:01 - i don't know if we'll keep this in when
47:02 - we go to mini max and we're gonna go to
47:04 - min max
47:05 - right around right really soon
47:07 - the last thing i want to add before we
47:09 - go to
47:10 - implementing the min max algorithm is
47:12 - just
47:14 - scoring the center columns and you know
47:16 - adding preference for center pieces
47:18 - because
47:19 - that's what's going to create more
47:21 - opportunities with the diagonals and the
47:22 - horizontals is if you have the center
47:25 - the center pieces
47:28 - okay so we can get our center array so
47:31 - score center and i guess this should be
47:36 - i'm going to move this comment
47:40 - right below the score equals zero
47:45 - move this up a bit and now i'm going to
47:47 - add the
47:48 - score center column
47:51 - so we're going to create a center array
47:53 - just like we were kind of making the row
47:54 - or the column arrays
47:57 - within the score vertical
48:00 - so we're going to do equals
48:03 - int
48:03 - i
48:05 - for i and list
48:07 - we want the board and we want every row
48:10 - position but we only want the center
48:12 - column so we can do column count
48:16 - and then we could just you know mainly
48:17 - think about it 0 1 2
48:20 - 3 would be the middle but just to kind
48:22 - of not have magic numbers i'm going to
48:24 - do floor division by 2.
48:27 - so that will get the
48:28 - the middle
48:29 - column
48:31 - and then what we want to do is just do
48:33 - center
48:35 - count i guess
48:36 - equals center array
48:40 - dot count piece
48:42 - and then we'll just add to our score
48:44 - i don't know
48:46 - three points or so
48:48 - let's see i i kind of did some weird
48:51 - numbers here
48:52 - i'm going to add like six
48:55 - for each piece in the center so center
48:59 - or score
49:01 - plus equals six let's say and these
49:03 - numbers are all going to change so don't
49:05 - worry too much about all the score
49:07 - increases this is something you play
49:09 - around with
49:10 - okay let's see if it's preferencing
49:11 - center now
49:16 - it should not have gone there for us
49:17 - referencing center
49:20 - score plus equals six
49:23 - let's really crank up this score real
49:25 - quick
49:26 - and see if it works
49:31 - it's weird
49:33 - yeah something's goofing
49:37 - oh
49:39 - okay sorry
49:40 - i was doing plus equals six but i was it
49:42 - should be plus equals
49:46 - center count
49:48 - times
49:50 - six right so if you had two it'd be
49:52 - twelve plus twelve it would be
49:54 - um if you had
49:55 - three you'd be plus 18 etc
50:01 - okay now it looks like it's preferencing
50:03 - center
50:05 - we'll see
50:08 - should block okay cool
50:10 - now i think it should go center if i'm
50:12 - not mistaken
50:14 - yeah cool and probably should go center
50:16 - again
50:17 - if i'm not mistaken
50:23 - okay i guess that created more diagonals
50:25 - but
50:26 - okay center cool should block and go
50:28 - center cool i think that's
50:31 - accounting for the center all right with
50:32 - that i think we're ready to move on to
50:34 - the min max algorithm and what i think
50:36 - is helpful
50:38 - at least when i was implementing this is
50:40 - i went ahead and just was reviewing the
50:43 - wikipedia page on minimax
50:46 - so
50:46 - you know
50:47 - if you didn't watch the video i posted
50:49 - minibacks is basically
50:51 - a way so that we can look down the
50:53 - branches of any sort of
50:55 - rule based game like chess checkers
50:58 - and in our case connect four
51:00 - so we can basically look down at
51:02 - branches and evaluate using our score
51:04 - function the best branch that we can
51:06 - guarantee getting
51:08 - so what i recommend we do is go ahead
51:11 - and go to the pseudocode
51:13 - and this is all we really have to
51:14 - implement so
51:17 - function minimax node depth maximizing
51:20 - player so the node in the r case is
51:23 - going to be the board depth is how far
51:25 - we want to search down in our game and
51:27 - maximizing player is going to be true
51:29 - for the ai and false
51:31 - when we're looking at the player's move
51:34 - so let's go ahead and implement this
51:37 - and i'll be kind of popping this window
51:39 - back in and out okay so score position
51:41 - is good let's define mini max
51:46 - uh
51:50 - uh
51:51 - okay
51:54 - def
51:55 - mini max so we're going to pass in the
51:58 - board
52:00 - we're going to pass in the depth and
52:02 - we're going to pass up in the maximizing
52:05 - player
52:08 - and i'm going to just do pass for now
52:09 - okay what do we need to do next in this
52:13 - if depth depth equals 0 or node is a
52:16 - terminal node so what is a terminal node
52:18 - in our case well that's whenever
52:20 - [Music]
52:21 - a game is one or i guess if we get to
52:23 - the end of the game those would be
52:24 - terminal node conditions so then we want
52:27 - to return the heuristic value of that
52:29 - node
52:30 - and else we want to kind of recursively
52:32 - check our tree
52:34 - like you see in this diagram down in the
52:36 - bottom right
52:37 - and find the best score so that's what's
52:39 - happening down here let's start off
52:41 - though with the i guess if steps equals
52:44 - zero condition that's when we're going
52:46 - to be returning the
52:48 - score position function score
52:51 - okay so what are
52:54 - okay so let's do this
52:58 - if depth equals equals zero
53:03 - or
53:04 - terminal node
53:07 - so this terminal node we haven't defined
53:08 - yet so let's just define it so what we
53:10 - just said was
53:11 - terminal nodes would be
53:13 - us winning
53:14 - the opponent winning or
53:16 - you know you've used all the pieces in
53:18 - the game so let's do those
53:23 - so i'm going to find another function
53:25 - sorry
53:26 - is terminal
53:28 - node and that'll just be true if it is a
53:30 - terminal node and false if it is not now
53:32 - taken aboard
53:34 - so what are the terminal node conditions
53:36 - well
53:38 - we have this winning move function
53:42 - right here so basically we can use this
53:44 - to our advantage so if
53:46 - it's a if this returns true for either
53:48 - of the pieces then it would be a
53:50 - terminal node so those will be two of
53:51 - our conditions
53:53 - so
53:54 - we want to return winning move
53:57 - board
53:58 - player piece
54:03 - or
54:04 - winning move
54:08 - board
54:10 - uh the
54:11 - ai piece
54:13 - or the final condition is that there's
54:15 - no more valid moves in the game so the
54:17 - board is completely filled up so what we
54:18 - can do in this is we can say length
54:21 - get valid locations
54:24 - of
54:25 - the board
54:26 - and that length should be zero if it's a
54:29 - terminal node
54:30 - so
54:31 - this statement as is will return true if
54:34 - it is a terminal node and false
54:35 - otherwise it's nice one liner so what
54:38 - we're now going to do is
54:41 - i guess valid locations
54:43 - equals get valid locations
54:47 - of the board
54:49 - and then we're going to do is terminal
54:52 - will be
54:52 - [Music]
54:56 - equal to is terminal node
54:59 - of the board
55:00 - so now we can do if depth equals zero or
55:03 - terminal node or i guess or
55:07 - is terminal
55:09 - okay what do we want to do in this case
55:12 - well there's three conditions
55:15 - so if we are the ai
55:17 - then
55:18 - the first thing we want to do is
55:22 - we want to if it is a winning move for
55:24 - us the ai we want to do if
55:27 - winning move
55:28 - so this is basically
55:30 - just figuring out which case of these
55:32 - three we're in
55:35 - if winning move
55:36 - uh
55:38 - board
55:40 - ai piece
55:43 - then we want to
55:46 - return
55:50 - a high score so return like
55:53 - you know a really big number
55:56 - lf winning move
55:59 - board
56:00 - player we want to return a really our
56:04 - player piece sorry
56:08 - we want to return a very low score
56:12 - and we're going to augment this so it
56:13 - also has a position but
56:15 - you'll see that in a sec
56:17 - okay turn a really low score if it's
56:19 - losing condition and then else
56:22 - this is going to be when we
56:24 - evaluate our score position this is a
56:27 - board that is not a winning condition so
56:30 - and it's not a terminal condition so we
56:31 - actually want to get the score for it so
56:34 - we're going to do
56:38 - and i'm really just following if you're
56:40 - getting confused with what i'm doing
56:42 - i'm doing this step
56:44 - of
56:46 - the mini max algorithm and i'm just
56:49 - finding the heuristic value of the node
56:52 - and these are kind of two edge cases the
56:54 - winning move cases
56:55 - and i'm just handling them separately i
56:57 - guess they could be kind of factored
56:59 - into my
57:00 - mini max but
57:02 - just
57:04 - because
57:07 - you know we're only really looking at
57:09 - the opponents uh it might work if i
57:11 - didn't handle these separately i just
57:14 - in my head it makes it easier if i
57:15 - handle these separately
57:17 - then finally the else condition is
57:21 - when we want to
57:24 - i guess the else condition here would be
57:27 - the game is over so that's just kind of
57:29 - like a weird case where we would return
57:33 - zero i suppose because you can't really
57:35 - do anything from there
57:38 - all right
57:39 - cool so we have the
57:42 - that's part of it and now the final
57:44 - thing is
57:46 - if it is not
57:49 - oh sorry
57:51 - if is terminal
57:53 - that's the is terminal cases
57:56 - either we win the opponent wins
57:58 - or the game is over
58:01 - those are the three cases so i can just
58:02 - even mark this game is over
58:06 - comma no more valid moves
58:09 - the other case is the depth of zero so
58:12 - we can just do else here and that's
58:13 - going to be depth is zero
58:16 - and in that case we want to find the
58:18 - heuristic value of the board so what
58:20 - we're going to do is just do return
58:22 - score
58:23 - positions
58:26 - uh
58:27 - score position of the board
58:30 - and
58:32 - i guess whatever piece we dropped
58:34 - so in our case it would be the ai's
58:37 - piece i guess maybe it would be good to
58:42 - specify this but i'm just going to
58:45 - keep it as the ai piece right now you
58:47 - can fix it if you need
58:48 - to all right so that's
58:51 - the first part of the mini max
58:55 - and sorry if this i hopefully this is
58:56 - not too confusing it'll all kind of fit
58:59 - together once we
59:00 - you know get through the rest of it
59:03 - all right let's finish implementing the
59:05 - minimax so let's do the bottom half of
59:07 - that what i was just highlighting on the
59:08 - wikipedia page and also this should be
59:11 - ai piece
59:14 - the ai and the player without the piece
59:17 - is just only was used for the turn
59:19 - um
59:21 - okay
59:22 - all right so else
59:27 - let's see what does that say
59:29 - if maximizing player then
59:34 - and we returned out of this so this week
59:37 - if you get into this if statement you'll
59:40 - not get into the other ones that we're
59:41 - about to define so
59:43 - if
59:45 - maximizing player and i'm going to just
59:47 - actually i think what will be easiest is
59:49 - if i just keep this on the screen
59:57 - where's the pseudocode
60:01 - pseudocode okay cool
60:04 - all right so we have the pseudocode on
60:06 - the screen
60:07 - and
60:08 - we have the code over here so
60:10 - oh gosh now i can make this the other
60:13 - half okay
60:15 - not too bad all right so if
60:17 - maximizing player i'm following right
60:19 - here
60:21 - it's amazing player
60:25 - then we want to initialize the score to
60:28 - some really low value
60:30 - so what we could do here
60:34 - is
60:35 - i think we actually use
60:37 - if we actually want to specify negative
60:39 - infinity and positive infinity i think
60:41 - we can do instead
60:45 - is we can do
60:48 - value equals math dot infinity that
60:52 - works and i can actually just do
60:53 - negative math dot infinity okay
60:57 - so that covers that
60:58 - and then for each child of node so
61:00 - that's for each position we can drop in
61:02 - our connect four game so what we're
61:04 - going to do here is we're going to do
61:06 - for column
61:08 - invalid locations
61:11 - which i already have to find up here
61:13 - fortunately for us
61:15 - column invalid locations
61:19 - comma row
61:21 - equals get
61:22 - next open row
61:24 - of the board and that specific column
61:26 - that we're looking at
61:28 - and then as before with when we're just
61:30 - doing this the score position function
61:32 - we need to copy the board so
61:34 - board dot copy
61:37 - just because otherwise we'll use the
61:38 - exact same memory location that the
61:40 - board is on so it will really screw up
61:42 - when we're you know recursively doing
61:44 - this
61:45 - okay and we can go ahead and drop a
61:47 - piece in that position v copy
61:51 - row column and we are the if we're the
61:54 - maximizing player then we're the ai
61:56 - piece
61:57 - all right
61:59 - and so what's going to happen here is
62:01 - we're going to have a new score
62:06 - score
62:07 - which is going to be equal to the mini
62:10 - max
62:12 - which is going to be the max so if you
62:14 - look at this it's going to be the max of
62:15 - the current value which is negative math
62:18 - infinity
62:19 - and minimax of depth minus 1.
62:23 - so
62:26 - new score i guess would just be
62:28 - the max of
62:31 - current score which was value
62:33 - and minimax
62:35 - of
62:36 - this is our recursive call here of the
62:38 - board copy
62:41 - depth minus 1
62:44 - and i guess we do false now because
62:46 - we're no longer the
62:48 - maximizing player now the minimizing
62:50 - player
62:51 - cool and then finally what we'll want to
62:53 - do is return
62:56 - the new score
62:58 - so that's the max of the value and the
63:01 - minimax and we want to do the same thing
63:04 - for
63:06 - the minimizing player so else
63:10 - we know we are the minimizing player
63:14 - and that is the code right here
63:17 - we want to initialize the value to
63:20 - positive infinity
63:25 - and now copy the same thing for column
63:27 - invalid
63:28 - locations
63:30 - same as before row equals get
63:34 - next open row
63:36 - of board and column
63:39 - we need to copy the board again
63:41 - because we don't want to use that same
63:43 - memory location otherwise we're going to
63:44 - have issues when we try to recurse back
63:47 - up the tree
63:48 - drop
63:49 - piece
63:50 - equals
63:53 - oh shoot
63:54 - board copy
63:56 - row column and now we are going to be
63:59 - the
64:00 - minimizing player
64:02 - so what we need to do is actually make
64:04 - this piece
64:06 - the player piece
64:11 - and same before the new score though is
64:14 - going to be because when we are if we
64:16 - remember this
64:18 - the minimizing player is trying to take
64:19 - the lowest value so if you see this node
64:21 - right here this 10
64:23 - 10 and plus infinity 10 is the lower
64:25 - node so it always take that
64:30 - so
64:31 - in the minimizing player case we want to
64:33 - take the the new score would be
64:36 - the min
64:38 - of the value and minimax
64:42 - of
64:43 - word copy
64:45 - depth minus one and then we want to do
64:48 - true
64:49 - for
64:50 - now switching to the maximizing player
64:52 - so this
64:54 - this false and this true is what's
64:56 - allowing us to switch back and forth
64:58 - between this maximizing player and the
65:01 - minimizing player in the context of the
65:03 - mini max algorithm
65:06 - and make sure you
65:07 - understand the mini max algorithm watch
65:09 - the video that i've posted previously on
65:11 - it or just kind of review this wikipedia
65:13 - page to kind of get a feel for how it
65:15 - works because that is crucially
65:16 - important for understanding how this new
65:19 - ai is working
65:22 - okay and we want to return
65:26 - value
65:27 - or the new score
65:30 - cool i think this is about it right
65:35 - i think so
65:37 - however the one issue i have right now
65:39 - as i look at this
65:40 - is we're returning the score which is
65:43 - good to know like how good of a move can
65:46 - we make
65:48 - at a certain location but we also need
65:50 - to augment the score with the column
65:53 - that produces that score
65:55 - so in addition to just producing
65:58 - or just figuring out what the best score
66:00 - is we need to figure out which column
66:02 - produces that score so to do that we're
66:05 - going to just actually get rid of this
66:07 - max and min we're going to just break it
66:09 - out a bit just it's easier to keep track
66:12 - of
66:13 - what we need
66:14 - so we're going to say that the new score
66:17 - is equal to the mini max that
66:20 - same thing for this
66:24 - and
66:26 - instead of doing it in just one line
66:27 - we're going to just bring it to the new
66:28 - line so if new score is
66:33 - greater than the value
66:36 - value equals new score
66:39 - so this is the same thing right now if
66:41 - we kept it like this this is the same
66:43 - thing as the max
66:45 - the one liner we just had but we also
66:47 - want to do
66:48 - something like column
66:50 - so this this column right here is like
66:52 - the best column you can get
66:54 - so we could initialize this to
66:58 - just a random choice of the
67:02 - valid locations
67:04 - random.choicevalid locations
67:07 - and same thing for down here
67:10 - column
67:11 - equals random.choice
67:13 - of the valid locations
67:18 - all right so now what we have is column
67:20 - equals whatever column we are currently
67:23 - iterating on that gave us this new score
67:26 - when we recursively did the mini max
67:28 - algorithm
67:31 - so that would be call
67:34 - and
67:36 - okay that looks i think this is good
67:37 - here
67:39 - we also know need to now
67:42 - implement it down here same thing so
67:46 - this time it would be if new score
67:50 - is less than the value
67:57 - we want to do
67:59 - value equals
68:01 - new score
68:04 - and
68:05 - column
68:06 - equals call
68:08 - and we want to
68:09 - [Music]
68:11 - okay and then finally what we have to do
68:13 - is instead of just returning the score
68:15 - we want to return both
68:18 - the score and the column that produces
68:20 - that score so we'll return a two pole so
68:22 - we'll do
68:23 - column
68:24 - and new score
68:27 - or i guess value is our final thing that
68:29 - we return
68:32 - same thing here
68:33 - turn column
68:35 - and value
68:36 - and then up here
68:39 - these are the terminal conditions so if
68:41 - we get a terminal condition
68:45 - we don't actually
68:46 - know which column produces the terminal
68:48 - location because it's just looking at
68:50 - the board particular but we can get that
68:52 - very easily because
68:55 - we would get it through this
68:57 - so basically what we can do
69:00 - yeah so basically when we returned this
69:03 - new score
69:06 - all right yeah so we're gonna augment
69:08 - these
69:10 - none
69:12 - just has to basically all be the same
69:13 - format even though these wouldn't
69:15 - actually produce
69:16 - a column value
69:23 - none
69:24 - zero
69:26 - okay so we don't know which column
69:28 - produces those
69:30 - and basically what we need to do now is
69:32 - if we want to adjust the score we need
69:33 - to get the first index
69:35 - we need to get the first index here
69:39 - is that it i think that might be it
69:43 - and then i guess right here too this
69:45 - would just give us a score
69:47 - so in this case two we need to do
69:50 - none comma score positions
69:53 - so basically we're always because this
69:55 - is a recursive function we always need
69:57 - it to return the same format so we're
69:59 - now just saying turn us the
70:01 - the best score
70:03 - in the column that produces the best
70:05 - score
70:07 - cool i think this is it we can delete
70:10 - this pass
70:11 - so let's go ahead and real quick test
70:14 - out our s you know our first attempt at
70:17 - the mini max
70:18 - and to do that we can just go down to
70:20 - here and instead of best pick best move
70:23 - what we're going to do is
70:25 - do column
70:26 - equals minimax
70:29 - of
70:31 - zero
70:32 - or actually what am i thinking it's
70:34 - bored
70:36 - then it is depth so let's just for sake
70:39 - of simplicity
70:40 - we'll start with depth
70:42 - equals two
70:44 - and then we are the maximizing player so
70:46 - that is true
70:48 - let's see if this works
70:53 - nope
70:55 - damn it
70:56 - is the location
70:58 - where we get the error
71:06 - where do we get this error too many
71:08 - indices for array
71:15 - 267.
71:18 - if is valid location
71:22 - oh shoot let's see
71:30 - oh all right yeah sorry i was just
71:31 - trying to get the column out of here but
71:33 - we actually get the column
71:35 - and the mini max score so i kind of have
71:38 - to unpack the tuple now it's not just
71:41 - one thing it returns
71:44 - okay
71:49 - all right so what we should see now
71:51 - i think at depth of two it should be
71:54 - smart enough to block
71:57 - oh i guess not yet
71:58 - i was hoping that it would block
72:01 - me from getting this
72:03 - situation where i could win on either
72:04 - side
72:05 - i'm gonna try increasing the depth to
72:07 - three and see if it does that
72:12 - all right so what i'm trying to see is
72:14 - if it's looking ahead in the future and
72:15 - how we can tell that is if it's looking
72:17 - ahead in the future it should prevent us
72:19 - from getting
72:20 - winds that can
72:21 - we can kind of
72:23 - have two spots
72:24 - where we win so
72:26 - if i drop it here it needs to block me
72:28 - so that i can't get the horizontal three
72:30 - on the bottom
72:31 - still is not doing it what the heck
72:38 - it might be some sort of error i'm going
72:40 - to
72:40 - just try one more time maybe seeing if
72:43 - it's not looking far enough in the
72:44 - future and do this depth four
72:48 - so this is how far of a branch it's
72:49 - checking
72:51 - yeah it's definitely having some
72:55 - issues
72:56 - here
72:57 - it did win that time but
72:59 - it's always picking
73:01 - zero
73:02 - it's always picking the farthest to the
73:04 - left to move
73:06 - why is that the reason it is always
73:08 - picking the farthest to the left even at
73:10 - depth of four is let's go up and just
73:14 - check
73:17 - why is my mouse being so fidgety today
73:19 - won't scroll up for me
73:25 - is okay i see it
73:30 - if we look at where we are returning
73:32 - this column and value it is inside of
73:35 - the for loop so it's
73:37 - on the first column basically and also
73:40 - we initialize the value to negative
73:42 - infinity so it's basically okay it's
73:43 - figuring out that whatever score is on
73:45 - the farthest to the left column it's
73:47 - going to be bigger than negative
73:48 - infinity so it's setting that column
73:50 - here and then returning it immediately
73:52 - what we need to do is just backspace
73:54 - this once
73:56 - and hopefully now it should be pretty
73:57 - good and i probably don't even need to
73:59 - go depth of four
74:01 - think about i'd go to like depth of
74:02 - three and it will still block just fine
74:09 - okay
74:10 - i kind of want to go first just because
74:11 - i feel like i'll see it easier
74:17 - okay so now it needs to block one of my
74:20 - horizontals which it does now which is
74:22 - good it needs a block cool that's
74:25 - looking good
74:27 - okay let's see if it's looking into the
74:29 - future it should put its piece right
74:31 - here next if i put it up here
74:34 - cool it's looking good it's like smart
74:37 - enough to know that like
74:38 - this position right here where my mouse
74:40 - is was the best spot to put it because
74:42 - that gives us a win here and here so if
74:44 - it looks in the future and knows it's
74:46 - going to win it's not going to be easily
74:47 - blocked by me
74:49 - looking good cool
74:55 - all right uh
74:58 - real quick
75:00 - um just because i'm not positive how i
75:02 - feel about the values that i currently
75:04 - set all these things up here in the
75:06 - score positions function too
75:10 - or i guess evaluate window i'm going to
75:12 - just change these to what i set when i
75:13 - was playing around with this so the
75:15 - window count equals 4. this actually is
75:17 - pretty irrelevant at this point
75:20 - i think the only reason this would play
75:22 - in is if we
75:24 - set the depth equal to zero
75:27 - and it had to use just this evaluate
75:30 - window so i'm going to leave this in
75:31 - here but this
75:32 - know that this is probably not too
75:34 - important anymore i'll still keep this
75:36 - value
75:37 - okay
75:38 - three and one so three in a row i'm
75:41 - going to give this a weight of five
75:45 - two in a row i'm going to give this a
75:46 - weight of two but remember that it's in
75:49 - multiple directions so you could have
75:50 - multiple twos in a row and it adds up
75:54 - uh opponent
75:56 - equaling three and one this is not as
75:58 - important anymore
75:59 - because
76:02 - and also i have to kind of make this a
76:03 - smaller value because
76:05 - it's this is factored into the terminal
76:07 - condition case so it will look ahead in
76:09 - the future and make sure that it's not
76:11 - losing
76:12 - so i'm going to make that minus four
76:14 - then the other thing that i change to is
76:16 - instead of making this times six i'm
76:18 - going to make the center column worth
76:19 - plus three and these are values you
76:21 - should play around with so if you really
76:22 - want an expert level ai play around with
76:24 - these values
76:25 - but honestly i feel like this ai right
76:28 - now
76:31 - like i'm gonna just play a game like try
76:33 - to
76:33 - win
76:35 - i guess it's still not amazing i guess
76:37 - it's depth three right now but
76:41 - yeah like look it like it's making
76:42 - pretty good moves
76:46 - and it's like gonna know to win if i put
76:48 - it there i think this is a pretty good
76:49 - ai at this point
76:51 - uh to make it even better what we can do
76:53 - is increase the depth of how far it's
76:55 - looking
76:58 - uh where is that so if you make it four
77:01 - it's looking if we think about how the
77:03 - mini max works uh
77:06 - it's looking farther down in this tree
77:08 - so this four would represent how far
77:10 - it's looking down it's like right now
77:12 - we're at depth four so that's why it's
77:13 - looking this far down and
77:15 - you can think of this graph as being all
77:17 - the possible ways a
77:19 - connect 4 board can work
77:21 - so depth 4 let's see
77:24 - this would be even better of an ai
77:26 - because it's looking farther in the
77:27 - future
77:33 - and we could even make this better let's
77:35 - just go to depth 5 and see what happens
77:44 - okay i kind of have a problem i don't
77:46 - know if you noticed it but
77:48 - i did depth five
77:50 - and it seems like it's just oh it
77:52 - finally made a move
77:54 - it just takes forever to make a move at
77:56 - this point
77:58 - try to like think about why that is
78:04 - you can even pause the video if you're
78:05 - trying to like think about why that is
78:08 - but yeah i mean if we're going it
78:12 - if we're doing depth five and we think
78:14 - about what the minimax is doing it is
78:17 - branching out
78:18 - at every step so from the top of my
78:20 - hands is the terminal node
78:22 - every time we do a higher oh my god i'm
78:24 - trying to be even every time we do a
78:25 - higher depth
78:28 - we expand exponentially more branches so
78:31 - this is basically like seven to the
78:32 - fifth power
78:34 - or maybe even six power because we also
78:35 - look at zero
78:37 - so it is a lot of branches to expand so
78:40 - it's going to run slowly so 5 is
78:42 - probably the max you can really do
78:43 - otherwise if you go to 6 your computer
78:46 - is just going to explode
78:48 - not really but basically it's probably
78:50 - going to freeze up and crash on you if
78:52 - you go to 6.
78:54 - so this gets us to the final thing i'm
78:56 - going to cover in the video
78:58 - and that is the alpha beta pruning so
79:00 - it's basically
79:01 - allowing us to go to deeper depth by
79:03 - eliminating a lot of the moves we have
79:05 - to look at and i didn't actually cover
79:07 - this in the video i posted about how
79:09 - does a board game ai work so check out a
79:11 - video i posted in the description on
79:14 - kind of the
79:15 - overview of it
79:17 - uh at a very high level yeah basically
79:19 - it is
79:20 - figuring out that
79:23 - there are certain branches that a
79:25 - computer is just or an ai is just not
79:27 - likely to take
79:28 - if it realizes like in a move if it goes
79:30 - a certain position that it loses it's
79:32 - not going to go down that branch so you
79:33 - can just not look further down into the
79:36 - future there
79:38 - yeah so check out that video real quick
79:40 - on alpha beta pruning and then once you
79:42 - watch the video we will implement alpha
79:43 - beta pruding to allow us to more quickly
79:47 - search the depths we want okay alpha
79:49 - beta pruning so just like
79:52 - when we are doing the mini max
79:54 - what i recommend is
79:57 - look going to the alphabetical pruning
79:59 - wikipedia page
80:03 - and there's also pseudocode there so i
80:04 - think that's helpful the pseudocode is
80:06 - helpful to follow
80:08 - but it's just basically an adaptation of
80:11 - what we've already seen with the minimax
80:14 - but now we have these two additional
80:15 - parameters alpha and beta and you should
80:18 - understand what these are now that
80:19 - you've hopefully watched the video or
80:21 - already had some knowledge about how it
80:23 - worked so
80:25 - we're gonna go up to
80:28 - our
80:32 - sorry i
80:34 - have this on another screen because i
80:36 - don't want to screw this step up
80:38 - um
80:39 - you should
80:40 - yeah go to your mini max function and
80:42 - we're going to be adding our alpha
80:45 - and our beta to that function
80:48 - and so we're also going to have to pass
80:49 - this into
80:51 - all of our
80:53 - other calls of it alpha beta
80:57 - and right here
80:59 - alpha beta
81:02 - and we'll also have to do it down here
81:05 - when we actually call this
81:07 - and if we remember
81:09 - the alpha and beta should be initialized
81:11 - to
81:13 - negative math infinity
81:15 - and this is just i'm looking at
81:18 - right here the initial call right here
81:21 - negative infinity
81:23 - negative math infinity
81:25 - math infinity and true so that's the
81:28 - initial call
81:30 - and then all right so let's define this
81:32 - new mini max function with alpha beta
81:34 - this should be a comma here
81:36 - all right so
81:39 - let's see what it's doing so basically
81:41 - all we're doing is that in addition to
81:43 - getting our max value we also are just
81:47 - evaluating the alpha
81:50 - so we can do this below the new score
81:52 - stuff
81:52 - so alpha
81:54 - equals max of
81:58 - the new score
81:59 - or i guess the value at this point we
82:01 - can do value because it would have
82:02 - changed value and alpha
82:06 - and then which we want to do is
82:14 - or i'll just do it in the same format
82:15 - that wikipedia is doing so alpha
82:20 - and the value
82:23 - okay and then what we want to do is if
82:26 - alpha is greater than or equal to beta
82:29 - then we want to break out of our loop
82:34 - and that is good
82:36 - and then same thing down here
82:40 - now
82:41 - we are the minimizing player so we want
82:43 - to do beta equals the min
82:45 - of the beta and the value
82:48 - and if we find that
82:50 - alpha is greater than or equal to beta
82:53 - then we've reached a condition where
82:54 - we're going to just break off because we
82:56 - don't need to look any more
82:57 - further in the tree
82:59 - and we'll break
83:02 - so i think that's all we need to do to
83:04 - implement alpha beta it's pretty
83:05 - straightforward after you have the mini
83:07 - max up and so let's run this real quick
83:11 - i'll probably get an error we'll see
83:14 - ah
83:15 - shoot i need to not use my track pad
83:16 - because
83:22 - keep accidentally dropping pieces
83:25 - okay it has a piece there this should
83:26 - drop quickly if before depth five was
83:28 - taking a while now that we did this it
83:30 - should drop quickly
83:33 - which was pretty good it was pretty good
83:37 - reasonable more reasonable than it was
83:38 - before for sure
83:41 - so i think that is looking pretty good
83:44 - and what we can honestly even do is now
83:47 - that we're searching so far
83:49 - what we can do is
83:51 - we have that initial time delay
83:54 - i can actually just comment that out at
83:56 - this point
83:57 - so this should be pretty quick and we're
83:59 - going at depth 5 which is pretty far
84:01 - down
84:04 - yeah it's not bad
84:06 - i think even if we go to depth six it's
84:08 - not too bad either but like before if we
84:10 - went to depth six it would take forever
84:15 - we'll see it also depends on what type
84:17 - of processing power you have
84:20 - so i'm going to try depth six here
84:23 - it's taken a bit for sure did i do this
84:26 - right
84:28 - it
84:29 - but not nearly as long as it was taken
84:31 - before
84:32 - yeah the the alpha beta pruning looks
84:34 - good and one thing i just realized is
84:35 - that
84:36 - um
84:37 - you're gonna see more performance gains
84:39 - kind of as the game goes on further
84:40 - because there's gonna be at the start of
84:41 - the game there's more possibilities and
84:43 - less places that can break out of that
84:45 - alpha beta thing but as a game goes kind
84:47 - of on you'll have more breaks frequently
84:49 - so the performance gains will be
84:51 - definitely seen as the game continues on
84:56 - all right that's we're going to end um
84:59 - what i would say too is like we have a
85:01 - pretty dang good ai
85:03 - as is but i didn't there are additional
85:06 - things we could do to make it even
85:07 - better so a couple ideas that i'm
85:10 - thinking about is uh one thing is that
85:13 - currently it doesn't weight
85:15 - lower like so if you think of the game
85:17 - i'm gonna run it real quick
85:22 - if you think of these rows down at the
85:24 - bottom it's like this first row here
85:26 - the second row etc it should we should
85:28 - wait
85:30 - um
85:32 - we should wait
85:35 - what am i trying to say we should wait
85:37 - the lower wins so like when you have
85:38 - three in a row that's lower that should
85:40 - probably be weighted higher than if you
85:42 - have a three in a row that's at the top
85:44 - here and that's because you know as the
85:48 - game fills up people have to push them
85:50 - on the lower rows before the upper rows
85:53 - so like if you are strategically playing
85:55 - as an ai you would want to like
85:58 - put your pieces down lower so you get
86:00 - more chances to win also what i
86:02 - recommend is you can make it even better
86:04 - than that by watching the even odd
86:07 - connect four strategy that i posted
86:08 - that's like a really cool strategy that
86:10 - you could try to implement with the ai
86:13 - um you could also
86:15 - let me think i mean there's other things
86:16 - you could play around with
86:19 - off the top of my head i'm kind of
86:20 - spacing right now but the values all
86:23 - could be tuned of the scores
86:25 - um
86:27 - but yeah just have fun with it have fun
86:29 - thank you guys for watching and peace
86:32 - out
86:33 - [Music]

Cleaned transcript:

how's it going everyone and welcome back to another video this video is long overdue but today we will be programming an expert level connect for ai which is gonna be a lot of fun if you haven't already i recommend you check out the video i did before like a while ago on i guess just programming the connect four game and what we're gonna be doing today is building off of that and actually implementing the ai um if you don't wanna like go through all the effort of what like programming the game from scratch you also can just go to my github page and i'll link to this in the description but there's this file connect for py so if you just click on the raw there and just copy all of this this is going to be the starting point from this video i'm going to be programming in python 3 and i'm using sublime text as my editor so i'm just gonna call this connect4original.py also if you haven't seen it already i really recommend you watch my video that i did called like how does a board game ai work because basically what we're going to be doing in this video is following along kind of the steps that i go through in that video on the theory behind a connect4ai so it really will help you with the background information on like how everything works because it can be a little bit complicated at times once you have the file locally just make sure real quick that it runs properly so when you run this original file you should ah why is it not running you should get a screen that pops up looks like connect four board and you just take turns being the yellow and red player dropping pieces i'll finish this up real quick and it should do something like that when you you win uh you don't have any errors to start off so just make sure that everything's working properly before we actually get into the ai and with this ai we're going to start off just like i did in the how does a board game ai video work with the simplest approach we can think of for the ai so we're just gonna have it the player two just drop a piece randomly somewhere on the screen so that's what we're gonna start out with before we begin take a second to review the code and make sure you kind of understand how all the pieces fit together because as we go through the steps of the ai if you don't really understand how the game is working it's going to be kind of confusing the steps that we're implementing and to start off we are implementing the random dropped piece ai so we're gonna have to go down to our game loop which is here and in the initial game we were checking for the mouse button down event and then based on whose turn it was so turn equals zero was the red piece i think and then the else statement was player 2 and that was the yellow piece we are making the drops based off of that in this random ai situation we are now not going to have player 2 drop when a mouse click happens is gonna just we'll have player two drop whenever um right after player one has made the move so once player one makes the move that should trigger player two to make the move and to kind of make some of this clear i don't like having like turn equals equals zero popping up in the code all over the place these are called magic numbers so what i'm going to do real quick is just to make things a little bit more clear is i'm going to go up here and define a static variable player which equals zero and i'm going to have a static variable or kind of just a yeah a variable called a i equal to one and i'll just when i making these variables will make it a little bit easier for me to read the code and also as we implement some of these functions with the ai it'll make it a little bit easier for us to understand how to implement it so now turn equals equals 0 is turn equals equals player and then for this we don't want it in the let me make this a little bit smaller just for a sec oh this can be too small i'll make it bigger but we don't want it to be in the if statement if mouse button down anymore we want it to be outside of this for loop because it shouldn't depend on event should just depend on when this i guess happens which we can store separately so we're going to move this back a few okay so that now should be in line with the 4 event and instead of an else we can't have an else without an if above it so what we're going to do now is we're going to do if turn equals equals a i and i guess we'll also do and not game over because we don't want this a piece to drop after the game has already been finished so if journey equals equals ai and not game over then we have the random ai making the decision and let's see there might be some other changes we have to make now that we did that one thing we might want to do is throw the print board somewhere differently actually it's good right here and let's see where else it was i didn't actually move it okay so i'm gonna move this stuff outside of the loop too let's see okay i'm thinking about this okay if game over that should be in the loop the turn what we're gonna do with the turns now is only have them change when a valid location was chosen so here the turn is changing and same thing for the player turn so if valid location then we'll change the turn okay uh no not that one less so inside the is valid location okay so now we what we have just done we haven't really done don't worry too much about the i guess logistics of what we're doing but basically we're setting it up so that we can pick a random spot to drop a piece we're just kind of having to do some i guess extra work to clean up the code and set it up for what we're trying to do so if turn equals ai and not game over cool and so now what we want to do is that initially right here we this was looking at where our mouse was and picking the column based off of that what we want to do instead is now just pick a random column so i'm going to do column equals random dot rand int 0 which is the farthest to the left column and we have column count columns right but indexing is gonna put that off by one so we're gonna do a column count minus one that'll pick a random number uh between zero and i guess six uh inclusive to drop our piece in and i have to i did not import random so i have to do that real quick all right i feel like i screwed something up and maybe we'll get some simple ai right here okay it seems to be working but it's immediate and that's kind of annoying but that's a good uh we're doing well so far oh and it's screwed up i just dropped a piece in a winning location and it screwed up there too so we have some things we need to do so the first thing i noticed that was really annoying was right when we dropped our piece the ai dropped their piece and that just doesn't seem very like it's not a good user experience so the first thing i'm going we're going to add is some time delay for the ai piece so down here we have the ai move and so basically what we're going to do is once this column has been selected and is a valid location so if it selects a column that's like not valid like already filled up or something it will run the loop again like nothing will have changed the turn won't have changed or anything and it will find a column that's valid and so in the is valid location we're going to add a a delay so i'm gonna do pygame.time.weight500 and this is similar to what we did before um when we ended the game just to like hold the player one wins on the screen so just like we did there so we're gonna add that and so let's see how it looks now quickly what the heck okay so i noticed another issue so i think it's working but what's not happening is the board is not getting reprinted after the we select our piece so the delay was there but it was being weird because it wasn't actually drawing the the board again so what we're going to do here is once we select like a is valid location we should update the board because it will have dropped a piece so i'm going to add this here see what it looks like now yay that looks pretty good and it's moving around okay it seems random but obviously as i mentioned or as yeah as i mentioned in the how does a board game ai work it's when you just select a random column it is such a stupid ai and it will not block my obvious three in a row so i can easily win right now also real quick while i'm thinking about it i don't know if you noticed this but right now i always get to go first so we probably would want it to be random who gets to go first it just makes it a little bit more realistic and we don't want to we want the code to work if the ai goes first so we can really easily add some logic that will allow us to initial randomly initialize who goes first and all i'm going to do is turn equals random.randint01 or i guess we could even do player ai which is going to be zero to one as well so what will happen now is instead of turn where was turn initialized somewhere in here turn equals zero now turn is going to be either one or zero and the reason we can do this just fine is because the only place turn can change is after a valid piece has been dropped so basically what's going to happen now is we're gonna end we're gonna skip over this event this code right here on the first iteration if we get one in that initialization step and then the ai will drop a piece it will switch to the player's turn and then we'll start back up at the top of the loop and we'll wait until the user clicks and then run the code so let's just see if that worked oh shoot yeah it looks like it worked i'll run it one more time just to make sure it's kind of weird that it's starting yellow it's a little bit laggy or something but it is working and i want to just make sure that i can get a i should be able to go first at some point too okay yeah so after three tries we initialized the zero and i get to go first as before one more thing before we move on to the slightly more advanced ai is that when i was running this one thing that i found that was annoying is come on run dude i have to click first is when the yellow piece is first so you see how when the yellow piece is first the yellow block popped up top here it draws the yellow block up here i don't really want that to happen now that only we're always red so i'm going to change this to turn equals player and then i'm going to actually get rid of this drawing the yellow circle on the mouse motion event so let's see what happens now yeah so now it just pops up immediately and i could add another delay but i'm fine with this cool yay all right let's move on to something smarter and actually start implementing the scoring heuristic for our board so what we're going to be doing is evaluating whether or not a board state is good or bad based on you know how many two in rows there are how many three in a rows there are whether or not you're playing in the center column and you know vice versa for the opponent having three in rows two rows etc and so this is exactly what we did in the how does a board game ai work video except the one difference is that a lot of the scores i think i was going through in that video were relative to the piece you dropped so like you'd only look at the three in a rows created or the two in rows created from the specific piece you dropped that turn what we're gonna have to do when we're implementing that so that we can use the minimax algorithm is do that relative the score will be not it will be independent from which piece was just most recently dropped so you'll kind of look at all of the board and count how many three in a rows how many two in rows etc let's define a function called score position which will give the we'll assign the score to our board so i'm going to define this right under the winning move function so score position and if we're scoring position we're going to need to take in two things uh in my opinion we're gonna have to take in the board obviously we'll also want to take in a piece so we have to know whether it's red or yellow going whether it's the player or the ai um okay cool and this is going to be pretty similar to how we did winning move or in a way basically what we're going to check is look at the whole entire board and basically be counting the number of twos and rows three in a rows etc i think to start off and make things easier let's just count whether you win or whether uh you win or lose so we'll just be looking at four in a rows and we'll start off with just horizontal so horizontal or score horizontal i'll say and let's see one thing i want to do real quick just it's on my mind is pieces defined as one or two so one is the player's piece value and two is the ai's piece value and that's another like magic number so i'm gonna just try to like i'm gonna define two more variables player piece and ai piece player piece equals one and this will just probably make our code a little bit easier to read again and aips equals two so let me just go through and try to switch things out so this would be player piece here this is ai piece defined in several locations go down player piece right here drop piece this would be player piece winning move this would be player piece i think this one is something different here let's see what else we have down here would be a eyepiece and i think down here would also be aips i think that might have been it not positive but just cleans up the code a little bit okay so we want to score the horizontal locations the way that i think we should do this is basically what we're going to do is it we could do it the exact same way we did winning move but it gets kind of tough with these if statements to count whether or not like you have two in a row exactly or three in a row exactly because then you'd have to like you have to factor in all the different ways you can have three in a row so what we're gonna do is i'll run the game real quick oh no what did i do sorry i just need to pass this function real quick what we are gonna do instead of that is basically imagine so look at my mouse down here in the corner we're gonna look at with horizontal starting we're gonna look at window sizes of four and just basically in those window sizes of four count how many empty squares and how many filled in squares there are and we'll basically be able to count then the lines of two lines of three lines of four from that so this is how it's going to work so we have our board and that's you know the matrix the row of rows and columns so what we're going to say is for r in range row count so for each row we're going to want to do this and then what we're going to do is we are going to define this row array and yes row array the best way yeah row array so this is going to be all of the pieces so if we're looking at a single row this is just going to be the seven tiles but just in a single list so it's easier and we're going to define that as row array equals into i for i in list board and then so we want the specific row we're on so it's going to be board index of row but then we want all the all the column positions for that row so that's why we use this colon right here i think that's what we want let me just see and the inta is just to make sure that we're always getting something that's can be indexed into the um okay ah so what am i saying sorry and i i think i just added this just to be cautious that we didn't try to index something with a float value or something so that's our row array and so then what we're going to do is get if this is like let's say we looked at the board down here the row array would be like this single list in here what we're going to do is look at all the pairs of all the window sizes of four so to do that we will do for c in range column count minus three and the reason we do minus three is because the last one we want to look at is this so we don't look it like we don't start with these last three as the farthest to the left if that makes sense i'm highlighting great in this area if you missed that okay so we're getting the horizontal windows and so the window then will be a four will be the row array and we're going to index that from our starting position so that's going to be from c to c plus i guess 4 would it be four or three i'm trying to think it's gonna be four yeah c plus four and we can actually make this a variable two just so you know where that four is coming from i'm just gonna call this window length so window length equals four so window length so we're getting four at a time and then what we're going to want to do with that is count the number of ones and twos so ai pieces and you know player pieces what not so what we're going to do with this window is there's a builtin function of lists in python dot count so what i'm going to do is count the piece that we're passing into the score position function and if that equals equals 4 so that would be we win so i guess if window dot count piece equals equals four let's say we have a score that we're defining so score is zero initially we'll say score plus equals like a hundred right so if we ever find four in a row on the board that's a really good board obviously um and so we should try to get that move okay so we have score plus equals 100 and then once we're done we're just going to do horizontal for now and i'll fill in we'll fill in the diagonal and vertical later turn score okay so now we have this score position function that looks at a single board state and gives the score of a hundred if it is a connect four and gives zero otherwise and i guess for the sake of this let's also preference uh three in a rows why not or maybe yeah three in a row so if i'll define this above or i'll define it below lf window.count piece equals equals three and window.count of zero so we should define this as a piece too so empty equals zero this is just how we are storing the values behind the scenes we know that count of empty equals equals one then let's add i don't know 10 to our score so this is three in rows this is four in rows right and then we need to find one more function and that is just like pick best move and that will give taking a board what else does this need to take in i'll start with just the board potentially i guess the piece too yeah why not pick best move so what we're going to do with this is we need to look at all the different columns we can make the move and then basically run the score position on all those columns and then pick the highest score that is returned so we will write that as follows so we have a function called i think valid locations if i'm not mistaken okay no we don't but we can find a function called valid locations real quick so i'm going to do that def valid load or let's just call it get valid locations so this will show us which columns we can actually drop it in and then evaluate from there that is a board we don't need to actually have a piece to figure out if it's a valid location or not and so valid locations is an empty list to begin and for column and range column count we don't have to do the minus one here because this is exclusive that that last value if is valid location of board and column then we want to append that specific column because that is a valid location this is just getting us a list of where we can drop just because we'll be doing a lot this a lot so it's going to abstract it into a function valid locations dot append column and then finally when we're done we'll want to return the valid locations okay so now we have valid occasions so in our pick best move we'll need to use this so valid locations equals get valid locations of the board and let's think what else uh we need to do so what we're going to want to do is for column in valid locations we want to figure out what the row so basically what we're going to do is to make our life easier is we're going to pretty much simulate dropping a piece and then have this new board that actually gets passed into the score position because we actually just taken a board object there so we have to kind of simulate each move to actually evaluate using that function so we're going to do is use our function get next open row and that takes in the board and the column and then this is something that's tricky and not intuitive is we can't just drop the piece into our current board and or we can't even do something like this we can't say like temp board equals board and then say okay let's uh drop drop piece in the temp board and row column and i guess peace we can't use this temp board to simulate the drop piece because what actually happens with the numpy objects that we're using to store all the values is that this temp board ends up pointing to the same exact memory location as the original board so what we actually need to do is make a copy of this board so this is creating a new memory location where our board is sitting and what we're doing is passing that new memory location into our drop piece function so any modifications don't modify our original board hopefully that made sense so drop piece um and then we want to basically find the score of the new board so i guess what happens is this drop piece automatically modifies temp board so we can just go ahead and do score equals score position of the temp board and whatever piece that we dropped and then what we'll want to do is basically keep track of a best score so we'll say best score and we'll set that to zero initially and we'll have best column and that'll just be like we'll just put it as a random choice of the valid locations and i defined valid locations below this so i'm going to just move these remove that down here okay so we have our best score and our best column best score is initially zero best column is just random but what we can do is if this score that we scored with this new board is greater than if score is greater than best score then we can set our new best score to score and we can set the new best column to whatever column we were checking when we got this new score okay does that make sense and then finally once we do this we'll do return best column i think that looks right all right let's try that out real quick so all we should see here is we didn't add that anything too complex we just made it preference winning horizontally and getting three in a rows horizontally so we shouldn't be looking at any sort of vertical maneuver okay so instead of the random location here i'm going to comment this out and do column equals pick best move of the board and i guess we're the ai here so i need to pass in the ai piece come on moment of truth i mean let's just stack on top of okay so now we should see it connect three in a row that's what we're hoping for and it did it cool so i'm going to just stack a top again the way we scored it too it should now preference filling this in after i drop which it did we got something a little bit smarter okay now that we have the score working for the horizontal moves we can kind of expand upon this and make it work for diagonal and vertical as well also do a little probably a little bit of cleaning so it ah where where where's the code okay pick us move struggling okay yeah so this is horizontal so we need to also do vertical vertical is also easy so score vertical do next so that would be force column and range column count the ones that are tricky are the diagonals so we're doing the exact same thing we did with horizontal uh but we're going to do it with vertical and then once we have it for each one we'll actually probably improve how we're actually scoring this make it more like i did in the we did in the other video all right for c and range column count let's see what else we should do we should then get the column array ray which is going to be similar to the last time it's going to be int i for i in list so this time we have the we want to get every row position for a specific column so we can do it like this i believe i think that's what we want and then we'll want to iterate through the windows just like we did last time but now we have to iterate through the the row window so for r in range row count minus three window equals row array c or r to r plus window length and we can copy this once we now that we have the window this code is oh shoot i didn't want to delete it this code is the exact same so i can just add this code and what we're going to ultimately do is abstract away this window counting stuff to its own function so okay so now it should if we run this again it should preference vertical as well so i'm going to block the horizontal and it's still stupid and it's oh it actually did block me that's interesting but i'm going to let it get okay so now it has two verticals in a row it should preference making the move right on top of it next if we did this right and it didn't so i'm guessing we did something screwy it's weird this is weird maybe it's just getting lucky okay it should hopefully win vertically let's see i don't know we did something wrong window count piece score plus equals hundred what did i do wrong here oh shoot i grabbed a row array this needs to now be column array okay sorry about that and also for r and range row count yeah okay that should be good hopefully let's see if it preferences vertical moves now too so i'm blocking the horizontal and now basically once it stacks oh shoot i'm going to block the horizontal again but come on okay let me play it again so you can see exactly what i was trying to show you right so it goes i'm going to block the horizontal and hopefully it stacks on top okay now that it's stacked on top we should because it doesn't have any sort of horizontal options it should stack again and it does and so it now should win vertically okay cool so that we kind of mainly validated that it was getting these windows correctly for the vertical okay so this was getting if we think about the same graph it was looking at like the sliver if we just cut off this one column it it was making a list out of these ah sorry these numbers zero zero two two two two okay now let's do diagonals diagonals are a little bit weird um so we'll start with the positively sloped diagonals so the ones that are low on the left side and rise up to the right side so score positive sloped diagonal all right so let's just run the game real quick just to see that how we're going to do this so basically if you look at my mouse we're going to look at all the possible ways we can do this diagonal slope so we can do like this we can move over do this move over do this move over do this and then rise up one row and do the same thing so basically now we have to um go from like row count minus three as well as column count minus three and do a little bit of manipulating like that and it's a little bit weird to get our windows but it shouldn't be too too bad so let's start with this so we're gonna iterate starting with the rows so for row r and range row count minus three because we're going to be cut off at the top because we're going up each time once and then for c and range column count count minus three because we can't just have a okay so and that's because we're going to the right each time four so we have to cut off early for that as well and then what we need to do is our window is going to now be we're going to do a little list comprehension to do this it's going to be the board at the row position and then at the column position and what we're going to do is we're going to have to add a little bit of value each time so it should start with 0 so we're going to we're going to just add some i plus i and that's going to be for i and range window length so basically what's happening is if you think about what i takes on if window length is 4 i is going to start out at zero so that's going to be just the arth the position at r comma c but then we're gonna this is gonna become one so we're gonna increase positively one and one so we're going to go up and across and that will continue and we'll actually get our window in the proper um we'll get we'll get a windows has a 4 that is a diagonal and this will repeat this window right here we'll repeat for all of these values so we'll end up getting all of the positively sloped diagonals and so we're going to just you can just copy this code here and we can do the same for negatively sloped diagonals so for r and range we'll do the exact same thing oh my gosh stop texting me ah sorry for c in range column count minus three and this is a little bit trickier because now we need to stop start at the top and go downwards so to do that bear with me we're going to want our window to be equal to we'll do a list comprehension again board r so this is going to be the same exact as before but now oh my gosh this is annoying wow i've never what is this crap sorry i'm gonna turn off the volume there we go okay so what i was saying was now the first thing we check is up here so that's gonna be the row plus one plus two plus three to get that position so that's going to be rho plus three and then the c i think will stay the same i know we're going to be going downwards so that's going to be c plus 3 as well to get the position we're looking for because we're going downwards so c plus three do we want c plus three uh yeah that should work sorry i'm just confusing myself now i guess the c stays the same so c is normal and rho plus 3 and then we'll minus i and we will in this case we will plus i for i in range window length i think that should work let's think so if we think about all the different combinations start with this position that's the sear the zeroth column that's good then we go down one the row decreased but the column increased down again row increase but the column decreased down again row increase or row decreases but column increases so i think what we did here is good and we can score that just like we scored the other ones it's a little bit tougher to test so what we'll do to test these is we'll temporarily comment out the horizontal and vertical and just see if it when it has the option and sees the diagonal that it preferences it so i'll make it easier for it so if it puts it here or here we should see on the next time it putting a three in a row okay yep it did i made the moves a little bit quick but as we can continue basically oh shoot don't make that if i put it right here it should if we implemented these diagonals properly connect it yay we can go ahead and uncomment all this now that we've checked that diagonal i guess we should ideally check positively sloped two but i'm pretty sure we're good there okay and now what i recommend we do is we're going to add a couple more different ways we can score this and just so we don't copy all this into each one of these individually let's abstract out a new function called like i don't know uh find it called window evaluate window how about evaluate window and we'll take in the board and the piece to that or i guess not the board we just need the window and i guess the piece for that so this is going to be the exact same thing as we did before so if window dot count piece equals equals four score plus equals 100 alif window.count piece equals equals three and window dot count is empty equals equals one score plus c equals ten let's think what else we should have should also have an lf for window dot count piece equals equals two i guess we it doesn't really matter if we use if or l if i don't think here and window dot count empty actually it does oh no it doesn't i don't think it does empty equals equals two reduced score plus equals five and these values these are kind of arbitrary and i'm fine leaving them as kind of arbitrary guys i don't really need to extract these out into their own variables i guess i could if i wanted to but basically these are the type of values you play around with as you kind of tune and try to make your ai better let's see what else we could do we could also have like i guess inverse piece so this would be the opponent piece so i can just call it component piece equals we'll just say player piece opponent piece equals player piece and if piece equals equals player piece then we just need to switch it so that would be then opponent piece would be equal to ai piece if that made sense what i did i just was saying that okay let's assume we're the ai and set the opponent piece to be player piece but if we're not the ai and we're the player and we're adding the window then the opponent piece should be aips so we could also do is something like if window dot count opponent piece equals equals three and window count dot opponent or win account empty equals equals one and then that means the opponent has a three in a row and we could do like score minus equals eight let's say so it's like we weigh us getting a three in a row more than we weigh the opponent getting a three in a row okay just to finish up this function we should initialize score equals zero we'll return score at the end and this is just going to be so then when we actually go into the score position we can delete these lines and what we'll actually do is do score plus equals evaluate window of window piece and we just copy this line here for each of the other locations that we added these logic cool cool cool all right let's see what happens oh no plus equals none type oh yeah should probably return the score okay so we should be seeing some preference so it should probably want to get this three in a row yep okay will it block me so it doesn't seem to be blocking me let's see if it preferences diagonal downwards i guess it's diagonal that way let's see if it preferences diagonal downwards now cool it's looking pretty good however it's not blocking me so that is an issue so it's not blocking me and the reason it's not blocking me i just realized is if we look at this if we think about how this evaluate window is working we're only calling it for the ai so if the ai ever sees the opponent has three and the window count is one empty is one then the opponent already has three so would be able to win in the next case so in this case it would be preferencing putting three in a row over blocking the opponent so watch what happens if i make this like negative 80. now it's going to preference and i also will have to we'll have to change the best score to be some sort of low negative number to start just so it doesn't screw up if we get a negative here now it should block always block if i ever get three in a row yeah see that cool i don't know if we'll keep this in when we go to mini max and we're gonna go to min max right around right really soon the last thing i want to add before we go to implementing the min max algorithm is just scoring the center columns and you know adding preference for center pieces because that's what's going to create more opportunities with the diagonals and the horizontals is if you have the center the center pieces okay so we can get our center array so score center and i guess this should be i'm going to move this comment right below the score equals zero move this up a bit and now i'm going to add the score center column so we're going to create a center array just like we were kind of making the row or the column arrays within the score vertical so we're going to do equals int i for i and list we want the board and we want every row position but we only want the center column so we can do column count and then we could just you know mainly think about it 0 1 2 3 would be the middle but just to kind of not have magic numbers i'm going to do floor division by 2. so that will get the the middle column and then what we want to do is just do center count i guess equals center array dot count piece and then we'll just add to our score i don't know three points or so let's see i i kind of did some weird numbers here i'm going to add like six for each piece in the center so center or score plus equals six let's say and these numbers are all going to change so don't worry too much about all the score increases this is something you play around with okay let's see if it's preferencing center now it should not have gone there for us referencing center score plus equals six let's really crank up this score real quick and see if it works it's weird yeah something's goofing oh okay sorry i was doing plus equals six but i was it should be plus equals center count times six right so if you had two it'd be twelve plus twelve it would be um if you had three you'd be plus 18 etc okay now it looks like it's preferencing center we'll see should block okay cool now i think it should go center if i'm not mistaken yeah cool and probably should go center again if i'm not mistaken okay i guess that created more diagonals but okay center cool should block and go center cool i think that's accounting for the center all right with that i think we're ready to move on to the min max algorithm and what i think is helpful at least when i was implementing this is i went ahead and just was reviewing the wikipedia page on minimax so you know if you didn't watch the video i posted minibacks is basically a way so that we can look down the branches of any sort of rule based game like chess checkers and in our case connect four so we can basically look down at branches and evaluate using our score function the best branch that we can guarantee getting so what i recommend we do is go ahead and go to the pseudocode and this is all we really have to implement so function minimax node depth maximizing player so the node in the r case is going to be the board depth is how far we want to search down in our game and maximizing player is going to be true for the ai and false when we're looking at the player's move so let's go ahead and implement this and i'll be kind of popping this window back in and out okay so score position is good let's define mini max uh uh okay def mini max so we're going to pass in the board we're going to pass in the depth and we're going to pass up in the maximizing player and i'm going to just do pass for now okay what do we need to do next in this if depth depth equals 0 or node is a terminal node so what is a terminal node in our case well that's whenever a game is one or i guess if we get to the end of the game those would be terminal node conditions so then we want to return the heuristic value of that node and else we want to kind of recursively check our tree like you see in this diagram down in the bottom right and find the best score so that's what's happening down here let's start off though with the i guess if steps equals zero condition that's when we're going to be returning the score position function score okay so what are okay so let's do this if depth equals equals zero or terminal node so this terminal node we haven't defined yet so let's just define it so what we just said was terminal nodes would be us winning the opponent winning or you know you've used all the pieces in the game so let's do those so i'm going to find another function sorry is terminal node and that'll just be true if it is a terminal node and false if it is not now taken aboard so what are the terminal node conditions well we have this winning move function right here so basically we can use this to our advantage so if it's a if this returns true for either of the pieces then it would be a terminal node so those will be two of our conditions so we want to return winning move board player piece or winning move board uh the ai piece or the final condition is that there's no more valid moves in the game so the board is completely filled up so what we can do in this is we can say length get valid locations of the board and that length should be zero if it's a terminal node so this statement as is will return true if it is a terminal node and false otherwise it's nice one liner so what we're now going to do is i guess valid locations equals get valid locations of the board and then we're going to do is terminal will be equal to is terminal node of the board so now we can do if depth equals zero or terminal node or i guess or is terminal okay what do we want to do in this case well there's three conditions so if we are the ai then the first thing we want to do is we want to if it is a winning move for us the ai we want to do if winning move so this is basically just figuring out which case of these three we're in if winning move uh board ai piece then we want to return a high score so return like you know a really big number lf winning move board player we want to return a really our player piece sorry we want to return a very low score and we're going to augment this so it also has a position but you'll see that in a sec okay turn a really low score if it's losing condition and then else this is going to be when we evaluate our score position this is a board that is not a winning condition so and it's not a terminal condition so we actually want to get the score for it so we're going to do and i'm really just following if you're getting confused with what i'm doing i'm doing this step of the mini max algorithm and i'm just finding the heuristic value of the node and these are kind of two edge cases the winning move cases and i'm just handling them separately i guess they could be kind of factored into my mini max but just because you know we're only really looking at the opponents uh it might work if i didn't handle these separately i just in my head it makes it easier if i handle these separately then finally the else condition is when we want to i guess the else condition here would be the game is over so that's just kind of like a weird case where we would return zero i suppose because you can't really do anything from there all right cool so we have the that's part of it and now the final thing is if it is not oh sorry if is terminal that's the is terminal cases either we win the opponent wins or the game is over those are the three cases so i can just even mark this game is over comma no more valid moves the other case is the depth of zero so we can just do else here and that's going to be depth is zero and in that case we want to find the heuristic value of the board so what we're going to do is just do return score positions uh score position of the board and i guess whatever piece we dropped so in our case it would be the ai's piece i guess maybe it would be good to specify this but i'm just going to keep it as the ai piece right now you can fix it if you need to all right so that's the first part of the mini max and sorry if this i hopefully this is not too confusing it'll all kind of fit together once we you know get through the rest of it all right let's finish implementing the minimax so let's do the bottom half of that what i was just highlighting on the wikipedia page and also this should be ai piece the ai and the player without the piece is just only was used for the turn um okay all right so else let's see what does that say if maximizing player then and we returned out of this so this week if you get into this if statement you'll not get into the other ones that we're about to define so if maximizing player and i'm going to just actually i think what will be easiest is if i just keep this on the screen where's the pseudocode pseudocode okay cool all right so we have the pseudocode on the screen and we have the code over here so oh gosh now i can make this the other half okay not too bad all right so if maximizing player i'm following right here it's amazing player then we want to initialize the score to some really low value so what we could do here is i think we actually use if we actually want to specify negative infinity and positive infinity i think we can do instead is we can do value equals math dot infinity that works and i can actually just do negative math dot infinity okay so that covers that and then for each child of node so that's for each position we can drop in our connect four game so what we're going to do here is we're going to do for column invalid locations which i already have to find up here fortunately for us column invalid locations comma row equals get next open row of the board and that specific column that we're looking at and then as before with when we're just doing this the score position function we need to copy the board so board dot copy just because otherwise we'll use the exact same memory location that the board is on so it will really screw up when we're you know recursively doing this okay and we can go ahead and drop a piece in that position v copy row column and we are the if we're the maximizing player then we're the ai piece all right and so what's going to happen here is we're going to have a new score score which is going to be equal to the mini max which is going to be the max so if you look at this it's going to be the max of the current value which is negative math infinity and minimax of depth minus 1. so new score i guess would just be the max of current score which was value and minimax of this is our recursive call here of the board copy depth minus 1 and i guess we do false now because we're no longer the maximizing player now the minimizing player cool and then finally what we'll want to do is return the new score so that's the max of the value and the minimax and we want to do the same thing for the minimizing player so else we know we are the minimizing player and that is the code right here we want to initialize the value to positive infinity and now copy the same thing for column invalid locations same as before row equals get next open row of board and column we need to copy the board again because we don't want to use that same memory location otherwise we're going to have issues when we try to recurse back up the tree drop piece equals oh shoot board copy row column and now we are going to be the minimizing player so what we need to do is actually make this piece the player piece and same before the new score though is going to be because when we are if we remember this the minimizing player is trying to take the lowest value so if you see this node right here this 10 10 and plus infinity 10 is the lower node so it always take that so in the minimizing player case we want to take the the new score would be the min of the value and minimax of word copy depth minus one and then we want to do true for now switching to the maximizing player so this this false and this true is what's allowing us to switch back and forth between this maximizing player and the minimizing player in the context of the mini max algorithm and make sure you understand the mini max algorithm watch the video that i've posted previously on it or just kind of review this wikipedia page to kind of get a feel for how it works because that is crucially important for understanding how this new ai is working okay and we want to return value or the new score cool i think this is about it right i think so however the one issue i have right now as i look at this is we're returning the score which is good to know like how good of a move can we make at a certain location but we also need to augment the score with the column that produces that score so in addition to just producing or just figuring out what the best score is we need to figure out which column produces that score so to do that we're going to just actually get rid of this max and min we're going to just break it out a bit just it's easier to keep track of what we need so we're going to say that the new score is equal to the mini max that same thing for this and instead of doing it in just one line we're going to just bring it to the new line so if new score is greater than the value value equals new score so this is the same thing right now if we kept it like this this is the same thing as the max the one liner we just had but we also want to do something like column so this this column right here is like the best column you can get so we could initialize this to just a random choice of the valid locations random.choicevalid locations and same thing for down here column equals random.choice of the valid locations all right so now what we have is column equals whatever column we are currently iterating on that gave us this new score when we recursively did the mini max algorithm so that would be call and okay that looks i think this is good here we also know need to now implement it down here same thing so this time it would be if new score is less than the value we want to do value equals new score and column equals call and we want to okay and then finally what we have to do is instead of just returning the score we want to return both the score and the column that produces that score so we'll return a two pole so we'll do column and new score or i guess value is our final thing that we return same thing here turn column and value and then up here these are the terminal conditions so if we get a terminal condition we don't actually know which column produces the terminal location because it's just looking at the board particular but we can get that very easily because we would get it through this so basically what we can do yeah so basically when we returned this new score all right yeah so we're gonna augment these none just has to basically all be the same format even though these wouldn't actually produce a column value none zero okay so we don't know which column produces those and basically what we need to do now is if we want to adjust the score we need to get the first index we need to get the first index here is that it i think that might be it and then i guess right here too this would just give us a score so in this case two we need to do none comma score positions so basically we're always because this is a recursive function we always need it to return the same format so we're now just saying turn us the the best score in the column that produces the best score cool i think this is it we can delete this pass so let's go ahead and real quick test out our s you know our first attempt at the mini max and to do that we can just go down to here and instead of best pick best move what we're going to do is do column equals minimax of zero or actually what am i thinking it's bored then it is depth so let's just for sake of simplicity we'll start with depth equals two and then we are the maximizing player so that is true let's see if this works nope damn it is the location where we get the error where do we get this error too many indices for array 267. if is valid location oh shoot let's see oh all right yeah sorry i was just trying to get the column out of here but we actually get the column and the mini max score so i kind of have to unpack the tuple now it's not just one thing it returns okay all right so what we should see now i think at depth of two it should be smart enough to block oh i guess not yet i was hoping that it would block me from getting this situation where i could win on either side i'm gonna try increasing the depth to three and see if it does that all right so what i'm trying to see is if it's looking ahead in the future and how we can tell that is if it's looking ahead in the future it should prevent us from getting winds that can we can kind of have two spots where we win so if i drop it here it needs to block me so that i can't get the horizontal three on the bottom still is not doing it what the heck it might be some sort of error i'm going to just try one more time maybe seeing if it's not looking far enough in the future and do this depth four so this is how far of a branch it's checking yeah it's definitely having some issues here it did win that time but it's always picking zero it's always picking the farthest to the left to move why is that the reason it is always picking the farthest to the left even at depth of four is let's go up and just check why is my mouse being so fidgety today won't scroll up for me is okay i see it if we look at where we are returning this column and value it is inside of the for loop so it's on the first column basically and also we initialize the value to negative infinity so it's basically okay it's figuring out that whatever score is on the farthest to the left column it's going to be bigger than negative infinity so it's setting that column here and then returning it immediately what we need to do is just backspace this once and hopefully now it should be pretty good and i probably don't even need to go depth of four think about i'd go to like depth of three and it will still block just fine okay i kind of want to go first just because i feel like i'll see it easier okay so now it needs to block one of my horizontals which it does now which is good it needs a block cool that's looking good okay let's see if it's looking into the future it should put its piece right here next if i put it up here cool it's looking good it's like smart enough to know that like this position right here where my mouse is was the best spot to put it because that gives us a win here and here so if it looks in the future and knows it's going to win it's not going to be easily blocked by me looking good cool all right uh real quick um just because i'm not positive how i feel about the values that i currently set all these things up here in the score positions function too or i guess evaluate window i'm going to just change these to what i set when i was playing around with this so the window count equals 4. this actually is pretty irrelevant at this point i think the only reason this would play in is if we set the depth equal to zero and it had to use just this evaluate window so i'm going to leave this in here but this know that this is probably not too important anymore i'll still keep this value okay three and one so three in a row i'm going to give this a weight of five two in a row i'm going to give this a weight of two but remember that it's in multiple directions so you could have multiple twos in a row and it adds up uh opponent equaling three and one this is not as important anymore because and also i have to kind of make this a smaller value because it's this is factored into the terminal condition case so it will look ahead in the future and make sure that it's not losing so i'm going to make that minus four then the other thing that i change to is instead of making this times six i'm going to make the center column worth plus three and these are values you should play around with so if you really want an expert level ai play around with these values but honestly i feel like this ai right now like i'm gonna just play a game like try to win i guess it's still not amazing i guess it's depth three right now but yeah like look it like it's making pretty good moves and it's like gonna know to win if i put it there i think this is a pretty good ai at this point uh to make it even better what we can do is increase the depth of how far it's looking uh where is that so if you make it four it's looking if we think about how the mini max works uh it's looking farther down in this tree so this four would represent how far it's looking down it's like right now we're at depth four so that's why it's looking this far down and you can think of this graph as being all the possible ways a connect 4 board can work so depth 4 let's see this would be even better of an ai because it's looking farther in the future and we could even make this better let's just go to depth 5 and see what happens okay i kind of have a problem i don't know if you noticed it but i did depth five and it seems like it's just oh it finally made a move it just takes forever to make a move at this point try to like think about why that is you can even pause the video if you're trying to like think about why that is but yeah i mean if we're going it if we're doing depth five and we think about what the minimax is doing it is branching out at every step so from the top of my hands is the terminal node every time we do a higher oh my god i'm trying to be even every time we do a higher depth we expand exponentially more branches so this is basically like seven to the fifth power or maybe even six power because we also look at zero so it is a lot of branches to expand so it's going to run slowly so 5 is probably the max you can really do otherwise if you go to 6 your computer is just going to explode not really but basically it's probably going to freeze up and crash on you if you go to 6. so this gets us to the final thing i'm going to cover in the video and that is the alpha beta pruning so it's basically allowing us to go to deeper depth by eliminating a lot of the moves we have to look at and i didn't actually cover this in the video i posted about how does a board game ai work so check out a video i posted in the description on kind of the overview of it uh at a very high level yeah basically it is figuring out that there are certain branches that a computer is just or an ai is just not likely to take if it realizes like in a move if it goes a certain position that it loses it's not going to go down that branch so you can just not look further down into the future there yeah so check out that video real quick on alpha beta pruning and then once you watch the video we will implement alpha beta pruding to allow us to more quickly search the depths we want okay alpha beta pruning so just like when we are doing the mini max what i recommend is look going to the alphabetical pruning wikipedia page and there's also pseudocode there so i think that's helpful the pseudocode is helpful to follow but it's just basically an adaptation of what we've already seen with the minimax but now we have these two additional parameters alpha and beta and you should understand what these are now that you've hopefully watched the video or already had some knowledge about how it worked so we're gonna go up to our sorry i have this on another screen because i don't want to screw this step up um you should yeah go to your mini max function and we're going to be adding our alpha and our beta to that function and so we're also going to have to pass this into all of our other calls of it alpha beta and right here alpha beta and we'll also have to do it down here when we actually call this and if we remember the alpha and beta should be initialized to negative math infinity and this is just i'm looking at right here the initial call right here negative infinity negative math infinity math infinity and true so that's the initial call and then all right so let's define this new mini max function with alpha beta this should be a comma here all right so let's see what it's doing so basically all we're doing is that in addition to getting our max value we also are just evaluating the alpha so we can do this below the new score stuff so alpha equals max of the new score or i guess the value at this point we can do value because it would have changed value and alpha and then which we want to do is or i'll just do it in the same format that wikipedia is doing so alpha and the value okay and then what we want to do is if alpha is greater than or equal to beta then we want to break out of our loop and that is good and then same thing down here now we are the minimizing player so we want to do beta equals the min of the beta and the value and if we find that alpha is greater than or equal to beta then we've reached a condition where we're going to just break off because we don't need to look any more further in the tree and we'll break so i think that's all we need to do to implement alpha beta it's pretty straightforward after you have the mini max up and so let's run this real quick i'll probably get an error we'll see ah shoot i need to not use my track pad because keep accidentally dropping pieces okay it has a piece there this should drop quickly if before depth five was taking a while now that we did this it should drop quickly which was pretty good it was pretty good reasonable more reasonable than it was before for sure so i think that is looking pretty good and what we can honestly even do is now that we're searching so far what we can do is we have that initial time delay i can actually just comment that out at this point so this should be pretty quick and we're going at depth 5 which is pretty far down yeah it's not bad i think even if we go to depth six it's not too bad either but like before if we went to depth six it would take forever we'll see it also depends on what type of processing power you have so i'm going to try depth six here it's taken a bit for sure did i do this right it but not nearly as long as it was taken before yeah the the alpha beta pruning looks good and one thing i just realized is that um you're gonna see more performance gains kind of as the game goes on further because there's gonna be at the start of the game there's more possibilities and less places that can break out of that alpha beta thing but as a game goes kind of on you'll have more breaks frequently so the performance gains will be definitely seen as the game continues on all right that's we're going to end um what i would say too is like we have a pretty dang good ai as is but i didn't there are additional things we could do to make it even better so a couple ideas that i'm thinking about is uh one thing is that currently it doesn't weight lower like so if you think of the game i'm gonna run it real quick if you think of these rows down at the bottom it's like this first row here the second row etc it should we should wait um we should wait what am i trying to say we should wait the lower wins so like when you have three in a row that's lower that should probably be weighted higher than if you have a three in a row that's at the top here and that's because you know as the game fills up people have to push them on the lower rows before the upper rows so like if you are strategically playing as an ai you would want to like put your pieces down lower so you get more chances to win also what i recommend is you can make it even better than that by watching the even odd connect four strategy that i posted that's like a really cool strategy that you could try to implement with the ai um you could also let me think i mean there's other things you could play around with off the top of my head i'm kind of spacing right now but the values all could be tuned of the scores um but yeah just have fun with it have fun thank you guys for watching and peace out
