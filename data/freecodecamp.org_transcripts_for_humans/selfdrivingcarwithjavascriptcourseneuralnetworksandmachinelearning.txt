With timestamps:

00:00 - In this course, you will learn how to build a 
self driving car simulation. By making every  
00:05 - component yourself with no libraries. This course 
is a great way to learn about neural networks.  
00:12 - You will also learn about modern JavaScript 
techniques, Raju teaches this course.  
00:17 - He has a PhD in computer science, and is one 
of the more creative tech YouTubers out there.  
00:23 - Hi, I'm Raju, and welcome to the self 
driving car, no libraries JavaScript course.  
00:29 - It's a course where I teach you how to make a 
self driving car. The and will do it without  
00:35 - using any kind of libraries so that you really 
understand what's going on under the hood.  
00:40 - Now, before you say anything, yeah, it won't be a 
real car you drive outside. But making this kind  
00:46 - of simulation is maybe even harder than doing 
it for real. Let me explain. In this course,  
00:52 - you'll learn how to implement simple physics 
to move the car in the beginning will control  
00:57 - the car ourselves using the keyboard to get 
the field that we want. I'll also teach how  
01:03 - to create the road and how to follow the car on 
the road like a drone is filming it from above  
01:09 - will then simulate some sensors on the car. 
These sensors work by raycasting and detect  
01:15 - if the car is too close to the side of the road or 
to other cars in traffic. To implement these will  
01:21 - use a formula for a segment intersection. Don't 
worry, I'll explain the math in a nice visual way.  
01:28 - You'll see we'll implement collision detection 
using the same segment intersection formula.  
01:34 - It's great, it works with any orientation and 
can even support other shapes as well. Now all  
01:40 - of these are things you don't have to worry 
about if you're working with real hardware.  
01:45 - The world gives you the best 
physics better than any simulation.  
01:49 - There are plenty of rows to drive on, 
we don't need to create them ourselves.  
01:53 - And nowadays, cars have a bunch of sensors that 
tell if something is touching or around the car.  
02:02 - Of course, if you want to build 
all of these yourself, then yeah,  
02:05 - making the simulation is easier. But what are you 
Elon Musk? Anyway, the second half of the course  
02:12 - is the really interesting part, you'll learn 
how to create and visualize a neural network,  
02:18 - an algorithm inspired by the biological neural 
networks in our brains. I'll briefly explain  
02:23 - how our brains work to the best of my ability and 
teach you how to code something similar ourselves,  
02:30 - then we'll optimize the brain by trial and error.  
02:34 - Yeah, to keep things simple, we just try 
randomly generating brains until we get  
02:39 - something that works. We'll parallelize this step 
and use hundreds of cars at once to save time.  
02:46 - By the way, this is something you can't do with 
real hardware unless you're really, really rich.  
02:51 - And that's why car companies use simulations 
to train their neural networks as well.  
02:57 - I'll also teach you a basic genetic algorithm to 
optimize faster. But don't expect anything too  
03:03 - fancy. This entire system is complex, but I made 
it so that each component is relatively simple  
03:10 - in and of itself. I made this course keeping 
in mind my high school days back in Romania.  
03:16 - So the knowledge you get from school should 
be enough depending on the curriculum. We'll  
03:21 - work with JavaScript because it's so easy to get 
started. You just need an editor and a browser,  
03:27 - which you probably have already. I'll teach you 
many modern JavaScript techniques. So this course  
03:33 - is perfect if you want to become a better 
coder, as well as a machine learning expert.  
03:39 - Now, JavaScript is not the best choice 
when doing artificial intelligence.  
03:43 - But since we're not using any libraries, it 
doesn't really matter. If you want to learn these  
03:48 - in a more useful language, like Python, then come 
study at Karelia University of Applied Sciences  
03:55 - there, I teach the same thing in Python as well. 
And we also study machine learning libraries and  
04:00 - even use hardware components. But now start your 
engines because the course is about to start.  
04:10 - I'll first teach you how to implement the car 
driving mechanics. You learn to make a car  
04:15 - that moves like this. It's not really that 
hard. You'll see. I'll refresh your memory  
04:22 - with some basic physics and trigonometry. 
And you'll be able to code this in no time.  
04:28 - We begin with this simple project setup. We have 
three files right here, index, HTML main, Jas, and  
04:36 - style css, and they're all empty for now. And 
I'm using Visual Studio code to write this.  
04:43 - And on the right, I have Google Chrome, and you 
need to have the developer tools open there.  
04:51 - It's really important. So if you plan to follow 
along, have a similar setup. You can use another  
04:58 - editor if you want to If I recommend this Visual 
Studio Code nowadays, let's begin with basic HTML.  
05:08 - In the head, I'm going to write a title for 
this. And it's going to be self driving car,  
05:15 - no libraries. Really, everything here is going to 
be just written by us, linking now the stylesheet.  
05:26 - And let me close the head and in the 
body, I'm going to define a canvas,  
05:33 - we are mostly going to use this canvas in this 
project here, I'm also linking the JavaScript file  
05:43 - like this. And we are done with the HTML for 
the moment, at least, refresh the page. And  
05:54 - not much happens rarely. It says here self 
driving car, no libraries in the in the tab  
06:01 - of the browser, but nothing appears in the page 
itself. Apparently, if you open this elements,  
06:09 - you will see that the canvas is actually 
there. It's just transparent. And the body  
06:16 - actually has this orange small margin there, I 
want to get rid of that margin and also make this  
06:25 - canvas visible somehow. So let's go to this style 
css next, and write some styles, I will remove  
06:35 - the margin for the body. And let's make the body 
have a dark gray background overflow to hidden.  
06:44 - And I'm going to use text align to center for now. 
Overflow is important. Otherwise, we might get  
06:51 - the scroll bar coming if the canvas is too big. 
And I don't want that. And I want everything to  
06:58 - align to center in the middle of the page. Now my 
canvas should have a different colored background,  
07:07 - maybe we set it to light gray like this. And save, 
refresh. And now you can actually see the canvas  
07:17 - without needing to inspect these elements right 
here. I'm gonna move back to the console, it's  
07:24 - probably the most important thing in the developer 
tools, I want my canvas to stretch the full  
07:30 - screen vertically. So I'm gonna go in main.js, 
right here. And I'm going to get a reference  
07:39 - to our canvas with ID my canvas we defined 
previously. And I'm going to set the height of  
07:47 - this to be the full window inner height like this. 
And the width is going to be just 200 pixels,  
07:57 - it will be like a road going upwards, we will need 
the space on the side to draw the neural network  
08:03 - later. Now if I save this and refresh, you can 
see it appearing there exactly how we want it.  
08:11 - Let's next pretend that we have a car, and we want 
to draw it on the canvas. To draw on the canvas,  
08:21 - we first need to get the drawing context, we will 
just use the to the context in this whole project.  
08:27 - So I'm going to have a reference to this canvas 
context right here and the city X. And it's going  
08:34 - to contain all the methods we need to draw the 
things that we need to draw in this project.  
08:40 - And if we would have a car, we would say 
something like this, let's get the car at,  
08:49 - for example, 100x 100 y, and the car 
maybe has a 30, width, and 50 height.  
09:00 - All of these are in pixels. And let's draw the 
car using this context. But we don't have the car  
09:08 - yet. This is the thing that we are going to 
need to define next, the car object. And we are  
09:14 - going to do this first by going inside the index 
html here and preparing to import the new file.  
09:23 - Car Jas like this. And now I'm going to add a new 
file here. Car JS in here. I'm going to say class  
09:38 - car. So we are defining our car class. And the 
constructor for this class is going to have  
09:46 - four different parameters. So we have here the 
X and the Y and a width and a height. So these  
09:54 - are properties of the car where we want it to be 
in how big should the car be? And we are going to  
10:01 - store these as attributes inside of the object 
like this so that the car remembers where it  
10:10 - is and how big it is. Now, remember, we also had 
this draw being called. So that draw was a method.  
10:20 - And it looks something like this, it gets context 
as a parameter. And in here, we begin path. And we  
10:31 - are going to draw a car as a simple rectangle. 
For now, the rectangle is going to start  
10:38 - at an x&y location. So I'm going to use this 
dot x minus this dot width divided by two.  
10:49 - So the x of the car is going to be the 
center inside the car, and it's going to have  
10:56 - parts in front behind, left and right, so on 
the top bottom, left and right, the y value,  
11:04 - I subtract half the height. So here, we also need 
to specify what is the width and the height of  
11:12 - this rectangle like this, and ask the context to 
fill it like so. And if I'm going to save this and  
11:22 - refresh the page, you can see the car there, or 
at least the black rectangle. For now, the car  
11:28 - is here at 100 100. So on computer screens, the 
y axis actually goes downwards. And the 00 point  
11:39 - relative to this canvas is actually right up 
here. Now, this is really boring as such. So I'm  
11:46 - going to teach you next how to move the car using 
the keyboard arrow keys. So for now, let's just  
11:53 - pretend that we have here some controls 
like this controls is equal to new controls.  
12:04 - And let me link a new file here in 
index controls J S, and also create  
12:18 - controls, J S. And we will do a similar thing as 
previously. So we need a class for these controls.  
12:27 - And the constructor, the controls object 
will have four different attributes,  
12:33 - one of it will know if it's going 
forward, one of it for the left,  
12:42 - one of it for the right, one for the reverse, like 
this. And I set them to false initially, but this  
12:50 - will change depending on what you press on the 
keyboard. So I'm next going to define a method for  
12:57 - adding so called keyboard listeners, 
so that we have a piece of code that  
13:03 - checks whenever we press a key or release a 
key. So I'm going to call here, add keyboard  
13:11 - listeners. And this is going to be a method inside 
of the controls class, like so. The reason I put  
13:20 - here this hashtag in front is because this is 
a private method. You can't access this from  
13:26 - outside that this controls class and you shouldn't 
it's its own responsibility. So how does this add  
13:33 - keyboard listeners look like? Well, we will add 
a key down event to the document and set this  
13:43 - to be equal to this arrow function. I will 
explain arrow functions in just a second. But  
13:49 - let's implement this first. So 
depending on the key that was pressed,  
13:57 - if this was the arrow left key, we are 
going to set this left to true and break  
14:07 - and do the same thing for the arrow right 
key like this. The arrow up key for forward  
14:23 - and the arrow down key for reverse  
14:36 - and that's it. But we also need 
to know when we release a key.  
14:40 - So I'm going to actually copy this code 
here like so. And this is going to be  
14:53 - on key up. And all of these things 
are going to be set to false.  
15:05 - I want to debug if all of this code that we wrote 
works. So I'm going to put here a console table.  
15:17 - This, I'm going to output this entire object into 
the console in a table format. When I press a key,  
15:26 - and when I release a key, I save the file refresh. 
And every time you press something like now I'm  
15:32 - pressing the up key. Now I released the app key. 
Now I'm pressing the Down key, I released the down  
15:41 - key left. And right, you can see the values in 
the console have changed. So this code seems to  
15:50 - be working. Great. But why is it working? So let's 
look a little bit up here. And this part of the  
15:58 - code may be a little strange to you, if you're 
not familiar with this arrow function notation.  
16:05 - This is actually the same thing as writing 
here, function of event like this. So we say  
16:13 - that unki down, this is the function that you're 
going to call. But if you write it like this,  
16:21 - this here stops referring to the object here 
to the controls object, it actually refers to  
16:29 - this function right here. And if I undo and use 
this arrow function notation, this continues  
16:37 - to refer to this object right here. So it's a 
difference in how these two type of functions  
16:44 - work in JavaScript. And it's convenient to have 
it in this way. Now, controls are triggering,  
16:50 - but let's move the car with them. So I'm going 
to go to car Jas. And we are going to write here  
16:58 - an update method. This update method is going to 
check if the controls say forward, let's just move  
17:08 - the car upward. So that means y minus equals to 
remember that y increases downwards on a computer.  
17:20 - And if these controls are reverse, then 
we add to y so that it goes downwards.  
17:30 - Now this won't do anything just yet, we need 
to go to main js here and start to animate.  
17:38 - So I'm going to right here animate and define 
an animate function like this. And inside here,  
17:48 - I'm going to update the car. And then I'm going 
to draw the car using this code we had previously  
17:56 - like this and call request animation frame 
with animate like so. Request Animation Frame  
18:07 - calls the Animate method again and again 
many times per second, it gives the illusion  
18:12 - of movement that we want. Now we can save the 
file, refresh the page. And when I press down,  
18:22 - something happens. So the car updates and redraws 
itself. But all the past positions of the car are  
18:31 - still there. And if I press up now takes a while 
but then it reaches again the top part and you  
18:39 - start seeing it again. But it leaves this black 
trail there. So we need to fix this. And actually,  
18:47 - we need to fix something else as well. If I'm 
going to resize this console here, you will see  
18:53 - that this canvas here doesn't stretch to fill 
the screen vertically anymore. This bothers me.  
19:00 - But it's, it's great, because we can fix both 
of these issues by moving this piece of code  
19:08 - from here to here. When you resize the canvas in 
this way, it means that it also becomes cleared.  
19:18 - So if I refresh now and press the Down 
key, the car is actually seemingly moving  
19:26 - and it doesn't leave that trail anymore. Also, 
if I resize this console here, it looks proper.  
19:37 - You might have to click on the screen here before 
you can press the top and down arrows. Sometimes  
19:45 - these listeners don't activate them unless you 
click inside the page. Okay, problem now is that  
19:52 - this doesn't move like a car at all. We need to 
work on this cars don't move so that you press  
19:59 - on something And then immediately stop, I'm going 
to go to the car constructor here and give the car  
20:08 - a speed attribute and an acceleration value 
like this. And here, instead of changing the  
20:18 - y value on forward, we are going to say that 
the speed will increase by the acceleration,  
20:26 - like this. And I'm going to copy this here below. 
But with minus, and here, I will say this dot  
20:37 - y minus equals this dot speed, I save the file, 
refresh the page, I press down. I press up, we,  
20:54 - okay, we need to stop the car from going 
too fast and implement some friction. So  
21:01 - I'm going to go here and say, max 
speed equals to something like three  
21:09 - and the friction of, let's say, 0.05, like this. 
And in the update method, I'm going to move here  
21:21 - and say, if the speed is more than this max speed, 
this speed becomes max speed, we are capping it  
21:34 - the same if the speed is less than minus this max 
speed. But in reverse, I want the car to be not as  
21:43 - fast, I'm just gonna divide by two here. If it's 
less than this, then I'm gonna cap it to be minus  
21:51 - max speed divided by two, maybe you want to have 
a max reverse speed or something declared on top,  
21:59 - feel free to do it, I think it's overkill. 
Also, there's no such thing as a negative speed,  
22:05 - like what we have here, the negative sign is 
just to indicate that the car is going backwards.  
22:11 - Luckily, this is another course on physics, 
otherwise, I might get in trouble for this.  
22:17 - Next thing we do is check if the speed is 
greater than zero, I will decrease it by  
22:25 - the friction like this. And if the speed is less 
than zero, then speed increases by the friction,  
22:35 - like this. Now I save the file, refresh the 
page, press it down, and the car is moving.  
22:44 - I released and it's slowed down a bit, and then 
it stopped. I'm pressing now up, and I release.  
22:52 - You can see it's still moving a little bit before 
it stops. And I think that this fields quite  
22:59 - okay. But at the moment, the car is only going 
forward and backward and the left and right,  
23:05 - don't do anything. One small issue though, 
let me see if I can get it to happen.  
23:16 - Okay, if you release in just the right way, 
you will see this, let me zoom in a little bit  
23:25 - more. See, the car is actually always 
moving, it's constantly moving, no matter  
23:32 - if we press a key or not, actually, if we don't 
press any key. And it's moving by by a very,  
23:39 - very, very small value. And that's because 
if the speed is not equal to zero, exactly,  
23:46 - then this friction is going to bounce it 
around, and eventually is going to move it  
23:52 - forwards by a very, very small value. So 
to fix this, we can actually right here.  
24:03 - If this speed has absolute value that is less 
than the friction just have it becomes zero  
24:13 - like so. And this is going to work, no need to 
test anymore. Let's implement the left and right  
24:22 - controls next. And say as before, if we press 
left, x gets minus two. And if we press WRITE,  
24:33 - x gets plus two, notice how I implement the 
basic thing first, and make it more advanced  
24:40 - afterwards. I really want you to get the idea that 
everything can be improved, but that you can make  
24:46 - a complex system even with easy components. I 
mean, by the end of this course you will have  
24:52 - a self driving car no matter if it moves like 
now, or if we implement better physics into it.  
24:58 - Now If I refresh the zoom out a 
bit. Now, if I press left and right,  
25:07 - the car moves in a very, very funny, 
non realistic way. But this is actually  
25:15 - how cars move in some games, for example. So if 
you want to make a self driving car for a game,  
25:24 - then this might be enough for you. But I'm 
gonna teach you how to do better than this. And,  
25:30 - actually, I don't like this for one important 
reason, we are breaking the laws of physics,  
25:38 - we have here, the value for this maximum 
speed. And we can reach that maximum  
25:45 - speed by going forward like this. But if I 
press right now, I'm actually going faster  
25:52 - than the maximum speed, but diagonally, 
because I'm going to maximum speed vertically  
25:58 - and a little bit to the left in this case. 
So this is bad for many reasons. Let me teach  
26:06 - you how to fix it. We are gonna go up here and 
define an angle, let's set it to zero. And here,  
26:17 - instead of doing this, we are actually going to 
modify the angle to increase by 0.03, for example.  
26:30 - And here we have angle minus equals 0.03. So 
this angle works according to the unit circle.  
26:41 - But in our case, the value of zero is 
upward. So it's a unit circle that is  
26:48 - rotated 90 degrees counterclockwise, if you will. 
But keep this image of the unit circle in mind of  
26:56 - the rotated unit circle in mind, because this 
is going to be our coordinate system for making  
27:04 - rotations. Speaking of which, we can make a very 
easy rotation like this using the Canvas context.  
27:13 - First, we save the context, then we translate 
to the point where we want the rotation to be  
27:20 - centered at. And now I'm going to tell the context 
to rotate by minus this angle. Next, I'm going to  
27:30 - remove here, this dot x and this dot y, because 
we're already translating to that point. And one  
27:40 - last thing we need to do is here, add the call 
to context restore. Because otherwise, on each  
27:48 - frame of the animation, we are going to translate 
and rotate and translate and rotate and translate  
27:54 - and rotate. And this is going to do some infinite 
series of translations and rotations. That will  
28:00 - look pretty funny, maybe, but not what we want. 
So let me save this refresh. And now when I press  
28:09 - left, my car rotates counterclockwise. And 
when I press right, it's rotates clockwise.  
28:18 - So we have something there. It's not yet good. 
It's more like, like a tank that can rotate in  
28:27 - place. cars can do that. But more importantly, 
if I rotate like this, and press the Down key,  
28:36 - my car just moves downwards in this weird way. And 
this is not correct. And same goes for upwards,  
28:45 - we want the car to actually move in the direction 
of this angle. So I'm going to implement this.  
28:54 - Based on the unit circle again, I'm going 
to make X go minus the sine of the angle  
29:02 - times the speed. So unit circle has a radius of 
one, this sign is between minus one and one. So  
29:10 - we need to scale this by the value of the speed 
as well. And then for y, we do the same thing,  
29:18 - but with the cosine here, according to the unit 
circle. Now we don't need this anymore. I can save  
29:26 - the file, refresh the page, rotate to the left, 
press down and look at that. The car is moving  
29:38 - properly. And I can actually start to 
feel like I'm driving a car. Mm hmm.  
29:50 - But backwards, it's flipped. Like, look 
at this. If I press backwards and right,  
29:57 - the car turns left. That's an That's how it 
happens in in real life. So we need to fix that.  
30:04 - And also this rotating in place. Next, I'm going 
to just put here, if this speed is not zero,  
30:16 - I'm going to calculate a flip. So I'm 
going to say the value of this flip  
30:23 - is one or minus one, depending on the speed, 
so that I can flip the controls backwards.  
30:30 - And if if this is the case, then 
here, I can just multiply by the flip.  
30:44 - If the flip is positive one, then this doesn't 
do anything. So when the car is moving forward,  
30:51 - when it has a positive speed, then this won't 
change. But when we go backwards, what essentially  
30:58 - happens is these signs are flipped. So let me 
close this here, and test again. Now if I press  
31:07 - left and right, nothing happens, because our speed 
is zero. But if I go backwards, and to the right,  
31:15 - it goes just the way I want. And now 
I'm doing these kinds of, I'm trying to  
31:22 - change the direction in the car, similar to how 
it would happen. When driving the car, play around  
31:34 - with it. And if there's something you don't like, 
change it, especially if you're good at physics.  
31:39 - But if you're not, you can try using libraries 
here as well. books to the is a really good one,  
31:45 - I think. But I'm happy with this, there's one 
thing that we don't need anymore. That's the debug  
31:52 - here in the controls, I'm just going to remove 
this, because now I'm confident that the controls  
31:58 - work as I want them to, I'm going to save this 
file. And in car, this update method starts to be  
32:07 - quite big, and more things are going to be coming 
here later. So one good thing would be to group  
32:16 - all this code here in a separate method, I'm going 
to cut it, and the method is going to be called  
32:25 - move, because that's what this is doing. It's 
moving the car, according to the controls. And  
32:33 - the move method is going to be a private method, 
it has the hashtag there. And I paste the code  
32:41 - that we had previously in here, I save 
this refresh, and everything still works.  
32:48 - As previously, I'll show you how to 
do the road next. So in index html,  
32:56 - we are going to say here that we include road 
Jas a new file that we have to also create here,  
33:07 - road Jas, like this. And in here, we are going to 
start to write our road class. So very similar as  
33:18 - before, we have a constructor here. And I want the 
roads to be centered around an x value, and have a  
33:28 - width. Now, these are going to be attributes 
that the roads should remember. And actually,  
33:37 - I want it to have also a number of lanes. So let's 
write here something like this. And define here,  
33:49 - a lane count that has a default value of three. 
For now at least, it's useful to have a few more  
33:56 - attributes here that we can pre compute and 
use later in our calculations. So for example,  
34:03 - we can have a value for left that is half the 
width less than x and a right that is half the  
34:12 - width more than x. And I want the road to go 
infinitely upwards and downwards. So let me  
34:20 - just define here a constant for infinity, really 
large number. There's actually one in JavaScript  
34:28 - already but I found that when drawing things 
with infinite size, weird things happen. So  
34:35 - let's just have a very, very big value here. Like 
this. Our top is going to be minus infinity and  
34:44 - bottom is going to be plus infinity. Remember 
that why on the computer grows downwards.  
34:53 - Now to draw the road I'm going to make a draw 
method here similar what we had the car draw  
35:00 - method. And I'm going to set here a line width of 
five. So a relatively thick line. And I'm going to  
35:08 - make it white. That's how the lines on the road 
usually are. And let's begin a path and move to  
35:21 - left and top and the line to left 
and bottom. So we are now drawing  
35:31 - a vertical line on the left side of 
the screen. I'm going to copy this,  
35:38 - below like this. And I'm also going to draw 
a line on the right side of the screen,  
35:49 - like so. And we are done with this route 
js for now, I'm going to move in the main  
35:58 - js file. And above where we define this car, I'm 
now going to say a road is equal to a new road  
36:10 - centered in half the width of the canvas. 
So that's going to be our center X.  
36:18 - And it's going to have width of the whole canvas 
width, I'm going to now go down here and write  
36:28 - road draw on the canvas as well before the car so 
that the road comes first and then the car on top  
36:36 - of it. Let's now save this refresh. And almost 
nothing happens. But you should be able to see  
36:44 - here on the sides, some white lines there. 
Now they're exactly at the side of the road,  
36:52 - I want to leave a little bit of margin there. So 
I'm gonna make here this with smaller, let's say  
37:02 - 90% of the canvas width, save this, and refresh. 
It looks better already. But we said that our  
37:12 - roads should have some lanes right here in the 
constructor, the third argument, it has by default  
37:21 - three lanes, and we will need to make them appear 
as well. I'll show you, we go back down here.  
37:30 - And I'm going to write a simple for 
loop going from zero to this ln count,  
37:39 - inclusive. So notice here I have 
less or equals to this lane count.  
37:45 - And now I want to know what is the x coordinate 
of each of these lines of these vertical lines  
37:54 - that we are going to draw. And depending on the 
lane count, we will have more or less of these  
38:01 - lines, but also the x values are different. 
We get these using linear interpolation,  
38:07 - I'll show you. We say here, x is equal 
to linear interpolation, or ulurp,  
38:16 - we will write this function Don't worry, it's not 
not complicated. And we will interpolate from left  
38:24 - to right, so we need to get values between 
left and right. According to a percentage,  
38:32 - this percentage is going to be i divided by this 
lane count like this. Think about it. This last  
38:42 - value from here is going to be between zero and 
one when I becomes this lane count, then this  
38:50 - is going to be one. And with all the in between 
values, you just get percent values over here.  
38:57 - So how this slurp function looks like is function 
ulurp. It's a funny name, but they've seen it used  
39:08 - by game developers at least. And that's it. So 
you have the value of a and then the difference  
39:21 - between B and A times this percentage t. So when 
t is zero, this part here is zero, you only have a  
39:33 - when t is one, this minus a from here will cancel 
out and you're just left with b so zero and one or  
39:42 - zero and 100% just give you the two endpoints. And 
for example, when t is in the middle, then this  
39:49 - difference is just half of that difference. So 
it's gonna move half away from a and so on. It's  
39:57 - a really simple function, and I've used it in Very 
many different projects, I really recommend that  
40:02 - you have it in your utilities as well. So let's 
see if it works first, and then I'll move it in  
40:09 - the utils file, it doesn't belong here. We'll be 
using this many times throughout this project.  
40:16 - So here, I'm going to align this part 
like so. But replace here left with x  
40:23 - value like this, and also this one. And 
we don't need this piece of code anymore.  
40:32 - Closing this here, and I think that we 
can save and test and look at that we have  
40:39 - three lanes on our road, I'll move this function 
now in a utils file. So let me create it utils.js,  
40:52 - paste it here. Say save the file, go to index 
html, include it, like this. And now if I refresh,  
41:04 - everything still works. Let me go next to row j, 
s, and add dashes to the middle lines, like so  
41:13 - I'm going to check if I is greater than 
zero and less than this line count,  
41:21 - like this. And in that case, I'm going to 
set line Dash. And I'm going to open an array  
41:29 - 20 and 20. And this means that our dash will 
have 20 pixels, and then a break of 20 pixels  
41:37 - and another dash and so on. So let me close this 
otherwise, for the borders, we are going to put  
41:47 - line dash equal to an empty array like 
that, I'm going to save this refresh.  
41:54 - And there are the dashes. Let's test also with the 
lane count of four just to see if it works. It's  
42:03 - quite nice. But you can see the car is off center. 
Now, I would like it to be on lane, right. So it  
42:12 - would be useful to have a method that tells us 
what is the center of a given lane, let's do it.  
42:22 - Get Lane center with a given index. So this 
will start from left to right starting at zero,  
42:30 - I'm going to get a helper variable first, the 
line width equal to a width divided by the line  
42:39 - count like this. And then using that, I'm going 
to say this left plus half the line width. So  
42:49 - I want to be starting these in the middle of the 
first lane. Plus, I'm going to multiply the lane  
42:59 - index by the line width like this. And this is 
going to give us four different line indices,  
43:09 - an offset of line width away from the middle of 
the first line, oh, not line with lane width.  
43:21 - Line Width is something else. It's the 
thickness of the line. Okay. And to test this,  
43:27 - we can go in main Jas. And here instead of passing 
this 100 for the X of the car, we can write road  
43:37 - get Lane center. And for example, maybe we right 
here three, to put it on the rightmost lane,  
43:47 - save this refresh, and the car is on the 
right lane, right. Let me go to the road  
43:55 - and move this to have a lane count of 
three. Again, I liked that value more.  
44:03 - And now we see a problem the car 
has gone. It's actually here. And  
44:11 - Lane index three, which is now outside the screen. 
So this is something you may want to have fixed  
44:19 - for example, by going here and using the minimum 
function and saying you want the minimum between  
44:28 - the lane index and this lane count minus one. 
With this, the car is going to go on the right  
44:41 - most possible Lane even if you accidentally tell 
it to go more than that. But I prefer my car to be  
44:50 - in the center. So let's put this on lane one 
here. And we'll keep it here for quite some time.  
44:59 - Now This looks nice. And driving on 
this road definitely feels feels nice.  
45:07 - But in the future, I want to detect these 
borders of the road here, and also have  
45:15 - collision detections with them. Because naturally 
we want the car to, to explode and impact. So  
45:23 - basically, it would be nice if the road object 
could tell us where these borders are. And I'm  
45:31 - going to do that. Next, I'm going to go here in 
the road in the constructor, and I'm going to say,  
45:39 - this borders is equal to an array, I'm 
going to put these borders in an array,  
45:46 - we now have just two left and right, but think 
about it, maybe we want to have highways, and  
45:53 - then you have another board there in the middle, 
or maybe some complicated situation requires more  
46:00 - for some reason. So I'm just going to use an array 
and you can experiment with different things.  
46:05 - And the first thing in this array is 
going to be a segment. So top left,  
46:12 - bottom left points form a segment. And 
I'm going to make this also an array,  
46:20 - something like this. And the reason for 
using arrays so much here is that our line  
46:26 - segment here is straight. But maybe you 
want to experiment with something else,  
46:31 - like adding curves on the road. Actually, 
that would be a nice homework for you to do.  
46:37 - So I'm gonna keep a race here like this, the 
borders for now are just two segments made of  
46:47 - two points each. And these are 
going to be here defined like so.  
47:01 - And I just copy this three more times 
and say two, top right. Bottom left.  
47:19 - Bottom Right. And here we have, right, I'm just 
going to copy this down here as well. And here we  
47:29 - have bottom, and I'm gonna copy this here as well, 
I will save this, and nothing really changed. Not  
47:39 - yet at least, because these borders are just here. 
If we say road borders, for example, they are just  
47:47 - in memory. And they are easy to access. Whenever 
we need them, we just ask the road, hey, where  
47:56 - are your borders, and it can give them to us like 
this. So the left border here with the X of 10,  
48:03 - and the right border with x of 190. And plus 
minus infinity for these great, but because  
48:10 - these borders are here, now, it makes sense here 
at the bottom to draw them separately. Because  
48:16 - if we change them, like maybe if you're gonna make 
them curved, this drawing here won't reflect that.  
48:22 - So I'm going to change this to be here 
starting at one and going to lane count,  
48:30 - minus one. And I'm going to 
keep just the line dash here,  
48:38 - like this. And then I'm going to move 
below this and say context set line dash  
48:46 - to empty array. And now I'm going to show 
you a for each syntax, we are going to go  
48:53 - through the borders for each border. 
Let's call it border, I'm going to use  
49:00 - this arrow notation again. And I'm going to say 
context, begin the path. Move to the first point  
49:11 - in the board their X and the Y and do align 
to the second point in the board their x and y  
49:25 - stroke. And that's it. Now keep in mind 
that this doesn't change anything. So  
49:32 - all the code that we are writing now is 
just to make everything more consistent,  
49:37 - but I will teach you a cool trick. Next 
we're gonna make it look like there's  
49:41 - a camera above the car and it's gonna 
follow the car as it moves on the road.  
49:46 - So I'm gonna go here to main Jas, before 
drawing the road. And I'm going to say  
49:54 - save the context and translate nothing on 
X but minus the y value of the car. And  
50:04 - below drawing these things, I'm going to say, 
restore again, like this. And now if I save,  
50:13 - my car moved up there. But if I accelerate, 
you can see that the car actually stand still.  
50:24 - Unless I go left and right, but the road is 
the thing that's moving. So what I want to do  
50:30 - is actually not keep the car up there, but maybe 
move it somewhere down, like for example, CAN bus  
50:40 - height times 50%. So this is now centering the car 
there. As I'm driving, this feels really great.  
50:51 - But maybe a better value would be something 
like 0.7. Because we in this way, we see more  
50:58 - of what is ahead of the car. And later when we add 
traffic, we want to be able to see those things,  
51:04 - and figure out if the car will do the right things 
or not. Really funny how easy this last thing was.  
51:13 - To add sensors to the car, I'm going to go to 
index html and include here. Sensor Jas, save this  
51:25 - file, and create a file called sensor Jas liked 
this. And inside here, I'm gonna define my sensor.  
51:38 - And the constructor will take the car  
51:42 - as the argument. And the reason is that I 
want the sensor to know where the car is,  
51:47 - it's attached to the car, and we're going 
to be using the car properties to update it.  
51:55 - So let's store here the car and other attributes 
will be the array count. So our sensor will  
52:04 - cast arrays in different directions. Let's just 
have three of these arrays for now. And then  
52:11 - the array length. So usually sensors like this 
have a range after which they don't work anymore.  
52:19 - So if they don't sense anything in this 100 
pixels range, then they can see beyond that,  
52:26 - and array spread. So here I'm setting pi divided 
by four, this is the same as 45 degrees. And  
52:36 - that means the angle that we are going to spread 
these rays that are being casted by the sensor.  
52:44 - So I'm going to keep here also an array called 
arrays. And this is going to keep each individual  
52:50 - array one by one after we create them. I'm next 
going to create an update method like this.  
52:58 - And we begin by setting these arrays to an empty 
array. So this arrays is what we are going to  
53:05 - start to populate next. And to do that I'm going 
to loop from zero to this array count, like this.  
53:14 - And I'm going to figure out the angle of each 
individual array. And to do that, I'm going to  
53:22 - use the loop function, our utility function from 
earlier here, that gives us a value between A and  
53:30 - B, depending on T, right. So if I go now back to 
sensors, the angle here is going to be between  
53:44 - Ray spread divided by two, remember the unit 
circle, the rotated unit circle and minus Ray  
53:54 - spread divided by two and the t value. Let's 
have it i divided by this array count minus  
54:04 - one this time, because I is not going to become 
equal to array count. So the maximum value for I  
54:12 - is this array count minus one 
actually need to remember this,  
54:16 - it's quite important. And with this, we can 
calculate the start point for for our array.  
54:24 - And that's just going to be the car X and 
Y like this and an endpoint of the array.  
54:32 - For this endpoint. I'm going to take the car x 
as the starting point. And then using the unit  
54:40 - circle, I'm going to take this angle that we made 
previously, and multiply it by the the length  
54:48 - so unit circle, just one big soul radius. We won't 
see anything we need to scale it up by the array  
54:56 - length here. And we do the very same thing In 
with the y, but with the cosine there instead.  
55:07 - Now with the start and end point available, I'm 
going to push these inside of the array to form  
55:15 - a segment. So notice here, I'm using this way 
of defining the segment, using an array here  
55:22 - in the same way that we used for the borders 
here in road Jas, the road borders are also  
55:33 - going to be made of segments defined in this 
way, it's good to be consistent like this.  
55:40 - Now, we also need to be able to draw 
our sensor. And I'm going to say draw.  
55:50 - And we go through all of the rays like this 
beginner path. And I'm going to put a line  
55:58 - with two. And I'm going to draw these arrays using 
yellow. I will move to the arrays start location,  
56:14 - x and y. So the first thing in the array 
of IRA is its start location. And then  
56:26 - I will line to the race and location. So one with 
x and y there like that. And now I can stroke  
56:38 - and close these like so I seem to be missing 
here a curly brace. Let's save this file,  
56:46 - and now instantiate the sensor, I will go 
to car and inside the car constructor here  
56:56 - above the controls, I think 
it's it's good. I'm going to say  
57:01 - this sensor is equal to new sensor 
of this. So I'm passing the car  
57:09 - through this. And then in the update method here, 
I'm also going to be telling the sensor to update  
57:20 - like this. And in the draw, in addition to drawing 
the car, I'm also going to be telling the sensor  
57:31 - to draw itself. So the car has now the 
responsibility to draw its own sensor.  
57:39 - Let's save this refresh. Okay, so we see now 
three lines popping out from the center of  
57:48 - the car like this. And they're at the 45 degree 
angle, which is good. And when we move the car,  
57:58 - maybe this is not what you want to happen. Maybe 
it is what you want to happen. I don't know,  
58:03 - you can experiment with these things. But I 
would like the sensor to rotate with the car.  
58:10 - So that when the car moves, the sensor also moves. 
But nowadays with gyroscopic technology, you could  
58:17 - probably have this kind of sensor as well if you 
if you actually want. So to fix this, it's really  
58:24 - easy. I just add here to the array angle plus this 
car angle like this. And it works as expected.  
58:42 - Let's play a little bit with these values up here 
more, for example, let's have 30 segments and  
58:51 - make them a bit longer like this. Wow. So many 
rays coming from there. It's like the sun. Let's  
59:02 - actually go all the way. So by The Times two. This 
is now spreading these rays in all directions. So  
59:13 - all 360 degrees, or pi times two there. Let's put 
it to have by so a 90 degree angle. I think I I  
59:24 - liked that. And let's try with Ray count of one. 
We'll have a surprise here. It doesn't work. Two  
59:34 - works just fine. But one doesn't. And 
the reason for that is this thing here,  
59:42 - this array count minus one. If array count is one 
then this becomes zero and we can divide by zero.  
59:51 - So what I'm going to do is I'm just going to 
replace this line. If this array count is one  
59:59 - I'm going to just return half, I want my array 
to be straight up in the middle between the array  
60:07 - span. Otherwise, I just do the exact same thing 
as previously. So now it works, no, no problems.  
60:18 - And we got it to work, we needed to do a little 
bit of more thinking right here, because of this  
60:24 - division by zero. Let's try with more arrays 
to see if that still works. Maybe five. Okay.  
60:33 - Nice. Now, before we get them to work to actually 
detect that there are some road borders here. I  
60:41 - want to refactor this a little bit. So all the 
code here in this update method, I'm going to  
60:49 - cut it and I'm going to say here, this dot private 
method, cast race, like this, and cast race.  
61:05 - He's going to get this code right here. 
This doesn't change anything, everything  
61:11 - still works. But now our update method here is 
simpler and more code can go into it. And we can  
61:17 - read it more clearly. Now, to be able to detect 
the road borders, we need to know where they are.  
61:24 - And at the moment, the sensor has no idea, we need 
to go to main Jas. And the first pass to the car  
61:32 - update method, the road borders like this. Now I'm 
going to go to car Jas and have the road borders  
61:46 - here, like this. And I'm going to take them 
and pass them to the sensor update as well.  
61:54 - So now in the sensor js, the update method 
receives them as well. And now we can use  
62:01 - them to detect with the sensor if the road 
borders are close or not, I'm going to add here,  
62:08 - an array for the readings. So these readings 
are going to be some values for each array,  
62:16 - telling if there is a border there or not. 
And how far is now in this update method.  
62:24 - I'm going to say readings is equal to an 
empty array, I initialize it here. And  
62:29 - then I will iterate through all the arrays 
like this. And add to this readings array,  
62:42 - or reading. So we will get readings 
using a new method that we need to define  
62:48 - that takes a array like this, and the borders 
as parameters. And now we're gonna go down here  
63:01 - and write our get reading method with a array and 
the given borders. So now what I'm going to do  
63:10 - is check to see where this array touches the 
road borders. And now we have just two borders,  
63:16 - one on each side. So one array can only touch 
both of them if the car goes off screen like this,  
63:22 - but it's good to consider multiple intersections 
anyway, especially because later we'll have  
63:27 - traffic. And we'll handle that using the same 
strategy as well. What we'll do is find all these  
63:33 - touches, and then keep the closest one to 
the sensor. And that will be our reading  
63:38 - in the same way that the real sensor would work. 
So let's see where this array touches any borders,  
63:46 - these touches is going to be an empty array. And 
I'm going to go through all the borders one by  
63:54 - one, we just have to at the moment, but it's good 
to write it like this. And we say that the touch  
64:01 - is equal to get intersection, this is going to be 
a function that we will need to write it's going  
64:07 - to be a very useful utility function, you'll 
see and the intersection will be between the  
64:14 - array of zero and the array of one. So this is 
gonna be one segment, so far. And another segment  
64:24 - the I wrote border zero and I wrote border one 
like this. Now if there is a touch, we will add  
64:38 - to our touches. So this get intersection 
function may return know if the segments  
64:46 - don't intersect. So that case nothing gets added 
to this touches array. Now, if we have absolutely  
64:57 - no touches with the given array, Arrays, then 
that means that there is no reading here, we  
65:03 - don't encounter anything with this array. So I'm 
going to say here return no like this. Otherwise.  
65:13 - And now I'm going to teach you a 
little bit more modern JavaScript,  
65:17 - you'll see this get intersection doesn't 
just return the intersection point,  
65:24 - but also an offset how far the 
point is from this array of zero,  
65:32 - which is pretty much the center of the car. So we 
do get with this get intersection, three things,  
65:39 - an x, a y, and this offset value that will be 
quite useful. So I just want all the offsets from  
65:48 - all the touches here in one array. And we can 
use modern JavaScript methods to get that.  
65:58 - Like this, the array map method basically 
goes through all the elements from this array.  
66:05 - And for each element, it takes its offset. 
Now this part here returns a new array.  
66:13 - In this case, it's called offsets. And that's it, 
we don't have to write a lot of code to get this  
66:20 - result here. And I think that's great. Now, 
we want to know from all of these offsets,  
66:26 - the minimum one, like if array touches many 
different things, like many borders or cars will  
66:33 - be later when we add the traffic. So we want to 
know the nearest one after the rate touches that  
66:40 - all the other ones don't exist, basically. 
So we are going to get the minimum offset  
66:48 - using the math minimum method. This minimum method 
here doesn't accept an array as an argument. But  
66:57 - it does work with many, many different values. 
So this dot, dot dot operator is spreading  
67:03 - the array into many different individual 
values. And finally, I'm going to return  
67:12 - the touch that has this minimum offset using 
this find method here. So going through all  
67:22 - the touches, element by element, if the offset 
of that touch is equal to this minimum offset,  
67:30 - it will return that touch. In this 
way, this code is pretty complex  
67:38 - take a while to look over it. But because 
we're using modern JavaScript methods, here,  
67:43 - the code is really short. So try to get used to 
the syntax, because you will see it everywhere,  
67:49 - especially if you work with React. Now I'm 
going to draw these readings somehow here  
67:56 - in the draw method, let, and is equal to the rays 
and points pretty much. But if there is a reading,  
68:11 - I'm going to set and to the value of that 
reading, remember the readings, what comes  
68:20 - from this get intersection function will be three 
things, the x, the y and the offset. So if we say  
68:27 - this here, we essentially pass the x and y to 
this and, and becomes a point with an X and Y  
68:36 - attributes. I'm going to now make this 
yellow segment until end, right here.  
68:51 - Like so. And I still want to know 
where this line would have continued,  
68:56 - I think it's nice to visualize that. 
So I'm going to copy all of this.  
69:03 - And I'm going to just make it, let's say black. 
And here I will draw from the tip of where the  
69:14 - end of the array could be to this end point. If 
it's a reading or not, if not, then this is just  
69:22 - going to be a line that is so small, you can't 
see it. Now, if I save all of this, and refresh,  
69:30 - it works for me, but it doesn't work for you. And 
that's because I have here in the utility file a  
69:38 - secret function that I added without telling you. 
Sorry, let me just indent this a little bit like  
69:47 - so so that you can actually see it. If you want to 
implement this yourself by watching on the screen  
69:54 - right now. I will make a separate video for this 
because I think the topic is very interesting,  
70:00 - and I have a nice way to teach it as well. But 
it works. Look, when I'm moving my car like this,  
70:07 - the race are going to the borders. And immediately 
when they are reaching the board, there's there,  
70:15 - they are turning black, like so. And only the 
yellow part is really interesting. And it's  
70:24 - what we will use later when we define the neural 
network. I'll show you how to implement collisions  
70:32 - next. That is when the car is approaching the side 
of the road here. I wanted to get damaged somehow.  
70:42 - So there's a good news and bad news. Good news 
is that I'm going to teach you how to detect  
70:48 - collisions using the segment intersection code 
from previously. The bad news is that the way that  
70:56 - we draw the car here, by rotating the context, we 
actually don't know where the corners of the car  
71:05 - are, like, what are their coordinates, and we're 
going to need to figure those out first. So  
71:11 - in car js, I'm going to create here a new 
method, and I will call this private method,  
71:23 - Create Polygon, this polygon will have a list 
of points an array of points. So one point per  
71:31 - corner of the car. And great news is that you can 
add more points, you can have different shapes.  
71:38 - And this method I'm going to teach you is going 
to work. So if you look at this car right here,  
71:47 - let me refresh so that it points upwards. And then 
we can use this distance right here as a radius,  
71:56 - like, it's pretty much the same distance no 
matter which of the corners we are looking at.  
72:02 - And the other thing that we will need to figure 
out is this angle, like what is this angle,  
72:09 - knowing the width and the height. So 
this radius is actually very easy to get  
72:17 - using the hypoid method here. So this is the 
hypotenuse of the triangle with width and height,  
72:26 - and I'm dividing it by two, because I just need 
half of it. And the angle here is a little bit  
72:34 - more tricky, maybe. So the tangent of this angle 
is actually the width divided by the height.  
72:43 - So we can use the arc tangent method, 
this eight and two method from the math  
72:51 - library to give us the angle, knowing the width 
and the height, like this. And I don't need to  
73:00 - divide this by two because that angle is the same 
no matter how you look at it. Now with these,  
73:06 - I can add my first point here, that x is 
going to be the center x of the Car minus  
73:15 - the sine of this car angle minus this 
alpha value. So I'm combining here,  
73:24 - the alpha angle, and the car angle as well, 
and then multiplying these by the radius.  
73:32 - And the same thing goes with y. But here I'm 
using the cosine, like this. So this was the top  
73:40 - right point. And we need to do the next ones as 
well. So here, let's just add alpha, like this.  
73:52 - Next point, I'm going to keep minus alpha there, 
but add here, math, pi plus, or 180 degrees.  
74:08 - And the last one, I will copy this one 
from here and change this alpha to a plus.  
74:19 - Like so. And now we just return the points.  
74:23 - And that's it. We want to update 
this after we move the car like this.  
74:30 - So this car will have a polygon attribute that 
will be generated in this way. And to draw the  
74:40 - car, we can now use this polygon instead. So 
instead of this trick here where we translate  
74:46 - the Rotate and then just draw a rectangle here, 
essentially losing the coordinate points, we  
74:52 - can remove all of this and just draw our polygon 
points in order I'll show you, we do begin path,  
75:06 - move to the first point in the polygon, like this.  
75:15 - And now loop through all remaining points.  
75:21 - So notice that I'm starting here at one, because 
I already moved to the first one previously.  
75:28 - And here I'm just going to line to the eighth 
polygons, x and y, like so. And I'm going to film,  
75:42 - save the file, refresh the page. Here, nothing 
happens. So everything still works. But  
75:54 - in a different way, in a better way, I'll 
show you. If we go up here, for example,  
76:00 - and just change one of these points, let's change 
this one by multiplying this radius by three,  
76:08 - then our car will look like that. It's kind of 
kind of funny. So we couldn't do this previously.  
76:15 - And and now we can do crazy things like this, 
like give complex shapes to our car. And we can,  
76:23 - of course, add more points if we want. But I'm 
not going to do that it's your job to experiment.  
76:30 - What I will do is teach how to do the 
intersection between this car polygon  
76:36 - and this line segment on the right, and 
detect if the car is damaged or not. So  
76:45 - let's go up here and say this damaged is equal 
to false, all cars are not damaged to begin with.  
76:55 - And then here, after we have our 
polygon, I'm going to assess damage  
77:02 - a method that we're going to need to write with 
the road borders. So now, here, let's define this  
77:13 - assess damage method, given some roads, borders, 
like so and loop through all the borders.  
77:26 - And check if there is an intersection between 
this polygon and the road border of i The  
77:37 - road border, then we return true. 
If the code reaches here, we return  
77:44 - false. Now we need to implement this Polly's 
intersect function here. And it will be a really  
77:52 - useful utility function that takes two polygons 
here as parameters. Now, notice here that this  
78:00 - road borders of it is actually not 
the polygon. It's a line segment,  
78:05 - but it will be general enough for it to work. So 
let's go now to utils J S. And I'm going to define  
78:16 - our polies intersect method with poly one 
and poly two, like so we look through all  
78:27 - of the points in poly one. And for each of them, 
we check all the points in poly two. And we  
78:37 - are going to see if they touch or not using 
our get intersection function from up here.  
78:49 - So we say here poly one of I and poly one of 
i plus one modulo the length. So this may look  
78:59 - tricky, but all the things that I'm doing here 
is I'm taking one point in the first polygon,  
79:05 - and then the next point in the first polygon. So 
I'm making segments essentially from one point  
79:14 - after the other. But at the end, this will give 
an error when we are reaching is equal to poly one  
79:22 - length minus one, because adding one to that then 
it will go over the array. But if we use here,  
79:30 - the modulo operator like this, then that value 
will become zero. And that's actually great  
79:37 - because the last point in the polygon needs 
to connect to the first point in the polygon,  
79:43 - like point zero. So this code solves two things. 
And I will continue and put the same thing  
79:50 - for poly two with the J this time. So essentially 
I'm taking all the segments that make the first  
79:59 - polygon and comparing them against every segment 
of the other polygon. And if there is a touch,  
80:08 - then I'm going to return true. Otherwise, 
if all of those checks have returned No,  
80:15 - then I will return here. False. So our policies 
don't intersect. Now to see if this works,  
80:22 - I'm going to go back to my car JS here. And 
actually in the draw method, the first thing  
80:30 - that I will do is see if this is a damaged car, 
I'm going to set the field style to gray color.  
80:40 - Otherwise, I will set the field style to one 
black color, like this saving the refresh, and  
80:53 - it changes color. And it changes color immediately 
when the car touches the border, even with this  
81:02 - complicated shape, because we are using each 
segment forming this polygon and comparing it  
81:12 - with the border of the road. Now this method 
is quite general. And it works for complicated  
81:20 - polygons as well. But it can become slow if you 
have very many points. So then you would need  
81:26 - to do some optimization here, maybe look at the 
bounding boxes, first star, or something like  
81:31 - that. And it's really reliable, as long as your 
object doesn't move too quickly. For example,  
81:40 - like if our car would move so fast that it could 
actually jump over a border or over another car in  
81:47 - traffic, then you will need a different collision 
detection strategy for that. But we won't let that  
81:54 - happen. And if I zoom in here, a lot I should 
mention this, because you may wonder why the car  
82:07 - doesn't detect a collision now. 
And the reason for that is that,  
82:11 - well, that line, that border of the road, 
it's a line, it's a mathematical line,  
82:18 - which actually has no thickness. And here we are 
drawing it with relatively thick thickness. And  
82:26 - that's why it looks like it's intersecting even 
though it's not, you could fix this if you want  
82:32 - by drawing the borders of the road with 
actual, very thin, infinitely long rectangles,  
82:39 - put, I'm not gonna do something like that this 
is great for our purpose, let me zoom back out.  
82:47 - Change this car to be a rectangle. Again, I don't 
want to keep it in this crazy shape. And now in  
82:55 - the update method, I will not allow it to move 
if it's damaged. So I'm going to say here, if not  
83:08 - damaged, then do all these things.  
83:14 - Sensor, maybe it's good to be like that. So the 
sensor will still work even if the car is damaged.  
83:20 - Let's see if this has any consequences. If I 
refresh, now, the car is a rectangle again.  
83:27 - And if I go to the side of the road, everything 
stops. So now I can play with the arrow keys,  
83:33 - nothing happens my car is useless. We really 
want to take any kind of impact seriously in  
83:40 - this so I am rendering the car useless at this 
stage. Now the car works, it has sensors, it's  
83:47 - detecting the borders, and it's getting damaged on 
impact. But this is quite lonely, don't you think?  
83:55 - It's time to add some traffic without it making 
it self driving cars not much of a challenge.  
84:02 - You just press the up arrow key and perfect 
driving. So let's add the traffic next. I'm gonna  
84:12 - go in main Jas. And up here I'm going to write 
const traffic is equal to and this is going to be  
84:25 - an array of cars pretty much. I'm going to add the 
nother car here that is on the same lane as our  
84:34 - card that we were used to, but I'm gonna put it in 
front and it's gonna be our first obstacle that we  
84:40 - need to avoid. Now here, we need to update this 
as well. So I'm going to go through all the cars  
84:50 - in our traffic and I'm going to tell each of them 
to update and keep in mind the road borders or  
84:58 - you can also pass there An empty array instead 
of the board, there's, if you want the traffic  
85:03 - to be invulnerable to everything. But I'm gonna 
keep it there for now, let's see later. And  
85:10 - we need to draw these as well. So I'm going 
to go here, another for loop going through  
85:17 - all the things in the traffic. Now we just have 
one thing, but this is going to be a general code.  
85:25 - And it's going to draw each of them on the canvas 
like now I save the file, refresh the page,  
85:33 - and there is another car in front of 
us. And if we press the arrow keys,  
85:40 - something strange happens. We are not controlling 
our car anymore, we are controlling the other car.  
85:48 - And that's because the key listeners are being 
overwritten from the original car to the last car  
85:56 - in the traffic, we're going to need to specify 
which car gets these controls and which not.  
86:04 - So I'm going to go up here and 
tell this car to have here.  
86:11 - Keys, I'm going to say this one to be just 
the dummy, maybe we will have it move slowly  
86:20 - or standstill or something like that. Dummy cars 
will have some very simple behavior. And now we  
86:27 - are going to go to car js. And in the constructor 
here, I'm going to also pass control type. So  
86:37 - either keys or dummy. And I'm going to pass this 
to the controls as well. And in controls Jas.  
86:47 - This constructor will get type like so. And here, 
we are going to switch according to the type.  
86:58 - And we are going to say that in 
case it was keys, we are doing that  
87:05 - break. And in case this is a dumping, I'm going 
to set forward to true and break. Now I save this  
87:15 - refresh a hint, the current front, the current 
front moved, I actually can't catch it.  
87:24 - Because we have the same movement speed, I 
mean, max speed. So it would be nice to go  
87:32 - here in the car constructor. And maybe specify 
here, a value for this max speed. Let's have it  
87:42 - default to three, but allow us to change it from 
the main file. So in main Jas here, I'm going  
87:54 - to set a value of two for the dummy, save this 
refresh. And now I can actually catch that dummy.  
88:07 - So far, the sensors are not reading this 
dummy car, and we're not even getting  
88:11 - damaged by it. We'll take care of that in 
a sec. But first, this scene is becoming  
88:17 - a bit too crowded with all these lines. And 
the dummy car doesn't really need a sensor.  
88:23 - So I'm going to disable this by going 
to our car J S. And if control type  
88:36 - is not dummy, then we will equip this car with 
the sensor. And later where we update the sensor.  
88:50 - We will check if this sensor exists. 
And only then update it. And same goes  
89:01 - down below for the trolling. So if there is 
a sensor, then we are going to draw it. And  
89:13 - now if I refresh that car in front doesn't 
have any sensors doesn't draw any sensors.  
89:21 - It's just a dummy going at fixed max speed 
there on the road. Let's interact with it.  
89:27 - I'm gonna go here in main Jas. And where we 
update here our car, I'm also going to pass  
89:40 - the traffic and because I'm going 
to write some general code here,  
89:46 - this is going to be needed to hear in traffic 
update as well. But I'm just gonna pass nothing  
89:55 - here because if I do pass traffic here, then that 
means that car in traffic is going to interact  
90:02 - with itself. So it's just going to get damaged 
by itself. And I would need to write some code  
90:09 - to prevent that. I'm also thinking about later, 
when we do some more complex simulations. And we  
90:15 - have a bunch of cars, I don't want to have a lot 
of broken down cars on the road and blockades. So  
90:24 - I think that I don't want the traffic to get 
damaged when it's touching other traffic or  
90:31 - us. So I'm leaving it empty. Here in case 
of the traffic, I'm saving this file,  
90:38 - and then I'm going to our car. And in our 
update method, here, I'm going to pass  
90:49 - traffic as well. And this is going to be needed 
inside the assess damage. Here, we will assess  
90:58 - damage with the traffic as well. But also, in 
the sensor update, the sensor will perceive  
91:06 - the traffic as well. Let's do this assess the 
damage first, it's quite easy. I'm going to pass  
91:15 - traffic. And I'm just going to copy this code 
and replace here road borders with traffic.  
91:26 - And here road borders with traffic of i dot 
polygon. I think it's right, I save this  
91:37 - refresh. And now when I press up, I'm catching, 
catching catching that car. And when we collide,  
91:44 - I'm damaged, it's not damaged. Because 
our car it's not in its traffic  
91:51 - list. But feel free to play with the code then 
make it like that if you wish. Now let's do  
91:56 - the sensors as well. So the sensor update here 
gets the traffic. I'm gonna go now to sensor js  
92:07 - and pass the traffic here as well. 
And also to this get reading here,  
92:16 - let me just write it a bit nicer. 
So you can see this on screen.  
92:24 - Like so. And the get reading has now 
a traffic to deal with as well. So  
92:32 - our touches, the things that the rays are 
going to intersect may be road borders, but now  
92:40 - polygon segments from the traffic cars. Let's 
do this. I'm gonna go here below. And I will say  
92:52 - I going through the traffic like this, 
I will get a poorly. I'm doing this just  
93:00 - so that I don't repeat traffic Have I got 
polygon everywhere. And now I'm going to go  
93:10 - through all of the points in that polygon and get 
an intersection value using our utility function  
93:20 - from the array of zero and array of one so this 
is the same as there. But here we are going to  
93:27 - take the polygon J point and J point plus one with 
our module shrink. Now if there is a value here,  
93:38 - then we add it to our touches as well. 
And that's it. Let's Save and test  
93:52 - okay, because the traffic cars are 
black and my array turns black is  
93:59 - it touches the nearest segment of its 
polygon. I don't see things very clearly.  
94:07 - Let me color the cars differently so that 
our car is blue and the traffic is red.  
94:16 - I'm gonna go in main Jas. And here let's 
draw this one as blue and the traffic  
94:27 - as red like this. And inside car Jas. 
I'm going to go down to our troll method  
94:37 - here and say color and the non damaged 
color is going to be color. We save this  
94:48 - refresh. And now we can actually see that the 
array turning black like that and our sensors  
94:58 - are reading that there is dancing in front of it. 
They are working from all different angles. Let  
95:06 - me try a trick I saw once in what was it fast and 
furious, maybe it was much better in that movie.  
95:18 - How it went right through us. We now have a 
complete simulation, a drivable car with sensors  
95:25 - that can see the road borders and other cars in 
traffic. But so far we've been doing the driving,  
95:31 - and that's about to change. Next, I'll give you 
a brief lesson in how our brains work. And then  
95:37 - I'll show you how to code something similar, 
an artificial neural network, you'll learn the  
95:44 - components of this kind of network and how to 
connect it to the car so it can move by itself.  
95:51 - Neural networks are computing systems inspired 
by the biological neural networks in our brain.  
95:58 - These are some neurons, these branch 
like structures received the signals.  
96:04 - When stimulated enough, a neuron will 
fire a signal through its axon. So a  
96:10 - single neuron does something really simple, and 
intelligence only comes when they work as a team.  
96:17 - You see, your brain has 86 billion neurons. You 
also have quite many of them in your spinal cord,  
96:24 - then sensory organs like in your eyes and yours. 
These sensors send signal to some neurons that  
96:32 - pass it to the brain. There the processing happens 
like a chain reaction where some neurons fire  
96:38 - some don't eventually signals arriving to motor 
neurons that pass them through your spinal cord  
96:45 - and make some muscles contract in very specific 
ways. Hey, a lot happened in just a split second,  
96:53 - let me try to slow this down and 
explain it to you. Pay attention.  
97:02 - sensors inside the year pick up 
compression waves from the air and sends  
97:06 - signals to the brain which figures out the 
direction based on different intensities.  
97:11 - signals then traveled to neck muscles tell them 
to contract and turn the head in that direction.  
97:18 - The eye catches a glimpse of what's happening 
and use signals travel to the brain. peripheral  
97:24 - vision is blurry. But good enough information 
exists to detect some kind of object approaching  
97:30 - and new signals travel to facial muscles to 
contract and protect the eyes from getting hurt.  
97:35 - Eyes are really important. At the same time, 
the brain begins to kind of defense protocol by  
97:41 - sending signals throughout the body. Time passes 
and the image becomes more clear. The brain does  
97:48 - pattern matching and recognizes the object as a 
bowl. Contextual and historical information will  
97:54 - play an important role in what happens next. Let's 
stick to the first one. The brain concludes there  
98:00 - is no threat and uses knowledge about physics it 
learned during its lifetime to predict where the  
98:05 - object is headed. It then sends new signals to 
the muscles to contract in slightly different  
98:10 - ways to catch the object instead of blocking it. 
And the rest is history. One history where the  
98:16 - brain did the good thing and not much happens 
afterwards. But sometimes this happens and the  
98:21 - brain learns it did something wrong and configures 
itself. So the same thing doesn't happen again.  
98:27 - Hopefully, anyway, I'm feeling really good about 
myself now that I know my brain can do something  
98:33 - like that in an instant. hope you do too. I work 
cars neural network, we'll do something like that.  
98:41 - Neurons on the first layer will be connected 
to the sensors, they will send signals forward  
98:47 - a few times, and the last layer will be 
connected to the car controls to make it  
98:52 - actually do something. Spoiler alert, we'll be 
working with relatively small networks here.  
98:58 - But that's okay, because we actually don't 
need very large networks to solve this problem.  
99:03 - Now implementing all this in one shot is well, 
scary. But it's easier if you break it into levels  
99:12 - like a building. Each level has a floor 
a ceiling and connections in between.  
99:18 - The ceiling of one level is the floor of the 
next man so on. Now, let's start to code one of  
99:24 - these levels. I'm going to go in index html 
and include a new file here. Let's call it  
99:33 - network Jas and create the file here like this.  
99:42 - Inside the file, we begin to write our level 
class. And a level has a layer of input neurons  
99:49 - and the layer of output neurons. Their numbers 
doesn't necessarily match. So I'll specify these  
99:56 - parameters here like this to define The actual 
neurons, we use simple arrays of values like this,  
100:06 - we need one for the inputs, 
and one for the outputs.  
100:12 - And I'll also add one for the biases, 
each output neuron has a bias,  
100:18 - a value above which it will fire. So I'm 
defining these as an array, like this.  
100:27 - Now, when coding this, I'm actually going to 
connect every input neuron to every output neuron.  
100:32 - That's not the case in our biological brains, 
but these connections will have weights. So  
100:39 - a weight of zero means pretty much the same 
thing. So let's have here, weights equals to  
100:46 - an empty array. And going through all of the 
inputs, I'm going to prepare here, an empty array,  
100:58 - the size of the output count. So 
for each input node, I'm gonna have  
101:04 - output count number of connections. And now what 
we have here so far is actually only a shell for  
101:11 - the brain to function, these weights and biases 
need to be set to some real values. So for that,  
101:18 - I'm actually going to simply randomize for now, 
we're going to have a random brain to begin with.  
101:27 - And to randomize, I'm actually going to define a 
static method here. This is different from what we  
101:34 - usually do, but we do it because I want 
to serialize this object afterwards,  
101:39 - and the methods don't serialize. So here, given 
a level, I'm going to go through its inputs  
101:49 - like this. And for each input, I'm going 
to go through its outputs like this.  
101:57 - And for every input output pair, I'm going 
to set the weight to a random value between  
102:06 - minus one and one. And to do that, I'm gonna 
write here, math dot random, which gives us  
102:12 - a value between zero and one, multiply this by 
two. So now we have a value between zero and two,  
102:20 - and subtract one. And now we have a value between 
minus one and one. And actually biases are going  
102:30 - to be in the same range as well. And you may 
wonder why negative values. And here's one reason  
102:37 - for it, think what should happen here, the car 
sees something with the front sensor, so it should  
102:44 - turn to avoid collision. But which way, negative 
weights connected to these sensors on the right  
102:50 - could send the message that don't turn to the 
right. So the remaining option is to turn left,  
102:58 - both weights and biases can be between minus one 
and one. And there is a nice mathematical reason  
103:04 - for this, which I will explain soon. Now, these 
inputs, they will be the values that we get from  
103:11 - the car sensors. And what we need to do is compute 
the outputs using these weights and biases that we  
103:18 - defined. Those are random for now. But in a smart 
brain, they will have some kind of structure,  
103:25 - we compute the output values using a feed forward 
algorithm. And it's actually quite simple.  
103:34 - Given some inputs, these given inputs, 
and I'm passing here the level as well,  
103:40 - I'm going to go through all of the level inputs, 
and I'm first going to just set them to these  
103:47 - given inputs, these will be the values that come 
from the sensor. So we do that using a simple for  
103:53 - loop like this. And now to get the outputs 
we are going to loop through every output  
104:03 - like this. And we are going to calculate some 
kind of sum between the value of the inputs  
104:12 - and the weights, I'll show you. So this sum is 
zero in the beginning. And now we are going to use  
104:20 - another variable j to loop through the inputs like 
this. And the sum will actually add the product  
104:30 - between the JSON input and the weight between 
the Chained input and the output like so. And  
104:39 - we repeat this with every input neuron. So, 
in the end, what we will have to do is check  
104:47 - is this sum greater than the bias of this output 
neuron and if so, we are going to set the output  
104:56 - neuron to one so we are essential Returning it on. 
Otherwise, the output neuron is going to be set to  
105:06 - zero. It's as simple as that. And now I just want 
to close this and return here, the outputs for  
105:16 - convenience. And I need to also close this level 
class right here. Now this code will work. And  
105:27 - we'll leave it as such. But I'm going to tell you 
a story. And it's a bit scary. So brace yourself.  
105:34 - You see, scientists like to write it by adding the 
bias here and comparing with zero. Because biases  
105:41 - can go either way, any structure implemented 
like this can be implemented this way as well.  
105:48 - And this, what we have now is 
the hyperplane equation. But  
105:55 - don't be scared. You see, in a very, very 
simple network, this is the line equation,  
106:02 - a very simple function. The one and 
only wait here controls the slope,  
106:08 - and the bias controls the y intercept, we 
have a function like this for each output,  
106:15 - these neurons will fire if the 
value of the function is above zero.  
106:19 - And with weights and biases between minus one and 
one, you can implement any situation. That's why  
106:25 - that rage. Now, when you have two sensors, you 
have a plane in 3d space. Think about the plane  
106:34 - that goes out of water like this. If the value of 
the two sensors is on dry land, then the neuron  
106:41 - will fire. When you add more sensors, you have 
higher dimensions that are harder to visualize.  
106:47 - But the math still works. And you 
can have as many sensors as you want.  
106:52 - I could go on with this story for hours and tell 
you that scientists don't use binary values here,  
106:57 - but instead allow neurons to fire all the time 
just at different amounts. I mean, it happens here  
107:04 - for these first ones, so why not for the other 
ones as well. Only the last ones need to be binary  
107:11 - to give you a clear yes or no answer. But networks 
are more powerful if these are left as such,  
107:17 - actually not exactly as such, because the values 
here tend to go a bit out of control and a more  
107:24 - complex function is often used to bring them back 
to scale. Now the story may turn into an actual  
107:30 - horror, if I start to tell you about what the 
layers actually do. Moving from linearly separable  
107:37 - cases to non linearly separable ones, and fine, 
fine, I stopped this now. But if you want to  
107:43 - experiment with things like that, you probably 
want to try some kind of library, like TensorFlow,  
107:49 - and there are actually more of them out there. 
Also, let me know if you're ready for more  
107:53 - advanced content like this, and maybe I'll make 
it someday. Meanwhile, I recommend three blue one  
108:00 - brown video on neural networks, it focuses more 
on the mathematics and uses things like vectors,  
108:05 - matrices, and other things that tend to scare 
students off for some reason, I try to avoid these  
108:11 - here. But if you plan to master machine learning, 
someday, you're gonna have to learn them. Sorry.  
108:18 - Now let's get back to completing our neural 
network code. So far, we have just one level.  
108:24 - Let's go now up here in the beginning, and define 
a neural network made out of many of these.  
108:32 - So I'm going to say here, class neural network, 
like so. And the constructor is going to get an  
108:42 - array of neuron counts. So this is going 
to be the number of neurons in each layer.  
108:52 - And I will define here, the levels, I'm going to 
make my neural network out of an array of levels,  
108:58 - those we defined earlier. And for 
each level, I'm going to specify  
109:07 - the input and output count like this. So I'm 
adding here, a new level with the neuron counts  
109:19 - from the eyes index, and the neuron counts from 
the i plus one index. That's it. Simple as that.  
109:31 - And here, we're going to need a feed forward 
algorithm as well. And this is also going to be  
109:37 - really easy. So in the same way, given inputs 
and the network, I'm going to get the outputs  
109:45 - by calling the feed forward method from the 
level with the given inputs and the network's  
109:54 - first level like so. So this is now calling 
the first level All to produce its outputs.  
110:02 - But then I'm going to loop through the remaining 
levels. So notice that here, I'm starting at  
110:12 - i equals to one. So looping through the remaining 
levels like this, I'm going to update this outputs  
110:22 - with the feed forward result. From the level, I 
like this, let me close this, return the final  
110:36 - outputs. And we are done with the feed forward 
method and with the neural network object.  
110:43 - So what we're doing here is essentially putting 
in the output of the previous level, into the  
110:52 - new level as the input. And the final outputs will 
tell us if the car should go forward, backward to  
110:59 - left or right. Now let's connect this network to 
our car sensors. So I'm going to go to car here,  
111:08 - all the way up in the constructor. And where we're 
saying that we defined sensors for our car, I'm  
111:16 - also going to say this dot grain is equal to new 
neural network. And here we have to specify our  
111:27 - array of neuron counts the size of the layers. 
So in the first layer, we are going to have  
111:35 - this dot sensor that array count. And here you 
can have as many layers as you want, but I'm just  
111:43 - going to add two of them. one hidden layer, and 
the output layer, which will have four neurons,  
111:50 - one for forward, one for backward, one for left, 
and one for right. Let's close this, like so.  
111:58 - And now, after we update the sensor here, 
I'm going to first take out the offsets from  
112:08 - the sensor readings. Remember, our readings 
had three things an x of y, and the offset  
112:16 - of where the reading was. And from each sensor 
reading, let's call it S, I'm going to check if it  
112:25 - is no, then I'm just going to return zero, there 
is no reading here, the sensor goes as far as  
112:32 - possible and doesn't see anything. Otherwise, 
I'm going to return here, one minus the sensor  
112:40 - offset. I'm doing this because I want our neurons 
to receive low values if the object is far away,  
112:48 - and higher values close to 
one if the object is close,  
112:52 - kind of like this flashlight. When we pointed 
at the wall, we see the light coming back at us.  
112:58 - And if we get closer, the light that bounces back 
is stronger. That's how sensors work in practice.  
113:05 - Now to see what the neural network has to say, 
we just say outputs is equal to a neural network,  
113:13 - feed forward these offsets with this brain. And 
I'm going to log here these outputs to test for  
113:24 - now, if I save the file, and refresh the page, I'm 
gonna get there at the bottom in the console, some  
113:32 - array of values for values, one for forward, one 
for left, one for right and one for backwards. So  
113:40 - at the moment, the car should actually go forward, 
left and right at the same time. But it can't do  
113:47 - that because the brain is not yet connected to 
the controls. It's kind of like when I had the  
113:52 - knee surgery a while back and they paralyzed me 
from the waist down. While the anesthetic was  
113:58 - wearing off, I really tried moving my feet brain 
was working normally, but motor neurons were  
114:04 - just not sending the signals properly. To make 
the car do its own decisions, we are going to  
114:11 - go here in main js. And instead of using the 
keys to control the car, let's write here, a  
114:20 - AI for artificial intelligence. I'm going to save 
this file and then car js. Up in the constructor.  
114:30 - I'm going to define here an attribute called 
use brain that is going to be equal to control  
114:39 - type double equals AI. So if our control 
type is AI, it means that the brain that  
114:48 - the car actually has already is going 
to be in use. So down here in update  
114:59 - if This brain is in use, we are going to say the 
controls forward, this is going to be equal to  
115:08 - output six zero controls left, this 
is going to be equal to outputs of one  
115:13 - controls, right, this is going to be called 
two outputs of two and controls. Reverse,  
115:20 - I think it was, is equal to outputs of 
three, let me just check this real quick.  
115:27 - Yes, it's reverse, saving this file, refresh 
the page. And nothing happens. But if you look  
115:36 - in the output, you'll see that this array has 
four zeros in it. So nothing is on forward,  
115:43 - reverse left or right, nothing is pressed. Let's 
try to refresh again, remember, these networks  
115:48 - are random so we can get anything out of this. 
Okay, this was interesting. So we have their  
115:57 - right and reverse turned on. So this was a card 
that just went backwards and to the right, okay,  
116:05 - here, we have a car going forwards, 
left, and then reverse. So the forward  
116:11 - then reverse actually cancel each other 
out, and the car is standing still. Okay.  
116:20 - Now, this is really interesting, we have a 
car that goes forward. So it went forward in  
116:26 - the beginning. But look what happens. Now, when 
those two sensors are touching the car in front,  
116:33 - the network somehow triggers the brake. It's 
amazing, this was randomly generated, and we  
116:39 - were lucky to get the really nice behavior out 
of this. So our car is supplying the brake, every  
116:46 - time it gets really close to the other car, and 
just out of luck, it's not colliding with it. So  
116:52 - it's doing this kind of stoking motion there. Now, 
this debugging here is not really very useful,  
117:00 - printing out the outputs like this. And actually 
debugging things like this is really hard,  
117:06 - you could go here and say, for example, car dot 
brain, and look at it and see that yes, it does  
117:16 - have these two levels that we defined previously. 
And the first level has some inputs, some biases.  
117:28 - So we have the inputs, here, you can see 000, for 
the middle ones, and some values for the first  
117:36 - and the last one, which is great, we visually 
see that one as well. And the outputs should be  
117:42 - for the first level here. One, one, and all the 
other ones are zero. But then the second level  
117:51 - is going to get those inputs, the 110000. And this 
network with these biases, random values between  
118:01 - minus one and one. And these weights, also many, 
many random values between minus one and one,  
118:08 - produce the result that you see here. So 
going forward, and reverse and left and right,  
118:15 - everything just cancels each other out, then 
our car with all this brain does nothing.  
118:22 - So you can see how debugging like this is 
very, very difficult. And we don't really  
118:28 - get the full picture unless we really start to 
analyze all these numbers here. And that's why  
118:35 - it's gonna be really great. When we visualize 
something here, I mean, make something that  
118:41 - at a glance, we can see this entire network in 
action. So I'm gonna go to index html here. And  
118:49 - I'm actually going to refactor things a bit. This, 
my canvas from the beginning, is gonna be called  
118:56 - car canvas like this. And we're gonna use another 
canvas on the right to display the network.  
119:05 - So we're gonna visualize a neural network in 
this one. Now, let me save this and go to our CSS  
119:14 - file. And my canvas will be renamed to 
car canvas. And I'm going to copy this  
119:21 - as network canvas and to distinguish between 
them. Let's make this background black.  
119:31 - Like this, now, in main Jas, I'm going to 
go here at the top and say that this all we  
119:39 - did so far is on the car canvas. And I'm actually 
going to refactor everywhere it says canvas here,  
119:48 - by pressing right click Rename symbol and saying 
here, car canvas like this, and this CT x is going  
119:58 - to be renamed to car seat dx, like this. And I'm 
gonna copy this part right here for the network  
120:11 - Canvas. So here we have network, Canvas, and 
network canvas. And here also network canvas.  
120:26 - And I think this one can be a little bit wider. 
Let's see if we can fit 300 pixels wide Canvas  
120:32 - next to our car Canvas from previously, 
then here, the car context is going to need  
120:39 - network context next to it. So network 
context coming from our network canvas,  
120:49 - right. And one more thing we need to do here, 
when we make our car Canvas have the same size as  
120:57 - the screen vertically, I'm going to do the same 
thing for our network accounts. Save the file,  
121:05 - refresh the page, and we have our car on the 
left doing something, whatever it's doing,  
121:12 - and every time we refresh, it's probably gonna do 
something different. Probably not something smart.  
121:21 - And on the right, we have a blank blank canvas 
that also stretches quite nicely with the size  
121:28 - of the screen. And what will be really great is if 
you can go here, after drawing all the car related  
121:36 - stuff, and saying visualizer draw me a network 
on the network context, and put there the car  
121:46 - brain like this. And now I'm actually going to add 
some code here that does the visualization for us.  
121:54 - I'm not teaching it here, because I think we 
would be sidetracking too much. But it's really  
121:59 - well described on my channel and their source 
code in the description. So saving everything  
122:07 - refreshed the page, and we have network 
that decides our car should go in reverse.  
122:16 - quite boring, let's try refreshing again.  
122:20 - This network says it should go forward, left 
and then reverse. So basically, it stands still  
122:29 - forward right and reverse. Right then 
reverse. That was kind of interesting.  
122:37 - One more thing is that this visualization 
also supports animation. So we could animate  
122:43 - this visualizer if you want by going 
here and specifying a time argument,  
122:50 - this value comes from the request animation 
frame method here. And here we can say network,  
122:59 - C dx dot line dash offset is equal to 
time. And when we do this, all by, okay,  
123:11 - this is a bit too fast. Let's slow down this 
a bit by dividing here by 50. And actually,  
123:20 - this animation should go the other way around. So 
I'm going to specify here minus time divided by  
123:27 - 50. And now it's a visual reminder that this 
is implementing the feed forward algorithm.  
123:34 - This thing here, one by one, these randomly 
generated networks and expecting some miracle is  
123:43 - not very convenient. So let's write some code 
to parallelize this and have many cars running  
123:51 - simultaneously, like in different parallel 
universes. I'm going to define here a function  
123:59 - called Generate cars that accepts and as the 
argument and I'm going to have an empty array  
124:10 - of cars at first. And then for i from one to N, 
I'm going to push a new car into this array and  
124:21 - the car is going to be centered in the middle lane 
at 100 Why with 30, width and 50 height like so,  
124:29 - and they are all going to be AI cars. And 
here I just return these cars like so. And up  
124:38 - here where we have car defined we are actually 
going to define cars instead equal to generate  
124:51 - cars have n like this and our n is equal to 
100. So we are going to have 100 cars going  
125:02 - in parallel, and hopefully one of them is going to 
do something right, we need to update these cars  
125:10 - here. So where we have here car dot update, we 
are going to write a loop and say, let i is equal  
125:17 - to zero, i is less than cars dot length, i plus 
plus. And then we have here cars of hi update,  
125:29 - like so. And we are going to do the same 
for the drawing down here, drawing them  
125:38 - as blue like this. But we still have two 
individual car objects here from previously.  
125:48 - And I only need one car here. So let's 
just replace it with the first car in the  
125:55 - array for now. Otherwise, this code will not 
work. So this is for translating the canvas on  
126:05 - one car from the 100. And this is just printing 
the brain of this one car somewhere on the right,  
126:13 - save the file, refresh the page, and then how its 
total mesh. One thing we can do to make this nicer  
126:25 - is actually drawed them semi transparent. So I'm 
going to go here and say car city x dot global  
126:35 - alpha is equal to 0.2. And after I'm done drawing 
these cars, I'm going to set global Alpha back to  
126:44 - one. So it doesn't affect what I'm going to 
be drawing afterwards or on the next frame.  
126:50 - So saving this and refreshing, it's a little bit 
better, but still quite much happening there.  
127:00 - I think that I want to emphasize one 
car, like for example, the zeroeth car,  
127:07 - this one that we are using everywhere, pretty 
much by drawing it again with the maximum opacity.  
127:17 - But also I want this one to be the only car 
for which we draw the sensors. So I'm going to  
127:24 - modify this draw method of the car next, 
and say here, a third parameter for draw  
127:35 - sensor. This is by default set to false. And 
here, if this sensor exists, and draw sensor,  
127:46 - only then we are going to draw its sensor. 
And now it's a little bit clearer, not so many  
127:53 - yellow lines there. And you can see something 
interesting already, that this car right here,  
128:01 - car zero is not the most interesting one, the most 
interesting one went somewhere up there, and it  
128:08 - was chasing the other red car. So back to main js, 
here, our cars have zero choices not really great,  
128:18 - we want to focus on the best car, the one that 
goes upwards, the most or the one with the minimum  
128:24 - y value. And I'm going to define this best car 
here and say, best car is equal to find the car  
128:40 - whose y value is equal to 
the minimum value, okay? Of  
128:52 - all the Y values of the cars. So this may seem a 
little bit scary. So what is happening here, cars  
129:04 - dot map, see going to see dot y this means that we 
are creating a new array with only the y values of  
129:13 - the cars. That's it. And here we are spreading 
this array because the math main method here  
129:22 - doesn't work with arrays. It works with many, 
many different values no matter how many you  
129:27 - want to pass it, but not with actual arrays. 
And that's why we need to spread it here.  
129:33 - And we just find the car whose y value is the 
minimum value of all the y values. The code is  
129:41 - not really complicated. But if you're not used 
to this modern syntax, then this can be a little  
129:46 - bit daunting at first. I added here because 
you will see it if you work with JavaScript.  
129:52 - So now with this best car, I'm going to copy 
it everywhere. We were using cars of zero  
129:58 - previously so we translate the canvas to the 
best cars. Why like this. And then here we are  
130:08 - drawing the best car without transparency so 
that we clearly see it. And with the sensors,  
130:16 - we are also drawing the brain of this best 
car. And that's it, I'm going to save this  
130:23 - and refresh. And now our canvas is always centered 
on the car that goes upwards, the most, in this  
130:33 - case, these stalking cars that are behind this 
red one. All right, let's try to refresh again.  
130:48 - And again, I'm waiting for a 
car that passes this red car,  
130:52 - but then continues to go in a straight 
line somehow. So just by trial and error,  
130:58 - I think that we're going to be able to 
get to something like that, let's see.  
131:13 - Okay, we got something, it's fidgeting quite 
a lot, but definitely better than all other  
131:20 - cars we had so far, it passed the car in the 
traffic, and it's just going forward forever,  
131:26 - pretty much. But now the problem is that when I 
leave the browser, this car is going to be gone.  
131:30 - And all my experimenting was for nothing. 
So let's write some code to save this car.  
131:39 - I'm going to use local storage for 
this. So I'm going to say, local storage  
131:46 - set item, the best brain that we have. So far, 
we're going to store it in this best brain  
131:54 - attribute and local storage. And the value is 
going to be a JSON string coming from the best  
132:04 - cars brain. So I'm essentially serializing that 
brain into local storage. And come to think of it  
132:12 - we might need to destroy the saved brain as well. 
So I'm going to discard, maybe it's a better word,  
132:20 - the value from local storage with this other 
function, I'm sure is going to be needed  
132:26 - sooner or later. Now this best car is actually not 
accessible here. So let me just update its value  
132:35 - here. But define it here as a global variable. 
Like this, I'm using lit because it's changing.  
132:44 - And I'm gonna set it to be the first car in the 
beginning, but it's gonna update on every frame.  
132:52 - Now, if we have in local storage 
of brain or best brain stored,  
133:00 - I'm going to set the brain of this best 
car to the value and I'm using JSON parse  
133:07 - because I am parsing the JSON string we saved 
previously, local storage only works with strings  
133:22 - like this. Now, in index html, I'm going to put 
these buttons vertically between the two canvases.  
133:31 - So here, I'm going to use a div to define river 
vertical buttons with ID vertical buttons.  
133:42 - And I'm going to say here, the first 
button is going to have an unclick of safe  
133:51 - like this and our second button is going 
to have an on click of this card, like so.  
134:09 - And here I'm actually going to use emojis 
for these boughten contents like this with  
134:16 - the save icon and trash like you can find 
emojis like this just by searching online.  
134:22 - So I'm gonna save this file and go to 
the CSS next, and remove this text align  
134:30 - from the body because we're going to use flex 
display instead. So I'm going to remove this  
134:37 - and say, display, flex, justify content and align 
items to center like this. And now our vertical  
134:52 - buttons are going to go here with display flex and 
flex direction column So this is by default row.  
135:02 - And making it column means that our buttons will 
go below each other. And here we define our button  
135:09 - next. So I like to remove the border and give it 
a round shape. So a radius there. And a padding,  
135:20 - this is some value that I found goes nicely 
with the emojis that we use, and the margin  
135:26 - of two pixels. And the cursor is set to pointer 
so that our arrow icon changes into a hand cursor  
135:34 - when the mouse is over it. And speaking of 
hovering with the mouse, let's set hover  
135:41 - for the button so that it gets blue background 
like this. So save the file, refresh the page.  
135:53 - And looks like we have another shaky car over 
here. But we are not going to lose it this  
135:59 - time. Because we can press the save button. And 
this means that now inside of our local storage,  
136:06 - we have this cars brain. So now when I'm going 
to refresh the page, what that means is that  
136:14 - here inside of main js, where we are loading the 
value from local storage, we still get the car  
136:24 - from previously. Now what we are doing here, 
could we actually fully automated so that the  
136:29 - computer tries again and again, and always keeps 
the best. But let's think about what the goal is.  
136:36 - I mean, what will a good network be able to do? 
Let's look at the definition of the best car here.  
136:43 - We're just using the y coordinate. But you can 
use other functions here as well. These are  
136:48 - called fitness functions. For example, you 
could measure the travel distance instead.  
136:55 - Doing that may result in cars that go backwards 
as an easy way to avoid the obstacles. Or just  
137:02 - go around in circles forever, going infinitely 
far, but also going nowhere at the same time.  
137:09 - So need to be careful when choosing a fitness 
function. I'm using the y value here. But if the  
137:15 - road would be turning, it wouldn't work anymore. 
So think about these and play around with the code  
137:22 - and try to think about other stuff as well. Like 
could you come up with a fitness function that  
137:27 - keeps rewarding the car for going upwards, 
but penalizes for going too much sideways,  
137:33 - or even better penalizes if you're 
not in the center of the lane.  
137:38 - These are all homework ideas for you. But 
now I think we're ready for more traffic.  
137:43 - Let's go here in our traffic array, put a comma at 
the end and add two more cars. One is going to be  
137:55 - on lane zero, and minus say 300 and the other 
one at the same vertical level. But lane  
138:05 - two, I'm going to save this refresh. 
And now let's see what happens  
138:17 - almost there. But that looks like even our 
shaky car didn't make it. So let's try again.  
138:35 - It looks like there are just not enough cars 
passing that first car in traffic. What we would  
138:41 - like to have is more cars like this shaky car. 
But not exactly like it so that one of them may be  
138:49 - is gonna stand the chance and pass the 
second and third car in the traffic. So  
138:56 - let's go now to network Jas. And I will teach 
you how to mutate a network. And it might  
139:04 - sound fancy, but it's really really easy. I'll 
show you. We right here a method called mutate,  
139:12 - which takes a network as a parameter and an 
amount. Let's default this to one or 100%.  
139:20 - This will just randomize everything what we had 
previously. But if you set this value to like 10%,  
139:27 - then you're gonna get the network that is 
close to the original one that we pass it here.  
139:34 - So how does this work? Well, we are going to go 
through all the levels of the network using a  
139:42 - for each loop like this. And for each level, I'm 
going to use this arrow function notation here.  
139:50 - I'm going to iterate through all the biases and 
then through all the weights later, but first  
139:58 - with the biases and I'm going to say that the AI 
bias is going to be equal to learn, we're going  
140:07 - to use linear interpolation again. And I will 
interpolate between the current value of the bias,  
140:15 - whatever that is, and a random value between minus 
one and one, as we did in the randomizing, but now  
140:24 - we're using loop to go from the current value of 
the bias to words, whatever that random value is,  
140:33 - depending on this amount right here. As 
simple as that. And I'm just going to repeat  
140:39 - the same thing for all the weights. So I 
just go through all the IJ weights like this.  
140:53 - And say that those weights, that 
weight of ing scoring to be equal to  
141:01 - linear interpolation between the current value of 
the weight and a value between minus one and one  
141:11 - random value. And again, depending on this 
amount, so if this amount is going to be  
141:20 - let me see, did I close this properly? Nope. So if 
this amount is going to be 100%, then we just get  
141:29 - this part right here. And this mutate is pretty 
much our randomized method that we had previously  
141:36 - here for a level. But now it works for the entire 
network. So if the amount is zero, then our  
141:44 - biases, and our weights just stayed the same. But 
if this value is somewhere in between, then it's  
141:52 - going to move away from these biases, depending 
on this amount. So let me save this file now.  
141:59 - And go back to main js, where we are reading the 
brain from the local storage here. And actually,  
142:08 - we are going to loop through all the cars and say, 
let i is equal to zero, less than cars dot length,  
142:18 - i plus plus. So for each car here, cars 
of high hits brain, it's going to become  
142:30 - equal to that from the local storage. So this 
as such is going to be really, really boring,  
142:38 - right? Because it means that if we refresh now, we 
just see 100 cars that are overlapping each other,  
142:46 - and they're, that are acting exactly the same.  
142:51 - But I'm going to put here a condition and say 
that if AI is not zero, so the brain that we have  
143:00 - in local storage will be kept for the case when 
I zero and that is our best car initialization  
143:08 - there. But for all the other ones, I'm going 
to mutate and say neural network, dot mutate  
143:17 - the car, have I brain by an amount, let's 
say 0.1. And now let's see what happens.  
143:29 - You can see many cars this time, but they are 
all following our shaky car quite closely.  
143:37 - This one, none of them was able to go beyond 
that second car in traffic. Let's try again.  
143:52 - Nope, it looks like this 0.1 might be too low. 
Basically, our new networks are too similar to the  
144:01 - one that we already have in memory. So let's try 
0.2. Now our cars look a little bit more different  
144:11 - than before, but still quite similar to our shaky 
car. And look at that we have a new best car.  
144:19 - Maybe. I hope it doesn't hit the border 
now. Yes, it figured out it has to turn.  
144:26 - That's great. So I'm going to save this new car 
right now. And when I'm going to refresh, now,  
144:33 - our new car the more improved car which 
wasn't even shaking is stored in memory  
144:40 - and it's going to mutate and try to become even 
better if possible. But our scenario now with  
144:47 - three cars is not a match anymore, so we can try 
even harder one. Let's go here and copy this.  
144:59 - Maybe The four more times. And here let's have 
two cars at minus 500. And the last at minus  
145:12 - 700. And we are going to have here maybe on 
lane zero and Lane one, and then on lane one  
145:21 - and lane two. So I'm just thinking how to 
make a complicated scenario that involves  
145:28 - all kinds of twists and turns. So let's save 
this and refresh. And now let's see what happens  
145:43 - okay, I'm gonna save this I did it before 
this other boring car over took it.  
145:53 - So that's something that you may want 
to pay attention to. Let's refresh  
146:11 - nothing I think we want the lower 
value for the mutation here.  
146:21 - So that more cars are going to be like that one 
that almost wented past these other two cars.  
146:29 - You can see quite many of them here 
now. Still nothing. Let's try again  
146:49 - okay, this is interesting. I would 
say this is a new winner now.  
146:54 - It got to this stage and now it's going 
in line with the other cars. Let's save  
146:59 - it. It's taking too long. Let me try with 1000 
cars. I think this should work on my computer  
147:13 - if your computer is too slow, then just 
stick with 100 cars and repeat more.  
147:22 - Ah, almost there. You  
147:53 - Yes, yes, we did it. We did it. 
Oh, no, no, no, no, no, no, no.  
148:06 - I should have saved that one. I think it could 
have mutated into something good eventually.  
148:14 - Hmm. Let me save this. It's clearly better.  
148:22 - Come on. I'm hopeful that this time 
we're going to make it. Let's see.  
148:33 - Okay, two cars there now. Will one 
of them stop before hit? Yes. Yes,  
148:40 - that car stopped just before hitting the 
sides there. Let me save this. Try again.  
149:03 - And now we have quite many of 
them that are quite similar.  
149:07 - Okay, let's keep just one car here and see it in 
action without any other things disturbing it.  
149:16 - Okay, that was quite, quite close there.  
149:24 - Oh, yes. Somehow I thought it's gonna get damaged 
even though I know that it's the best car from  
149:30 - previously so it won't get damaged. There are many 
more sophisticated genetic algorithms out there.  
149:36 - For example, some algorithms use crossover. So 
they take two networks and mush them together  
149:43 - somehow. The hope is that maybe one car knows how 
to turn left really well and another one knows how  
149:49 - to turn right. So combining these networks 
could give you a new one that can do both.  
149:56 - Thank you can implement this. If you got this 
far. I think You can try it out and let me know  
150:02 - how it went. We are now actually done, I 
won't be teaching you any more algorithms,  
150:08 - you have many things you can play around with. 
And I'm quite happy with the car we have right now  
150:14 - it's making its own decisions, and it's avoiding 
all other cars. It couldn't be better like if it  
150:20 - would recognize the lanes, but I'll let you worry 
about that. Meanwhile, I'm going to relax and show  
150:26 - you how to draw a car in PowerPoint. Since you've 
got this far, all I can say is congratulations.  
150:36 - Hope you took things seriously. And by now 
you've learned how to simulate driving mechanics  
150:41 - detect collisions and create artificial 
sensors. You also know about neural networks,  
150:47 - what they can do and how to optimize 
them using a simple genetic algorithm.  
150:52 - But we just scratched the surface here, and 
I haven't really taught you why the neural  
150:57 - network works. I mean, sure, we built one. 
And because it's so complex, you can assume  
151:03 - some smart behavior is possible. But how does it 
really work? We have such a great system now that  
151:10 - it's a shame to put it to waste. So I'm thinking 
about making a new course where we start off with  
151:16 - a very simple network and gradually go bigger 
and bigger and see what each of them can do.  
151:22 - We could also try new things like 
teaching the car to stop before impact,  
151:27 - how to respect the lanes, maybe even how 
to park and other cool stuff like that.  
151:33 - What do you think? Would you like a course 
like that to practice even more JavaScript  
151:37 - and become a master of making diagrams that 
show what's inside these so called black boxes.  
151:44 - And if you want something else right now, I do 
have a lot of content on YouTube. This course  
151:50 - teaches how to build location based applications. 
In this one, we make an augmented reality piano.  
151:56 - And here we use the camera to make a new kind of 
puzzle game. I have many small projects as well,  
152:02 - but it's really hard to keep track. Maybe they're 
better organized on my website. I don't know.  
152:08 - By the way, on the website, you can find a more 
enhanced version of the self driving car. Check  
152:14 - it out if curious. Anyway, thanks for watching. 
Please share this course with anyone you think is  
152:21 - interested. And since you got this far, you're 
probably subscribed already. So see you guys

Cleaned transcript:

In this course, you will learn how to build a self driving car simulation. By making every component yourself with no libraries. This course is a great way to learn about neural networks. You will also learn about modern JavaScript techniques, Raju teaches this course. He has a PhD in computer science, and is one of the more creative tech YouTubers out there. Hi, I'm Raju, and welcome to the self driving car, no libraries JavaScript course. It's a course where I teach you how to make a self driving car. The and will do it without using any kind of libraries so that you really understand what's going on under the hood. Now, before you say anything, yeah, it won't be a real car you drive outside. But making this kind of simulation is maybe even harder than doing it for real. Let me explain. In this course, you'll learn how to implement simple physics to move the car in the beginning will control the car ourselves using the keyboard to get the field that we want. I'll also teach how to create the road and how to follow the car on the road like a drone is filming it from above will then simulate some sensors on the car. These sensors work by raycasting and detect if the car is too close to the side of the road or to other cars in traffic. To implement these will use a formula for a segment intersection. Don't worry, I'll explain the math in a nice visual way. You'll see we'll implement collision detection using the same segment intersection formula. It's great, it works with any orientation and can even support other shapes as well. Now all of these are things you don't have to worry about if you're working with real hardware. The world gives you the best physics better than any simulation. There are plenty of rows to drive on, we don't need to create them ourselves. And nowadays, cars have a bunch of sensors that tell if something is touching or around the car. Of course, if you want to build all of these yourself, then yeah, making the simulation is easier. But what are you Elon Musk? Anyway, the second half of the course is the really interesting part, you'll learn how to create and visualize a neural network, an algorithm inspired by the biological neural networks in our brains. I'll briefly explain how our brains work to the best of my ability and teach you how to code something similar ourselves, then we'll optimize the brain by trial and error. Yeah, to keep things simple, we just try randomly generating brains until we get something that works. We'll parallelize this step and use hundreds of cars at once to save time. By the way, this is something you can't do with real hardware unless you're really, really rich. And that's why car companies use simulations to train their neural networks as well. I'll also teach you a basic genetic algorithm to optimize faster. But don't expect anything too fancy. This entire system is complex, but I made it so that each component is relatively simple in and of itself. I made this course keeping in mind my high school days back in Romania. So the knowledge you get from school should be enough depending on the curriculum. We'll work with JavaScript because it's so easy to get started. You just need an editor and a browser, which you probably have already. I'll teach you many modern JavaScript techniques. So this course is perfect if you want to become a better coder, as well as a machine learning expert. Now, JavaScript is not the best choice when doing artificial intelligence. But since we're not using any libraries, it doesn't really matter. If you want to learn these in a more useful language, like Python, then come study at Karelia University of Applied Sciences there, I teach the same thing in Python as well. And we also study machine learning libraries and even use hardware components. But now start your engines because the course is about to start. I'll first teach you how to implement the car driving mechanics. You learn to make a car that moves like this. It's not really that hard. You'll see. I'll refresh your memory with some basic physics and trigonometry. And you'll be able to code this in no time. We begin with this simple project setup. We have three files right here, index, HTML main, Jas, and style css, and they're all empty for now. And I'm using Visual Studio code to write this. And on the right, I have Google Chrome, and you need to have the developer tools open there. It's really important. So if you plan to follow along, have a similar setup. You can use another editor if you want to If I recommend this Visual Studio Code nowadays, let's begin with basic HTML. In the head, I'm going to write a title for this. And it's going to be self driving car, no libraries. Really, everything here is going to be just written by us, linking now the stylesheet. And let me close the head and in the body, I'm going to define a canvas, we are mostly going to use this canvas in this project here, I'm also linking the JavaScript file like this. And we are done with the HTML for the moment, at least, refresh the page. And not much happens rarely. It says here self driving car, no libraries in the in the tab of the browser, but nothing appears in the page itself. Apparently, if you open this elements, you will see that the canvas is actually there. It's just transparent. And the body actually has this orange small margin there, I want to get rid of that margin and also make this canvas visible somehow. So let's go to this style css next, and write some styles, I will remove the margin for the body. And let's make the body have a dark gray background overflow to hidden. And I'm going to use text align to center for now. Overflow is important. Otherwise, we might get the scroll bar coming if the canvas is too big. And I don't want that. And I want everything to align to center in the middle of the page. Now my canvas should have a different colored background, maybe we set it to light gray like this. And save, refresh. And now you can actually see the canvas without needing to inspect these elements right here. I'm gonna move back to the console, it's probably the most important thing in the developer tools, I want my canvas to stretch the full screen vertically. So I'm gonna go in main.js, right here. And I'm going to get a reference to our canvas with ID my canvas we defined previously. And I'm going to set the height of this to be the full window inner height like this. And the width is going to be just 200 pixels, it will be like a road going upwards, we will need the space on the side to draw the neural network later. Now if I save this and refresh, you can see it appearing there exactly how we want it. Let's next pretend that we have a car, and we want to draw it on the canvas. To draw on the canvas, we first need to get the drawing context, we will just use the to the context in this whole project. So I'm going to have a reference to this canvas context right here and the city X. And it's going to contain all the methods we need to draw the things that we need to draw in this project. And if we would have a car, we would say something like this, let's get the car at, for example, 100x 100 y, and the car maybe has a 30, width, and 50 height. All of these are in pixels. And let's draw the car using this context. But we don't have the car yet. This is the thing that we are going to need to define next, the car object. And we are going to do this first by going inside the index html here and preparing to import the new file. Car Jas like this. And now I'm going to add a new file here. Car JS in here. I'm going to say class car. So we are defining our car class. And the constructor for this class is going to have four different parameters. So we have here the X and the Y and a width and a height. So these are properties of the car where we want it to be in how big should the car be? And we are going to store these as attributes inside of the object like this so that the car remembers where it is and how big it is. Now, remember, we also had this draw being called. So that draw was a method. And it looks something like this, it gets context as a parameter. And in here, we begin path. And we are going to draw a car as a simple rectangle. For now, the rectangle is going to start at an x&y location. So I'm going to use this dot x minus this dot width divided by two. So the x of the car is going to be the center inside the car, and it's going to have parts in front behind, left and right, so on the top bottom, left and right, the y value, I subtract half the height. So here, we also need to specify what is the width and the height of this rectangle like this, and ask the context to fill it like so. And if I'm going to save this and refresh the page, you can see the car there, or at least the black rectangle. For now, the car is here at 100 100. So on computer screens, the y axis actually goes downwards. And the 00 point relative to this canvas is actually right up here. Now, this is really boring as such. So I'm going to teach you next how to move the car using the keyboard arrow keys. So for now, let's just pretend that we have here some controls like this controls is equal to new controls. And let me link a new file here in index controls J S, and also create controls, J S. And we will do a similar thing as previously. So we need a class for these controls. And the constructor, the controls object will have four different attributes, one of it will know if it's going forward, one of it for the left, one of it for the right, one for the reverse, like this. And I set them to false initially, but this will change depending on what you press on the keyboard. So I'm next going to define a method for adding so called keyboard listeners, so that we have a piece of code that checks whenever we press a key or release a key. So I'm going to call here, add keyboard listeners. And this is going to be a method inside of the controls class, like so. The reason I put here this hashtag in front is because this is a private method. You can't access this from outside that this controls class and you shouldn't it's its own responsibility. So how does this add keyboard listeners look like? Well, we will add a key down event to the document and set this to be equal to this arrow function. I will explain arrow functions in just a second. But let's implement this first. So depending on the key that was pressed, if this was the arrow left key, we are going to set this left to true and break and do the same thing for the arrow right key like this. The arrow up key for forward and the arrow down key for reverse and that's it. But we also need to know when we release a key. So I'm going to actually copy this code here like so. And this is going to be on key up. And all of these things are going to be set to false. I want to debug if all of this code that we wrote works. So I'm going to put here a console table. This, I'm going to output this entire object into the console in a table format. When I press a key, and when I release a key, I save the file refresh. And every time you press something like now I'm pressing the up key. Now I released the app key. Now I'm pressing the Down key, I released the down key left. And right, you can see the values in the console have changed. So this code seems to be working. Great. But why is it working? So let's look a little bit up here. And this part of the code may be a little strange to you, if you're not familiar with this arrow function notation. This is actually the same thing as writing here, function of event like this. So we say that unki down, this is the function that you're going to call. But if you write it like this, this here stops referring to the object here to the controls object, it actually refers to this function right here. And if I undo and use this arrow function notation, this continues to refer to this object right here. So it's a difference in how these two type of functions work in JavaScript. And it's convenient to have it in this way. Now, controls are triggering, but let's move the car with them. So I'm going to go to car Jas. And we are going to write here an update method. This update method is going to check if the controls say forward, let's just move the car upward. So that means y minus equals to remember that y increases downwards on a computer. And if these controls are reverse, then we add to y so that it goes downwards. Now this won't do anything just yet, we need to go to main js here and start to animate. So I'm going to right here animate and define an animate function like this. And inside here, I'm going to update the car. And then I'm going to draw the car using this code we had previously like this and call request animation frame with animate like so. Request Animation Frame calls the Animate method again and again many times per second, it gives the illusion of movement that we want. Now we can save the file, refresh the page. And when I press down, something happens. So the car updates and redraws itself. But all the past positions of the car are still there. And if I press up now takes a while but then it reaches again the top part and you start seeing it again. But it leaves this black trail there. So we need to fix this. And actually, we need to fix something else as well. If I'm going to resize this console here, you will see that this canvas here doesn't stretch to fill the screen vertically anymore. This bothers me. But it's, it's great, because we can fix both of these issues by moving this piece of code from here to here. When you resize the canvas in this way, it means that it also becomes cleared. So if I refresh now and press the Down key, the car is actually seemingly moving and it doesn't leave that trail anymore. Also, if I resize this console here, it looks proper. You might have to click on the screen here before you can press the top and down arrows. Sometimes these listeners don't activate them unless you click inside the page. Okay, problem now is that this doesn't move like a car at all. We need to work on this cars don't move so that you press on something And then immediately stop, I'm going to go to the car constructor here and give the car a speed attribute and an acceleration value like this. And here, instead of changing the y value on forward, we are going to say that the speed will increase by the acceleration, like this. And I'm going to copy this here below. But with minus, and here, I will say this dot y minus equals this dot speed, I save the file, refresh the page, I press down. I press up, we, okay, we need to stop the car from going too fast and implement some friction. So I'm going to go here and say, max speed equals to something like three and the friction of, let's say, 0.05, like this. And in the update method, I'm going to move here and say, if the speed is more than this max speed, this speed becomes max speed, we are capping it the same if the speed is less than minus this max speed. But in reverse, I want the car to be not as fast, I'm just gonna divide by two here. If it's less than this, then I'm gonna cap it to be minus max speed divided by two, maybe you want to have a max reverse speed or something declared on top, feel free to do it, I think it's overkill. Also, there's no such thing as a negative speed, like what we have here, the negative sign is just to indicate that the car is going backwards. Luckily, this is another course on physics, otherwise, I might get in trouble for this. Next thing we do is check if the speed is greater than zero, I will decrease it by the friction like this. And if the speed is less than zero, then speed increases by the friction, like this. Now I save the file, refresh the page, press it down, and the car is moving. I released and it's slowed down a bit, and then it stopped. I'm pressing now up, and I release. You can see it's still moving a little bit before it stops. And I think that this fields quite okay. But at the moment, the car is only going forward and backward and the left and right, don't do anything. One small issue though, let me see if I can get it to happen. Okay, if you release in just the right way, you will see this, let me zoom in a little bit more. See, the car is actually always moving, it's constantly moving, no matter if we press a key or not, actually, if we don't press any key. And it's moving by by a very, very, very small value. And that's because if the speed is not equal to zero, exactly, then this friction is going to bounce it around, and eventually is going to move it forwards by a very, very small value. So to fix this, we can actually right here. If this speed has absolute value that is less than the friction just have it becomes zero like so. And this is going to work, no need to test anymore. Let's implement the left and right controls next. And say as before, if we press left, x gets minus two. And if we press WRITE, x gets plus two, notice how I implement the basic thing first, and make it more advanced afterwards. I really want you to get the idea that everything can be improved, but that you can make a complex system even with easy components. I mean, by the end of this course you will have a self driving car no matter if it moves like now, or if we implement better physics into it. Now If I refresh the zoom out a bit. Now, if I press left and right, the car moves in a very, very funny, non realistic way. But this is actually how cars move in some games, for example. So if you want to make a self driving car for a game, then this might be enough for you. But I'm gonna teach you how to do better than this. And, actually, I don't like this for one important reason, we are breaking the laws of physics, we have here, the value for this maximum speed. And we can reach that maximum speed by going forward like this. But if I press right now, I'm actually going faster than the maximum speed, but diagonally, because I'm going to maximum speed vertically and a little bit to the left in this case. So this is bad for many reasons. Let me teach you how to fix it. We are gonna go up here and define an angle, let's set it to zero. And here, instead of doing this, we are actually going to modify the angle to increase by 0.03, for example. And here we have angle minus equals 0.03. So this angle works according to the unit circle. But in our case, the value of zero is upward. So it's a unit circle that is rotated 90 degrees counterclockwise, if you will. But keep this image of the unit circle in mind of the rotated unit circle in mind, because this is going to be our coordinate system for making rotations. Speaking of which, we can make a very easy rotation like this using the Canvas context. First, we save the context, then we translate to the point where we want the rotation to be centered at. And now I'm going to tell the context to rotate by minus this angle. Next, I'm going to remove here, this dot x and this dot y, because we're already translating to that point. And one last thing we need to do is here, add the call to context restore. Because otherwise, on each frame of the animation, we are going to translate and rotate and translate and rotate and translate and rotate. And this is going to do some infinite series of translations and rotations. That will look pretty funny, maybe, but not what we want. So let me save this refresh. And now when I press left, my car rotates counterclockwise. And when I press right, it's rotates clockwise. So we have something there. It's not yet good. It's more like, like a tank that can rotate in place. cars can do that. But more importantly, if I rotate like this, and press the Down key, my car just moves downwards in this weird way. And this is not correct. And same goes for upwards, we want the car to actually move in the direction of this angle. So I'm going to implement this. Based on the unit circle again, I'm going to make X go minus the sine of the angle times the speed. So unit circle has a radius of one, this sign is between minus one and one. So we need to scale this by the value of the speed as well. And then for y, we do the same thing, but with the cosine here, according to the unit circle. Now we don't need this anymore. I can save the file, refresh the page, rotate to the left, press down and look at that. The car is moving properly. And I can actually start to feel like I'm driving a car. Mm hmm. But backwards, it's flipped. Like, look at this. If I press backwards and right, the car turns left. That's an That's how it happens in in real life. So we need to fix that. And also this rotating in place. Next, I'm going to just put here, if this speed is not zero, I'm going to calculate a flip. So I'm going to say the value of this flip is one or minus one, depending on the speed, so that I can flip the controls backwards. And if if this is the case, then here, I can just multiply by the flip. If the flip is positive one, then this doesn't do anything. So when the car is moving forward, when it has a positive speed, then this won't change. But when we go backwards, what essentially happens is these signs are flipped. So let me close this here, and test again. Now if I press left and right, nothing happens, because our speed is zero. But if I go backwards, and to the right, it goes just the way I want. And now I'm doing these kinds of, I'm trying to change the direction in the car, similar to how it would happen. When driving the car, play around with it. And if there's something you don't like, change it, especially if you're good at physics. But if you're not, you can try using libraries here as well. books to the is a really good one, I think. But I'm happy with this, there's one thing that we don't need anymore. That's the debug here in the controls, I'm just going to remove this, because now I'm confident that the controls work as I want them to, I'm going to save this file. And in car, this update method starts to be quite big, and more things are going to be coming here later. So one good thing would be to group all this code here in a separate method, I'm going to cut it, and the method is going to be called move, because that's what this is doing. It's moving the car, according to the controls. And the move method is going to be a private method, it has the hashtag there. And I paste the code that we had previously in here, I save this refresh, and everything still works. As previously, I'll show you how to do the road next. So in index html, we are going to say here that we include road Jas a new file that we have to also create here, road Jas, like this. And in here, we are going to start to write our road class. So very similar as before, we have a constructor here. And I want the roads to be centered around an x value, and have a width. Now, these are going to be attributes that the roads should remember. And actually, I want it to have also a number of lanes. So let's write here something like this. And define here, a lane count that has a default value of three. For now at least, it's useful to have a few more attributes here that we can pre compute and use later in our calculations. So for example, we can have a value for left that is half the width less than x and a right that is half the width more than x. And I want the road to go infinitely upwards and downwards. So let me just define here a constant for infinity, really large number. There's actually one in JavaScript already but I found that when drawing things with infinite size, weird things happen. So let's just have a very, very big value here. Like this. Our top is going to be minus infinity and bottom is going to be plus infinity. Remember that why on the computer grows downwards. Now to draw the road I'm going to make a draw method here similar what we had the car draw method. And I'm going to set here a line width of five. So a relatively thick line. And I'm going to make it white. That's how the lines on the road usually are. And let's begin a path and move to left and top and the line to left and bottom. So we are now drawing a vertical line on the left side of the screen. I'm going to copy this, below like this. And I'm also going to draw a line on the right side of the screen, like so. And we are done with this route js for now, I'm going to move in the main js file. And above where we define this car, I'm now going to say a road is equal to a new road centered in half the width of the canvas. So that's going to be our center X. And it's going to have width of the whole canvas width, I'm going to now go down here and write road draw on the canvas as well before the car so that the road comes first and then the car on top of it. Let's now save this refresh. And almost nothing happens. But you should be able to see here on the sides, some white lines there. Now they're exactly at the side of the road, I want to leave a little bit of margin there. So I'm gonna make here this with smaller, let's say 90% of the canvas width, save this, and refresh. It looks better already. But we said that our roads should have some lanes right here in the constructor, the third argument, it has by default three lanes, and we will need to make them appear as well. I'll show you, we go back down here. And I'm going to write a simple for loop going from zero to this ln count, inclusive. So notice here I have less or equals to this lane count. And now I want to know what is the x coordinate of each of these lines of these vertical lines that we are going to draw. And depending on the lane count, we will have more or less of these lines, but also the x values are different. We get these using linear interpolation, I'll show you. We say here, x is equal to linear interpolation, or ulurp, we will write this function Don't worry, it's not not complicated. And we will interpolate from left to right, so we need to get values between left and right. According to a percentage, this percentage is going to be i divided by this lane count like this. Think about it. This last value from here is going to be between zero and one when I becomes this lane count, then this is going to be one. And with all the in between values, you just get percent values over here. So how this slurp function looks like is function ulurp. It's a funny name, but they've seen it used by game developers at least. And that's it. So you have the value of a and then the difference between B and A times this percentage t. So when t is zero, this part here is zero, you only have a when t is one, this minus a from here will cancel out and you're just left with b so zero and one or zero and 100% just give you the two endpoints. And for example, when t is in the middle, then this difference is just half of that difference. So it's gonna move half away from a and so on. It's a really simple function, and I've used it in Very many different projects, I really recommend that you have it in your utilities as well. So let's see if it works first, and then I'll move it in the utils file, it doesn't belong here. We'll be using this many times throughout this project. So here, I'm going to align this part like so. But replace here left with x value like this, and also this one. And we don't need this piece of code anymore. Closing this here, and I think that we can save and test and look at that we have three lanes on our road, I'll move this function now in a utils file. So let me create it utils.js, paste it here. Say save the file, go to index html, include it, like this. And now if I refresh, everything still works. Let me go next to row j, s, and add dashes to the middle lines, like so I'm going to check if I is greater than zero and less than this line count, like this. And in that case, I'm going to set line Dash. And I'm going to open an array 20 and 20. And this means that our dash will have 20 pixels, and then a break of 20 pixels and another dash and so on. So let me close this otherwise, for the borders, we are going to put line dash equal to an empty array like that, I'm going to save this refresh. And there are the dashes. Let's test also with the lane count of four just to see if it works. It's quite nice. But you can see the car is off center. Now, I would like it to be on lane, right. So it would be useful to have a method that tells us what is the center of a given lane, let's do it. Get Lane center with a given index. So this will start from left to right starting at zero, I'm going to get a helper variable first, the line width equal to a width divided by the line count like this. And then using that, I'm going to say this left plus half the line width. So I want to be starting these in the middle of the first lane. Plus, I'm going to multiply the lane index by the line width like this. And this is going to give us four different line indices, an offset of line width away from the middle of the first line, oh, not line with lane width. Line Width is something else. It's the thickness of the line. Okay. And to test this, we can go in main Jas. And here instead of passing this 100 for the X of the car, we can write road get Lane center. And for example, maybe we right here three, to put it on the rightmost lane, save this refresh, and the car is on the right lane, right. Let me go to the road and move this to have a lane count of three. Again, I liked that value more. And now we see a problem the car has gone. It's actually here. And Lane index three, which is now outside the screen. So this is something you may want to have fixed for example, by going here and using the minimum function and saying you want the minimum between the lane index and this lane count minus one. With this, the car is going to go on the right most possible Lane even if you accidentally tell it to go more than that. But I prefer my car to be in the center. So let's put this on lane one here. And we'll keep it here for quite some time. Now This looks nice. And driving on this road definitely feels feels nice. But in the future, I want to detect these borders of the road here, and also have collision detections with them. Because naturally we want the car to, to explode and impact. So basically, it would be nice if the road object could tell us where these borders are. And I'm going to do that. Next, I'm going to go here in the road in the constructor, and I'm going to say, this borders is equal to an array, I'm going to put these borders in an array, we now have just two left and right, but think about it, maybe we want to have highways, and then you have another board there in the middle, or maybe some complicated situation requires more for some reason. So I'm just going to use an array and you can experiment with different things. And the first thing in this array is going to be a segment. So top left, bottom left points form a segment. And I'm going to make this also an array, something like this. And the reason for using arrays so much here is that our line segment here is straight. But maybe you want to experiment with something else, like adding curves on the road. Actually, that would be a nice homework for you to do. So I'm gonna keep a race here like this, the borders for now are just two segments made of two points each. And these are going to be here defined like so. And I just copy this three more times and say two, top right. Bottom left. Bottom Right. And here we have, right, I'm just going to copy this down here as well. And here we have bottom, and I'm gonna copy this here as well, I will save this, and nothing really changed. Not yet at least, because these borders are just here. If we say road borders, for example, they are just in memory. And they are easy to access. Whenever we need them, we just ask the road, hey, where are your borders, and it can give them to us like this. So the left border here with the X of 10, and the right border with x of 190. And plus minus infinity for these great, but because these borders are here, now, it makes sense here at the bottom to draw them separately. Because if we change them, like maybe if you're gonna make them curved, this drawing here won't reflect that. So I'm going to change this to be here starting at one and going to lane count, minus one. And I'm going to keep just the line dash here, like this. And then I'm going to move below this and say context set line dash to empty array. And now I'm going to show you a for each syntax, we are going to go through the borders for each border. Let's call it border, I'm going to use this arrow notation again. And I'm going to say context, begin the path. Move to the first point in the board their X and the Y and do align to the second point in the board their x and y stroke. And that's it. Now keep in mind that this doesn't change anything. So all the code that we are writing now is just to make everything more consistent, but I will teach you a cool trick. Next we're gonna make it look like there's a camera above the car and it's gonna follow the car as it moves on the road. So I'm gonna go here to main Jas, before drawing the road. And I'm going to say save the context and translate nothing on X but minus the y value of the car. And below drawing these things, I'm going to say, restore again, like this. And now if I save, my car moved up there. But if I accelerate, you can see that the car actually stand still. Unless I go left and right, but the road is the thing that's moving. So what I want to do is actually not keep the car up there, but maybe move it somewhere down, like for example, CAN bus height times 50%. So this is now centering the car there. As I'm driving, this feels really great. But maybe a better value would be something like 0.7. Because we in this way, we see more of what is ahead of the car. And later when we add traffic, we want to be able to see those things, and figure out if the car will do the right things or not. Really funny how easy this last thing was. To add sensors to the car, I'm going to go to index html and include here. Sensor Jas, save this file, and create a file called sensor Jas liked this. And inside here, I'm gonna define my sensor. And the constructor will take the car as the argument. And the reason is that I want the sensor to know where the car is, it's attached to the car, and we're going to be using the car properties to update it. So let's store here the car and other attributes will be the array count. So our sensor will cast arrays in different directions. Let's just have three of these arrays for now. And then the array length. So usually sensors like this have a range after which they don't work anymore. So if they don't sense anything in this 100 pixels range, then they can see beyond that, and array spread. So here I'm setting pi divided by four, this is the same as 45 degrees. And that means the angle that we are going to spread these rays that are being casted by the sensor. So I'm going to keep here also an array called arrays. And this is going to keep each individual array one by one after we create them. I'm next going to create an update method like this. And we begin by setting these arrays to an empty array. So this arrays is what we are going to start to populate next. And to do that I'm going to loop from zero to this array count, like this. And I'm going to figure out the angle of each individual array. And to do that, I'm going to use the loop function, our utility function from earlier here, that gives us a value between A and B, depending on T, right. So if I go now back to sensors, the angle here is going to be between Ray spread divided by two, remember the unit circle, the rotated unit circle and minus Ray spread divided by two and the t value. Let's have it i divided by this array count minus one this time, because I is not going to become equal to array count. So the maximum value for I is this array count minus one actually need to remember this, it's quite important. And with this, we can calculate the start point for for our array. And that's just going to be the car X and Y like this and an endpoint of the array. For this endpoint. I'm going to take the car x as the starting point. And then using the unit circle, I'm going to take this angle that we made previously, and multiply it by the the length so unit circle, just one big soul radius. We won't see anything we need to scale it up by the array length here. And we do the very same thing In with the y, but with the cosine there instead. Now with the start and end point available, I'm going to push these inside of the array to form a segment. So notice here, I'm using this way of defining the segment, using an array here in the same way that we used for the borders here in road Jas, the road borders are also going to be made of segments defined in this way, it's good to be consistent like this. Now, we also need to be able to draw our sensor. And I'm going to say draw. And we go through all of the rays like this beginner path. And I'm going to put a line with two. And I'm going to draw these arrays using yellow. I will move to the arrays start location, x and y. So the first thing in the array of IRA is its start location. And then I will line to the race and location. So one with x and y there like that. And now I can stroke and close these like so I seem to be missing here a curly brace. Let's save this file, and now instantiate the sensor, I will go to car and inside the car constructor here above the controls, I think it's it's good. I'm going to say this sensor is equal to new sensor of this. So I'm passing the car through this. And then in the update method here, I'm also going to be telling the sensor to update like this. And in the draw, in addition to drawing the car, I'm also going to be telling the sensor to draw itself. So the car has now the responsibility to draw its own sensor. Let's save this refresh. Okay, so we see now three lines popping out from the center of the car like this. And they're at the 45 degree angle, which is good. And when we move the car, maybe this is not what you want to happen. Maybe it is what you want to happen. I don't know, you can experiment with these things. But I would like the sensor to rotate with the car. So that when the car moves, the sensor also moves. But nowadays with gyroscopic technology, you could probably have this kind of sensor as well if you if you actually want. So to fix this, it's really easy. I just add here to the array angle plus this car angle like this. And it works as expected. Let's play a little bit with these values up here more, for example, let's have 30 segments and make them a bit longer like this. Wow. So many rays coming from there. It's like the sun. Let's actually go all the way. So by The Times two. This is now spreading these rays in all directions. So all 360 degrees, or pi times two there. Let's put it to have by so a 90 degree angle. I think I I liked that. And let's try with Ray count of one. We'll have a surprise here. It doesn't work. Two works just fine. But one doesn't. And the reason for that is this thing here, this array count minus one. If array count is one then this becomes zero and we can divide by zero. So what I'm going to do is I'm just going to replace this line. If this array count is one I'm going to just return half, I want my array to be straight up in the middle between the array span. Otherwise, I just do the exact same thing as previously. So now it works, no, no problems. And we got it to work, we needed to do a little bit of more thinking right here, because of this division by zero. Let's try with more arrays to see if that still works. Maybe five. Okay. Nice. Now, before we get them to work to actually detect that there are some road borders here. I want to refactor this a little bit. So all the code here in this update method, I'm going to cut it and I'm going to say here, this dot private method, cast race, like this, and cast race. He's going to get this code right here. This doesn't change anything, everything still works. But now our update method here is simpler and more code can go into it. And we can read it more clearly. Now, to be able to detect the road borders, we need to know where they are. And at the moment, the sensor has no idea, we need to go to main Jas. And the first pass to the car update method, the road borders like this. Now I'm going to go to car Jas and have the road borders here, like this. And I'm going to take them and pass them to the sensor update as well. So now in the sensor js, the update method receives them as well. And now we can use them to detect with the sensor if the road borders are close or not, I'm going to add here, an array for the readings. So these readings are going to be some values for each array, telling if there is a border there or not. And how far is now in this update method. I'm going to say readings is equal to an empty array, I initialize it here. And then I will iterate through all the arrays like this. And add to this readings array, or reading. So we will get readings using a new method that we need to define that takes a array like this, and the borders as parameters. And now we're gonna go down here and write our get reading method with a array and the given borders. So now what I'm going to do is check to see where this array touches the road borders. And now we have just two borders, one on each side. So one array can only touch both of them if the car goes off screen like this, but it's good to consider multiple intersections anyway, especially because later we'll have traffic. And we'll handle that using the same strategy as well. What we'll do is find all these touches, and then keep the closest one to the sensor. And that will be our reading in the same way that the real sensor would work. So let's see where this array touches any borders, these touches is going to be an empty array. And I'm going to go through all the borders one by one, we just have to at the moment, but it's good to write it like this. And we say that the touch is equal to get intersection, this is going to be a function that we will need to write it's going to be a very useful utility function, you'll see and the intersection will be between the array of zero and the array of one. So this is gonna be one segment, so far. And another segment the I wrote border zero and I wrote border one like this. Now if there is a touch, we will add to our touches. So this get intersection function may return know if the segments don't intersect. So that case nothing gets added to this touches array. Now, if we have absolutely no touches with the given array, Arrays, then that means that there is no reading here, we don't encounter anything with this array. So I'm going to say here return no like this. Otherwise. And now I'm going to teach you a little bit more modern JavaScript, you'll see this get intersection doesn't just return the intersection point, but also an offset how far the point is from this array of zero, which is pretty much the center of the car. So we do get with this get intersection, three things, an x, a y, and this offset value that will be quite useful. So I just want all the offsets from all the touches here in one array. And we can use modern JavaScript methods to get that. Like this, the array map method basically goes through all the elements from this array. And for each element, it takes its offset. Now this part here returns a new array. In this case, it's called offsets. And that's it, we don't have to write a lot of code to get this result here. And I think that's great. Now, we want to know from all of these offsets, the minimum one, like if array touches many different things, like many borders or cars will be later when we add the traffic. So we want to know the nearest one after the rate touches that all the other ones don't exist, basically. So we are going to get the minimum offset using the math minimum method. This minimum method here doesn't accept an array as an argument. But it does work with many, many different values. So this dot, dot dot operator is spreading the array into many different individual values. And finally, I'm going to return the touch that has this minimum offset using this find method here. So going through all the touches, element by element, if the offset of that touch is equal to this minimum offset, it will return that touch. In this way, this code is pretty complex take a while to look over it. But because we're using modern JavaScript methods, here, the code is really short. So try to get used to the syntax, because you will see it everywhere, especially if you work with React. Now I'm going to draw these readings somehow here in the draw method, let, and is equal to the rays and points pretty much. But if there is a reading, I'm going to set and to the value of that reading, remember the readings, what comes from this get intersection function will be three things, the x, the y and the offset. So if we say this here, we essentially pass the x and y to this and, and becomes a point with an X and Y attributes. I'm going to now make this yellow segment until end, right here. Like so. And I still want to know where this line would have continued, I think it's nice to visualize that. So I'm going to copy all of this. And I'm going to just make it, let's say black. And here I will draw from the tip of where the end of the array could be to this end point. If it's a reading or not, if not, then this is just going to be a line that is so small, you can't see it. Now, if I save all of this, and refresh, it works for me, but it doesn't work for you. And that's because I have here in the utility file a secret function that I added without telling you. Sorry, let me just indent this a little bit like so so that you can actually see it. If you want to implement this yourself by watching on the screen right now. I will make a separate video for this because I think the topic is very interesting, and I have a nice way to teach it as well. But it works. Look, when I'm moving my car like this, the race are going to the borders. And immediately when they are reaching the board, there's there, they are turning black, like so. And only the yellow part is really interesting. And it's what we will use later when we define the neural network. I'll show you how to implement collisions next. That is when the car is approaching the side of the road here. I wanted to get damaged somehow. So there's a good news and bad news. Good news is that I'm going to teach you how to detect collisions using the segment intersection code from previously. The bad news is that the way that we draw the car here, by rotating the context, we actually don't know where the corners of the car are, like, what are their coordinates, and we're going to need to figure those out first. So in car js, I'm going to create here a new method, and I will call this private method, Create Polygon, this polygon will have a list of points an array of points. So one point per corner of the car. And great news is that you can add more points, you can have different shapes. And this method I'm going to teach you is going to work. So if you look at this car right here, let me refresh so that it points upwards. And then we can use this distance right here as a radius, like, it's pretty much the same distance no matter which of the corners we are looking at. And the other thing that we will need to figure out is this angle, like what is this angle, knowing the width and the height. So this radius is actually very easy to get using the hypoid method here. So this is the hypotenuse of the triangle with width and height, and I'm dividing it by two, because I just need half of it. And the angle here is a little bit more tricky, maybe. So the tangent of this angle is actually the width divided by the height. So we can use the arc tangent method, this eight and two method from the math library to give us the angle, knowing the width and the height, like this. And I don't need to divide this by two because that angle is the same no matter how you look at it. Now with these, I can add my first point here, that x is going to be the center x of the Car minus the sine of this car angle minus this alpha value. So I'm combining here, the alpha angle, and the car angle as well, and then multiplying these by the radius. And the same thing goes with y. But here I'm using the cosine, like this. So this was the top right point. And we need to do the next ones as well. So here, let's just add alpha, like this. Next point, I'm going to keep minus alpha there, but add here, math, pi plus, or 180 degrees. And the last one, I will copy this one from here and change this alpha to a plus. Like so. And now we just return the points. And that's it. We want to update this after we move the car like this. So this car will have a polygon attribute that will be generated in this way. And to draw the car, we can now use this polygon instead. So instead of this trick here where we translate the Rotate and then just draw a rectangle here, essentially losing the coordinate points, we can remove all of this and just draw our polygon points in order I'll show you, we do begin path, move to the first point in the polygon, like this. And now loop through all remaining points. So notice that I'm starting here at one, because I already moved to the first one previously. And here I'm just going to line to the eighth polygons, x and y, like so. And I'm going to film, save the file, refresh the page. Here, nothing happens. So everything still works. But in a different way, in a better way, I'll show you. If we go up here, for example, and just change one of these points, let's change this one by multiplying this radius by three, then our car will look like that. It's kind of kind of funny. So we couldn't do this previously. And and now we can do crazy things like this, like give complex shapes to our car. And we can, of course, add more points if we want. But I'm not going to do that it's your job to experiment. What I will do is teach how to do the intersection between this car polygon and this line segment on the right, and detect if the car is damaged or not. So let's go up here and say this damaged is equal to false, all cars are not damaged to begin with. And then here, after we have our polygon, I'm going to assess damage a method that we're going to need to write with the road borders. So now, here, let's define this assess damage method, given some roads, borders, like so and loop through all the borders. And check if there is an intersection between this polygon and the road border of i The road border, then we return true. If the code reaches here, we return false. Now we need to implement this Polly's intersect function here. And it will be a really useful utility function that takes two polygons here as parameters. Now, notice here that this road borders of it is actually not the polygon. It's a line segment, but it will be general enough for it to work. So let's go now to utils J S. And I'm going to define our polies intersect method with poly one and poly two, like so we look through all of the points in poly one. And for each of them, we check all the points in poly two. And we are going to see if they touch or not using our get intersection function from up here. So we say here poly one of I and poly one of i plus one modulo the length. So this may look tricky, but all the things that I'm doing here is I'm taking one point in the first polygon, and then the next point in the first polygon. So I'm making segments essentially from one point after the other. But at the end, this will give an error when we are reaching is equal to poly one length minus one, because adding one to that then it will go over the array. But if we use here, the modulo operator like this, then that value will become zero. And that's actually great because the last point in the polygon needs to connect to the first point in the polygon, like point zero. So this code solves two things. And I will continue and put the same thing for poly two with the J this time. So essentially I'm taking all the segments that make the first polygon and comparing them against every segment of the other polygon. And if there is a touch, then I'm going to return true. Otherwise, if all of those checks have returned No, then I will return here. False. So our policies don't intersect. Now to see if this works, I'm going to go back to my car JS here. And actually in the draw method, the first thing that I will do is see if this is a damaged car, I'm going to set the field style to gray color. Otherwise, I will set the field style to one black color, like this saving the refresh, and it changes color. And it changes color immediately when the car touches the border, even with this complicated shape, because we are using each segment forming this polygon and comparing it with the border of the road. Now this method is quite general. And it works for complicated polygons as well. But it can become slow if you have very many points. So then you would need to do some optimization here, maybe look at the bounding boxes, first star, or something like that. And it's really reliable, as long as your object doesn't move too quickly. For example, like if our car would move so fast that it could actually jump over a border or over another car in traffic, then you will need a different collision detection strategy for that. But we won't let that happen. And if I zoom in here, a lot I should mention this, because you may wonder why the car doesn't detect a collision now. And the reason for that is that, well, that line, that border of the road, it's a line, it's a mathematical line, which actually has no thickness. And here we are drawing it with relatively thick thickness. And that's why it looks like it's intersecting even though it's not, you could fix this if you want by drawing the borders of the road with actual, very thin, infinitely long rectangles, put, I'm not gonna do something like that this is great for our purpose, let me zoom back out. Change this car to be a rectangle. Again, I don't want to keep it in this crazy shape. And now in the update method, I will not allow it to move if it's damaged. So I'm going to say here, if not damaged, then do all these things. Sensor, maybe it's good to be like that. So the sensor will still work even if the car is damaged. Let's see if this has any consequences. If I refresh, now, the car is a rectangle again. And if I go to the side of the road, everything stops. So now I can play with the arrow keys, nothing happens my car is useless. We really want to take any kind of impact seriously in this so I am rendering the car useless at this stage. Now the car works, it has sensors, it's detecting the borders, and it's getting damaged on impact. But this is quite lonely, don't you think? It's time to add some traffic without it making it self driving cars not much of a challenge. You just press the up arrow key and perfect driving. So let's add the traffic next. I'm gonna go in main Jas. And up here I'm going to write const traffic is equal to and this is going to be an array of cars pretty much. I'm going to add the nother car here that is on the same lane as our card that we were used to, but I'm gonna put it in front and it's gonna be our first obstacle that we need to avoid. Now here, we need to update this as well. So I'm going to go through all the cars in our traffic and I'm going to tell each of them to update and keep in mind the road borders or you can also pass there An empty array instead of the board, there's, if you want the traffic to be invulnerable to everything. But I'm gonna keep it there for now, let's see later. And we need to draw these as well. So I'm going to go here, another for loop going through all the things in the traffic. Now we just have one thing, but this is going to be a general code. And it's going to draw each of them on the canvas like now I save the file, refresh the page, and there is another car in front of us. And if we press the arrow keys, something strange happens. We are not controlling our car anymore, we are controlling the other car. And that's because the key listeners are being overwritten from the original car to the last car in the traffic, we're going to need to specify which car gets these controls and which not. So I'm going to go up here and tell this car to have here. Keys, I'm going to say this one to be just the dummy, maybe we will have it move slowly or standstill or something like that. Dummy cars will have some very simple behavior. And now we are going to go to car js. And in the constructor here, I'm going to also pass control type. So either keys or dummy. And I'm going to pass this to the controls as well. And in controls Jas. This constructor will get type like so. And here, we are going to switch according to the type. And we are going to say that in case it was keys, we are doing that break. And in case this is a dumping, I'm going to set forward to true and break. Now I save this refresh a hint, the current front, the current front moved, I actually can't catch it. Because we have the same movement speed, I mean, max speed. So it would be nice to go here in the car constructor. And maybe specify here, a value for this max speed. Let's have it default to three, but allow us to change it from the main file. So in main Jas here, I'm going to set a value of two for the dummy, save this refresh. And now I can actually catch that dummy. So far, the sensors are not reading this dummy car, and we're not even getting damaged by it. We'll take care of that in a sec. But first, this scene is becoming a bit too crowded with all these lines. And the dummy car doesn't really need a sensor. So I'm going to disable this by going to our car J S. And if control type is not dummy, then we will equip this car with the sensor. And later where we update the sensor. We will check if this sensor exists. And only then update it. And same goes down below for the trolling. So if there is a sensor, then we are going to draw it. And now if I refresh that car in front doesn't have any sensors doesn't draw any sensors. It's just a dummy going at fixed max speed there on the road. Let's interact with it. I'm gonna go here in main Jas. And where we update here our car, I'm also going to pass the traffic and because I'm going to write some general code here, this is going to be needed to hear in traffic update as well. But I'm just gonna pass nothing here because if I do pass traffic here, then that means that car in traffic is going to interact with itself. So it's just going to get damaged by itself. And I would need to write some code to prevent that. I'm also thinking about later, when we do some more complex simulations. And we have a bunch of cars, I don't want to have a lot of broken down cars on the road and blockades. So I think that I don't want the traffic to get damaged when it's touching other traffic or us. So I'm leaving it empty. Here in case of the traffic, I'm saving this file, and then I'm going to our car. And in our update method, here, I'm going to pass traffic as well. And this is going to be needed inside the assess damage. Here, we will assess damage with the traffic as well. But also, in the sensor update, the sensor will perceive the traffic as well. Let's do this assess the damage first, it's quite easy. I'm going to pass traffic. And I'm just going to copy this code and replace here road borders with traffic. And here road borders with traffic of i dot polygon. I think it's right, I save this refresh. And now when I press up, I'm catching, catching catching that car. And when we collide, I'm damaged, it's not damaged. Because our car it's not in its traffic list. But feel free to play with the code then make it like that if you wish. Now let's do the sensors as well. So the sensor update here gets the traffic. I'm gonna go now to sensor js and pass the traffic here as well. And also to this get reading here, let me just write it a bit nicer. So you can see this on screen. Like so. And the get reading has now a traffic to deal with as well. So our touches, the things that the rays are going to intersect may be road borders, but now polygon segments from the traffic cars. Let's do this. I'm gonna go here below. And I will say I going through the traffic like this, I will get a poorly. I'm doing this just so that I don't repeat traffic Have I got polygon everywhere. And now I'm going to go through all of the points in that polygon and get an intersection value using our utility function from the array of zero and array of one so this is the same as there. But here we are going to take the polygon J point and J point plus one with our module shrink. Now if there is a value here, then we add it to our touches as well. And that's it. Let's Save and test okay, because the traffic cars are black and my array turns black is it touches the nearest segment of its polygon. I don't see things very clearly. Let me color the cars differently so that our car is blue and the traffic is red. I'm gonna go in main Jas. And here let's draw this one as blue and the traffic as red like this. And inside car Jas. I'm going to go down to our troll method here and say color and the non damaged color is going to be color. We save this refresh. And now we can actually see that the array turning black like that and our sensors are reading that there is dancing in front of it. They are working from all different angles. Let me try a trick I saw once in what was it fast and furious, maybe it was much better in that movie. How it went right through us. We now have a complete simulation, a drivable car with sensors that can see the road borders and other cars in traffic. But so far we've been doing the driving, and that's about to change. Next, I'll give you a brief lesson in how our brains work. And then I'll show you how to code something similar, an artificial neural network, you'll learn the components of this kind of network and how to connect it to the car so it can move by itself. Neural networks are computing systems inspired by the biological neural networks in our brain. These are some neurons, these branch like structures received the signals. When stimulated enough, a neuron will fire a signal through its axon. So a single neuron does something really simple, and intelligence only comes when they work as a team. You see, your brain has 86 billion neurons. You also have quite many of them in your spinal cord, then sensory organs like in your eyes and yours. These sensors send signal to some neurons that pass it to the brain. There the processing happens like a chain reaction where some neurons fire some don't eventually signals arriving to motor neurons that pass them through your spinal cord and make some muscles contract in very specific ways. Hey, a lot happened in just a split second, let me try to slow this down and explain it to you. Pay attention. sensors inside the year pick up compression waves from the air and sends signals to the brain which figures out the direction based on different intensities. signals then traveled to neck muscles tell them to contract and turn the head in that direction. The eye catches a glimpse of what's happening and use signals travel to the brain. peripheral vision is blurry. But good enough information exists to detect some kind of object approaching and new signals travel to facial muscles to contract and protect the eyes from getting hurt. Eyes are really important. At the same time, the brain begins to kind of defense protocol by sending signals throughout the body. Time passes and the image becomes more clear. The brain does pattern matching and recognizes the object as a bowl. Contextual and historical information will play an important role in what happens next. Let's stick to the first one. The brain concludes there is no threat and uses knowledge about physics it learned during its lifetime to predict where the object is headed. It then sends new signals to the muscles to contract in slightly different ways to catch the object instead of blocking it. And the rest is history. One history where the brain did the good thing and not much happens afterwards. But sometimes this happens and the brain learns it did something wrong and configures itself. So the same thing doesn't happen again. Hopefully, anyway, I'm feeling really good about myself now that I know my brain can do something like that in an instant. hope you do too. I work cars neural network, we'll do something like that. Neurons on the first layer will be connected to the sensors, they will send signals forward a few times, and the last layer will be connected to the car controls to make it actually do something. Spoiler alert, we'll be working with relatively small networks here. But that's okay, because we actually don't need very large networks to solve this problem. Now implementing all this in one shot is well, scary. But it's easier if you break it into levels like a building. Each level has a floor a ceiling and connections in between. The ceiling of one level is the floor of the next man so on. Now, let's start to code one of these levels. I'm going to go in index html and include a new file here. Let's call it network Jas and create the file here like this. Inside the file, we begin to write our level class. And a level has a layer of input neurons and the layer of output neurons. Their numbers doesn't necessarily match. So I'll specify these parameters here like this to define The actual neurons, we use simple arrays of values like this, we need one for the inputs, and one for the outputs. And I'll also add one for the biases, each output neuron has a bias, a value above which it will fire. So I'm defining these as an array, like this. Now, when coding this, I'm actually going to connect every input neuron to every output neuron. That's not the case in our biological brains, but these connections will have weights. So a weight of zero means pretty much the same thing. So let's have here, weights equals to an empty array. And going through all of the inputs, I'm going to prepare here, an empty array, the size of the output count. So for each input node, I'm gonna have output count number of connections. And now what we have here so far is actually only a shell for the brain to function, these weights and biases need to be set to some real values. So for that, I'm actually going to simply randomize for now, we're going to have a random brain to begin with. And to randomize, I'm actually going to define a static method here. This is different from what we usually do, but we do it because I want to serialize this object afterwards, and the methods don't serialize. So here, given a level, I'm going to go through its inputs like this. And for each input, I'm going to go through its outputs like this. And for every input output pair, I'm going to set the weight to a random value between minus one and one. And to do that, I'm gonna write here, math dot random, which gives us a value between zero and one, multiply this by two. So now we have a value between zero and two, and subtract one. And now we have a value between minus one and one. And actually biases are going to be in the same range as well. And you may wonder why negative values. And here's one reason for it, think what should happen here, the car sees something with the front sensor, so it should turn to avoid collision. But which way, negative weights connected to these sensors on the right could send the message that don't turn to the right. So the remaining option is to turn left, both weights and biases can be between minus one and one. And there is a nice mathematical reason for this, which I will explain soon. Now, these inputs, they will be the values that we get from the car sensors. And what we need to do is compute the outputs using these weights and biases that we defined. Those are random for now. But in a smart brain, they will have some kind of structure, we compute the output values using a feed forward algorithm. And it's actually quite simple. Given some inputs, these given inputs, and I'm passing here the level as well, I'm going to go through all of the level inputs, and I'm first going to just set them to these given inputs, these will be the values that come from the sensor. So we do that using a simple for loop like this. And now to get the outputs we are going to loop through every output like this. And we are going to calculate some kind of sum between the value of the inputs and the weights, I'll show you. So this sum is zero in the beginning. And now we are going to use another variable j to loop through the inputs like this. And the sum will actually add the product between the JSON input and the weight between the Chained input and the output like so. And we repeat this with every input neuron. So, in the end, what we will have to do is check is this sum greater than the bias of this output neuron and if so, we are going to set the output neuron to one so we are essential Returning it on. Otherwise, the output neuron is going to be set to zero. It's as simple as that. And now I just want to close this and return here, the outputs for convenience. And I need to also close this level class right here. Now this code will work. And we'll leave it as such. But I'm going to tell you a story. And it's a bit scary. So brace yourself. You see, scientists like to write it by adding the bias here and comparing with zero. Because biases can go either way, any structure implemented like this can be implemented this way as well. And this, what we have now is the hyperplane equation. But don't be scared. You see, in a very, very simple network, this is the line equation, a very simple function. The one and only wait here controls the slope, and the bias controls the y intercept, we have a function like this for each output, these neurons will fire if the value of the function is above zero. And with weights and biases between minus one and one, you can implement any situation. That's why that rage. Now, when you have two sensors, you have a plane in 3d space. Think about the plane that goes out of water like this. If the value of the two sensors is on dry land, then the neuron will fire. When you add more sensors, you have higher dimensions that are harder to visualize. But the math still works. And you can have as many sensors as you want. I could go on with this story for hours and tell you that scientists don't use binary values here, but instead allow neurons to fire all the time just at different amounts. I mean, it happens here for these first ones, so why not for the other ones as well. Only the last ones need to be binary to give you a clear yes or no answer. But networks are more powerful if these are left as such, actually not exactly as such, because the values here tend to go a bit out of control and a more complex function is often used to bring them back to scale. Now the story may turn into an actual horror, if I start to tell you about what the layers actually do. Moving from linearly separable cases to non linearly separable ones, and fine, fine, I stopped this now. But if you want to experiment with things like that, you probably want to try some kind of library, like TensorFlow, and there are actually more of them out there. Also, let me know if you're ready for more advanced content like this, and maybe I'll make it someday. Meanwhile, I recommend three blue one brown video on neural networks, it focuses more on the mathematics and uses things like vectors, matrices, and other things that tend to scare students off for some reason, I try to avoid these here. But if you plan to master machine learning, someday, you're gonna have to learn them. Sorry. Now let's get back to completing our neural network code. So far, we have just one level. Let's go now up here in the beginning, and define a neural network made out of many of these. So I'm going to say here, class neural network, like so. And the constructor is going to get an array of neuron counts. So this is going to be the number of neurons in each layer. And I will define here, the levels, I'm going to make my neural network out of an array of levels, those we defined earlier. And for each level, I'm going to specify the input and output count like this. So I'm adding here, a new level with the neuron counts from the eyes index, and the neuron counts from the i plus one index. That's it. Simple as that. And here, we're going to need a feed forward algorithm as well. And this is also going to be really easy. So in the same way, given inputs and the network, I'm going to get the outputs by calling the feed forward method from the level with the given inputs and the network's first level like so. So this is now calling the first level All to produce its outputs. But then I'm going to loop through the remaining levels. So notice that here, I'm starting at i equals to one. So looping through the remaining levels like this, I'm going to update this outputs with the feed forward result. From the level, I like this, let me close this, return the final outputs. And we are done with the feed forward method and with the neural network object. So what we're doing here is essentially putting in the output of the previous level, into the new level as the input. And the final outputs will tell us if the car should go forward, backward to left or right. Now let's connect this network to our car sensors. So I'm going to go to car here, all the way up in the constructor. And where we're saying that we defined sensors for our car, I'm also going to say this dot grain is equal to new neural network. And here we have to specify our array of neuron counts the size of the layers. So in the first layer, we are going to have this dot sensor that array count. And here you can have as many layers as you want, but I'm just going to add two of them. one hidden layer, and the output layer, which will have four neurons, one for forward, one for backward, one for left, and one for right. Let's close this, like so. And now, after we update the sensor here, I'm going to first take out the offsets from the sensor readings. Remember, our readings had three things an x of y, and the offset of where the reading was. And from each sensor reading, let's call it S, I'm going to check if it is no, then I'm just going to return zero, there is no reading here, the sensor goes as far as possible and doesn't see anything. Otherwise, I'm going to return here, one minus the sensor offset. I'm doing this because I want our neurons to receive low values if the object is far away, and higher values close to one if the object is close, kind of like this flashlight. When we pointed at the wall, we see the light coming back at us. And if we get closer, the light that bounces back is stronger. That's how sensors work in practice. Now to see what the neural network has to say, we just say outputs is equal to a neural network, feed forward these offsets with this brain. And I'm going to log here these outputs to test for now, if I save the file, and refresh the page, I'm gonna get there at the bottom in the console, some array of values for values, one for forward, one for left, one for right and one for backwards. So at the moment, the car should actually go forward, left and right at the same time. But it can't do that because the brain is not yet connected to the controls. It's kind of like when I had the knee surgery a while back and they paralyzed me from the waist down. While the anesthetic was wearing off, I really tried moving my feet brain was working normally, but motor neurons were just not sending the signals properly. To make the car do its own decisions, we are going to go here in main js. And instead of using the keys to control the car, let's write here, a AI for artificial intelligence. I'm going to save this file and then car js. Up in the constructor. I'm going to define here an attribute called use brain that is going to be equal to control type double equals AI. So if our control type is AI, it means that the brain that the car actually has already is going to be in use. So down here in update if This brain is in use, we are going to say the controls forward, this is going to be equal to output six zero controls left, this is going to be equal to outputs of one controls, right, this is going to be called two outputs of two and controls. Reverse, I think it was, is equal to outputs of three, let me just check this real quick. Yes, it's reverse, saving this file, refresh the page. And nothing happens. But if you look in the output, you'll see that this array has four zeros in it. So nothing is on forward, reverse left or right, nothing is pressed. Let's try to refresh again, remember, these networks are random so we can get anything out of this. Okay, this was interesting. So we have their right and reverse turned on. So this was a card that just went backwards and to the right, okay, here, we have a car going forwards, left, and then reverse. So the forward then reverse actually cancel each other out, and the car is standing still. Okay. Now, this is really interesting, we have a car that goes forward. So it went forward in the beginning. But look what happens. Now, when those two sensors are touching the car in front, the network somehow triggers the brake. It's amazing, this was randomly generated, and we were lucky to get the really nice behavior out of this. So our car is supplying the brake, every time it gets really close to the other car, and just out of luck, it's not colliding with it. So it's doing this kind of stoking motion there. Now, this debugging here is not really very useful, printing out the outputs like this. And actually debugging things like this is really hard, you could go here and say, for example, car dot brain, and look at it and see that yes, it does have these two levels that we defined previously. And the first level has some inputs, some biases. So we have the inputs, here, you can see 000, for the middle ones, and some values for the first and the last one, which is great, we visually see that one as well. And the outputs should be for the first level here. One, one, and all the other ones are zero. But then the second level is going to get those inputs, the 110000. And this network with these biases, random values between minus one and one. And these weights, also many, many random values between minus one and one, produce the result that you see here. So going forward, and reverse and left and right, everything just cancels each other out, then our car with all this brain does nothing. So you can see how debugging like this is very, very difficult. And we don't really get the full picture unless we really start to analyze all these numbers here. And that's why it's gonna be really great. When we visualize something here, I mean, make something that at a glance, we can see this entire network in action. So I'm gonna go to index html here. And I'm actually going to refactor things a bit. This, my canvas from the beginning, is gonna be called car canvas like this. And we're gonna use another canvas on the right to display the network. So we're gonna visualize a neural network in this one. Now, let me save this and go to our CSS file. And my canvas will be renamed to car canvas. And I'm going to copy this as network canvas and to distinguish between them. Let's make this background black. Like this, now, in main Jas, I'm going to go here at the top and say that this all we did so far is on the car canvas. And I'm actually going to refactor everywhere it says canvas here, by pressing right click Rename symbol and saying here, car canvas like this, and this CT x is going to be renamed to car seat dx, like this. And I'm gonna copy this part right here for the network Canvas. So here we have network, Canvas, and network canvas. And here also network canvas. And I think this one can be a little bit wider. Let's see if we can fit 300 pixels wide Canvas next to our car Canvas from previously, then here, the car context is going to need network context next to it. So network context coming from our network canvas, right. And one more thing we need to do here, when we make our car Canvas have the same size as the screen vertically, I'm going to do the same thing for our network accounts. Save the file, refresh the page, and we have our car on the left doing something, whatever it's doing, and every time we refresh, it's probably gonna do something different. Probably not something smart. And on the right, we have a blank blank canvas that also stretches quite nicely with the size of the screen. And what will be really great is if you can go here, after drawing all the car related stuff, and saying visualizer draw me a network on the network context, and put there the car brain like this. And now I'm actually going to add some code here that does the visualization for us. I'm not teaching it here, because I think we would be sidetracking too much. But it's really well described on my channel and their source code in the description. So saving everything refreshed the page, and we have network that decides our car should go in reverse. quite boring, let's try refreshing again. This network says it should go forward, left and then reverse. So basically, it stands still forward right and reverse. Right then reverse. That was kind of interesting. One more thing is that this visualization also supports animation. So we could animate this visualizer if you want by going here and specifying a time argument, this value comes from the request animation frame method here. And here we can say network, C dx dot line dash offset is equal to time. And when we do this, all by, okay, this is a bit too fast. Let's slow down this a bit by dividing here by 50. And actually, this animation should go the other way around. So I'm going to specify here minus time divided by 50. And now it's a visual reminder that this is implementing the feed forward algorithm. This thing here, one by one, these randomly generated networks and expecting some miracle is not very convenient. So let's write some code to parallelize this and have many cars running simultaneously, like in different parallel universes. I'm going to define here a function called Generate cars that accepts and as the argument and I'm going to have an empty array of cars at first. And then for i from one to N, I'm going to push a new car into this array and the car is going to be centered in the middle lane at 100 Why with 30, width and 50 height like so, and they are all going to be AI cars. And here I just return these cars like so. And up here where we have car defined we are actually going to define cars instead equal to generate cars have n like this and our n is equal to 100. So we are going to have 100 cars going in parallel, and hopefully one of them is going to do something right, we need to update these cars here. So where we have here car dot update, we are going to write a loop and say, let i is equal to zero, i is less than cars dot length, i plus plus. And then we have here cars of hi update, like so. And we are going to do the same for the drawing down here, drawing them as blue like this. But we still have two individual car objects here from previously. And I only need one car here. So let's just replace it with the first car in the array for now. Otherwise, this code will not work. So this is for translating the canvas on one car from the 100. And this is just printing the brain of this one car somewhere on the right, save the file, refresh the page, and then how its total mesh. One thing we can do to make this nicer is actually drawed them semi transparent. So I'm going to go here and say car city x dot global alpha is equal to 0.2. And after I'm done drawing these cars, I'm going to set global Alpha back to one. So it doesn't affect what I'm going to be drawing afterwards or on the next frame. So saving this and refreshing, it's a little bit better, but still quite much happening there. I think that I want to emphasize one car, like for example, the zeroeth car, this one that we are using everywhere, pretty much by drawing it again with the maximum opacity. But also I want this one to be the only car for which we draw the sensors. So I'm going to modify this draw method of the car next, and say here, a third parameter for draw sensor. This is by default set to false. And here, if this sensor exists, and draw sensor, only then we are going to draw its sensor. And now it's a little bit clearer, not so many yellow lines there. And you can see something interesting already, that this car right here, car zero is not the most interesting one, the most interesting one went somewhere up there, and it was chasing the other red car. So back to main js, here, our cars have zero choices not really great, we want to focus on the best car, the one that goes upwards, the most or the one with the minimum y value. And I'm going to define this best car here and say, best car is equal to find the car whose y value is equal to the minimum value, okay? Of all the Y values of the cars. So this may seem a little bit scary. So what is happening here, cars dot map, see going to see dot y this means that we are creating a new array with only the y values of the cars. That's it. And here we are spreading this array because the math main method here doesn't work with arrays. It works with many, many different values no matter how many you want to pass it, but not with actual arrays. And that's why we need to spread it here. And we just find the car whose y value is the minimum value of all the y values. The code is not really complicated. But if you're not used to this modern syntax, then this can be a little bit daunting at first. I added here because you will see it if you work with JavaScript. So now with this best car, I'm going to copy it everywhere. We were using cars of zero previously so we translate the canvas to the best cars. Why like this. And then here we are drawing the best car without transparency so that we clearly see it. And with the sensors, we are also drawing the brain of this best car. And that's it, I'm going to save this and refresh. And now our canvas is always centered on the car that goes upwards, the most, in this case, these stalking cars that are behind this red one. All right, let's try to refresh again. And again, I'm waiting for a car that passes this red car, but then continues to go in a straight line somehow. So just by trial and error, I think that we're going to be able to get to something like that, let's see. Okay, we got something, it's fidgeting quite a lot, but definitely better than all other cars we had so far, it passed the car in the traffic, and it's just going forward forever, pretty much. But now the problem is that when I leave the browser, this car is going to be gone. And all my experimenting was for nothing. So let's write some code to save this car. I'm going to use local storage for this. So I'm going to say, local storage set item, the best brain that we have. So far, we're going to store it in this best brain attribute and local storage. And the value is going to be a JSON string coming from the best cars brain. So I'm essentially serializing that brain into local storage. And come to think of it we might need to destroy the saved brain as well. So I'm going to discard, maybe it's a better word, the value from local storage with this other function, I'm sure is going to be needed sooner or later. Now this best car is actually not accessible here. So let me just update its value here. But define it here as a global variable. Like this, I'm using lit because it's changing. And I'm gonna set it to be the first car in the beginning, but it's gonna update on every frame. Now, if we have in local storage of brain or best brain stored, I'm going to set the brain of this best car to the value and I'm using JSON parse because I am parsing the JSON string we saved previously, local storage only works with strings like this. Now, in index html, I'm going to put these buttons vertically between the two canvases. So here, I'm going to use a div to define river vertical buttons with ID vertical buttons. And I'm going to say here, the first button is going to have an unclick of safe like this and our second button is going to have an on click of this card, like so. And here I'm actually going to use emojis for these boughten contents like this with the save icon and trash like you can find emojis like this just by searching online. So I'm gonna save this file and go to the CSS next, and remove this text align from the body because we're going to use flex display instead. So I'm going to remove this and say, display, flex, justify content and align items to center like this. And now our vertical buttons are going to go here with display flex and flex direction column So this is by default row. And making it column means that our buttons will go below each other. And here we define our button next. So I like to remove the border and give it a round shape. So a radius there. And a padding, this is some value that I found goes nicely with the emojis that we use, and the margin of two pixels. And the cursor is set to pointer so that our arrow icon changes into a hand cursor when the mouse is over it. And speaking of hovering with the mouse, let's set hover for the button so that it gets blue background like this. So save the file, refresh the page. And looks like we have another shaky car over here. But we are not going to lose it this time. Because we can press the save button. And this means that now inside of our local storage, we have this cars brain. So now when I'm going to refresh the page, what that means is that here inside of main js, where we are loading the value from local storage, we still get the car from previously. Now what we are doing here, could we actually fully automated so that the computer tries again and again, and always keeps the best. But let's think about what the goal is. I mean, what will a good network be able to do? Let's look at the definition of the best car here. We're just using the y coordinate. But you can use other functions here as well. These are called fitness functions. For example, you could measure the travel distance instead. Doing that may result in cars that go backwards as an easy way to avoid the obstacles. Or just go around in circles forever, going infinitely far, but also going nowhere at the same time. So need to be careful when choosing a fitness function. I'm using the y value here. But if the road would be turning, it wouldn't work anymore. So think about these and play around with the code and try to think about other stuff as well. Like could you come up with a fitness function that keeps rewarding the car for going upwards, but penalizes for going too much sideways, or even better penalizes if you're not in the center of the lane. These are all homework ideas for you. But now I think we're ready for more traffic. Let's go here in our traffic array, put a comma at the end and add two more cars. One is going to be on lane zero, and minus say 300 and the other one at the same vertical level. But lane two, I'm going to save this refresh. And now let's see what happens almost there. But that looks like even our shaky car didn't make it. So let's try again. It looks like there are just not enough cars passing that first car in traffic. What we would like to have is more cars like this shaky car. But not exactly like it so that one of them may be is gonna stand the chance and pass the second and third car in the traffic. So let's go now to network Jas. And I will teach you how to mutate a network. And it might sound fancy, but it's really really easy. I'll show you. We right here a method called mutate, which takes a network as a parameter and an amount. Let's default this to one or 100%. This will just randomize everything what we had previously. But if you set this value to like 10%, then you're gonna get the network that is close to the original one that we pass it here. So how does this work? Well, we are going to go through all the levels of the network using a for each loop like this. And for each level, I'm going to use this arrow function notation here. I'm going to iterate through all the biases and then through all the weights later, but first with the biases and I'm going to say that the AI bias is going to be equal to learn, we're going to use linear interpolation again. And I will interpolate between the current value of the bias, whatever that is, and a random value between minus one and one, as we did in the randomizing, but now we're using loop to go from the current value of the bias to words, whatever that random value is, depending on this amount right here. As simple as that. And I'm just going to repeat the same thing for all the weights. So I just go through all the IJ weights like this. And say that those weights, that weight of ing scoring to be equal to linear interpolation between the current value of the weight and a value between minus one and one random value. And again, depending on this amount, so if this amount is going to be let me see, did I close this properly? Nope. So if this amount is going to be 100%, then we just get this part right here. And this mutate is pretty much our randomized method that we had previously here for a level. But now it works for the entire network. So if the amount is zero, then our biases, and our weights just stayed the same. But if this value is somewhere in between, then it's going to move away from these biases, depending on this amount. So let me save this file now. And go back to main js, where we are reading the brain from the local storage here. And actually, we are going to loop through all the cars and say, let i is equal to zero, less than cars dot length, i plus plus. So for each car here, cars of high hits brain, it's going to become equal to that from the local storage. So this as such is going to be really, really boring, right? Because it means that if we refresh now, we just see 100 cars that are overlapping each other, and they're, that are acting exactly the same. But I'm going to put here a condition and say that if AI is not zero, so the brain that we have in local storage will be kept for the case when I zero and that is our best car initialization there. But for all the other ones, I'm going to mutate and say neural network, dot mutate the car, have I brain by an amount, let's say 0.1. And now let's see what happens. You can see many cars this time, but they are all following our shaky car quite closely. This one, none of them was able to go beyond that second car in traffic. Let's try again. Nope, it looks like this 0.1 might be too low. Basically, our new networks are too similar to the one that we already have in memory. So let's try 0.2. Now our cars look a little bit more different than before, but still quite similar to our shaky car. And look at that we have a new best car. Maybe. I hope it doesn't hit the border now. Yes, it figured out it has to turn. That's great. So I'm going to save this new car right now. And when I'm going to refresh, now, our new car the more improved car which wasn't even shaking is stored in memory and it's going to mutate and try to become even better if possible. But our scenario now with three cars is not a match anymore, so we can try even harder one. Let's go here and copy this. Maybe The four more times. And here let's have two cars at minus 500. And the last at minus 700. And we are going to have here maybe on lane zero and Lane one, and then on lane one and lane two. So I'm just thinking how to make a complicated scenario that involves all kinds of twists and turns. So let's save this and refresh. And now let's see what happens okay, I'm gonna save this I did it before this other boring car over took it. So that's something that you may want to pay attention to. Let's refresh nothing I think we want the lower value for the mutation here. So that more cars are going to be like that one that almost wented past these other two cars. You can see quite many of them here now. Still nothing. Let's try again okay, this is interesting. I would say this is a new winner now. It got to this stage and now it's going in line with the other cars. Let's save it. It's taking too long. Let me try with 1000 cars. I think this should work on my computer if your computer is too slow, then just stick with 100 cars and repeat more. Ah, almost there. You Yes, yes, we did it. We did it. Oh, no, no, no, no, no, no, no. I should have saved that one. I think it could have mutated into something good eventually. Hmm. Let me save this. It's clearly better. Come on. I'm hopeful that this time we're going to make it. Let's see. Okay, two cars there now. Will one of them stop before hit? Yes. Yes, that car stopped just before hitting the sides there. Let me save this. Try again. And now we have quite many of them that are quite similar. Okay, let's keep just one car here and see it in action without any other things disturbing it. Okay, that was quite, quite close there. Oh, yes. Somehow I thought it's gonna get damaged even though I know that it's the best car from previously so it won't get damaged. There are many more sophisticated genetic algorithms out there. For example, some algorithms use crossover. So they take two networks and mush them together somehow. The hope is that maybe one car knows how to turn left really well and another one knows how to turn right. So combining these networks could give you a new one that can do both. Thank you can implement this. If you got this far. I think You can try it out and let me know how it went. We are now actually done, I won't be teaching you any more algorithms, you have many things you can play around with. And I'm quite happy with the car we have right now it's making its own decisions, and it's avoiding all other cars. It couldn't be better like if it would recognize the lanes, but I'll let you worry about that. Meanwhile, I'm going to relax and show you how to draw a car in PowerPoint. Since you've got this far, all I can say is congratulations. Hope you took things seriously. And by now you've learned how to simulate driving mechanics detect collisions and create artificial sensors. You also know about neural networks, what they can do and how to optimize them using a simple genetic algorithm. But we just scratched the surface here, and I haven't really taught you why the neural network works. I mean, sure, we built one. And because it's so complex, you can assume some smart behavior is possible. But how does it really work? We have such a great system now that it's a shame to put it to waste. So I'm thinking about making a new course where we start off with a very simple network and gradually go bigger and bigger and see what each of them can do. We could also try new things like teaching the car to stop before impact, how to respect the lanes, maybe even how to park and other cool stuff like that. What do you think? Would you like a course like that to practice even more JavaScript and become a master of making diagrams that show what's inside these so called black boxes. And if you want something else right now, I do have a lot of content on YouTube. This course teaches how to build location based applications. In this one, we make an augmented reality piano. And here we use the camera to make a new kind of puzzle game. I have many small projects as well, but it's really hard to keep track. Maybe they're better organized on my website. I don't know. By the way, on the website, you can find a more enhanced version of the self driving car. Check it out if curious. Anyway, thanks for watching. Please share this course with anyone you think is interested. And since you got this far, you're probably subscribed already. So see you guys
