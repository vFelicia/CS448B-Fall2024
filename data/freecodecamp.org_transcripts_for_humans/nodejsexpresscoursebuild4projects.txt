With timestamps:

00:00 - improve your node.js skills by building
00:02 - four projects
00:03 - this course is taught by john smilga the
00:06 - wonderful instructor from coding addict
00:08 - what's up everybody this is john from
00:10 - coding addict and welcome to another
00:12 - nodejs video
00:14 - and in this video we're going to make
00:16 - four node js projects while working on
00:19 - the projects amongst other things we'll
00:21 - cover what is mongodb and how to set it
00:24 - up in our app how to get up and running
00:26 - with mongoose how to set up error
00:28 - handling in express and eventually we'll
00:31 - deploy our project to heroku and
00:33 - implement swagger documentation as well
00:36 - just like my other videos we'll start
00:38 - with the fundamentals and slowly but
00:40 - surely move up to more complex
00:41 - functionality this is the second part of
00:44 - node.js tutorial video so my assumption
00:47 - is that you're already familiar with
00:48 - nodejs and express basics if you're
00:51 - interested in the first video
00:53 - node and express tutorial you can find
00:56 - the link in the description in order to
00:58 - follow with a project you will need a
01:00 - starter and the fastest way you can get
01:02 - it is by navigating to johnsmilk.com
01:05 - again the url is johnsmilk.com
01:07 - and once you hit this lovely site look
01:10 - for the projects more specifically
01:13 - node ones
01:14 - and then all of these three links lead
01:16 - to the same repo
01:18 - so you can pick any of them and once you
01:21 - click you'll navigate to the repo node
01:24 - express course and essentially in here
01:27 - just pick your weapon whether you want
01:28 - to download zip or if you just want to
01:31 - clone it i think in my case i'm just
01:33 - going to go with download option
01:35 - then go back to your computer look for
01:38 - your downloads
01:39 - then crack open the zip file
01:42 - and
01:42 - right away open up your favorite editor
01:45 - in my case that is visual studio code
01:48 - i'll drag and drop
01:51 - and during this video will work on
01:54 - following projects
01:55 - so we'll work on zero three task manager
01:59 - store api
02:01 - as well as
02:03 - jw2 basics and jobs api
02:06 - and for all the projects you'll have the
02:09 - same structure where there's going to be
02:11 - a final and a starter so final is a
02:15 - complete project and starter is where
02:17 - we'll do all of our work now keep
02:20 - something in mind where for the final
02:23 - one
02:24 - not only you'll need to install
02:26 - all the dependencies basically run npm
02:29 - install
02:30 - but you'll also need to add some
02:32 - additional info what info well that we
02:35 - will cover during the project so don't
02:37 - be surprised if you just run npm install
02:40 - and npm start in the final folder
02:43 - and you get back bunch of errors
02:45 - that's about it for overall setup and
02:47 - when it comes to
02:49 - project specific setup i'll cover that
02:52 - right after each project intro video so
02:55 - once you've got the repo in your text
02:56 - editor feel free to continue with the
02:58 - video awesome and welcome to our first
03:01 - project task manager api and before we
03:04 - cover the features let me list the main
03:07 - goals of this project and they're
03:09 - following with the help of this project
03:11 - we will learn how to set up and connect
03:14 - to the cloud database
03:16 - so effectively we'll learn how to
03:18 - persist our data to the cloud
03:21 - and not only that we'll also learn how
03:23 - to perform all the crowd operations and
03:26 - crud stands for create read update and
03:28 - delete on our data which is fundamental
03:32 - fundamental to any application also let
03:35 - me mention that since it's a node course
03:37 - we'll only work on a back end so
03:40 - essentially the front end app you see
03:41 - right now is already prepared for you
03:44 - and it's only there so you get the full
03:47 - picture
03:48 - and the same is going to be for the rest
03:50 - of the project
03:51 - i'm probably not going to make front
03:53 - ends for all of them
03:54 - but if i'll see that a matching
03:57 - front-end app can provide more clarity
04:00 - i'll definitely whip up one as well just
04:02 - so you can see the entire request and
04:04 - response cycle not just post my
04:07 - responses as far as the first project on
04:09 - the front end we've got a form analyst
04:12 - and by communicating with our backend
04:14 - meaning by sending requests to our api
04:17 - the user can create read update and
04:20 - delete or destroy tasks again let me
04:22 - stress something this is not your
04:24 - typical to-do list app that stores
04:27 - everything in local storage what's
04:29 - fundamentally different is that we're
04:31 - going to be responsible for setting up
04:33 - the api that communicates with the cloud
04:36 - database and persist the data to the
04:39 - cloud and as far as the functionality it
04:42 - goes something like this where we have
04:44 - the form
04:44 - and of course i can enter a new task
04:47 - that's exactly how i'll call it we press
04:49 - submit
04:51 - so we send off the post request and
04:54 - since we're successful we get back all
04:56 - the tasks and the newest task is added
05:00 - to the list
05:01 - now we can also delete task so if i
05:04 - don't want to walk the cat i just
05:05 - removed from the list and then if we
05:08 - want to edit we click over here and
05:11 - first we'll see only the specific data
05:14 - about that one task and then if we want
05:17 - to edit for example if i want to set it
05:20 - up as completed and if i want to rename
05:23 - it as
05:24 - old task then of course we just press
05:26 - edit then we send off the request and
05:30 - now if we navigate back to all the tasks
05:32 - now as you can see it is completed
05:35 - and the name is different as well and as
05:38 - far as the task manager setup
05:40 - like i already previously mentioned we
05:42 - have
05:43 - final folder so this is where you'll
05:45 - find complete project
05:47 - however not only we need to install
05:51 - all dependencies but also if you take a
05:54 - look at the readme you'll notice a text
05:56 - where it says in order to run the
05:58 - project you need to set up dot env and
06:02 - set up the uri connection variable
06:06 - and essentially these are the things
06:08 - that we'll cover during the project so
06:10 - in order to spin up the project yes
06:13 - you'll have to watch some videos where
06:15 - we actually cover that and only then
06:17 - you'll be able to do that now as far as
06:20 - the setup
06:21 - a lot of things should look very
06:23 - familiar so in here we have the public
06:26 - and of course in the public this is
06:29 - where we have our app again everything
06:32 - is already prepared for you and just so
06:34 - we all are on the same page i actually
06:37 - created that with vanilla.js and then of
06:40 - course we have the app.js and here i
06:44 - simply have one line task manager app
06:46 - and then if you take a look at the
06:48 - package.json as far as the packages we
06:51 - have express something we covered in the
06:55 - second part of the course and then you
06:57 - see two more packages dot env
07:00 - and mongoose and of course these ones
07:02 - will cover during the project why
07:04 - they're there and what is going to be
07:06 - the use case
07:07 - now in order to make our dev setup
07:10 - easier i also installed nodemon as a dev
07:14 - dependency and as far as the script well
07:17 - you just need to type npm start
07:20 - and that essentially will spin up
07:22 - nodemon with app.js and then we also
07:25 - have git ignore which we're going to
07:28 - cover a little later once we create the
07:31 - env but long story short this is just a
07:34 - file
07:34 - that prevents specific files being added
07:38 - to the source code and essentially with
07:40 - this setup these two things will be
07:42 - ignored if we decide to push this up to
07:45 - the github so we'll ignore node modules
07:48 - because usually they're pretty big and
07:50 - then dot env because this is where we
07:52 - want to keep our secrets and of course
07:54 - we will cover this one later in the
07:57 - project
07:58 - and once we're familiar with the setup
08:01 - let's kick things into gear and actually
08:03 - start working on project
08:05 - and first thing that you need to do
08:07 - is to navigate to the starter folder
08:11 - again you're looking for the third
08:13 - project the task manager and then more
08:16 - specifically the star folder
08:18 - and i think the fastest way to navigate
08:21 - there is by just typing cd
08:24 - and then grab the star folder
08:27 - and drop it here
08:28 - and then once you're in a starter before
08:30 - you do anything make sure that you
08:32 - install all the packages and of course
08:34 - we do that by running npm install and
08:38 - then once all the packages are in place
08:42 - in order to spin up the nodemon we need
08:44 - to go with npm start unless of course
08:47 - you want to change it to a different
08:49 - command if that's the case then make the
08:53 - changes and then use that command
08:55 - instead so in my case i'll just wait a
08:57 - little bit i mean it shouldn't take too
08:59 - long there's not that many packages in
09:01 - there and then once i have all the
09:03 - packages in place then of course like i
09:06 - said we're gonna go with npm start
09:09 - and if you see task manager in the
09:11 - console
09:12 - we are in good shape
09:13 - and now let's set up the most basic
09:16 - express server which essentially is just
09:18 - going to be listening for one route
09:20 - forward slash hello
09:22 - and it's going to be on port 3000 now if
09:25 - you want to jog your memory and test it
09:26 - up yourself just pause the video and
09:30 - resume once you're done
09:31 - if you don't want to do that just keep
09:34 - on watching the video and the way we set
09:36 - up the most basic express server
09:39 - is by setting up a variable by the name
09:41 - of express then we'll set it equal to
09:44 - require and that's going to be equal to
09:46 - our express package then we need to
09:48 - initialize it so we go with app and that
09:50 - is equal to express and we invoke it
09:54 - and then unlike the previous examples
09:57 - we'll actually set up a variable by the
09:59 - name of port and for time being we'll
10:02 - hard code this to 3000 but eventually
10:05 - there is going to be more code and i'll
10:08 - talk about the reasoning later so for
10:10 - now just set up the variable and we'll
10:12 - be in good shape and in here we need to
10:14 - go with amp.listen of course and first
10:17 - thing we pass in is the port and the
10:19 - second is the console.log so we go here
10:23 - with some kind of text
10:25 - and i'm going to go with server is
10:27 - listening
10:28 - on port and then of course we pass in
10:32 - the port value and i always like to add
10:34 - those three dots as well so i'll do it
10:37 - in this case and then i'll open up my
10:40 - console the moment i have server is
10:42 - listening on port 3000 which is just
10:46 - awesome so now let's also set up that
10:48 - one lonely route so above the port
10:52 - i'm going to go with my comment routes
10:54 - and then we'll just say app.get so this
10:57 - is going to be a get request now what is
10:59 - going to be the url well we'll go with
11:02 - forward slash and hello so that's going
11:04 - to be the path and then of course we
11:06 - have the callback function
11:08 - once the user hits the route and we're
11:12 - looking for iraq and res so request and
11:14 - response and we simply want to go with
11:16 - reg dot send and then we'll pass task
11:21 - manager
11:22 - and app so i'll save it here i'll
11:25 - navigate to the browser and i'm looking
11:28 - for port 3000 of course
11:31 - and then we'll go with hello
11:33 - and if we see task manager app displayed
11:36 - in the browser then of course we are off
11:39 - to the great start
11:41 - beautiful and once we have the bones in
11:43 - place
11:44 - next let's take a look at our
11:45 - application so we can decide what route
11:49 - eventually we're going to have
11:51 - and i can see that i'm getting all my
11:53 - tasks
11:54 - so there will definitely be a get
11:57 - request that gets me all my items now i
12:00 - can also create a new task
12:03 - so there will be a post request that can
12:07 - create a new task now we can also delete
12:10 - one so there will be a route for that
12:13 - and if we click on edit we open up a new
12:16 - page
12:17 - and in here we get info about specific
12:21 - route so there will be a get request
12:24 - that just gets me info about one single
12:27 - task and also
12:29 - we'll have the ability to edit so if i
12:32 - change the completed from true to false
12:37 - if i successfully edit that then if i go
12:40 - back to the tasks of course in here i
12:42 - don't see the check mark which means
12:44 - that i successfully edited the task and
12:48 - what that means is that there's also a
12:50 - route
12:51 - for the update and in summary our routes
12:55 - are going to look something like this
12:56 - where there will be a get request on api
13:00 - version one and then tasks so this will
13:03 - get all the tasks then there will be a
13:05 - post request on api version 1 tasks
13:09 - again the same url however the method is
13:12 - different so total different
13:14 - functionality in this case we'll create
13:16 - a new task
13:18 - and then we have guest route
13:20 - with params so with the id of the task
13:24 - that gets us that single task and of
13:27 - course one for update and one for delete
13:31 - and since there's a lot to unpack over
13:33 - here i'll spend the next video on the
13:35 - reasons behind such api structure
13:38 - all right so let's go step by step and
13:42 - probably your first question is well why
13:44 - do we go here with forward slash api and
13:47 - then version one and essentially that is
13:50 - just a convention we need to understand
13:52 - that on the server we also might have
13:55 - different routes not just the routes for
13:58 - the api
13:59 - so for example you could be serving a
14:02 - index page here
14:04 - on a forward slash meaning there could
14:06 - be a nice index.html page that you're
14:09 - serving up over here and then also
14:13 - on the same server you have the api
14:15 - routes so convention is effectively just
14:19 - to signal that
14:21 - all of these are the api routes now as
14:24 - far as the version well as you're
14:26 - setting up the api eventually you might
14:30 - want to change some things so it's
14:32 - easier if you have this version because
14:33 - that way when you create a new one then
14:37 - you can just direct everybody to api and
14:40 - then version two three or whatever and
14:43 - while we're still on that same note
14:45 - why don't we navigate to a hacker news
14:47 - one the one that i showed you previously
14:50 - with algolia and you'll notice exactly
14:53 - the same setup more essentially they go
14:55 - with domain and then forward slash and
14:58 - then api and then version number one and
15:01 - that leads me to my next point where if
15:04 - you're ever in doubt or if you're just
15:06 - interested
15:07 - on different setups just check out the
15:10 - different apis there's tons of apis out
15:13 - there and you can just look for one
15:15 - then take a look at their setup and then
15:17 - decide if what they're doing makes sense
15:20 - to you then of course you can implement
15:22 - in your project if not then just move on
15:24 - to a different api
15:26 - and eventually you'll find a setup that
15:28 - makes the most sense to you
15:30 - after that you're probably wondering
15:32 - okay i understand the api high-end
15:34 - version that kind of makes sense but why
15:37 - do we go here with get and then tasks
15:39 - then we have the post and
15:42 - the same tasks and then for get patch
15:45 - and delete we go to the tasks but then
15:48 - we're looking for the colon why isn't
15:50 - this written in a different way where
15:52 - we're just looking for a single task or
15:55 - something along those lines
15:57 - and to give you a short answer that is a
16:01 - convention but since there's more to it
16:04 - i want to actually cover that in a few
16:06 - videos
16:07 - so i want to set up the basic routes
16:09 - with just some simple responses
16:11 - then i want to open up the postman
16:14 - and do a little bit of setup over there
16:16 - and then right before we start setting
16:18 - up the database i actually want to spend
16:20 - one video on just talking about the
16:23 - convention and then lastly if you
16:25 - remember in tutorial we worked with put
16:28 - and now for the update we're using patch
16:31 - and i know that this might be a little
16:32 - bit frustrating to you but that's also
16:34 - going to be something that we will cover
16:36 - a bit later
16:37 - once we have already a working
16:40 - application because that way i believe
16:42 - that i can give you a
16:43 - solid example of the differences between
16:46 - the put and patch that's about it for
16:49 - the general route structure so now let's
16:51 - start implementing it
16:52 - not bad that bad i think we're good with
16:55 - the general structure
16:57 - so now let's start implementing it
17:00 - and i want to right away set up the
17:02 - router
17:03 - as well as the controllers
17:05 - and if you remember at the very end of
17:07 - the express tutorial i covered why is
17:10 - that necessary
17:11 - and essentially the short answer is that
17:14 - as our application grows bigger it's not
17:16 - going to be very sustainable
17:18 - if we'll just start dumping everything
17:21 - in the app drives and for time being i
17:24 - just want to create this one route now
17:26 - as far as the response it's just going
17:28 - to be a simple string that says hey
17:32 - here are all the items or something
17:34 - along those lines and then once we have
17:37 - that one in place then we'll add the
17:39 - rest of them and then we'll test it out
17:42 - in postman
17:43 - so let's get cracking
17:45 - and i'm going to go with new folder so
17:47 - here
17:48 - will be all the controllers and in this
17:51 - case i'm going to be looking for tasks
17:53 - and i also want to set up a routes
17:56 - folder
17:57 - so in the routes folder
17:59 - we'll go with new file
18:01 - and same thing we're going to go with
18:04 - tasks js
18:06 - and then as far as the setup in the
18:08 - routes we need to look for the express
18:11 - router
18:12 - so say const express and that is equal
18:15 - to require
18:16 - and then again we'll look for express
18:18 - and this should be a refresher because
18:20 - we did cover that at the end of the
18:22 - express tutorial
18:24 - so just to jog your memory if we go back
18:27 - to express tutorial and then more
18:29 - specifically we'll look for the final
18:31 - one
18:32 - the file 13
18:34 - the router people shows a basic router
18:37 - example
18:38 - and essentially we have two options we
18:41 - can either go with route or get
18:43 - and then add all the controllers one by
18:46 - one
18:47 - or we can actually change them together
18:49 - where we go with router and then user
18:52 - route so this is going to be the main
18:54 - route in our case api version one and
18:57 - then tasks and then we chain
19:00 - get and post and i think i'm gonna go
19:03 - with this setup so first let's start by
19:05 - setting up the router
19:07 - and that is equal to express and then
19:09 - router we invoke it
19:11 - and then eventually we'll import
19:14 - controllers but for now of course we
19:16 - don't have any so let's just leave that
19:18 - one blank and we'll go with router
19:21 - router then route like i said then
19:24 - forward slash and then i want to go with
19:26 - get method and for time being i'll just
19:29 - hard code the response over here so say
19:33 - wreck and res
19:35 - and res dot and send and like i said
19:39 - we'll just start simply so say all items
19:43 - now let's save that one and then all the
19:46 - way in the bottom we want to go with
19:48 - module exports and that is equal to our
19:52 - router so now back in the app.js we want
19:55 - to import the router we want to import
19:58 - our tasks and we want to set up the
20:00 - middleware so in here
20:02 - let's just go with const and then routes
20:05 - and that is equal to require and then
20:08 - like i said we're going to be looking
20:10 - in the routes folder and then more
20:13 - specifically we're looking for tasks
20:16 - and then right after this hello and
20:18 - don't worry we'll change that one a
20:20 - little bit later for time being it can
20:22 - just stay the way it is we'll go with
20:24 - app.use and then of course what route
20:28 - are we looking for well we want to go
20:30 - with api
20:31 - then version one and then tasks
20:34 - so that's going to be that root route
20:36 - for the tasks router and then we just
20:39 - want to go with our routes and you know
20:42 - what let's just change the round but for
20:44 - some reason i went with routes
20:46 - let's just call it tasks
20:48 - i believe it's going to make a bit more
20:50 - sense and since we'll be sending json
20:53 - from our application
20:54 - for example when we're creating a new
20:57 - task
20:58 - and since i want to access that data
21:01 - in my routes what we need to do of
21:03 - course is get middleware that is built
21:06 - into express and that middleware is
21:09 - express json so above the routes we'll
21:12 - go here
21:13 - and i'll try to spell this correctly
21:16 - since that is always an issue hopefully
21:19 - this is correct middleware and then
21:21 - we'll just go with app.use and
21:23 - eventually we'll set up the static one
21:25 - as well
21:26 - but since at the moment we have barely
21:29 - any routes i'm just gonna go with
21:30 - express
21:31 - and json if you remember if we don't use
21:35 - this then we won't have that data in
21:38 - rec.body
21:40 - so i'll save it here
21:41 - and i'll leave the comments just so we
21:44 - all are on the same page
21:46 - and before i test it out in the browser
21:48 - let me just double check so i'm using
21:50 - the middleware
21:51 - where i'm saying that i'm looking for
21:54 - api version one and then tasks and then
21:56 - i pass in my router my tasks router and
22:01 - then in the router
22:02 - effectively i have this root path
22:06 - which just matches whatever i pass over
22:08 - here so again i go with api version one
22:11 - and then tasks and then i set up a get
22:14 - route where i manually pass in my
22:17 - controller and here i just say res.send
22:21 - and i pass in a string of all items and
22:25 - looks about right so
22:27 - let me go here and we're going to go
22:29 - with localhost 3000 since it's a get
22:32 - request of course we can access it then
22:34 - api version 1
22:36 - and then tasks and we should see a
22:40 - string of all items and if we do then of
22:43 - course we're heading in the right
22:45 - direction so the last thing that i want
22:47 - to do in this video
22:49 - is to first close my express tutorial
22:52 - one
22:53 - and then in the controllers we want to
22:55 - create a new file and we'll call this
22:58 - tasks.js
22:59 - and again just to jog your memory the
23:01 - whole deal
23:02 - why we're setting up separate routes and
23:05 - separate controllers because if i'll try
23:08 - to jam everything in app.js
23:11 - it's going to get messy pretty fast so
23:14 - what i want to do right now is take this
23:17 - logic and place it in a separate file
23:20 - because eventually of course there will
23:21 - be way more logic than just res dot send
23:25 - so i'm going to go to my controllers
23:27 - and effectively i want to create my
23:29 - function
23:30 - the controller function and i'm just
23:32 - going to go with const
23:34 - get all and then tasks and i'll set it
23:38 - up as an r function i'm looking for rec
23:41 - and res
23:42 - and functionality will be exactly the
23:44 - same whereas dot send
23:46 - and we're just going to go with all
23:49 - and then items
23:51 - and then we're going to go with module
23:52 - exports and since i'm going to add more
23:55 - functions in here i'll right away export
23:58 - it as an object so say get all tasks
24:01 - that's when i'm exporting and then back
24:04 - in the routes of course i want to access
24:06 - it so i'll say here that i wanted the
24:08 - structure get
24:10 - all tasks from and of course we need to
24:13 - require it
24:14 - and in this case we're looking in the
24:17 - controllers so i'm going to go two
24:19 - levels up i'm looking for controllers
24:21 - and then more specifically task so
24:24 - instead of hard coding this value of
24:26 - course i'll just pass it in and i'll say
24:29 - get all tasks and if i go back to my url
24:33 - and if i can still see all items then of
24:36 - course
24:37 - we are in good shape and let me just
24:39 - test it out where i'll change this
24:41 - around and i'll say all items
24:44 - from from the file
24:49 - and then if we go back yep we still have
24:52 - the correct result and with this in
24:54 - place now we can set up the same basic
24:57 - structure for rest of the routes as well
25:00 - beautiful and in the same fashion let's
25:03 - set up the rest of the controllers so we
25:06 - have the get one now i want to create
25:09 - one for the post
25:11 - one for get but that's going to be a
25:13 - single item and we also have one for
25:15 - patch and one for delete and pretty much
25:19 - in all of them
25:20 - the setup is going to be exactly the
25:22 - same as far as functionality i'll just
25:24 - send back and i'll say what the
25:27 - controller is doing since of course we
25:30 - haven't connected to the database or
25:33 - anything like that and i just need to
25:35 - come up with a name in my case i'm going
25:36 - to go with create task and again we have
25:40 - rack and res
25:43 - and then we want to copy and paste since
25:45 - i want to speed this up and i'll just
25:47 - say create
25:49 - task create task and why don't we change
25:52 - this one around and we'll say get all
25:55 - tasks
25:56 - now we want to copy and paste and we'll
25:59 - have three more we'll have one for
26:03 - getting task so get task and here we'll
26:07 - say get
26:08 - single task then we'll have one for
26:11 - updating
26:12 - and that's exactly how we'll call it
26:14 - we'll say update task
26:17 - the same is going to be over here and
26:19 - then the last one of course will be
26:21 - delete and then task and you guessed it
26:25 - we also need to change the text
26:27 - and now of course we want to place that
26:30 - in the same object so let's go with
26:33 - create task
26:34 - then get task and we have update task
26:38 - and last one is delete task and then
26:41 - back in the routes of course we want to
26:44 - import them so say here create task
26:47 - get task
26:48 - then update task and delete one and now
26:52 - we just need to set up the routes if we
26:54 - take a look at the app.js
26:57 - these two
26:58 - the get and post are gonna go to api
27:01 - version one and then tasks
27:03 - and then the rest of them are going to
27:05 - be wii d id params
27:08 - so
27:08 - same initial path but then we'll just
27:11 - add the forward slash and then id
27:13 - and that's of course is where we're
27:15 - going to pass the id of the task
27:17 - so where i have the get request to get
27:19 - all the tasks i'll chain
27:22 - dot post and of course
27:24 - which controller are we gonna use of
27:26 - course the create task one and then we
27:29 - can simply go to the next line and we'll
27:32 - go with router
27:34 - then route and like i said we'll go with
27:37 - forward slash and then id
27:40 - and then we're looking for
27:42 - get route and that will be equal to get
27:45 - the single task then we'll set up our
27:48 - patch and that will be equal to update
27:50 - task and then lastly we have delete one
27:53 - and now we'll be equal to delete task
27:56 - now since we know that we can only
27:58 - really test the single task and get all
28:02 - tasks because that's the default method
28:04 - the browser performs we'll stop over
28:07 - here and in the next video we'll spin up
28:11 - the postman to quickly test all of our
28:14 - routes because trust me you don't want
28:16 - to go any further without knowing that
28:19 - at least the basic setup works because
28:22 - you can set up whatever logic you have
28:24 - over here
28:25 - if there's a small bug and you cannot
28:27 - access these strings then you'll spend
28:30 - way more time later searching for that
28:32 - bug
28:34 - nice job and once we have the basic
28:36 - structure for all of our routes
28:39 - now let's test them out in a postman so
28:43 - i'm gonna head back to my desktop i'm
28:45 - looking for the postman and since in
28:48 - this case we'll spend way more time over
28:50 - here i also want to cover some
28:52 - configuration options so for starters i
28:55 - want to switch to a dark mode because i
28:57 - think you'll appreciate that more so if
29:00 - you want to do that as well just go to
29:02 - the cog and then you're looking for the
29:04 - settings here
29:06 - and then in the settings just look for
29:08 - themes and of course we have a dark
29:11 - theme as well so that's the first thing
29:14 - that i'm going to do
29:15 - then we want to create a collection
29:17 - now why would you want to do that well
29:20 - since we'll be setting up multiple
29:22 - routes
29:23 - and they'll reference the same
29:24 - application which is going to be easier
29:27 - as we create more and more applications
29:30 - and in order to create that collection
29:32 - we go here and click on creating the
29:35 - collection and for starters i just want
29:38 - to change the name so i'll click on
29:40 - these three dots over here
29:43 - and of course we're looking for rename
29:46 - and then i'm just going to go with 0 3
29:49 - and we'll call this task manager now if
29:52 - you're not happy with this name of
29:53 - course pick your own one and once i have
29:56 - the task manager then we want to start
29:59 - by creating a request
30:02 - so we create a new request it's going to
30:04 - be a get request and instead of typing
30:08 - all the time manually here local
30:11 - and then host and we're going to go with
30:14 - 3000 and then of course api version 1
30:17 - and then tasks what we want to do is set
30:20 - up a global variable
30:22 - now there's multiple ways how we can do
30:24 - that you can actually set up the
30:26 - environment so think of this as a dev
30:30 - environment and then you can have
30:31 - production environment but in our case
30:34 - we'll just set up this localhost and
30:37 - then 3000 api and version 1
30:41 - simply as a variable and you can do it
30:44 - from here as you can see they even give
30:45 - you a suggestion on all that but i'm
30:48 - just going to go the long route where we
30:50 - click here on that eye
30:52 - and then notice i have already won for
30:55 - the url i have localhost 3000 and then i
30:59 - actually changed it later to forward
31:01 - slash api
31:02 - so now what i want to do i want to
31:04 - showcase how we can remove it so if i go
31:06 - over here
31:08 - and if i remove it and i set up a new
31:10 - one in this case again i'll call this
31:12 - url and then as far as this value well
31:15 - i'm just going to take this whole thing
31:17 - so i'm going to go with localhost and
31:19 - then 3000 and of course we're looking
31:22 - for api and if you want you can also
31:24 - include the tasks but in my case i'll
31:27 - stop right after the version one so
31:30 - let's copy that one again i'm setting
31:32 - this up as a global but you can set it
31:35 - up in the environment as well
31:38 - and then
31:40 - once we add that we should be able to
31:42 - right away access it so now of course we
31:44 - just need to save it and then in order
31:47 - to use it
31:48 - we need to go back and you know what
31:50 - i'll remove everything for now and if we
31:52 - go with these double curlies this is
31:55 - going to give us access to those
31:57 - variables and all the way in the bottom
31:59 - we have the url and of course as you can
32:01 - see it is global so in here i'm going to
32:04 - go with url i'll close it and then i'll
32:07 - go with forward slash and then tasks and
32:10 - once i save i should get back get all
32:14 - tasks and of course that means that our
32:17 - basic setup works and before we continue
32:20 - and do the same thing with the rest of
32:22 - the tasks now of course we want to save
32:24 - it and not only want to save it we want
32:26 - to save it in our collection so let's
32:29 - click over here save as and let's give
32:32 - it a more meaningful name and in this
32:35 - case again i'll say
32:37 - get all
32:39 - tasks
32:40 - and of course we're looking for task
32:41 - manager
32:42 - so this is going to be saved in this
32:45 - collection and we simply click on save
32:48 - so if i take a look at my task manager
32:51 - now of course i have get all tasks where
32:53 - we use the global variable and we can
32:56 - successfully see our string and i'll
32:59 - close few of these tabs because it's
33:01 - getting quite busy and let's do the same
33:04 - thing for the rest of them
33:06 - so in this case i'm going to be testing
33:09 - the create one the one for the post
33:11 - that's why we need to change the method
33:14 - that's the first thing you want to do
33:15 - then we'll go with our url again we'll
33:19 - close it out forward slash
33:21 - and then tasks and remember now we want
33:24 - to send some data correct now we're not
33:27 - doing anything with that data on a
33:29 - server but just for the kicks why don't
33:32 - we send it i'm going to go here with
33:34 - body then we're looking for the raw
33:37 - and of course we're not looking for text
33:39 - we're looking for json we just need to
33:42 - make sure that we use the correct syntax
33:45 - and in this case i'll say name and that
33:48 - will be equal to testing
33:50 - and we just click on send and if we can
33:53 - see create task we are in good shape now
33:56 - since i also want to test out whether my
33:58 - middleware is working
34:00 - i'm going to go back to my controllers
34:01 - i'm looking for
34:03 - create task
34:04 - and in here instead of just going with
34:07 - send we're gonna go with json
34:10 - so now i'll be sending back the json
34:13 - and i'll pass in reg.body
34:16 - so if you want of course you can log it
34:19 - on a server but in my case i think it's
34:21 - going to be faster if i just send back
34:23 - whatever
34:24 - i'm getting from the client so if we go
34:27 - back and if we change this around and
34:30 - we'll say here shake
34:32 - and
34:34 - bake and if we add a comma and then
34:37 - completed
34:39 - we set to true once we send
34:42 - that should be our response and of
34:45 - course the only thing that's left to do
34:47 - as far as the create route is go to save
34:49 - as
34:50 - and then we'll say create
34:52 - task
34:54 - save it
34:55 - and now let's continue again i'll close
34:57 - these ones
34:58 - just so it's not that busy and in this
35:01 - case i want to go with get route
35:03 - then we want to go here with the url
35:06 - again
35:07 - and of course we haven't set up the
35:09 - database so there's no real id but we
35:12 - can definitely test it out if we just go
35:14 - with tasks and then whatever gibberish
35:17 - so in this case i'm going to go with
35:20 - hello so that's going to be my id so
35:23 - we're not sending anything as far as
35:25 - data but we are using the params again
35:29 - if we take a look at the routes we can
35:31 - clearly see that we have forward slash
35:33 - and then id
35:34 - that is going to be our param
35:37 - and if we want to test it out where we
35:39 - have get task of course we have the
35:42 - request and the id is sitting in the
35:45 - params so in here i'll do the same thing
35:48 - i'll say json
35:50 - and we'll just say id and that one is
35:53 - equal to rec
35:55 - params and the id so if we save here
35:59 - and then go back and just use the get
36:01 - route and click send we have the key
36:04 - with the name of id and then the value
36:08 - is hello so if we'll change it around
36:11 - and if we'll say peter of course the
36:13 - value will be peter again same spiel we
36:17 - got save as
36:18 - and we'll name this update task or i'm
36:21 - sorry get single task my apologies get
36:25 - single task
36:26 - we'll save it and then we have two more
36:29 - we have one for update and one for
36:32 - remove
36:33 - and in order to speed this up i don't
36:35 - think i'm going to do any testing
36:36 - anymore we simply want to open up a new
36:39 - route we want to go with patch in this
36:41 - case and again we're going with url and
36:45 - then forward slash tasks whatever value
36:48 - you want to pass in over here so i'm
36:50 - going to go with one two three send and
36:53 - of course i have update task beautiful
36:56 - let's save that one
36:58 - and we'll write here
37:00 - update
37:02 - and task
37:03 - and the last one of course
37:05 - is delete so let's close these two
37:08 - and again your request we're looking for
37:11 - delete method
37:13 - the url is going to be exactly the same
37:15 - and then we want to go with forward
37:17 - slash tasks and then any of the ids that
37:20 - we have already used since we'll change
37:22 - that later anyway and once we send the
37:25 - response should be delete task now if
37:28 - you don't want to go with save as you
37:30 - can simply click on command s
37:33 - that's going to be a shortcut and we go
37:35 - here with delete
37:37 - and then task and of course we save it
37:40 - in the same task manager
37:43 - and once we can clearly see that we can
37:45 - access all our routes correctly
37:48 - then we can move on to our next topic
37:51 - okay
37:52 - and once we're done with the postman
37:54 - before we start setting up our database
37:56 - let's quickly talk about our routes more
37:59 - specifically why we use such structure
38:02 - long story short it's because we're
38:04 - building a rest api
38:06 - and since these days the term api is
38:08 - used pretty much for everything let's
38:10 - just all agree that in our case since
38:12 - we're building a server essentially we
38:14 - want to create a http interface so the
38:18 - other apps most likely front-end ones
38:21 - can interact with our data that's how we
38:24 - view api in the scenario
38:26 - and when it comes to rest it stands for
38:29 - representational state transfer and
38:32 - arguably the most popular api design
38:35 - pattern and essentially it's a pattern
38:37 - that combines http verbs route paths and
38:41 - our resources aka data so effectively
38:44 - rest determines how the api looks like
38:47 - now let me emphasize something it's a
38:49 - pattern not a strictly enforced set of
38:53 - rules
38:54 - so nothing stops you from setting your
38:55 - own api
38:57 - in totally different manner in fact if
38:59 - you have used apis on your front-end
39:02 - apps you know that some of them have
39:04 - totally different structure i guess the
39:07 - best advice i can give you is this
39:09 - whatever pattern you decide on stick
39:11 - with it or in other words be consistent
39:14 - otherwise it's just going to be very
39:15 - confusing for your users and this is a
39:18 - common approach where you have the main
39:20 - list
39:21 - so that could be orders that could be
39:24 - customers
39:25 - that could be items whatever and of
39:28 - course in our case it is tasks and in
39:30 - order to get all the items we go with
39:32 - get method and then if we want to create
39:35 - one it's going to be the same endpoint
39:38 - but we just go with different method and
39:41 - of course in this case it is post and
39:44 - not to be redundant we already discussed
39:46 - this before
39:47 - but just because they have the same url
39:50 - the same endpoint since the methods are
39:52 - different in this case we have get and
39:55 - of course in second scenario we have
39:57 - post these are two totally different
40:01 - requests please keep that in mind
40:03 - and then for individual item
40:06 - you have the same path pretty much so
40:08 - you have api and then tasks orders
40:10 - customers or whatever and then you just
40:13 - use the params to point to that one
40:15 - specific item and then if you want to
40:18 - get the item then of course it is a get
40:20 - method for update you'll use put or
40:22 - patch and then to delete one you'll use
40:25 - the delete method instead and since json
40:28 - is a common format for receiving and
40:31 - sending data in rest api we'll use that
40:34 - approach as well so even though at the
40:36 - moment we use send method in our routes
40:39 - eventually we'll switch to json method
40:41 - instead
40:42 - also i'd like to point out that rest in
40:45 - general is somewhat fuzzy
40:47 - in fact oftentimes you'll deviate a
40:50 - weight from straight up rest
40:52 - since that's what the setup will require
40:55 - one more thing you can probably notice
40:57 - something essentially our api allows our
41:00 - user to perform a crot operations on our
41:03 - data and crud stands for create read
41:07 - update and destroy and it's a common
41:10 - approach where the api interface is
41:12 - built around crud since those are
41:14 - usually or typically operations that
41:17 - users or apps want to perform on a given
41:20 - data whether it is again users orders
41:23 - customers or in our case of course it is
41:25 - going to be a task and we'll return to
41:28 - credit a little later when i can
41:30 - actually show you how it relates to our
41:33 - data lastly there's obviously more to
41:36 - rest
41:37 - and some of that we will discuss in
41:39 - later projects
41:40 - but since i'm not a big fan of long
41:42 - slide videos and i believe we covered
41:45 - all the major points we'll stop right
41:47 - here
41:48 - and move on to our database setup if you
41:51 - remember in express tutorial the route
41:53 - setup was extremely similar to that we
41:55 - have right now with one big caveat
41:59 - we used basic array to store some list
42:02 - of items on our server and based on the
42:05 - request we performed some kind of
42:07 - operation on the list
42:09 - and then send back the response and of
42:12 - course that is not very serious approach
42:14 - to store our data and therefore starting
42:17 - with this project we'll set up and
42:19 - connect to a proper database
42:22 - and pretty much for the remainder of the
42:23 - course we'll use nosql or non-relational
42:27 - database by the name of mongodb now i'm
42:31 - not going to dwell on differences
42:33 - between non-relational and relational
42:35 - databases as well as pros and cons for
42:37 - each of them but the major difference is
42:40 - that unlike traditional database where
42:42 - we have rows and columns in mango divi
42:45 - we can simply store everything as json
42:48 - and basically it doesn't care how the
42:50 - data relates to each other instead of
42:52 - tables we have collections which
42:54 - represent group of items and instead of
42:56 - rows we have documents which represent
42:59 - single item
43:01 - and a document is a set of key value
43:04 - pairs and as far as data types we can
43:06 - use strings numbers arrays objects and
43:09 - many more it's very easy to get started
43:12 - and even though you can set it up on
43:14 - your local machine as well we'll right
43:16 - away go for cloud option since that's
43:19 - something you'll probably end up doing
43:20 - anyway we'll use mongodb atlas which is
43:23 - a official option basically it's created
43:26 - by the same people who created mongodb
43:28 - and since they offer generous free tier
43:31 - you'll just have to create an account
43:33 - and you'll be good to go and once we're
43:36 - familiar with mongodb let's set up and
43:38 - configure mongodb atlas so we can host
43:42 - and manage our data in the cloud
43:45 - i have the account already but since i
43:47 - want to cover all the steps in detail
43:50 - i'll set up another dummy account
43:52 - together
43:53 - and remember we can set up the entire
43:54 - thing for free so don't worry your
43:56 - credit card can stay nicely tucked away
43:59 - in your wallet
44:00 - if you get stuck or confused in any of
44:03 - the steps we're about to take here's an
44:05 - awesome resource you can use just google
44:07 - create mongodb atlas
44:10 - and follow this link which actually
44:12 - brings us to official docs
44:15 - and here you'll find a checklist which
44:18 - we're going to use as a roadmap for the
44:20 - following few videos
44:22 - and what is the first thing they want us
44:23 - to do
44:24 - create a new account so let's do this
44:27 - people
44:28 - i'm going to open this up in new tab
44:32 - and then of course you can find bunch of
44:34 - useful info in here yadda yadda you keep
44:36 - on scrolling and i actually want to
44:38 - navigate to a login page and i'm just
44:41 - going to pretend that i don't have the
44:42 - account and we're going to go for sign
44:45 - up and here of course you just need to
44:47 - provide
44:49 - all the necessary info
44:51 - and once you have filled everything out
44:53 - and as i said no don't worry this is not
44:55 - my real phone number then of course just
44:58 - click on sign up and up next they're
45:00 - going to ask for organization
45:02 - and project name
45:04 - and in my case i'm gonna go with node
45:08 - and express
45:10 - course
45:12 - then i'll pick javascript we'll click on
45:15 - continue
45:16 - and we probably can actually skip this
45:19 - but let's just leave it there and up
45:21 - next they want us to set up the cluster
45:24 - now if you take a look at the checklist
45:26 - actually cluster is already second step
45:30 - so let's go back here and
45:32 - pretty much you always want to show for
45:34 - a free one unless of course you want to
45:36 - start paying them so in here we'll just
45:39 - go with create cluster that's going to
45:41 - be the free one then it's using aws okay
45:45 - awesome as far as region i'm going to go
45:47 - with this one
45:48 - then we have cluster tier and additional
45:50 - settings and we'll leave them both as
45:53 - default and lastly i just want to change
45:55 - the name
45:56 - and i think i'm going to go with node
45:58 - express
46:00 - and project and once we're done we just
46:03 - need to click on create cluster
46:06 - and we'll get ourselves a new cluster
46:09 - now as you can see over here they say
46:11 - that it's going to take a little bit of
46:13 - time which is usually the case so i'll
46:16 - stop the video here and i'll see your
46:18 - next one where we'll continue with our
46:21 - steps
46:22 - and once our cluster is ready to go
46:24 - before we start messing around with data
46:27 - so with collections and documents and
46:29 - all that
46:30 - there's a few things that i want to do
46:32 - first
46:32 - and i'm going to start by setting up the
46:34 - database access
46:36 - so effectively in here we'll set who can
46:39 - access our database now i'm not talking
46:42 - about the atlas account
46:44 - no i'm talking about the database and
46:47 - collections we're about to set up
46:50 - and we simply need to click on add new
46:52 - database user
46:54 - and we're gonna go with password
46:57 - and if you get some default values just
46:59 - wipe them clean
47:00 - and i'll simply go with john
47:03 - and as far as the password i'm just
47:04 - gonna go with one two three four please
47:08 - please please do not do that in your own
47:11 - setup the only reason why i'm doing that
47:13 - because you'll be able to see my
47:14 - password anyway and don't worry once i'm
47:17 - done setting up this project of course i
47:20 - will change my password so it's not
47:22 - going to be one two three four and once
47:24 - you're done with the user and password
47:26 - notice we have database user privileges
47:29 - and this user can read and write to any
47:33 - database so i'll leave it the way it is
47:36 - and we'll add a new user
47:38 - that's good i'll close this one
47:41 - and then we want to set up the network
47:43 - access
47:44 - so we want to set up from where we can
47:47 - access our database
47:50 - and you can already imagine that of
47:51 - course once we deploy the project then
47:54 - of course we'll set up that ip address
47:56 - but for time being while we work locally
47:59 - we might as well set up access from
48:02 - anywhere now if you want you can set up
48:05 - your own ip address here so you can just
48:08 - add the current one but in my case i'm
48:10 - going to go allow access from anywhere
48:12 - and i'll just click on confirm and
48:15 - lastly i want to get the connection
48:17 - string
48:17 - that we're going to use once we connect
48:20 - our database to our application and in
48:24 - here what you're looking for is connect
48:27 - so you want to go back to the cluster
48:28 - then connect and then you want to go
48:31 - with connect your application so not the
48:34 - compass one not the shell actually
48:37 - the second one here connect your
48:39 - application
48:40 - and then i'm gonna go with 3.6 or later
48:44 - that's about right and then you just
48:46 - want to copy this one and then navigate
48:48 - back to our project
48:50 - now eventually we'll set it up as the
48:53 - environment variable yes that's going to
48:55 - be the case but for the time being i'll
48:58 - simply create a new folder in the
49:00 - starter and i'll call this db
49:03 - and then instead of the db there's going
49:06 - to be a new file and we'll call this
49:08 - connect gis
49:10 - and then i want to create a new variable
49:12 - and i'll call this connection
49:15 - string and i'll set it equal to that
49:17 - value now we'll have to add some values
49:20 - over here but we'll do that later once
49:23 - we're actually ready to connect our
49:26 - application to the database so just take
49:28 - the string copy and paste set it up in
49:32 - the db and then connect js
49:35 - and now we can start exploring the atlas
49:38 - setup
49:39 - as a quick side note while working in
49:41 - local setup essentially while working on
49:44 - your computer you can use any of these
49:46 - two options so either access from
49:49 - anywhere
49:50 - or our actual ip address
49:53 - but once we go to production
49:55 - more specifically once we deploy our
49:57 - project to heroku
49:59 - you will need to use
50:01 - access from anywhere option otherwise
50:03 - you'll get an error and you won't be
50:06 - able to connect your app to mongodb
50:09 - now this is specific to heroku
50:12 - for example when it comes to
50:14 - digitalocean another popular option for
50:16 - hosting your node apps
50:19 - if you're using your local address while
50:21 - developing once the project is hosted
50:24 - you just swap the ip address from local
50:27 - to production but the way heroku setup
50:30 - works you'll need to go with allow from
50:32 - anywhere option otherwise you'll get an
50:35 - error and once we have set up database
50:37 - access network access
50:39 - as well as the connection string now
50:42 - let's actually explore the data part
50:44 - and we want to click on collections
50:47 - then we're going to go with our own data
50:50 - and then we need to come up with a
50:52 - database name now the first one will be
50:54 - a dummy one and of course once we
50:57 - connect to our application then we'll
51:00 - create a task manager one so the first
51:02 - one i'll just call store
51:05 - and then they ask us to create a
51:07 - collection and don't worry i'll cover
51:09 - what actually our collections and all
51:11 - that but for time being i'm just gonna
51:13 - go with product
51:15 - and then we'll create one
51:17 - and once we have everything in place we
51:20 - are ready to start creating documents so
51:24 - whenever we talk about mongodb
51:27 - we'll have the database so that
51:30 - essentially is going to be that
51:31 - application again in our case eventually
51:34 - this will be the task manager one
51:37 - and then
51:38 - inside of that database we'll have
51:41 - collections
51:42 - now if you're familiar with regular
51:44 - databases you can think of them as
51:47 - tables and in our collections we'll have
51:50 - group of mongodb documents so if i name
51:53 - my one products you can probably already
51:55 - guess that here i'll have list of
51:58 - products and if i'll decide that my
52:00 - store will also have users of course i
52:03 - can go here and create a new collection
52:06 - and as a quick side note we won't have
52:08 - to do this manually i'm just showing you
52:10 - the general setup manually of course
52:12 - eventually all this is going to happen
52:14 - automatically once we connect from our
52:17 - task manager so i have a list of
52:20 - products and then of course i can also
52:23 - create a list of users or list of orders
52:27 - and hopefully you get the gist and once
52:30 - we have our list
52:31 - now let's talk about the individual
52:33 - items so i can go to any of my
52:36 - collections
52:37 - and then once i'm here i can insert a
52:40 - document
52:41 - and document in mongodb effectively
52:45 - represents that one single item and
52:48 - what's really cool that just like
52:49 - javascript object effectively it's a set
52:53 - of key value pairs now by default the
52:55 - moment we create a new document we'll
52:58 - get this underscore id which is going to
53:01 - be that unique id
53:03 - so we don't need to worry about the ids
53:05 - and then of course we need to set up a
53:08 - type so what is going to be the type
53:11 - for our document what is going to be
53:13 - type for the item and if you click over
53:16 - here as you can see these are options we
53:18 - can set it up as an array binary boolean
53:21 - and yada yada and i'm purposely not
53:24 - going to spend too much time on types
53:26 - since eventually we'll set it up from
53:28 - our server anyway
53:29 - and at that point the setup is going to
53:31 - be a bit different
53:33 - since we'll use tool called mongoose now
53:36 - in our case what are we looking for well
53:38 - we're just looking for the string i'm
53:40 - just going to go here with name and then
53:42 - i'll set it equal as first
53:45 - and product so here of course i can
53:48 - insert
53:49 - and now not only i have the product
53:51 - collection but i also have my first item
53:55 - my first document
53:57 - and here comes the biggest gotcha in
53:59 - mongodb documents have a dynamic schema
54:02 - and what that means in plain english is
54:04 - the simple fact that documents in the
54:06 - same collection don't need to have the
54:08 - same set of fields or the structure
54:11 - so if i were to go to insert document
54:14 - and instead of string
54:16 - i'm going to go with array
54:18 - and i'm going to call this colors
54:21 - and then i'll set my first one to be red
54:23 - then second one blue
54:25 - and if i'll save it as far as mongodbe
54:29 - is concerned
54:30 - they're still the same items in this
54:34 - product collection so nothing stops you
54:37 - from doing that now just because you can
54:40 - does not mean you should and therefore
54:42 - we will use additional library by the
54:44 - name of mongoose which will set up that
54:47 - structure for us but as far as straight
54:49 - up mongodb yes both of these documents
54:53 - are still part of this product
54:55 - collection
54:56 - even though their structure might be
54:58 - totally different
55:00 - few videos ago while discussing arrest i
55:03 - mentioned crud
55:04 - create read update and destroy or delete
55:08 - and now i want to quickly show you how
55:10 - is that going to look like
55:12 - with our current
55:14 - manual setup
55:15 - i fully understand that some parts might
55:17 - look really silly especially the read
55:19 - one but in my opinion it's important we
55:22 - start with the basics
55:24 - and hopefully that way we'll have a
55:26 - better understanding of overall
55:28 - principles when we need to implement
55:30 - crud in our rest api
55:33 - so what does crud means in our manual
55:36 - setup well first we want to create an
55:38 - item correct so in here we just find any
55:42 - of the collections and in this case i'm
55:45 - going to stick with products since i
55:47 - already have some items over here and
55:49 - then we simply go with insert document
55:52 - and again we just come up with a type
55:55 - and then some kind of value and my case
55:58 - i think i'm gonna go with another name
56:01 - and i'll just leave it as a string
56:03 - and i'll say test
56:05 - crud
56:07 - i'll insert the document
56:09 - and i'm done
56:10 - so we're done with the first part where
56:12 - we created an item now the second one
56:15 - reading them well we simply stare at the
56:18 - screen and we can see that we have three
56:21 - items so i can see that i have three
56:23 - products again in our application that
56:26 - just means that we'll be able to read
56:28 - the documents that we have in our
56:31 - database when we're working with gui
56:34 - it's very straightforward where you're
56:36 - just staring at the screen then we want
56:38 - to update them
56:39 - and then with the manual approach we
56:41 - just look for this little pencil and we
56:44 - say that we want to change some values
56:45 - around here so in here i could go with
56:48 - another item and i'll say green so now
56:52 - of course i have successfully updated
56:54 - the array as well and you know what
56:57 - let's also add one more and i'll call
56:59 - this
57:00 - orange then i update and i'm done with
57:03 - that part as well so not only we can
57:06 - create read but we can also update and
57:09 - then last one delete well we simply look
57:12 - for another icon in this case we are
57:15 - looking for the trash icon so we just
57:18 - click here and now of course we remove
57:21 - the item so that's the basic approach of
57:24 - crud in our manual setup all right and
57:28 - once our database is ready to go
57:30 - now we need to connect to it from our
57:32 - server and we can definitely use the
57:34 - native mongodb driver and i believe the
57:37 - package name was just that mongodb but a
57:41 - very popular alternative is to use
57:44 - package by the name of mongoose
57:46 - instead which is a object data modeling
57:50 - library
57:51 - and essentially the reason why it's so
57:53 - popular and why we're going to use it in
57:55 - this and rest of our projects is because
57:58 - right out of the box it comes with bunch
58:01 - of goodies that make our development
58:03 - faster now i'm not going to list them in
58:06 - this video since you'll see them in
58:08 - action in all of our projects just let
58:10 - me repeat that yes you can set up your
58:14 - apps with just native mongodb package
58:17 - but the reason mongo's is so popular
58:20 - is because it has extremely
58:22 - straightforward api and it basically
58:24 - does all the heavy lifting for us when
58:26 - it comes to our project i already
58:28 - installed mongoose so we can start using
58:30 - it right away but if you want to use
58:33 - mongoose in your own future project the
58:35 - command is npm install and mongoose and
58:39 - one last thing in this project we're
58:41 - going to be using mongoose version 5
58:43 - something
58:44 - so if by the time you're watching this
58:47 - if they have a higher version pretty
58:49 - much everything starting from six
58:51 - so if you have five point i don't know
58:54 - 14 15 or whatever you'll be still in
58:56 - good shape but if
58:58 - by the time you're watching this they
59:00 - already have version six their api might
59:02 - also be different and at that point you
59:05 - have two options
59:06 - install this particular mongoose version
59:09 - or just use the latest one and utilize
59:12 - their docs as a quick sign note since i
59:14 - recorded the course mongos did come out
59:16 - with new version version number six
59:19 - now the good news is that as far as i
59:21 - checked the only change that affects our
59:24 - project is the lack of deprecation
59:26 - warnings which we're going to cover in
59:28 - the next video rest of them don't really
59:30 - affect us now i still suggest using
59:33 - mongo's version that's already installed
59:35 - in the starrer while working on these
59:37 - projects but as far as i have tested and
59:40 - the current student feedback you'll have
59:42 - no problem implementing the knowledge in
59:44 - your own project with version 6 instead
59:48 - all right
59:49 - and once we're familiar with mongoose
59:51 - let's kick it up a notch and finally
59:53 - start using our database on our server
59:56 - and the first thing we need to do is to
59:58 - set up a connection and at least a basic
60:01 - setup is going to look something like
60:03 - this
60:04 - where we're going to import mongoose and
60:07 - of course we're going to do that in
60:09 - connect.js so i'm looking for db folder
60:12 - and then more specifically for
60:13 - connect.js and then here at the top
60:16 - above the connection string i'm going to
60:18 - go with const mongos that's the name of
60:21 - my instance and then that is equal to
60:23 - require and of course i'm looking for
60:25 - the markers
60:27 - and once i have the instance then the
60:29 - method name is connect so we go here
60:32 - with
60:33 - mongoose.connect and the first thing we
60:35 - want to pass in
60:36 - is the connection string but if you
60:38 - remember
60:39 - i said that we'll have to make some
60:41 - changes take a look so this is going to
60:44 - be my username correct but then what is
60:47 - the value for the password of course
60:49 - that is some dummy value so in here we
60:52 - need to pass in our actual password so
60:55 - in my case of course that is one two
60:57 - three four but i strongly suggest using
61:01 - more secure one for your application
61:04 - and then here at the very end we have my
61:07 - first database
61:09 - so this is what they set up by default
61:11 - and that's going to be the name for the
61:13 - database if i don't change it
61:15 - and you're probably wondering well wait
61:17 - a minute i mean we didn't set this up on
61:20 - the atlas so why it's here you see if
61:23 - it's not going to be there it's going to
61:24 - be created for you
61:26 - so here you have two options either you
61:28 - can just go with this one or in my case
61:31 - i'm going to remove it and again just
61:34 - make sure that you don't remove more
61:36 - than you should so you want to remove
61:38 - everything starting with the forward
61:40 - slash
61:40 - all the way to the question mark and in
61:43 - here of course you need to come up with
61:44 - a name and in my case i'm going to go
61:47 - with the same name as my application
61:50 - so since i have 0.1 for no tutorial and
61:53 - then task manager is 0.3 that's exactly
61:57 - what i'm going to set up over here so
61:59 - i'm going to go with 0.3
62:02 - then hyphen and i think i'm going to go
62:04 - uppercase so i'm going to go with 0.3
62:07 - task
62:08 - and manager again this is going to be
62:10 - the database name and if you haven't
62:12 - created that database already
62:14 - they will create for you and once we add
62:17 - these changes our connection string is
62:19 - ready to go so now we simply need to
62:21 - pass in as a first argument now the
62:25 - second argument is going to be options
62:26 - and effectively
62:28 - this is where we'll pass in some values
62:30 - just to avoid some deprecation warnings
62:33 - and you'll see what i'm talking about in
62:34 - a second but for time being we'll just
62:37 - leave it empty and then this returns a
62:40 - promise so we simply can go with dot
62:42 - then and since i want to see whether i'm
62:44 - successful as far as the connection i'll
62:47 - just pass in the callback function and
62:49 - i'll say log and of course i'll remove
62:52 - the semicolon and i'll say connected
62:55 - connected
62:57 - to the db
62:59 - dot dot and then since there might be an
63:01 - error as well we also want to go with
63:03 - catch
63:04 - and of course we'll just be looking for
63:06 - the error so we have our callback
63:08 - function and i'll say error and we'll
63:11 - simply cancel log the error so we'll say
63:13 - here cancel log
63:15 - and i'm going to be looking for the
63:16 - error and once we save nothing happens
63:19 - and the reason why nothing happens is
63:21 - because we're not executing this
63:23 - function yet
63:24 - but if you remember during tutorial one
63:27 - of the first things that i covered is
63:29 - the fact that if we have a function
63:32 - in a module
63:34 - where the function is effectively
63:37 - executed there and then
63:39 - we only need to import meaning require
63:43 - the module and will right away execute
63:46 - the function so i simply want to
63:48 - navigate to app.js and then this is just
63:50 - temporary because we will change this
63:53 - setup around this one we won't leave it
63:55 - this way i just want to get the
63:57 - connection up and running and therefore
64:00 - i'm just going to go to app.js and then
64:03 - we go with require and notice i'm not
64:05 - assigning this to any kind of variable
64:07 - simply go with require then we look in
64:09 - the db and then more specifically we're
64:12 - looking for the connect and once you
64:14 - save you'll have tons of deprecation
64:18 - warnings and don't worry we'll fix them
64:20 - in a second but all the way in the
64:23 - bottom if everything is correct over
64:25 - here
64:26 - if you pass in the correct password and
64:29 - you grab the correct connection string
64:31 - then you should see connected to the
64:34 - database
64:35 - and if i want to test out the error i'll
64:38 - simply remove the four since i know that
64:40 - that is going to be a wrong password so
64:42 - once i save now of course i'll have this
64:46 - error so i'm just going to keep on
64:47 - scrolling and notice here it's going to
64:49 - say atlas error and of course i already
64:52 - know why because my password is correct
64:55 - and if we'll take a look at our
64:57 - graphical interface in the atlas once we
65:00 - refresh we're not going to see any
65:02 - changes because again we haven't set up
65:05 - any kind of logic so you're looking at
65:07 - it you're like okay i still have one
65:08 - database what's happening don't worry
65:11 - once we start adding the items that
65:13 - database will be created for us in my
65:15 - case 0.3 task manager and even though i
65:20 - will refactor this in the next video
65:22 - because there's some gotchas that i want
65:24 - to talk about before we do that i'll
65:26 - show you how we can remove those
65:28 - deprecation warnings
65:30 - in a console and if you remember we just
65:32 - need to pass in the second argument
65:34 - which is going to be an object and in
65:36 - here we just need to pass in following
65:38 - key value pairs and we'll start with use
65:40 - new
65:41 - url parser and we'll set it equal to
65:44 - true then we'll look for use create
65:47 - index we'll set that one equal to true
65:50 - and then we'll go with use find and
65:53 - modify that one will be false and then
65:56 - lastly we want to go with use
65:58 - unified topology and that one will set
66:01 - equal to true so once i save now i don't
66:05 - have any of those warnings i simply see
66:07 - server is listening on port 3000 and
66:10 - then i have connected to the database
66:13 - and if that is also something that you
66:14 - see in a console you are in good shape
66:17 - and we're ready to move on to the next
66:19 - step nice we have successfully connected
66:22 - to the database
66:23 - and life is great
66:25 - but before we start messing around with
66:27 - the data there's something that's
66:29 - bugging
66:30 - and simply the fact that our server and
66:33 - database connection don't work in sync
66:37 - now what do i mean well let's take a
66:39 - look at the console so first i have
66:41 - console log
66:43 - that our server is listening on port
66:45 - 3000
66:46 - and only then we're connecting to the
66:48 - database
66:50 - but if we think about it
66:52 - what is really a use for our server if
66:56 - we are not connected to the database
66:58 - whatever we're about to do is going to
67:00 - fail anyway
67:02 - so what i'm trying to say is wouldn't it
67:04 - make more sense
67:06 - if we try to connect to the database and
67:09 - only if we're successful
67:11 - then we spin up the server if not well
67:13 - then we'll just kill the application
67:16 - and in order to do that we need to
67:18 - restructure our code a bit where i'm not
67:20 - going to invoke mongoose connect
67:23 - in the connect.js
67:25 - i'll refactor the code and i'll set it
67:28 - up as a function and instead we will
67:31 - invoke it in the app.js
67:34 - and in order to do that we'll just
67:35 - remove this dot then and catch
67:38 - now options of course stay we're not
67:41 - doing anything with that
67:42 - and here let's create a function we'll
67:45 - say connect
67:46 - and db and that is equal to our function
67:50 - so essentially we're setting up the
67:52 - arrow function and eventually we'll set
67:55 - up the env variable and effectively
67:57 - we'll pass it from the app.js and
68:00 - therefore i'll add the parameter here
68:03 - the url for time being we won't use it
68:05 - we'll do the same thing what we did
68:08 - before where we just passed in the
68:10 - connection string that's coming up in
68:12 - next video
68:14 - and then i want to grab this mongoose
68:15 - connect
68:16 - cut it out and then from this connect db
68:20 - i just want to return that result so
68:22 - effectively what we're returning we're
68:24 - turning a promise correct and then all
68:27 - the way at the bottom
68:29 - we're going to go with module
68:31 - and export so now of course we want to
68:32 - export it and where we want to export of
68:34 - course connect
68:36 - and db so once we have this setup then
68:41 - we'll just have server is listening on
68:44 - port 3000 because now of course we want
68:46 - to assign it to some kind of variable
68:48 - and again the order is really up to you
68:51 - but i'm just going to put it below
68:54 - the task so i'll just move it over here
68:57 - below the tasks and i'll say that that
69:00 - is equal to connect db
69:02 - so effectively i'm just getting that
69:04 - function over here and i'll set it equal
69:07 - to the required one
69:09 - and then once i have access to the
69:10 - function then all the way in the bottom
69:13 - i want to set up one more function by
69:16 - the name of start
69:18 - and in this function we will invoke
69:20 - connect db
69:22 - and then only if we're successful
69:24 - then we'll spin up the server so let's
69:26 - go somewhere here in the bottom
69:28 - and we'll say can't start again we'll
69:30 - use the arrow function and since i know
69:32 - that my connectdb returns a promise
69:35 - correct
69:36 - i can set this function as a sync and
69:39 - that way of course we can use the await
69:42 - keyword and every time we have a
69:44 - synchronous operation it's very useful
69:46 - to set it in the try catch block so that
69:49 - way if there is an error we can handle
69:51 - it as well
69:53 - and in try block we'll pass in a wait
69:56 - so since i know that it returns a
69:58 - promise i'll use my await keyword then
70:01 - i'm going to go with connectdb again
70:03 - eventually we'll pass in the string
70:06 - coming from the env file for time being
70:09 - we just have hard coded e and d connect
70:12 - js and then only if we're successful
70:15 - then we'll spin up the server so i'll
70:18 - move this line of code right below the
70:21 - connectdb and again we'll just spin up
70:24 - the server if the connection is
70:26 - successful if not we're gonna go with
70:29 - console.log
70:30 - and then we'll just look for the error
70:33 - so once we save nothing happens we don't
70:35 - spin up the server because of course
70:37 - now we have a function so all the way on
70:40 - the bottom i'm just going to go with
70:42 - start and then you'll notice that
70:45 - there's a console log for the server now
70:48 - of course we don't have the console log
70:50 - for the connection because we removed
70:52 - that in connect js but if you really
70:55 - want to test it out again go back over
70:57 - here
70:58 - and just mess with your password and
71:01 - you'll right away see
71:02 - that we'll get that error in console and
71:06 - in here it says bad auth authentication
71:09 - fail so we know that our setup works so
71:12 - if of course we will have a wrong
71:15 - password then we won't be successful
71:17 - however if everything goes smoothly then
71:20 - we should see that our server is
71:23 - listening on port 3000 not bad not bad
71:27 - we have set up the connection we have
71:29 - refactor code and we're almost almost
71:33 - almost ready to start tinkering with the
71:36 - data but there's one last thing that i
71:39 - want to do first
71:40 - and that is simply setting up the dot
71:43 - env file now why we would want to do
71:45 - that well let's think about it
71:47 - eventually we might push this up to the
71:51 - github correct
71:52 - and what do you think is going to happen
71:54 - the moment i push this up to the getup
71:57 - of course everyone who takes a look at
71:59 - my repo
72:00 - can nicely grab the string
72:03 - and then tamper with my data and how we
72:07 - can avoid that well the solution is to
72:10 - set up dot emv file where we can keep
72:13 - our secret
72:15 - and then in our application we'll have
72:17 - to use a package
72:19 - by the name of dot env and of course i
72:22 - already installed it for you and then
72:24 - we'll be able to access those secret
72:27 - variables anywhere in our application
72:30 - and once we push this up to the github
72:32 - if we add git ignore so dot git ignore
72:36 - file and then in here we specifically
72:38 - say which files we want to ignore and
72:41 - make sure that you add dot env now i
72:44 - also added node modules because that is
72:45 - common practice since that folder is so
72:48 - big but as far as keeping secret secrets
72:52 - make sure
72:53 - that not only you set up dot env
72:56 - and of course use the package because
72:58 - otherwise you won't be able to access
73:00 - the variables but always always always
73:03 - the moment you set up dot env
73:05 - also set up dot git ignore and that way
73:08 - we'll just push this up to the github
73:11 - and then dot env will be ignored so when
73:14 - people come and see your repo they won't
73:17 - see this
73:18 - secret connection string so let's start
73:21 - here by creating dot env and in my case
73:24 - i'm going to do that in the root so i
73:26 - also suggest you do the same so i'm
73:29 - going to go to the starter i'm looking
73:30 - for new file and i'm going to go with
73:33 - dot and then env and in here we have
73:36 - again key value pairs however we don't
73:38 - need to use the quotation marks
73:41 - and i think i'm going to go with
73:43 - and then uri in this case so i'm not
73:46 - going to go with long name the
73:47 - connection string and then you simply
73:50 - want to take this value so cut it out
73:53 - from the connect js
73:55 - go back to dot env
73:57 - set it equal to my uri
74:00 - and then where i have connect js i can
74:03 - simply remove it and then remember
74:06 - when we were setting up the function
74:08 - i said that i'm going to be looking for
74:10 - the parameter but of course initially we
74:12 - were not using it now of course i want
74:14 - to use it so i'll remove the hard-coded
74:17 - connection string and i'll say url and
74:21 - we'll just save now there's going to be
74:23 - an error don't worry because of course
74:25 - we're not passing that connection string
74:28 - notice over here we have the parameter
74:31 - blah blah blah is undefined okay that
74:33 - was expected now what we want to do
74:36 - is go to the app.js since over here we
74:40 - invoke start
74:42 - and then we want to pass in that value
74:45 - from the dot envy into the connect db
74:49 - and in order for us to access those
74:51 - secret variables we simply need to
74:54 - require that package so i'm going to go
74:57 - below connect db
74:58 - and we'll just say require and notice
75:01 - how we don't have to assign it to any
75:03 - kind of variable we just go with dot env
75:06 - and that's the package name and as i
75:08 - said if you want to install you just go
75:09 - with npm install and then the package
75:12 - name
75:13 - dot env pretty self-explanatory and then
75:17 - you want to use process dot env and then
75:21 - whatever is the variable name so let me
75:23 - save my dot env and then back in the
75:26 - app.js once we require we just want to
75:29 - go with dot and config
75:32 - so essentially we just want to invoke
75:34 - the config so now if we keep on
75:36 - scrolling where we have the connect db
75:40 - we want to go with process dot envy and
75:43 - remember that was one of those global
75:45 - variables we go with dot env
75:48 - and then we go or whatever the
75:51 - name for your variable is in my case
75:54 - that is uri and we'll save it and
75:57 - of course we're back in business because
75:59 - i have server is listening on port 3000
76:03 - again very very important
76:05 - if you want to keep your secret
76:07 - variables actually secret set up the dot
76:10 - env
76:11 - get the package and you'll be able to
76:13 - access them anywhere in your application
76:16 - by using
76:17 - process.env and then whatever e is the
76:20 - name of the variable beautiful
76:23 - and once our connection string is a env
76:26 - variable now let's set up the structure
76:28 - for our future documents
76:31 - and assign them to the collection and
76:34 - we're going to do that using schema and
76:37 - model from the mongoose
76:39 - and the way it's going to look like
76:41 - we're going to go to our starter and
76:43 - we'll create yet another folder and in
76:45 - this case we'll call this models and
76:48 - then inside of the models we'll create a
76:51 - new file
76:52 - and we'll call this task.js so i'm going
76:55 - to go here with task.js and then the
76:58 - setup is going to be following where
76:59 - again we import mongoose and we set it
77:02 - equal to require
77:04 - and then mongoose of course
77:06 - and then we're looking for
77:09 - mongoose.schema so we set up a new
77:12 - variable and i'll call this task
77:15 - schema schema and that is equal to new
77:18 - so we're using the constructor and we go
77:21 - with new mongoose and schema
77:24 - and you're probably wondering okay what
77:27 - on earth is happening
77:29 - well if you remember
77:31 - when we were setting up the atlas
77:34 - manually one of the first things that i
77:36 - mentioned
77:37 - is the fact that for our document
77:40 - there is no set structure
77:43 - but that's exactly what i want where for
77:45 - my tasks i only want the name which is
77:48 - going to be a string and a completed
77:51 - property which is going to be a boolean
77:53 - because you would have to agree
77:55 - that it's not going to make much sense
77:57 - if somewhere
77:59 - in my tasks i'll have an array with the
78:02 - color values correct so therefore we go
78:06 - here we go with schema and using
78:08 - schema we'll set up the structure for
78:11 - all the documents that eventually we'll
78:14 - have in our collection and the syntax is
78:16 - following where again we use key value
78:19 - pairs
78:20 - and eventually we'll set them equal to
78:23 - an object and we'll pass in
78:25 - more options but since i just want to
78:28 - get something quickly in our database
78:31 - we'll just start quick and dirty where
78:33 - essentially i want to come up with a key
78:36 - in my case again that is going to be
78:38 - name and completed so those are going to
78:40 - be the two keys and i'll just set up the
78:43 - types so that is a bare minimum where
78:46 - you go with the key name and then the
78:49 - actual schema type so what type of data
78:51 - this is going to be and if you're
78:53 - interested on what options we have just
78:56 - navigate to mongoose official docs and
78:58 - then look for schema types keep on
79:01 - scrolling and then of course you can see
79:03 - string number and yada yada so i'm going
79:06 - to navigate back and i'll say name so
79:09 - that's going to be my first key and i'll
79:11 - just set it equal to string
79:13 - then comma and of course i'm looking for
79:16 - completed
79:17 - completed that is going to be my second
79:19 - key and that will be set equal to
79:22 - boolean again barebones setup will do
79:25 - more complicated a little bit later and
79:27 - then once we have the schema so
79:29 - essentially once we have the structure
79:32 - for the data
79:34 - now we want to set up that model and
79:36 - think of model
79:38 - as a representation for the collection
79:41 - so these guys are sticking in the
79:44 - product so now of course we'll create
79:46 - tasks collection and then all the tasks
79:50 - that we're about to
79:52 - push into our database of course will be
79:55 - added to that specific collection and
79:58 - what's even more cool in mongoose a
80:00 - model is a wrapper for the schema
80:03 - so if the schema defines the structure
80:05 - for the document like the type
80:08 - validations and etc a mongoose model
80:11 - provides an interface to the database so
80:14 - using the model will be able to create
80:17 - update query and delete our documents
80:20 - with great ease since the api is
80:22 - extremely extremely straightforward and
80:25 - you'll see what i mean in the upcoming
80:27 - videos
80:28 - and we do that by creating a model and
80:31 - we right away export so go with module
80:34 - dot exports and that is equal to mongos
80:38 - then model
80:40 - and then model is looking for two things
80:42 - it is looking for the name
80:44 - and then we want to pass in the schema
80:46 - so in here i'm going to go with task and
80:49 - then comma and of course this is the
80:51 - schema that i want to pass in so say
80:53 - here task schema and once we're done
80:56 - with this the only thing we need to do
80:59 - is go to our controllers
81:02 - and start using our model
81:04 - beautiful
81:05 - we have set up our first schema as well
81:08 - as the model
81:10 - and of course we want to start using it
81:12 - and yes we will use it in controllers
81:15 - therefore we'll navigate there and i'm
81:17 - going to be looking for my model and
81:19 - i'll assign it to the task variable i'll
81:22 - say require i'm looking
81:24 - in the models folder and then more
81:26 - specifically task and then before we
81:29 - continue let me just give you a brief
81:32 - overview of what we're about to do so if
81:36 - we navigate back to mongoose docs and
81:39 - more specifically if you're looking for
81:41 - the models we can find here more info
81:44 - you can see that models are fancy
81:45 - constructors compiled from schema
81:47 - definitions
81:48 - an instance of a model
81:51 - is called a document
81:54 - and then they give you this example
81:56 - pretty much
81:57 - everything that we did in last video
81:59 - apart from the fact that of course they
82:01 - have different values
82:02 - and here we have nice explanation that
82:04 - the first argument is singular name of
82:08 - the collection your model is for since
82:11 - mongoose automatically looks for the
82:13 - plural lowercase version of your model
82:17 - name
82:18 - so effectively eventually we'll have the
82:21 - tasks
82:22 - then i mentioned one more time that the
82:24 - instance of the model is called document
82:27 - and there are few ways how we can create
82:29 - one we can go this route
82:32 - or we can use dot create
82:35 - and here they showcase the callback
82:38 - function approach but we can also use a
82:41 - weight
82:42 - and essentially what create is looking
82:44 - for well it's looking for the object
82:47 - with those properties so in our case we
82:49 - have name
82:50 - as well as the completed correct and of
82:53 - course we can pass this manually but
82:56 - wouldn't it make more sense if we just
82:58 - go to create task route
83:00 - and since we know that in there we can
83:02 - access the task data in the request.body
83:06 - why don't we just pipe it through and
83:09 - pass it along to our model create method
83:12 - and it's going to work something like
83:13 - this
83:14 - where i'll grab the body of course it's
83:16 - going to be coming from my postman here
83:19 - shake and break and the value will be
83:21 - true and then instead of sending it back
83:25 - we'll pass it into task dot create now
83:29 - since i'm going to be using a weight on
83:31 - a task dot create of course i want to
83:34 - refactor this and i'll say that this
83:37 - function the create task actually is
83:39 - going to be async so my controller will
83:42 - be async
83:43 - and then instead of the function body
83:45 - i'm going to go with task and i'll set
83:48 - it equal to a weight like i said i'm not
83:50 - gonna use the callback function approach
83:52 - i'll use a weight instead and we'll
83:55 - await for task
83:56 - dot create and like i said if you want
83:59 - you can hard code this here you can say
84:01 - name and then first
84:04 - task and of course we can do the same
84:06 - thing for completed
84:08 - but i already covered why it's going to
84:10 - make way more sense if we just take this
84:13 - rec dot body so whatever we're getting
84:15 - from the postman and then let's just
84:18 - pass that object into task.create and
84:22 - let's see what happens so i'll remove it
84:24 - here
84:25 - and i'll just say
84:27 - rec dot body
84:29 - over here and as far as the response
84:32 - well now i'm just waiting for a task so
84:34 - instead of wrecked that body in response
84:37 - i'll place my task and i also want to
84:40 - add the status and if you remember the
84:42 - correct status was 201 effectively that
84:46 - is if you have a successful post request
84:50 - and then instead of json being equal to
84:53 - rec.body we'll pass in the object and in
84:57 - here we'll pass in our task and then
85:00 - once we save again nothing happens
85:02 - because we haven't triggered the post
85:04 - request
85:04 - but
85:05 - if we go back to the postman and if i
85:09 - click here send what i should see
85:13 - is this i should see the task so that's
85:16 - my object and now check it out we have
85:19 - this underscore id and what that means
85:22 - well that means that we created a new
85:24 - document with the following properties
85:27 - we have name we have completed we of
85:30 - course have the id like i just mentioned
85:33 - and we also have this underscore
85:35 - underscore v so of course these two are
85:38 - created by default every time we create
85:41 - the document and then these ones we
85:44 - provide
85:45 - so if you want to keep on testing we're
85:48 - gonna go with second task
85:50 - and
85:51 - we'll set maybe the completed to false
85:54 - again this is all quick and dirty just
85:56 - because i want to have some data in my
85:59 - database there will be still some
86:01 - modifications to the code
86:03 - but if we can see the successful
86:05 - responses
86:07 - where we have tasks with underscore id
86:10 - what that also means my friends
86:12 - is that when we go to our database and
86:15 - if i refresh
86:18 - check it out now of course i have the
86:20 - task manager like i said that's my
86:23 - database and what do you know
86:26 - of course i have the tasks collection
86:28 - now what do i have in task collection i
86:30 - have documents what documents
86:33 - shake and bake
86:34 - and second task and if you have the same
86:37 - result congrats we're off to the great
86:40 - start
86:41 - nice at this point we can successfully
86:42 - create new tasks
86:44 - and persist them in our cloud database
86:47 - so now it's really just about applying
86:49 - the same concepts to the rest of our
86:52 - routes but before we set up the rest of
86:54 - the four controllers in a similar
86:57 - fashion there are a few important things
86:59 - that i want to cover first
87:00 - for starters i just want to showcase
87:02 - that since we set up our schema
87:05 - only the properties that we specified in
87:08 - our schema will be passed on to the
87:11 - database
87:12 - and everything else is going to be
87:14 - ignored
87:15 - don't believe me let's try it out first
87:18 - i just want to showcase that in our
87:19 - schema we specified two properties name
87:23 - and completed so now if i go back to the
87:27 - postman
87:28 - and i'll just set up testing schema
87:31 - that's going to be my name
87:33 - testing schema i'll leave completed as
87:36 - false but if i try to add some
87:39 - properties
87:41 - that are not on my schema effectively
87:43 - they will be just ignored so my guys i'm
87:45 - just gonna say
87:46 - random is equal
87:48 - to random now i do still need to use the
87:51 - proper jsons index and then i'll just
87:54 - add the amount and i'll set it equal to
87:57 - five
87:58 - now you can add 10 000 properties and
88:00 - again the result is going to be exactly
88:02 - the same so i'll just leave these two
88:05 - and we'll try to send it so here i send
88:09 - and then check it out
88:10 - now what i get back is only the name and
88:13 - only the completed again let me repeat
88:16 - only the properties that you set in your
88:19 - schema
88:20 - will be passed on to the database
88:22 - everything else will be ignored which of
88:25 - course is really really cool because
88:27 - that way we can avoid this mess
88:30 - where if you remember back in the store
88:32 - when i was setting up the products one
88:34 - has name the other one has the colors
88:37 - because there is no structure for these
88:40 - documents
88:41 - when we use schema there is a structure
88:45 - so whatever we set up in a schema
88:48 - is going to be passed on to this
88:50 - database and whatever comes as an extra
88:54 - is just going to be ignored all right
88:56 - and once we've got that out of the way
88:58 - next i want to talk about validation
89:01 - you see even though we only accept the
89:03 - properties that are specified in the
89:06 - schema
89:07 - our current setup has one big doozy
89:10 - there is no validation so essentially we
89:14 - can pass in empty values how is that
89:17 - gonna look like well again we can go
89:19 - back to the postman
89:21 - and in first example i'll just remove
89:24 - completed
89:25 - and i'll pass in the name
89:28 - as an empty string now i do need to fix
89:30 - this comma here
89:32 - but you'll see that actually we're
89:34 - successful
89:35 - so i can create item this way
89:38 - and what's even more interesting
89:41 - is that i can send an empty object and
89:44 - i'll still be successful
89:46 - and you have to agree that
89:47 - actually this is not the best setup
89:49 - correct so that way we can just set up a
89:52 - bunch of empty items now what can we do
89:55 - about it well we can add the validation
89:59 - to our schema now before we continue
90:01 - though let me just say that when it
90:03 - comes to validation since it's a pretty
90:06 - big topic we'll just be scratching the
90:08 - surface the plan is to show you more
90:11 - features as we progress with the
90:13 - upcoming projects since i have a feeling
90:16 - that if we'll spend the next hour or two
90:19 - on just validation
90:21 - understandably a lot of you will lose
90:23 - interest and attention don't worry
90:25 - though the end of the video i will show
90:27 - you where you can get more info so at
90:30 - the moment we have a very minimal setup
90:33 - where we have properties
90:35 - and we just specify the type
90:37 - however
90:38 - we can set up our properties as objects
90:42 - and then we can also set up built-in
90:45 - validators how is that going to look
90:47 - like well
90:48 - i'll remove the string part from the
90:50 - name and then i'll set it equal to an
90:52 - object i'll add a comma of course since
90:54 - i need to keep the proper syntax and
90:57 - here the first property we want to set
90:59 - up is type now it's still going to be a
91:01 - string but now of course we can add more
91:04 - validators now what validators can we
91:07 - use for starters we can go with required
91:11 - so what this is going to do
91:13 - is if i pass in the value the object
91:17 - without my name property then it's going
91:20 - to spit back big fat error now at the
91:23 - very basic level you can set up equal to
91:26 - true or false either it is required or
91:28 - not but if you want a custom message you
91:32 - can actually set it equal to an array
91:34 - where you go with the first value again
91:36 - true or false
91:37 - and then you add a comma and then you
91:39 - pass in that custom message and in my
91:41 - case i'm going to go with must provide
91:44 - and name
91:45 - now what else i can do well i can trim
91:48 - to imagine the scenario in a postman if
91:51 - i go here with name
91:52 - and if i pass in here spaces and then
91:56 - john effectively with our current setup
91:59 - that's exactly how we'll save it in our
92:01 - database
92:02 - and if i don't want that i can simply go
92:04 - back where we have the object and then
92:06 - the property that you're looking for is
92:09 - trim
92:10 - and we'll set it equal to true
92:12 - and what's also really nifty that for
92:14 - strings we can get min values or max
92:17 - values and in my case since i don't want
92:20 - my value to be bigger than 20 characters
92:23 - for the name one i can go with max
92:26 - and property that we're looking for is
92:29 - length make sure that you spelled
92:31 - correctly this is always a doozy for me
92:34 - when it comes to length and again we'll
92:36 - set it equal to an array and i'll say
92:39 - that the value for my string is going to
92:41 - be 20 and then in here we'll just go
92:43 - with name
92:45 - cannot
92:46 - be more
92:48 - than
92:49 - and of course we'll set it equal to 20
92:52 - and nine characters and essentially
92:54 - we're done with basic validators for
92:57 - name because like i already mentioned i
92:59 - really just want to scratch the surface
93:01 - so you get the main idea and then as
93:05 - we're progressing with the project then
93:07 - of course we'll implement more features
93:09 - and i want to do the same thing for
93:11 - completed where i'm not going to go with
93:13 - required hopefully this is clear and
93:16 - you'll see in a second what kind of
93:17 - error we have if we don't pass the name
93:21 - but for the completed i just want to
93:22 - show you that we can also set some
93:24 - default values and again we want to
93:27 - remove this boolean and we're going to
93:29 - go type we'll set it equal to
93:32 - boolean
93:33 - and then as far as the default value the
93:35 - property is simply default and as far as
93:38 - default in this case
93:40 - for the task property completed i think
93:42 - it's going to make most sense
93:44 - if we'll set it equal to false
93:46 - again just to showcase how is that going
93:48 - to look like
93:49 - in a real project so as i'm adding the
93:52 - task
93:53 - new
93:54 - task
93:55 - by default it's not going to be
93:57 - completed and only when we navigate to a
94:00 - specific task page and i say yep it's
94:03 - completed now we can add it and then of
94:05 - course we can navigate back to all the
94:07 - tasks this was just my setup of course
94:10 - there's a million different ways how you
94:11 - can do that but that's why in here
94:14 - when i'm setting up my validators i set
94:17 - my completed one to be equal to false so
94:20 - now of course we can save it
94:22 - and we can test it out so i'm going to
94:25 - navigate back to my setup here in a
94:28 - postman and as you can see completed is
94:31 - still not required
94:33 - and that is done on purpose so
94:34 - essentially i already set this up as
94:36 - default false so i don't want to set it
94:39 - up as required therefore we don't need
94:41 - to pass it here but i just want to see
94:44 - how it nicely is going to trim
94:46 - and how we also will get errors
94:49 - if we don't pass in any values so in
94:52 - here let me just try with the john and
94:54 - notice once we send we actually get
94:57 - trimmed value back and completed is set
95:00 - to false
95:01 - right away okay
95:03 - that's an awesome start but notice what
95:05 - happens if we send an empty string
95:07 - so let me remove all the values let me
95:10 - click on send
95:12 - and now check it out so we have here
95:14 - this sending request and the reason why
95:18 - we're not getting anything back because
95:20 - we have big fat error in our console we
95:24 - have validation error and there's few
95:26 - things that we need to understand about
95:28 - this error
95:29 - first it is caused in a task schema
95:32 - because we finally set up the valve
95:34 - there and we set it equal to true and of
95:37 - course we're sending empty string so
95:40 - that's the same thing as if i were to
95:43 - send completely empty object over here
95:46 - so if i cancel it and if i send it again
95:49 - notice again we're not getting the
95:51 - response that's point number one number
95:53 - two
95:54 - if you take a look at the console you
95:57 - see that we have this unhandled promise
96:00 - rejection
96:01 - and this error is originated blah blah
96:03 - blah blah and long story short it is
96:07 - caused in our create task because we
96:10 - have a weight keyword however we're not
96:12 - handling this gracefully we don't have
96:15 - the try catch block where we set up the
96:18 - await in the try and if there's an error
96:21 - then of course we do something about it
96:24 - and since this video is already getting
96:25 - quite long i'll actually do that in the
96:28 - next one
96:29 - so just put this one on ice and then in
96:32 - next video we'll set up a proper
96:34 - response and just to recap as far as
96:37 - basic validation we just need to set our
96:40 - property equal to an object then we need
96:43 - to set up still the type and in our case
96:46 - that was the string and then we can go
96:48 - with the required
96:49 - if we want to have a custom message then
96:51 - we just set it equal to an array
96:54 - and the first item is going to be the
96:56 - value whether that's true or false for
96:58 - required and then the second one will be
97:00 - the custom message
97:02 - then for the string we can also use trim
97:05 - and that's just going to make sure that
97:06 - we don't have any white space and you
97:08 - can probably already guess that there's
97:10 - one for the min length as well
97:13 - and in a completed one we covered how we
97:15 - can add a default value as well so for
97:19 - this one we set it equal to false and if
97:22 - one of our validations is going to fail
97:25 - then of course we won't be successful of
97:27 - adding that item
97:29 - and like promised if you want to learn
97:32 - more about validation just head on over
97:34 - to mongoose docs
97:37 - so navigate here and then you're looking
97:39 - for the validation
97:41 - and as you can see there's quite a bit
97:44 - of info here so if your idea of good
97:47 - time is scouring through the docks you
97:49 - won't be disappointed
97:51 - not bad not bad i think we have good
97:54 - general understanding of the basic
97:56 - validation
97:57 - in mongoose
97:59 - so now let's switch gears and talk about
98:02 - how we can handle it more gracefully
98:04 - because at the moment well we're just
98:07 - leaving our user hanging correct
98:09 - so if the user
98:11 - sends some kind of request with
98:14 - incorrect data then of course we have
98:17 - the error here on the server but as you
98:19 - can see the user is just hanging and
98:23 - probably it's not the best approach and
98:25 - again the whole reason for that is
98:27 - because we have a synchronous operation
98:30 - however we're not handling if there is
98:34 - an error and the fix is following where
98:36 - we want to go with try catch and then we
98:39 - want to place our await
98:41 - in the try block and also right away set
98:45 - up my response so if we are successful i
98:49 - still want to send back the response
98:51 - with our task document the one that
98:54 - we're getting back
98:55 - from the model
98:57 - and then the second thing if there is an
99:00 - error what do we do well we could also
99:03 - send back the response and in this case
99:05 - the status is going to be 500 and
99:08 - effectively that is just a general
99:10 - server error and as i said i'm purposely
99:13 - using just a general server error status
99:16 - code the 500 one since we'll discuss
99:19 - errors in greater detail later in the
99:22 - project
99:23 - and then we can go with json and i'll
99:25 - set up the message property and i'll set
99:28 - it equal to my error so now if we save
99:32 - and if i go back
99:34 - and if i send one more time you'll
99:37 - notice that instead of hanging we
99:40 - actually get a response and in here i
99:42 - can see that the status is 500 so it's
99:45 - definitely our response
99:47 - and at this point in time you probably
99:49 - have two questions
99:51 - first
99:52 - do we really need to wrap all our logic
99:56 - in every controller in trying catch
99:59 - since i can give you a hint that in the
100:01 - remaining controllers we'll also use the
100:04 - functions
100:05 - and we'll stick a weight in front of
100:07 - them and the short answer is yes
100:10 - for timing we'll have to do that but
100:12 - then eventually by the end of the
100:14 - project i'll show you multiple ways how
100:17 - we can simplify that
100:18 - and how we can omit this boilerplate
100:21 - code for try and catch then your next
100:24 - question probably is okay
100:26 - we get the response
100:28 - but this error
100:30 - seems a bit lengthy can we make it
100:32 - shorter and my answer again is yes we
100:35 - can
100:36 - and the most basic approach is going to
100:38 - look something like this
100:40 - instead of setting message property
100:42 - equal to another parameter
100:44 - just simply set it equal to generic
100:46 - there was another string value as far as
100:49 - more complex setup i'll discuss it at
100:51 - the end of the project since i want to
100:54 - keep moving along with the rest of the
100:55 - functionality as far as my setup i will
100:58 - keep sending this giant object since
101:00 - that way i can show exact error messages
101:03 - we're getting and as far as our api i
101:05 - think we're actually in pretty good
101:07 - shape where we can create a task we do
101:10 - have some basic validations and if there
101:13 - is any kind of error well we simply send
101:16 - back 500 that there is a server error
101:19 - and we send back error message yes quite
101:22 - long one but at least it's better than
101:25 - leaving the user hanging
101:27 - and if we want to try out the max length
101:30 - and simply go here with name
101:33 - and then i'll just add some gibberish
101:35 - just so it's more than 20 characters so
101:38 - let me type it out here and then once i
101:40 - save again we get the error message
101:43 - where we have name cannot be more than
101:46 - 20 characters
101:48 - that should do it for this video and now
101:50 - we're ready to move on to our next topic
101:52 - and once we're done discussing the
101:55 - validation
101:56 - as well as the need for try and catch
101:59 - since we have a synchronous operation
102:01 - why don't we continue with our
102:03 - controllers
102:04 - and up next i want to work on
102:07 - get
102:07 - all tasks
102:09 - so we know already how we can create a
102:11 - task we know that we have a model in the
102:14 - model we pass in the schema and then in
102:17 - order to get the instance we go with the
102:19 - name of the model and of course the
102:21 - method name is dot create now what about
102:25 - rest of the correct operations and again
102:28 - we'll use our best helper the mongoose
102:31 - docs and if we navigate there and then
102:34 - if we look for queries
102:36 - then we can have this nice text where it
102:39 - says mongoose models provide several
102:42 - static helper functions
102:44 - four
102:44 - and this should be already familiar
102:47 - crud crowd operations and each of these
102:50 - functions returns a mongoose query
102:52 - object
102:53 - now we'll work with query object way
102:56 - more in the next project but for time
103:00 - being we just need to understand that
103:02 - on every model
103:04 - we have these methods that we can use
103:07 - starting with delete menu all the way to
103:10 - update one and the one that we want to
103:12 - use right now is this one the find one
103:15 - and i'll just open this up in a separate
103:17 - tab and then we can see that as far as
103:20 - the parameter we want to pass in the
103:22 - filter object now what does that mean
103:25 - well it means that if i'll leave this
103:27 - filter object empty this is just going
103:30 - to get me
103:31 - all the documents
103:32 - so in our case this is just going to get
103:34 - us all the tasks now if we start
103:37 - supplying the values for example in our
103:40 - case we could say completed equal to
103:42 - true of course that is going to get us
103:44 - what that is going to get us only the
103:46 - documents that are completed
103:49 - again the way i've set up the projects
103:51 - of the next project the second project
103:53 - is the one where we'll take a deep dive
103:56 - into the filtering sorting and all that
103:59 - for time being we just need to
104:00 - understand that if we want to get all
104:03 - the documents which is going to be in
104:04 - our case for the get all tasks
104:07 - controller we simply need to use find
104:10 - now it's also really interesting
104:13 - is the fact that if we go back and if we
104:16 - keep on scrolling
104:18 - we can read that a query also has dot
104:21 - then function
104:23 - and thus can be used a promise
104:25 - now there is a caveat where technically
104:29 - it's not returning a promise that's why
104:31 - i say here
104:32 - used as a promise and essentially what
104:35 - that means for us is that yes we can use
104:38 - a weight so for simplicity we can stick
104:42 - a weight in front of it and we'll be in
104:45 - good shape however if you keep on
104:46 - scrolling you'll read that queries are
104:49 - not promises and there are situations
104:52 - where it's really important but if we
104:54 - keep on reading here they have that then
104:56 - function
104:57 - for async await as a convenience so long
105:01 - story short similarly to how we created
105:04 - task with a weight and we set up try and
105:07 - catch block we'll do it here as well
105:11 - and the way we'll do that we'll go with
105:13 - try catch
105:14 - so in here of course there's going to be
105:16 - an error but if we're successful then of
105:19 - course we'll just send back all the
105:21 - tasks so let's start here with const and
105:24 - i'll set it equal to the tasks and the
105:27 - value will be equal to a weight so use a
105:30 - weight keyword therefore in front of the
105:32 - function i want to set up my sync and
105:35 - then i want to go with task so that's
105:36 - going to be the name of the model and
105:39 - then the static function name is fine
105:42 - and since i want to get all the
105:43 - documents in the task collection
105:46 - therefore i'll just stick here a empty
105:50 - object and then as far as the error well
105:52 - in order to speed this up i'll just copy
105:54 - the error
105:55 - from the create task and pass it here as
105:59 - well and now the only thing is missing
106:02 - is our response if we're successful what
106:05 - do we want to do well we want to go with
106:07 - res dot and then we're looking for the
106:10 - status in this case the status is going
106:12 - to be 200
106:14 - and then json and in here i'll just say
106:17 - tasks so i'll be sending back the object
106:20 - and then instead of that object there's
106:21 - a property by the name of tasks
106:24 - and as far as the value it's going to be
106:26 - equal to whatever i'm getting back from
106:29 - the find and i'm just using the es6
106:31 - shorthand where if the property name
106:34 - is exactly the same as the variable for
106:37 - the value well we can omit the second
106:39 - part
106:40 - and effectively it's the same as if i
106:44 - were to write like this so we have tasks
106:46 - equal to tasks and then with es6 we can
106:49 - just shorten this up
106:51 - and once we save
106:53 - and if we go back to the postman
106:56 - and you know let me fix this one
106:58 - i'll say here properly i'll say testing
107:03 - testing task
107:05 - because i want to save that create one
107:08 - so i'll save it here so it stays as our
107:10 - request and i'll close it and then if we
107:13 - go to all the tasks
107:15 - and we simply hit send
107:18 - now what we should see
107:19 - is of course our object and check it out
107:22 - now we have all the tasks so we have our
107:26 - array and then inside of that array we
107:29 - have items of course each item is
107:32 - represented as an object so successfully
107:35 - we have set up the second route as well
107:38 - for all the tasks and here we use the
107:41 - find static function and we pass in the
107:44 - empty object which just gets us all the
107:46 - documents in the collection and in our
107:49 - case of course those are our tasks and
107:52 - then if we're successful if there was no
107:55 - error we just go with res dot status so
107:57 - we set up the status for response and we
108:00 - send back a json and i just jam all my
108:03 - tasks inside of the object and set it
108:05 - equal to the tasks property awesome and
108:09 - once we have set up the controllers for
108:12 - create task and get all tasks
108:15 - next i want to work on get task
108:18 - and effectively in our application
108:21 - that route provides info about specific
108:24 - tasks
108:25 - so in here
108:26 - i can see all the tasks i can create one
108:28 - of course
108:29 - but if i want to edit it i'm going to
108:31 - click on edit button and then notice how
108:34 - i'm getting the info about this specific
108:37 - task of course normally you wouldn't
108:39 - share the id but in this case i just
108:41 - wanted to provide more info so not just
108:43 - the name but also an id so that way you
108:46 - can clearly see that this info is just
108:49 - about this task and similarly i can go
108:52 - to the next one and again i'll get the
108:55 - id i'll get the name and whether it's
108:57 - completed or not now in this video of
109:00 - course we won't set up the edit but at
109:03 - least we'll get that specific info and
109:06 - general the setup is going to be pretty
109:08 - similar to the one we have with get all
109:10 - tasks
109:11 - however
109:13 - we'll also have to implement a specific
109:15 - response
109:17 - if
109:18 - the id that we pass in doesn't match any
109:21 - of the tasks that we currently have
109:24 - and in order to get up and running we'll
109:26 - navigate back to the docs to the
109:28 - mongoose docs and in this case we're
109:31 - looking for the find one static helper
109:34 - function just like we used find in this
109:37 - case we're looking for find one
109:39 - open up new browser window and then
109:42 - notice as far as the parameters we go
109:44 - with conditions so we pass in conditions
109:47 - object and
109:49 - they're very helpful here where they say
109:52 - find one adventure whose country is
109:54 - croatia otherwise no so essentially we
109:57 - use a weight just for convenience we
110:00 - have our model then we have find one and
110:03 - then we pass in the object
110:05 - and in that object we set up what well
110:08 - we set up the condition
110:10 - and in this case they look for the
110:12 - country in our case of course
110:14 - we will look for a task and we'll use
110:16 - the id
110:18 - so i'll say
110:19 - get me the task whose id
110:21 - is equal to whatever i'm getting from
110:24 - the params otherwise we'll get back now
110:27 - so let's now get back i'm looking for
110:29 - get task and remember in here of course
110:32 - i'm getting that params id
110:35 - and before we type anything here in the
110:37 - controller
110:38 - i just want to set it correctly my id
110:41 - because of course
110:42 - initially well i was just passing here
110:45 - repeater but of course that's not the
110:47 - case anymore and since i want to use the
110:49 - id that i'm getting back from the mongol
110:51 - i'm gonna go to all the tasks i'll run
110:54 - it of course i get my list awesome and
110:57 - then pick any of the tasks doesn't
110:59 - really matter which one just look for
111:01 - the id
111:02 - copy this one and then go back to the
111:05 - single task and then of course instead
111:07 - of peter
111:08 - pass in the eddy and send and if you get
111:11 - back the id key with this value with
111:15 - that long string value which is an id
111:18 - then of course we're in good shape and
111:20 - i'm doing this just so we don't have the
111:22 - console log here on the server you can
111:24 - definitely do so but i just think that
111:27 - it's more convenient for us to see those
111:29 - logs here in a postman and then once we
111:33 - have everything in a place i want to go
111:35 - with my get task
111:37 - and here what's the logic well we could
111:40 - start by setting up i sync of course
111:42 - because we'll use the await then we'll
111:45 - go with our try catch block and then
111:48 - i'll move this sucker up and then first
111:51 - we just want to get that id out of the
111:54 - params so of course you can write it the
111:56 - long way but i always like to do the
111:58 - structuring first so we'll go here with
112:01 - const id
112:02 - and then i always prefer giving it
112:04 - somewhat useful alias otherwise you just
112:07 - end up with bunch of ids and then once
112:10 - in a while it's just confusing which id
112:12 - is for what so i'll say grab me the id
112:16 - which is coming from the params but use
112:18 - the alias of task id from now on and
112:21 - then i set it equal of course to rec dot
112:24 - params
112:25 - so it's the same object that i'm getting
112:28 - and then of course we want to use that
112:29 - fine one correct
112:31 - so we're going to go with const this is
112:33 - going to be our document that we're
112:35 - getting back if we're successful
112:37 - and we'll go with await and then task
112:41 - and then find
112:42 - find one and then like i said we pass in
112:45 - the object and in this case i'm going to
112:47 - be looking for underscore id
112:49 - so not the name but underscore id which
112:52 - matches to that in the params so use
112:55 - here task
112:57 - and then id
112:58 - and if i'm successful beautiful we'll
113:02 - send back the task
113:04 - if not then we'll have to send back the
113:07 - 404 response so here we'll go with res
113:10 - dot and we're looking for status so say
113:13 - that everything is correct we were
113:16 - successful and therefore we'll go with
113:18 - res dot status 200 then dot json and
113:22 - then i just want to pass in a task i'll
113:24 - say yep that's the task you're looking
113:26 - for now there also might be a case where
113:29 - there's something wrong with an id
113:31 - where essentially yes we're getting the
113:34 - value from the params but it doesn't
113:37 - match any of the tasks and if you
113:38 - remember documentation
113:40 - then we get null
113:42 - so what is the case then well then i
113:44 - want to check if the task actually is
113:47 - null and then of course i want to send
113:49 - back different response now make sure
113:52 - make sure make sure that you always
113:54 - always always set up here return
113:57 - otherwise what's going to happen well
113:59 - javascript is going to be reading the
114:01 - code and if you don't have the return
114:03 - even though there might be no task well
114:06 - you'll send one response and then you'll
114:08 - send the next one right after that so
114:10 - always always make sure that you have
114:12 - return so that way javascript knows okay
114:14 - so now i just need to return from the
114:16 - function and in here we go with
114:18 - res.status now in this case though of
114:20 - course task that we're looking for
114:22 - doesn't exist
114:24 - and the status code for that is 404
114:27 - and then again we go with json here and
114:30 - we'll pass in the message in the object
114:33 - and the message we'll be following we'll
114:35 - say no task with id
114:38 - and then colon and then we'll just look
114:40 - for task
114:42 - and then id
114:44 - and eventually of course we also might
114:46 - have the error
114:48 - and i'll talk about these two errors in
114:50 - the next video because that's going to
114:52 - be a common theme that will set up for
114:55 - the upcoming rounds and i kind of want
114:57 - to give it a separate video
115:00 - so in here
115:01 - let's just scroll up
115:03 - and let's just look for that generic one
115:05 - the arrest that status 500 and then
115:08 - we'll just pass in the error
115:10 - copy this one
115:11 - and then scroll down
115:13 - and below where we have the catch of
115:15 - course pass it in so if i go back right
115:18 - now to my postman and if i click on send
115:22 - i should
115:23 - get shaken big because of course that is
115:27 - the id now if you don't believe me we
115:28 - can go back to all the tasks let's keep
115:31 - on scrolling and then i think i'm going
115:33 - to be looking for this testing schema
115:36 - because some of them are actually empty
115:39 - when we were testing out that's when we
115:40 - were setting them up so now grab this id
115:43 - instead
115:44 - go back to single task
115:46 - and then copy and paste and of course
115:49 - now the value is going to be testing
115:52 - schema and like i mentioned previously
115:54 - i'll talk about errors why we have two
115:57 - of them essentially why we have two
115:59 - responses for the errors in the next
116:02 - video but that's how we can set up a
116:04 - route to get a single item
116:06 - so we go again with try catch we set up
116:09 - async and then we use the static
116:11 - function find one and then of course in
116:14 - this case we're looking for the id
116:17 - that has the value the same as in our
116:20 - params if we can find one awesome we
116:24 - send back that specific task
116:27 - if not then we send back 404 and then
116:30 - all the way in a catch block we have our
116:32 - generic error okay so why do we have
116:35 - these two responses
116:37 - where we have four or four
116:39 - with no task with this id and then we
116:42 - still have the generic one well it's
116:44 - simply because we can have two types of
116:47 - errors
116:48 - and in order to show you that we just
116:50 - need to navigate back to the postman and
116:52 - then notice where we have the params
116:55 - where i set up this long id why don't we
116:58 - try changing the last value so instead
117:01 - of b that i have here i'm gonna go with
117:04 - zero and once we send well we should get
117:07 - the message no task with blah blah blah
117:11 - id why well because of course
117:13 - in our database we don't have any item
117:16 - whose id is matching and i can clearly
117:19 - see the 404 that means that of course
117:22 - that that is our response but
117:25 - if we change this around and then
117:28 - instead of keeping the same amount of
117:30 - characters we start removing or adding
117:33 - you'll see this error
117:35 - and the name of this error is cast error
117:38 - so effectively what's happening
117:41 - if we have the correct syntax for the id
117:45 - but we cannot find the item then of
117:47 - course we'll have to deal with it
117:48 - ourselves because essentially there is
117:51 - no task with this id but if the id
117:55 - is actually going to have the wrong
117:57 - syntax meaning it's not going to match
117:59 - the amount of characters that mongoose
118:02 - is looking for then of course we'll get
118:04 - the error from the mongoose and like i
118:06 - already mentioned this is going to be
118:08 - somewhat common setup for us for the
118:11 - upcoming controllers as well because for
118:14 - both of them for update task as well as
118:16 - delete task at the end of the day we'll
118:18 - still have to find that one specific
118:21 - item
118:22 - and if we're not successful
118:24 - then we'll send back the 404 but we'll
118:26 - always have this generic one as well
118:29 - just in case the actual syntax for the
118:32 - id is totally off awesome i think we're
118:35 - moving in nice space
118:37 - and up next i'll actually work on the
118:40 - lead task why well because with update
118:43 - task
118:44 - it's a bit more complicated and i kind
118:46 - of want to leave it as the last one
118:48 - because i promised you that i'll show
118:50 - you the differences between put and
118:53 - patch as well so therefore let's work on
118:56 - delete now most of the stuff is going to
118:58 - be exactly the same so once you're
119:00 - comfortable with delete i think you'll
119:02 - have no problem setting up update tasks
119:04 - as well
119:06 - and just to showcase in our application
119:08 - if we go back to all the tasks
119:11 - if you click on removing the task there
119:14 - we go now of course we just removed the
119:16 - task
119:17 - and the setup is going to be very very
119:20 - similar to getting the task of course
119:23 - the biggest difference
119:24 - is going to be the method or the
119:26 - function that we're going to use and in
119:28 - this case we're looking for find one and
119:31 - delete
119:32 - but everything else pretty much is going
119:34 - to be the same so if you want you can
119:36 - just copy and paste and change the
119:37 - values but in my case
119:39 - since it's going to be a bit more
119:40 - productive why don't we type it out
119:42 - together so i'll go with my sync we go
119:46 - with try catch block now i have simple
119:49 - res dot sends so i'll just remove it all
119:51 - together then we want to look for that
119:54 - id in the params because again setup
119:56 - isn't going to be exactly the same
119:58 - where we pass in the id with our params
120:01 - and we'll call this task id
120:04 - and that one is equal to rec dot params
120:08 - then once we have access to params we
120:10 - just want to go with const task is equal
120:13 - to await
120:14 - again task and then find one
120:17 - and
120:18 - remove or i'm sorry delete so find one
120:21 - and delete and in here we want to pass
120:24 - in the id again so underscore id and
120:27 - that one is equal to our task and then
120:30 - id
120:31 - and then once we have the setup of
120:33 - course then we have two options if such
120:36 - task exists
120:38 - then we send back r200
120:40 - if the task doesn't exist so essentially
120:43 - if this is equal to null then of course
120:45 - we go with r404 and in this case i will
120:48 - speed this up a little bit where i'll
120:50 - grab the if condition
120:52 - like so
120:53 - and then as far as the response
120:55 - initially i'm gonna go with a json
120:58 - object and i'll set task equal to task
121:01 - but at the very end of the video i'll
121:03 - discuss multiple options that we have so
121:05 - this is the 404 if we're not successful
121:09 - again if that item doesn't exist with
121:11 - that particular id if we are successful
121:14 - we go with res dot
121:16 - and then status
121:17 - and we pass in 200
121:20 - and then we just go with json and then
121:22 - we pass in the task so essentially that
121:24 - way in a postman we'll be able to see
121:27 - which task we removed and then just like
121:30 - the previous controllers we'll grab our
121:33 - generic one as well
121:35 - and set it up in the catch one so if
121:38 - there is an error there's going to be a
121:40 - message property with that particular
121:43 - so we navigate back to the postman
121:46 - and we're looking for delete task again
121:48 - we have this dummy value in my case that
121:51 - is peter but in your case it might be
121:53 - something else so again we need to go to
121:56 - get all tasks run it so now of course we
122:00 - can see all our tasks and then just pick
122:03 - whichever you want to remove and you
122:05 - know what in my case i'm going to go for
122:07 - those empty ones first because i don't
122:09 - want them in my database anyway so i'll
122:12 - go over here i'll grab the id and then
122:15 - i'm looking for delete task copy and
122:19 - paste and then once i save check it out
122:22 - now of course i can see that i removed
122:24 - this task and i'll remove another dummy
122:26 - one as well so let me run it one more
122:28 - time now i can clearly see that i have
122:30 - only one without a name since i removed
122:33 - the previous one so let me just grab it
122:36 - over here
122:37 - and then
122:38 - back to delete task
122:40 - copy and paste and then send
122:42 - and of course i can clearly see that i
122:44 - removed this one as well and just to
122:46 - showcase again why we have those two
122:49 - errors let's go back to all the tasks
122:52 - let's send and i'll grab the first one
122:54 - for shake and bake
122:56 - and what you'll notice
122:58 - is that if i pass in the id
123:01 - and if i just change the last value
123:04 - so i still keep the same structure
123:06 - then of course we'll get our 404 so no
123:10 - task with id and of course i have 404
123:13 - now if i'll start adding or removing the
123:17 - items
123:18 - and of course what you'll see
123:20 - is this error so of course this is
123:23 - coming from our catch block hopefully
123:25 - that makes sense and then lastly i just
123:28 - want to mention that as far as this
123:30 - response i purposely set it up here as a
123:32 - task
123:33 - just so we can see
123:35 - in the postman because i think it's a
123:37 - bit useful when we're setting up our
123:39 - first api
123:41 - but by any means you're not limited to
123:44 - sending this type of response why well
123:47 - because usually when it comes to
123:49 - deleting a task
123:50 - you're really not looking for the data
123:52 - here take a look at our front end it
123:55 - really doesn't care what task we're
123:57 - actually removing
123:58 - because the way the functionality works
124:00 - is i click on a button
124:02 - then i'm looking for a response and if
124:05 - the server sends back this 200 then
124:09 - right away
124:10 - on my front end i go like okay awesome i
124:13 - was successful so let me fetch the
124:15 - entire list one more time so it's not
124:18 - like i take that item and then i do
124:20 - something about it no i just say i want
124:22 - to remove the item if i'm successful
124:25 - awesome i'll do one thing if i'm not
124:27 - successful then of course i want to
124:29 - display some error message or something
124:32 - along those lines
124:33 - therefore
124:34 - if you go back and if you change this
124:37 - around to for example and i'll just show
124:39 - you some common ones that you might see
124:41 - in the other apis so let me comment this
124:43 - one out i'll copy and paste
124:46 - and then as long as you go with 200 you
124:49 - can simply even go like this you can say
124:51 - send that's it that's all you have to do
124:54 - and the functionality will still work or
124:57 - you might see something like this where
124:59 - again copy and paste
125:00 - and then if we go with json
125:03 - and some people just go with task and
125:06 - then set it equal to null
125:08 - and you might add a status property here
125:12 - with
125:13 - success
125:14 - and as you can see sky is the limit i'm
125:17 - just showing you what type of responses
125:20 - you might get back because again the
125:22 - main idea is that if you're successful
125:26 - if you're getting d200
125:28 - already on a front end you know what's
125:30 - happening so most likely you're not
125:32 - going to be looking for that one
125:33 - specific item that you're deleting but
125:36 - again in my case i just set up this task
125:39 - so we can nicely see in a postman what
125:42 - we're moving so i'll remove these two
125:44 - lines of code here
125:46 - and then i'll just set it back to my
125:49 - json where i have task is equal to task
125:52 - and as a quick sign out once we're done
125:55 - setting up the update task route i'll
125:58 - spend an entire video on various options
126:02 - that you have
126:03 - for your responses
126:05 - so just put the pin on that and we'll
126:07 - come back to it a bit later
126:10 - all right and we have successfully
126:11 - arrived at our last controller the
126:14 - update task one and if we are
126:17 - comfortable with getting the single task
126:20 - and setting up the delete task we should
126:23 - be in good shape because yes there's
126:25 - gonna be a bit more functionality
126:27 - because in this case not only are we
126:30 - looking for the id
126:32 - but we'll also need the body since of
126:35 - course we'll be updating something
126:37 - correct and then the second thing we
126:39 - have to pass in some options since by
126:42 - default we won't get right away the
126:45 - validators working and also we won't get
126:48 - the item that we just updated and don't
126:51 - worry of course i'll talk about all of
126:53 - that in detail so for now just to stay
126:55 - consistent i'll move this sucker down
126:57 - i'll move it below the delete task
127:00 - and let's just start simply by accident
127:03 - both of the things let's get the params
127:06 - one and then the body one so we just
127:08 - want to see that we are successful on
127:11 - acquiring both of those things so i'll
127:13 - set this up as async
127:16 - it's just a simple send so i'll just
127:18 - remove it
127:19 - and we're going to go with try catch
127:21 - and for now let's just go with arrest
127:23 - dot and then status we'll set it equal
127:27 - to 200 and then the json one and here i
127:30 - want to grab two things i want to grab
127:33 - my id
127:34 - just double check that i'm getting it
127:36 - properly from the params and also the
127:39 - body so for now
127:41 - above the res dot status let's set up
127:44 - the id one more time we'll say id so
127:46 - we're destructuring
127:48 - from the rec dot params
127:50 - rec dot params and second one is going
127:53 - to be rec.body
127:55 - and if you want you can assign it to a
127:57 - data or whatever but in my case i'm just
128:00 - going to set up the property here and
128:02 - set it equal to directly so let's just
128:05 - say id
128:06 - is equal to a
128:08 - task id and then data is going to be
128:11 - equal to rec.body again why are we going
128:15 - to be passing data well because if we're
128:17 - updating something of course you need
128:19 - that new info correct so if i go back to
128:22 - my application and if i say that instead
128:25 - of walking the dog i want to walk the
128:28 - cat of course i need to supply this name
128:30 - otherwise it's not going to make any
128:31 - sense the same goes for completed i need
128:34 - to pass in that key with the new value
128:38 - and in this case of course it's going to
128:39 - be false so once i click edit notice i'm
128:42 - successful awesome so if i go back to
128:44 - all the tasks now i have lock the cat
128:48 - and in order to test this out again we
128:50 - need to go back to the postman we're
128:52 - looking for
128:53 - getting all the tasks since i want those
128:55 - correct ids
128:57 - and
128:58 - you can pick any of them doesn't really
129:00 - matter i think i like the shake and bake
129:03 - the most
129:04 - so take this one
129:06 - then we need to go to patch the update
129:09 - task one
129:10 - copy and paste and then in response we
129:14 - should see the id correct we're not
129:16 - gonna see the data since we haven't set
129:19 - up anything here in our body at least
129:21 - not right now but we'll do it in a
129:23 - second but of course now we're just
129:25 - getting update task
129:27 - so let's see let me go back here update
129:29 - task probably i didn't save the file my
129:32 - apologies let me run one more time
129:34 - and now i should see the id
129:36 - that matches of course my shake and bake
129:38 - but as far as data there's nothing there
129:40 - why well because i haven't sent anything
129:43 - from my front end right so now let's go
129:47 - to the raw and then we'll set it equal
129:49 - to the json
129:51 - and then we set up our object and
129:53 - remember we're looking for the name
129:56 - and i'll just say testing
129:58 - edit funk
130:00 - functionality i guess and then we're
130:02 - going to be looking for completed and
130:04 - we'll set it equal to let's just double
130:07 - check in here it's true so let's go with
130:09 - false
130:11 - and let's set it here of course now not
130:13 - only i'm getting the id just coming from
130:16 - the params but i also have the data
130:18 - property and in there of course i can
130:20 - clearly see those values again the whole
130:22 - deal why i'm doing this is just so we
130:25 - don't have to console.log on a server
130:28 - and once we have all of this in place
130:31 - now let's roll up our sleeves and
130:32 - actually set up our functionality so
130:35 - i'll remove this one we don't care about
130:37 - this one right now and again we want to
130:39 - go with the task meaning i'll sign up a
130:42 - variable with the name of task and i'll
130:45 - set it equal to await
130:47 - and of course now we're looking for task
130:50 - the model name and then find one
130:52 - and if this one was find one and delete
130:55 - what do you think is going to be this
130:57 - one well it is find one and update
131:01 - and in here we need to pass in a few
131:03 - things first we need to pass in the
131:05 - object where again we set up our
131:08 - condition
131:09 - so in this case again i'm going to go
131:11 - with id matches to that one in the
131:14 - params so underscore id equal to task id
131:19 - that's step number one
131:20 - then of course we need to pass in that
131:22 - new data since we're updating something
131:25 - correct so let's go here with comma and
131:28 - that's going to be the second value so
131:29 - essentially you need to set up the
131:31 - object and set up which properties
131:33 - you're updating but remember we're
131:35 - already getting that as far as wreck
131:37 - that body so reg.body is right away this
131:40 - object so i can simply set up my next
131:44 - parameter like so where i go with
131:46 - reg.body and then we have options object
131:49 - but i first want to show you what
131:51 - happens if we don't use it and then
131:53 - we'll add both of the values in there as
131:56 - well so let's start here again by
131:59 - checking the task because again we might
132:02 - have a situation where there is no task
132:04 - with that specific id
132:06 - and again just speed this up or copy and
132:09 - paste and then if we are successful then
132:12 - of course i want to send back the task
132:15 - i'll say task is equal to task
132:17 - and don't forget the generic error where
132:20 - we go to resdot status
132:22 - and then you already know the rest copy
132:25 - and paste
132:26 - and you'll notice something interesting
132:28 - since we don't have the options you'll
132:31 - notice the following thing where
132:33 - i go with testing edit function okay
132:36 - that's awesome i completed false
132:39 - but essentially what we're gonna get
132:41 - back
132:42 - is the original value so remember the
132:45 - shaken bag
132:46 - effectively this is what we'll get back
132:48 - so once i send notice
132:51 - yeah i get 200
132:52 - so i was successful
132:55 - but notice the value here it's shaking
132:57 - big and what's more interesting that
132:59 - once i click on getting all the tasks
133:02 - it's actually changed
133:04 - so i was successful so here's the gotcha
133:07 - the reason why is that happening
133:09 - is because we're not passing in the
133:11 - options and as far as the options we
133:14 - want to do two things we want to get the
133:16 - new one back because by default we're
133:18 - getting the old one that's why we were
133:20 - successful
133:22 - but in our update response we got the
133:25 - old value and the second thing what
133:27 - you'll notice
133:28 - is the fact that we're not running the
133:30 - validators so if you remember when we
133:33 - were setting up the model
133:35 - one of the things that i set up for the
133:37 - name was required equal to true
133:40 - now if i try to update item
133:43 - with name
133:45 - equal to an empty string i'm actually
133:47 - going to be successful now again we're
133:49 - getting back the old value and in order
133:52 - to check the new one we just need to run
133:54 - get all tasks
133:55 - notice and i promise you i'll say this
133:57 - for the last time in this video the
133:59 - reason for that is because we don't have
134:01 - the options object
134:03 - and in order to set it up we just need
134:05 - to go back to all the controllers and
134:07 - like i said
134:08 - third parameter is going to be our
134:11 - options
134:12 - and then we simply go with new true so
134:15 - this will always always always return
134:18 - that new item the one that is already
134:22 - updated and then the another property we
134:24 - can run is run validators and we'll set
134:27 - it equal to true so once we do that of
134:31 - course we fixed both bugs so if i for
134:35 - the final time i guess in this video go
134:37 - back to my post man and in here
134:42 - i'm gonna go back to shake
134:44 - and bake and we'll set the value
134:48 - equal to true
134:49 - we should see that right away so i can
134:52 - see shake and bake and if i try to do
134:55 - that
134:55 - without passing anything in the name
134:58 - then of course i'll get my big fat error
135:01 - because when i was setting up the model
135:03 - i said that name is actually required
135:06 - awesome and believe it or not we're
135:09 - actually done with our basic setup
135:12 - as far as the api
135:14 - and in order to showcase that i'll
135:16 - simply go back to app.js
135:19 - and then i want to serve my static files
135:21 - because this is where my app is sitting
135:24 - and of course since our api is up and
135:27 - running we can simply set up those
135:29 - static files the app and the
135:32 - functionality should work and if you
135:35 - remember in order to serve static files
135:37 - we need to use another middleware and
135:40 - we're going to go with app.use we'll
135:42 - pass in express
135:44 - and the name is static and then in here
135:46 - we just simply need to say where the
135:49 - static files are located and in our case
135:51 - of course that is in the public folder
135:54 - and let me just say that if your code is
135:58 - exactly like mine
136:00 - everything is going to work now back in
136:02 - the app.js i don't think we need that
136:04 - hello one anymore so let me remove this
136:07 - one
136:08 - folder out
136:10 - i'll just leave the version one and then
136:12 - tasks and then if i go to localhost 3000
136:17 - and i removed that hello
136:19 - i should see my app and i can clearly
136:22 - see that these are all the tasks that i
136:25 - currently have and if i want to add new
136:27 - one i'm just going to say testing app
136:30 - and once i add of course i have all the
136:32 - way in the bottom a testing app well
136:35 - effectively i have two
136:36 - but we right away can also practice on
136:39 - deleting so there it is now we can
136:41 - delete the items
136:43 - all the way to second task then if i
136:46 - want to see the single task just click
136:48 - over here notice now i have the task id
136:51 - as well as second task and then
136:54 - eventually if i want to edit well i just
136:56 - click here on completed
136:58 - and i'll say third task
137:00 - third task
137:02 - and if everything is correct we should
137:03 - see task edited now i still need to fix
137:06 - the css but as long as you see the
137:08 - correct text you should be in good shape
137:11 - now of course by the time you're
137:12 - watching this i'll fix this but the idea
137:14 - is following if i try to edit the item
137:17 - without providing the name now of course
137:18 - i'll get error please try again i just
137:21 - need to fix the css more essentially if
137:24 - i'm successful i still get this red
137:27 - color and then once i navigate back now
137:30 - these are going to be my task
137:32 - if you're interested in the actual app
137:35 - just navigate to the public one you'll
137:37 - see that i used vanilla.js
137:40 - just so everyone can be on same page
137:43 - and essentially as far as the logic
137:46 - you're looking for browser objects and
137:49 - i'm not going to show you the entire
137:50 - thing but as far as submitting the new
137:54 - task i'm just listening for submit event
137:57 - then i prevent the default i'm looking
138:00 - for the value in the input
138:02 - and notice that i'm using the axios
138:04 - library
138:05 - and check out the method
138:06 - what is the method name
138:08 - that is post why well because that's how
138:11 - we can pass data onto the server correct
138:14 - now what is the url
138:16 - that should be familiar we have api
138:18 - version one and then of course i'm
138:20 - looking for the tasks and in here i pass
138:24 - in the data
138:25 - so unlike the postman where we were
138:28 - doing that manually now of course i just
138:30 - grab the input and i'll pass it in and
138:33 - if you remember the completed was set
138:36 - to false right from the get go so i
138:39 - don't need to worry about that i just
138:41 - need to pass in the name
138:43 - and again everything is in try catch
138:46 - so if i'm successful
138:49 - then of course what happens well
138:51 - then i add the correct alerts and all
138:54 - that and then i just refetch one more
138:58 - time tasks
138:59 - now if i'm getting the error then of
139:02 - course i'll add different alerts and
139:04 - hopefully you get the gist
139:06 - and just to lastly showcase the delete
139:09 - one
139:09 - if we scroll up a little bit notice the
139:12 - method here and like i previously
139:15 - mentioned the only thing i'm looking for
139:17 - here is the response if everything is
139:20 - correct if i have 200 awesome
139:24 - i just refetch all the tasks if not
139:27 - then there's an error and essentially i
139:29 - don't remove it from my dom that's why i
139:32 - said that technically when you're set up
139:34 - for the delete
139:35 - in most cases you're not going to have
139:37 - to send back that item that you're
139:40 - removing and now it's simply about
139:43 - making this app better because yes we
139:46 - have the core functionality in place we
139:48 - can definitely test it out on the front
139:50 - end and everything is awesome but
139:53 - there's some things that we would want
139:54 - to fix for example i want to remove all
139:57 - these strike catch blocks i don't want
139:59 - to repeat myself in such a way i also
140:01 - want to set up one place where we're
140:03 - dealing with errors and other
140:05 - improvements so in the following videos
140:08 - we'll make our app better so we have the
140:11 - core functionality in place now we just
140:13 - want to make it better all right and up
140:16 - next i want to finally discuss put
140:18 - method versus patch method
140:21 - so why in this api in our routes we used
140:24 - patch
140:25 - and during tutorial we used put
140:28 - so here's the deal yes put and patch are
140:31 - both
140:32 - are both for updating the resource but
140:35 - the assumption is that when you use put
140:38 - you're trying to replace the existing
140:40 - resource
140:41 - and patch is for partial update
140:44 - and since i'm fully aware that this
140:46 - might sound like mumbo jumbo to you let
140:49 - me give you an example
140:51 - so if we go to our postman
140:55 - and then more specifically update task
140:58 - if the id is correct
141:01 - then only the properties that i'll pass
141:04 - in
141:04 - will be updated so in this case if i'm
141:07 - gonna go with
141:08 - shake
141:10 - and bake number two
141:12 - and i'll actually remove completed
141:16 - only the property that is passed in will
141:18 - be updated so if i send check it out now
141:22 - i get the task and i can clearly see
141:24 - that completed is there even though i
141:27 - didn't pass it why well because that's
141:30 - how our functionality is set up in the
141:32 - controller
141:33 - so if i'll pass completed and i'll set
141:35 - it equal to false of course it will be
141:37 - updated as well so if i go here
141:40 - completed
141:41 - and i'll set it to false yes in this
141:43 - case since i'm passing the property of
141:45 - course now i'm going to get the new
141:48 - result
141:49 - now what is the difference with put well
141:52 - let me go the long route and actually
141:54 - set up one more controller but keep in
141:56 - mind that this is going to be just
141:58 - temporary controller so if you don't
142:00 - want you can just sit back and relax and
142:04 - we'll start in our routes where
142:06 - essentially i want to go with my route
142:09 - and in this case i'm still looking for
142:11 - this forward slash and then colon id
142:14 - because again
142:16 - the functionality is going to be almost
142:17 - the same but i'm looking for a different
142:20 - method and i'm looking for put and of
142:22 - course now we just need to create the
142:24 - controller and in my case eventually
142:26 - i'll call this update or i'm sorry edit
142:29 - task just so it's a little bit different
142:31 - so of course i'm not exporting that yet
142:34 - but i'll right away set it here in my
142:37 - structure i'll say edit task and then
142:40 - back in the controllers
142:43 - i just want to go below the update task
142:45 - again this is just going to be temporary
142:47 - but i'll go with const edit and then
142:50 - task and that one is going to be equal
142:52 - to whatever i have over here we simply
142:56 - need to add
142:57 - one more option
142:59 - in the find one and update so let me
143:02 - select this whole thing just so we don't
143:04 - have to type it from scratch and all the
143:06 - way in the bottom
143:07 - we're going to go with edit task
143:10 - and like i said it's going to be
143:11 - temporary so in here i'm not going to
143:13 - save it with all my routes
143:16 - but let me just save my current ones
143:19 - and i'll close all of these windows and
143:21 - let's set up a new route
143:23 - so in this case it's going to be a put
143:25 - route
143:26 - and remember we have our variable so i'm
143:29 - looking for url and then i'm looking for
143:32 - the tasks
143:33 - and of course i want to grab some kind
143:34 - of id
143:35 - so let me get
143:37 - again all the tasks here
143:40 - and i'm going to stick with shaken back
143:43 - because i like that name so much
143:45 - so let me grab this id here
143:47 - then back in tasks i will pass it in
143:50 - and then let's try to recreate the same
143:53 - functionality that we have for now e in
143:55 - the patch and essentially
143:57 - what i really want is just to pass in
144:00 - some data in my body so i'm gonna go
144:03 - here with raw
144:04 - again we're looking for json
144:06 - and we'll set it up name
144:09 - equal to john
144:11 - nothing particularly original and once i
144:14 - save of course now shaken bake has the
144:17 - name of john but here comes the biggest
144:20 - difference between put method that we're
144:23 - using over here
144:24 - and the patch method so idea with put is
144:28 - that if i send only the name
144:31 - my expectation
144:33 - is that
144:34 - all the rest of the properties which of
144:36 - course in our case is just completed
144:38 - will be removed from that item so we
144:41 - will replace that item and how is that
144:43 - going to look like in our controller
144:45 - well here everything is going to be
144:47 - exactly the same
144:49 - but by default mongoose doesn't do that
144:52 - so by default mongoose is going to be
144:54 - like okay so you want to get the item
144:57 - you want to update it awesome just get
144:59 - me the properties you want to update and
145:01 - rest of them will stay the same
145:03 - and if i actually want to remove those
145:06 - properties the ones that i'm not passing
145:08 - in with my request i need to add another
145:11 - option here and the option name is
145:13 - overwrite
145:14 - and we need to set it equal to true so
145:17 - now you'll notice that back in my
145:19 - postman
145:20 - if i send here with name and let's just
145:24 - keep it interesting and pass in peter
145:26 - check it out we have name
145:28 - and the complete is still there now why
145:30 - it's still there well because in our
145:33 - model we have default set to false so
145:37 - there is some default one if i remove it
145:40 - you'll notice that with output method
145:42 - the way the controller works right now
145:45 - if i send it right now then of course
145:47 - i'll just get the name
145:50 - so completed is not there anymore so if
145:53 - i take a look at all the tasks now and
145:56 - the first one actually completed is
145:58 - missing so that is going to be the
146:01 - difference where when we work with put
146:04 - the expectation
146:05 - is that we'll replace
146:08 - the item so we'll just pass in the
146:11 - properties that we want to set up in
146:13 - item and then rest of them effectively
146:16 - will be removed
146:18 - but when we're working with patch we're
146:20 - just updating the properties that we're
146:22 - passing in just remember that in real
146:24 - life you will see the apis where the put
146:28 - method is used with the same
146:30 - functionality as the patch now in our
146:33 - case for the remainder of the project
146:36 - we'll use the patch one instead so
146:38 - therefore i'll remove this edit one
146:40 - and here as well
146:42 - and the same i want to do in routes like
146:45 - i said
146:46 - this is just for demonstration purposes
146:49 - so save it here and i also want to
146:51 - remove this route from my postman just
146:54 - so it's not in a way so say don't save
146:58 - and i'm back to my five routes and of
147:00 - course for the update i'm using the
147:03 - patch one and before we start
147:05 - refactoring our code and adding some
147:07 - extra middleware let's just spend a few
147:09 - minutes on our responses
147:12 - and more specifically on the other
147:14 - options you have when setting them up
147:17 - and i'll use get all tasks route as my
147:20 - example just keep in mind that the same
147:22 - goes for the rest of them
147:25 - and essentially when i was setting up
147:26 - the route i said that you have tons of
147:29 - options here as far as the response so
147:33 - in my case i'm just setting up course
147:35 - djson object and then i set the property
147:38 - tasks equal to tasks but you can also do
147:42 - something like this where i'll copy and
147:45 - paste
147:46 - and i'm going to go with res.status so
147:48 - this won't change we're just talking
147:50 - about the object that we're sending back
147:53 - and instead of simply just sending tasks
147:56 - you could also add the amount of tasks
147:59 - and for this property name of course sky
148:02 - is the limit
148:03 - whatever you want to come up with in my
148:05 - case i'm going to go with amount but you
148:07 - can also call it maybe value maybe the
148:10 - number of hits or something along those
148:13 - lines and here you're just looking for
148:15 - tasks
148:16 - and of course the length like so
148:20 - and also what we could do and i'll just
148:22 - comment these options out just so they
148:24 - can stay for your reference
148:26 - and let me copy and paste so i don't
148:28 - have to type arrest that status also
148:30 - what we could do well i could set up a
148:34 - flag here where i say success
148:37 - is equal to true and then of course we
148:40 - need to keep in mind if that is the case
148:43 - then you also need to add something here
148:46 - where you have the error whether that is
148:48 - 404 error
148:49 - or it's the general 501 so effectively
148:53 - here i just add this extra bit of data
148:56 - where i say yeah the success was true
149:00 - and then you can even place it in the
149:02 - data property and then say tasks
149:05 - is equal to tasks and also maybe add the
149:09 - amount so that's also something that you
149:11 - might see around for example the hacker
149:14 - news api uses the number of hits like so
149:18 - essentially you just get that value and
149:20 - again that is going to be equal to the
149:22 - array that you're getting back equal to
149:25 - a length and once i said of course my
149:27 - response is going to look like this now
149:30 - if you don't like the success one
149:32 - go maybe with status that's also
149:34 - something that you might see around
149:36 - where we set up status is equal to
149:38 - success
149:39 - for the successful responses and then
149:42 - for errors of course we're going to go
149:44 - with status and then fail or error or
149:48 - whatever string value you might want to
149:49 - set up and if you're wondering why am i
149:52 - showing you this is because i want you
149:53 - to be aware of your options
149:56 - so just because i'm setting it this way
149:59 - where i just pass in the tasks of course
150:02 - that's not a rule that's pretty much my
150:05 - preference
150:06 - and why i don't prefer setting up the
150:08 - statuses or successes or the data here
150:12 - that is simply because of the front end
150:14 - so in my experience when we use frontend
150:17 - there's two things that are going on
150:20 - effectively when we have asynchronous
150:22 - responses we already have try and catch
150:25 - and because of that i find the status or
150:27 - success to be a bit redundant because
150:30 - effectively just like i showed you with
150:32 - delete
150:33 - if i'm successful then of course this
150:36 - code will run regardless and then if
150:39 - there's some kind of error then of
150:41 - course i'm gonna have my code e in the
150:44 - cache block and why i don't like setting
150:46 - up the data well because on my front end
150:48 - usually i use axios and if you're
150:50 - familiar with axios it right away
150:53 - returns a data property so it right away
150:57 - has that data object so if you set this
151:00 - response in such a manner where you have
151:03 - data returned in the object then on the
151:06 - front end you'll have
151:08 - data
151:09 - and then in that data object you have
151:11 - another data so essentially on the front
151:13 - end you need to do something like this
151:15 - where there is a data object inside of
151:17 - that data object there's another data
151:19 - object and then you only get the tasks
151:22 - which is of course not the end of the
151:24 - world but in my case again i find it a
151:27 - bit redundant
151:28 - and lastly when it comes tutorials and
151:30 - courses i also enjoy the fact that
151:33 - there's less typing in the setup where i
151:36 - just pass in the tasks so be aware of
151:38 - your options my suggestion is whichever
151:42 - route you pick just stick throughout the
151:45 - api
151:46 - so there's no confusion
151:48 - don't set up one type of response for
151:51 - one route and then go totally different
151:54 - in a different route that's going to be
151:55 - very confusing to whomever is using your
151:58 - api and lastly let me just say this yes
152:01 - you can set up your own api responses
152:04 - however you like
152:06 - but if you want our front-end app the
152:09 - one that's sitting in the public to work
152:11 - properly
152:12 - the responses
152:14 - have to be exactly the same as mine
152:17 - because that's what the app is expecting
152:21 - if you'll set it up willy-nilly then you
152:24 - might get some bugs
152:26 - not bad not bad once we have discussed
152:28 - our response options
152:31 - next i want to work on route not found
152:35 - so at the moment
152:36 - life is awesome we have our application
152:40 - everything works if i go to index.html
152:42 - of course i can see the application
152:44 - if i go to api then version one and then
152:47 - tasks of course i can see all the tasks
152:50 - what happens if i go with api version
152:53 - one
152:54 - and then hollow so i have cannot get api
152:58 - blah blah blah
152:59 - and i can clearly see in my browser that
153:02 - of course we get 404 error but
153:06 - essentially this is going to be the
153:07 - default one
153:08 - and instead i want to set up the custom
153:10 - one just like they have in algolia one
153:13 - or again
153:14 - if you're looking for some kind of
153:16 - resource
153:17 - and the server can find the resource and
153:20 - essentially we still get the 404 but of
153:23 - course the value here is unknown now it
153:26 - doesn't really matter what you set up as
153:28 - far as the value just want to showcase
153:30 - how we can set up a custom 404 response
153:35 - and the way we do that we go back to our
153:37 - application here
153:39 - and then in the app.js i want to remove
153:41 - these comments
153:43 - because i think we're clear on the rest
153:45 - api
153:46 - and location here is very important so
153:49 - we have the middleware for public and
153:51 - json that still stays the same
153:54 - then we have all our routes for the
153:57 - tasks
153:58 - and then right after that we want to go
154:00 - with app.use and then we'll pass in our
154:04 - middleware function the one that will
154:06 - handle the 404 and send some kind of
154:10 - custom response now we haven't created
154:13 - it yet
154:14 - so let's go back to our starter we'll
154:16 - create a new folder because there's
154:19 - going to be a few middlewares that we'll
154:20 - set up in the upcoming videos so say
154:24 - middleware
154:25 - and then inside of the middleware we
154:27 - want to go with new file and i'll call
154:29 - this one not surprisingly
154:32 - not found and a js and as far as the
154:35 - logic well we'll still have access to
154:37 - erec and res so we just need to come up
154:40 - with function name in my case it's going
154:41 - to be not
154:43 - found and i'll set it equal to rec and
154:45 - res
154:46 - and then as far as the response i'm just
154:48 - going to go with res dot
154:50 - then status and of course in this case
154:53 - it's 404 so the server is letting the
154:55 - user know that it cannot find the
154:57 - resource and then as far as the message
154:59 - i'll just use the simple send and i'll
155:01 - say route
155:03 - does not
155:04 - and exist
155:06 - so now of course we just need to export
155:08 - this and we do that with module then
155:12 - exports of course
155:13 - and we'll set it equal to our not found
155:16 - and then back in the app.js
155:19 - above the app.users we're going to go
155:22 - with const not found is equal to require
155:27 - then we're looking of course e in our
155:30 - middleware so let me say dot middleware
155:33 - and then more specifically we're looking
155:35 - in and not found and then in the
155:38 - app.used we'll just stick not found one
155:42 - and once we save and in this case i'll
155:44 - just use the postman just so you can see
155:47 - that it's gonna work exactly the same
155:49 - and if we're looking for the url
155:51 - and then we'll go with hello now of
155:54 - course we have our custom one we have
155:56 - route does not exist which is pretty
155:59 - awesome and just to showcase that it's
156:01 - going to be the same scenario in the
156:03 - browser as well notice once we refresh
156:06 - we have route does not exist so we set
156:09 - up the middleware folder in there we
156:11 - have not found.js and then back in the
156:15 - app.js we import the function we set
156:18 - some kind of name in my case it's not
156:20 - found and then all the way in the bottom
156:23 - we go with app.use and we pass in the
156:26 - function and in that function we'll have
156:28 - access to rack and res and in our case
156:32 - we're just interested in response and
156:34 - we'll set up a 404 with whatever message
156:38 - we want to send back
156:40 - awesome and up next i want to work on
156:42 - asynchronous wrappers for all our
156:46 - controllers why
156:47 - well because we have asynchronous
156:50 - operations
156:51 - and yes it's very useful to use these
156:53 - try catch blocks
156:55 - but you'll have to agree with me that
156:58 - it becomes somewhat redundant pretty
157:00 - much for every controller setting up try
157:04 - and then catch and as you can see
157:06 - essentially i'm just copying pasting the
157:08 - code around so there has to be a better
157:10 - solution and that better solution is to
157:13 - create a middleware function
157:15 - that essentially we'll wrap our
157:18 - controllers
157:19 - and in there we'll just set up the
157:20 - functionality where we don't have to
157:23 - repeat ourselves and before we continue
157:25 - let me just say that there are some npm
157:27 - packages that do that for us
157:30 - and most likely in the upcoming project
157:32 - we'll use them instead since that way we
157:35 - can save some time on the setup but i
157:37 - think it's very important to have at
157:39 - least a general idea of what the package
157:42 - is doing instead of blindly installing
157:44 - it and therefore in our first project
157:47 - we'll set up the basic logic ourselves
157:50 - and we'll start over here with new file
157:52 - and i'll call this async js and then
157:56 - inside of it i'm just going to go with
157:57 - const
157:58 - async wrapper so i simply create a
158:02 - function
158:03 - at the moment nothing is happening here
158:05 - and then i want to export it so module
158:08 - exports
158:09 - and then a sync wrapper
158:11 - and once we set up the export now of
158:14 - course i just want to go to my
158:16 - controllers
158:17 - and import that middleware so i'm
158:20 - looking in the middleware and i'm
158:22 - looking for async so in here let's just
158:25 - call this a sync
158:27 - wrapper again and that is equal to
158:29 - require
158:31 - then we navigate to our middleware
158:34 - folder and of course we're looking for
158:36 - the async
158:37 - and now what we want to do
158:39 - is wrap
158:41 - all of our controllers now i'm not going
158:43 - to wrap all of them right away i'll just
158:45 - start with get all tasks just so you
158:48 - understand how it is going to work so
158:51 - what we want to do here is just to take
158:53 - this async wrapper this function
158:56 - and just wrap our current controller
158:59 - and essentially it's going to look like
159:01 - this where we go with a sync wrapper
159:05 - and we pass in the controller the
159:07 - current controller
159:09 - as an argument and since we know that we
159:11 - can do that in javascript we are in good
159:13 - shape so we pass it in
159:16 - and then back in the async
159:18 - of course i need to set up the parameter
159:21 - so since i'm passing in already in the
159:23 - controllers my function my controller as
159:27 - an argument back in my sync js my
159:30 - middleware i just need to go with some
159:32 - kind of parameter now you can call this
159:35 - callback you can call this function it
159:36 - doesn't really matter in my case i'm
159:38 - just going to go with fn
159:40 - and what am i trying to do here well i'm
159:44 - trying to avoid this try catch so
159:47 - essentially i want to have my cake and
159:49 - eat it too where i can still use this
159:52 - nice await syntax
159:54 - but i don't have to set up these try
159:57 - catch blocks how can we do that well we
160:00 - set up the try catch blocks inside of
160:03 - the wrapper
160:04 - and the first thing that i want to do
160:05 - from this function
160:06 - is to return another one so in here i'll
160:09 - say return async
160:12 - and then if you remember
160:14 - in the express by default we right away
160:17 - got request response as well as the next
160:21 - so that's what i'm trying to do over
160:23 - here since i wrapped my controller
160:26 - in my middleware and if you pay close
160:29 - attention we're actually invoking the
160:32 - async wrapper right away now of course i
160:35 - want to pass in those request
160:37 - response and next down to my function
160:40 - down to this controller correct because
160:43 - now of course i wrap my controller in my
160:46 - middleware and the way we do that we
160:48 - return another function since i'll use a
160:51 - weight inside of the function body
160:53 - that's why i set it up here as async and
160:56 - please please please keep something in
160:57 - mind where these ones the wreck res and
161:01 - next we'll have access to right away
161:04 - because at the end of the day we return
161:06 - another function from async wrapper and
161:09 - then inside of the function body one of
161:11 - the things that i want to do is pass
161:15 - these rec res and next
161:17 - from express down to this function so
161:20 - hopefully that is clear again we get
161:22 - these ones by default the reason why we
161:25 - have access to them because from our
161:27 - async wrapper we actually return another
161:30 - function so that's how we'll have right
161:32 - away access to them and then in the
161:34 - function body we'll decide what to do
161:37 - with our parameter
161:39 - with our argument which is our current
161:42 - controller and as far as logic i want to
161:44 - go with try catch block and then inside
161:47 - of the try block i'm going to go with a
161:49 - weight
161:50 - and function and here we'll pass in rec
161:54 - res and next
161:56 - and then once we have passed all of
161:58 - these things down to our controller of
162:00 - course now have access to them in here
162:04 - as well and there also since there might
162:06 - be a case for an error we'll go with
162:08 - next and then we'll pass in the error
162:11 - and if you're wondering what's happening
162:13 - over here essentially we're passing this
162:15 - to a next middleware which we haven't
162:18 - set up yet e in our app.js so that's
162:21 - what's coming up in the following videos
162:23 - we'll set up another set of middleware
162:26 - and in this case we'll deal with errors
162:29 - so once we save over here we can go back
162:32 - to the controllers and now i can remove
162:35 - the try catch block so remove the try
162:38 - catch block completely and at this point
162:41 - you should only have these two lines of
162:43 - code where we're waiting to find all the
162:46 - tasks and if we're successful we send
162:50 - back those tasks and as far as the async
162:53 - wrapper we take our controller
162:56 - as a argument
162:57 - and then since we return the function we
163:00 - have access to rec res and next that are
163:03 - coming from the express
163:06 - and we set up the try catch block and in
163:09 - here we have a weight because our
163:12 - controller is still async and we know
163:14 - that by default a sync function will
163:17 - always always return a promise so in
163:21 - here i just have a wait and i'm waiting
163:24 - for that promise to be settled either
163:27 - resolved or rejected and since my
163:29 - controller will still need to access
163:31 - rack res and possibly next since i get
163:34 - them from express i pass it down to my
163:37 - controller
163:38 - and then if there is an error so in here
163:42 - if we trigger some kind of error whether
163:45 - in get all tasks or any of the
163:49 - controllers then of course we'll catch
163:51 - it over here and we'll pass it to a next
163:55 - set of middleware which we haven't set
163:58 - up yet and now of course once we have
164:00 - everything in place now we just want to
164:01 - apply these changes to all the routes
164:04 - now i fully understand that some people
164:07 - are very negative about refactoring the
164:09 - code and to some degree i sympathize
164:12 - with that because i also hold the
164:14 - opinion where it's not very useful if
164:16 - we're all the time refactoring the
164:18 - application
164:19 - but it was important for me to show you
164:22 - the long way first because that way you
164:25 - have a good understanding of how
164:27 - everything works and now we just set up
164:30 - the middleware that actually handles
164:32 - that so let's go back to the controllers
164:35 - and slowly but surely let's add this a
164:38 - sync wrapper to all the routes and the
164:42 - setup is going to be following for all
164:43 - of them where we start with a sync
164:46 - wrapper so we set up our two parentheses
164:49 - here and we need to make sure that
164:51 - second parenthesis the closing one is
164:53 - right after the curly brace correct
164:56 - then we want to remove the try block as
164:58 - well as the catch block
165:00 - and again we'll be just left with wait
165:03 - does that create if we're successful we
165:06 - send back the task and effectively we
165:08 - want to do that for all our controllers
165:12 - so let me go here with a sync wrapper
165:14 - same deal
165:16 - wrap this guy here
165:18 - and then we have try
165:21 - and we remove the catch but we are
165:24 - leaving this one
165:25 - so i will work with this one a little
165:27 - bit later for time being we'll leave it
165:29 - as it is with this response and once we
165:32 - set up our custom error there's going to
165:34 - be some changes here as well let's keep
165:37 - on scrolling we're looking for the async
165:39 - wrapper
165:40 - and again we want to add the closing one
165:43 - right after the curly brace we still
165:46 - pass in the function i'll remove my try
165:49 - i'll remove my catch here
165:52 - and we'll save it and the same goes for
165:55 - updating a task as well so we go here
165:57 - with async wrapper
166:00 - and we'll close it
166:03 - then
166:04 - we want to remove try
166:06 - and we want to remove catch
166:09 - and just to try it out why don't we go
166:11 - to create task
166:14 - and then i'm just going to go with
166:16 - creating task creating
166:18 - task let's try it out
166:20 - everything still works i can create my
166:22 - task but if i'll try to add a task with
166:27 - an empty string value i should get the
166:29 - error and i do but of course this is not
166:32 - the error that we're sending so that's
166:34 - something that we're going to work on in
166:35 - the upcoming videos and once we have set
166:38 - up the async wrapper next i want to work
166:41 - on catching the errors and we're going
166:44 - to start our journey actually in the
166:47 - express documentation so go to
166:49 - expressjs.com and then in search box
166:53 - just type error and first let's take a
166:56 - look at the default one and if you take
166:58 - a look at the first sentence express
167:00 - comes with built-in error handler that
167:02 - takes care of any errors that might be
167:05 - encountered in the app this default
167:08 - error handling middleware function is
167:10 - added at the end of the middleware
167:12 - function stack
167:13 - and if we pass in error to the next
167:17 - and you do not handle it in a customer
167:20 - handler it will be handled by the
167:23 - built-in one why am i telling you this
167:25 - well because that answers this question
167:28 - where is this response coming from well
167:31 - that is coming from the default built-in
167:34 - error handler that's point number one i
167:36 - want to make otherwise you might be
167:38 - wondering well where are we getting this
167:39 - info second next correct that's why in
167:43 - the async wrapper we set up this next
167:46 - and error so we passed it to the next
167:49 - middleware but in our case of course we
167:52 - haven't set up that handler yet so
167:55 - therefore it was just eventually passed
167:57 - down to the built-in one and lastly if
168:00 - we go back and if we say here error so
168:02 - i'll search one more time and in this
168:04 - case we're looking for
168:06 - writing error handlers so this is what
168:08 - we're about to do we'll set up another
168:11 - set of middleware however in this case
168:14 - the middleware will handle errors
168:17 - and you can see that if we want to
168:19 - handle errors we just pass in
168:22 - four arguments and then the first one
168:24 - will be that error and then we want to
168:27 - place that at the very end of our routes
168:31 - so let's just navigate back and of
168:33 - course in the example they showcase how
168:36 - they right away set up the middleware in
168:38 - the app.js
168:39 - in our case since we'll have more code
168:42 - essentially i want to create another
168:44 - file in the middleware so in here i'm
168:47 - just looking for new file and i'll call
168:50 - this error
168:51 - and then handler and inside of the file
168:54 - i just need to come up with the function
168:56 - and i'm going to go the long route where
168:58 - i'll say error
168:59 - handler
169:01 - middleware and that is equal to error
169:03 - again in this case we need to have four
169:05 - parameters request response and we also
169:09 - have next and as far as the logic we'll
169:12 - add more code once we set up our own
169:15 - custom error class but for time being we
169:19 - just want to go with return
169:21 - and res that status and if you remember
169:24 - that's exactly what we had previously e
169:26 - in the try catch block and i'm just
169:28 - going to go to 500 and we'll say json
169:32 - error and error is equal to error now if
169:35 - you want you can cancel log it of course
169:37 - but the result is going to be exactly
169:39 - the same where in here we'll have access
169:42 - to that error the one that is going to
169:44 - be coming in our case from this async
169:47 - wrapper and then we just need to decide
169:50 - what we want to do and i'll just start
169:52 - by setting error equal to error and
169:54 - you're not actually
169:55 - i want to go with message is equal to
169:58 - error and now we simply want to go back
170:00 - to app.js
170:02 - where we have not found let's just copy
170:04 - and paste and now we just need to come
170:06 - up with a name and as you know naming is
170:09 - probably the hardest thing in
170:11 - programming so in my case i'm just going
170:13 - to call this error handler and then
170:16 - middleware and of course that one is
170:18 - coming
170:19 - from the file that we just set up the
170:21 - error handler and then we want to scroll
170:24 - all the way down and right after not
170:26 - found we're going to go with app.use and
170:29 - of course we'll pass in the error
170:31 - handler middleware and once we save and
170:34 - we go back to the postman and try to
170:37 - send the same request
170:39 - meaning the request with a incomplete
170:42 - data then we should get a different
170:45 - response but we don't effectively it
170:47 - looks like i have a bug so let me check
170:49 - the error handler and yes of course i
170:52 - didn't export the function so let me go
170:54 - with module
170:56 - exports and that one is equal to a error
170:58 - handler one and of course if i test it
171:01 - out right now i should see the custom
171:03 - response and we can clearly see that
171:06 - because we have the message now like i
171:08 - already mentioned previously if you
171:10 - don't like these big massive error
171:13 - messages you can simply go back over
171:15 - here and instead of setting the message
171:18 - equal to an error you can just hard code
171:21 - some kind of message so you can go
171:23 - something along the lines of something
171:27 - something went
171:29 - wrong
171:30 - comma try again
171:33 - later
171:34 - this is what we'll see in postman again
171:36 - we send and now of course our message is
171:40 - shorter so essentially this is how we
171:42 - can set up a custom error handler in
171:45 - express where we add another piece of
171:48 - middleware and then in there we have
171:50 - four arguments and the first one is
171:52 - going to be the error and of course in
171:55 - our case the way we pass the errors down
171:57 - to this custom error handler is by using
172:00 - the hsync wrapper and there we have the
172:03 - next so as you remember from tutorial
172:06 - with next we pass it to the next
172:08 - middleware and previously we used the
172:10 - built in default one and now of course
172:12 - we have our own where effectively you
172:14 - can set up whatever logic you want if
172:16 - you want to send this as 200
172:18 - nothing stops you from doing that but of
172:21 - course a more meaningful response would
172:23 - be with some kind of error code and with
172:26 - some kind of meaningful message whether
172:28 - that is hard-coded string or you can
172:31 - pass in the entire error object and
172:35 - right after we set up our custom error
172:36 - handler let's work on our 404 responses
172:40 - too
172:41 - and essentially i want to set up a
172:43 - custom error class
172:44 - which extends from the general
172:47 - javascript error class and that way we
172:49 - can handle all of our 404 responses in
172:52 - our newly created error handler as well
172:56 - and we're going to start by navigating
172:59 - back to the controllers
173:00 - and the routes or controllers that i'm
173:04 - looking for are following i want to work
173:06 - on update task
173:08 - here we send the 404 then the same is
173:11 - for deleting the task
173:12 - and of course getting the task
173:15 - and let's just start over here
173:17 - with getting the task
173:19 - and simply i want to showcase that we
173:20 - can create a new error object
173:22 - if we run the built in javascript error
173:26 - constructor and we go here with const
173:28 - and no surprise i'm going to call this
173:30 - error and that is equal to new and then
173:32 - we just go with error and here we pass
173:35 - in the message
173:37 - so i can say not found
173:39 - and then next line i'm just going to go
173:41 - with error so now i'm dealing with the
173:44 - object that i just created and i'll set
173:46 - another property on it and i'll say
173:48 - status so that's the name of the
173:50 - property and of course the value will be
173:53 - 404 so now
173:56 - if you want you can console log it here
173:59 - or what we can simply do
174:01 - is use next
174:03 - and pass this guy
174:05 - down to our custom error handler
174:08 - remember that's how it works we call
174:10 - next and then we pass in the error and
174:13 - of course in this case we are creating
174:15 - that error ourselves instead of getting
174:18 - it from the mongoose and the only thing
174:21 - that's missing right now
174:22 - is in our controller
174:24 - because we don't have the next so i want
174:27 - to go here with next
174:29 - and then we need to go with return again
174:32 - i already mentioned why we want to do
174:33 - that because we don't want
174:35 - javascript to keep reading the code now
174:38 - of course we have this one right now but
174:40 - hopefully you get to just where we need
174:41 - to go with return and then next and now
174:45 - of course i want to pass in my newly
174:48 - created error object
174:50 - and once i do that
174:52 - if we go back over here in the error
174:54 - handler and if we simply cancel log we
174:58 - should
174:59 - see our newly created error object so
175:01 - i'm going to go here with console.log
175:02 - and i'll look for my error
175:05 - and now let me go back to the postman
175:08 - and essentially what i want to do i want
175:09 - to get all the tasks
175:12 - and then i'll look for one of the ideas
175:14 - but again i don't want to get that cast
175:16 - error so i still want to keep the same
175:19 - structure i just want to pass in the
175:22 - wrong value so i'll look for single task
175:25 - i'll copy
175:26 - and paste and then instead of three i'm
175:29 - gonna go with four so once we send of
175:31 - course we get our custom error message
175:35 - as vague as it currently is
175:37 - and then of course in console i can
175:40 - clearly see that i have
175:42 - not found so of course that is going to
175:44 - be my message and i understand that it
175:46 - might be a bit confusing but effectively
175:49 - the idea is following where once we
175:50 - create this new our object that property
175:53 - is going to be on there so in order to
175:55 - access the string value we'll have to go
175:58 - over here and simply go with error and
176:01 - then that message and as far as the
176:03 - status well we can clearly see it here
176:05 - we're going to have 404 so now just for
176:08 - kicks what we can do
176:10 - is set up message is equal to error
176:14 - message like i said
176:16 - there's the property on that object and
176:18 - then as far as the status well i can
176:20 - simply change this one around where
176:22 - instead of 500 i'll pass in error and
176:25 - then status and don't worry of course
176:26 - there's more code coming and once i have
176:29 - applied these changes of course we can
176:31 - swing back to our postman and check it
176:34 - out now of course we have 404
176:37 - and then the message is not found so
176:40 - that's pretty cool
176:42 - now of course we just need to go back to
176:44 - the tasks
176:45 - and set it up in such a way where we
176:48 - don't have to do this all the time
176:50 - manually and the idea is following where
176:53 - again we'll create a new class a new
176:56 - custom error class
176:58 - and we'll extend it from the javascript
177:01 - error
177:02 - and then we'll create a new instance and
177:05 - yada yada and effectively the way we
177:07 - want to do that we want to create a new
177:09 - folder and i'll call this errors
177:12 - pretty self-explanatory so we're going
177:14 - to go here with new folders and
177:17 - we're going to go with errors and inside
177:19 - of it i'm going to create another new
177:20 - file and in this case i'm going to call
177:23 - this custom
177:24 - and hyphen error and of course i'm going
177:27 - to add the js extension
177:29 - and then instead of my custom error now
177:32 - i want to extend from the error class
177:35 - now here's the deal in this case i'll
177:36 - just write out the code and then i'll go
177:38 - line by line of what's happening because
177:40 - i think that's going to be a bit more
177:42 - productive so let's go here with class
177:44 - and then we just need to come up with a
177:46 - name in my case
177:48 - i'm going to go with the long one i'm
177:50 - going to say custom
177:51 - api
177:52 - and then error now we need to use the
177:55 - extends keyword and since i want to
177:57 - extend from the error class i'm going to
177:59 - go here with error and as far as the
178:01 - functionality we want to go with
178:03 - constructor and here we'll pass in
178:05 - message
178:07 - and status code
178:09 - and then inside the constructor we want
178:11 - to call super
178:13 - then pass in the message and right after
178:16 - i call super i'm going to go with this
178:18 - dot status code
178:21 - and i'll set that one equal to whatever
178:23 - i'm passing in the constructor so in
178:26 - here i'll pass e in the status code and
178:28 - as far as these few lines of code a
178:30 - constructor method is a special method
178:32 - we invoke when we create a new instance
178:35 - of a class
178:37 - and in our case we'll pass in two
178:39 - arguments an error message and a status
178:42 - code then since we're extending
178:45 - basically we're setting up a child class
178:47 - we need to call supermethod which in
178:50 - turn invokes a constructor of a parent
178:54 - class
178:54 - and in our case we pass in our message
178:57 - value
178:58 - as a result we'll have access to all the
179:00 - methods and properties of the parent so
179:04 - in our instance we'll have the message
179:06 - property and with this dot status code
179:09 - we create a status code property as well
179:12 - and that's how we can create our new
179:14 - custom error class and essentially if
179:17 - you want to create new instances you can
179:19 - simply go with custom and then api error
179:22 - and then pass in those two values the
179:24 - message and status code but i actually
179:27 - like to set up a new function that does
179:29 - that for me
179:30 - and here i'm going to go with const
179:32 - create
179:33 - custom
179:34 - and error and this function is going to
179:36 - be looking for two parameters a message
179:40 - and then a status code
179:43 - and what i'm going to do is from this
179:45 - function i'm going to return that new
179:48 - instance so i'm going to go to return
179:50 - new and then we're looking for custom
179:53 - api error and then of course we'll pass
179:56 - in the message here
179:58 - as well as the status code now of course
180:01 - if you want to keep the same parameter
180:03 - names you can definitely do so but in my
180:05 - case i'm purposely setting this up so
180:07 - you can see that this is coming from the
180:09 - function as far as the message and of
180:12 - course i pass e into my custom api error
180:16 - more specifically in the constructor as
180:19 - a message
180:20 - and then of course we just need to
180:22 - export this and we'll have to export
180:24 - both of them and you'll see in a second
180:26 - why so we're going to go with module
180:28 - exports is equal to an object and then
180:30 - we're looking for create custom error
180:32 - and then custom api error and once we
180:35 - have both once we have the class as well
180:38 - as the function and we're exporting both
180:41 - now of course we want to go to the tasks
180:43 - we just need to remember that of course
180:45 - we're exporting object
180:47 - so therefore we'll have to provide a
180:50 - specific name in our case i'm looking
180:52 - here for the function so i'm going to go
180:54 - with const i'll set up my curlies and
180:56 - i'll say create
180:58 - and then custom
181:00 - and error so of course that is my
181:02 - function set it equal to require i do
181:05 - need to go two levels up
181:07 - so in here we're looking for the errors
181:10 - and then more specifically i'm looking
181:12 - for the custom one
181:13 - and then i want to replace
181:16 - all of these three instances and of
181:18 - course i want to remove this manual code
181:19 - as well
181:20 - so start over here
181:22 - and then i'll keep this one for the
181:24 - second just because i want to reuse the
181:26 - same message and the idea is following
181:29 - where we go with return
181:32 - then next and then instead of the next
181:35 - we pass in create custom error
181:38 - and of course we want to pass in the
181:40 - message so that's why i'll just copy
181:42 - this one just because i want to speed
181:44 - this up
181:45 - and then the second thing is going to be
181:47 - my status code which of course is going
181:50 - to be 404 and now we can remove the
181:52 - second line
181:54 - and we just want to copy and paste
181:57 - so it's the same deal over here
182:00 - and the same in the update task as well
182:03 - and once we have all of this in place
182:05 - now we just want to go to error handler
182:08 - so our custom error handler and instead
182:11 - of looking for the function we're
182:14 - looking for the class because in here
182:16 - i want to check if the instance is equal
182:20 - to our customary one then of course i'll
182:23 - pass in the status code and the error
182:25 - message however if there is any other
182:28 - error then of course we'll just go with
182:30 - res.status 500 and whatever we had
182:33 - before so let me go at the top and i'm
182:36 - going to go with const again it is named
182:39 - import so we're looking for custom
182:42 - api and then error and that is equal to
182:45 - require
182:46 - and same deal we go two levels up we're
182:49 - looking for errors and more specific
182:51 - custom error
182:53 - and let's right away set up the default
182:55 - one and this one i'll set it back to 500
182:58 - here and then as far as the json let's
183:01 - go with the same message i'm just going
183:03 - to say something
183:04 - went wrong please try again
183:07 - and above this return we're going to go
183:08 - with if
183:09 - and then we'll check if the error is the
183:12 - instance of our custom api error
183:16 - then of course i want to go with return
183:19 - and i want to pass in the res dot status
183:23 - and then that will be equal to a error
183:27 - dot status code because of course that's
183:29 - where the value is sitting in that
183:31 - property and then when it comes to the
183:34 - actual message same deal i'm going to go
183:36 - with message and this will be equal to
183:39 - error and then we're looking for the
183:41 - message property and once we save let's
183:44 - go and test it out or essentially
183:47 - if i send it here from the postman of
183:50 - course i'll have no task with this id
183:53 - and if i'm going to mess with the syntax
183:55 - i should get the cast error which of
183:57 - course i do because i can clearly see
183:58 - that something went wrong please try
184:01 - again
184:02 - lastly let me just repeat one more time
184:05 - that error handling and validation
184:07 - is something we're going to return to
184:09 - later most likely in a separate project
184:13 - this is just a general setup just to get
184:16 - you comfortable with overall ideas and
184:19 - later we'll work on more complex
184:21 - validation and error handling approach
184:25 - nice i think we're done with error
184:27 - handling at least for now
184:29 - and now let's talk about deployment
184:31 - and right off the bat i want to say that
184:34 - we're not going to deploy this project
184:36 - simply because we have not covered
184:38 - authentication yet
184:40 - as well as extra packages for security
184:43 - and deploying the project where anyone
184:46 - can tinker with all the data is somewhat
184:49 - irresponsible
184:50 - and it actually can lead to a lot of
184:52 - headaches
184:53 - but with that said there is something
184:55 - deployment related i want to cover
184:58 - and that is our port variable
185:00 - you see hard-coded value like port 3000
185:03 - or 6000 or 7000 is decent solution in
185:07 - our local environment but when it comes
185:09 - to deployment in many environments the
185:12 - host so the platform where the project
185:14 - is hosted on may want to independently
185:16 - set the port value to whatever makes
185:19 - sense to the platform because as you can
185:21 - imagine it needs to handle more than
185:23 - just one application at the time
185:25 - and in order to make that possible when
185:28 - it comes to port value
185:29 - instead of hard coding to 3000 6000 or
185:33 - whatever we'll have to use the port
185:35 - variable that is available in
185:37 - process.env instead
185:39 - and setup or operator just in case it's
185:42 - undefined
185:44 - and in order to set that up we need to
185:45 - go to our port variable that's why in
185:49 - this case we set it up as a variable
185:52 - and then before d3000 we actually want
185:55 - to go with process
185:57 - and then dot env and then we're looking
186:00 - for the port variable so we go here with
186:03 - port and then if it is set then of
186:07 - course we'll use that value if not
186:10 - then we'll use the or operator and then
186:12 - of course we're going to go with 3000
186:15 - now of course in a local environment by
186:18 - default it's not going to be set so
186:20 - always go back to the 3000 however once
186:23 - we deploy it's going to be a different
186:25 - scenario now if you want to test it out
186:28 - in local environment you can actually do
186:30 - so and we do that by stopping the server
186:34 - and then we want to go with a port
186:36 - and we set it equal to whatever value
186:38 - you want now my case i'm going to go
186:40 - with 5000 because i believe my final one
186:42 - is using that so i'm going to go with
186:44 - 6000 and then you want to go with node
186:47 - and then what is the name of the file
186:49 - you want to run of course it is app.js
186:52 - and now check it out in a console we
186:54 - should
186:55 - see six thousand now of course i still
186:58 - see three thousand because i didn't save
186:59 - the file my apologies let me stop the
187:02 - server
187:03 - just so you don't think that i'm messing
187:04 - with you and let me run the command one
187:07 - more time and now of course in the
187:09 - console i can see server is listening on
187:13 - port 6000 and one more time as far as
187:16 - our logic we just say set port to
187:19 - whatever is the environment variable by
187:21 - the name of port
187:22 - or 3000
187:24 - if there's nothing there
187:26 - awesome congrats on completing the
187:28 - project and i'll see you next one all
187:30 - right and welcome to our next project
187:33 - the store api
187:34 - where we'll learn the advanced filtering
187:37 - sorting and dynamically populating our
187:39 - database as well as bunch of other cool
187:41 - stuff
187:42 - while i did not create the front end for
187:44 - this project just because it seemed like
187:46 - an overkill the idea is following
187:48 - imagine we're in charge of store api and
187:52 - we want to provide a bunch of search
187:53 - options for our users everything
187:56 - starting with search by name to
187:58 - filtering based on price amount
188:01 - since we'll cover all the options in
188:03 - great detail during the project i won't
188:05 - do it right now
188:07 - but i do want to showcase where i got
188:08 - the idea from and how that would look
188:11 - like in real life and it's probably not
188:13 - going to be surprised if i tell you that
188:15 - i got this idea from the hacker news api
188:18 - and if you remember they offer quite a
188:20 - few search options for their user now
188:24 - we're not going to implement all of them
188:26 - but we will mimic the major ones and as
188:29 - far as how it's going to look like in
188:30 - real life if you took my react course
188:32 - you probably worked on a store project
188:35 - and during that project we built the
188:37 - entire search functionality on a
188:39 - front-end
188:40 - now imagine once we're done building our
188:43 - api the front-end only needs to make
188:46 - http calls and we send back the data
188:50 - so the same result user can still search
188:52 - for products but only this time the
188:55 - backend does all the heavy lifting and
188:58 - frontend is only responsible for http
189:01 - calls so the user can still search for
189:04 - products whether that's based on name or
189:07 - category or company and of course you
189:09 - can read the rest
189:10 - but the difference is of course that now
189:13 - the front end only makes the http call
189:17 - and then the back end does all the heavy
189:19 - lifting and as far as the project setup
189:22 - again we've got two folders final one
189:25 - and starter one and of course the final
189:27 - one is for your reference and the
189:29 - starter one is where we'll do all of our
189:31 - work
189:32 - and just like in the previous project
189:34 - when it comes to final in order to run
189:36 - it you'll need to complete some extra
189:38 - steps first not just npm install
189:42 - and of course i'll cover all that during
189:44 - the project as far as the starter most
189:46 - of the things should look very familiar
189:48 - since we covered them in the tutorial as
189:52 - well as the previous project
189:53 - and you'll also notice that in order to
189:56 - save some time on a boilerplate
189:58 - i already prepared a folder structure
190:01 - for you
190:02 - now when it comes to files
190:04 - most of them are empty since that's
190:06 - going to be our job during the project
190:08 - but the folders are already there while
190:11 - i understand that some people like
190:12 - creating everything from scratch since
190:14 - we're going to be building quite a few
190:16 - projects in my opinion there's very
190:18 - little benefit to repeat all the steps
190:21 - every single time
190:23 - all right and once we're familiar with
190:25 - the setup now let's kick things into
190:27 - gear
190:28 - and of course let's start working on a
190:30 - project and the first thing we need to
190:32 - do
190:33 - is install all dependencies
190:36 - and we do that by navigating to the
190:37 - starter so again big picture we're
190:40 - looking for
190:42 - fourth project
190:43 - so zero for store api and then more
190:47 - specifically the starter
190:49 - and i think the fastest way is just
190:51 - typing cd
190:53 - and then take the folder
190:55 - drag and drop and of course we're
190:57 - sitting in the folder
190:58 - and then we run npm
191:01 - install
191:02 - and while the project dependencies are
191:04 - being installed let me just mention that
191:06 - in this project we will set up
191:09 - everything from the scratch just like we
191:11 - did in the previous project
191:13 - just so we can keep on practicing on
191:15 - getting our project off the ground but
191:18 - starting with the next project
191:20 - some of the boilerplate code the one
191:22 - that we'll type in this and few of the
191:24 - following videos will be already
191:26 - prepared for you since that way we can
191:29 - right away cut to the chase
191:31 - and don't waste our time on stuff we
191:33 - already covered
191:34 - and once the dependencies are there then
191:36 - of course i just need to check the
191:38 - package.json and i can clearly see that
191:40 - the command is
191:42 - npm start and of course we just spin up
191:45 - the nodemon so we go here with npm start
191:48 - and we are in good place now of course
191:51 - let me navigate to the app.js
191:54 - and here let's start adding the code
191:56 - and the first thing that i want to do is
191:58 - get that package in the env so i have
192:01 - access to environment variables because
192:03 - of course again we'll connect to our
192:05 - database and we simply do that by typing
192:08 - require then we're looking for dot env
192:11 - that's package name and if you remember
192:14 - we invoke config now of course we
192:17 - haven't set up the env yet the file e in
192:20 - the root of our project but we
192:22 - definitely need to use the dot env
192:24 - if we want to access the variables and
192:26 - of course we'll work on that envy once
192:28 - we actually start connecting to the
192:31 - database then i'll add a comment of
192:34 - async errors
192:36 - and you'll see why i do that in a few
192:38 - videos and then of course we want to
192:40 - spin up the express so we go here with
192:42 - const and express is equal to express of
192:46 - course so i go here with require and
192:49 - then express
192:51 - and then once i have the package then of
192:52 - course we want to spin up the app so we
192:55 - go const app is equal to express and
192:58 - then of course we invoke it now i'll
193:00 - start listening for the server a little
193:02 - later
193:03 - now i just want to import two middleware
193:05 - functions that we set up e in the
193:07 - previous project and those are error
193:09 - handler so this one over here
193:12 - more essentially we just catch all the
193:14 - errors and then we decide what is going
193:16 - to be our response and then the second
193:18 - one is not found because this is going
193:20 - to be the case where i don't want to
193:22 - repeat the same stuff we already covered
193:25 - in the previous project
193:27 - so that's the code that i already
193:28 - prepared for you and now we simply need
193:31 - to import both of them and come up with
193:33 - some meaningful names
193:35 - in this case i'm going to go with not
193:36 - found
193:38 - and then middleware
193:39 - and that is equal to require and of
193:42 - course i'm looking in the middle or
193:44 - folder
193:45 - and then more specifically we're looking
193:47 - for that not found one then we'll copy
193:50 - and paste and then just change the name
193:52 - where instead of not found we're gonna
193:55 - go with error and of course the file
193:57 - that we're looking for is also different
193:59 - and i called it error handler and once
194:02 - we have both of these imports in place
194:04 - now of course we can set up the express
194:07 - json middleware as well while we're at
194:09 - it and you know what in here let me just
194:12 - add middleware comment and then like i
194:15 - said we're going to go with app.use and
194:18 - then we'll pass in the express
194:20 - and we're invoking json then we'll set
194:23 - up our one lonely route for time being
194:26 - and essentially this is just for testing
194:28 - so let me add here routes eventually of
194:31 - course we'll set up the router and all
194:34 - that but for time being we're just gonna
194:35 - go with app.get we're going to be
194:38 - looking for the home page meaning the
194:40 - forward slash and then we'll set up rec
194:42 - and res so of course our callback
194:45 - function and here let's say rec and res
194:48 - and as far as the response i'm actually
194:50 - going to be cheating a little bit where
194:52 - i'm going to go with res.send
194:54 - and then since i can pass in some html
194:57 - i'll say heading 1
194:59 - and name of the project store api
195:02 - and of course now i want to close my
195:04 - heading 1 and then also i want to set up
195:07 - a link
195:08 - that will navigate to the products page
195:12 - the one that we haven't set up yet
195:14 - and here let's just go with ahref and i
195:16 - guess more correctly the product route
195:19 - because technically we'll be sending
195:21 - json it's not going to be a page and
195:23 - here we go with forward slash api and
195:26 - then version one products
195:29 - and i'm purposely keeping this api in
195:31 - version one just because we already have
195:33 - the global variable in a postman and
195:36 - then as far as the text let me just
195:39 - close it here and then close the actual
195:42 - tags
195:43 - and then we'll say product route so that
195:46 - way if we ever need to we can just
195:48 - quickly
195:49 - navigate from the browser as well so
195:52 - let's save this one and let's keep it
195:54 - going and in here i'll add a comment for
195:58 - product
195:59 - route that we'll set up in the upcoming
196:02 - videos and then i want to use both of
196:04 - these middlewares so we have not found
196:06 - an error middleware and i simply want to
196:09 - use app.use but make sure you do that
196:12 - right after the app.get so we'll say
196:15 - here app.use and first let's just look
196:18 - for not found one and then we'll do the
196:20 - same thing with the other one as well so
196:23 - pass here error middleware then i want
196:25 - to set up my start function
196:27 - but initially i'm not going to use that
196:29 - connectdb so simply just go with
196:32 - app.listen but we'll place it in a start
196:35 - because of course eventually we will
196:37 - connect to the database so let's just
196:39 - start over here start
196:40 - and it's going to be async
196:43 - and then as far as the function body
196:44 - let's just go try catch
196:46 - and then eventually we'll connect to db
196:50 - connect db but for time being we just
196:52 - simply want to go with app.listen
196:55 - and then what is the port well we need
196:57 - to create that port variable
196:59 - and if you remember the end of the
197:01 - previous project effectively we'll set
197:03 - this up dynamic where we'll go with
197:05 - const port is equal to
197:07 - process
197:08 - dot env online port if it is undefined
197:12 - then of course we can hard code this
197:14 - value
197:15 - and i believe that in my final one i
197:18 - have 5000 so i'll keep this one as 3
197:22 - 000.
197:23 - and then we'll pass in that variable
197:25 - here the port one and then of course
197:27 - let's set up the console.log just so we
197:28 - can see that everything works
197:30 - and here we'll just say server
197:33 - is listening
197:34 - to the port and then whatever
197:37 - is the port variable
197:38 - so let's say you're here
197:41 - port
197:41 - and then i'll add those three dots and
197:44 - then if there's an error of course we'll
197:45 - go with console.log and the error and
197:48 - now finally we can just invoke start
197:51 - and if you can see in a console
197:54 - server is listening on port 3000 then of
197:57 - course we are in good shape and if you
197:59 - want to test it out in the browser just
198:01 - navigate there look for localhost 3000
198:05 - and of course this is what you should
198:06 - see the hearing one as well as link now
198:10 - we don't have the route for api version
198:13 - one product but we can nicely test r404
198:16 - since we can see the route does not
198:19 - exist text and if we have all this in
198:23 - place now of course we can move on to
198:25 - our next topic and once our basic
198:27 - express server is up and running next i
198:31 - want to connect to our database
198:33 - and if you remember we just need to
198:35 - navigate to the atlas
198:37 - and then we're looking for connect
198:39 - so that is going to give us that
198:41 - connection string and of course we'll
198:43 - have to supply here the proper values so
198:47 - let me just grab this one
198:49 - then we're going to navigate back to our
198:51 - project and of course i'll right away
198:53 - set it up in dot env so in the starter
198:57 - make sure it's in root we're going to go
198:59 - with new file and then we go
199:02 - dot env here and then once we have the
199:06 - file then of course we want to create a
199:08 - new variable and since it is a common
199:10 - practice to call this uri we'll do
199:13 - the same where we'll say
199:15 - underscore uri is equal and now of
199:18 - course we copy and paste
199:20 - now as far as the database i'm gonna
199:22 - call my one zero four and then store api
199:26 - essentially the same as the project name
199:29 - but sky's the limit you can choose a
199:32 - different name of course as well and
199:34 - then as far as the password since i
199:36 - changed from my silly one two three four
199:39 - now of course i'll freeze the video so
199:41 - you don't see what is my real password
199:44 - and then once you add your own password
199:47 - then make sure that you save dot env
199:50 - that's a must then we want to restart
199:52 - the server so in my case i'll stop the
199:55 - server with control c and then again we
199:57 - go with npm start and then once
200:01 - everything is in place now of course we
200:03 - just need to go back to
200:05 - app.js and i just want to showcase that
200:08 - of course the function is already there
200:11 - so the only thing you'll need to do
200:13 - is just to invoke it in appdress of
200:16 - course you need to require it and then
200:18 - pass in the connection string with
200:20 - proper values and since we already
200:22 - covered all of this setup in the
200:25 - previous project essentially there's
200:27 - really nothing new that we can learn
200:29 - over here i already prepared all the
200:31 - code so we simply need to grab this
200:34 - function
200:35 - and then pass in the correct connection
200:39 - string so let's go back to app.js and i
200:42 - guess we'll do that somewhere at top so
200:45 - right after app and before the
200:47 - middleware we're just going to go with
200:49 - const and again i'll name it exactly the
200:51 - same connect db and that one is equal to
200:54 - require we're looking in the database
200:57 - folder and then more specifically we're
200:59 - looking for connect
201:01 - now this function of course returns a
201:04 - promise that's why we set up start with
201:08 - our sync
201:09 - and then right above the app.listen i'm
201:12 - just going to go with await connect db
201:15 - and then of course i'm looking for my
201:17 - variable the one that's coming from the
201:20 - dot env and i simply go here with
201:22 - process and then dot env and then of
201:26 - course the variable name was
201:28 - uri and if you see in a console server
201:31 - is listening on port 3000 then of course
201:34 - we are in good shape and we can move on
201:37 - to our next task and once we have
201:39 - successfully connected to the database
201:42 - next i want to set up two routes for the
201:44 - product
201:45 - and you'll see why we have two routes
201:47 - essentially the idea is that one of them
201:50 - the first one
201:51 - is just going to be for manual testing
201:54 - and then since i want to keep on
201:56 - practicing on setting up the router
201:59 - we'll do just that and up here i can
202:01 - notice that i actually have a spelling
202:03 - bug
202:05 - or this should be route and then right
202:07 - after the home route i'll set up my
202:09 - router and i'll do that using add.use
202:13 - and then i just need to come up with
202:14 - that base path or root path for the
202:16 - router and in my case like i already
202:19 - mentioned i'm gonna go with api
202:21 - version one and this is gonna be looking
202:24 - for the product and like i mentioned
202:27 - when we're setting up this route i
202:28 - simply add this api in version one
202:30 - because that way it's easier in postman
202:34 - since we already have that global
202:36 - variable and effectively in here we want
202:38 - to pass in the router
202:40 - but in order for the router to work of
202:42 - course we'll have to set up the
202:44 - controllers as well therefore we'll
202:46 - start in the controllers the file is
202:48 - already created for you and the name is
202:50 - product
202:51 - and for time being we'll simply set up
202:54 - two functions and we'll just send some
202:58 - dummy data back
202:59 - and two functions are going to be
203:00 - following we're going to go with const
203:03 - get all
203:04 - products and the first one i'll call
203:06 - static now this is going to be async
203:09 - since of course we will use the methods
203:12 - that we have on the mongos
203:14 - and here let's look for rec and res of
203:17 - course and then as far as the function
203:19 - body for time being simply want to go
203:22 - with res dot status
203:24 - and i'll set it equal to 200 and then as
203:27 - far as the response i'm going to go json
203:30 - and then instead of the json i'll pass
203:32 - in the object and in here there's going
203:33 - to be a message property and then we'll
203:36 - just write products
203:38 - testing route now let me copy and paste
203:41 - this
203:42 - and then we just want to remove that
203:43 - static part
203:45 - and we also want to remove the testing
203:47 - one so this is going to be actual route
203:50 - and then of course we can export this so
203:52 - let's go with module exports and this is
203:55 - going to be my object and here i simply
203:57 - want to pass in both functions so get
203:59 - all products and get all products static
204:03 - so we set this up then of course we need
204:06 - to navigate to our routes so in here
204:09 - this is where we'll set up our router
204:11 - and then we'll start by getting the
204:13 - express so const express
204:16 - is equal to require
204:18 - and then we want to pass in the express
204:20 - of course again and then once we have
204:22 - that let's set up the router and if you
204:24 - remember the syntax is following where
204:26 - we go with router and then we go with
204:28 - express
204:29 - dot and then with the capital case we go
204:32 - with the router and then of course we
204:34 - invoke it
204:35 - then i want to import both of these
204:37 - functions from my controllers and i'll
204:40 - right away use the structuring so go
204:42 - with const and then the name is get all
204:45 - product of course and then get all
204:47 - product and we'll add a static one and
204:50 - that is equal to require
204:52 - then we're looking in controllers and
204:54 - then of course the file we're looking
204:55 - for is the product
204:57 - and then if you remember we have
204:59 - multiple options and in this case i'm
205:01 - going to go router route and then i'll
205:04 - go with forward slash so essentially
205:06 - this is going to be
205:09 - for that main route here the api version
205:12 - one and product
205:15 - and as far as which controller i want to
205:17 - use i'll use this get all products and
205:20 - please don't mix them up again the
205:22 - controller you want to pass in is
205:25 - get all product
205:27 - and as far as the static one let's copy
205:29 - and paste and then we'll just add that
205:31 - here at the end so this is going to be
205:34 - our main path or root path and then
205:36 - we're going to go with forward slash
205:38 - static and this is where we want to pass
205:41 - in that get
205:42 - all product static
205:44 - and then once we have this setup in
205:46 - place now of course we just need to
205:48 - export this so look for module exports
205:52 - and of course we'll export our router
205:54 - and once we have set up the routes then
205:57 - of course let's just finally navigate
206:00 - back to the app.js of course we do want
206:03 - to import that
206:04 - and come up with some kind of name and
206:06 - in my case i'm going to do that right
206:08 - after the connectdb and we'll just say
206:10 - const and i'll name this product
206:14 - router and that is equal to require and
206:16 - then i'm looking in the routes folder
206:19 - and then more specifically you want to
206:21 - get the product
206:23 - and then let's keep on scrolling and
206:25 - where we have app.use
206:28 - for our middleware now of course we'll
206:30 - pass in our router so let's just say
206:33 - here
206:34 - products and router and once we save
206:38 - i'll spin up the server one more time
206:40 - and if you want to test this out let's
206:43 - just navigate
206:44 - back to the browser so i think you can
206:47 - close this one
206:48 - and then
206:49 - at the moment it says route does not
206:52 - exist but once we refresh
206:54 - check it out of course now we have
206:56 - message
206:57 - product route beautiful and then if we
207:00 - want to test out the static one well we
207:02 - have product testing route and once we
207:05 - have all of this in place now of course
207:07 - we can move on to our next task and
207:10 - since we have both of our routes in
207:12 - place i think it's an awesome time to
207:14 - actually set up a new collection e in a
207:17 - postman and of course set up those
207:19 - routes as well so in here i'm just gonna
207:22 - save pretty much everything from the
207:24 - previous project
207:26 - close all the tabs here i'll say yep
207:28 - save changes and what i'm looking for of
207:31 - course is the new collection so i'll say
207:33 - here new collection then i'll right away
207:36 - rename it
207:37 - and i guess i went for edit should i
207:40 - went for rename
207:42 - and then we're gonna go with or at least
207:45 - i'm gonna go with zero four and then
207:47 - store
207:49 - and then api
207:51 - and then in here we'll set up two routes
207:53 - basically one for the product the api
207:56 - version one and then product and the
207:58 - second one for the static one so at this
208:02 - point i think i can close these tabs
208:04 - here and we're looking for new request
208:06 - now both of them are gonna be get
208:08 - requests
208:09 - so let's go over here url
208:12 - and then we want to go with double
208:14 - curlies and then we're looking for the
208:16 - products
208:17 - let's send
208:18 - and check it out of course we have
208:21 - product route beautiful again save as or
208:25 - you can simply click on command s
208:28 - and this is going to be get all
208:31 - products okay awesome we're looking for
208:34 - store api let's save it over here and
208:36 - now let's just add that static one as
208:38 - well and i'll do that by opening up a
208:40 - new tab again same thing get route and
208:44 - then we're looking for the url one
208:46 - and then once we have the url
208:49 - uh the products and then of course the
208:51 - static one as well
208:53 - so static here let's send because now we
208:55 - have product testing route and as far as
208:59 - the name
209:00 - i'll just call it that i'll say
209:03 - get all
209:04 - products
209:05 - but i'll say testing
209:08 - and once we have both routes in place
209:10 - now of course we can move on to our next
209:12 - topic
209:13 - and once the postman is ready to go
209:15 - and before we deep dive
209:17 - into the mongoose now let me showcase
209:20 - something in our application
209:23 - where if you take a look at the
209:25 - middleware you'll notice that
209:28 - there is no async wrapper
209:30 - and if you remember we needed to use
209:33 - something
209:34 - either we set up try catch pretty much
209:37 - in every route correct or of course the
209:41 - other option was using that async
209:43 - wrapper
209:44 - but when we were setting it up i also
209:46 - mentioned that there are packages that
209:48 - do that for us and that's why if you
209:51 - take a look at the package json you'll
209:53 - notice package the express
209:56 - async errors and essentially the only
209:59 - thing we need to do is just go back to
210:01 - app.js and then where we have a comment
210:05 - for async errors
210:07 - just import the package that's it that's
210:09 - all you have to do so let's go over here
210:11 - acquire and then of course we're looking
210:13 - for the package name of express async
210:16 - errors and just to stay on the safe side
210:18 - i'll stop the server
210:20 - and i'll spin it up one more time
210:23 - and now you'll notice that if i go back
210:25 - to the product one
210:27 - and or i'm sorry the products in the
210:30 - controller i'm actually going to close
210:32 - the routes i don't think we'll need that
210:33 - anymore as well as the app.js we're
210:35 - pretty much
210:36 - done over here and then if in any of the
210:40 - controllers you'll go here and throw the
210:43 - error which you'll notice that will
210:45 - actually be able to access that error in
210:48 - our custom error handler and essentially
210:50 - what that means is that whenever
210:53 - mongoose
210:54 - is going to spit back that error unlike
210:57 - the previous time where initially we set
210:59 - up trying catch and then we built our
211:01 - own async wrapper in this case the
211:04 - package takes care of that so in here
211:06 - let me just go throw
211:08 - and i'll call this new error
211:10 - and i'll say testing package or testing
211:13 - async errors whatever you want testing
211:16 - async
211:17 - errors
211:18 - and just to showcase that in the error
211:21 - handler i have the console log for the
211:24 - error and of course in here i'm sending
211:26 - back some kind of hard-coded message so
211:29 - first what i want to do is from the
211:31 - postman navigate to my static one just
211:35 - to showcase that of course we are
211:37 - catching those errors nicely with our
211:39 - package and then i'll cover the package
211:42 - in more detail so let me go back to the
211:45 - postman
211:46 - unfortunately it's all the way on the
211:48 - left-hand side so there's a little bit
211:49 - of jumping here and i'm looking for the
211:51 - static one i simply wanna invoke the
211:54 - route and now check it out something
211:56 - went wrong please try again and if i
212:00 - navigate back
212:01 - all the way here in the bottom i should
212:04 - see error testing async errors and if
212:08 - you're interested in finding out more
212:10 - about the package just go to google and
212:13 - type express async errors and of course
212:16 - one of the links is going to lead back
212:18 - to their docs and effectively if you
212:20 - want to use it in your own project just
212:22 - go with npm install express async errors
212:27 - then we keep on scrolling and notice how
212:29 - the only thing we need to do is to
212:31 - require it and then we're good to go now
212:34 - one thing you probably noticed that i
212:36 - did not use next and essentially the
212:39 - reason why i didn't do that is because
212:41 - if you read their docs they say that
212:44 - instead of using next we simply need to
212:46 - throw a error and of course since i can
212:49 - see the error in the console that means
212:51 - that i am getting that error in my
212:54 - custom error handler so the
212:56 - functionality still works so long story
212:59 - short instead of setting up try catch
213:02 - instead of setting up our own middleware
213:05 - we effectively just used a package that
213:07 - does all the work for us and as a result
213:10 - we can eat and have our cake too meaning
213:14 - we get the benefits of just using
213:17 - asynchronous code and we don't need to
213:19 - worry about setting up try catches or
213:23 - our own middleware and the package name
213:25 - that does that for us is a sync express
213:29 - errors and we simply need to require it
213:32 - in the app.js and once we have discussed
213:35 - async errors
213:37 - next let's set up the model
213:40 - and before we go anywhere let me just
213:42 - mention that i will keep this console
213:43 - log just because i want to showcase some
213:46 - stuff here and there but of course
213:48 - if you don't want it you can just remove
213:50 - it or you can maybe pass in the error
213:54 - over here where you have the message
213:56 - like we did in a previous project that
213:59 - is totally up to you
214:00 - now let me just navigate to complete
214:02 - project and you know what i'll make this
214:04 - one all the way on the left
214:06 - and what i want to showcase is that of
214:09 - course we have the products
214:12 - and what do the products have well they
214:14 - have some kind of properties correct now
214:16 - featured rating created that and of
214:19 - course you can read the rest
214:21 - and in order to set it up what are we
214:23 - going to need we will need a schema
214:26 - correct and using schema we'll set up a
214:29 - nice structure for our data and we
214:32 - already know how to do that
214:33 - so of course we just need to create a
214:36 - model and therefore we'll right away
214:39 - have a
214:40 - models folder and in there we just have
214:43 - the empty product js and in here we need
214:46 - to start by getting the mongoose
214:48 - and of course i'm looking for my
214:50 - mongoose package so we go here with the
214:52 - require
214:53 - and we're looking for the mongoose then
214:56 - we want to go with our schema
214:58 - and i'm going to call this product
215:00 - schema so that's going to be the
215:02 - structure for my product and i'll set it
215:04 - equal to new mongoose
215:07 - and then of course i'm looking for to
215:09 - schema
215:10 - and then in here we want to pass in the
215:12 - object and this is where we'll set up
215:14 - the properties so this is going to be a
215:16 - good refresher on how we can set up the
215:19 - properties as well as the validations
215:22 - and the properties i want to set up are
215:24 - following i want to first go with name
215:26 - and now we'll have a type
215:28 - of string
215:30 - then we want to go with required and
215:32 - remember we had multiple options and one
215:34 - of them was setting this up as an array
215:37 - and the first values of course is going
215:39 - to be true or false and then the second
215:41 - one will be that custom error message
215:44 - and here we go with product name must
215:47 - must be provided
215:49 - and then in order to save a little bit
215:51 - of time i'll just grab this whole thing
215:54 - copy and paste at least once and then
215:57 - the second property i want to set up is
215:59 - the price and of course this will be a
216:02 - number
216:03 - so let's go over here
216:04 - say number and then as far as the error
216:07 - message let's just say product price
216:10 - must be provided after that we want to
216:13 - set up a feature property
216:15 - and we simply do that by going with
216:17 - featured that's the name of the property
216:19 - again we'll set it up as an object and
216:22 - then type is going to be equal to our
216:24 - boolean and then by default we'll just
216:26 - say that all the products are not
216:28 - featured so that way of course we don't
216:30 - need to worry about whether the product
216:32 - is featured not we simply set all of
216:35 - them as false then we want to go with
216:38 - rating now of course if you do provide
216:40 - featured as true then of course it will
216:42 - be featured but by default all of them
216:44 - will be false hopefully that is clear
216:47 - then we want to go with rating and now
216:49 - we'll be equal to a number so we're
216:52 - going to go here with type
216:54 - number and let's just say that as far as
216:56 - default value it's going to be 4.5 again
217:00 - if the number is provided of course that
217:02 - value will be set up as far as the
217:05 - rating but
217:06 - if there is no number then there is a
217:08 - default value
217:10 - and then we want to go with created at
217:12 - so essentially this is just going to be
217:15 - a date when this product was created
217:19 - and what's really cool that in mongoose
217:21 - we can use date type and we can actually
217:24 - set the current time and we do that by
217:27 - creating the property created at we set
217:30 - it as an object and then instead of the
217:32 - object let's go with type and then date
217:35 - and then if we want to set up the
217:37 - current time we simply go with default
217:39 - and then we go with date dot and then we
217:43 - invoke now so now of course every time
217:45 - we'll create that new product if we
217:48 - don't supply the created ad by default
217:52 - is just going to be a current time and
217:54 - then we have company and company is a
217:57 - little bit interesting
217:58 - where essentially if you take a look of
218:00 - course we have the name for the company
218:03 - but when you're adding the products what
218:06 - we want to do is set up some kind of
218:09 - guardrails where we can only provide
218:11 - specific companies
218:13 - and if you're interested how that would
218:15 - look like in a real project so imagine
218:17 - the scenario you have the product and
218:19 - then as far as the companies these are
218:22 - your possible values that's it it's not
218:24 - like i'm just gonna randomly add here
218:27 - trader joe's or lucky donuts or
218:29 - something along those lines
218:31 - and the way we can set that up in
218:33 - mongoose is following where we need to
218:35 - go with company here and of course i'll
218:38 - set it up as an object then as far as
218:41 - the type yes it's going to be a string
218:44 - but if i want to limit the possible
218:47 - options
218:48 - for this property then we go with enum
218:51 - property and then in this array we
218:54 - provide those options and in here of
218:56 - course you can provide whatever values
218:58 - you want now i strongly suggest
219:00 - adding the same values as me because in
219:03 - the next video we'll dynamically
219:06 - populate our database and if your values
219:08 - will differ then of course you might get
219:10 - the bugs and companies that i chose are
219:13 - following
219:14 - so i went with ikea
219:17 - or in some places in the world they're
219:19 - also called ikea which is very very
219:22 - weird and then let me check the other
219:24 - ones so i have this one then let's keep
219:26 - scrolling i have this one
219:29 - and you know what in order to avoid
219:31 - confusion i'm just gonna avoid actually
219:35 - pronouncing them
219:36 - then we have this one
219:39 - and then let's add a comma again copy
219:41 - and paste and of course in here i added
219:44 - those double quotation marks which is
219:45 - probably not something i want and then i
219:47 - have the last one let's keep on
219:49 - scrolling this one over here
219:51 - so those are the four values that i
219:54 - chose and again for your own project you
219:56 - can set it up however you would like but
219:58 - since we'll be adding those products
220:01 - dynamically in the next video so we
220:03 - don't need to add them one by one i
220:05 - strongly suggest using the same values
220:08 - now what's also really really cool
220:10 - is the fact that we can set up a custom
220:14 - error message
220:15 - if the value doesn't match any of these
220:19 - items in the list and the way we do that
220:22 - is actually following where i'll comment
220:24 - this out just so it stays for your
220:26 - reference and we actually set it up as
220:28 - an object here and then as far as the
220:31 - possible values we go with values
220:34 - property and of course we still use the
220:36 - same values and when it comes to custom
220:39 - error message we go with message and
220:42 - then in order to access the value that
220:45 - the user is providing meaning the one
220:47 - that is coming in with a request
220:50 - the syntax is following where we go with
220:52 - curlies and then value so essentially
220:55 - that will access whatever the user is
220:58 - providing and then we want to go with
221:00 - some kind of message and in my case i'm
221:02 - just going to say is not
221:05 - supported and once we save we have our
221:07 - schema ready to go so now of course we
221:10 - just want to set up our model so we're
221:12 - going to go here module export
221:14 - and we'll set it equal to mongos
221:18 - model
221:19 - and then as far as the name i'm going to
221:21 - go with
221:22 - product
221:23 - and then i want to pass in my schema
221:25 - which of course is the product schema so
221:29 - product schema over here and once we
221:31 - save we're ready to move on to our next
221:34 - task
221:35 - and once we have our schema and model in
221:38 - place
221:39 - before we can start setting up any kind
221:41 - of functionality of course we need to
221:43 - have data
221:44 - otherwise how you're going to set up any
221:47 - kind of filtering if you have no product
221:50 - in a database and effectively we have
221:53 - two choices you either can set up a post
221:57 - route and then just manually add them
222:00 - or a better approach is just to automate
222:03 - this
222:04 - and essentially just have some kind of
222:06 - list and pass it on to your database now
222:09 - lucky for you
222:10 - if you take a look at our project you'll
222:12 - notice the product json
222:16 - and essentially this is just a list of
222:18 - products just so we can start working on
222:22 - the filter functionality and the only
222:24 - thing we need to do is set up populate
222:27 - js
222:28 - where we'll dynamically add all of these
222:31 - values to our database so instead of
222:34 - going to manual route we're one by one
222:37 - we add them we'll right away just add
222:40 - them to our database by actually
222:42 - invoking the populate.js and the way
222:45 - it's going to look like we're going to
222:47 - go over here we'll first grab our dot
222:50 - env so let's say over here dot env then
222:54 - we want to go with config
222:56 - and then what's really interesting that
222:58 - we need to have another connection so
223:01 - yes we have one for app.js of course
223:04 - that still stays the same but since we
223:06 - want to connect to the database one more
223:08 - time we'll have to grab that connect
223:12 - function as well
223:13 - and here i'm just going to go const
223:16 - connect
223:17 - db because that is coming from where
223:20 - that is coming from our db folder
223:23 - correct so we go here with db
223:25 - and then more specifically connect
223:27 - that's the first thing we want to grab
223:29 - then we want to grab the model and
223:31 - you'll see why and we just need to come
223:33 - up with the name in my case i'm going to
223:34 - go with product
223:35 - and then of course we're requiring that
223:38 - it is coming from the models
223:41 - and then more specifically product
223:44 - and then lastly i want those json
223:46 - products
223:47 - because that's the data that i'm going
223:49 - to be passing on to the database so here
223:52 - we need to come up with the name in this
223:54 - case i think i'm going to go json
223:55 - product
223:56 - and we'll set it equal to require
223:59 - and where the file is actually sitting
224:01 - right next to us so just go with forward
224:04 - slash and then we're looking for product
224:07 - json and once we have
224:09 - all of this in place we want to set up
224:12 - that start function one more time
224:14 - however in this case of course we're not
224:16 - going to be setting up app.listen we
224:18 - simply want to connect to the database
224:20 - and then use the model to automatically
224:24 - add those json products the one that we
224:27 - have in the file to our database and the
224:31 - way it's going to look like we're going
224:32 - to go here with const and start
224:35 - and we'll set it equal to a sync
224:38 - and in here we'll set up another try
224:40 - catch like so so let's go try catch and
224:44 - of course eventually we'll invoke it
224:46 - here as well
224:47 - and then i want to go with my await
224:50 - then we want to pass in the connectdb
224:53 - and of course inside of the connectdb
224:55 - we'll pass in the process
224:57 - dot env and of course our variable so
225:00 -  and then underscore uri
225:04 - and just because i want to see whether
225:06 - we're going to get some weird bugs i'm
225:09 - also going to type in the catch a log
225:13 - so go over here with log and then we're
225:15 - going to be looking for the error and
225:17 - once we have all this in place we can at
225:19 - least try the connection now there's
225:22 - still some code that's missing but we'll
225:24 - get to it in no time so first what i
225:26 - want to do is stop the server over here
225:30 - and then we just want to go with the
225:33 - start invoke it and then in this case
225:36 - i'm not looking for nodemon i'll simply
225:38 - go with
225:39 - node and then of course i'm looking for
225:41 - the filename so since i'm already in a
225:43 - starter i just need to write populate
225:46 - and then once we run it
225:48 - if our connection again is successful we
225:51 - shouldn't see any errors in the console
225:54 - now if you want to help yourself out of
225:56 - course you can just type here log
225:58 - and let's just say success or something
226:00 - along those lines so let's say here
226:02 - success
226:04 - and an exclamation point let's save it
226:07 - one more time again let's stop it and if
226:09 - you remember from tutorial in order to
226:11 - go back to the last command we simply
226:14 - press arrow key up or down in micros i'm
226:16 - going to press it down and check it out
226:19 - now of course we have the success so we
226:21 - successfully connected to the database
226:23 - now if i want to check out the error
226:25 - i'll comment out the dot env stop the
226:28 - server one more time sorry about the
226:30 - detour but these things are important
226:32 - and then once we run it of course we're
226:34 - not successful connecting to the
226:36 - database because
226:37 - the uri parameter is not provided
226:41 - awesome so let me uncomment the env
226:44 - then clear everything and once we have
226:46 - successfully connected to our database
226:49 - there's two things that i want to do
226:51 - first
226:52 - i want to remove all the products that
226:55 - are currently there
226:57 - and then i want to use the create and
226:59 - just pass e and the json product so if
227:02 - you remember in a previous setup and i
227:05 - think i'm just going to go for final
227:07 - and let me look for controllers and
227:09 - tasks notice here this create we passed
227:12 - here a object correct when we were
227:15 - creating that task
227:17 - now what we can also do is pass in the
227:20 - array so if you take a look at the
227:22 - product
227:23 - and i'm sorry not this one products json
227:26 - you'll notice that this is an array at
227:29 - the end of the day and then since this
227:31 - is an array what i can do i can just
227:34 - pass this in
227:35 - into the dot create
227:37 - and then by doing so of course i'll add
227:41 - all of these products to our database so
227:44 - let's try it out let me navigate to the
227:47 - populate one
227:48 - i have the json product i'm in good
227:51 - shape so now let me go below the await
227:54 - but before the success
227:56 - and in here i want to go with await now
227:59 - i'm not waiting for the actual response
228:01 - and i want to go with my model
228:04 - because model has all those functions
228:07 - and then we want to go with delete many
228:09 - so now i just want to remove all the
228:11 - products that are currently there of
228:13 - course
228:13 - in our case there are no products but
228:16 - i'm just making sure that later if you
228:18 - want to reuse it then whatever gibberish
228:21 - you added or whatever data you currently
228:23 - have you just remove it and then you
228:26 - start from scratch this is technically
228:28 - optional if you don't want to do it you
228:30 - don't have to but in my case i always
228:32 - like to start with scratch and then we
228:34 - want to go with a weight
228:35 - and then product
228:37 - product and then remember the function
228:39 - create so now we're just dynamically
228:42 - creating a bunch of product by passing
228:44 - in json products that's all we have to
228:47 - do here we go with json product
228:50 - and now let's try it one more time and
228:52 - then of course we'll double check in our
228:54 - application so in here i'm going to go
228:56 - back to my console and then i want to go
228:59 - with node and populate and if i'll see
229:02 - the success then i know that i'm heading
229:05 - in the right direction so now let me
229:07 - just go back to my atlas one let me
229:10 - refresh
229:11 - and now where i have my collections i
229:14 - should have more values
229:17 - and effectively i have the store api
229:19 - awesome and in here i have of course all
229:23 - the products now i'm not sure how many i
229:25 - set up it really doesn't matter if you
229:27 - see these products added to your
229:29 - database now of course we can start
229:31 - finally setting up our filter
229:34 - functionality
229:36 - and while we're still on topic actually
229:38 - no there is a method by the name of exit
229:42 - now why that would be useful in our case
229:44 - because well let's think about it so we
229:47 - have our popular js
229:49 - if we're successful
229:51 - then we might as well just terminate the
229:53 - whole process
229:54 - correct i mean we don't need this file
229:57 - to be running
229:58 - and if there's an error then again we'll
230:00 - exit but maybe with a error code
230:04 - and the way we set up the process.exit
230:07 - is simply by navigating to the start
230:09 - here and then probably right after the
230:12 - success
230:13 - we'll set up a process again that is
230:16 - that global variable that we have access
230:18 - to then we go with exit and that's the
230:21 - method name and then if we pass in zero
230:24 - that just means that everything went
230:26 - well and we're just exiting the process
230:29 - however if i take the exit method and
230:33 - pass it in and of course in this case
230:35 - since i'm running it in the catch i want
230:37 - to pass in error code i'll pass in one
230:41 - and then let's do it one more time i'll
230:43 - clear everything and i'll not test it
230:45 - out with an error but let's just go here
230:47 - with node populate and now you'll notice
230:51 - that once we're successful we actually
230:54 - exit the process why well because we
230:56 - have process dot exit and of course the
230:58 - code in this case that we passed in is
231:01 - zero and if you want to double check
231:02 - your data just navigate back to the
231:05 - atlas and you'll see that all your
231:08 - product data is still there
231:11 - and once we have dynamically added
231:13 - products to our database i think i can
231:16 - just close the popular js
231:18 - at least in my case i'm not going to use
231:20 - it anymore the same goes for product js
231:23 - and then the rest of the work will
231:25 - pretty much do over here
231:26 - in the controllers
231:28 - and the first thing that i want to
231:30 - showcase actually this is a refresher
231:33 - where essentially if we want to search
231:36 - for a product in a mongoose meaning for
231:39 - some kind of items in our case of course
231:40 - that is product well we need to go with
231:43 - find method correct so let's just go
231:45 - over here
231:46 - i'm in the mongoose docs and i'm looking
231:49 - for the queries
231:51 - and then we'll keep on scrolling keep on
231:53 - scrolling in this case they show the
231:55 - find one example but the idea
231:58 - effectively is the same that if you go
232:00 - with find
232:02 - and of course if you pass in the mp
232:04 - object
232:05 - then you'll get all the documents and of
232:08 - course in the object you can also pass
232:10 - in some options and if you go with
232:13 - properties then you just need to provide
232:15 - what value you are looking for so in our
232:18 - case if we take a look at our model over
232:20 - here in the product js well these are
232:23 - all our properties correct whether
232:25 - that's name price featured and yada yada
232:29 - so in here let me start up my server and
232:32 - then back in product.js i want to get
232:35 - the model because of course we'll go
232:37 - over the basics first where i'll start
232:40 - by just getting the product and that is
232:42 - equal to require
232:44 - and i'm looking for my model again
232:47 - so i'll go two levels up and then i'm
232:50 - looking for the models
232:51 - and then the product and then let's
232:54 - start in the static one so i'll do a
232:56 - little bit of work here i'll show you
232:58 - the manual approach and then in get all
233:01 - products well this is where we'll set up
233:03 - the real functionality the one that
233:05 - we'll use in our project and then we
233:09 - already know the asynchronous so that's
233:11 - good and now let's just start by saying
233:13 - const product and simply let's take a
233:16 - look if we pass in the empty object so
233:20 - in here let's go with weight and then
233:22 - product that's the name of the model and
233:24 - then find and like i said let's just
233:26 - pass in the empty object and then
233:29 - instead of the message
233:31 - i'm just going to go here with product
233:34 - and then let's test it out in a postman
233:36 - so i'll go back to my testing one i'll
233:39 - send it and i should see
233:41 - my array of products and if that is the
233:44 - case then of course we're heading in the
233:47 - right direction now
233:49 - if i want to be more specific
233:51 - if i want to say hey
233:53 - get me
233:54 - the product where the company is equal
233:56 - to this one or get me the product where
233:59 - the name is equal to this one or maybe
234:02 - get me only the featured one then of
234:05 - course we simply need to go back here
234:07 - and where we have the object well i can
234:10 - say
234:10 - featured
234:12 - featured
234:13 - and then this is going to be equal to
234:14 - what true or false so let's just pass
234:17 - intro
234:18 - and then let's run it one more time and
234:20 - what you'll notice in your static route
234:22 - only the products
234:24 - that are featured are going to be
234:26 - displayed and you know what i think in
234:28 - this case it is going to be very helpful
234:30 - if i'm just going to go with those
234:32 - number of hits
234:34 - and i'll set it equal to my array
234:36 - because that way you can right away see
234:38 - if you're getting the correct set of
234:40 - data so let's go over here and in this
234:43 - case it says something went wrong and of
234:45 - course because for some reason i decided
234:47 - to add number of hits in the find and
234:50 - this is actually something that i'll
234:51 - cover later why we get those errors and
234:55 - how to avoid them so let me remove it
234:57 - this was pretty much an early taste what
234:59 - kind of errors we're going to have so
235:01 - let me run it over here where i have the
235:03 - json response so don't be like me be
235:05 - better than me and don't pass it into
235:08 - the find pass it actually where you are
235:11 - sending the response and let's go back
235:13 - over here let's send and of course i
235:15 - have the products and all the way at the
235:17 - bottom i have number of hits is equal to
235:20 - seven and if you'll take a look you'll
235:22 - see that
235:23 - all the products have featured set true
235:26 - and you can probably already imagine
235:27 - that if i'm just going to go here with
235:29 - name
235:31 - and of course we can combine them and
235:32 - again this is something that we'll cover
235:35 - in more detail in next videos so
235:37 - therefore i'll remove it and i'll just
235:39 - start with scratch i'll say name is
235:41 - equal to whatever i have here my
235:44 - apologies i copied the wrong thing
235:46 - if i have multiple
235:48 - tables and for some reason i just want
235:50 - to look for this one i can just pass e
235:52 - in the value where i say yeah get me the
235:55 - product
235:56 - but the name property needs to have this
235:59 - value and now of course once we send i
236:02 - should get only one
236:03 - that's the only one that has the
236:06 - matching name hopefully we're clear on a
236:08 - basic setup so now of course we can
236:10 - start implementing the get all products
236:14 - where the setup is going to be more
236:16 - complex than just hard coding the name
236:19 - or any of the other property values all
236:22 - right i think we're solid on filter
236:24 - functionality so now let's splice things
236:27 - up and implement the dynamic approach
236:29 - since it's highly unlikely that we'll
236:31 - send our responses
236:33 - based on hard-coded filter values
236:36 - and first let's start with our requests
236:39 - more specifically query params because
236:41 - that's how we will get our data
236:43 - and in order to jog your memory on query
236:46 - string params let's go back to my
236:48 - favorite api at least for this course
236:51 - of course the api is hacker news by
236:53 - algolia api
236:55 - and once we navigate here
236:58 - once we start scrolling and everything
236:59 - and looks like i'll have to refresh you
237:02 - can see that of course we can get the
237:03 - items we can provide the route params
237:07 - that's clear but if we keep on scrolling
237:10 - notice of course
237:11 - now we can start searching for some data
237:15 - and how do they set up the search well
237:17 - they have the domain
237:19 - then of course they have some kind of
237:20 - endpoint that ends with search and then
237:23 - they have a question mark
237:25 - and after the question mark we have key
237:26 - value pairs which essentially are query
237:29 - string parameters and then of course
237:31 - based on what you're looking for whether
237:34 - you intercept the query or you want to
237:36 - look for different page
237:38 - then you pass in the value and hopefully
237:41 - you get the correct result and as far as
237:43 - our setup we first need to understand
237:46 - how we can send those query string
237:48 - parameters from the postman correct so
237:51 - let me open up the postman and then of
237:53 - course i'm going to be looking for get
237:55 - all products
237:56 - so i'll just leave the testing one as it
237:58 - is so essentially in there we'll just
238:01 - hard code all the time
238:02 - but back in get all products not only
238:05 - i'm going to be looking for the product
238:07 - but i can go with question mark and then
238:09 - of course i can add key value pairs now
238:12 - we have two options either you can type
238:14 - it here for example you could say
238:16 - name is equal to john and notice how
238:20 - right away they're being added in this
238:22 - table as well so that's the second
238:24 - option where if you don't want to do it
238:26 - in the url
238:27 - you can just set it up over here and
238:29 - what's really cool
238:30 - you can actually check and uncheck them
238:33 - and what that means is that if i go here
238:35 - with john and then of course i send
238:38 - again the name
238:39 - and if i don't want to send it then i
238:41 - can just remove it and if i want to take
238:44 - a look at the featured ones and of
238:46 - course this is going to be featured
238:48 - and as far as featured i want to start
238:50 - with true and then once we send of
238:53 - course now we just get back the message
238:56 - but if we take a look at our controller
238:59 - we should have access to those key value
239:01 - pairs in rec dot query so let's test it
239:04 - out i'm going to go with simple
239:06 - console.log just so we can see that
239:08 - we're getting data and it is sitting in
239:10 - rec
239:11 - and query and let's do it one more time
239:14 - from the postman so let's send it again
239:17 - we get back the hard coded result but
239:19 - take a look at our console of course i
239:22 - can see that i have the object and then
239:24 - in there i have key value pairs
239:26 - with whatever i'm setting up in a
239:29 - postman and once we have jogged our
239:31 - memory on query string parameters now we
239:34 - simply want to go back to the postman
239:36 - and i'll just use the featured
239:39 - and i'll show you in a second why i want
239:41 - to do that and then i'll send it of
239:43 - course and if i take a look at my app of
239:45 - course now i only have featured so now
239:48 - let's set up the logic
239:50 - where i'll remove the console log
239:53 - and then we'll still be looking for the
239:55 - products
239:56 - and we'll use define of course but in
239:58 - this case
239:59 - instead of hard coding
240:01 - instead of setting up the object and
240:03 - then passing in whatever key and then
240:06 - the value of course will pass in
240:08 - directly direct.query now we will
240:11 - refactor the code because there are some
240:14 - gotchas we need to be aware of but with
240:16 - the most basic setup we'll pass the
240:18 - query directly into the find
240:21 - and let's hope that we'll get some
240:23 - results so let's start the same way
240:25 - we'll go with const products
240:28 - and that is equal to await
240:30 - and then product
240:32 - then dot find and like i said we'll
240:34 - directly pass in rec
240:37 - and query
240:39 - and of course once i get back the
240:41 - results i want to also send them and
240:43 - then in this case i'm going to remove
240:45 - the message and i'll just say the same
240:48 - thing where i'll pass in the product
240:50 - as well as the length of my array so
240:52 - that way i know how much i'm sending so
240:55 - let me go back and then one more time
240:57 - from the postman and again the route is
241:00 - forward slash product
241:02 - not the testing one and now i just pass
241:04 - in featured because that is one of the
241:07 - keys that i have and as far as the value
241:09 - i go with true and then once we send
241:12 - check it out now of course we have the
241:14 - product
241:15 - and the amount of items is equal to
241:18 - seven so if i'll change this to false
241:21 - now of course i'll get a different set
241:23 - of values again let's just quickly cover
241:25 - the logic where we have access to query
241:28 - string parameters in
241:30 - reg.query and since we get back the
241:33 - object we can directly pass it into the
241:36 - find one and then since in this case i'm
241:39 - looking for
241:40 - featured
241:41 - and i'm setting it equal to true that of
241:44 - course returns only the products that
241:46 - are featured and then if we pass into
241:48 - false then of course we'll get only the
241:50 - product where featured is set to false
241:54 - not bad not bad i think our basic setup
241:58 - works pretty nice or there are some
242:01 - gotchas we need to be aware of
242:03 - what do you think is going to happen if
242:06 - in a query string params we're going to
242:08 - pass in some kind of value that doesn't
242:11 - match any of the values that we have
242:14 - currently in the model so remember when
242:16 - we're setting up the model we have name
242:18 - price featured and yadi area but what
242:22 - happens if
242:24 - i send with my request a page
242:27 - which essentially we'll do because
242:29 - that's one of the functionalities we
242:31 - want to add and i guess the best way to
242:33 - showcase that is just by going back to
242:36 - the postman and here of course i still
242:38 - have featured set to false now you can
242:41 - leave it you can remove it that's really
242:43 - up to you what i want you to do
242:45 - is go below featured and then just add
242:48 - another key value pair and then in this
242:51 - case go for something that is not in our
242:53 - data so in my case i'm going to go with
242:55 - page because like i said we use that
242:57 - later anyway and then you can come up
242:59 - with whatever value you want and of
243:01 - course i want to check it here and also
243:04 - as a side note just notice the syntax so
243:07 - if you're going to be setting this up
243:08 - manually in the url just remember that
243:11 - in between them you need to add this
243:14 - ampersand of course postman is already
243:17 - doing that for us but if you're setting
243:18 - this manually just don't forget so now
243:21 - once i send
243:23 - check it out of course i have no values
243:26 - why well if i navigate back
243:29 - and take a look at my product what
243:31 - happens over here well i pass in
243:34 - rec.query directly correct and without
243:37 - even cancel logging we already know that
243:39 - we have a object
243:41 - with featured set to true or false that
243:44 - is really irrelevant and then we're
243:47 - looking for the page with some kind of
243:49 - value
243:50 - now mongoose of course is like well
243:52 - listen i don't have
243:54 - any product where there is a page
243:57 - property and that is actually set to 2
244:01 - 1 or whatever so therefore if i go back
244:04 - and if i do the same thing with the
244:06 - testing one again i'll have zero values
244:10 - back
244:10 - so hopefully that is clear so yes this
244:13 - probably is going to work with the most
244:15 - basic setup but then
244:17 - as your filtering gets more complex
244:20 - there has to be a better approach and
244:23 - that better approach is for starters
244:25 - pulling out only the properties you want
244:28 - to apply to the find now what do i mean
244:30 - by that well i'm going to go with const
244:32 - then i'll destructure from reg.query and
244:35 - in my case i'm just going to be looking
244:38 - for a feature of course eventually we'll
244:40 - add more values but for time being i'm
244:43 - only looking for featured so i can add
244:46 - 10 000 more items in here in a query it
244:50 - doesn't matter i'm just going to be
244:52 - looking for featured and if feature is
244:54 - set to true
244:55 - then i'll add it to define and once we
244:58 - have successfully pulled out the feature
245:00 - out of the query so now of course we're
245:03 - only going to be looking for this value
245:05 - instead of passing this directly into a
245:08 - find a better approach is actually to
245:10 - set up a new object so in here i'm going
245:12 - to go with const and i'll call this
245:14 - query
245:15 - object and that is equal to a new object
245:18 - and now i'll use the if and i'll say if
245:21 - featured is true
245:23 - then what i want to do is to set up a
245:25 - new property
245:27 - in this query object so in my new object
245:30 - i want to set up a new property by the
245:33 - name of featured so let's go over here
245:36 - let's say query object feature that's
245:38 - the property name and in here i'm going
245:41 - to use the turning operator where i'll
245:43 - say if the featured is set to true then
245:47 - of course i'll set this property equal
245:49 - to true now then of course e is going to
245:51 - be false so let's go with featured and
245:54 - then we're checking for true so let's
245:57 - say over here true now of course we use
246:00 - ternary operator and then if this is
246:02 - true then we set it equal to true if not
246:05 - then of course we go with false and once
246:08 - i have this logic i'll save
246:11 - and then instead of passing reg.query
246:14 - what it will do will pass in the query
246:17 - object and then since i want us to be on
246:20 - the same page i'm just going to go with
246:22 - console.log
246:23 - and you'll notice that
246:25 - first we only set featured so we're not
246:28 - going to be setting the page and we'll
246:31 - only do that
246:32 - if it is actually passed e into the
246:35 - query so if it doesn't exist so if the
246:38 - user doesn't send featured then of
246:40 - course this logic won't be applied and
246:43 - of course this is just going to be an
246:44 - empty object and then we get all the
246:46 - items so let's test out one more time so
246:49 - now of course i'm going to go back to
246:51 - all the products and let's send and now
246:54 - of course i get back the value of 16
246:57 - because i'm looking for all the products
247:00 - that are not featured but notice how the
247:03 - page is not messing everything up so in
247:06 - here i can clearly say yep featured is
247:08 - there the value is equal to false and
247:11 - this is the object that i'm passing e
247:13 - into define but if we have a different
247:16 - request
247:17 - for example if there is no featured and
247:20 - the user is only looking for the page of
247:22 - course we're not handling the page
247:24 - functionality we'll work on that later
247:26 - but for time being what happens we get
247:29 - all the products why well because we
247:32 - have
247:32 - empty object so hopefully this makes
247:35 - sense instead of passing directly
247:37 - reg.query we set up a new object and
247:41 - first we just pull out the properties
247:43 - we're interested so in my case i'm going
247:45 - to be looking for featured i'm going to
247:47 - be looking for name later on and
247:49 - hopefully you get the gist and then
247:51 - we'll check
247:52 - if the property is actually coming in
247:54 - with a request awesome we'll set up a
247:57 - new property on our query object and
248:00 - then of course there's also going to be
248:01 - some kind of functionality in this case
248:03 - it was just straight up turning operator
248:06 - and then
248:08 - instead of passing that property
248:10 - directly we'll pass in the entire query
248:13 - object and that way of course we can
248:15 - avoid that bug that i showed you in the
248:17 - beginning of the video
248:19 - wonderful once we have the general
248:21 - structure in place
248:23 - so effectively
248:24 - once we have the empty object and then
248:27 - we check for the properties that
248:29 - correspond to whatever we have
248:32 - in the model now of course we can
248:34 - continue and add more functionality to
248:37 - our api correct so we want our user to
248:40 - search based on name maybe also based on
248:44 - price
248:44 - as well as rating and company and all
248:48 - that now i can tell you right away that
248:50 - we will purposely work on the number
248:53 - values so the price and rating and all
248:56 - that a little later because probably
248:59 - that's going to be the most complex
249:01 - logic of this project for now i want to
249:03 - work on name
249:05 - and company now company should be
249:07 - somewhat straightforward where we're
249:10 - going to check for the company so say
249:12 - hey
249:12 - is the company property on myrac.query
249:16 - and of course then we'll set up the
249:19 - value in the object
249:21 - and if of course we can find something
249:23 - then we're in good shape if not and of
249:26 - course we return nothing so let's go
249:28 - back and the first thing that i want to
249:30 - do is of course pass it from my postman
249:33 - so in here i'll remove the page
249:35 - hopefully it is clear what happens with
249:37 - the properties that are actually
249:39 - not on our model
249:41 - and then let's set up a new one and here
249:43 - i'll say company
249:46 - company
249:47 - and as far as the values well let me
249:49 - check
249:50 - since it's going to be faster so let's
249:52 - say i'm going to go with this one copy
249:54 - and paste and now i'm going to look for
249:56 - both i'll say hey get me where the
249:59 - feature is false and company is this one
250:02 - so let me send it here and now what you
250:05 - should see
250:06 - is only the product that matches company
250:10 - now of course not yet but that is the
250:13 - eventual goal so let me navigate back
250:15 - and notice again we only get the
250:17 - featured why because that's my logic so
250:20 - let's go back over here and let's say
250:22 - that we're also going to be looking for
250:24 - the company again not to be redundant
250:26 - because this company corresponds to
250:28 - something we have already in the model
250:32 - otherwise we'll have that mess where
250:34 - mongoose is going to be like hey listen
250:36 - what's happening i cannot find anything
250:38 - then of course we want to set up the
250:40 - logic and this is going to be as
250:42 - straightforward as it gets where
250:44 - essentially i'm going to say if the
250:45 - company exists
250:47 - then of course i just want to set up my
250:50 - property on a query object and the name
250:52 - of course will be company and i'll set
250:54 - it equal to my company the one that i'm
250:58 - pulling out of here so once i save and
251:01 - once we try one more time we should get
251:03 - different amount of values and of course
251:06 - in this case we get only six so now we
251:09 - get featured false and company is equal
251:13 - to ikea
251:14 - now if i'm going to pass in some kind of
251:16 - gibberish
251:17 - i'm going to say that i'm looking for a
251:19 - company bbb of course i'm gonna get zero
251:21 - results but that's what we expected
251:24 - so if we're looking for something that
251:26 - doesn't make sense just of course the
251:28 - user is not gonna be successful but if
251:31 - the user provides correct company value
251:33 - then of course we send back the list of
251:35 - products that correspond to that value
251:38 - and if you're wondering well where the
251:40 - user
251:41 - is going to know that info well that's
251:44 - why we have documentation
251:45 - so if you go back to this api you can
251:48 - see how they clearly explain
251:50 - what are our options and essentially how
251:53 - we can work with the api so now of
251:55 - course in our api we handle two things
251:58 - we handle featured and we also handle
252:01 - the company
252:02 - and once we have the first two down i
252:04 - think we already understand the pattern
252:06 - so let's try to do the same thing with
252:08 - the name
252:09 - and we'll start with the most basic
252:11 - setup where essentially i'm gonna go
252:13 - with a name and then whatever value i'm
252:16 - passing in meaning e in the query and
252:19 - then eventually we'll come up with more
252:21 - complex setup where we have the rejects
252:24 - because at the moment we need to
252:25 - understand that of course with our most
252:28 - basic setup we're only going to be
252:30 - looking for the product whose name
252:33 - matches exactly now what am i talking
252:35 - about well let me go back to the static
252:38 - one
252:38 - let me send it from here
252:40 - and i just essentially want to get one
252:42 - of the names and i'll look for this one
252:46 - and what you'll notice that with the
252:48 - most basic set effectively we'll get
252:50 - only the product whose name matches
252:53 - exactly so if i go here and if i send of
252:56 - course now i get only one product but
252:59 - if i mess it up here meaning if i just
253:02 - pass in the first value
253:04 - you'll notice that actually we get
253:06 - nothing so yes
253:08 - it's a good starting point
253:10 - where the value needs to match exactly
253:13 - but then of course we'll make it more
253:15 - complex and add rejects to the mix
253:18 - because that way we'll be able to just
253:20 - pass in some kind of text values and
253:22 - we'll get the product where that value
253:25 - is somewhere in a name
253:27 - so after my long rambling let me just go
253:30 - back over here where we have get all
253:32 - product and what is the property that
253:34 - we're going to be looking for of course
253:35 - that is the name and there's also
253:37 - something that i want to mention where
253:40 - nothing stops you
253:41 - from setting up your own api and saying
253:45 - here that you're going to be looking
253:46 - for the search for example like they
253:49 - have in the hacker's news api nothing
253:53 - stops you it doesn't mean that these
253:55 - properties need to match exactly now of
253:57 - course i'm setting up this way because
254:00 - it's much more easier later when i'm
254:02 - setting up the object properties so
254:04 - these ones definitely need to match
254:06 - whatever we have in a database but as
254:09 - far as what values we're looking from
254:11 - the query this is really up to you and
254:14 - again just to showcase that notice how
254:16 - they in here use query so we can
254:19 - definitely set up our own api
254:22 - with a query or search or whatever the
254:25 - only reason why i'm using the name
254:27 - is because it's just going to be easier
254:29 - when i'm setting up here in the object
254:31 - hopefully that is clear and then let's
254:34 - keep scrolling and we'll start like i
254:36 - said with the most basic setup we'll say
254:38 - if the name exists
254:40 - then i want to go with my query object
254:42 - of course name property and that one
254:44 - will be equal to the name so let me
254:47 - swing back to the postman and again now
254:50 - switch to get all products
254:53 - and since i'm just gonna get one value
254:56 - since at the moment my name is gonna
254:58 - match exactly i'll remove these ones
255:01 - i'll remove featured and company and you
255:04 - know what let me go to complete project
255:06 - and that way i can get the name right
255:08 - away and once i have the name now of
255:11 - course i'm going to be looking for the
255:13 - product
255:14 - and we want to add a new key
255:16 - and in here i'll call this a name
255:19 - and then i'm going to be looking for
255:20 - this value
255:21 - and then once i send of course now i'll
255:24 - get that one product and if we take a
255:27 - look at our query object of course this
255:30 - is what we have so we have a name and of
255:33 - course whatever value i passed in and
255:35 - since i have one product that matches
255:38 - that that's exactly what we get but if
255:41 - you take a look at the mongoose
255:42 - documentation you'll notice that they
255:45 - have these query operators now this one
255:49 - we'll use a little later
255:51 - when we set up our numeric filters but
255:54 - with the name i actually want to set it
255:56 - up as rejects and since mongoose is
255:58 - sitting on top of mongodb we can get
256:01 - those query operators from the
256:03 - documentation so let's search for
256:06 - mongodb query operators
256:09 - then let's navigate here and as you can
256:11 - see we have a long list of the operators
256:15 - now the one that we're looking for is
256:17 - this one the rejects one and essentially
256:20 - the setup is following where we go with
256:22 - rejects and then we have bunch of
256:25 - options now the one that we'll use is
256:27 - just case insensitive and then of course
256:30 - we just need to pass
256:32 - in the pattern so let me try it out back
256:35 - in our application and i think i'm going
256:38 - to start with the static one
256:41 - just so i can show you the setup and
256:43 - then of course we'll set up the more
256:45 - complex one as well so let me go here
256:48 - and i'll scroll above where i have the
256:50 - static product and i'll just set up some
256:52 - kind of value now since i'm not going to
256:54 - be passing this with a query just
256:56 - understand that eventually of course a
256:58 - value will be coming from the query so
257:00 - in here i'm just going to say const and
257:03 - let's call this search and i'll just
257:05 - type aaa
257:07 - now where i'm looking for the name
257:10 - instead of just passing in the value
257:12 - directly we'll set it equal to an object
257:15 - and then the setup is following where we
257:18 - go with dollar sign and then i'm looking
257:20 - for that reject query operator and then
257:23 - as far as the value i'll pass in the
257:26 - search again eventually it's going to be
257:28 - coming from our query here and then i
257:31 - also want to set up the options and
257:32 - therefore i'm going to go with dollar
257:34 - sign and then i'll pass in the options
257:37 - and i'll set options equal to i and
257:40 - you're not instead of 3a's why don't we
257:42 - go with just one so let's save it over
257:44 - here again the way it works we're
257:46 - looking for name property but instead of
257:49 - looking for
257:50 - entire name instead we go with rejects
257:53 - where essentially we're just looking for
257:55 - the pattern and the way we set up we go
257:58 - with rejects operator then we pass in
258:01 - the variable which of course again is
258:03 - going to be coming from our query and
258:05 - then we have the options and in this
258:07 - case i'm passing i which just means for
258:10 - case insensitive and once we navigate
258:13 - back to the postman and run it you'll
258:15 - notice that of course i'll get all the
258:18 - items where there is at least a a
258:22 - and then if we're going to go with a b
258:24 - now of course we're going to be getting
258:26 - a different value so now of course i
258:28 - only have 5. now in order to set it up e
258:32 - and get all product what do we need to
258:34 - do we need to look for a name we already
258:36 - doing that and then where we have here
258:39 - if name exists and then query object
258:42 - name we simply need to change this
258:44 - around where again you want to go with
258:46 - this one instead and in order to speed
258:49 - this up i'm just going to copy and paste
258:51 - let's scroll down and let's just say
258:53 - that if name exists then of course we'll
258:56 - use the rejects instead now in this case
258:58 - of course
258:59 - the search doesn't exist correct so we
259:02 - need to go with name so if you need to
259:04 - pause it here and write it from the
259:06 - scratch please do so because in my case
259:08 - of course i saved a little bit of time
259:10 - and just use the one from the static so
259:13 - once we save again i'm purposely leaving
259:16 - this one just so you can see what is
259:18 - coming in and if we hop back to
259:21 - all the products and of course now i'm
259:24 - just going to go
259:25 - with some kind of text value
259:28 - that is less than the entire name in
259:30 - this case i'm going to go with e
259:31 - then i will look for the company
259:34 - and why don't we keep the same one over
259:36 - here
259:37 - and then i'll also look for featured
259:39 - anvils and notice how slowly but surely
259:43 - now we can search for more options so in
259:46 - this case i'm looking for featured set
259:49 - to false company equal to ikea and then
259:52 - of course e in the name i'm looking 40.
259:55 - so i'm looking for the product where e
259:57 - is in the name and then once i send
260:00 - check it out now of course i have six of
260:02 - them and if you'll double check you'll
260:06 - notice that definitely e is a name the
260:08 - featured is set to false and of course
260:11 - company matches to the one that we have
260:14 - in the query string parameters
260:16 - beautiful at this point our users have
260:18 - three options for filtering
260:20 - featured company and of course the name
260:23 - eventually we'll set up numeric filters
260:25 - as well but like i mentioned previously
260:28 - since it's probably going to be the most
260:30 - complex thing in this project at least
260:33 - in my opinion we'll implement that last
260:35 - for now i want to switch gears and show
260:38 - you how we can sort our data first in
260:41 - final project then the general
260:44 - setup and then of course we'll implement
260:46 - it in our get products as well
260:49 - and something to keep in mind sorting
260:52 - does not affect the amount of items
260:54 - we're returning
260:56 - just the order
260:57 - in which they are displayed
260:59 - so let me navigate to my final project
261:02 - and then as far as the sorting notice
261:04 - right now
261:05 - i'm just getting them based on a date
261:08 - when they were created and of course
261:10 - since we added them dynamically meaning
261:12 - we pass in the entire batch that's why
261:15 - of course pretty much
261:16 - all of them are with the same date but
261:20 - if i want to sort them based on name
261:23 - what do i need to do well i need to go
261:25 - to the url bar because of course i'm not
261:28 - in the postman and then i go with
261:30 - question mark and then i just need to
261:32 - decide which property i want to use
261:34 - and first i want to go to sort
261:37 - and then let me zoom out a little bit
261:40 - and of course we either can go with name
261:42 - we can go with company we can go with
261:45 - also price and all that so let's just
261:47 - start here with the name
261:48 - and then once i pass it in again i'm
261:51 - going to get 10 values because i already
261:53 - have the limit there but you'll notice
261:55 - that the companies or i'm sorry the
261:59 - product are going to be in the
262:01 - alphabetical order so this is going to
262:03 - be my first one then i have the second
262:05 - one
262:06 - and on and on and on now if you want to
262:10 - sort them the opposite way meaning of
262:12 - course now we go from a to z but if you
262:14 - want to sort them z to a
262:16 - let me zoom in here
262:18 - and then you just want to pass in the
262:20 - negative sign here so where you have the
262:22 - name so that's going to be that
262:24 - parameter that you're using and then if
262:27 - you pass in the negative now you'll
262:29 - notice that the first value is the
262:31 - wooden table instead hopefully that is
262:34 - clear now what we can also do
262:37 - is chain them together so for example
262:40 - not only i want to look at the name but
262:43 - i want to also look at the price why
262:45 - would i want to do that well
262:47 - if i take a look at these ones where i
262:50 - have wooden desk notice how the name is
262:52 - exactly the same
262:53 - correct
262:54 - and the only difference between them is
262:57 - the price so if i add here a comma
263:00 - and then i say that i'm also going to be
263:03 - sorting based on a price and since i
263:06 - don't add the negative
263:08 - i'm just going to be looking for the
263:09 - smallest value first notice now i have
263:12 - the wooden desk with 15 dollars first
263:15 - and then i have one for 40. and you can
263:17 - probably already guess i'm sorry for all
263:19 - this zooming in and zooming out but i
263:22 - just think that it's important that you
263:23 - see everything that i type here if we go
263:26 - with negative then of course what is
263:29 - going to happen well we'll have one desk
263:31 - but
263:32 - the largest value is first now of course
263:36 - i can just sort based on price then i
263:39 - just remove the name and then if i go
263:41 - with price notice again we start with
263:43 - the smallest value and then you already
263:45 - know what happens if we pass in the
263:47 - negative
263:48 - now as far as the setup
263:50 - let's just go to the mongoose and i'm
263:53 - actually here where we have the queries
263:55 - and i'm looking for
263:57 - i believe it was over here yeah so
264:00 - general queries not find or refine by
264:03 - the or any of these functions just
264:05 - general queries
264:07 - keep scrolling keep scrolling keep
264:09 - scrolling and then in here they'll
264:11 - showcase two options
264:13 - that you can use now not for sorting but
264:15 - in general for filtering we have two
264:18 - options and we are using this one where
264:21 - essentially we set up the entire json
264:24 - but you also have this approach
264:27 - available as well and this is again just
264:29 - for your knowledge now what we're
264:31 - interested is this
264:33 - notice after defined what do we see over
264:36 - here we see limit
264:38 - sort and select and notice how they are
264:41 - chained after defined
264:44 - so first we set up our filter object
264:47 - correct and we passed into define but
264:50 - when it comes to limit sort and select
264:53 - we actually need to chain them after
264:55 - define and this is gonna become really
264:59 - important a little later on when we work
265:02 - with get all products so first i just
265:04 - want to show you the manual approach
265:07 - where we just go with sort but then when
265:09 - we set up all the products the fact that
265:12 - we need to chain them is going to be
265:14 - very very important so let me navigate
265:17 - back to our project and let's just start
265:20 - with the static approach
265:22 - so remove the search one not going to be
265:24 - looking for name and in order to make it
265:27 - interesting essentially i'm just going
265:28 - to pass in the empty object just so i
265:30 - can get all the product and then
265:32 - remember instead of the method i want to
265:34 - go with string
265:36 - and i want to pass in the name so i'll
265:38 - start simply with the name so if we
265:40 - navigate to the postman again the static
265:44 - now
265:45 - and if we send a request notice of
265:48 - course our response
265:51 - is going to be in the alphabetical order
265:54 - meaning we'll start with a
265:56 - and all the way to w at the very very
265:59 - end and as you can see i have 23
266:02 - products now if i'll change this around
266:04 - and if i'll say negative here
266:06 - then of course once we send
266:08 - check it out now of course we start with
266:10 - the wooden table and same goes if i want
266:13 - to go with price and syntax is following
266:15 - where we want to create a space and then
266:18 - we type in whatever property we're
266:21 - looking for so in this case again we go
266:24 - with a name but it's going to be z2a and
266:27 - then we'll set up the price
266:29 - of course that is going to be from the
266:32 - smallest to the biggest value let me go
266:34 - back to the postman let me send and of
266:36 - course i start
266:38 - with a w correct but
266:41 - my price for the ones that actually
266:44 - match
266:44 - is gonna be the smallest one first so
266:47 - the smallest price first and then the
266:50 - largest one hopefully that is clear
266:52 - hopefully we understand how we can set
266:54 - up a basic sort so now of course we just
266:57 - need to implement that in get all
267:00 - products
267:01 - nice and once we're familiar with
267:03 - general info now of course let's
267:05 - implement that in
267:07 - get all products
267:09 - and we'll start the same way we'll have
267:12 - to pull this out out of the query since
267:14 - i'm interested in that particular
267:16 - property and of course the property that
267:19 - i'm going to be looking for
267:20 - is the sort one so if the sort is in the
267:24 - query then of course we're good to go
267:26 - but here comes the biggest gotcha
267:29 - where if we take a look at our code
267:31 - right now we are waiting
267:34 - for this one to complete correct and
267:37 - essentially when we go with this fine
267:39 - one we get back a query object but
267:43 - remember
267:44 - in order to sort we need to chain this
267:48 - correct we first go with find and then
267:50 - if you want to implement sort we need to
267:52 - chain it right after find now here's the
267:55 - problem though in my current setup yeah
267:58 - technically i can go here with sort
268:01 - but again remember there might be a
268:04 - scenario where the user is not passing
268:07 - in the sort
268:08 - so we want to do that conditionally and
268:11 - the issue here is following where you
268:13 - can say all right so i'm just going to
268:15 - go with let products
268:17 - and then i'll remove this sort from here
268:20 - and then i'm just going to go with if
268:22 - and then sort exist then of course i'll
268:24 - set products
268:26 - product equal to product
268:29 - and then of course sort and then pass in
268:32 - the value but the problem is following
268:35 - where since we have this await
268:38 - actually here in the product we don't
268:40 - have any more that query object that is
268:43 - going to be returned from the find one
268:45 - we actually already get that list of
268:48 - products so what i'm trying to say
268:51 - that in order for this functionality to
268:53 - work where we actually are chaining the
268:56 - sort if of course it is passed in by the
268:59 - user we need to remove this await and
269:02 - the way it's going to look like instead
269:03 - of setting up the products here we'll go
269:06 - let result and then of course we'll have
269:09 - multiple conditions in this case of
269:11 - course we'll start with sword but then
269:13 - there's also going to be one for fields
269:15 - and we'll also set up pagination
269:18 - hopefully that is clear and only then at
269:20 - the very end we'll get the product
269:23 - so we're going to go below the
269:26 - conditions at the moment we have only
269:28 - sort but make sure that it is always
269:30 - sitting at the very very end and of
269:33 - course in here i'm just gonna go
269:35 - const product is equal to my result
269:40 - and of course i wanna wait for it so i'm
269:42 - gonna say here await
269:44 - and then i'll remove this one so
269:46 - hopefully this is clear where instead of
269:48 - sticking the await over here since we'll
269:51 - chain the sort and fields and limit and
269:55 - all that at the very end of the query
269:58 - object we're getting back
270:00 - that's why we need to remove this await
270:02 - because this right away returns those
270:04 - documents and then set up the await when
270:08 - we have the complete result and i think
270:10 - at this point i can comment out the
270:12 - query object and i think i'll uncomment
270:15 - once we start working on numeric filters
270:18 - and now let's just work with the sort
270:20 - one so for starters let's just see what
270:24 - we're getting back because that way
270:26 - we'll have a better understanding of
270:28 - what kind of functionality we need to
270:30 - set up so let me just check it here a
270:32 - sort and then we want to go back to the
270:34 - postman we're not working in a static
270:36 - one we want to go to all the products
270:39 - and again since i want to get more data
270:41 - i'm just going to remove just keep in
270:43 - mind that of course
270:44 - you can still keep them you can still
270:47 - keep these query params as well because
270:50 - you will get the correct data i mean we
270:53 - saw that we're getting six heads but
270:54 - since i want to have more product i'll
270:57 - just remove them temporarily and we'll
270:59 - come up with a new key and in this case
271:02 - i'll say sort
271:04 - so let's set it up here sort and then as
271:07 - far as the values let's just start
271:09 - simply like we did with name
271:12 - and once we send let's just go back and
271:15 - of course now i can see that as far as
271:17 - my value i have my name
271:20 - now technically we can right away set up
271:22 - the sort and effectively we'll change
271:24 - this to the result
271:26 - but there's one gadget that we need to
271:28 - be aware of
271:29 - if we're sorting based on multiple
271:32 - parameters then of course the value that
271:34 - we can see in the console is going to be
271:37 - different so if i'm going to go here
271:39 - with comma and then price and you can
271:42 - keep the minus or you can just set up
271:44 - the price the result is going to be the
271:46 - same or essentially now we have two
271:49 - values meaning we have one long string
271:52 - but inside of the string of course i
271:54 - have both i have name and price and the
271:58 - idea is that maybe the user decides to
272:01 - chain i don't know three more correct so
272:04 - how we can split them up so we can get
272:07 - the correct values because if you'll try
272:09 - to pass this e into a sort remember the
272:13 - syntax is following where i want to go
272:16 - with a space in between them e instead
272:18 - of the comma so you're not going to be
272:20 - successful now what can we do well we
272:22 - can use the good old javascript where
272:25 - essentially we'll create a variable i'll
272:26 - call this sort list and that is equal to
272:30 - sort and i'll split it i'll say that i
272:33 - want to split it on a comma and then i
272:36 - want to join it back together so
272:38 - essentially i split it into an array and
272:40 - then from the array i join it back
272:42 - together in this case however just with
272:45 - empty spaces and now what we want to do
272:48 - is to go with result remember
272:51 - that is the query object that we're
272:53 - getting back from the find and we want
272:55 - to set it equal to result
272:57 - and then sort and now we want to pass in
273:00 - this sort list in there
273:03 - now what's also really cool is that we
273:05 - can set up some kind of default one so
273:06 - let's imagine the scenario where the
273:08 - user hasn't passed in the sort key but i
273:12 - actually want to sort it based on the
273:15 - time when those items were created how
273:17 - we can do that well we can simply go
273:19 - with else
273:21 - else and here we'll go with the result
273:24 - and that is equal to result of course
273:26 - again and we go with sort and now i'll
273:30 - just hard code the value just like we
273:32 - did over here however which property i'm
273:34 - looking for well let's take a look at
273:36 - our model
273:38 - all the way in the bottom we have what
273:40 - we have created that again since we
273:43 - created all of our projects pretty much
273:45 - at the same time technically you can
273:47 - argue that in our case it doesn't make
273:49 - much sense normally of course that's not
273:51 - going to be the case that's why this is
273:53 - going to work really nicely where we go
273:56 - result and then sort and then we pass in
273:58 - the string and i'm looking for created
274:02 - add
274:02 - and then once we save our functionality
274:06 - should be working so let me try it out
274:08 - i'm going to go over here i have the
274:10 - sort one okay awesome and then once we
274:14 - send of course we start with a products
274:18 - that start with a
274:19 - and then of course
274:21 - as you can see we get the rest all the
274:24 - way to w but if i'll change this around
274:27 - and i'll say that i want to go the
274:28 - opposite direction of course we can send
274:31 - the request
274:32 - notice again we have those two
274:34 - that have the same exact name
274:37 - but since we go here with this minus
274:40 - price that's why we start with the
274:43 - highest value
274:44 - so effectively we have the descending
274:47 - order but if we'll change this around of
274:50 - course we'll have the ascending order
274:52 - instead so that's how we can add the
274:54 - sort functionality to our api
274:58 - and once the sort functionality is in
275:00 - place next i want to showcase how we can
275:02 - select certain fields and i think the
275:06 - easiest way for me to show you that is
275:08 - going to the final project and then i'm
275:11 - just going to go with fields so that's
275:13 - the key please keep in mind that
275:15 - something that i made up
275:17 - the actual method name is different it
275:19 - is select but in the query variables we
275:22 - set up fields so this is just going to
275:24 - showcase which fields we want to see and
275:26 - as far as the values the same as with
275:28 - sort we simply need to pass here the
275:31 - properties that are in our schema and in
275:34 - my case since i want to see
275:36 - only the name property and only the
275:38 - price i'll type
275:40 - name price and hopefully you get the
275:42 - gist
275:43 - if you want to see some other properties
275:46 - just add comma and then the actual
275:48 - property so let's go over here and now
275:51 - of course you can see that in my
275:52 - response i only have the id which is
275:54 - going to be by default as well as the
275:57 - name and the price and if we take a look
276:00 - at the docs we can see that the method
276:02 - name is select
276:04 - and again we have these multiple options
276:07 - where if you want to go with just string
276:10 - you can simply say select and then pass
276:13 - e in the properties so let's try it out
276:15 - in our static one
276:17 - so let's move up we have the sort i
276:19 - think i'm going to remove the sort for
276:20 - now and we'll just say select
276:23 - and then in here i'll do the same thing
276:26 - i'll say
276:27 - name and price
276:29 - and once we go back to the postman which
276:32 - is always tough because it's all the way
276:35 - on the left hand side then i keep
276:36 - forgetting that
276:37 - now of course notice our response only
276:40 - has these two properties it has the two
276:43 - fields of
276:44 - name and price and if we want to
276:47 - implement that in get all products what
276:50 - do we need to do well first we need to
276:52 - come up with the name in a query string
276:55 - again this is what i said before
276:58 - where when it comes to the query string
277:00 - you are setting this up because you'll
277:02 - tell the user in docs hey
277:04 - if you want to search for certain fields
277:06 - then you need to add this property in
277:09 - the query string parameter
277:11 - if you decide that you'll call this
277:13 - shake and bake you're in charge you can
277:15 - definitely do so now in my case i'm not
277:17 - going to be such a rebel i'm just going
277:19 - to go with fields
277:21 - then we're going to keep on scrolling
277:23 - and right after this sort and you know
277:26 - at this point i think it's going to be
277:28 - very useful if i add some comments here
277:30 - and then right after sort but before the
277:33 - product would check for the fields again
277:36 - we'll say if the fields exist
277:39 - then we'll do the same thing where we
277:41 - want to split them up
277:43 - and of course join them back together in
277:45 - the process we'll remove that comma and
277:47 - then of course we just need to chain the
277:49 - select method so in this case in order
277:52 - to speed this up i'm just going to copy
277:54 - and paste this is now going to be a sort
277:57 - list we'll call this fields list
278:00 - and then instead of sort we're going to
278:02 - be looking for fields
278:04 - functionality is going to be exactly the
278:05 - same we split it up we join it back
278:07 - together and then as far as the result
278:10 - of course i don't want to sort it
278:11 - anymore i want to use select and i want
278:14 - to pass in the field list like so so go
278:18 - over here and then let's navigate to the
278:21 - postman and of course in this case we're
278:23 - not looking for the static one anymore
278:25 - we want to go with
278:27 - all the products here
278:29 - and then let's just add both of them
278:31 - together so i have the sword i'll keep
278:34 - that one and then i'll create a new key
278:37 - i'll call this fields
278:39 - fields and then as far as the values
278:42 - let's just say we're going to be looking
278:43 - for the company and also i just want to
278:45 - see the rating over here so let's pass
278:48 - these two and of course we'll notice
278:51 - that we only get the rating as well as
278:54 - the company in our response all right
278:57 - and once we have covered how we can
278:58 - select certain fields
279:00 - next i want to show you how we can skip
279:03 - and limit
279:04 - and by using both of those things you
279:06 - can actually set up a option for the
279:09 - user to choose a page now how's that
279:12 - going to look like well in our final
279:14 - project we can go here with limit and
279:17 - then just decide how many products you
279:18 - want to get back and i believe again we
279:20 - have 23 products so of course if you'll
279:24 - go with 30 then we'll just get all of
279:26 - them so just to showcase that notice of
279:28 - course now we have 23 but if i'm gonna
279:31 - go less so if i'm going to go with limit
279:33 - and then for example four then of course
279:36 - i'll get only four items and if i don't
279:39 - pass anything in then of course by
279:41 - default we'll get 10. that's where we
279:43 - have number of hits and that is equal to
279:46 - 10. so hopefully that is clear and as
279:48 - far as getting the correct page just
279:51 - like they have over here where you pass
279:53 - in the page and that is going to return
279:56 - that exact page number we have to
279:58 - combine limit with skip which is another
280:02 - option we have and before we go any
280:04 - further let me just showcase how is that
280:06 - going to look like in our manual setup
280:09 - so in here i think i'm going to stick
280:11 - with select i mean
280:13 - it can stay there it doesn't really
280:15 - matter and then as far as limit we
280:17 - simply need to go with a method and
280:19 - again we chain it and hopefully by now
280:22 - it's clear that ian get all products
280:25 - we'll have to do that before we await
280:27 - for the result and then in here we
280:29 - simply need to pass in the value so if i
280:32 - want to limit my response here to 4
280:36 - then of course i can go back to the
280:37 - postman now i'm looking for the static
280:40 - one i send it and of course i'm only
280:43 - gonna get four of them now if this value
280:46 - is gonna be bigger than all the items i
280:48 - have of course i'm just gonna get all
280:51 - the items that i have in my list and
280:54 - essentially skip works exactly the same
280:57 - way but the difference is that it just
281:00 - skips the first items in response so let
281:04 - me just limit this by 10
281:06 - and i'll make sure that we actually sort
281:09 - a to z so that way of course you can see
281:12 - exactly what we're getting back so let
281:14 - me go here and i'll chain
281:16 - that sort and i'm just going to be
281:19 - looking for the name and of course now
281:22 - we have a setup where we're
281:24 - alphabetically sorting our responses as
281:27 - well and in order to show you how so it
281:29 - works first let's take a look at our
281:31 - basic response so if we go here notice
281:34 - i'm getting 10 items correct because
281:37 - that is my limit and then i start with
281:40 - this item and then i have the next one
281:42 - next my next one so if i'm gonna go here
281:44 - with skip
281:46 - and for starters i'm just gonna say skip
281:48 - one
281:49 - notice that of course now we start
281:52 - with our second item
281:54 - so the item that was second in a
281:57 - previous response and if we keep making
282:00 - skip bigger you can probably already
282:02 - guess that we're just going to be
282:04 - skipping the items
282:06 - in our response so now of course we
282:09 - right away start with a letter b
282:12 - and once we understand the manual
282:14 - approach now of course we'll have to
282:16 - implement that in get all product and
282:19 - the goal is to use skip and limit to set
282:22 - up a pagination functionality
282:24 - nice and once we have discussed limit
282:26 - and skip now let's see how we can
282:29 - implement them to set up the pagination
282:32 - and in this case i'm not going to be
282:34 - looking for those values in reg.query
282:37 - meaning i'm not going to structure them
282:39 - because we'll set up the variables with
282:41 - the same name so i think it's just going
282:43 - to be easier if we'll go with rec query
282:46 - and then the page as well as the limit
282:50 - and all that so let's just scroll down
282:52 - again we're working right now in get all
282:55 - products i'll make this one smaller
282:57 - and we keep on scrolling keep on
282:59 - scrolling and then right after the
283:01 - fields we want to set up three values we
283:04 - want to go here with const and page so
283:07 - this is what the user is going to pass
283:10 - in
283:11 - same as they have here
283:13 - notice we go with page and then we just
283:15 - set up the page number
283:17 - now by default i do want to set up where
283:20 - we get the first page that's why you go
283:22 - here with page and then remember
283:24 - whatever is coming from the rec.query
283:28 - actually is a string and again just save
283:30 - some time i'm not gonna cancel log
283:33 - because we did the console.logs before
283:35 - and notice page is actually two correct
283:38 - but it is a string of two so of course
283:41 - before we do anything we need to turn it
283:43 - into a number so let me scroll back down
283:46 - and then i'll do the same thing over
283:48 - here where i scroll to the page and then
283:51 - we'll start with the number and then
283:53 - i'll say that i'm going to be looking
283:54 - for rec query
283:57 - and then the page now if the user
284:00 - doesn't pass the value then i'll simply
284:02 - use the or operator and i'm just going
284:04 - to say that it is going to be equal to
284:06 - one
284:07 - and the same is going to be for the
284:09 - limit i'll say that yes in the query
284:12 - there might be a limit since again it's
284:14 - going to be a number i need to use this
284:16 - number meaning since i want this to be a
284:19 - number but
284:20 - it's going to be a string we need to go
284:21 - with number and then we pass in rec
284:25 - query and then limit and if no limit is
284:30 - passed then we go with 10. that's why in
284:33 - a complete project you'll see this one
284:35 - where by default essentially we're just
284:37 - getting back 10 products
284:40 - hopefully we are clear on this one
284:42 - so if the value is passed in awesome
284:45 - we'll use this value if not then we have
284:47 - some defaults and now of course we just
284:49 - want to set up the logic
284:51 - and the way we set up the logic we go
284:53 - here with const skip and that is equal
284:56 - to
284:57 - page minus one and then we multiply this
285:01 - by limit and i'll show you with actual
285:04 - comment example just so we are on the
285:06 - same page so i'll set up the skip and
285:08 - now of course i just want to chain the
285:11 - skip and limit to my result remember
285:14 - we're still working on the result so
285:16 - once i have
285:17 - all of this functionality in place
285:20 - then we'll simply go with result is
285:22 - equal to and then we go with a result
285:25 - and then we change the skip we pass in
285:28 - the skip variable and then we chain
285:30 - limit and of course we pass in the limit
285:34 - variable
285:34 - now it's going to be kind of hard to see
285:37 - in our response so let me just set up
285:39 - some comments just so you understand how
285:41 - everything works so at the moment we
285:43 - have 23 products correct so if i decide
285:48 - to limit my response to only seven items
285:51 - how many pages i have well we need to
285:54 - divide 23 by seven
285:56 - and effectively we'll have four pages so
285:59 - we'll have seven seven seven so that's
286:01 - going to be 21 and then the last page
286:04 - actually is going to have
286:06 - only two items so we have total four
286:09 - pages
286:10 - and the way the logic works
286:12 - is following where the user will pass in
286:15 - some kind of value
286:16 - so maybe for the page is gonna go for 2
286:19 - because remember by default it's always
286:22 - going to be 1
286:23 - and then we multiply this
286:25 - by the limit that's the key over here so
286:29 - if we just have a default page we'll
286:31 - have 1
286:33 - subtracted by one of course that is
286:35 - going to be zero and then multiplied by
286:38 - the limit still gonna be zero so
286:40 - effectively we'll skip zero items and
286:43 - then we'll just limit our response to
286:46 - seven however if the user is going to be
286:49 - looking for the second page then of
286:52 - course we'll have 2 minus 1 so have
286:55 - value of 1 and that is multiplied by the
286:57 - limit so in this case since i'm looking
287:00 - for page number two i'll skip seven over
287:04 - here and then i'll have the limit of
287:07 - seven so that's how i can see the second
287:09 - page and in order to showcase that let
287:12 - me just go to the static one
287:14 - and i want to get all the items
287:18 - just so you can see over here
287:19 - and i think i'll keep this as
287:22 - name and price like so and i'll sort
287:25 - this based on name
287:28 - and then let's do the same thing here so
287:30 - let me send it this is my entire list
287:34 - and then if i go to all the products now
287:37 - let me set it up everything correctly
287:40 - where i do want to still sort
287:42 - and i actually want to start i guess
287:45 - with a name
287:47 - and then i'm going to remove the price i
287:49 - don't really care about that i think so
287:52 - i mean let me just double check so
287:55 - select yeah so i'm only sorting by the
287:57 - name
287:58 - so let's see let's see so we have
288:00 - products i'm only sorting by the name
288:03 - and then when it comes to fields i only
288:05 - want to see
288:07 - name
288:08 - and then price
288:10 - and by default of course we're only
288:13 - going to get 10 because we already have
288:15 - that limit of 10. so therefore let me
288:18 - add here
288:19 - limit
288:21 - and i'm just going to go with a limit of
288:24 - 30. of course that is way more than we
288:27 - have the product so now of course i'll
288:29 - have all the products if i check it out
288:31 - here i have 23.
288:33 - now if i'm gonna be looking for
288:36 - page number two and i'll set up the
288:39 - limit where i wanna see only the four
288:42 - items or three or two or whatever then
288:45 - of course you'll notice that in here
288:48 - effectively we'll just skip whatever
288:51 - items we have in a limit so in this case
288:54 - if i go with limit off to just to make
288:57 - it simpler and then if i go for page
289:00 - number two
289:01 - so here we'll pass in the value of two
289:04 - you'll notice how we'll skip the first
289:06 - two items and we'll right away go
289:09 - for this one the albany sectional so let
289:12 - me send it here
289:14 - and check it out now of course we have
289:16 - albany sectional and i purposely set
289:18 - them up both the same just so you can
289:20 - see how it works so now of course we're
289:22 - looking at this page and as i'm changing
289:25 - the limit i'll be changing how many
289:28 - items i'm getting back and how many
289:30 - items i'm skipping and then when it
289:32 - comes to page of course it affects the
289:36 - amount of items we're skipping as well
289:38 - because if i go with three then of
289:40 - course we will skip two times whatever
289:44 - is the limit and those are the items
289:46 - we're skipping and of course that is
289:48 - going to return us that third page all
289:51 - right we're almost done with the project
289:53 - functionality the only thing left is to
289:56 - set up numeric filters or in other words
289:59 - provide a option for the user to search
290:02 - based on the number condition for
290:05 - example get only the product where the
290:07 - price
290:07 - is more than 30 or less than 30 and
290:10 - hopefully you get the gist but since
290:13 - there's going to be quite a bit of logic
290:15 - i will split this up in multiple videos
290:16 - and hopefully that way you won't be
290:19 - overwhelmed now just to showcase how is
290:21 - that going to look like i'm going to go
290:23 - to my final project and in here i want
290:26 - to go with numeric filters
290:29 - and of course i'll explain why we have
290:31 - this type of key
290:33 - and then we want to go with whatever
290:35 - property we want but of course it will
290:38 - make more sense if we're just going to
290:40 - go with the properties that actually
290:42 - have numbers as values so in our case of
290:45 - course we have price and then we'll go
290:48 - greater than and then of course we'll
290:50 - pass in the value
290:51 - so since i'm not using sort it's
290:54 - probably harder to see
290:55 - but it's definitely only the product
290:58 - where the price is more than 30. now
291:01 - just to showcase that let's go with
291:03 - ampersand let's add short and let me
291:06 - zoom in
291:07 - and then we're looking for the actual
291:10 - value and of course in here i want to
291:13 - pass a and d price so say here price and
291:17 - then let's check it out what we have of
291:18 - course we have 31 then 39 and on and on
291:22 - and on so this is how our api is going
291:26 - to look like
291:27 - now as far as the mongoose we'll have to
291:29 - use again
291:31 - those query operators and in this case
291:34 - for the greater one we go with dollar
291:36 - sign and then greater than and the same
291:39 - goes for less than but of course here we
291:41 - type lt now i'll show you all the ones
291:45 - that we're going to use in the next
291:46 - video now let's just try it out
291:49 - in our manual setup where we want to
291:51 - navigate back we're looking for the
291:54 - product
291:55 - and at the moment i have fined so let's
291:57 - go with price
292:00 - so let's go here with price and we set
292:02 - it equal to an object
292:03 - then we're gonna go with the dollar sign
292:06 - and then we'll pass in sorry not get
292:09 - gt so that's going to be greater than
292:12 - and then of course as far as the value
292:14 - well let's set up the same 30. and once
292:17 - we save of course and if we go back to
292:20 - our static one we should i mean we
292:22 - should let's see so at the moment i find
292:25 - name price and for some reason
292:27 - not returning any kind of value
292:30 - so let me send it one more time there
292:32 - must have been some kind of bug and now
292:35 - of course i can see only the items where
292:37 - the price
292:38 - is more than 30. and just so we can keep
292:41 - on practicing
292:42 - i'm going to go with sort
292:44 - and place here
292:46 - price
292:47 - let's see
292:49 - so that should be the ascending order
292:51 - and you can clearly see that we start
292:54 - with the product where the price is more
292:57 - than 30.
292:58 - so that is the manual setup and that's
293:00 - the general idea
293:01 - and now of course we can start working
293:04 - on get all products because in here
293:07 - we'll have way more logic nice and
293:10 - before we start typing away in get all
293:12 - products let me just showcase where i
293:15 - got the idea from and what are we
293:17 - actually shooting for and it's not going
293:19 - to be a surprise where
293:22 - i'm using again my api and as you can
293:24 - see here the key
293:27 - in the query string is numeric filters
293:30 - that's why we use the same one
293:32 - and then as far as the options of course
293:34 - they provide following so these are the
293:36 - ones where they have numeric values
293:39 - correct and we'll do the same so
293:41 - therefore in our case we'll just have
293:43 - one for the price and one for the rating
293:46 - and as far as conditions we'll notice
293:49 - how they use actually more user-friendly
293:52 - ones correct the ones that we're using
293:54 - in the final one and if we take a look
293:56 - at the mongoose one of course they have
293:58 - this dollar sign greater than and less
294:01 - than so pretty much that's going to be
294:03 - the biggest deal converting these
294:05 - user-friendly ones
294:07 - that we can simply pass in the url
294:10 - to the mongoose ones and in order to do
294:12 - that we'll have to do a little bit of
294:14 - regular expression magic but don't worry
294:17 - the code is pretty straightforward and
294:20 - of course i already got it for you
294:22 - and first thing we need to decide what
294:24 - is going to be the name
294:25 - for the key
294:27 - in the query string parameter and again
294:30 - i'll copy my favorite api at least for
294:32 - this course
294:33 - and i'll name this numeric filters so
294:36 - say here that i'm going to be looking
294:38 - for numeric
294:40 - and then filters
294:42 - now once i have access
294:44 - to the numeric filters i just want to
294:46 - scroll down
294:47 - and we'll do the same thing where again
294:50 - we'll set up a if condition and in this
294:53 - case i'll uncomment the query object
294:55 - because there's going to be times where
294:57 - i do want to showcase what we're getting
294:59 - back and let's just say with numeric
295:01 - filters and then as far as what i want
295:04 - to pass in well first let's go to get
295:07 - all product and again
295:09 - just to kind of keep this nice and sweet
295:12 - i'll remove rest of them and then at the
295:15 - end if we want we can add all of them
295:17 - but i'll just remove these ones and then
295:20 - we want to go with numeric
295:22 - filters because that's the name that i
295:23 - came up with meaning that's the one that
295:26 - you'll showcase in documentation
295:28 - and then as far as the values
295:30 - well let's simply go with price is
295:33 - bigger than i don't know
295:35 - 40 and then comma
295:38 - and what was the other one i believe
295:40 - that was rating and then let's set
295:42 - rating bigger or equals to four
295:46 - so let's send it to all our products
295:50 - and of course i didn't save it
295:52 - very very smart so let me go back over
295:55 - here i'm going to go with log and
295:57 - actually i didn't cancel log it either
295:58 - so let me look for numeric
296:01 - and we're going to be looking for of
296:03 - course the filters if they exist we want
296:06 - to console log them so let's go back
296:08 - over here and now of course i have empty
296:11 - query object because i didn't pass
296:13 - anything in and here i have one string i
296:15 - have price is bigger than 40 and rating
296:18 - is bigger or equals to four and the
296:22 - first thing we want to do is set up the
296:25 - operator map now what does that mean
296:27 - you'll see in a second so in here let's
296:29 - go with const operator
296:31 - and that map and in here i want to map
296:34 - the user-friendly ones to the ones that
296:37 - are understood by the mongoose so i'll
296:39 - say bigger than
296:41 - and then as far as the mongoose it
296:43 - understands the dollar sign and then we
296:46 - have greater than and once we have the
296:48 - first one of course we just want to add
296:50 - the comma and i'll copy and paste this
296:53 - four times
296:55 - and as far as the second value i'm going
296:57 - to go with
296:58 - greater than or equal and when it comes
297:00 - to mongos we just need to add this e at
297:03 - the very end
297:04 - then as far as the equal well we simply
297:08 - go with equal sign and then here we say
297:10 - equals and of course we'll do the same
297:13 - thing with less than and less than
297:16 - equals so in here let's go less than
297:19 - less than equals and as far as the
297:21 - mongoose values it's lt
297:24 - and then lte
297:26 - so once we have the map then this is
297:29 - where the regular expression magic
297:31 - happens where first i want to set up the
297:33 - regular expression and then we want to
297:36 - run the replace method where we pass in
297:38 - that regular expression and if it is a
297:41 - match
297:42 - then of course we'll change the value
297:44 - from the user-friendly one that we're
297:47 - getting in the numeric filters e into
297:50 - the one that is understood by the
297:52 - mongoose and when it comes to regular
297:54 - expression we just go with const and
297:57 - i'll call this
297:58 - rejects noun is equal to the regular
298:01 - expression and this one i got from the
298:04 - stack overflow so please don't overthink
298:06 - it you can always find those values you
298:08 - really don't need to come up with them
298:10 - yourself
298:11 - and inside of the regular expression we
298:15 - just want to go here with b
298:18 - and then set up the parenthesis and then
298:20 - you just want to pass in
298:22 - all of these values separated by the
298:25 - vertical bars
298:27 - so in here
298:28 - we go with less than
298:30 - then greater than and hopefully you get
298:32 - the gist and once i have all the values
298:35 - then we want to add one more b
298:38 - so let's go over here we add b
298:40 - and then we're going to go with a g flag
298:43 - and once i have my regular expression
298:46 - then i want to go with the replace
298:48 - method where essentially i call numeric
298:51 - filters which of course is going to be
298:53 - my string
298:54 - and then i'll pass the regular
298:56 - expression and if there is a match then
299:00 - of course we'll convert from the
299:02 - user-friendly one to the one that is
299:04 - understood by the mongoose so in here
299:07 - let's call this let filters and that one
299:10 - is equal to our numeric filters then we
299:13 - go with replace method and then as far
299:16 - as the first argument we want to pass in
299:18 - our rejects and the second one will be
299:20 - the callback function if there is a
299:23 - match so what we could do here i can
299:25 - access the match if there is one and as
299:28 - far as the functionality well i want to
299:30 - take this match
299:31 - and then i want to get the value that
299:34 - corresponds to something that is
299:36 - understood by the mongoose so here i'll
299:39 - return a string and i'll purposely use
299:42 - the template literal here and i'll
299:45 - purposely also add these hyphens and
299:48 - you'll see later why we want to do that
299:49 - so there's going to be two hyphens one
299:51 - at the start and then one at the end and
299:54 - then we want to access the actual value
299:56 - and now i want to go for my operator map
300:00 - and then i want to look for the match
300:03 - and hopefully you understand how this
300:04 - works so essentially
300:06 - i have the object
300:08 - object has the properties correct and
300:11 - then if there is a match over here then
300:13 - i just say hey
300:15 - get me that key
300:16 - and effectively i will swap the values
300:20 - and just so you can see how everything
300:22 - works
300:22 - instead of numeric filters why don't we
300:25 - look for the filters over here
300:28 - and then let's go back to the postman
300:31 - and send a request one more time and now
300:33 - of course you'll see the result so
300:35 - notice
300:36 - instead of this one where we have price
300:39 - is bigger than 40 and rating is bigger
300:42 - or equals to four now of course we have
300:45 - this we have price and then this is
300:47 - going to be that amongst value and the
300:50 - same goes for the rating and since i
300:53 - don't want to overwhelm you we'll stop
300:55 - over here and we'll continue with the
300:57 - logic in next video we have successfully
301:00 - converted our values to the ones that
301:03 - are understood by the mongoose but we're
301:06 - not done because of course i cannot pass
301:09 - this one into my query object we need to
301:13 - do a bit more data massaging
301:16 - and the way it's going to look first i
301:18 - want to come up with options because if
301:19 - you take a look at their api
301:21 - like i mentioned previously you can only
301:24 - do that on
301:26 - certain
301:27 - properties because these properties of
301:29 - course have number values and
301:31 - essentially we want to do the same where
301:33 - i'm going to go with options and that's
301:35 - just going to be an array and here i'll
301:37 - pass into string values i'll say price
301:41 - and rating because of course those are
301:43 - the two properties that use the number
301:45 - value
301:46 - and then we want to go with filters and
301:48 - set it equal to the filters and first
301:51 - again we'll use the split method
301:52 - remember that's the method that's
301:54 - splitting string into an array and i'll
301:58 - say that i want to split it where's the
302:00 - comma so of course now i'll have two
302:02 - items in my array i'll have this one
302:05 - and i'll have this one
302:07 - hopefully that is clear and then after
302:09 - that we want to go with four each so now
302:12 - iterate over that array and then in the
302:15 - callback function i'll have access to
302:17 - that item again it's going to be a
302:19 - string of price and yada yada and the
302:22 - same goes for the rating
302:24 - and then we want to do more splitting
302:26 - over there
302:27 - and effectively i'm going to split it
302:29 - into array and then remember we also
302:31 - have array destructuring where i can
302:33 - pull out the values
302:35 - and i'm just going to set it equal to
302:37 - item split and remember that when we
302:40 - were setting up our regular expression i
302:43 - purposely added here these hyphens so
302:45 - now each item so price and the rating i
302:49 - actually want to split it on that hyphen
302:52 - so say here split it on hyphen and the
302:55 - way the array destructuring works
302:57 - instead of object where we say a
302:59 - specific property whatever i'm going to
303:01 - type here first
303:03 - is going to match this price because of
303:05 - course we're splitting on hyphen the
303:06 - second one is going to be of course my
303:09 - operator and the third one is going to
303:12 - be the value so in here i can just go
303:14 - with field
303:15 - and then operator and as i said not if
303:18 - you need to catch up on the array of
303:20 - structuring i have that video in my
303:23 - javascript nugget series so let's go
303:25 - over here with the value so this is
303:27 - going to be the actual value and then
303:30 - only if the field so only if the price
303:33 - and rating is actually in my options
303:35 - only then
303:37 - i want to add a new property on that
303:40 - query object so in here right after that
303:43 - i'm going to go with if and then the
303:45 - name is options and we can use this
303:47 - includes method
303:49 - and if it includes the actual field then
303:53 - inside of the block i want to go with
303:56 - query object and then i want to set up
303:58 - the field so now again i'm dynamically
304:01 - setting up the property
304:02 - on my query object and since we're
304:05 - cancel logging of course you'll be able
304:06 - to see that and then as far as the value
304:09 - well again we need to go with object of
304:11 - course so let's set it here equal to an
304:13 - object and then we go with operator
304:16 - again this is dynamic of course because
304:19 - this operator will change in one case we
304:22 - have greater than in other case we have
304:24 - greater or equals so therefore again we
304:27 - go with operator that is coming from
304:30 - here
304:31 - and then as far as the value well we're
304:34 - still getting this as a string correct
304:36 - so we need to go again with number and
304:39 - then pass in the value so now of course
304:42 - once i save
304:44 - since we're constant logging you'll be
304:46 - able to see actually what we have in a
304:49 - query object so let me go back let me
304:51 - send it one more time and what you'll
304:54 - notice
304:55 - is this query object we have price and
304:58 - of course we have greater than and as
305:01 - far as the rating we have greater than
305:04 - or equals so what's really cool of
305:07 - course now we get the correct values
305:09 - where we only get the ones that have the
305:13 - price bigger than 40 and rating is
305:15 - bigger or equals to four so if i'll
305:18 - change this around and if i'll just say
305:20 - that i'm looking for a rating that is
305:22 - bigger or equals to 4.5 and then maybe
305:26 - the price
305:27 - is going to be
305:28 - bigger than 90 then of course once we
305:31 - save check it out we have
305:33 - only
305:34 - how many seven products correct so
305:36 - that's how we can set up these numeric
305:39 - filters in our api and once we have the
305:42 - numeric filters in place we're pretty
305:44 - much done with the project hopefully
305:46 - everyone enjoyed it and i'll see you in
305:48 - the next one all right and welcome to
305:50 - our next adventure
305:52 - the json web token basics project so far
305:55 - in our projects all the routes were
305:57 - public
305:58 - meaning
305:59 - anyone can access them and use them
306:00 - however they please
306:02 - but of course that's not how we want to
306:04 - set up apps in real world
306:06 - i don't want random people to access my
306:08 - data
306:08 - and i bet you probably feel exactly the
306:10 - same way
306:12 - so how we can restrict the access well
306:14 - i'm glad you asked a very popular method
306:17 - is using jwt or json web tokens
306:21 - and for the sake of simplicity just
306:23 - think of them as long strings now of
306:26 - course they're way more complex than
306:28 - that but let's just not worry about that
306:30 - right now
306:31 - and the idea is following imagine we
306:33 - have two routes
306:34 - a dashboard and a login or register
306:37 - route
306:38 - now dashboard is protected so i can
306:40 - click all day long on get data
306:43 - but i'll have no access to the info
306:46 - and only if i log in
306:48 - i get the token and only once i have the
306:51 - token i can access the secret info which
306:54 - in this case is just going to be a
306:55 - random number so let's try it out i have
306:58 - the dashboard clearly says here no token
307:01 - present and check it out not authorized
307:03 - to access this route and again i can
307:06 - click all day long and i can showcase
307:08 - that
307:08 - in the console where notice we're
307:10 - getting these
307:11 - 401 errors but i'll have no access to
307:15 - the data now in order to access the data
307:18 - of course i need to log in and of course
307:20 - this is just going to be a simple
307:22 - version where i just need to provide
307:23 - some kind of values if i won't provide
307:26 - the values then i'll get the 400 one so
307:29 - this is going to be a bad request and i
307:31 - still don't get the token so let's go up
307:34 - i'll say user name and i'm just going to
307:37 - go with my john and again you just need
307:39 - to provide some kind of values it
307:40 - doesn't really matter in a later project
307:43 - of course it will matter what we provide
307:45 - there but in this case we just need to
307:47 - provide something and only if i do that
307:50 - then
307:51 - i send it here notice user created so
307:54 - now of course i have no errors and also
307:57 - in the local storage i'm going to get
307:59 - the token now don't worry about the
308:01 - front end local storage and all that
308:03 - i'll talk about it in more detail later
308:06 - just think that you're getting the token
308:09 - and once the token is present and of
308:11 - course we can clearly see that here with
308:13 - the text of token present then
308:16 - we can make as many requests as we want
308:19 - in order to get our data again as long
308:22 - as the token is valid we are good to go
308:25 - now if again i'll try to submit and then
308:28 - i'll remove the token then again we're
308:30 - back to the not authorized this route
308:33 - now the reason why i made this project
308:34 - so simple and straightforward is because
308:37 - it's crucial that you grasp the main
308:39 - concept
308:41 - if you do i guarantee you you'll breeze
308:43 - through the upcoming projects
308:45 - even though they will be way more
308:47 - complex than this
308:49 - just always remember
308:51 - if a valid token is present in the
308:54 - request the user can access specific
308:57 - info
308:58 - now not all of the info of course you
309:00 - can only access the info that belongs to
309:03 - you so you cannot just randomly come
309:05 - here and get my data but still if the
309:08 - token is present you can get that
309:10 - specific data but
309:13 - if we have a restricted route so keep in
309:16 - mind that login is not restricted anyone
309:18 - can try to log in but if we do have the
309:21 - restricted route like we have with
309:23 - dashboard
309:24 - if the token is not present or it's not
309:28 - valid then the server in this case
309:31 - that's of course us
309:33 - will kick back the error response and
309:35 - that's how essentially
309:37 - we restrict access to certain routes
309:41 - aka certain resources
309:44 - and as far as the setup again we've got
309:46 - the folders final where you'll find the
309:48 - complete code
309:50 - and a starter where we'll do all of our
309:52 - work
309:53 - and when it comes to final you'll be
309:54 - able to spin it up once we cover
309:57 - gwt or json web token basics since
310:01 - you'll need to set up a variable in.env
310:04 - and when it comes to starter all of it
310:07 - should look very familiar and like i
310:09 - promised in a previous video
310:10 - in order to save some time on a
310:12 - boilerplate i already set up a basic
310:15 - express server for you
310:17 - so let me install dependencies
310:20 - and then i'll show you our app.js
310:22 - so let me zoom out
310:24 - i'll open up my terminal i'll clear
310:26 - everything and then of course first i
310:29 - want to navigate to the star one
310:31 - so grab it over here and then we're
310:33 - gonna go with npm
310:35 - install
310:36 - and then of course you will also spin up
310:39 - and pm start
310:41 - now when it comes to package json of
310:44 - course there are few other packages as
310:47 - well
310:48 - and i'll talk about them once we get
310:50 - there
310:51 - and when it comes to app.js essentially
310:54 - first i require dot env and of course
310:57 - that is in order to access the env
311:00 - variables then we have express async
311:02 - errors and if you remember we use that
311:04 - package just so we don't have to set up
311:06 - our own async middleware
311:09 - then we grab the express from express
311:11 - and we invoke it and we set it equal to
311:14 - app
311:14 - then we're looking for two middlewares
311:17 - not found one an error handler one and
311:20 - if you take a look at the folder the
311:22 - middleware one of course you'll see the
311:24 - error handler
311:25 - this is the one that we used all the way
311:28 - in the project number three this is
311:30 - essentially what we set up where we have
311:32 - the custom api error
311:34 - and of course we're looking for that
311:36 - instance and then if that is the case
311:38 - then this is the response if not then we
311:40 - just send back the 500 one the generic
311:43 - one
311:44 - and of course since we're using
311:46 - our own error class of course we also
311:49 - have it in the errors so if you take a
311:51 - look at the custom error one of course
311:53 - you can see that we have the class that
311:55 - is extending from the error and we'll do
311:58 - that because of course there's going to
312:00 - be some instances where we'll implement
312:03 - our own class instead
312:05 - and of course i'm importing both of them
312:07 - from the middleware like i said
312:09 - and then you can find the other one the
312:11 - not found here as well and then we'll
312:14 - also work on the authentication
312:16 - middleware that's what we'll find here
312:19 - the empty file
312:20 - then we keep on moving and we can see
312:22 - that we have app.years so we implement
312:26 - the middleware and in this case i'm
312:28 - looking for a static one so essentially
312:30 - we're serving static files
312:33 - because this is where our front-end app
312:36 - lives notice over here again we have
312:38 - index.html style css as well as the
312:42 - browser app.js and then of course we
312:44 - have express json and that is simply
312:47 - because one of the routes is going to be
312:49 - a post route and i want to access
312:52 - request.body
312:54 - so i want to get that data that's going
312:56 - to be coming in and then of course we
312:58 - implement both middlewares the not found
313:00 - one as well as error handler one and
313:03 - then we have the port variable we set it
313:05 - equal to process.env port or 3000 and of
313:10 - course in the final one it's a little
313:11 - bit different i believe it's 5 000 just
313:14 - so we don't have the port issues meaning
313:17 - just so we don't have two apps trying to
313:19 - access the same port and then of course
313:21 - i have a start one however you'll notice
313:23 - that in this case we're not connecting
313:26 - to the database so i simply wanted to
313:28 - showcase how everything is going to work
313:31 - without database
313:32 - and of course the next project will
313:36 - implement the database because of course
313:38 - that will add an extra layer of
313:40 - complexity and of course in here i just
313:42 - call app.listen set up the port i set up
313:45 - the console.log and if there is an error
313:47 - i log one now if you're wondering why i
313:50 - kept this db folder with connect1
313:52 - just so you don't forget the setup again
313:55 - in the next project of course
313:57 - a major part of the application is going
314:00 - to be setting up everything once the
314:02 - database in this case i just wanted to
314:04 - showcase how everything is going to work
314:07 - in isolation and if you can see server
314:10 - is listening on port 3000
314:12 - you can bravely navigate to your browser
314:15 - and we're looking for localhost 3000 and
314:19 - of course you'll see the app now nothing
314:21 - is going to work i can guarantee you
314:23 - that because of course we have no routes
314:25 - but you should see the ui so you should
314:28 - see the form as well as this g brush
314:30 - here in the bottom and if you do
314:33 - then of course we're in good shape and
314:35 - now we can start working on the project
314:37 - beautiful and once we're done with the
314:40 - setup
314:40 - next i want to set up our two lonely
314:42 - routes so we'll have one fake one for
314:46 - the login register and sign up and
314:49 - please understand that of course in the
314:51 - following projects there's going to be a
314:53 - huge distinction
314:55 - whether we're registering or we're
314:57 - actually just logging in but in this
314:59 - case we'll jam both of them together
315:01 - because our main concern
315:03 - is going to be that
315:05 - jwt or json web token and as a quick
315:08 - side note in the following videos when i
315:11 - use term jwt of course i'm talking about
315:14 - the json web token and then basically
315:17 - what we want is to set up those two
315:19 - routes and we already know how to do
315:21 - that so of course we have the routes
315:22 - folder in there eventually we'll have
315:25 - the router
315:26 - and then we'll also have the controllers
315:29 - so in this case let's just start with
315:30 - controllers so i'm going to go here with
315:32 - const and effectively i'll set up both
315:35 - of these functions
315:36 - and i'll go with this sync because
315:38 - remember we have the package that
315:41 - handles that the express async error so
315:44 - we don't have to set up the try catchers
315:46 - or our own middleware and we can simply
315:49 - go with rec and res
315:51 - and as far as the response we'll just go
315:53 - with the res dot and then send
315:55 - and here i'm just going to say fake
315:58 - login
316:00 - register
316:01 - and then of course d sign up and like i
316:04 - said normally of course there's going to
316:06 - be a difference whether we're logging in
316:09 - or we're registering however in this
316:11 - case we'll just mush all of them
316:13 - together
316:14 - and then we'll say we're out here
316:17 - that's for the login and when it comes
316:19 - to dashboard this is where we want to
316:20 - share that secret or authorized data so
316:24 - let's just say here dashboard
316:26 - and that will be equal against your sync
316:29 - rook and res
316:32 - and here let's do it a little bit more
316:33 - interesting where i just want to set up
316:35 - some random number and i'll call this a
316:37 - lucky
316:38 - number and of course that will be equal
316:41 - to math
316:42 - random which is coming from the
316:44 - javascript we'll multiply this by i
316:46 - don't know maybe 100
316:48 - and then let's wrap everything
316:50 - in the math floor
316:52 - and essentially we should get the random
316:54 - numbers between
316:56 - 0 and 100
316:58 - and then once we set up the lucky number
317:00 - let's just go with the res dot status
317:02 - and of course eventually this route will
317:04 - be protected but of course for time
317:06 - being we'll just go with res dot status
317:08 - 200
317:09 - and then i'll say json and we'll be
317:12 - sending back the object i'll say message
317:14 - here
317:15 - and eventually it's going to be the name
317:17 - of the user
317:18 - and therefore i'll place everything
317:20 - right away in template string but for
317:21 - now
317:22 - since we don't have the user i'm just
317:24 - going to say john doe
317:26 - and then the other property on the
317:28 - object is going to be a secret
317:30 - so let's say here comma secret
317:33 - and again we'll use the template string
317:36 - and we'll say here is your authorized
317:38 - data your lucky number and then of
317:40 - course we'll access the variable and
317:42 - once we have all of this in place once
317:44 - we have the first string as well as the
317:46 - second one with lucky number now of
317:48 - course we just want to export them and i
317:51 - think for now i can just close the
317:53 - console as well as the sidebar and we'll
317:55 - just go with module
317:57 - exports and of course we're exporting
317:59 - the object and we're looking for two
318:01 - functions login
318:03 - and dashboard and it looks like i made a
318:06 - big old doozy where essentially i set up
318:09 - my code
318:10 - in the router instead of the controllers
318:13 - my apology so take all of this code
318:16 - cut it out from the routes
318:18 - and you're actually looking for the
318:20 - controllers we copy and paste and then
318:24 - back in or out of course this is where
318:26 - we want to set up the router so in here
318:29 - we're looking for express just like we
318:31 - did before we go with require we're
318:34 - looking for the express package of
318:36 - course
318:37 - then we want to set up the router so
318:39 - const
318:40 - router is equal to express.router
318:43 - router we invoke it
318:45 - and then we're looking for both of the
318:47 - controller functions
318:49 - and those are login and dashboard and
318:51 - both of them are coming from the
318:53 - controllers
318:54 - so hopefully you're able to fix my bugs
318:58 - and essentially we want to go two levels
319:00 - up
319:00 - and then we're looking for the main
319:03 - and then once we have all of this in
319:04 - place eventually there's going to be a
319:06 - middleware for authentication as well
319:09 - but for time being we'll just go with a
319:11 - router and then in here let's go with
319:14 - dashboard first so dashboard
319:17 - and this is going to be a get route
319:20 - and we'll simply pass in the dashboard
319:22 - controller
319:24 - now the login one is going to be a post
319:26 - one because of course we want to get
319:28 - those user credentials the username as
319:31 - well as the password so we go here with
319:33 - router
319:35 - then route
319:36 - then forward slash login
319:39 - and of course in this case we go with
319:41 - post method and then we'll pass in login
319:45 - and then last thing we want to do is of
319:47 - course export this so module
319:49 - exports and we set it equal to the
319:52 - router
319:53 - and then once we have all of this in
319:55 - place we go back to the app.js we're
319:58 - looking for the main router
320:00 - so i'm going to go above both the
320:03 - middlewares
320:04 - and i'll say here main
320:06 - router now that is coming from my route
320:09 - so require
320:11 - and it's in the same folder essentially
320:14 - it's in the root so we simply go with
320:16 - forward slash we're looking for the
320:18 - routes
320:19 - and more specifically main
320:22 - and then where we have the middleware
320:24 - for not found one and all that above it
320:27 - we'll just go with app.use
320:29 - and again what is going to be that root
320:33 - endpoint well in my case again i'm going
320:35 - to go with api and then version one
320:38 - because that's the setup that i have of
320:40 - course e in the postman and then of
320:43 - course we'll just set up that every time
320:45 - we get a request
320:47 - on this root endpoint we'll just go with
320:50 - main router so we go with main router
320:52 - and of course in the main router we have
320:55 - the dashboard so that one will be api
320:58 - version one forward slash dashboard and
321:00 - then for the login you already can
321:02 - imagine that it's going to be api
321:05 - version one and login and once the basic
321:08 - controllers as well as the routes are in
321:11 - place now of course we can move on to
321:13 - our next task
321:15 - nice and once we have our basic
321:18 - controller setup in place
321:20 - now let's also test it out e in the
321:22 - postman so in here we want to go with
321:25 - another collection
321:27 - and of course
321:28 - i'll give it another name
321:30 - and i'm going to go with 0 5
321:33 - and pretty much the same as the app name
321:36 - so say here jwt basics and then in here
321:40 - we'll have two routes
321:42 - one
321:43 - like you just saw is going to be to get
321:44 - one and we're just going to be looking
321:46 - for the url
321:48 - then we'll go with forward slash and
321:51 - then we're looking for the dashboard of
321:53 - course
321:54 - so that's going to be our get route once
321:56 - we send the force we should see hello
321:58 - john doe yadda yadda the lucky number is
322:01 - 90 and notice how every time we send of
322:04 - course we'll get a different value and
322:06 - this is done on purpose just so you can
322:08 - see that we are getting a new request
322:10 - out and then of course i just want to
322:12 - save it
322:14 - so let's say over here and of course i
322:16 - want to save it here
322:17 - in my latest collection
322:19 - and then i want to do the same thing
322:22 - with my other route with log in one but
322:24 - of course that one is the post one
322:26 - correct so let me close this one and
322:29 - we'll just start with post
322:31 - then we're looking for the url
322:33 - and of course the route is logging here
322:37 - and just to jog your memory when it
322:38 - comes to the post route of course we
322:40 - want to send some kind of data to the
322:43 - server because effectively
322:45 - we want to create a resource on a server
322:48 - so therefore we go with body we'll go
322:50 - with raw and we'll set it equal to json
322:54 - and in here let's just go with username
322:57 - because this is what we'll be sending
322:59 - from our front-end application
323:01 - as well as the password and of course
323:03 - since we're just testing everything out
323:06 - we can go with whatever values you want
323:08 - and as a side note
323:10 - in general we'll only check if the
323:12 - values are provided
323:14 - now in the following project of course
323:16 - this is where the things are going to
323:18 - get way more interesting than that but
323:20 - for now you just want to send username
323:23 - and then comma and of course the
323:25 - password
323:26 - and as far as the password i think
323:28 - throughout this project i'm just gonna
323:30 - stick with secret and then once we send
323:34 - of course we have fake login blah blah
323:36 - blah which means that everything is
323:39 - correct and once we have tested both the
323:41 - routes and once we have properly saved
323:44 - them in our collection so here let's
323:46 - just call this login
323:48 - register and of course we can start
323:50 - focusing on the real logic therefore in
323:53 - here i'm just going to save it and we
323:55 - can start working on our next task and
323:57 - before we continue let me just give you
323:59 - a big picture
324:01 - of what we're about to do so first we
324:04 - know that we have a post route the login
324:07 - one
324:08 - and essentially
324:09 - since we want to log in or register user
324:12 - in this case we're going to be looking
324:13 - for two things we're going to be looking
324:15 - for username as well as the password and
324:19 - we already know that it's going to be
324:20 - available in reg dot body
324:23 - now if both of them exist we want to
324:26 - create a new
324:28 - jwt
324:29 - if not then we want to send back the
324:31 - error response then we want to say hey
324:33 - listen please provide email and password
324:37 - now
324:38 - if we're good
324:39 - if we create a new json web token then
324:42 - of course we want to send it back to the
324:44 - front end
324:45 - since frontend needs to access it in
324:48 - order to send another request in order
324:52 - to send the get request where
324:54 - essentially we display this secret
324:56 - information
324:57 - and on our end we want to set up the
324:59 - authentication
325:01 - so only the request
325:03 - with jwt can access the dashboard
325:06 - otherwise if you go currently to our
325:09 - front end notice and click here and i
325:12 - can actually access the data but that's
325:15 - not what we want what we want on the
325:17 - front end here or from the postman
325:19 - doesn't really matter but of course with
325:21 - front end it's just easier to see we
325:23 - want to provide username and password
325:26 - and only if both values are provided
325:29 - then we get back the token and only with
325:32 - our token we can make a successful get
325:34 - request
325:35 - and eventually display our secret data
325:38 - on a front end otherwise we get an error
325:41 - since the dashboard route is restricted
325:43 - and only accessible by authenticated
325:46 - users or in other words only by the
325:49 - requests where json web token is present
325:54 - and if we take a look at the comments
325:55 - the first thing we want to do is check
325:57 - for username and password and since it's
326:00 - a post route we already know that data
326:03 - is going to be indirect.body so here we
326:06 - go with const and then looking for both
326:08 - things username
326:10 - password and this is going to be the
326:12 - case where i will log them out so i'll
326:14 - set up here log
326:16 - and i'm going to be looking for both
326:18 - user name
326:19 - and password this is the case where you
326:21 - can send those requests from the front
326:23 - end
326:24 - but i highly encourage you to do that
326:26 - from the postman first and only do that
326:28 - later once our jwt functionality is in
326:33 - place
326:33 - so my case i'm going to navigate to my
326:35 - postman i'm looking for the login one i
326:38 - have the body yeah that's awesome and
326:40 - then i'll send it and back in my
326:43 - application
326:44 - if i take a look at the console of
326:46 - course i have
326:47 - john and secret there also could be a
326:50 - case
326:51 - where the user is trying to
326:53 - log in with just empty values correct
326:56 - so
326:57 - he or she can send this type of request
327:00 - and now on the console i can see that i
327:02 - have nothing and before we issue the
327:04 - token
327:05 - which eventually will allow
327:08 - the front end to access the route i want
327:11 - to check
327:12 - whether the username and the password
327:15 - have been provided
327:17 - now eventually once we work with
327:19 - database effectively we have three
327:21 - options first option remember when we
327:23 - use mongo's required validation
327:26 - it checks that for us
327:28 - if the value is not present it simply
327:30 - spits back the error so that's
327:32 - definitely one route that we can take
327:34 - once we introduce a database but in this
327:36 - case remember we're not connecting to
327:38 - the database another option we have is
327:40 - to set up the entire additional layer of
327:43 - validation which is going to be sitting
327:45 - in front of all of our requests
327:47 - and in order to accomplish that task
327:50 - we'll utilize another package by the
327:51 - name of joy
327:53 - but i only want to do that in a later
327:54 - project once we have a solid
327:57 - understanding of the json web tokens now
328:00 - the third option
328:01 - is actually checking for both of these
328:03 - values over here
328:05 - where i can say hey
328:07 - if the username or the password
328:10 - have not been provided
328:12 - then i'll send you back a a response now
328:15 - in our case what's really cool we have
328:17 - that package that wraps all of our
328:20 - routes and we simply want to throw a
328:22 - error what error
328:24 - well our custom one where we say hey
328:26 - listen you did not provide both values
328:30 - so therefore we'll send back a 400
328:32 - response which essentially is a bad
328:34 - request so let's try it out
328:37 - i'm going to go back to my controllers
328:39 - and here i'll say if
328:42 - and then if there's no username
328:44 - username and the setup let me move these
328:47 - ones up
328:49 - and i'll add that comment check
328:52 - in the controller
328:54 - in the controller and once we're done
328:56 - i'll actually show you how we could have
328:58 - used that in task manager as well so
329:01 - let's go down and then we have username
329:04 - if it doesn't exist or
329:06 - if the password doesn't exist so
329:09 - essentially if one or both are missing
329:12 - then we want to throw that error why
329:13 - well because that's what we can do since
329:16 - we have that express async errors now
329:19 - what error are we looking for of course
329:21 - that is our own one
329:23 - so in the controllers what we want to do
329:26 - is import our custom error so let's go
329:29 - here with const custom
329:33 - api error now that is equal to require
329:36 - we're looking in the errors in this case
329:39 - and more specifically we're looking in
329:41 - the custom one
329:43 - and if
329:44 - the user hasn't provided the values of
329:47 - username and password then of course we
329:49 - can simply throw a new error and
329:51 - remember this is going to be handled in
329:53 - our own error handler middleware correct
329:56 - the middleware that we set up it's going
329:58 - to check for our own
330:00 - api error and if that is the case then
330:03 - we'll send back the status with the
330:05 - status code as well as the error message
330:07 - so now we simply want to throw new
330:10 - custom api error my apologies i started
330:13 - typing error actually we need to go with
330:15 - custom api error and here we'll say
330:17 - please provide email and password and as
330:20 - far as the error code it's going to be
330:21 - 400. so 400 stands for bad request and
330:25 - once we have the code to throw the error
330:27 - now i can remove this cancel log
330:29 - and let's just go back to the postman
330:31 - and test it out
330:32 - so if i haven't provided anything i
330:36 - should have please provide email and a
330:38 - password and status code should be 400.
330:42 - again
330:43 - if you already forgot how the custom api
330:46 - error works and all that please go back
330:48 - to the previous project
330:50 - i believe we set it up in task manager
330:53 - where i covered all of this e in great
330:55 - detail so essentially if these two
330:57 - values are not provided we have three
331:00 - options we can either use and you
331:03 - know just so it's less confusing i'll
331:04 - write here mongoose validations or we
331:08 - can set up another validation layer with
331:10 - the help of package by the name of joy
331:13 - which we'll do later or we can simply
331:15 - check in the controller
331:18 - and just to showcase
331:20 - if you take a look at the task manager
331:22 - so remember that was our third project
331:24 - where we essentially just started
331:26 - working with database more specifically
331:28 - if we're looking in the controllers
331:31 - and then create task remember we handle
331:34 - this with the help of mongoose correct
331:37 - because if you take a look at the models
331:39 - you'll see the name and this one is set
331:41 - to required now the same way we could
331:44 - have just checked e in the controller we
331:47 - could have just said okay
331:48 - check if the task exists
331:51 - if it doesn't exist we throw the error
331:53 - in this case it was a little bit
331:54 - different we used next since we used our
331:57 - own async wrapper the general idea
331:59 - doesn't change we're still throwing the
332:01 - error and if everything is great then
332:04 - we're creating a task and the only
332:06 - reason why i'm telling you all of this
332:08 - is just so i understand that you have
332:10 - multiple options you're not limited to
332:13 - just setting up the validations in the
332:16 - mongoose yes you should do it it doesn't
332:18 - mean that you should skip that part just
332:20 - be aware that there's extra layers of
332:22 - validation that we can add and in our
332:25 - case we simply set them up right in the
332:28 - controller so if the username or a
332:31 - password is not provided just throw the
332:33 - error which gets handled in our own
332:36 - middleware in the error handler one and
332:39 - here we just check for the custom api
332:42 - and then we send back the response and
332:44 - of course if that is the case we don't
332:46 - send back this string we send back the
332:49 - error
332:50 - all right we check for empty values now
332:52 - what well now we need to create a json
332:55 - web token and send it back but before we
332:58 - do that let's back up a little bit and
333:00 - take a look at the big picture one more
333:02 - time so far we have been setting up all
333:05 - our routes in the following fashion as
333:07 - long as the endpoint exists user just
333:09 - needs to make a request and our server
333:11 - will send a response but that's about to
333:14 - change from now on we'll have two types
333:17 - of routes
333:18 - the public ones accessible by anyone and
333:21 - restricted ones accessible only with
333:24 - correct signed jwt or json web token so
333:29 - back to our app
333:30 - if the user provides correct credentials
333:33 - meaning in our case of course those are
333:35 - just some values in the username and
333:38 - password we send back the signed json
333:41 - web token and in order to access
333:43 - dashboard wrote he or she basically a
333:46 - frontend needs to provide the same token
333:49 - otherwise we'll kick it back with an
333:51 - error response and before we analyze the
333:54 - structure of the json web token let's
333:56 - talk about some big picture things first
333:58 - and let's start with general concept
334:01 - json web token is just a way to exchange
334:04 - data between two parties and probably
334:06 - the most common example for such parties
334:09 - is a front-end app and our api
334:12 - now why using jwet
334:14 - is far better
334:15 - than just some random string
334:17 - simply because jwt has a security
334:21 - feature
334:22 - where we can be sure about the integrity
334:24 - of our data if the token passes the
334:27 - validation it means
334:29 - it's the same token we sent to the
334:31 - client
334:32 - and the data wasn't tampered with second
334:34 - for now don't worry how and where the
334:36 - front end will store the token i'll
334:38 - discuss it in more detail in a few
334:40 - videos and third please keep in mind
334:42 - that one of the features of http
334:45 - is that it is stateless and that simply
334:48 - means that server does not know or you
334:51 - can think does not remember any previous
334:54 - requests
334:55 - sent by the same client
334:57 - and as a result yes
334:59 - even after the first second or even the
335:02 - 200 successful dashboard request
335:05 - frontend
335:06 - will still need to provide the valid
335:08 - token otherwise the axis will be denied
335:11 - remember how i suggested to think of
335:13 - jwts as long strings well of course it's
335:17 - way more complex than that so now let's
335:20 - spend few minutes on the jwt structure
335:23 - and then of course we'll dive back into
335:25 - the code
335:26 - and a very good resource is cite by the
335:29 - name of
335:30 - jwtio
335:32 - again the url is jwt io and more
335:36 - specifically we're interested in two
335:38 - pages the introduction one and the
335:41 - debugger and i'll start with
335:42 - introduction and i'm not going to read
335:45 - the entire thing line by line that just
335:47 - seems a big waste of your time but i do
335:50 - want to point out some things here and
335:51 - there as always if you are interested in
335:53 - learning more you know already where to
335:55 - find it
335:56 - and the first thing that i want to point
335:58 - out is this sentence where it says this
336:00 - information can be verified and trusted
336:03 - because it is digitally signed so this
336:06 - is what i was saying in a previous video
336:09 - essentially we do that using the secret
336:12 - and the algorithm and we'll learn more
336:14 - about them in a few seconds so let's
336:17 - just keep on scrolling they say when you
336:18 - should use tokens okay
336:21 - and this is going to be the structure
336:23 - for the web token and like i said the
336:26 - result is going to look like a large
336:28 - string but of course it's way more
336:30 - complex than that and essentially in the
336:32 - json web token we have the header
336:34 - payload as well as the signature
336:38 - and when it comes to header consists of
336:40 - two parts and one is going to be the
336:42 - type of token and of course we're going
336:44 - to go with jwt and the second one is
336:47 - going to be the algorithm that is used
336:49 - of course to create that signature then
336:53 - this one gets encoded with base64 url so
336:57 - we'll code this one
336:58 - and then we have the payload in the
337:00 - payload this is where we'll place the
337:02 - information
337:03 - and as an example we can place here the
337:05 - id of the user that just signed on or
337:09 - logged in or registered or whatever
337:11 - then we send back the token the entire
337:14 - token with that payload back to the
337:16 - front end
337:17 - then the front end sends it back to us
337:19 - and then when we decode we get that id
337:23 - and essentially what that means
337:25 - is that if the user has some kind of
337:27 - resource we access right away resources
337:30 - that belong to only that user so
337:33 - essentially if you create some kind of
337:35 - resource
337:36 - only you can access it
337:38 - or modify modified or whatever then we
337:40 - keep on scrolling keep on scrolling and
337:42 - i'll talk about the payload of course
337:44 - when we actually create our own token
337:47 - this is just an example of what we can
337:49 - send back again this also gets encoded
337:53 - with base64 url and then lastly we have
337:56 - the signature
337:58 - and as far as the signature this is
338:00 - where the algorithm is used the one that
338:02 - is specified in the header and then we
338:05 - add here the secret to sign our token
338:09 - and as far as the secret this is
338:11 - something that we'll have to keep on the
338:13 - server
338:14 - and again i'll talk about when we
338:16 - actually create our own signature so
338:20 - once we set up our first token then i'll
338:23 - talk about it how and where we should
338:26 - store the secret value and the idea is
338:28 - we have the algorithm we have the
338:31 - encoded header as well as the payload
338:34 - then we take the secret string value
338:37 - that is always going to be only on the
338:39 - server
338:40 - and then we sign this one and then once
338:43 - we sign this is going to be a result so
338:46 - essentially this is what we're sending
338:48 - back to the front end and after that we
338:50 - have a bunch of useful information of
338:52 - how we can send back the token
338:54 - from the front end and this is something
338:56 - again we'll cover a little bit later
338:59 - once we already create our token so
339:01 - we'll swing back and i'll discuss what
339:03 - is the better and all this cool stuff
339:06 - and as far as the structure i think
339:08 - we're pretty much done i just want to
339:10 - showcase in debugger that of course we
339:13 - have the token like i said this is the
339:16 - signed token the encoded one and this is
339:19 - what we're sending back to the front end
339:21 - so this is what the front end will
339:22 - receive
339:24 - now once we decode there you go you'll
339:26 - have information about that user so
339:29 - you'll have some kind of id maybe a name
339:32 - and when it was issued and of course
339:35 - later we'll do something with that data
339:37 - so this is that id that we're looking
339:39 - for the user id and then we can use this
339:42 - id to access the database resources and
339:45 - all that cool stuff hopefully we're
339:47 - clear on the structure
339:49 - so now we can take a look at the package
339:51 - we'll use to sign and decode our tokens
339:55 - when it comes to signing and decoding
339:57 - our tokens there are quite a few
339:59 - packages out there so you definitely
340:01 - have plenty of options but for my
340:03 - projects i usually use package by the
340:06 - name of json web token of course if
340:09 - you're using starter i already installed
340:11 - it for you but if you ever want to use
340:14 - it in your own project just run this
340:16 - command and as far as the docs since
340:18 - we'll use only two methods i'm pretty
340:20 - sure i won't return here but of course
340:23 - if you ever need more info just utilize
340:25 - the search engine nice and once we have
340:28 - discussed the general principles of jwt
340:32 - now let's try to issue one
340:34 - in the project
340:36 - and first what we want to do
340:38 - is import the package and again the
340:41 - package we're looking for is this one
340:43 - the
340:44 - json web token and of course we want to
340:47 - assign it to some kind of variable so
340:49 - i'm going to go with jwt is equal to
340:52 - require and of course we're looking for
340:54 - the package and once we have the package
340:57 - after the if assuming
340:59 - that both of the values are provided we
341:02 - want to create a new token
341:04 - and we do that in following way so we
341:07 - come up with some kind of variable in
341:08 - this case again it's going to be a token
341:10 - pretty straightforward and then we go
341:12 - with jwt so the package name and then
341:16 - we're looking for the sign method
341:19 - and then in the sign method
341:22 - we want to provide three values we want
341:24 - to provide a payload
341:27 - a jwt secret
341:29 - essentially is just a secret string
341:32 - and then the options
341:34 - now when it comes to payload you go with
341:37 - object and pretty much in here you can
341:39 - pass whatever you want sky's the limit
341:42 - now please remember one thing you don't
341:44 - want to send back some kind of
341:46 - confidential information so don't stick
341:49 - a password over here that is a very very
341:52 - very bad practice now what normally gets
341:55 - sent back well if we're creating a user
341:58 - a id is very helpful because then later
342:01 - on when we're authenticating the request
342:05 - we can check for the user if i'm
342:07 - creating a user and that user is i don't
342:11 - know checking for some kind of resources
342:13 - we only provide resources
342:15 - that belong to the user
342:18 - so in our task manager application
342:21 - we only provide tasks that belong to the
342:25 - user and as a result only the user
342:29 - who created task for example can view it
342:32 - or it and hopefully you get the gist
342:35 - so in here i'm just gonna go with
342:37 - username that was already provided over
342:40 - here so that's what i'm sending back and
342:42 - like i said normally send back the id
342:44 - but since we don't have the connection
342:47 - to the database
342:48 - i'll create a dummy one from scratch
342:51 - i'll simply go with id
342:52 - and then i'll go with new date and i'll
342:55 - say get time and let me just add a
342:58 - comment just so it's clear that this is
343:00 - only for demo and once i have both of
343:03 - the comments first i'll add the id
343:06 - and then i just want to mention here
343:08 - that when it comes to payloads it's a
343:10 - good idea to keep them small because the
343:12 - bigger the payload the more data you're
343:14 - sending over the wire and of course as a
343:16 - result for someone with bad internet
343:19 - connection the user experience might not
343:22 - be the best one so that's about it for
343:24 - the payload and then we want to provide
343:26 - that jwt secret so we go here with a
343:29 - comma
343:30 - and we right away want to set it up in
343:33 - our dot envy so of course we need to
343:36 - create one from the scratch and in the
343:38 - star we're going to go with new file dot
343:41 - env and then we need to come up with a
343:43 - variable name and in my case i'm going
343:45 - to go with jwt underscore
343:49 - secret and when it comes to value
343:52 - in this application i'm just going to go
343:54 - with something really simple as jw
343:57 - secret
343:58 - but let me grab the comment that i left
344:00 - here
344:01 - just for a demo
344:03 - in production use long complex and
344:07 - unguessable string value and when it
344:10 - comes to more complex projects i'll show
344:12 - you how we can create one so let me just
344:14 - take this one out
344:16 - and then i think i'll just leave that in
344:18 - the controller there
344:20 - right below the payload small comment
344:23 - where again you always always when it
344:26 - comes to production you want to have
344:28 - them long complex and unguessable in
344:31 - this case we're just cheating because i
344:33 - don't want to bother with that so we go
344:35 - with variable and then some kind of
344:37 - value and now of course we just need to
344:39 - go back to the controller here
344:41 - and then remember we can access it with
344:44 - process dot env and then more
344:47 - specifically
344:49 - we're looking for jwt
344:51 - and then underscore secret and if you're
344:54 - confused or just wondering why we're so
344:57 - fussy about this jwt secret string if
345:01 - you recall the json web token structure
345:03 - video
345:04 - this is the secret that is used to sign
345:06 - r tokens and therefore it's a good
345:08 - practice to only keep it on the server
345:11 - and make it more complex than our
345:14 - current jwt secret
345:16 - just keep in mind that if someone gets a
345:18 - hold of your key
345:20 - they can start signing tokens on your
345:22 - behalf and that's definitely not the
345:24 - spot you want to be in as you can see
345:26 - even in the docs they suggest your 256
345:30 - bit secret and like i already mentioned
345:33 - in the following project i'll show you
345:35 - where and how
345:36 - we can set up a proper secret value in
345:39 - no time and then the last thing we want
345:41 - to provide
345:42 - is options and we're going to go with
345:45 - expires in option
345:46 - and i'll set it equal to 30 days
345:49 - and i'll come back and talk about the
345:52 - expirations and all that a little bit
345:54 - later so once we have the token now of
345:57 - course we want to change our response
345:59 - where instead of the string
346:01 - we're going to go with actual status so
346:04 - set it up over here 200
346:07 - then that
346:08 - and of course we're going to be looking
346:09 - for the json here
346:11 - and then let's just add here a message
346:15 - and we'll say user created
346:17 - user created and this is the case where
346:19 - the front end is using that message
346:22 - so i strongly suggest keeping it the
346:24 - same way and then we'll go with token so
346:28 - effectively we have our token and now we
346:31 - just want to send back to the user so
346:34 - once we save we're going to go back to
346:37 - the login one and in this case i'll try
346:40 - one more time providing empty values and
346:43 - of course in that case i get back my
346:45 - error one but if i go here and if i say
346:49 - john
346:50 - and secret i should
346:53 - get back my json web token and of course
346:56 - i do and what's really cool
346:58 - if you take this value
347:00 - and just head back to the website
347:03 - and just copy and paste what do you know
347:06 - of course now i have username some kind
347:09 - of fake id and this is going to be the
347:12 - expiration so as you can see
347:14 - this is the payload
347:16 - that we're sending
347:18 - not bad not bad we signed a token
347:20 - sent it back to the front end now
347:23 - well first we need to understand how the
347:25 - request with the token already present
347:28 - is going to look like
347:30 - but before we continue let me just
347:32 - emphasize something
347:33 - since it's a backend course we're not
347:36 - going to dwell too much
347:37 - on do's and don'ts on the proper
347:40 - jwt storage on a front end yes of course
347:44 - there are best practices and don't get
347:46 - me wrong they are important but our
347:49 - current goal is to secure resource
347:51 - access on the server
347:53 - and therefore we're only really
347:55 - interested in how the request is going
347:57 - to look like so we can implement the
348:00 - correct functionality on our end and if
348:03 - you keep reading the introduction you'll
348:04 - see that a common approach on a
348:07 - front-end is to set up the authorization
348:10 - header
348:11 - in your request so of course in our case
348:14 - that is going to be a get request
348:16 - and then add the bearer schema
348:18 - essentially what that means is that we
348:20 - have the header by the name of
348:23 - authorization
348:24 - then we go with bearer and then space
348:27 - and then the token and in this video
348:29 - i'll show you how it looks like on the
348:31 - front end as well as the front end code
348:34 - and then in the next video we'll do it
348:35 - together in a postman
348:38 - and basically the idea is following
348:40 - where i have the username password and
348:42 - all that and i just go here with peter
348:44 - and then i pass in my secret
348:47 - and what i want you to see
348:49 - is the local storage because of course
348:52 - at the moment we have nothing in there
348:54 - and the idea is following where i will
348:57 - get back to token because of course i'm
348:59 - providing some kind of values in the
349:01 - username as well as the password and now
349:04 - check it out here i have token so now of
349:07 - course
349:07 - when i'm making that next request so if
349:10 - i go here with get data of course in my
349:13 - code i just grab the token from the
349:15 - local storage and of course i'm
349:17 - successful and if we take a look at the
349:20 - network requests so again this is going
349:22 - to be for the login this is to get the
349:24 - token and then of course as far as the
349:27 - dashboard just open it over here and
349:29 - notice the headers so we keep on
349:32 - scrolling the request headers blah blah
349:34 - blah and what we're looking for of
349:36 - course is this authorization one so
349:39 - that's the one that we want we have
349:41 - authorization then we have the bear and
349:44 - then of course we have the token
349:47 - and if you're interested in a code just
349:49 - navigate to browser app.js
349:52 - and first what you want to do is to look
349:55 - for the form event listener we're
349:57 - listening for the submit event and then
350:00 - in here i have try and catch and in the
350:03 - try and catch i'm using axiorys library
350:06 - with a post request and surprise
350:08 - surprise i'm sending this post request
350:10 - where to a login one and what am i
350:13 - passing in passing in username and
350:15 - password and what happens if i'm
350:18 - successful notice this line of code we
350:20 - go with local storage set item token and
350:24 - then whatever i got back from the server
350:27 - so i right away save this token in the
350:30 - local storage now there's also a catch
350:33 - and in this instance i just removed the
350:36 - token now again this is just my
350:37 - preference just so i can demonstrate
350:39 - things but hopefully you get the overall
350:42 - idea that of course on the front end
350:44 - you'll store this token somewhere
350:47 - and then of course when it comes to
350:49 - actual request
350:50 - i have the button i have the event
350:52 - listener the click event listener and
350:55 - then i'm issuing a get request
350:58 - of course where is it going it's going
351:00 - to the dashboard and the way we add the
351:02 - headers again this is just for axiorys
351:04 - library but the idea is going to be
351:06 - exactly the same for fetch or any other
351:09 - ajax library where you'll go with
351:11 - headers and then of course the name is
351:14 - authorization and then like i said we go
351:16 - with bearer schema and then we add the
351:19 - space and then we pass in a token and as
351:22 - you can see i'm getting this token
351:24 - from the local storage and of course
351:27 - let's take a look how we can send the
351:28 - same request
351:30 - with a postman and once we have
351:32 - discussed in theory how we can send back
351:35 - the token let's try doing that in the
351:38 - postman so in a login every time i send
351:42 - a successful request meaning where the
351:44 - username and password
351:47 - are valid values instead of empty
351:49 - strings then of course we're getting
351:51 - back the token
351:52 - and of course all this time i'm creating
351:55 - with john but just understand that every
351:57 - time we're getting that unique token
352:00 - and what we want to do
352:02 - take this token so copy this one and of
352:05 - course don't worry later we'll set it up
352:07 - with different usernames at the moment
352:09 - there's really no need for that and then
352:12 - back in the dashboard so in our get
352:15 - request we're not looking for the body
352:17 - we're looking for the headers and in the
352:20 - following project i'll show you how i
352:22 - can do that dynamically in postman
352:24 - because of course when it comes to
352:25 - bigger project is going to get annoying
352:28 - really fast if you have to all the time
352:31 - copy and paste those tokens just to test
352:33 - something out but in this project yes
352:36 - we'll do this manually so again we are
352:39 - in the dashboard that's the route of
352:41 - course it is get and all that and then
352:43 - we're looking for the headers and header
352:46 - name is going to be the authorization
352:48 - one
352:49 - then we want to set it equal to bearer
352:52 - that's the name and you have to follow
352:55 - this to the t
352:56 - so bearer and then copy and paste the
352:59 - token so now of course
353:01 - if we send
353:03 - yeah we get the value blah blah blah we
353:05 - have the number but what's more
353:06 - interesting if we go back to the
353:08 - dashboard and if you log request headers
353:12 - you'll see something really cool where
353:14 - if i go with request and like i said
353:17 - headers now let me send one more time
353:19 - again the token is still valid we have
353:22 - 30 days so everything is going to work
353:24 - if i scroll up check it out we have
353:27 - authorization header and then of course
353:30 - i have the bearer and then this is the
353:33 - value
353:34 - and this is what we'll do in the
353:35 - following videos
353:36 - we'll extract this
353:39 - and actually validate it and if it is
353:41 - valid only then we'll send back the data
353:45 - with the actual username the moment of
353:48 - course we just have john doe but
353:50 - eventually we'll set up where whatever
353:52 - username gets sent back to the front-end
353:55 - well that one will send back here
353:58 - because that way we'll showcase that we
354:00 - only access
354:01 - the specific resources that the user has
354:05 - not just some random ones
354:06 - beautiful
354:08 - and in order to get to this value we'll
354:10 - just have to do a little bit of
354:11 - javascript magic
354:13 - and we'll also have to throw a few of
354:15 - the errors if the values are not
354:18 - provided
354:19 - so in dashboard first i want to assign
354:22 - that authorization header to some kind
354:25 - of variable and in my case i'm going to
354:26 - go with auth header and then i'm looking
354:29 - for a request
354:31 - and then of course headers like i said
354:33 - and then we're looking for the
354:35 - authorization one so once i have access
354:38 - to the header then i want to check
354:41 - whether it actually exists because maybe
354:44 - user is sending a request without the
354:47 - header altogether and if it exists
354:50 - whether it starts with a better and then
354:54 - the space again this is very very
354:56 - important that the syntax is exact
354:59 - because if it's not going to be exact
355:00 - then of course all of this loses the
355:03 - meaning so let's say here if
355:05 - and then off header so if it doesn't
355:07 - exist or
355:09 - the auth header
355:11 - and then starts with that's the method
355:13 - that we can use on javascript strings
355:16 - and in here i just want to say if it
355:19 - doesn't start with the bearer then of
355:22 - course we'll throw the error so if there
355:25 - is no authorization header
355:27 - or it doesn't start with bearer then of
355:30 - course we'll throw our custom error
355:34 - so i'll just add here bear
355:36 - and then the space now if that is the
355:39 - case what we can do
355:40 - well we can throw our own custom error
355:43 - and in order to speed this up i'm just
355:45 - going to copy and paste we're throwing
355:47 - the error and normally you're going to
355:49 - be way more awake than this but in this
355:52 - case since we're of course just testing
355:54 - the jwts i'll say here no token provided
355:59 - in that case if you hit some kind of
356:01 - roadblock at least you know where the
356:03 - error is coming from and when it comes
356:05 - to text normally it's going to be along
356:06 - the lines of invalid credentials to
356:09 - access this route and as far as the
356:11 - status code instead of 400 it's going to
356:15 - be a 401 so that is not a bad request
356:20 - that is actually the authentication
356:22 - error but again in this case just to
356:24 - make it easier if you need to debug i'm
356:26 - gonna go with no token provided
356:29 - and then as far as the error we're gonna
356:31 - go with
356:32 - 401 and of course in order to test it
356:35 - out why don't we go back
356:37 - and then i'm just gonna uncheck the
356:40 - authorization just so we can actually
356:42 - see what we get back and once we click
356:45 - check it out now we have message no
356:48 - token provided and what is the error of
356:50 - course error is 401
356:53 - now if i go back to the authorization
356:56 - header and if i send now i can see
356:59 - something went wrong
357:00 - try again later
357:02 - that's interesting so let me double
357:04 - check my code and yes of course it
357:07 - starts with not start with so let me try
357:10 - one more time
357:12 - let's send and there you go now of
357:14 - course we have hello john though and of
357:16 - course the secret as well and once we
357:18 - have passed the first stage now i just
357:20 - want to get that token and we can access
357:23 - it in a following way where i'm going to
357:24 - go with cons token is equal to auth
357:27 - header and then we want to split it
357:30 - again this is a string so we split it on
357:32 - a space and we're looking for the second
357:35 - value
357:36 - and if you want to double check let's go
357:39 - with token and let's cancel log it just
357:42 - so we are on the same page so let's send
357:44 - one more time and as i know there's a
357:46 - tiny bug there as well
357:48 - and you should see
357:49 - in the console
357:51 - a token
357:52 - and i'm also going to fix it over here
357:55 - what i'm going to say your lucky number
357:57 - and once we have all of this in place
358:00 - now of course we just need to set up the
358:02 - verification where yes we got back the
358:05 - token from the front end however now we
358:08 - want to verify
358:09 - whether the token is actually valid and
358:13 - as far as verification goes something
358:15 - like this
358:16 - where if you take a look at the docs of
358:18 - the package
358:19 - the json web token one you'll see that
358:22 - one of the options we have is using
358:24 - try catch and then we just need to come
358:27 - up with some kind of variable name in my
358:28 - case i'm going to go with decoded and
358:31 - that is equal to the package so jwt
358:35 - now the method name is verify and here
358:38 - we need to pass into values we need to
358:40 - pass in the token
358:42 - and then the second value
358:44 - is that secret string so again we go
358:47 - with our process
358:49 - dot env and then the jwt and if there's
358:53 - some kind of error for example
358:56 - the token might be expired we'll handle
358:59 - that in the catch block and what do we
359:02 - want to do well we want to throw another
359:04 - custom error and this is going to be the
359:07 - case where i'll show you that vague
359:09 - response where again we'll throw custom
359:12 - error if we're not able to verify the
359:14 - token and as far as the response will
359:16 - say not authorized to access this route
359:19 - hopefully this is clear so we try to
359:22 - verify
359:23 - if there's any kind of issue we throw
359:25 - another custom error and in this case we
359:29 - go with not authorized to access this
359:30 - route and again the code is still 401
359:35 - because that is authentication error and
359:38 - then of course if we're successful then
359:40 - we just keep on typing because all the
359:43 - data is going to be in this decoded now
359:46 - what data you might ask well let's go to
359:48 - console.log and let's check it out
359:50 - together so let's cancel log one more
359:52 - time
359:53 - let's send it here
359:55 - and now of course you can see that i get
359:57 - back my id username as well as other two
360:00 - properties issued at
360:02 - and expiration and of course
360:05 - all of this is coming from our payload
360:08 - the one that we passed over here
360:10 - when we signed the token so of course
360:13 - you can already imagine that if the name
360:15 - is going to be different for the user
360:17 - name of course this value will also
360:20 - change and by accessing that value now
360:23 - of course we can set up a dynamic
360:25 - response so what do we do over here
360:28 - we just say okay we have access to the
360:31 - decoded one so let's take our code and
360:34 - just move it up place it in the try
360:36 - block
360:37 - and then instead of just console logging
360:40 - i'll keep the random one and all that
360:41 - don't worry there's gonna be a little
360:43 - bit different setup in a second anyway
360:45 - but instead of john doe we'll go over
360:48 - here with decoded and what is the
360:50 - property that i'm looking for on the
360:52 - object of course that is the username so
360:55 - we just go back over here to the
360:56 - username and if i navigate back to the
360:59 - postman now of course once i send i'll
361:02 - get back to john so let's go over the
361:04 - steps in the postman first and then
361:07 - we'll try it out in the front end in our
361:10 - application so first let's go with login
361:13 - again i'll try to log in without
361:16 - providing the username for example i'll
361:19 - send it over here now of course i have
361:21 - please provide email and password so
361:23 - that was that first check so if we are
361:26 - successful here if i provide peter
361:29 - then of course i'll get back my token
361:32 - awesome and i can see that the user has
361:34 - been created
361:35 - then we want to go to the dashboard and
361:38 - where we have authorization header now i
361:41 - want to change this around where instead
361:44 - of this value again just make sure
361:46 - there's that space that's a big deal
361:48 - here we'll provide this value instead
361:51 - and now of course i have hello peter and
361:53 - then again some random lucky number
361:56 - and if everything works in a postman it
361:58 - should also work on the front end so
362:01 - let's try it out over here let's refresh
362:03 - of course we can see no token present
362:06 - and here i'll just try to get the token
362:08 - without providing the values and of
362:09 - course not successful
362:11 - so i get back the error and therefore
362:14 - i'm going to go with anna and then again
362:16 - some kind of dummy password we send it
362:19 - now we're successful
362:21 - user has been created of course i can
362:23 - see that token is present oftentimes the
362:26 - token is going to be in local storage
362:28 - and of course it is so now of course
362:29 - when we're making those following
362:31 - requests
362:32 - now the token is present so we're
362:34 - successful now we can clearly see our
362:37 - username and then we're getting those
362:40 - random values so all the following
362:43 - requests are going to be successful as
362:46 - long as we provide a token and since
362:48 - token is in the local storage of course
362:51 - we can always access it when we make it
362:54 - and then we're good to go now if we
362:56 - remove it and in this case i just set up
362:59 - the functionality that if the user tries
363:01 - to
363:02 - get the token without providing the
363:04 - values then i just wipe out the token
363:08 - in the local storage so if we go back
363:10 - notice it's actually empty now i'm not
363:12 - saying that that's always going to be
363:14 - set up on the front end it's just
363:15 - something that i used in this case so
363:18 - now if we go back again we don't have
363:20 - the token so we get this not authorized
363:23 - to access this route nice work we're
363:26 - actually done with the main
363:27 - functionality but just like in a
363:29 - previous project once everything is in
363:31 - place let's also work on some
363:33 - improvements which we'll use heavily in
363:36 - the following projects and first i want
363:38 - to set up the authentication middleware
363:40 - and essentially the idea is following
363:43 - where yes at the moment we have the
363:45 - dashboard route and in there we're
363:47 - successfully checking whether the json
363:50 - web token has been provided and of
363:53 - course if it's there then we send back
363:55 - the lucky number if not then we throw
363:57 - the error but we need to understand that
364:00 - in a more realistic application of
364:02 - course there's going to be multiple
364:05 - routes that use this functionality and
364:07 - what are we going to do are we really
364:09 - going to copy and paste for every route
364:11 - that needs it or
364:13 - it just makes more sense to take all
364:16 - this code stick it in the middleware and
364:18 - then just choose which routes need to be
364:21 - authenticated and of course the answer
364:24 - is setting up our own middleware so
364:26 - first let's go to the middleware
364:28 - directory in there you'll find
364:30 - auth.js and we'll just start very simply
364:33 - by creating a function that function of
364:35 - course is going to be a sync and we'll
364:37 - be looking for rec res and next and next
364:41 - is very very important because otherwise
364:44 - our whole cycle is going to break and
364:47 - then of course we just want to cancel
364:49 - log so in the beginning we'll just
364:50 - cancel log and then we'll set up the
364:52 - functionality let's go over here as
364:54 - always naming is really up to you i'm
364:56 - gonna go with authentication and then
364:59 - middleware and that is equal to like i
365:01 - said async
365:03 - then we go with request and response and
365:06 - then next because remember in order to
365:08 - move on to the next middleware which of
365:09 - course in our case is going to be a
365:11 - dashboard route we'll have to call next
365:14 - and i'm going to go with console.log
365:16 - then i'm looking for rec
365:18 - headers and then more specifically i'm
365:20 - looking for the authorization one i just
365:23 - want to check whether it exists
365:26 - and then i want to go next like i said
365:29 - and then of course we invoke it now we
365:31 - just need to export this so we're going
365:33 - to go here module
365:35 - and export
365:38 - and that will be equal to my
365:40 - authentication middleware function
365:43 - and now another million dollar question
365:45 - so where are we going to use this
365:47 - middleware now in a later project
365:50 - we'll actually use it on multiple routes
365:52 - but in this case we only have dashboard
365:55 - that needs it correct so as far as the
365:57 - login this is going to be for public
366:00 - access
366:01 - but when it comes to dashboard this is
366:03 - going to be protected by that
366:05 - authentication middleware so therefore
366:07 - in the router in the managers we're
366:10 - going to go here const and then of
366:12 - course i'm looking for my function and
366:15 - in this case i'm just going to call this
366:17 - auth
366:18 - middleware and that is equal to require
366:20 - of course
366:21 - then we had the middleware folder and
366:23 - the auth file and the syntax is
366:25 - following where where we have this get
366:28 - method
366:29 - before the dashboard i actually want to
366:32 - stick my middleware so i'm going to say
366:34 - auth
366:35 - and then middleware and i'll add comma
366:38 - so now of course every time
366:40 - someone's going to be hitting this route
366:42 - first they'll go through the middleware
366:45 - and of course in the middleware since i
366:46 - have next then i'll pass to the
366:49 - dashboard
366:50 - and in order to test it out i'm just
366:52 - going to navigate to the browser so this
366:54 - is where i have the working application
366:56 - and it doesn't really matter whether
366:58 - you're logged in or not just go here to
367:01 - get data
367:02 - and of course in my case i haven't
367:04 - logged in i have no token so therefore
367:06 - i'm getting back this not authorized
367:09 - access this route but what i'm more
367:11 - interested
367:12 - is back in my application in the console
367:15 - i can see bearer and that is set to null
367:18 - so now i know that
367:19 - all the requests that are going to the
367:22 - dashboard are actually hitting this off
367:24 - middleware first so now of course we
367:26 - just need to add the functionality and
367:28 - we'll be in good shape beautiful
367:30 - and once our bare bones setup is in
367:33 - place
367:33 - now we simply want to go back to the
367:35 - controller the main one and we'll need
367:38 - to copy and paste two things and again
367:40 - i'm just doing this just so we can get
367:42 - to the functionality and you're looking
367:44 - for jwt because of course we'll
367:47 - implement that functionality as well as
367:50 - the custom api error and as i said not
367:53 - in the following videos we'll work on
367:56 - more errors so essentially we'll create
367:59 - here more error classes so i'll have to
368:01 - do some refactoring as well but for time
368:04 - being we'll just grab these two lines of
368:07 - code we want to go back to the auth we
368:10 - want to make sure that the paths are
368:12 - correct so as far as json web token of
368:14 - course it doesn't really matter i mean
368:16 - that's the package we installed we just
368:18 - want to make sure that this path is
368:20 - correct
368:21 - and it looks about right so now of
368:23 - course let's go back to the controllers
368:26 - let's keep scrolling keep scrolling
368:28 - so of course that was the previous route
368:31 - the login one and as far as the
368:33 - dashboard we simply want to take this
368:36 - logic where we're looking for the header
368:38 - and if there's some kind of issue of
368:40 - course we just throw the custom api
368:43 - error
368:44 - then we get the header and if everything
368:46 - is great
368:47 - if we can verify the token then instead
368:50 - of setting up right away response in our
368:53 - middleware we're actually going to set
368:55 - up a property on a request object and
368:58 - the property is going to be user and
369:00 - then we'll pass it to the next
369:02 - middleware which of course
369:04 - is going to be this dashboard route so
369:07 - let's go step by step let me take these
369:10 - i mean what is it five lines of code
369:13 - take it out so everything up to try and
369:15 - catch you want to go back to the auth js
369:19 - now you want to remove the console log
369:22 - and just keep the next because that is
369:24 - very very important
369:25 - then back in the controller you also
369:28 - want to take the try block but we'll
369:30 - have to do a little bit of acrobatics
369:34 - here because i'll actually need these
369:36 - lines of code so let's go back over here
369:39 - take the try catch as well step by step
369:42 - and then copy and paste and here the
369:45 - logic is following where you want to
369:47 - remove this response with lucky number
369:50 - so these things go you want to cut it
369:52 - out and go back to your controller and
369:56 - set it up in the dashboard so this logic
369:58 - stays of course the same where we have
370:00 - lucky number we generate that and of
370:02 - course we only send that response if
370:05 - we're successful now back in the author
370:08 - js like i said we're still checking for
370:11 - the header we're checking whether it
370:13 - starts with bear if not we throw the
370:16 - custom api error that's why we import it
370:18 - over here
370:19 - then we keep on scrolling we get to the
370:22 - split we get the token and now of course
370:24 - we have try and catch where we are
370:27 - invoking the verify method we pass in
370:30 - the token that we're getting back as
370:32 - well as the secret one and then if we're
370:35 - successful
370:36 - then instead of sending a response since
370:38 - we're working in the middleware the
370:40 - logic is going to be following where i'm
370:42 - going to go with const and then i'm
370:44 - looking for two things i'm looking for
370:46 - id
370:47 - and the username here and that one will
370:49 - be equal to decoded so of course
370:52 - if i'm successful this is going to have
370:54 - some kind of value if not we'll throw
370:57 - the error and then if that is the case i
370:59 - want to go with
371:01 - and i'll just set it up to the object
371:03 - where i'll have id
371:05 - and username and of course once i have
371:08 - set up the user property
371:10 - with this object value now of course i
371:13 - want to call next so
371:15 - we'll move this next up over here and
371:18 - what happens in the controller in the
371:20 - request we'll have that user property
371:24 - and now instead of looking for decoded
371:26 - of course we'll look for the user
371:28 - now in order to make it a bit more
371:31 - explicit i'll actually cancel log it
371:34 - just so you can see where it's coming
371:35 - from so i'm going to go here with rec
371:38 - and user so you can clearly see that
371:40 - we're getting that
371:42 - from our middleware of course and then
371:45 - instead of looking for decoded we're
371:47 - going to go here for user and username
371:51 - now in this case i also need to add
371:52 - direct since of course i didn't
371:54 - destructure it so on the request object
371:57 - and i have the user property and in
371:59 - there i'll have the username as well as
372:02 - id and let's just test it out one more
372:04 - time to functionality so again i'm gonna
372:06 - be on localhost 3000 i don't have the
372:09 - token so now of course i shouldn't see
372:11 - anything in the console and i don't
372:14 - because remember we only get to the
372:16 - dashboard if we're authenticated so
372:19 - let's try it out here where i'll say
372:21 - peter and then again my secret password
372:25 - i'll submit
372:26 - okay i created a user token as present
372:29 - and then once i click on getting the
372:31 - data now of course i have hello peter
372:34 - and i'm getting the lucky number and now
372:37 - if i take a look at the console check it
372:39 - out now of course on the request object
372:42 - once we get to the dashboard we actually
372:44 - have the user with id and username peter
372:48 - and of course this is coming from our
372:51 - middleware where essentially again we
372:53 - check for the authorization header then
372:56 - we check for the bearer we split it up
372:59 - we get the token then we use try and
373:01 - catch because we want to run the
373:03 - verify method and then we pass in a
373:05 - token we pass in the secret and then
373:08 - from the decoded we get the id and
373:11 - username and since we want to pass it to
373:13 - the next middleware
373:15 - essentially we create a new object we
373:17 - say user object on the request and then
373:20 - pass it on to the next middleware and of
373:23 - course if we're not able to verify the
373:25 - token
373:26 - then we send back our custom api
373:29 - response and again the end result is
373:31 - following where you can set up whatever
373:34 - amount of route you want
373:36 - and in front of all of them you can just
373:38 - stick off middleware and then you don't
373:41 - have to repeat this code the code is
373:42 - sitting in one place and check for token
373:45 - if the token is not present then you
373:46 - just send back the error response
373:49 - and once we have the middleware in place
373:51 - now i want to switch gears and talk
373:53 - about the errors
373:55 - and if we take a look at our application
373:57 - at the moment we have two types of
374:00 - custom errors we have one for
374:03 - 400 that's going to be the bad request
374:06 - and then we have another one for
374:08 - authentication where of course we have
374:10 - 401
374:12 - and technically we have been doing fine
374:15 - with just this one custom error but
374:17 - there's actually a better approach
374:19 - where yes we have custom api error
374:23 - that extends from the error so this
374:25 - logic stays the same
374:27 - but instead of just using this one class
374:30 - will actually extend from this custom
374:33 - api error and then for every type of
374:36 - error we have which again in our case r2
374:40 - we have one for battlequest and the
374:42 - second one for authentication we set up
374:46 - two more classes and then in those
374:48 - classes we right away hard code the
374:50 - status code and i fully understand that
374:54 - this might sound confusing so let's just
374:56 - start working on it and in the process
374:58 - you'll see what i mean so first what you
375:00 - want to do
375:01 - in the custom api error just remove the
375:04 - status code we'll set them up in
375:06 - separate classes and then we want to
375:09 - create three more files and we're going
375:11 - to start with index.js and you'll see at
375:14 - the very end of the video why we want to
375:16 - use that
375:17 - then we want to set up two more
375:19 - and we're looking for bad request
375:22 - and we'll go with js and then i'll set
375:25 - up another file by the name of on
375:28 - authenticated
375:30 - and then of course it is js
375:32 - and then in the bad request what we want
375:35 - to do
375:36 - is pretty much take the code that we
375:38 - have in the custom error one pretty much
375:41 - just copy and paste because we'll just
375:43 - change some things around so copy and
375:45 - paste over here
375:47 - and then i want to close this one
375:49 - so i'll say close saved
375:52 - and then instead of the custom api error
375:55 - we're going to go with bad request
375:58 - that request
376:00 - and of course this is going to be
376:01 - extending not from the error actually
376:04 - it's going to be extending from our
376:06 - custom api error so let's go here with
376:09 - const and we're looking for custom
376:13 - api error now this is in the same folder
376:15 - correct so we just go here with the
376:18 - require
376:19 - and then we pass in the path
376:21 - so the path of course is custom api
376:24 - error and instead of like i said
376:26 - extending from the error we're standing
376:28 - from custom api error and then we still
376:32 - have the constructor we don't want to
376:34 - use the status code over here and as i
376:36 - said not you know what
376:37 - in customer i also want to remove it
376:40 - so we just have the constructor and
376:43 - super here as far as the message and
376:45 - then in the bad request
376:47 - this is where not only we have super
376:50 - method with a message but it will also
376:52 - go with this dot status code
376:55 - status code and we'll set it equal to
376:59 - some kind of hard-coded value now for
377:01 - the battlequest what value we're going
377:02 - to use well we're going to go with 400
377:05 - and then of course instead of exporting
377:07 - custom api error we're going to go with
377:10 - bad request and now we simply want to
377:12 - take all of this code copy again just so
377:15 - we can save a little bit of time
377:17 - and paste in the
377:19 - authenticated one and then of course
377:21 - again i'll have to change some values
377:23 - around
377:24 - where this is going to be the
377:25 - unauthenticated error so let's go over
377:28 - here on
377:29 - authenticated
377:31 - and we'll call this error of course
377:33 - we're still looking for the custom one
377:36 - so we're still extending from this one
377:38 - now the status code is going to be 401
377:41 - and here we'll also say that we're
377:43 - exporting on authenticated error and
377:46 - then we want to go to index.js
377:48 - and here we'll import all three of them
377:51 - the custom error the bad request as well
377:54 - as the unauthenticated
377:56 - and then we'll export them as one big
377:59 - object and you'll see once we start
378:01 - factoring the application why it's more
378:03 - useful so essentially if you want you
378:06 - can technically leave it the way it is
378:07 - just remember that
378:09 - every time you'll need to use
378:11 - one of these you'll essentially need to
378:13 - look for that specific file
378:15 - if we set up this index.js first of all
378:18 - you'll be able to look just in the
378:20 - errors because by default the index.js
378:23 - will be served and in there we'll have
378:25 - all of the errors so let's start here
378:27 - with const and then custom api error and
378:31 - of course i'm looking for the file by
378:33 - the name of custom api error then we
378:36 - copy and paste and we just want to
378:38 - change these values around so of course
378:40 - this will be the bad request one and
378:42 - then last one will be that
378:44 - authentication one and of course we just
378:46 - want to change these files around
378:48 - so this will be the bad request one
378:51 - and then the last one will be equal to
378:54 - our authentication one and then we want
378:57 - to set up the object we'll say module
379:00 - exports and that is equal to our custom
379:03 - api error and then the battery quest one
379:06 - as well as the authentication one now of
379:09 - course at the moment our imports are a
379:12 - little bit different but before we do
379:14 - that i also want to talk about the
379:15 - status codes so let's just fix the
379:17 - status codes first and then we'll do
379:20 - both things we'll import the proper
379:23 - error classes in our application and
379:26 - also right away set up the status codes
379:29 - using the external library all right so
379:32 - far in our application every time we
379:34 - need a status code we just type the
379:37 - number value which is kind of okay but
379:39 - there's actually a better approach and
379:42 - that better approach is using the
379:44 - library by the name of http status codes
379:48 - and of course we need to install the
379:49 - library so this is the code if you need
379:52 - it for your own project in my case of
379:54 - course i already installed in the stars
379:56 - so that's why it's available and then we
379:58 - simply want to get the status codes from
380:02 - the library
380:03 - and then this is an object and then as
380:06 - far as the properties we just need to
380:08 - look for the text values for example for
380:11 - 200 we're going to go with ok
380:14 - now if you want to take a look at the
380:16 - codes of course just keep on scrolling
380:18 - and you'll notice that if we want to go
380:20 - with 200 response of course then we just
380:23 - type okay
380:24 - if we want to go with battlequest then
380:27 - we just type it and this is going to be
380:28 - 400 and hopefully you get the gist and
380:31 - as a result
380:33 - we'll accomplish two things
380:35 - it's going to be easier to understand
380:37 - what is happening as far as our
380:38 - responses
380:40 - instead of juggling the 400s and 401s
380:43 - and all that in your head and the second
380:45 - thing of course we'll have more
380:46 - consistency so let's try it out and in
380:49 - this video i'll just try it out here in
380:52 - the error classes and then of course in
380:54 - next video when we'll be refactoring our
380:57 - code since of course we have different
381:00 - setup for the errors then we'll also
381:02 - implement those status codes there as
381:04 - well
381:05 - and what we want to do is go to the bad
381:07 - request and then below or above the
381:09 - custom api error again this part doesn't
381:12 - really matter we're just going to go
381:14 - with const and then we're looking for
381:16 - status codes now this is a named import
381:19 - so make sure that the name is exactly
381:21 - the same
381:22 - status codes and then that one is coming
381:25 - from our library http status codes and
381:29 - then instead of this 400 we're going to
381:32 - go with status codes and then we're just
381:34 - going to be looking for bad requests
381:36 - notice how they right away give you all
381:38 - of these suggestions again it's easier
381:41 - to read it's easier to understand what
381:43 - is happening and second we'll have the
381:45 - consistency and we want to do the same
381:47 - thing in on authenticated as well so
381:50 - let's navigate to this file again we'll
381:53 - copy and paste just so we can speed this
381:55 - up so copy and paste we get the status
381:58 - codes and in this case of course we're
382:00 - not looking for the bad request which
382:02 - one we're looking for
382:04 - unauthorized so let's go over here let's
382:06 - say status codes dot
382:08 - and then we're looking for the
382:10 - unauthorized one and once we have fixed
382:13 - the error classes using the status codes
382:16 - now of course we just need to hop back
382:18 - to our application and refactor it since
382:22 - of course our error handling has changed
382:24 - as well awesome and as far as the
382:27 - refactoring we actually need to work in
382:29 - three files
382:30 - we want to look for our middleware so of
382:33 - course that is going to be the other one
382:34 - so let me just close all of them for now
382:37 - and then let's start from the scratch so
382:38 - like i said we're going to be looking
382:40 - for the auth middleware that's the first
382:42 - one
382:43 - then we also want to work in the main.js
382:45 - we'll have to
382:47 - change the code here as well and then
382:49 - lastly of course it's also going to
382:51 - happen
382:52 - in the error handler so where we have
382:54 - middleware for her handler we'll have to
382:56 - change some things around here as well
382:58 - so first let's start in the auth chairs
383:01 - now what error are we throwing over here
383:04 - well at the moment it is custom api
383:07 - error
383:07 - but actually what error is it well of
383:10 - course it is the authentication error
383:13 - correct and we already have the class
383:15 - for that which has the unauthorized
383:18 - status code so what we simply want to do
383:21 - is look for index.js so of course this
383:24 - is going to be the errors folder and
383:26 - then more specifically we want to look
383:28 - for this error i'm just going to copy
383:30 - this value and then back in the auth now
383:33 - of course we're exporting as named
383:35 - exports so we need to change this around
383:37 - where i'll say okay i'm expecting here
383:40 - the object and this is not going to be
383:42 - coming from the custom error it's
383:44 - actually going to be coming from the
383:46 - errors copy and paste and now of course
383:48 - i just get the
383:50 - unauthenticated error and then instead
383:52 - of the custom api error we're going to
383:55 - go here and we'll say on authenticated
383:58 - error and now of course we don't need to
384:00 - pass in that status code correct we just
384:03 - need to provide the message so let's
384:05 - remove it over here
384:06 - and then we want to do the same e in the
384:09 - catch correct so the functionality is
384:11 - going to be exactly the same and just so
384:14 - we can speed this up
384:15 - maybe let me grab the first part over
384:17 - here
384:18 - and copy and paste and then again we
384:21 - don't need the status code we just
384:23 - remove it and we'll be in good shape so
384:26 - that's the first file we want to fix
384:28 - then we want to go to the main.js e in
384:31 - the controller and pretty much it's the
384:33 - same thing
384:34 - where at the moment i have custom api
384:36 - error
384:38 - but effectively what error i want to
384:39 - throw here well i want to throw the
384:42 - battery quest one correct
384:44 - pretty much everything after that is
384:46 - just for successful responses
384:49 - and i think i'm going to remove the
384:50 - console log since we already covered
384:52 - that and then let's scroll up again we
384:54 - want to change what we're actually
384:57 - requesting so in this case i'm looking
384:59 - for this
385:00 - bad request error so let's go back to
385:02 - the main.js and we'll set it up as an
385:05 - object over here and then again we're
385:08 - not looking in the custom error we're
385:10 - looking in the errors and keep in mind
385:13 - that since we're exporting as object if
385:15 - you have multiple errors we simply want
385:18 - to add comma and then just get them so
385:21 - now we're looking for bad request error
385:23 - and instead of custom api error we'll
385:26 - exchange it for
385:27 - bad request error we already have the
385:29 - status code so we can remove that and
385:32 - then finally let's go to the error
385:34 - handler one and in here of course i'm
385:38 - still looking for the custom api error
385:40 - so as far as the instance this doesn't
385:42 - change because both of them the bad
385:44 - request
385:45 - as well as the unauthenticated
385:48 - extend from our custom api so this will
385:52 - be still true the difference of course
385:55 - is that we're looking for the object in
385:56 - this case and we're looking in the
385:59 - errors that's number one and the second
386:02 - thing we want to do is get those status
386:04 - codes and that is coming from the http
386:07 - package so let's say here http status
386:11 - codes and in the if block everything is
386:14 - going to stay exactly the same because
386:16 - of course we're getting the status code
386:19 - from the object correct and then as far
386:22 - as the message it's also there but when
386:24 - it comes to this 500 you can change this
386:27 - around and say that we'll be looking in
386:29 - the status codes and this is going to be
386:31 - equal to the internal server error and
386:35 - when it comes to message i guess it can
386:37 - stay the same and with all of this in
386:39 - place let's just navigate to the browser
386:42 - and then let's test it out let me
386:44 - refresh
386:45 - let me remove that token
386:47 - so we're not cheating here so let me
386:50 - remove it from the local storage and
386:52 - let's try it out and let me refresh one
386:54 - more time we have no token okay that's
386:56 - awesome i can see not authorized to
386:59 - access this route so i can clearly see
387:01 - that my functionality works at least for
387:03 - now and then of course if i wanna see
387:06 - something i'm gonna go with anna and
387:08 - then i say secret and then we submit and
387:11 - user is created token is present so now
387:13 - of course let's get data and of course
387:15 - the user is still the same and
387:17 - everything is correct and if you want to
387:20 - try out setting up the user
387:22 - without any kind of values let's try it
387:24 - out we have please provide email and
387:27 - password and if we inspect
387:30 - we should see in the console
387:33 - bunch of errors meaning we have one for
387:36 - 401 and then we have one for
387:38 - bad request and again not to be
387:41 - redundant but all of this code
387:43 - refactoring and then introducing new
387:47 - packages
387:48 - as well as setting up more error classes
387:51 - is going to make way more sense
387:53 - as we progress to more complex projects
387:57 - my idea is following where i want to
387:59 - show you the simple setup first
388:02 - and then show you these changes on a
388:04 - small project because that way i believe
388:07 - that it's going to be easier for you to
388:09 - follow along because now we have only
388:12 - what six seven files something like that
388:14 - correct but as our projects grow
388:17 - we'll still rely on these topics we'll
388:20 - still rely on multiple error classes
388:23 - we'll rely on status codes
388:25 - as well as setting up the middleware but
388:27 - of course then it's going to make way
388:30 - more sense because we'll have
388:32 - way more routes and way more
388:35 - functionality and with all of this in
388:37 - place we're done with the project
388:40 - hopefully everyone enjoyed it and i hope
388:42 - to see you next one all right and
388:44 - welcome to our next project the jobs api
388:47 - where we'll finally combine our auth
388:49 - knowledge with crud functionality and as
388:52 - a result we'll have an api where users
388:55 - can log in and manage their job search
388:58 - during the project we'll also learn how
389:00 - to deploy our app to heroku so host our
389:03 - apps on the cloud and set up nice
389:05 - documentation with swagger ui for this
389:09 - project i still managed to build a
389:11 - matching front-end app but moving
389:14 - forward so in our future apps i'll
389:16 - exclusively use documentation to
389:18 - showcase the end result since building a
389:21 - front-end project for every api is just
389:24 - too time-consuming
389:25 - and before we take a look at the
389:27 - features let me stress one more time
389:29 - our job will be setting up the api so
389:32 - the back end the front end is there just
389:34 - to give you a better overall perspective
389:37 - on how the api is going to be consumed
389:40 - in real life and basically the idea is
389:43 - filing where we have some kind of
389:44 - front-end application
389:46 - and we can log in or register so of
389:49 - course if i haven't created my account
389:52 - then first i would need to register so i
389:54 - go over here and then i'll type some
389:57 - kind of gibberish i'll say that i'm
389:58 - peter the email will be peter
390:02 - gmail.com and then we go with secret now
390:05 - regardless
390:07 - whether you're logging in or registering
390:10 - will be sending the token the json web
390:13 - token and then on the front end will
390:15 - right away be able to
390:17 - showcase the user account so if i go
390:20 - here and if i say that i want to
390:22 - register
390:23 - and if i submit if i provide the correct
390:26 - values now i can see my dashboard since
390:28 - i just created my account i have no jobs
390:30 - so of course in here i just need to
390:32 - provide the values i'm going to go with
390:33 - apple again and i'm going to be looking
390:35 - for
390:36 - front and position
390:38 - i submit now i have my job i can delete
390:41 - the job
390:42 - i can edit the job and i can also take a
390:45 - look at the single job
390:46 - so in this page
390:48 - i'm actually fetching data about that
390:51 - one single job and i have functionality
390:54 - to edit once i change some values
390:57 - now when i'm sending this http request
391:00 - this is going to be a patch request so
391:03 - here i edit and if i provided the
391:05 - correct values then i successfully
391:08 - modified the job
391:09 - so now i can go back to the dashboard
391:12 - and i see that i have my job but in this
391:15 - case instead of pending which is going
391:17 - to be the default case we have the
391:19 - interview and if i'm no longer
391:21 - interested or maybe they sent me a
391:24 - rejection i can also remove the job and
391:27 - once i do that i have no jobs to display
391:31 - and as a quick side note if you're just
391:33 - interested in the front-end project just
391:36 - navigate to johnsmilk.com
391:38 - and at this point it is still on home
391:41 - page but if you don't see it there it's
391:44 - always going to be available in the
391:46 - projects page and you can quickly find
391:48 - it if you look for youtube now youtube
391:51 - doesn't mean that the project is going
391:52 - to be on youtube
391:54 - i'm just grouping my projects that way
391:56 - and then in here you can take a look at
391:58 - the application if you click on this
392:01 - massive master button
392:03 - and if you want to take a look at the
392:04 - source code just look for star files or
392:07 - complete both of them
392:09 - actually go to the same repo
392:12 - and then in the source you'll be able to
392:14 - find everything and a few things to know
392:17 - about the project when it comes to the
392:19 - url of course i'm using my api so if you
392:23 - want to clone the project
392:25 - and test it out on your backend you just
392:28 - need to change the url and that is in
392:31 - the ax usgs so in the source i have
392:33 - axios.js
392:35 - and as you can see the url is pointing
392:37 - to
392:37 - my backend but if you want to test it
392:40 - out on yours you just need to change the
392:42 - url and lastly keep in mind that i
392:44 - recorded this in july of 2021 so
392:47 - eventually once the react 18 is stable
392:50 - i might refactor the code to take
392:52 - advantage of the new features all right
392:55 - and as always we'll start with the setup
392:58 - and essentially we're looking for the
392:59 - folder number six of the jobs api and
393:02 - then more specifically we have two more
393:04 - directories we have the final one as
393:06 - well as the third and of course we'll do
393:08 - all of our work in star
393:11 - and then final is for your reference so
393:14 - this is the complete project
393:16 - now at this point you should be able to
393:18 - already spin up the final project if you
393:21 - want to just look for readme and then
393:24 - here you'll find the info where we do
393:26 - need to create a dot env file in a root
393:29 - and then set up two variables the
393:32 - uri as well as jwt secret one and of
393:36 - course this is gonna be the connection
393:38 - string the uri which you're
393:39 - getting from mongodb you just need to
393:42 - set up the proper password as well as
393:45 - database you want to use and as far as
393:47 - the jwt secret one for time being you
393:49 - can set up some kind of silly value like
393:52 - we did in a previous project because in
393:54 - the jobs one i'll show you where to get
393:57 - a proper jwt secret value and after that
394:02 - just run npm install and npm start and
394:06 - the final project should be good to go
394:09 - now as far as the starter we'll just
394:11 - navigate here to the folder
394:13 - and first thing that i want to do is go
394:15 - with cd
394:16 - and then drag and drop the star and
394:19 - before we do anything let's just go with
394:20 - npm install and npm start so that should
394:25 - install the dependencies and spin up the
394:27 - dev server and as far as the setup in
394:30 - this case we're going to have two
394:31 - controllers one for authentication and
394:35 - the second one for the jobs again we
394:37 - have db1 where we're connecting to the
394:39 - database that should be already familiar
394:42 - then we have errors folder with all our
394:44 - classes so we start with our custom api
394:48 - one and then we have one for bad request
394:50 - we have one for not found on
394:52 - authenticated as well as index.js where
394:56 - we essentially pull in all the classes
394:59 - and then we can start using them around
395:02 - the project since we have index.js
395:04 - we simply need to reference the errors
395:06 - folder and that will be the default
395:09 - export and then we have middleware one
395:12 - where we've got a authentication one so
395:14 - essentially this is going to be exactly
395:17 - the same like we did in the previous
395:18 - project however this one i want to
395:20 - retype from the scratch because we only
395:22 - did it once and then probably in the
395:25 - upcoming project we will reuse this one
395:27 - as well and then of course we have error
395:30 - handler one
395:31 - so this is where i got the custom api
395:33 - one and then i'm just checking if that
395:35 - is the case if that's our custom api we
395:39 - send the response with the status code
395:41 - as well as the error message and i'm
395:43 - using the status codes library and i
395:46 - prefer using this package because in my
395:48 - opinion it adds a bit more consistency
395:51 - to our application
395:53 - as well as it's easier to understand
395:56 - what's happening with a status code in
395:58 - this case we have internal server error
396:02 - and also during this project we'll do
396:04 - more work here in the error handler one
396:06 - because i want to show you how we can
396:08 - check for
396:09 - multiple mongoose errors instead of
396:12 - sending back always this 500 one with
396:15 - the long error message then we have not
396:18 - found so if the user is looking for the
396:20 - route that doesn't exist we send back
396:22 - 404 and then route does not exist after
396:25 - that we have two models so we'll have
396:27 - job and user and also the same goes for
396:30 - routes we'll have the auth as well as
396:33 - the jobs and then eventually we come to
396:36 - app.js where again we have two packages
396:38 - that we have used quite extensively dot
396:40 - env as well as the express async errors
396:43 - i don't think i need to repeat what
396:45 - they're doing then we're looking for
396:47 - express we invoke it and we set it equal
396:50 - to the app we have two middlewares we
396:52 - have not found one as well as the error
396:55 - handler one that we invoke dot json
396:58 - because there's going to be some post
397:00 - routes and we want to access data in
397:04 - reg.body there's a simple route app.get
397:08 - just a forward slash so this of course
397:10 - is going to be to our homepage just so
397:12 - we can test it out whether that's the
397:14 - postman or the browser and i pass in the
397:17 - not found one as well as the error
397:19 - handler one in app.use and i set up the
397:22 - port in this case i'm going to go with
397:24 - 3000 i believe the final one is 5000 and
397:28 - then we have a start function
397:31 - where we just invoke
397:33 - app.listen and eventually we'll add here
397:36 - more code if you can see clearly in
397:38 - console server is listening on port 3000
397:41 - and if you navigate to the browser and
397:45 - go for localhost 3000 you can see the
397:48 - jobs api we are in good shape and we can
397:51 - start setting up our application
397:53 - all right and once our basic app is up
397:56 - and running let's start setting up the
397:57 - structure
397:58 - and we'll start with our controllers so
398:01 - essentially in here we want to set up
398:03 - the functions that eventually will be
398:06 - controllers for our routes
398:08 - and i want to start with auth and again
398:10 - this is just going to be a structure so
398:13 - we'll just add some dummy code like
398:15 - registered user or login user and that
398:18 - sort of stuff so let's go here with
398:20 - const register so this is going to be
398:23 - our first function and again it's going
398:25 - to be async rec and res and in the body
398:28 - like i said i'm just going to go to
398:29 - rest.send and we'll go the register user
398:33 - register user and then as far as the
398:35 - author out the second one will be a
398:37 - login one so let's just copy and paste
398:40 - and i simply want to change here the
398:42 - name for the function
398:43 - as well as the string so let's go with
398:46 - register login or i'm sorry
398:49 - we're going to go with
398:50 - login user my bad so login
398:54 - and let's go with user since i have the
398:57 - controller i also want to export it so
399:00 - we're going to go with module
399:02 - then export
399:04 - and i'll set it up as an object and
399:06 - we'll go to register
399:08 - and log in and essentially in order to
399:10 - speed it up i just want to take this
399:12 - whole thing
399:13 - copy and then back in the jobs we're
399:17 - gonna go with get all jobs
399:20 - get job create job
399:22 - update job and delete job essentially we
399:24 - have a crud functionality so i can just
399:27 - remove the second function as well as
399:29 - the login one we will rename them and
399:31 - let's just start with get
399:33 - all jobs so this is going to be a get
399:35 - route that gets me on the jobs
399:38 - so i'll say the same thing in string so
399:40 - get all jobs let's just change what
399:43 - function we're exporting and now we want
399:45 - to copy and paste this four times i
399:47 - believe one two three
399:49 - and four so we'll go here with
399:52 - get job this is going to be a route to
399:54 - get a single job
399:56 - then we have one for creating a job so
399:59 - create and job as far as the string
400:02 - we'll go with create job
400:04 - then we have one for updating the job
400:08 - update job
400:10 - and let's do it over here as well
400:13 - update job and lastly we have one for
400:16 - deleting job so let's say delete and job
400:20 - the same goes for the string so delete
400:23 - job and now i just want to add the rest
400:25 - of the functions
400:26 - in my
400:28 - object the one that i'm exporting so go
400:30 - with get job then we're looking for
400:33 - create job
400:35 - the update job so comma update job and
400:38 - delete job and once we have the basic
400:40 - controller structure in place
400:42 - now of course we can do the same thing
400:45 - with our routes and as far as our routes
400:47 - let's start with auth js and of course
400:50 - we need to set up the router so let's go
400:52 - with const express easy equal to
400:55 - acquire
400:56 - acquire and of course i'm looking for
400:58 - express
401:00 - remember we need to go with some kind of
401:02 - variable and micros router and we'll set
401:04 - it equal to your express dot and router
401:07 - we invoke it and then we'll import both
401:10 - of the functions from auth controller
401:12 - and remember the names were register and
401:15 - login so let's go over here
401:17 - login
401:18 - and register and both of these things
401:20 - are coming from our controller the auth
401:22 - one so let's navigate over there we have
401:25 - controllers and of course the auth one
401:28 - and once i have my imports in place now
401:29 - of course we just need to set up the
401:31 - routes and if you remember we also had
401:34 - an option of router and then that and
401:37 - then whatever is the method and both of
401:40 - these are going to be the post routes so
401:42 - i'll simply go with router that post and
401:45 - then we go with forward slash register
401:49 - and then of course we'll pass in our
401:51 - controller after that we'll copy and
401:53 - paste again router.post in this case
401:56 - we're looking for the login one
401:58 - and of course the controller will invoke
402:01 - he is also going to be a login one and
402:03 - then at the very very end we'll just go
402:05 - with module
402:06 - exports and that is equal to the router
402:10 - so that should do it for
402:12 - auth.js and before we navigate to app.js
402:15 - and import it and set it up let's also
402:17 - do the same thing with the jobs router
402:21 - because essentially the idea is exactly
402:22 - the same where i want to go to jobs and
402:25 - again in order to speed it up
402:27 - let's just take
402:28 - these two lines of code
402:30 - and i'm sorry i navigated to the wrong
402:33 - file so here in the jobs i set up the
402:36 - router yep that stays the same and now
402:39 - we just want to go
402:40 - with const and we want import we want to
402:43 - import get all jobs get job
402:48 - also i'm going to be looking for create
402:49 - job
402:51 - create job then we want to update the
402:53 - job
402:54 - and lastly we want to get a job or i'm
402:56 - sorry not get job delete job
402:59 - delete
403:00 - and job and all of that is coming again
403:03 - from the controllers correct so go with
403:06 - require and we'll set it equal to the
403:09 - controllers folder and of course we're
403:11 - looking for the jobs and once we have
403:13 - these imports in place now of course
403:15 - we'll do the other way where we go with
403:17 - router dot route and then we'll have
403:20 - post and get on a forward slash and then
403:23 - we'll have the get delete and patch on
403:26 - forward slash and then the route param
403:28 - so let's go with router
403:31 - dot route and this is going to be the
403:33 - forward slash of course and therefore
403:35 - we'll go with post so this is going to
403:38 - be to add the job and get all the jobs
403:41 - remember that was the structure for rest
403:43 - api and we're looking for the controller
403:46 - of create job of course let's go with
403:48 - dot and then get and this is going to
403:51 - get me all the jobs then we'll copy and
403:54 - paste
403:55 - and i'll add here the id remember the
403:57 - route params
403:58 - and in this case we're not going to have
404:00 - post
404:01 - so i can remove this one and we'll start
404:04 - with get now this is going to get me the
404:06 - single job here
404:08 - then we're gonna have one for delete of
404:11 - course the controller is delete job and
404:14 - then lastly we have one for patch and
404:17 - here we'll pass in update job and then
404:19 - at the very very end of course i want to
404:21 - go with module
404:23 - dot exports
404:25 - and the router now of course if you
404:27 - prefer this index you can also use it
404:30 - here in auth js i just thought that this
404:32 - is a nice refresher where of course we
404:35 - can set up our routes
404:37 - this way as well
404:39 - and once we have both of the route files
404:41 - in place now of course we just need to
404:43 - go to app.js we need to import both of
404:47 - them
404:47 - and again as always this is really up to
404:49 - you
404:50 - but i'm gonna do that above the error
404:53 - handlers because there's also going to
404:55 - be a connectdb here so connect db is
404:58 - still coming up let's just go with
405:00 - routers
405:02 - and here let's say const auth router and
405:05 - that of course is equal to require
405:08 - and we're looking in the routes
405:11 - and then more specifically of course i
405:13 - want to access the auth one copy and
405:16 - paste and this is going to be a jobs
405:18 - router of course this is coming from
405:21 - routes and forward slash and jobs
405:24 - and then i don't think we need a dummy
405:26 - one anymore i think we are pretty clear
405:29 - on what's happening so now of course
405:30 - let's remove it let's say app.use and as
405:34 - far as the path i'm going to go with api
405:37 - version 1 again that's my setup in
405:39 - postmatch so we might as well continue
405:41 - using that one and as far as the auth
405:44 - i'm going to go with
405:46 - forward slash auth and of course what
405:48 - that means in here we have the full path
405:50 - of api version one auth and then
405:54 - register
405:55 - and the same goes for the login and as
405:58 - far as the jobs will do exactly the same
405:59 - we'll go with api version
406:02 - jobs and then the forward slash is just
406:05 - going to have the create one and get all
406:07 - of them and then the route params will
406:10 - have the rest of the three hopefully
406:12 - that is clear because again we pretty
406:14 - much keep repeating the same thing so
406:16 - let's go with api version one and then
406:18 - auth and then let's just pass in the
406:21 - auth router so now of course we just
406:23 - need to copy and paste and let's go with
406:25 - jobs1
406:26 - and of course now we want to implement
406:29 - the jobs router so i'll say over here
406:32 - and i don't think i'm going to do any
406:34 - kind of testing since it doesn't make
406:37 - sense at the moment i'm just going to
406:39 - check my error so it says over here
406:41 - router.post requires a callback function
406:45 - but it's not given so let's see let's
406:47 - see let's see
406:48 - maybe i didn't export something
406:50 - so let's go to jobs
406:52 - that's the router
406:54 - and of course i'm looking here for the
406:57 - auth one for some reason
406:58 - so let's remove this one
407:01 - and then as far as create job
407:03 - looks like i didn't export it or
407:05 - something along those lines so let me
407:07 - take a look at the jobs
407:09 - of course
407:10 - there's a naming issue it's a create job
407:14 - so create job and of course i need to do
407:17 - it over here as well so once i fix this
407:20 - tiny bug
407:21 - now we should be heading in the right
407:22 - direction where we have the routes we
407:25 - have the controllers so now of course we
407:27 - just need to start adding the logic
407:29 - and the reason why i'm not testing
407:31 - anything right now because of course
407:33 - we'll work in each of the controllers
407:36 - quite extensively and before we do
407:38 - anything of course we'll just check
407:40 - whether we're getting this silly string
407:43 - response and if we do then of course
407:45 - we'll work on our logic
407:48 - all right and before we can start
407:49 - registering our users
407:51 - the last thing that we need to do as far
407:54 - as the general setup is to set up
407:56 - connection to the database and of course
407:59 - we have the function we already have
408:01 - connect js we have the functionality
408:03 - where of course we use the mongoose we
408:05 - set up to connect we pass e in the url
408:08 - and of course these are going to be our
408:10 - options to remove those depreciation
408:13 - warnings and the only thing we need to
408:15 - do is set up in a star
408:18 - dot env
408:19 - and here let's go with underscore
408:22 - uri
408:23 - and of course you want to pass in your
408:25 - connection string so let's go to connect
408:28 - we're looking for connect your
408:30 - application
408:31 - i'll take this one over here
408:34 - and copy and paste and as far as
408:37 - database i mean it's not going to be a
408:38 - surprise if i go over here with
408:41 - 0 6
408:42 - and i'll call this
408:44 - jobs
408:46 - api
408:47 - and then of course i just need to
408:48 - provide my password and once you do that
408:52 - just navigate to app.js
408:54 - so let me close everything just so it's
408:56 - not so busy
408:58 - and i guess in the app js i'm going to
409:00 - go above the routers i'll say const
409:03 - connect
409:05 - and then db
409:06 - and that will be equal to require of
409:08 - course
409:10 - and we're looking for our function
409:12 - and that is located in the db folder
409:16 - not the error sorry the db one and now
409:19 - we're looking for connect and then we'll
409:21 - just scroll down where we have the start
409:24 - and we'll go with await
409:26 - and we'll invoke the connectdb and now
409:29 - of course we want to go process dot env
409:32 - and then the
409:34 -  underscore
409:36 - and uri so underscore and uri and once i
409:41 - save and if i can still see servers
409:44 - listening on port 3000 that means that
409:47 - our connection is ready to go and now
409:50 - can finally start setting up our
409:53 - authentication all right and once the
409:55 - database connection is in place the
409:57 - first thing we want to do is to create a
409:59 - user model
410:01 - and in a process we'll learn a few more
410:03 - built in mongoose validators
410:06 - and as xenon if you need to reference
410:09 - the steps we're about to take
410:11 - just navigate to the readme in the root
410:15 - so in the star route look for readme and
410:18 - here you'll find all the steps and since
410:21 - i want to show you more validators let
410:23 - me open up the mongoose docs so in here
410:26 - we're looking for a validation
410:28 - and then more specifically just look for
410:31 - the string one because in the user
410:33 - pretty much all of them are going to be
410:35 - strings so
410:36 - just click on any of these ones
410:38 - and here and there i'll just use this as
410:41 - a reference just to showcase what's
410:43 - happening and essentially we want to
410:45 - navigate of course to the user model so
410:48 - the file is over here and remember we're
410:51 - looking for the is of course so
410:52 - const
410:53 - mongos is equal to require and of course
410:56 - i'm looking for the mongoose and after
410:58 - that we will add two more packages the
411:01 - jwt one the json web token one as well
411:04 - as bcrib js but of course that is still
411:07 - coming up and i want to start by
411:09 - creating a schema so let's go here let's
411:12 - call this
411:13 - user
411:14 - schema not as equal to new mongoose
411:18 - and of course we're looking for the
411:20 - schema here in this case
411:22 - and i want to go with parentheses
411:24 - pass in the object and as far as the
411:26 - properties will have three we'll have
411:29 - name
411:30 - email as well as the password so let's
411:32 - go over here with the name that's going
411:34 - to be the first one i think i can close
411:36 - the sidebar just so i have a little bit
411:37 - more real estate and we'll start with
411:39 - type type will be equal to string then
411:42 - we'll right away set it equal to
411:44 - required
411:45 - and then we'll set it equal to array
411:47 - remember the first value is whether it
411:50 - is true or false of course in my case
411:52 - i'm going with true and then we'll say
411:54 - please
411:56 - provide a name so of course that is our
411:59 - required validator and after that i just
412:01 - want to showcase that in the mongoose
412:03 - docs we can see that we have min length
412:05 - and max length
412:07 - now of course as far as the values
412:09 - that's really up to you
412:10 - my case i'm going to go with min length
412:12 - and i'll set it equal to 3
412:16 - and of course i'm going to also set up a
412:18 - max length and i'm just going to say 50.
412:22 - then i want to go with email
412:24 - and in order to speed this up we will
412:26 - copy and paste and of course i'll change
412:29 - the name here this is going to be an
412:31 - email
412:32 - then i'll still set it as required so
412:35 - that's going to stay the same let's set
412:37 - it over here and then we also have a
412:40 - match one which pretty much creates a
412:43 - validator that checks if the value
412:46 - matches the given regular expression now
412:49 - why we want to use that because i want
412:51 - to use the regular expression to check
412:53 - for the valid email there's plenty of
412:56 - suggestions out there most likely the
412:58 - first answers that are going to pop up
413:01 - are going to be from stack overflow just
413:03 - pick the one that makes the most sense
413:05 - to you and you'll be good to go now as
413:07 - far as this project you have two options
413:10 - you can either get the code in the
413:12 - readme or just look in the final one so
413:15 - in the final of course i have the models
413:17 - and all that and then just look for the
413:19 - user one and you can take the entire
413:22 - property that's really up to you so in
413:25 - my case i'm just gonna navigate to the
413:27 - readme i'll take here this code and then
413:30 - i want to go back to the user
413:32 - and more specifically the email i want
413:35 - to remove both of these the min length
413:37 - and max length and then we want to go
413:39 - with match
413:40 - and we pass in the array so essentially
413:43 - that's the syntax and then we want to
413:46 - pass in the regular expression then
413:49 - comma and then whatever error message we
413:52 - want to provide and in this case it's
413:53 - pretty much going to be the same
413:55 - i'm just going to say please provide
413:57 - valid email
413:59 - and once i have the match in place the
414:01 - last thing i want to set up for the
414:02 - email
414:03 - is unique
414:05 - and true
414:07 - and essentially what unique does it
414:10 - creates a
414:11 - unique index and this is something you
414:13 - need to be aware of where technically
414:16 - it's not a validator and that becomes
414:18 - important when we run validate method
414:21 - manually which we haven't done so don't
414:23 - lose your sleep over that and when
414:26 - you're writing automated tests and of
414:28 - course you can read more about it in the
414:30 - docs but the way it works it just
414:32 - creates that unique index so if i'm
414:34 - trying to save a user
414:36 - but there is already a email news
414:40 - then i'll get the duplicate error
414:42 - message and lastly i want to go with
414:44 - password and here
414:46 - i think i'm going to take the name
414:49 - because pretty much is going to be
414:50 - exactly the same where i'm going to go
414:53 - with password
414:54 - password and then required will be true
414:57 - now of course the error message is going
414:59 - to be a little bit different
415:00 - say here password and then as far as the
415:03 - middle length and max length i think i'm
415:05 - going to go with 6
415:07 - and no longer than 12.
415:09 - so let's set it up this way we have the
415:12 - user in place
415:13 - the only thing left to do is of course
415:16 - export it so let's go with module
415:19 - and export
415:21 - and i'll set it equal to our mongoose
415:24 - model
415:25 - and of course we want to pass in
415:28 - our name and my case i'm going to go
415:30 - with user as well as the user schema so
415:34 - user and schema and once we save now of
415:37 - course we can start setting up our
415:40 - register controller
415:42 - beautiful our user model is in place so
415:44 - now of course let's set up the first
415:47 - route and steps are going to be
415:48 - following where first we want to
415:50 - validate a name email and password
415:52 - whether of course the user has provided
415:55 - the correct values and in this case i'll
415:58 - purposely go with mongo's option just
416:00 - because i want to show you how we can
416:03 - send back nice error responses instead
416:06 - of those big objects then we want to
416:08 - hash the password and don't worry if
416:11 - this looks like gibberish to you right
416:12 - now of course i'll cover it extensively
416:15 - a little bit later
416:17 - after that if we're successful
416:19 - if we can hash the password if the
416:22 - values have been provided then of course
416:24 - we create the user and once we have the
416:26 - user we want to create that token that's
416:29 - going to be associated with that user
416:31 - and with that token the user can start
416:34 - creating resources which of course in
416:36 - our case is going to be jobs and in
416:39 - order to get that token to the user of
416:40 - course we will include it in our
416:43 - response
416:45 - so let's get cracking
416:47 - and of course we're looking for the
416:48 - controllers in this case and of course i
416:51 - have the final open so i'm actually in a
416:53 - wrong folder so let me look for
416:55 - controllers we're looking for the auth
416:58 - and of course more specifically the
417:00 - register one we can start by importing
417:03 - the model
417:04 - so in here i'm going to set up a user
417:07 - and that is going to be equal to require
417:10 - then we're looking two levels up
417:12 - and of course i'm looking for the models
417:14 - and then more specifically a user model
417:17 - and once i have the model before we do
417:19 - anything here let's just check in the
417:22 - postman
417:23 - whether we're getting this silly string
417:25 - because if we don't then of course we do
417:27 - need to troubleshoot so let me navigate
417:29 - back of course here i have all my
417:31 - workspaces and i'll create a new one
417:33 - that's not a surprise
417:35 - i will rename it and i'll say
417:38 - 0 6
417:39 - and let's call this jobs api
417:43 - now the url of course is going to stay
417:45 - the same remember that global variable
417:47 - so
417:48 - that saves us a little bit of time and i
417:50 - want to go with new request this is
417:53 - going to be a post request
417:55 - and here i'm going to be looking for my
417:58 - url of course so url and then remember
418:01 - we're looking for auth
418:03 - and register hopefully that is correct
418:06 - let me just double check
418:08 - so in the
418:09 - here i have api version one so that
418:12 - should be still in my global variable in
418:15 - the postman and then more specifically
418:17 - auth
418:18 - and then if we take a look at the routes
418:21 - in here in the auth of course i have the
418:24 - register and like i said both of them
418:26 - are going to be post routes so why don't
418:29 - we start by selecting a body then we're
418:32 - going for raw we want to go with json
418:35 - and then let's just set up the name
418:38 - and it's not going to be surprised if
418:40 - i'm going to go with john
418:41 - then as far as the email let's just go
418:43 - with the dummy one so i'm going to say
418:45 - john
418:47 - gmail.com
418:49 - and then lastly we want to go with
418:50 - password and i'm just going to stick
418:52 - with secret because that's the most
418:55 - simplest one in my opinion so i have
418:57 - name
418:58 - email
418:59 - as well as the password
419:01 - and of course once i send i should get
419:04 - register user if you don't then again
419:07 - please troubleshoot because otherwise
419:09 - anything we're about to do it's not
419:11 - going to make sense and before we move
419:14 - along let me just save this one
419:16 - and i'm going to look for my jobs and
419:18 - let's just call this register
419:21 - and user so let's save it over here and
419:24 - let's right away test whether we're
419:26 - getting back the correct values meaning
419:28 - whether i can access them in a reg dot
419:31 - body so change this one around where
419:33 - we'll say res.json and i'm just going to
419:36 - pass in reg.body again in this case i'm
419:39 - just checking
419:40 - whether my middleware is correct and if
419:43 - i can see all the three values that i'm
419:45 - sending from my postman then of course
419:47 - we are in good shape
419:49 - now i also want to get these status
419:51 - codes remember that was the library that
419:53 - we used before so let's go over here
419:55 - let's say const and we're looking for
419:57 - status codes
419:59 - and that is coming from our library the
420:02 - http status code so require
420:06 - require
420:07 - and we're looking for the http status
420:09 - codes and then in here i want to set up
420:11 - the status
420:13 - status
420:14 - and of course dot json after that and
420:17 - let's just go with status codes
420:20 - and then we'll set it up as created
420:22 - because remember we are creating a
420:25 - resource so this will send back the 201
420:29 - and once we have all of this in place
420:32 - now of course we can create that new
420:35 - user correct so let's go here let's say
420:38 - const user and we'll go with a weight
420:42 - because of course this is asynchronous
420:44 - then the model name user and we'll go
420:48 - with create method and in the create
420:50 - method since i want mangoes to do all
420:53 - the validation i'll simply pass in
420:56 - rec.body just like we're doing over here
420:59 - so now of course i can remove it from my
421:01 - json and for them being i'll just send
421:04 - back the user our current code actually
421:07 - is a big big mesh because we're saving
421:10 - the passwords as they come in as strings
421:13 - and that's a very very bad practice and
421:16 - don't worry we will fix that a little
421:17 - bit later for now i just want to see
421:20 - whether everything works and once we hop
421:22 - back to the postman
421:24 - we should be able to send a request and
421:27 - in my response i can see that i created
421:29 - a new resource
421:31 - in a database since i have that
421:34 - underscore id and then the rest of the
421:36 - properties that i provided in my request
421:40 - and with this in place now of course we
421:41 - can move on to our next step
421:44 - beautiful we can save our user
421:47 - and before we cover why it's such a bad
421:50 - practice to save our password as a
421:53 - string
421:54 - now let me remind you about the error
421:56 - checking
421:57 - and more specifically let me just jog
421:59 - your memory on the fact that we can
422:02 - check for the empty values right in the
422:05 - controller because keep in mind that at
422:07 - the moment we are doing that using the
422:10 - mongoose so first let me show you how we
422:13 - can do that in the controller and then
422:15 - i'll talk about it while we're checking
422:17 - in the mongoose essentially what i'm
422:19 - trying to accomplish
422:21 - and if you remember we simply check it
422:23 - in the following way where we go with
422:25 - name email and password now all of that
422:29 - is coming from rec that body of course
422:32 - and then we want to go with if and if
422:34 - one of the values is missing then we'll
422:37 - throw our own custom error more
422:39 - specifically the bad request one so
422:42 - let's say over here email
422:44 - and then we'll do the same thing for the
422:46 - password so if one of them is missing
422:49 - then of course we'll throw the error and
422:51 - of course we need to import that so say
422:53 - here const and we're looking for bad
422:56 - request
422:58 - quest
422:59 - and error so that's the one we're
423:01 - looking for now if you don't want to
423:02 - make the typo then of course just
423:04 - navigate to the errors folder more
423:06 - specifically index.js and then just grab
423:09 - this value
423:10 - so that way you'll avoid some
423:12 - unnecessary typos so let me just make
423:15 - sure that the name is correct looks
423:17 - about right and then we want to go with
423:19 - require of course we're going two levels
423:21 - up and we're looking for the errors and
423:23 - since we have index js over there of
423:25 - course we don't need to be more specific
423:28 - by default we'll get back the index.js
423:31 - and once i have the import in place now
423:33 - of course we just want to throw the
423:35 - error in the if block where it'll say
423:37 - throw new
423:39 - and of course i'm looking for bad
423:41 - request one
423:42 - and then we just need to pass in the
423:44 - message because remember the status quo
423:47 - is already there and let's just say
423:49 - please
423:50 - please provide
423:52 - name
423:53 - email
423:54 - and password
423:56 - and password and once i save and once we
424:00 - navigate back to the postman if i'll
424:03 - remove the password completely
424:06 - and if i'll just send notice now of
424:08 - course i will get the message now our
424:11 - functionality will still work because of
424:14 - course we're using the mangos validators
424:17 - even if i remove this code so if i
424:20 - comment this one out and if we go back
424:23 - and if we send without a password or
424:26 - without any of these two values as well
424:28 - of course we'll get back there now the
424:31 - reason why i'm using the mongoose
424:33 - validator because during this project i
424:36 - also want to show you
424:37 - how we can send back more meaningful
424:40 - response because at the moment of course
424:42 - i'm sending 500 which technically isn't
424:45 - the case because of course now we have a
424:47 - bad request instead of internal server
424:50 - error and also notice these massive
424:52 - objects probably would be better
424:55 - if we would send just please provide the
424:57 - password or the email or the name and
425:00 - therefore in this project we will use
425:02 - mongoose validators quite a bit
425:06 - just because of course i want to show
425:08 - you how we can send back more meaningful
425:10 - messages but that doesn't mean that
425:13 - we're not going to check in the
425:14 - controller so of course this one is
425:17 - optional
425:18 - but there's going to be some cases where
425:20 - yes we will have to set up that check
425:23 - directly in the controller so this one
425:26 - i'll remove because this pretty much is
425:29 - a repetition here but when it comes to
425:31 - different routes yes there might be some
425:33 - cases where we check directly in the
425:36 - controller hopefully that is clear so
425:39 - now we can start tackling the password
425:42 - issue
425:42 - not bad not bad if we take a look at our
425:45 - database we should see user's collection
425:48 - and overall life is great
425:50 - if only not for one big doozy
425:53 - notice how we store password as string
425:57 - so now if someone breaks into my
425:58 - database he or she can easily ruin the
426:01 - life for all my users
426:03 - since in most cases people use the same
426:06 - password for everything
426:08 - so if there's one thing i want you to
426:10 - take away from this course please
426:13 - never ever store user passwords as
426:16 - strings trust me they will thank you for
426:19 - that later
426:20 - okay well what's the solution
426:22 - well we want to hash them instead which
426:25 - in simple terms means generating random
426:28 - bytes
426:29 - and combining it with the password
426:32 - before we pipe it through the hash
426:34 - function a mathematical algorithm that
426:37 - maps data of any size to a bit string of
426:41 - fixed size
426:42 - something to remember hashing is a
426:44 - one-way street meaning it cannot be
426:47 - reversed
426:48 - also if the input changes even tiny bit
426:52 - the resulting hash will be completely
426:54 - different which is really really good
426:56 - for storing passwords since we can
426:58 - accomplish two things at once store
427:01 - passwords in a form that protects them
427:04 - even if the password itself is
427:07 - compromised and at the same time being
427:10 - able to verify the correct user password
427:14 - both of which will cover extensively in
427:17 - the upcoming lessons when it comes to
427:19 - password hashing
427:21 - for this and following projects we'll
427:23 - use a library by the name of bcrypt.js
427:26 - again the library is called bcrypt.js
427:30 - and if you're using a star i already
427:32 - installed it for you so we can start
427:34 - using it right away
427:36 - and as far as the syntax for hashing the
427:39 - password it goes something like this
427:41 - where first we want to import the
427:43 - library of course and we're looking for
427:45 - the bcrib js again please keep in mind
427:49 - that the library name is bcrypt.js
427:52 - don't install the beaker one and then
427:55 - wonder why you have bugs so again the
427:57 - name of the library is be crypt.js and
428:00 - the only reason why i'm telling you that
428:02 - because i fully understand that it's
428:03 - very easy to mix them up
428:06 - and once we have access to the library
428:09 - instead of dumping the entire body with
428:11 - our name email and password we want to
428:14 - create a new temporary user object and
428:18 - in here i'll just pull out the values
428:20 - from direct that body so my apologies we
428:22 - already had this code but i removed it
428:25 - with a bad request
428:27 - so now i'll have to retype it one more
428:28 - time so we'll look for name email and
428:31 - password and all of that is coming from
428:35 - rec.body and then i want to set up the
428:38 - temp user object and of course keep in
428:41 - mind that in the temp user
428:43 - all three properties need to be there
428:46 - otherwise we'll get back the error so of
428:48 - course in here i'm passing reg.body now
428:51 - i want to set up a new object and you'll
428:54 - see
428:54 - why i'm telling you that in a second and
428:57 - effectively i first want to set up the
428:59 - hashed password and then i'll go over
429:02 - line by line and explain what's
429:04 - happening so let's start over here with
429:06 - const temp user
429:08 - and we'll use the es6 thing
429:11 - where i'll go with name is equal to name
429:13 - and emails equal to email and what i
429:15 - want to do here is set up also a
429:18 - password but password will be equal to a
429:21 - hash password which of course at the
429:23 - moment we don't have
429:24 - and in order to set up the hashed
429:26 - password we need to run two methods we
429:29 - need to run gensalt
429:31 - and then the actual hash method and
429:35 - first i want to create a variable and
429:37 - i'll say salt and we have an option of
429:39 - running them asynchronously so just go
429:42 - with a weight then i'm looking for
429:44 - bcrypt and like i said the method name
429:47 - is
429:47 - jen salt and then we want to pass e in
429:50 - the number value
429:52 - again i'll explain all of this in great
429:55 - detail in a second and then once we have
429:57 - the salt then we want to create that
429:59 - hashed password so let's say over here
430:02 - hashed and password and we'll go with
430:06 - await then bcrypt again decrypt and the
430:10 - method name in this case is hash
430:13 - and we need to pass in two things we
430:15 - want to pass in the password we want to
430:17 - hash
430:18 - as well as the random bytes which
430:20 - essentially is that sold so let's start
430:23 - over here with password then comma then
430:26 - we pass in the salt and now where we
430:29 - have the password in the temp user
430:31 - instead of directly using the password
430:33 - we'll go with hash password and now of
430:36 - course instead of dumping the entire
430:39 - body we'll go with dot dot again we want
430:41 - to spread them out and then we'll go
430:43 - with temp user and once we save all of
430:47 - this now let's hop over to the postman
430:50 - and let's try to send the request
430:53 - so in here we need to keep in mind two
430:55 - things first
430:57 - the fact that we have set up four unique
430:59 - emails so if we'll try to send
431:03 - the same email we'll get the a response
431:06 - that's number one number two remember
431:08 - when we're setting up the password the
431:10 - basic password we also add the max
431:13 - length since i wanted to showcase that
431:15 - we have that valve there now in this
431:17 - case of course we will get an error
431:19 - because the hashed value is going to be
431:22 - way longer than 12. so let's try it out
431:25 - let's send
431:26 - and like i said we will get an error
431:29 - where the max length is 12 and of course
431:32 - this is the hashed password value and in
431:36 - order to fix that of course we just need
431:38 - to go to our user model and then remove
431:41 - the max length like i said
431:43 - i added this just so you can see that we
431:45 - have this option but of course in our
431:47 - case we are not going to use it and then
431:50 - once i fix that then the another bug is
431:53 - going to be that we have a unique email
431:55 - so if i send with john gmail.com of
431:59 - course i'm going to get an error which
432:01 - pretty much tells me that i have
432:04 - error
432:05 - and more specifically there's an issue
432:08 - with an email and this is the case where
432:10 - again we'll work on these custom error
432:13 - messages in a second now we simply want
432:16 - to change the john to john 1 at
432:20 - gmail.com and once i send check it out
432:24 - now of course i'm getting back the user
432:26 - now it's still not a good idea to send
432:29 - back the password so that's also
432:30 - something that i will work on a little
432:32 - bit later now the good news is that if
432:35 - we navigate right now to our mongodb
432:38 - and if we take a look we'll see our
432:41 - second user
432:42 - with a email of john 1 and of course now
432:46 - the password is hashed
432:48 - and what that means is that even if
432:50 - someone breaks into our database and
432:52 - steals all the data instead of actual
432:55 - password values they'll get the hashed
432:58 - ones which prevents them from easily
433:00 - reusing them later
433:02 - now that doesn't mean that you shouldn't
433:04 - protect your database of course not
433:05 - that's not what i'm saying just make
433:07 - sure that you always always hash your
433:10 - passwords and never ever ever
433:13 - store them as strings and as far as the
433:16 - code if we take a look at auth.js
433:19 - in line 9 we generate salt
433:22 - which essentially just means random
433:25 - bytes and we do that by running the
433:27 - method
433:28 - gen salt and in there we provide a
433:31 - number of rounds so how many
433:34 - random bytes we'll get and of course the
433:36 - bigger the number the more random bytes
433:39 - we'll get and of course that also means
433:41 - that the more secure our password is
433:44 - going to be but we also need to keep in
433:46 - mind the more rounds you have
433:49 - the more processing power is going to
433:51 - require and therefore i just went with
433:53 - 10 which i believe is a default one and
433:56 - trust me that is already a very very
434:00 - secure password and then of course we
434:02 - take that salt so there's random bytes
434:05 - and we pass in the hash method and hash
434:08 - method is simply looking for the
434:11 - password so the password we want to hash
434:13 - as well as the result and once we
434:15 - provide both those values as a result we
434:18 - get back that hashed password and of
434:20 - course that one we can safely store in
434:24 - our database so we just add it to our
434:26 - user and we're good to go beautiful we
434:29 - now know how to hash user passwords
434:32 - and if we take a look at our register
434:34 - user steps essentially we just need to
434:36 - generate a token which should sound
434:38 - already familiar since we spent the
434:41 - entire project on that
434:43 - and we'll be good to go right well yes
434:46 - and no
434:47 - that's true we don't have much left
434:50 - but if we take a look at our controller
434:53 - it's getting somewhat busy so if we'll
434:56 - keep on adding more functionality
434:58 - and just keep jamming the code in the
435:00 - controller eventually it's going to get
435:02 - bloated and way harder to manage
435:05 - now what's the solution you might ask
435:07 - well
435:08 - another set of middleware only in this
435:10 - case we're talking about the mongoose
435:12 - middleware but just keep one thing in
435:14 - mind the end result is going to be
435:17 - exactly the same
435:19 - will still hash users passwords
435:22 - it's just the logic will be stored
435:24 - nicely in a separate place
435:26 - and since i want to show you the entire
435:28 - documentation i'm going to navigate back
435:31 - we're looking for the middleware and of
435:33 - course you can read yada yada yada we
435:35 - have pre and post so before and after
435:38 - hooks and essentially we're looking for
435:41 - pre
435:42 - and more specifically pre save and the
435:45 - way we set it up
435:47 - we have the schema so in our case of
435:48 - course that is going to be our user
435:50 - schema then we go with pre so that's the
435:53 - syntax and we're looking for save
435:56 - so before we save the document and then
435:59 - in the callback function
436:01 - this is where we can access the
436:04 - properties in a document and do some
436:06 - exciting stuff and of course since this
436:09 - is a middleware then we just go with
436:12 - next and once we're done we pass it on
436:14 - to the next middleware now i'll also
436:17 - show you with async weight so this is
436:19 - coming up first let's just focus on this
436:22 - next one over here and essentially what
436:25 - we want to do
436:26 - is take the bcrypt we'll just save a
436:28 - little bit of time
436:30 - and we will go to our models we're
436:33 - looking for user one of course
436:35 - and then here let's copy and paste we
436:37 - have the bcrypt let's keep on scrolling
436:39 - okay that's our setup and here this is
436:42 - where we want to go with our schema so
436:44 - before we set up the model we'll go with
436:47 - user schema that's the name of course
436:50 - then we're looking for pre and then save
436:53 - so pre-save and since we'll use a weight
436:56 - we'll right away set it up as a sync
436:59 - and then let's go with function and i
437:02 - highly highly highly suggest using the
437:05 - good old function keyword value because
437:08 - that way this will be scoped to our
437:10 - document so if you'll go with arrow
437:13 - functions if you're familiar with them
437:14 - you know that
437:16 - as far as scoping this there's different
437:19 - set of rules in this case if we use the
437:21 - good old function that's why you'll see
437:23 - that in the docs as well
437:25 - this will always point to our document
437:28 - so in here let's go with our function
437:31 - and it is a sync nice then let's pass in
437:34 - the next of course
437:35 - and then remember the functionality what
437:37 - are we looking for over here well i want
437:40 - to generate the salt correct and of
437:43 - course i want to get the password and
437:47 - just so we get comfortable let's write
437:48 - it from the scratch so let's go to the
437:50 - user one
437:51 - and essentially i want to go with const
437:53 - salt so now we're generating those
437:55 - random bytes so let's just go over here
437:57 - with a weight and then be crypt and of
438:01 - course the function name was gen salt
438:04 - and i'm not going to go 20 rounds i'm
438:05 - going to go with 10 here
438:07 - and then as far as the password well
438:10 - this is where the callback function
438:12 - comes into play where in this function
438:15 - this will point to the document so when
438:18 - we type this over here basically what
438:20 - we're talking about is our document
438:22 - before i want to save the document what
438:24 - do we want to accomplish
438:26 - well we want to hash the password
438:27 - correct
438:28 - so what we can do we can go with this
438:30 - dot and we're looking for password so of
438:32 - course this is over here and we simply
438:36 - want to go with await and we want to
438:38 - hash it we want to go with await then
438:41 - bcrypt and then of course the method
438:43 - name is hash
438:46 - and then we're looking for this.password
438:49 - so our current password for saving
438:52 - and then we pass in salt and that's it
438:55 - that's all we have to do and once we're
438:57 - done with the functionality what's left
438:59 - well we want to pass it on to the next
439:01 - middleware so we just go with next and
439:04 - we invoke it and now check it out
439:07 - if we take a look at our controller
439:09 - since we're not sending the bad request
439:11 - here anyway i don't really need all
439:14 - these lines of code that's it i simply
439:17 - want to take my body just like we had
439:19 - before with dot dot erect.body and
439:22 - everything else is taken care of over
439:25 - here and you have to agree that this is
439:28 - much cleaner and nicer to work with so
439:31 - let's go back
439:33 - and then like i said i'm not interested
439:35 - in any of these things over here
439:38 - and we'll simply go with dot dot correct
439:41 - that body i'm still sending the user
439:43 - just because i want to showcase that
439:45 - will be hashing the password but don't
439:47 - worry that's also not a good practice to
439:49 - send back the password so we won't do
439:51 - that in a few seconds so let's go back
439:54 - to our postman
439:56 - we want to send it
439:58 - and check it out we have john with john
440:00 - blah blah blah and of course we have our
440:03 - hashed value so our functionality still
440:05 - works and the last thing that i want to
440:07 - cover in this video notice the docs in
440:10 - mongoose 5.0 blah blah blah next we can
440:13 - go with async await well that simply
440:15 - means that back in our user one
440:18 - can just remove it and
440:21 - what they're telling us in the docs that
440:22 - it's still going to work so let's test
440:24 - it out in this case i'm going to go with
440:26 - john 2 since remember we have those
440:29 - unique emails let's send it and we still
440:32 - get the response so we know that that
440:34 - works and if i go to my database now of
440:37 - course i should
440:39 - have quite a few users already there
440:41 - with hash passwords apart from the first
440:44 - one of course that is where the secret
440:46 - is and now i can remove it
440:49 - and we are good to go now we can hash
440:51 - the password but we're doing that using
440:54 - the mongoose middleware nice we're a
440:57 - little bit familiar with mongoose
440:59 - middleware so now let's continue with
441:01 - our steps we're saving the user so we're
441:04 - good on that and now of course we just
441:06 - want to generate the token and send back
441:09 - the response
441:11 - and we'll first set up functionality
441:13 - again in the controller so we're clear
441:15 - on what's happening and next video i'll
441:18 - show you another nifty setup that we can
441:20 - use with mongoose and like i already
441:23 - previously mentioned this should feel
441:25 - familiar because we spent the entire
441:28 - project on that the jwt basics so if we
441:32 - go back to the controllers in the fifth
441:34 - project meaning the folder name is five
441:37 - of course this is not the fifth project
441:39 - and if we take a look at the main
441:41 - check it out we go with jwt sign correct
441:45 - and of course that is coming from our
441:47 - library the json web token one then we
441:50 - pass in whatever we want to pass it on
441:53 - to the front end and of course later
441:56 - we'll use the id to access the resources
441:59 - that are associated with that user
442:02 - then we pass in the jw secret one and in
442:06 - this project i'll show you where we can
442:08 - get a proper value and eventually we
442:11 - pass in the options and we just say in
442:14 - how long it expires so let's try to
442:17 - recreate that back in the auth.js and
442:20 - what are we looking for here we're
442:22 - looking for the library of course now i
442:25 - can remove the bcrypt because everything
442:27 - is already set up in model so let's go
442:29 - over here with jwt
442:32 - we will set it equal to require of
442:34 - course
442:35 - and then we're looking for the package
442:38 - the json web token one and then once we
442:41 - create the user this is the case where
442:43 - we want to create that token correct so
442:45 - let's go over here with const and then
442:47 - we'll go with token and for time being
442:50 - i'll just pass in some random string and
442:53 - then we'll set up properly everything
442:55 - after that so let's go here with jwt
442:58 - then we go with sine of course
443:00 - and we want to pass in the data we want
443:03 - to send back
443:04 - and in my case again we'll go with id
443:07 - and name so let's start with user id
443:10 - that's just how i decided to call my
443:12 - property here so user id is equal to
443:15 - user so that's the user that i'm getting
443:18 - back over here and remember on that
443:20 - object we have id property correct and
443:23 - if you want to double check it's right
443:25 - over here this is what we're currently
443:27 - sending back
443:28 - and we go with underscore of course
443:30 - and then we'll go with id
443:32 - and again that's just my preference to
443:35 - kind of separate the two otherwise you
443:37 - have job id you have user id and many
443:40 - more ids and then if you just keep using
443:42 - this underscore in my opinion is just
443:45 - harder to manage everything so that's
443:47 - why i always go with user id job id or
443:50 - whatever so that's the first thing that
443:52 - i'm sending and next i want to send the
443:54 - name
443:55 - so i go with name and then again user
443:58 - that's my object and the name and like i
444:01 - said i'm just going to pass in some jwt
444:04 - secret right away so i'm just going to
444:06 - be cheating a little bit over here
444:08 - and then we'll add a comma and then
444:11 - let's go again with expression remember
444:14 - this one was expires in 30 days so use
444:18 - the same value and of course a little
444:20 - bit later i'll talk about other options
444:22 - as well so let's go here let's say
444:25 - expires and in
444:27 - and i'll set it equal to
444:29 - 30 days
444:31 - then we save and of course instead of
444:34 - sending back the user i want to send
444:37 - back the token
444:38 - and this is the case where as always
444:40 - there's multiple setups that you can
444:43 - have
444:44 - you can send back maybe only the token
444:46 - or you can be like hey
444:49 - maybe my front end needs the name
444:51 - directly now what am i talking about if
444:54 - i go back to the application
444:56 - that i built for this project
444:58 - if i go to login
445:00 - and of course more specifically i'm
445:02 - going to be looking for register and
445:03 - then i'll try to use
445:05 - some kind of values here
445:07 - that are not already a database so i'm
445:10 - going to go with anna
445:11 - and maybe let's add a tube because then
445:13 - for sure everything is going to work
445:15 - once i submit
445:16 - not only i'm going to get back token i'm
445:19 - going to say here never i'll also get
445:22 - back the name but again this really
445:24 - depends on the setup that you have on a
445:27 - front end you can send back only the
445:30 - token and actually there are setups
445:32 - where the front end
445:33 - decodes the token instead instead of me
445:37 - sending here a name and set it equal to
445:39 - username front end decodes the token now
445:43 - it's not going to be our case but just
445:44 - keep in mind that's why you don't ever
445:47 - want to store anything here as far as
445:50 - the secrets because as far as the coding
445:52 - you can actually do that now of course
445:54 - when it comes to verifying
445:56 - that's where you need that jwt secret
445:59 - but as far as decoding yes there are
446:02 - some setups where front-end just decodes
446:04 - and gets whatever property it needs so
446:07 - in my case the jobs app i'm also looking
446:10 - for the user and more specifically the
446:13 - name property but hopefully it is clear
446:15 - that in this case it's just my
446:17 - preference when i was building the
446:18 - front-end app
446:20 - when it comes to response what you
446:22 - definitely want to send back is the
446:24 - token because that of course will allow
446:26 - that user to access resources on the
446:30 - server later on so my guess i'm going to
446:32 - go with user so that's going to be
446:34 - another property i'm sending and in this
446:36 - case of course i'll access my user
446:38 - object and i'm just going to be looking
446:40 - for a name so i'll have another property
446:43 - there by the name of name and then i'll
446:46 - set it equal to user and then name and
446:50 - of course now i just need to add a comma
446:52 - and we're successfully sending the token
446:55 - and again let's test it out in a postman
446:57 - first
446:58 - so i'm gonna go here with john3
447:01 - at gmail.com we send it back now notice
447:04 - we're not sending back the password
447:05 - anymore and of course i'm getting the
447:08 - user as well as the token and just to
447:12 - reiterate on the front end of course i'm
447:15 - using the ana over here so in react i
447:17 - set the state and i set up the state
447:20 - value just to showcase that notice over
447:22 - here i have my reducer blah blah blah i
447:25 - have user and notice the name of course
447:28 - that is anna and i'm accessing that
447:30 - right from the response
447:32 - and then when it comes to the token
447:35 - you'll have multiple options and one of
447:37 - them is going to be storing it in a
447:40 - local storage so now of course in the
447:41 - local storage not only i have the name
447:44 - so that way when i refresh of course i
447:46 - can still showcase data but i also get
447:50 - the token so when i'll be making future
447:53 - requests on behalf of anna of course
447:56 - i'll have the token hopefully it is
447:58 - clear and now of course we can take a
448:00 - look at another solution that mongoose
448:03 - provides to make our code cleaner
448:06 - awesome and to complete our register
448:08 - functionality
448:09 - let's learn about schema instance
448:12 - methods
448:13 - in mongos so i'm going to navigate to
448:15 - the docs in this case we're looking for
448:18 - schemas
448:19 - and if we take a look at the list
448:22 - we see this instance method
448:24 - and essentially what happens
448:26 - every document we create we can have
448:30 - functions on them so these are going to
448:32 - be instances of course of our schema
448:35 - correct and the way we set up those
448:37 - functions we go with
448:38 - the schema name then methods and then
448:42 - whatever function you want so
448:44 - essentially once i create that user over
448:46 - here in the register
448:49 - that user will have a function and you
448:51 - can probably already guess that we'll
448:53 - create a function
448:54 - that just generates that token and of
448:57 - course in that function we'll pretty
448:59 - much have the same code and therefore we
449:02 - won't have to bother with that in the
449:05 - actual controller in the register
449:08 - controller and let's start somewhat
449:10 - silly where i want to go back to my
449:12 - model the user one and let's just go
449:14 - with user schema
449:16 - so of course that is the name that stays
449:18 - the same then we go with methods and
449:21 - then let's just say
449:23 - get name
449:24 - so let's imagine that we're just lazy
449:26 - getting the username and we have
449:28 - multiple options we can set it up as
449:31 - async
449:32 - or we can just set it up as a regular
449:34 - function so in this case we'll just go
449:36 - with a regular function so no async
449:38 - keyword but again we do want to use this
449:41 - function keyword not a our function
449:44 - because that way this will always point
449:47 - to our document
449:48 - and with get name simply what do i want
449:51 - to do i want to return
449:53 - this dot and name and now of course we
449:56 - just want to go back to auth.js
449:58 - and where we have user.name let's just
450:01 - invoke let's say user
450:04 - and we're going to be looking for get
450:06 - name so invoke this one and now let's go
450:10 - to the postman and let's try to send it
450:13 - so i'll navigate back i'll send it and
450:16 - because i wasn't careful of course i
450:18 - didn't pay attention to my email so of
450:21 - course i need to change it to
450:22 - john4gmail.com
450:25 - and i can clearly see that i still have
450:27 - the name so if i'll change this one
450:29 - around then if i'll say anna
450:31 - and maybe i'll go with
450:34 - anna gmail.com
450:36 - then i'll still be able to access the
450:38 - name and what that means is that we can
450:40 - generate the token using the instance
450:43 - method instead so again we're trying to
450:46 - keep all our logic in one place where we
450:49 - have the user schema instead of
450:52 - scattered around
450:54 - our controllers and let's just fix
450:57 - everything back we'll say username
451:00 - we'll stay with that for time being of
451:02 - course we can cut it out and i think
451:05 - we'll retype one more time from scratch
451:07 - just so we can get comfortable with jwt
451:10 - now i'm not gonna need the import here
451:13 - for the token anymore so i can
451:15 - definitely cut it out i have my user
451:17 - awesome and eventually i'll invoke a
451:20 - method that will get me that token so
451:22 - now let me save auth.js
451:25 - back in the user of course the name is
451:27 - not going to be get name
451:29 - and you know what i'll just set up
451:31 - everything from scratch i'll say user
451:33 - schema
451:34 - then again the syntax is methods and
451:37 - then we're looking for the function name
451:40 - and in this case i'll call this create
451:42 - jwt and again it's going to be a simple
451:45 - function here and as far as the logic
451:48 - we'll just return right away jwt sign
451:52 - and of course in here i need to get the
451:54 - library so let's go with jwt at the top
451:57 - and then
451:58 - jwtc sign and again remember in the
452:02 - function we can access the document how
452:05 - well by using this correct and as far as
452:08 - the payload again i'm going to go with
452:10 - user id then i'll set it equal to this
452:14 - and underscore id so this points to the
452:16 - document and then we're going to go with
452:19 - comma
452:20 - name and then we'll just go with this
452:22 - dot name and again we'll just cheat a
452:24 - little bit where i'll say
452:26 - jwt secret and then as far as the
452:30 - expression again we'll keep it at 30
452:32 - days so expires
452:35 - and we'll set it equal to 30 days so now
452:38 - if i go back to auth.js i simply want to
452:42 - call create
452:44 - jwt that's it that's all we have to do
452:47 - so once we create the user of course we
452:49 - have that instance method and here i can
452:51 - just say token
452:53 - and i'm going to go user and of course
452:56 - the name of the method is create
452:59 - and jwt we invoke it and now of course
453:03 - we can go back to our postman now we
453:06 - already have one anna
453:08 - and let's just change the name just so
453:10 - we can see that it works we'll go maybe
453:12 - with peter
453:13 - and i'll set it here as peter as well
453:16 - and then once we send of course
453:18 - now i have the peter as well as the
453:21 - token and of course that means that
453:23 - everything works and successfully we're
453:26 - done with our register controller and in
453:29 - the process we learned about hashing the
453:31 - passwords setting up the mongoose
453:34 - middleware as well as the instance
453:36 - methods on a schema all right and once
453:39 - we're good with register route like
453:41 - promised let's swing back to the json
453:44 - web tokens and the first thing i want to
453:46 - talk about is the expression so remember
453:49 - in options we go with expires in and as
453:52 - far as default setup so if we just
453:55 - provide a number this is going to be in
453:58 - seconds
453:59 - now if we provide a string
454:02 - then we need to make sure that we add
454:04 - time units whether that's days hours and
454:07 - all that
454:08 - otherwise it's going to be interpreted
454:10 - as milliseconds so if you go something
454:13 - like this
454:14 - string of 120 it's going to be equal to
454:16 - 120 milliseconds and of course we'll
454:20 - return to this one once we start
454:21 - refreshing the tokens and all that cool
454:24 - stuff for now just be aware that by
454:26 - default it's going to be seconds unless
454:28 - you provide a string with a time unit
454:32 - that should do it for expires in and as
454:35 - far as that secret string
454:37 - yeah you can get away with jw secret but
454:40 - of course a more proper setup is
454:43 - generating some kind of more secure key
454:46 - and i prefer using all keys generator
454:49 - dot com again this is a free one of
454:51 - course if you want you can donate and
454:53 - all that but you can use it for free
454:55 - you're looking for encryption key and
454:58 - then more specifically you're looking
454:59 - for 256 bit one and then of course you
455:03 - can get the value and just take that
455:05 - value and stick it in the dot env file
455:10 - and as a side note we can also set the
455:13 - expires in ind ind.env as well and
455:16 - actually this is exactly what we'll do
455:18 - right now so let's navigate back to our
455:21 - project i'm looking for dot envy and
455:24 - then i want to set up two values i want
455:26 - to go with jwt underscore
455:29 - secret and that is going to be of course
455:32 - equal to my encrypted one and then the
455:36 - second thing that i want is that
455:38 - expiration and as far as the name i
455:40 - think i'm going to go with jwt
455:43 - jwt underscore
455:45 - and lifetime
455:47 - and now of course once i have both of
455:49 - these things and as i know of course i
455:51 - need to set it to some kind of value so
455:53 - in my case i'm going to go back to my 30
455:55 - days and once i save both of them
455:58 - now of course i just need to spin up the
456:00 - server
456:02 - and i'll be able to access that in my
456:04 - user model and once my server is up and
456:07 - running i can just go back over here
456:10 - and instead of hard coding
456:12 - simply go with process
456:14 - dot env and in this case of course i'm
456:17 - looking for jwt underscore secret and
456:21 - then as far as expires in i'm gonna go
456:24 - with my value and again we're looking
456:27 - for process dot env and we're looking
456:30 - for jwt
456:31 - and lifetime or however you called your
456:36 - variable
456:37 - and once we have both of these in place
456:39 - now of course let's test it out just to
456:41 - make sure that we don't have any silly
456:42 - bugs
456:43 - and let's go with peter
456:45 - and we'll set it up as 23. i send and
456:49 - everything is correct so once i have all
456:53 - of this in place now of course we can
456:54 - switch gears and set up the login
456:57 - functionality beautiful once we can
456:59 - successfully register the user
457:02 - now of course let's worry about the
457:03 - login functionality
457:05 - and
457:06 - honestly
457:07 - we have covered pretty much all of the
457:09 - things apart from checking the password
457:13 - so of course since we're using a library
457:15 - to hash the password of course we want
457:17 - to compare it as well
457:19 - now since that involves creating another
457:22 - instance method we'll actually do that
457:24 - in next video in this video simply want
457:27 - to check whether we're getting the email
457:29 - and the password with some kind of
457:32 - values because that's the whole setup
457:33 - for the logging in in this case they
457:36 - don't need to provide name they just
457:38 - need to provide email and a password if
457:40 - they don't we send back the bad request
457:42 - one
457:43 - after that we'll check for the user in
457:45 - our database so basically we'll go with
457:47 - our user and find one and we'll pass in
457:50 - the email
457:51 - and if we can find one
457:53 - then of course we'll send back the user
457:56 - and if not then of course we'll send
457:57 - back another error and let's start here
458:01 - by removing that not send i'll close the
458:04 - sidebar here and let's start by const
458:07 - email and password and this is the case
458:10 - where i'll do the checking the initial
458:12 - checking right in the controller and
458:15 - i'll actually cover
458:16 - why that's my preference in this case
458:19 - once we're done setting up compare
458:21 - passwords functionality so first in the
458:24 - request i'm looking for email and
458:26 - password and right out of the gate i'll
458:28 - say if no email
458:31 - or if no password
458:33 - then of course we'll go with our bad
458:36 - request and of course we'll do that in
458:38 - if block and we'll say throw
458:41 - new and we already have the import for
458:43 - battlequest so we just go with bad
458:46 - request error and we just need to
458:48 - provide a message please
458:50 - provide
458:51 - email
458:52 - and password
458:54 - and once i have this one in place then
458:56 - of course we want to check for the user
458:58 - correct how do we check for user well we
459:01 - have the model we have the user model
459:04 - and on it we have a method by the name
459:05 - of find one so let's come up with some
459:08 - kind of variable name and microsoft's
459:10 - going to be user and we'll go with await
459:13 - of course it is asynchronous then we go
459:15 - with user dot and find one
459:19 - and then instead of passing in the id
459:21 - and all that we'll pass in the email so
459:24 - whatever we're getting from the user
459:26 - we'll just pass it in here and
459:28 - effectively at this point we have two
459:30 - options
459:31 - if the user exists
459:34 - awesome then of course we can send back
459:36 - the response with the username as well
459:39 - as we can create token of course
459:41 - now if the user doesn't exist then of
459:44 - course we want to throw another error
459:46 - now in this case though we're not going
459:48 - to be throwing bad request error in this
459:51 - case if there is no user then of course
459:53 - we'll send back the unauthenticated
459:57 - error because in this case the user is
460:00 - not providing valid credentials and
460:03 - that's a big difference so let's go back
460:05 - to auth.js of course we want to import
460:07 - that so in here let's go with on
460:10 - authenticated error
460:12 - that's the class we're looking for and
460:14 - in here let's check and eventually
460:16 - there's also going to be code for
460:18 - comparing
460:19 - the password
460:21 - but like i said we'll do that in next
460:23 - video so that is still coming up for now
460:25 - we'll just say
460:27 - if there is no user then please throw
460:30 - that error
460:31 - throw new and again we're looking for
460:33 - our auth error and we'll simply say
460:36 - invalid credentials credentials and once
460:40 - we have taken care of this now of course
460:43 - we want to create the token because if
460:45 - we go past this error that means that
460:47 - user is there user exists and remember
460:51 - the instance method we created in the
460:53 - previous videos the create token one or
460:56 - create jwt don't remember i believe it
460:59 - was create jwt of course we want to
461:01 - invoke it and essentially we want to
461:03 - send back the same response so the same
461:06 - response as we sent when we registered
461:09 - the user so if user exists let's create
461:12 - that token and of course we'll go with
461:14 - user
461:15 - create
461:16 - jwt we invoke it we get back to token
461:20 - and now it's the same deal we go with
461:22 - status now in this case we want to go
461:24 - with status codes and it's not going to
461:27 - be 201 it's going to be 200 and of
461:29 - course that one is the okay one and then
461:32 - as far as the json same deal also in my
461:36 - setup on my front end i'm looking for
461:39 - the name property so not to be redundant
461:42 - but you always want to send back the
461:44 - token but optionally you want to include
461:47 - some more things as well and in my case
461:50 - those more things is just a username so
461:53 - go with user
461:54 - for name of course the property and then
461:57 - username and then comma
461:59 - and of course in here we're looking for
462:02 - a token
462:03 - so right after the name we'll go token
462:05 - and of course that is equal to the token
462:08 - that we're getting back from create
462:10 - token and now of course we can go and
462:13 - check it out in the postman
462:16 - so let's go back over here i believe we
462:19 - just created peter 23
462:22 - so now let's just test it out i'll
462:24 - create a new route
462:26 - so let's say here new route it's still
462:28 - going to be a post route of course
462:31 - and as far as the url again we're
462:33 - looking for our global variable
462:35 - forward slash and it's going to be auth
462:38 - and of course in this case it's a login
462:41 - one and then let's just grab these
462:43 - values over here
462:45 - let's say that we'll take the name email
462:48 - as well as the password and of course we
462:50 - won't use the name
462:52 - but we can nicely copy and paste just to
462:55 - save a little bit of time copy and paste
462:57 - and of course
462:58 - forgot about my curlies so let's place
463:02 - it here properly everything
463:05 - and this is turning out to be a mess
463:07 - okay
463:07 - i set up everything correctly over here
463:10 - and i don't need the name
463:12 - and i'm just going to be sending the
463:14 - peter 23 with a secret again for time
463:17 - being we're really just checking whether
463:20 - that secret is there i'll save it and
463:23 - i'll say in the jobs one
463:25 - and we'll say login user
463:29 - and then let's test it out
463:31 - cursor here still have the body yes
463:34 - everything is correct and of course i'm
463:36 - getting back to peter
463:38 - now if i'll do some mistakes
463:41 - if for example i'll remove the password
463:44 - we should get the 400 one and that's the
463:47 - please provide email and password okay
463:48 - that's good let me add the password and
463:51 - now let's mess up the email instead of
463:54 - 23 i'll go to and now of course i have
463:57 - invalid credentials and of course the
463:59 - error in this case is 401 so our base
464:03 - functionality works really great the
464:05 - only thing that's left to do in here is
464:08 - just to compare the password using our
464:11 - library and if you remember the library
464:14 - name was bcrypt js not bad not bad we
464:18 - can register user we can almost log in
464:22 - and the reason why i say almost because
464:24 - of course the moment as long as there's
464:26 - some kind of value for the password
464:28 - we're actually sending back the token so
464:30 - now let's fix that let's actually
464:32 - compare the password and this is that
464:35 - interesting thing where you might be
464:37 - like okay but wait a minute
464:39 - back when we were registering of course
464:41 - we were hashing this password correct we
464:44 - went with gensalt and then hash and the
464:46 - deal is following where essentially we
464:49 - have our library we have the package
464:51 - dbcrypt1 and in the beaker package of
464:54 - course there is a function by the name
464:57 - of compare
464:59 - and it compares
465:01 - the hashed passwords so again it's a
465:04 - one-way street once we hash the password
465:07 - that's it
465:08 - but with compare method we compare those
465:11 - hash passwords and of course if they
465:13 - match awesome we send back the token and
465:16 - user has successfully logged in and of
465:19 - course keep in mind that we can set up
465:21 - this functionality right over here but
465:24 - why we would want to do that if we
465:26 - already know how to set up the instance
465:28 - methods so instead of jamming more code
465:31 - in the login controller we'll simply go
465:33 - over here and i'll say user schema
465:37 - and of course we need to go with methods
465:40 - and then as far as the name i'm going to
465:42 - go with check password or compare
465:45 - password again naming is really up to
465:47 - you
465:47 - in my case i'm gonna go maybe with
465:49 - compare password sounds a little bit
465:51 - more sophisticated and this is going to
465:54 - be a sync function
465:56 - and then this function is going to be
465:58 - looking for one argument and that of
466:00 - course is going to be the password
466:02 - that's coming with a request
466:04 - and i'm just going to name this one
466:06 - candidate password
466:09 - and password
466:10 - and then as far as the function body i
466:13 - want to come up with some kind of
466:15 - variable and in my case i will call this
466:17 - is match and we'll set it equal to a
466:20 - weight because we can run the compare
466:23 - method asynchronously and we'll say
466:26 - await again the package name is bcrypt
466:28 - of course and then the method name
466:31 - is compare and then in the compare we'll
466:34 - pass in two things
466:36 - we'll pass in the password so the
466:38 - candidate password essentially the
466:40 - password that is coming in with a
466:43 - request and after the comma of course
466:46 - we'll get the password from the document
466:48 - of course the one that is already saved
466:51 - in a database so let's go back to the
466:54 - compare and we'll just go with candidate
466:56 - password so again the one that's coming
466:58 - in with the request and of course in
467:00 - order to access the document password we
467:03 - simply go to this dot and we provide the
467:06 - password and then what we want to return
467:08 - from the function is the match so let's
467:11 - say here returned and is match and once
467:14 - we have the function in place
467:16 - now we simply want to go back to
467:18 - auth.js and if we can see that we have
467:22 - the user we also want to set up one more
467:24 - if statement where we'll check the
467:26 - password so now of course i can move
467:28 - this comment down and i can say if there
467:32 - is a user i also want to check whether
467:35 - the password matches and we can do that
467:37 - by going with const and then come up
467:40 - with some kind of variable is password
467:42 - correct and of course we need to go with
467:45 - a weight because our function is
467:46 - asynchronous then we're looking for the
467:49 - user so of course this only happens if
467:52 - we have a user if we don't have the user
467:54 - then we right away send back invalid
467:56 - credentials and here we'll go with check
467:59 - or i'm sorry compare password of course
468:02 - i went with sophisticated name then we
468:04 - pass in the password that we're getting
468:07 - from the user and now of course we want
468:09 - to do the same thing where we want to
468:11 - check
468:11 - if the password is correct
468:14 - then of course we just return a token
468:16 - and all that if not then we'll throw the
468:19 - error
468:20 - and i'll just speed this up and we'll
468:22 - copy and paste and we'll do the same
468:24 - thing
468:25 - if the password is false meaning
468:28 - if we get back is match as false then of
468:32 - course we'll just throw this error and
468:34 - now let's go and test it out in the
468:35 - postman so at this point i have email as
468:39 - well as the password and they should be
468:41 - correct so let's send it here and of
468:43 - course i get back the response but
468:46 - if i start messing with the values for
468:48 - example if i go
468:50 - with a wrong email now of course i'll
468:53 - get invalid credentials so let's set it
468:56 - back to 23 and then if we do the same
468:59 - thing with the password we'll also get
469:01 - back the same message so notice here we
469:04 - have this invalid credentials now if i
469:07 - provide the correct values the correct
469:09 - email as well as the password then of
469:11 - course everything is great and we get
469:13 - back the token now lastly you're
469:15 - probably wondering okay but why did you
469:17 - check over here right in the controller
469:20 - because technically we need to
469:22 - understand that yes if there is no email
469:24 - of course we'll get that mongo's error
469:26 - correct well let me showcase something
469:29 - so i'll comment this one out so
469:31 - basically now we're not checking for
469:33 - empty values
469:35 - and let me provide the correct one let
469:37 - me say that yeah the correct email is
469:39 - going to be peter 23 yay area but i'll
469:43 - remove the password
469:45 - and essentially once i send i get back
469:47 - this error response but it is empty so
469:50 - let's go over the
469:51 - reasons why is that happening well if we
469:53 - take a look at the user of course we
469:55 - have the compare one and this one will
469:58 - throw an error it will throw an error
470:01 - because of course we're passing in the
470:02 - empty value correct back in auth.js
470:05 - we're getting back the password but
470:07 - password is just empty string
470:10 - and we are getting the error and we are
470:12 - actually handling that error
470:14 - in our error middleware so let's go back
470:17 - over here the error handler we are
470:19 - handling it over here and i can actually
470:21 - showcase that can go with log
470:23 - and we can cancel log the error and
470:26 - again let me send one more time and in
470:28 - the console you'll see the error and
470:30 - again it is thrown
470:32 - by our library notice here legal
470:34 - arguments undefined and i just find it
470:37 - easier to check it right over here or
470:41 - something we'll learn later to set up a
470:43 - validation layer and again that is all
470:45 - coming up for time being i just find it
470:48 - easier to check for that error right
470:50 - here for those empty values and then
470:53 - just send back the response instead of
470:55 - chasing it in error handler can that
470:57 - just my preference of course if you
470:59 - don't like this setup you don't have to
471:01 - use it but that's my explanation for
471:05 - using this bad request over here
471:07 - hopefully everything is clear as far as
471:09 - the register and login and now of course
471:12 - we can move on to our next step all
471:14 - right and once the login register are in
471:16 - place as far as auth the last thing we
471:19 - need is auth middleware where we can
471:21 - verify the token and if everything is
471:24 - correct and get the user id and pass it
471:26 - along to the job routes now the
471:28 - functionality is going to be exactly the
471:30 - same like in the previous project i
471:33 - might just use different variable names
471:35 - here and there and to answer your
471:37 - question yes
471:38 - i'll purposely retype everything from
471:40 - scratch
471:42 - just because i find repetition to be
471:44 - very important aspect of learning now if
471:48 - you don't agree with my opinion
471:49 - essentially you have two options you can
471:51 - just copy and paste the code from the
471:53 - previous project and i'll show you of
471:55 - course where you can get it in a second
471:57 - or make this a challenge and try to
472:00 - recreate everything from scratch
472:02 - yourself and of course if you get stuck
472:05 - utilize the previous project code or
472:07 - this video lecture and of course the
472:10 - code that i'm talking about is this one
472:12 - if you navigate to folder number five
472:15 - the jwt basics one and then more
472:18 - specifically if you look in the
472:19 - middleware of course you'll find the
472:21 - middleware that we are about to set up
472:24 - and now of course i'll close everything
472:26 - and i'll start from scratch so i'm
472:28 - looking in the star looking for the
472:30 - middleware and i'm going to go for my
472:33 - authentication one
472:34 - and first let's start with imports and
472:37 - essentially we're looking for the user
472:38 - first so that's going to be our model so
472:40 - let's go with require
472:43 - and i believe this was two levels up so
472:46 - let me look in my models
472:49 - and of course user okay that's good then
472:51 - i want to go with my jwt because of
472:53 - course we want to verify the token so
472:56 - let's go over here with require and the
472:58 - package name is jsonwebtoken and the
473:00 - last thing that i want is the
473:03 - unauthenticated error which of course is
473:05 - coming from my errors and this is the
473:08 - case probably
473:10 - where it's going to be faster if i just
473:12 - copy and paste so let me take a look at
473:13 - index.js
473:15 - and of course
473:16 - the name is right here
473:18 - so let me import this from my errors and
473:22 - again i think i'll have to go two levels
473:24 - up so let me take a look at
473:26 - require and we're looking at the errors
473:29 - folder and since we have index.js you
473:32 - already know that we don't need to
473:34 - specify the path we just simply say
473:36 - errors
473:37 - and with all of this in place now of
473:39 - course what we want to do is go with
473:42 - const auth so that's going to be our
473:44 - middleware and of course it's going to
473:45 - be a function
473:47 - and it's going to be looking for three
473:48 - things the iraq res and next and then as
473:52 - far as the function body remember the
473:54 - first thing we want to do is check for
473:56 - the header so let's add here the comment
473:59 - and we're looking for a header first for
474:01 - the authorization one and then we want
474:04 - to check whether it starts with bearer
474:06 - so first i'm going to set up the
474:07 - variable and i'll say auth
474:11 - header and that is equal to require
474:14 - errors
474:14 - and the authorization one of course and
474:17 - then after that i'm looking for if
474:19 - statement and in here i want to check
474:22 - if it doesn't exist if there is no
474:24 - header then of course we'll throw the
474:26 - error or
474:28 - if it doesn't start with better so let's
474:30 - go over here with mouth header and we'll
474:34 - go with starts with so of course that's
474:37 - the javascript method that we can use on
474:39 - a string and then we go with better and
474:42 - in some setups you'll see this space
474:44 - added as well but
474:46 - honestly it doesn't really matter
474:47 - because remember
474:49 - once we are done with if statement we're
474:51 - still getting the token and if there's
474:54 - going to be no space then of course the
474:56 - token won't make sense we won't be able
474:59 - to verify the token we're splitting the
475:00 - token anyway
475:02 - and let's go over here with throw new
475:04 - and of course we're looking for on
475:07 - authenticated error and as far as the
475:09 - text let's go with authentication
475:12 - and invalid
475:14 - and you know we'll also need to add here
475:16 - async so let's add over here async now
475:19 - we're checking for the header as well as
475:22 - the bearer and if one of them is false
475:25 - then of course we throw the error and
475:27 - once we're done with that let's go with
475:29 - our token so let's say kant's token is
475:32 - equal to auth error and then remember
475:35 - we're splitting it
475:36 - and we're splitting it on the empty
475:38 - space and then we're looking for the
475:40 - second value that's why we go with one
475:43 - so we turn this into array and then
475:45 - we're looking for the second item in
475:47 - array and this is what i'm saying so
475:50 - even if you omit this and if you just
475:53 - check for the better if the user has
475:56 - sent bearer and then right away token
475:58 - well
475:59 - this one won't make sense because
476:01 - basically this will be undefined
476:03 - we won't be able to split the string and
476:07 - of course if that's the case we won't be
476:09 - able to verify hopefully that is clear
476:11 - so let's go over here with try catch and
476:14 - then as far as the try block we'll try
476:16 - to get the payload so let's say over
476:19 - here payload and remember the method
476:21 - name is jwt and verify and here we want
476:25 - to pass in two things we want to pass in
476:27 - the token comma and then of course we're
476:30 - looking for process dot env
476:32 - and then jwt underscore secret
476:37 - and now of course once i have the
476:38 - payload i just want to pass it along to
476:41 - the job routes and in order to do that
476:44 - we'll first add a comment attach
476:47 - the user to the job route and then as
476:52 - far as the logic we can simply set up a
476:54 - reg.user so i'm right away setting up
476:57 - the property on a request object
477:00 - and as far as the value is in there i'm
477:02 - going to go with user id again that's
477:04 - just my preference and then i'll go with
477:07 - payload so this is what i'm getting back
477:09 - from the verify and of course in there
477:12 - i'll have the user id as well and
477:14 - technically we won't use the name
477:17 - but just for testing i'll pass in the
477:19 - name as well so let's say here name and
477:22 - again we're looking for payload and then
477:24 - that name and again if you're a little
477:26 - bit confused essentially in here we're
477:29 - just getting the payload that we're
477:30 - setting up in the route so if we take a
477:33 - look at our index routes i'm sorry not
477:36 - the index roads if we're looking at the
477:39 - author outs
477:40 - and notice here when we're creating the
477:43 - json web token right now of course the
477:45 - functionality the actual functionality
477:48 - is in the model so let me go over there
477:50 - in the user essentially this is what
477:53 - we're passing in we're passing in the
477:55 - user id as well as the name so
477:58 - in the authentication middleware of
478:00 - course this is what we're getting back
478:02 - and again this is just for testing
478:03 - essentially in our controllers in the
478:06 - job controllers of course we'll just use
478:08 - the us id but since i want to showcase
478:10 - that this is actually the same user also
478:13 - pass in the name here as well and then
478:16 - as far as the catch well we have the
478:18 - error and we can just throw it we can
478:20 - just say over here throw new and we'll
478:24 - go with our error and essentially the
478:26 - text is going to be exactly the same so
478:29 - i'll just take it from here and copy and
478:31 - paste and before i let you go of course
478:34 - remember that we need to do two things
478:37 - we need to export the auth as well as we
478:40 - need to invoke the next because
478:41 - otherwise we won't get to the job routes
478:43 - anyway so let's go over here with next
478:46 - first so now of course we pass along the
478:48 - user to the job routes and we need to go
478:52 - with module
478:53 - exports
478:54 - and then we're looking for auth
478:57 - and i'll set up the actual middleware as
479:00 - well as test it out in next video all
479:03 - right and once the auth middleware is in
479:05 - place now of course we just need to
479:07 - decide
479:08 - where we're going to place it because if
479:10 - you remember the previous project we
479:12 - only had one
479:13 - authenticated route and of course we
479:16 - just used the router for that
479:18 - and technically we can do the same thing
479:20 - over here in jobs but we just need to
479:23 - understand that of course in this case
479:25 - we want to authenticate
479:27 - all the routes so basically we want to
479:29 - protect all of them because if i create
479:32 - a job
479:33 - i only want to look at my jobs and i
479:36 - don't want you to modify my jobs or
479:39 - you probably don't want me to modify
479:40 - yours so essentially what i'm saying we
479:43 - want to add that protected route
479:46 - for all of them so we want to protect
479:49 - all of our routes as far as the jobs not
479:52 - just one of them so technically you can
479:54 - say yeah well okay we can import and
479:56 - then we can just add them one by one and
479:59 - technically it is an option but there's
480:01 - actually a better one
480:03 - if we go to app.js take a look we have
480:06 - app.use and then of course we have
480:09 - all the job routes and in this scenario
480:11 - what we can do we can just get the
480:13 - middleware and then stick it in front of
480:16 - the jobs router and with that in place
480:20 - all of our jobs routes will be protected
480:22 - so instead of going one by one
480:25 - we just do that in app.js and as a
480:27 - result we'll protect
480:29 - all the job routes so let's do it we're
480:32 - going to go where we have the connect
480:33 - and above or below doesn't really matter
480:36 - i'll say authenticate
480:39 - user
480:40 - and we'll go with require and of course
480:42 - i'm looking for my middleware
480:44 - and in there i'm looking for
480:46 - authentication one and then we scroll
480:48 - down
480:49 - we go with authenticate user pass the
480:52 - comma and we're good to go
480:54 - and in order to test it we'll go to the
480:57 - controllers over here and since we'll
480:59 - start working in create job anyway i'll
481:02 - look for
481:03 - create job and we'll just test it out
481:05 - and we'll test it out in the following
481:07 - way where i'll go with res.json
481:10 - and let's just pass here rec dot user
481:14 - so i'm getting that user from my auth
481:16 - one if everything is correct and of
481:19 - course i should be able to see the user
481:22 - as well as the id so let me save it over
481:25 - here and as a side note i actually
481:27 - removed all my current users e in the
481:30 - database just so we can start nicely
481:32 - from scratch because as we were setting
481:34 - them up we used the dummy string and
481:37 - then we set up the proper one just so we
481:39 - don't get any dumb bugs i also suggest
481:42 - to do the same work remove all the users
481:45 - and we'll start everything from the
481:46 - scratch so now of course i want to go to
481:48 - the postman i already have the register
481:51 - route correct so let's just get the
481:54 - token first so of course i go with name
481:57 - email and password i get the token
482:00 - awesome
482:01 - that's what i wanted and now of course
482:03 - we want to set up a new route now again
482:05 - this is going to be a post route to
482:08 - create a job so let's go over here let's
482:11 - say new route we're looking for the post
482:13 - method
482:14 - and we use the same url of course and
482:17 - then if you remember
482:19 - the difference was that for jazz we just
482:22 - go with forward slash and jobs and if
482:25 - you want to double check just go to
482:27 - app.js first notice that's the path
482:30 - again this is already part of our
482:32 - variable the url one then we have the
482:34 - jobs and then of course in the routes as
482:37 - far as the post well that's going to be
482:39 - a route anyway so that's going to be the
482:41 - forward slash now for getting the single
482:43 - job deleting and all that then of course
482:45 - we'll pass in the route parameters as
482:48 - well but for the post it's simply
482:50 - forward slash which just means that we
482:52 - go with url and then the jobs now we're
482:55 - really not concerned with the body
482:57 - because we're just testing whether our
483:00 - authentication works but what we do need
483:03 - to get is authorization over here and my
483:06 - apologies i'm actually looking for the
483:08 - headers and the reason why i'm showing
483:10 - you the authorization because
483:12 - at the end of this project or maybe in
483:14 - few videos i'll show you how we can set
483:17 - this up dynamically so you don't have to
483:20 - every time just copy and paste the user
483:23 - token because we need to understand that
483:24 - of course we can use
483:26 - multiple users correct and you don't
483:28 - want to copy and paste
483:30 - every time that token so i'll show you a
483:32 - dynamic way how we can set that up but
483:35 - not yet so let's go here where we have
483:37 - the headers again we're looking for the
483:39 - authorization one
483:41 - and then we want to go with bearer and
483:44 - we want to pass in the token and once i
483:46 - send if everything is correct
483:49 - check it out i have the user id which
483:52 - should match to whatever id i have in
483:55 - the database and of course i'm not going
483:57 - to check value by value but hopefully
483:59 - you understand the idea where these ones
484:02 - should match this one and the one that i
484:05 - have over there on the postman and i can
484:07 - clearly see the name so what happens if
484:11 - i go with different user
484:13 - if i register this user instead
484:16 - and let's go with anna here again the
484:18 - same secret we get different token
484:21 - and now of course we should get
484:23 - different name correct so in the jobs
484:26 - i'll remove the john token
484:29 - and i'll paste the ana one once i send
484:32 - of course now i get back the ana so what
484:35 - that means in any of the job routes i'll
484:38 - have anna's id or john's id or whichever
484:42 - token i'm getting and when it comes to
484:44 - any of these functionalities
484:46 - will only deal with the resources
484:48 - that are associated with a user
484:52 - hopefully we're on the same page and now
484:54 - of course we can start setting up the
484:56 - functionality
484:57 - and once we're done setting up our auth
484:59 - middleware i also want to mention
485:01 - something where as you're looking at
485:03 - someone else's code you might come
485:05 - across this syntax
485:07 - where instead of creating a object
485:11 - like we are doing in line 20
485:14 - what they do is they look for the user
485:17 - in the database so they take the model
485:20 - the user model and then either find by
485:23 - id
485:24 - or find one that also works and then of
485:27 - course they just pass in the id that is
485:30 - coming from the token
485:31 - and in most cases they will use the
485:33 - select to remove the password there's
485:35 - really no point to pass this password to
485:39 - the upcoming middleware meaning our
485:42 - request
485:43 - and therefore they just use the select
485:45 - and remove it and then when it comes to
485:48 - reg.user well i just set it equal to
485:52 - this variable and it's definitely an
485:54 - option but the reason why i'm not doing
485:57 - that in this project is simply because
485:59 - if we just think about it we really have
486:02 - no functionality to remove that user
486:04 - anyway so if i'm getting my id
486:07 - from the token i'm pretty sure
486:10 - that there is a user on the other side
486:14 - again you might see this code and yes we
486:17 - might implement ourselves in a future
486:20 - project but not in this case i really
486:22 - didn't see the point of looking for the
486:24 - user since we have no functionality to
486:27 - remove it in the first place now if you
486:29 - do decide to go with this logic then of
486:31 - course just make sure that you remove
486:34 - line 20 because otherwise you're
486:36 - overriding with our current setup anyway
486:39 - awesome and once our auth is working now
486:42 - essentially we want to set up a model
486:45 - for the job
486:46 - and of course work on rest of the routes
486:49 - now before we set up the model though
486:52 - let me also quickly save it
486:54 - so this is going to be create job
486:57 - so let's set up the name create
487:01 - job and of course i'll set it in the
487:03 - jobs one and i also want to test it out
487:06 - really quickly
487:08 - where if in headers i make that mistake
487:11 - and i don't add the space what response
487:14 - i get of course i have
487:16 - authentication error so again this just
487:19 - proves the point that i was making
487:20 - before where essentially even if we omit
487:23 - the space over here we still check the
487:25 - token
487:26 - and of course in that case we're not
487:28 - able to split it meaning we are
487:30 - splitting it but we're just getting
487:31 - undefined and as a result our token is
487:35 - undefined as well so hopefully that is
487:37 - clear so now let me just navigate to the
487:40 - models and i want to create
487:42 - a job model and the first thing that i
487:44 - want to do is set up the mongoose
487:47 - and of course that is equal to require
487:50 - and we're looking for a package the
487:52 - mongoose one and after that let's just
487:54 - set up our schema so let me close the
487:56 - sidebar just so we have a little bit
487:58 - more real estate so job schema
488:01 - and that is equal to new mongoose
488:04 - and schema
488:06 - schema and here let's pass in the object
488:09 - and as far as the properties i'm going
488:11 - to have the company
488:14 - and that will be equal to an object of
488:16 - course type will be
488:18 - set to string
488:19 - then required will be true
488:22 - and essentially we'll set it up as an
488:24 - array of course and let's just say true
488:27 - and as far as the message we'll go with
488:30 - please
488:31 - provide
488:32 - company
488:33 - and name and last thing that i want to
488:36 - set up for the company's max length that
488:39 - we can use
488:40 - on strings
488:42 - and in here
488:44 - we'll set it up as 50. of course if you
488:47 - want to go a different value be my guest
488:50 - so let me take the company and we'll
488:52 - copy and paste this one
488:54 - one time and the second property we want
488:57 - to set up is the position
489:00 - it's going to be a string again
489:02 - it will be required and in this case of
489:04 - course we'll say position please provide
489:08 - position as far as the max length in
489:10 - this case let's maybe increase it in my
489:13 - case i'm going to go 200
489:15 - and then as far as the job interview
489:17 - well there's always this status whether
489:21 - it's pending so whether we're waiting
489:22 - for response whether we already have the
489:25 - interview or
489:26 - it was declined correct
489:29 - and essentially we want to do that using
489:31 - the status property so comma status
489:35 - and then again it's going to be an
489:37 - object it's going to be a string but
489:40 - we'll use that enum remember
489:42 - option where we can set up the array
489:44 - with a possible values so let's say here
489:47 - enum and as far as possible values like
489:50 - i said we'll go with interview
489:52 - then declined
489:54 - declined
489:56 - and then last one will be pending and
489:59 - this is going to be the case again where
490:01 - on the front end will just provide these
490:04 - two values the company one and position
490:07 - when we are creating the job
490:09 - so these are going to be the values that
490:11 - are required however the status one we
490:14 - will manipulate when we are modifying
490:17 - the job so therefore we'll go with
490:20 - status these are our options and then
490:22 - like i said lastly we'll go default and
490:25 - we'll set it equal to pending that's the
490:27 - setup i'm going to have and then
490:29 - probably the most most important
490:32 - property that we haven't set up
490:34 - is the created by why well because in
490:37 - here
490:39 - we'll tie our job
490:41 - to the actual user and the way it's
490:43 - going to look like we'll go here with
490:45 - created
490:46 - by again the name is really up to you
490:48 - but that's set up that i have created by
490:51 - and then type is not going to be string
490:54 - or a number in fact it's going to be a
490:56 - mongoose then types and then we're
491:00 - looking for object and id so this is
491:03 - very very important so essentially now
491:05 - we're tying our job model to the user
491:09 - one so we have the user model over here
491:12 - correct so this is where we're creating
491:14 - a user so every time we'll create a job
491:18 - we will assign it to one of the users
491:21 - and as a result of course our
491:22 - functionality will work
491:24 - because every job that we will create
491:26 - will be associated with a user so first
491:30 - we have a type and we need to go
491:32 - mongoose types and then object id that's
491:35 - going to be the type for our property
491:37 - and then we need to go with ref and we
491:40 - need to specifically say well which
491:42 - model are we referencing and in this
491:44 - case we'll go with user of course so i
491:47 - want to tie the job to the user
491:50 - hopefully that is clear and then of
491:52 - course we want to go with required as
491:54 - well because we don't want to create a
491:56 - job without a user we'll set it equal to
491:59 - true
492:00 - and then as far as the value again let's
492:02 - just go with please provide
492:05 - and user and then lastly
492:08 - right after the schema object the first
492:11 - option that we have over here i want to
492:13 - go with comma
492:15 - and we'll set up timestamps and true and
492:18 - i'll showcase them once we actually
492:21 - start sending requests from the postman
492:23 - because you'll see the benefit of using
492:26 - timestamps right in the response so
492:28 - don't worry about them for now i'll show
492:31 - you once we start getting back the
492:32 - responses and of course eventually what
492:35 - we want to do is just go with module
492:37 - exports and we want to set it equal to
492:40 - mongos
492:41 - then model
492:43 - and then as far as the name i'm just
492:45 - going to go with
492:46 - job
492:47 - and then we'll pass in the job schema
492:51 - and once we have all of this in place
492:54 - now of course we can focus on routes and
492:56 - i guess let's start with the create job
492:58 - one nice we have the model so now let's
493:01 - just set up the functionality for
493:03 - creating the job and then one by one
493:06 - we'll deal with the rest of the
493:08 - controllers as well
493:10 - and in order to set everything up first
493:13 - of course
493:14 - from the postman we need to send the
493:16 - data
493:17 - and what data are we looking for again
493:19 - let's jog our memory we have the job
493:22 - model and here i'm looking for the
493:24 - company name
493:25 - as well as the position
493:27 - now let's not worry about the created by
493:29 - yet since that one we will get from our
493:32 - auth middleware
493:34 - and in here let's just set up some kind
493:36 - of values in the body so let's go with
493:39 - raw and we're going with json of course
493:42 - and then here let's say company
493:45 - company and then i'm just gonna go with
493:48 - google because why not
493:49 - and then as far as the position well
493:52 - let's just go with intern so position
493:56 - and then we pass in the intern
493:59 - now let's go back to our controller
494:02 - where we have the jobs one create job
494:05 - and instead of sending back the user i
494:08 - want to send back the wreck that body
494:11 - again just so we can test whether
494:13 - everything works so i have create job
494:15 - route i send it here and of course i
494:18 - have invalid authentication because
494:22 - i didn't fix my better one so let me go
494:25 - back and let me just add that space and
494:28 - now everything should work where of
494:30 - course i'm getting the values for the
494:32 - company as well as deposition
494:35 - so now what's left to do is go back to
494:38 - create job and of course in here we want
494:41 - to import
494:42 - finally our model correct and we want to
494:45 - create a new one so let's do that we're
494:48 - going to go at the top here
494:50 - and we'll create our imports and
494:53 - effectively we're looking for three
494:54 - things i want to get the status codes i
494:57 - want to get the job model
494:59 - as well as the requests and for requests
495:02 - we have two options we have bad request
495:05 - error as well as not found one so let's
495:08 - go with khan's job so that's going to be
495:11 - my model so require
495:13 - and of course we're looking in the
495:15 - models here and more specifically job
495:18 - then we want to get the status codes so
495:21 - const and then status codes now that is
495:25 - coming from our library of course
495:27 - so require an http status code and then
495:31 - lastly we have those two errors so let's
495:34 - go here with bad
495:36 - request
495:38 - an error
495:39 - and the second one will be the not found
495:41 - one so not
495:43 - found error
495:44 - and both of them are coming
495:46 - from
495:47 - and of course the errors
495:49 - so let's go two levels up and we're
495:52 - looking in the errors folder
495:55 - and once we have all the imports in
495:57 - place we'll swing back to create job and
496:00 - essentially the idea is following
496:02 - where of course
496:04 - at the moment i'm just passing in the
496:06 - ragdot body e and the json response
496:08 - correct
496:09 - and if you remember what was the method
496:11 - name to create new document well that
496:14 - was of course create and of course in
496:16 - this case we're looking for the job one
496:19 - correct so the way the setup is going to
496:21 - look like we're going to go with job
496:23 - then we'll await of course and then we
496:26 - go with model name and create and we
496:29 - pass indirect that body but the moment
496:32 - what we're missing is that user and
496:35 - where is the user located of course it
496:37 - is located in the rec dot user now what
496:41 - are we really looking for is the id
496:43 - correct so what we want to do here is
496:46 - just go with rec dot body again if you
496:49 - want a console log of course you can
496:51 - definitely do so but i'm just going to
496:53 - skip that part and we'll go with
496:54 - reg.body then we want to create
496:58 - onrec.body a new property by the name of
497:02 - created by why well because
497:04 - in our job model that's how i called my
497:07 - property
497:08 - so i add this property
497:10 - onrac.body and where is it located it's
497:13 - located in rec
497:15 - user and the property name is user id
497:19 - like so so now of course once we pass
497:22 - indirect that body will still have the
497:24 - validations but if everything is correct
497:27 - we create a new job and now of course we
497:30 - just need to handle that as far as
497:31 - response so let's just set up
497:33 - res.status now again this is going to be
497:36 - the created one so let's go with status
497:38 - codes
497:40 - status codes then we go with comma or
497:43 - i'm sorry d dot and then we go with
497:45 - created and then as far as the json i
497:48 - just want to send back the job so let's
497:50 - go over here and let's test it out so
497:53 - now i'm getting back the company and
497:54 - position but if everything is correct i
497:58 - should get way more than that and once
498:01 - we send unfortunately
498:03 - instead of getting back to job i get
498:05 - back the error where it says
498:06 - created by
498:08 - and it is a validation error which
498:11 - actually just showcases that our
498:12 - validation still works which is really
498:15 - really good and the problem of course is
498:17 - in here where i went with reg.body and
498:20 - it should be created by not created by
498:24 - so let me save and let me test it out
498:26 - one more time and once i send
498:28 - now of course i'm getting back the job
498:32 - and as far as the job i have the status
498:34 - so like i said by default it's going to
498:35 - be pending so this is going to be the
498:37 - job id and this is very very important
498:40 - that's why on the auth i set up that
498:43 - user id and that's why also when i was
498:46 - setting up djs and web token i prefer
498:48 - using that user id once you start
498:51 - building a bigger application you'll get
498:53 - bunch of these underscore ids and it
498:56 - gets confusing quite fast and therefore
498:58 - i prefer setting up that extra piece of
499:00 - code where i go with user id or job id
499:05 - or whatever and if you keep looking at
499:07 - it okay you can see the google you can
499:09 - see the position
499:10 - all that is nice but you're also
499:13 - probably noticing the created by and
499:16 - essentially this points to anna and of
499:19 - course what that means is that now this
499:21 - job will always always be tied to anna
499:24 - so once i register and log in and get my
499:28 - token and all that
499:29 - i won't be able to modify look at it or
499:32 - whatever and you're probably noticing
499:35 - these ones as well
499:36 - the created at and updated that and
499:39 - effectively we get them by default once
499:42 - we set up timestamps as true
499:45 - so mongoose schemas have that timestamps
499:48 - option that tells mongoose to
499:51 - automatically manage create that and
499:54 - update it at properties on our documents
499:58 - so that means is that of course we don't
500:00 - need to set them up manually and you can
500:02 - probably already guess that this one
500:05 - will always point to the time when the
500:07 - document was created and this one will
500:09 - change as we're updating and of course
500:12 - we can use these properties for example
500:14 - in filters and essentially this is
500:16 - exactly what we'll do when we're getting
500:18 - all the jobs and once we can
500:20 - successfully get back our first job i
500:23 - want to congratulate you on pretty much
500:27 - getting over the biggest hurdle because
500:29 - from now on everything is going to be
500:31 - exactly the same like we worked in the
500:34 - previous projects the only difference of
500:36 - course as far as the controllers will
500:38 - always always get that user id as well
500:43 - because of course we'll need to use it
500:44 - to search for jobs to update jobs and
500:47 - all that cool stuff awesome and once we
500:50 - can create the job now of course let's
500:52 - worry about the rest of the
500:53 - functionality
500:54 - and let's do it one by one so next one
500:57 - up we have get all jobs
501:00 - now in order to get the jobs we already
501:02 - know the method that is find which is of
501:05 - course available on the model however in
501:07 - this case when it comes to the filter
501:09 - object of course we'll pass in created
501:12 - by property and we'll set it equal to
501:15 - the user because what we want
501:17 - is to get only the jobs that are
501:20 - associated with the user and i know that
501:23 - i keep pretty much repeating the same
501:25 - thing and my apologies for that but that
501:27 - is very very crucial in this case we're
501:30 - not looking for all the jobs like we did
501:33 - in a task we're only looking for the
501:35 - jobs that are associated with this user
501:39 - and as far as the functionality it goes
501:41 - something like this where we'll go with
501:43 - jobs that is equal to a weight
501:47 - and then we'll go with job find and
501:50 - remember the filter object and remember
501:52 - if it was empty then of course we're
501:54 - just getting all the jobs but that's not
501:56 - what we want
501:57 - in here we want to say created by and we
502:01 - want to set it equal to rec
502:03 - user and user id again that user
502:07 - property here is going to be on every
502:10 - request since in the app.js
502:13 - we placed our off middleware in front of
502:17 - all of our jobs routes and then let's
502:19 - also sort quickly and let's sort based
502:23 - on creator that remember this property
502:26 - the creator that let's sort based on
502:29 - that
502:30 - so let's say here dot
502:32 - sort
502:33 - and let's just pass in the property
502:35 - created at
502:36 - and as far as the response well let's
502:38 - just go with res dot status
502:41 - and as far as the status codes of course
502:43 - we'll be looking for okay one still
502:46 - status codes and then okay and when it
502:49 - comes to json response
502:51 - i want to send back the jobs as well as
502:54 - the count because that's what i'm
502:56 - looking for on my front end again this
502:59 - is really optional you can of course
503:01 - send just jobs but in my case i want to
503:04 - send both and once i have all of this in
503:07 - place
503:08 - now of course we can go back to the
503:10 - postman i'll save both routes the
503:13 - register user as well as create job and
503:16 - you know what why don't we create a few
503:18 - more jobs
503:19 - so in here we'll say apple
503:21 - and we'll say front-end developer
503:26 - developer and then let's create one more
503:29 - and this one will be facebook
503:31 - as far as the developer let's just say
503:34 - backend one so let's send it here
503:37 - and once i send i want to check my
503:39 - database and there i have jobs okay
503:42 - that's good
503:43 - and as far as anna i believe i'm setting
503:46 - up everything as anna i have the one for
503:49 - google one for apple as well as the
503:52 - facebook and once i have all of these
503:54 - jobs in place now of course we can
503:56 - create a new route so let me save it
503:58 - over here
504:00 - and let's just go with get route in this
504:02 - case of course and we're looking for url
504:05 - and this is going to go to the same one
504:08 - as create job so we simply go with
504:10 - forward slash
504:12 - and jobs
504:13 - and of course we just send it and if
504:16 - everything is correct we should get
504:18 - authentication invalid why because of
504:21 - course we do need to include the header
504:23 - so let me go back to the headers
504:26 - let's go to authorization so now of
504:28 - course we know that our middle works
504:30 - we cannot just randomly access
504:33 - all the jobs you can only access your
504:36 - jobs and then let's go with bearer
504:39 - and then let's pass in the token that we
504:41 - have for anna again i'll show you in a
504:45 - second how we can set this up
504:47 - programmatically so we don't have to
504:49 - copy and paste every time so let's say
504:52 - here bearer let's send and now of course
504:54 - i have jobs array with the count off
504:57 - three and i can clearly see that all the
505:00 - info is correct all right and once we
505:03 - can create the job as well as get all
505:06 - jobs
505:07 - why don't we set up that token
505:09 - dynamically in the postman because as
505:12 - we'll be creating more users and of
505:14 - course add more functionality it's going
505:16 - to get annoying quite fast if we'll have
505:18 - to copy and paste each and every time
505:21 - that token value
505:22 - and first what i did is saved the
505:25 - request the get all jobs one and as you
505:28 - can see that's the name and of course i
505:30 - saved it in
505:32 - jobs api and as far as the setup it's
505:35 - going to go something like this where
505:37 - we'll start in login user and then we'll
505:39 - repeat the same in register but for time
505:42 - being i just don't want to worry about
505:44 - setting up those unique emails so let's
505:46 - go over here where we have the login
505:48 - user and we're looking for a test
505:51 - and we just need to add a little bit of
505:54 - code first we want to access the
505:56 - response that we're getting back notice
505:58 - of course if we're successful if we have
506:00 - logged in then of course we'll get back
506:02 - to token correct and in order to get
506:04 - that we'll just set up some kind of
506:06 - variable in my case i'm going to go with
506:08 - json data and we need to go with pm so
506:12 - postman and then dot and we're looking
506:15 - for response
506:17 - and in there we have a function by the
506:19 - name of json and then let's just go with
506:22 - our token value and let's set up our
506:26 - global variable and notice here on right
506:28 - hand side we actually have snippets so
506:31 - if we want to set up a new global
506:32 - variable we just click it and now we
506:34 - just need to provide the values
506:36 - and effectively the name is going to be
506:39 - access token
506:41 - and then as far as the value this is
506:43 - where we go with json data dot and of
506:46 - course i know that in my responses token
506:49 - is going to be located in token property
506:52 - so simply go with a token
506:55 - and now of course once we send we should
506:58 - see in the globals a new variable and of
507:02 - course we do and the only thing that's
507:04 - left to do is to go to either get all
507:08 - jobs or create job doesn't really matter
507:10 - we can go here and instead of
507:13 - authorizing that manually
507:15 - i'll unclick it and then we're looking
507:18 - for authorization
507:19 - then we want to go with bearer so
507:22 - probably you have by default here this
507:24 - inherit just go to better token one and
507:27 - then as far as the value well this is
507:29 - where you want to access that global one
507:31 - correct so you just go here with access
507:34 - token and now once we send we should
507:38 - get back the job now of course i created
507:41 - with the same values if i check the body
507:43 - so i have facebook and backend developer
507:45 - so if i take a look at my database
507:48 - and if i refresh i should have two
507:51 - values i'll have one that i created
507:53 - before and the second of course was
507:56 - created when we're testing this dynamic
507:59 - setup and of course we can do the same
508:01 - thing with get all jobs as well so let's
508:05 - take a look we have the headers here and
508:07 - i'm sorry i'm looking in the wrong place
508:09 - so we have the headers here let's remove
508:12 - it let's check the authorization again
508:14 - we have better token we're using access
508:17 - token and then once we send in the body
508:20 - now we should get four jobs and in order
508:24 - for everything to work we also need to
508:26 - do that in the register user so let's go
508:29 - back quickly to the login one let's grab
508:33 - these two lines of code then we'll go to
508:35 - register one again we have the tests
508:38 - let's save it here as well and now let's
508:40 - try to create another user so let's go
508:44 - to i believe in the body right this is
508:46 - where we were creating a new user
508:49 - and i'm going to go back to my good old
508:51 - peter
508:52 - peter at gmail.com we send we get back
508:56 - the token and now the moment of truth
508:59 - if i create a job
509:02 - and let's just say in this case netflix
509:06 - and then it's still going to be a
509:08 - back-end developer now this one should
509:11 - be created for peter and again notice
509:14 - how we don't need to worry about those
509:16 - headers anymore so let's go back to our
509:18 - database
509:20 - let's refresh and if everything is
509:22 - correct i should have a user by the name
509:26 - of peter that i created of course
509:29 - there it is there's my peter and if i
509:31 - take a look at the jobs
509:33 - peter should also have a job so i keep
509:36 - scrolling and yes there is i have the
509:39 - netflix one and of course it is a
509:42 - back-end developer so if i take a look
509:44 - at get all jobs now of course i should
509:47 - get only one that is associated with
509:51 - peter so let me go back to get all jobs
509:54 - let me send and now of course i have
509:56 - count of one so hopefully it is clear
509:58 - that now we're dynamically setting that
510:01 - access token so you don't need to
510:04 - manually do that each and every time and
510:08 - once we have all of this in place now of
510:10 - course we can continue with our
510:12 - application beautiful and once we can
510:14 - set up the access token dynamically in
510:17 - the postman now of course let's keep on
510:19 - working on our routes
510:20 - and next one up we have get job and i
510:24 - think this is going to be the case where
510:25 - i'll actually log in back in as anna so
510:29 - where i have the login user out i'll
510:31 - just go with anna now of course i get
510:33 - this token just because she has more
510:36 - jobs now let me save all of these routes
510:39 - since i don't want to set up everything
510:40 - from the scratch
510:42 - and then once i have logged in as anna
510:45 - let me just double check get all the
510:47 - jobs yep i have four of them and then
510:50 - remember for get job
510:52 - what we'll need to pass of course that
510:54 - is going to be the route parameter
510:57 - correct this is where we'll provide the
510:59 - id and if you want to double check that
511:01 - just go back to the routes we're looking
511:02 - for the jobs one and notice so the post
511:05 - and get all jobs
511:07 - is for the root and then we have the
511:10 - forward slash and then colon and then
511:12 - the eddy of course this is going to be
511:14 - that route parameter which will get me
511:16 - that single job
511:18 - make sure that i can delete one as well
511:21 - as update one
511:22 - and in order to test it out whether our
511:24 - basic functionality works essentially
511:26 - whether we can get that silly string we
511:28 - need to go back to the postman and i
511:31 - think i'll just leave the login user one
511:34 - and then i'll open up a new tab we're
511:36 - looking for get request of course
511:39 - then we go over here with our url
511:42 - and then forward slash and this is where
511:44 - i want to pass in the eddy so in get all
511:47 - jobs as far as the response of course
511:50 - will get back those ids correct and now
511:52 - if i want that one single job i just
511:55 - need to take underscore id again you're
511:57 - not looking for the user here you're
511:59 - looking for underscore id which just
512:02 - signals a job id so copy this one then
512:06 - go back to the get one the one will get
512:09 - the single request and remember we still
512:11 - need to go with authorization we need to
512:14 - set up better token and of course we'll
512:16 - use the access token and once we send if
512:19 - everything is correct
512:21 - of course we should get route doesn't
512:23 - exist because i was pretty smart and i
512:26 - forgot to add the jobs one so let's go
512:29 - over here and let's say
512:31 - jobs and then once we send now of course
512:33 - we have get single job so we know that
512:36 - this functionality works and of course
512:38 - now we just need to go back to our
512:40 - controller and in here i'm going to be
512:42 - looking for two things in the request
512:44 - first we need to remember that as far as
512:47 - the jobs we can access it in the params
512:50 - object that's going to be the job id
512:52 - and when it comes to user of course that
512:54 - one is located in the user object that
512:57 - we're getting from the middleware so
512:59 - let's destructure both of these things
513:01 - because
513:01 - as our functionality gets more complex i
513:04 - think it's easier if we can clearly see
513:07 - where we're getting those values from so
513:10 - i'm going to structure my request object
513:12 - and in there i'm looking for two things
513:14 - i'm looking for the user object and
513:16 - remember in the user object i have the
513:19 - user id so now of course we're doing the
513:22 - nested destructuring so i'm looking for
513:24 - that first
513:25 - and then what i want is the params so
513:27 - this one of course is provided by the
513:30 - express and then more specifically we're
513:32 - looking for the id now why we're looking
513:34 - for id because that's how i called it
513:37 - over here and then since i want to have
513:40 - more clarity on which one is which i'll
513:43 - right away give it an alias of
513:45 - job id like so so now we have both we
513:49 - have the job id from the params
513:52 - so this one is coming
513:53 - from here and then since we have the
513:56 - access token now of course we can also
513:58 - access the id of anna
514:01 - and then it's simply a logic of
514:04 - finding that one job
514:06 - where the id is the job id as well as
514:09 - created by is equal to the user id and
514:12 - if the job doesn't exist
514:14 - then we'll throw this error because
514:16 - remember
514:17 - we have two types of error either we'll
514:19 - get a casting error where the syntax
514:22 - doesn't match to that of the mongoose
514:25 - object id
514:26 - or
514:27 - simply we just pass in some kind of
514:30 - wrong job id and then of course if
514:32 - everything is correct then we send back
514:34 - the job so let's try it out we're going
514:36 - to be looking for the job and that will
514:38 - be equal to a weight of course
514:41 - then we go with our model name and then
514:43 - we go with find one that's the method
514:45 - name and then in here in the filter
514:48 - object we pass in underscore id which is
514:51 - equal to our job id first now of course
514:54 - in here the order is not important
514:56 - but we do want to check for both
514:58 - otherwise somebody can just get the id
515:01 - and then they can access the job so
515:03 - let's go to created by
515:06 - and we'll set it equal to our user id
515:09 - and then like i said we have two options
515:11 - for errors either we have a casting
515:13 - error which will handle a little bit
515:15 - later as far as the nice responses or we
515:18 - simply have a case where we provided
515:21 - some wrong id and we'll simply check
515:23 - that by saying if there is no job then
515:27 - we'll throw our new error and of course
515:29 - we're looking for not found one
515:32 - and then we'll pass in the actual text
515:35 - with the job id so let's say no
515:38 - job with id and since i'm using template
515:41 - string i can right away access it and
515:43 - i'm going to be looking for my job id
515:45 - now if everything is correct then of
515:47 - course we'll get back the entire job so
515:50 - say here res dot status which we're
515:53 - looking for are status codes then we'll
515:56 - go with okay and then we'll go with json
515:59 - and i'll send back the job now of course
516:01 - we can just test it out in our postman
516:04 - where instead of this get single job i
516:06 - should get the job that matches that id
516:09 - in this case i'm getting the google one
516:11 - so now let me double check where i have
516:13 - all the jobs
516:15 - and i'm gonna be looking for well these
516:18 - ones technically are both the same so
516:20 - let me look for the apple one
516:22 - and i'll grab the id that's the job id
516:25 - again keep that in mind that is very
516:27 - very important we're not looking for the
516:30 - user id
516:31 - and once i send of course i should get
516:33 - back the apple and if you get the same
516:35 - results then of course we can move on to
516:38 - our next step awesome and up next we
516:40 - have update job and essentially i can
516:44 - tell you right away that a lot of the
516:46 - stuff that we already wrote in get job
516:49 - will repeat over here so therefore in
516:51 - order to speed this up a little bit of
516:53 - course i will do some copy and pasting
516:55 - here as well
516:57 - and in order to test it out
516:59 - i'm just going to navigate again back to
517:01 - the postman this is where i'll start
517:03 - i'll save this one first the single job
517:06 - one so get
517:07 - single
517:09 - job
517:10 - single job
517:11 - and then let's create one for patch
517:14 - meaning one for update but of course the
517:16 - method will be patch
517:18 - and i'll leave get all jobs since i want
517:20 - to keep using those ids of course
517:23 - and i think i can close the login one
517:25 - for now because we already have logged
517:27 - in as anna
517:28 - and then let's look for the patch method
517:31 - and ascended i'm messing up the get
517:33 - single job my apologies so let me open
517:35 - up the new one
517:37 - and i'm gonna go with patch we're
517:38 - looking for the url one
517:40 - and again we'll be looking for the jobs
517:44 - and then we wanna go with that route
517:47 - parameter
517:48 - and of course this is going to be that
517:50 - job id so let me get all the jobs and
517:53 - you know what i'll work with that last
517:55 - one since we have repeating values so
517:58 - let me grab here this id
518:00 - and then pass it here
518:02 - and remember authorization we go with
518:05 - better token and we have access token
518:07 - and if i send and if i get update job
518:10 - then of course we know that we can start
518:12 - setting up the functionality and as far
518:15 - as the logic
518:16 - like i already said
518:18 - i mean most of it is going to be exactly
518:20 - the same the difference of course is the
518:22 - mongoose method we're going to use and
518:24 - the fact that i'll check for both i'll
518:27 - check for company as well as the
518:30 - position and i'll check whether they are
518:32 - not empty and you'll see what i mean in
518:34 - a second so where i have the update job
518:37 - let's just start working and first
518:39 - same deal i'm going to be looking for
518:41 - the user as well as the params so that
518:44 - won't change because remember in the
518:46 - routes i mean all of them are looking
518:49 - for that route parameter correct so
518:52 - let's take this one
518:53 - there's really no point to repeat
518:56 - ourselves in this case so let's copy and
518:58 - paste however the difference is that
519:00 - in this case since we're updating also
519:03 - in the body we'll provide some info and
519:06 - in my case i'm going to be looking for
519:07 - both
519:08 - i want to get the company as well as the
519:10 - position so let's go here with raw and
519:14 - we'll go with json here and if you want
519:16 - to speed this up you can actually go to
519:18 - create job and just take these values so
519:21 - that's going to be our patch one copy
519:23 - and paste
519:24 - and we just need to remember to add the
519:26 - curlies here
519:28 - and as far as the values well let's come
519:30 - up with some kind of company and i'll
519:32 - call this random and then it's not going
519:35 - to be a backend developer so it's going
519:37 - to be a full stack
519:39 - and then
519:40 - back in my controller we also want to
519:43 - add it over here so i'm still the
519:46 - structuring the request object correct
519:49 - and in there i have params i have the
519:51 - user now as well as the body because
519:54 - remember in here we're sending that in
519:56 - the body so let's go back and let's say
519:59 - body and in the body we'll be looking
520:01 - for
520:02 - company
520:04 - company
520:05 - and position
520:07 - don't forget to add the comma and right
520:09 - after we structure everything
520:11 - i also want to check whether the company
520:14 - or the position
520:16 - is empty and if that's the case i want
520:18 - to send back the bad request so say here
520:21 - company
520:22 - is equal to an empty string or position
520:26 - is equal to an empty string and if that
520:28 - is the case i'm going to go with throw
520:31 - new and we're looking for
520:33 - bad request of course
520:35 - so bad request error and we'll say
520:37 - company
520:39 - or
520:41 - position
520:43 - fields cannot
520:45 - be empty let's save it here and then of
520:49 - course we want to use our find one and
520:52 - update
520:53 - and remember we need to basically pass
520:55 - in three things we want to pass in what
520:57 - we want to update
520:59 - we want to pass in which job we're
521:01 - looking for and then of course we also
521:04 - have options where i want to get back
521:06 - the updated version as well as i want to
521:09 - run the validators so let's do that
521:12 - however there is a tiny bug over here
521:15 - and essentially i'll come back to this
521:16 - one why i prefer setting up the check in
521:20 - the controller once we start talking
521:21 - about the mongoose errors and let's just
521:25 - go with cons job
521:27 - and we'll set it equal to a weight
521:29 - then job of course that's the model
521:32 - find one and update
521:34 - and then like i said first we want to
521:36 - pass in well which job are we going to
521:40 - update and the setup is going to be
521:42 - exactly the same
521:43 - where i want to look for underscore id
521:45 - as well as who created it so let's go
521:48 - here let's say
521:50 - underscore id is equal to my job id of
521:52 - course
521:53 - job id then we want to pass in the comma
521:56 - and we'll go with created
521:58 - and then buy now that is equal to my
522:01 - user id
522:02 - and then of course we want to pass in
522:04 - what we want to update so let's just go
522:06 - here with the rack
522:08 - and body and then we want to pass in the
522:10 - options
522:11 - and i'm going to go with new true so
522:13 - we'll be getting back that updated job
522:16 - and then i also want to right away run
522:18 - my validators and of course the property
522:21 - for that is run
522:23 - validators and we'll set it equal to
522:25 - true now if the job doesn't exist we
522:28 - already know what we can do we can
522:30 - simply throw a not found there and if
522:33 - everything is correct and of course we
522:35 - return the job so let's scroll down copy
522:38 - and paste
522:39 - and our functionality should be working
522:42 - where if everything is correct i'll get
522:45 - back the updated job if not then of
522:47 - course i'll get back the error so let's
522:49 - test it out right now in the postman so
522:52 - i'm going to go with full stack
522:53 - developer and you know before we send
522:56 - the correct request
522:58 - why don't we remove that last value in
523:01 - the id let's send it here and now of
523:03 - course we're getting back that massive
523:05 - mongoose error that we'll work on a
523:07 - little bit later and then if i just
523:09 - change it around to four then of course
523:11 - i'll get back no job with id such and
523:14 - such so let me change it back to three i
523:16 - think that was the correct one and now
523:18 - once i send now of course i am the
523:21 - company and the position is full stack
523:24 - developer and with this in place we only
523:27 - need to worry about remove job
523:29 - functionality beautiful so now let's
523:32 - just set up remove jump functionality
523:34 - and i guess let's start by saving our
523:37 - request in the postman
523:39 - so again we go with save as or just
523:42 - control or i believe command s
523:45 - and then let's just write up the job
523:49 - update job
523:51 - and of course we want to set up the same
523:53 - thing for delete job
523:55 - and let's just start everything from
523:57 - scratch again we have a new request
523:59 - we're going to go with delete
524:02 - and then the url is going to be our
524:04 - global variable then forward slash jobs
524:07 - and now back in get all jobs why don't
524:11 - we remove that random one so if i go
524:13 - with get all jobs i can clearly see that
524:16 - i'm getting back the random job that's
524:18 - the one that we just updated so why
524:20 - don't we remove this one so again i'm
524:22 - looking for underscore id i'll right
524:25 - away set it up as my route param and as
524:28 - far as the logic well we're not going to
524:30 - be setting up anything in the body we
524:32 - really don't need to what we're looking
524:34 - for of course is the authorization again
524:37 - want to go with pair token access token
524:39 - awesome let's send we should get back
524:43 - delete job and as far as the
524:44 - functionality again we're going to be
524:46 - looking for user and params both of them
524:50 - are located in the request correct so
524:53 - one is coming from auth middleware and
524:55 - the second one is coming from the params
524:58 - again i know this is a repetition but
525:00 - it's very very important that we
525:01 - understand that
525:02 - then let's copy and paste so we have
525:04 - access to both of these ones
525:06 - then as far as the method name we're
525:08 - looking for
525:09 - find one and remove so let's go here
525:12 - with const
525:14 - and we'll set it equal to job
525:16 - and we'll set it to a weight
525:19 - and of course like i said job
525:21 - and then find one
525:23 - and remove that's one we're looking for
525:26 - and as far as the filter object let's
525:28 - just go again with underscore id
525:31 - and then job id of course
525:33 - and the same goes for the user id
525:36 - created that or sorry created by
525:39 - and then we set it up as user id and the
525:43 - same deal if the job doesn't exist then
525:46 - we send back the error and if everything
525:49 - went smoothly then we simply want to
525:51 - send back 200 that's all we have to do
525:54 - and i'll do that by cheating a little
525:55 - bit where i'll take this code from the
525:58 - update one and just copy and paste so
526:01 - we're throwing the error if there is no
526:03 - job or if everything is successful we
526:06 - don't need to actually send back the
526:07 - json again that's really going to depend
526:10 - on your front end but in my case
526:12 - i'm just looking for that 200 so if
526:15 - there's some kind of error then of
526:16 - course i have one functionality on my
526:18 - front end however if everything went
526:20 - smoothly if i remove the job then of
526:23 - course i'm just getting back that 200
526:25 - that's it so now of course let's test it
526:27 - out in our postman where we have the job
526:30 - we want to remove it let's send it here
526:32 - as you can see i'm not getting anything
526:34 - back but i have 200 which is always a
526:37 - good sign so now of course let's go to
526:40 - get all jobs or you know what let's save
526:42 - this one first let's say save as and say
526:45 - remove or delete job it's really up to
526:48 - you
526:48 - delete job
526:50 - save it and then when it comes to get
526:52 - all jobs of course i can send it and
526:56 - count is back to three when it comes to
526:59 - anna and with this in place let's just
527:01 - quickly try out to log in as peter so we
527:05 - just simply want to change the name here
527:07 - i'm going to go with peter the password
527:09 - is still the same and of course i just
527:11 - need to be correct with my email i send
527:14 - it yep i get the token and now let's
527:16 - take a look at all the jobs that peter
527:18 - has
527:19 - and of course it's only one so now let
527:22 - me grab this id
527:24 - and first i'll change it so first we'll
527:27 - go with update
527:28 - and as far as the body i'll just pass in
527:33 - random and when it comes to your
527:35 - position i'm gonna go back to the
527:37 - internal one
527:38 - in turn here so let's send it that's the
527:41 - response i have company random and of
527:44 - course i want to also see whether i can
527:46 - delete it so when it comes to delete job
527:49 - i'll take the same id
527:51 - i'll go back here
527:53 - i'll copy and paste and once we run get
527:56 - all jobs for the peter now so let's go
527:58 - back to all the jobs and once we run it
528:01 - now of course we have jobs this empty
528:03 - array and count is zero but keep in mind
528:06 - this is still a successful response it's
528:09 - just peter hasn't created any jobs or
528:12 - in our case we created it and then of
528:14 - course we removed it and with this in
528:17 - place we're done setting up the core
528:19 - functionality for our application
528:22 - beautiful and before we worry about
528:24 - deployment let's make our mongoose error
528:27 - responses more user-friendly and before
528:30 - we start let me just say that
528:32 - just like our error classes we will only
528:35 - do this once
528:36 - and after that we'll bring it from
528:38 - project project so if at some point you
528:41 - get bored just remember we only need to
528:44 - do that in this project and then for
528:46 - remaining projects of course we'll just
528:48 - reuse the code and the idea is following
528:51 - where currently we have three mongoose
528:53 - errors we have validation one remember
528:56 - that is if the user doesn't provide one
528:59 - of the values then we have the duplicate
529:01 - issue where email is unique and of
529:03 - course we also have the cast error and
529:06 - if you remember that's when the id
529:07 - syntax doesn't match exactly to what the
529:11 - mongoose is looking for
529:13 - we want to go to the middleware and more
529:15 - specifically we want to go to the error
529:17 - handler and of course at the moment
529:20 - i'm logging the error and in here i'm
529:23 - just sending back this generic response
529:26 - so internal server error and i'm just
529:28 - passing in the object and if i take a
529:31 - look at the postman
529:33 - i'm going to be looking for register
529:34 - route and then if i have already a user
529:38 - in this example susan so if i already
529:41 - have that email and if i try to register
529:44 - one more time of course i'm going to get
529:46 - that duplicate error correct because i
529:49 - already have the email in the system and
529:52 - essentially the goal is following where
529:54 - we want to send back more user-friendly
529:57 - response and also we want to change the
530:00 - status code because at the moment we're
530:01 - just sending 500 but of course this is
530:04 - 400 this is bad request
530:07 - and the way we do that we navigate back
530:09 - to error handler material and we'll
530:12 - start by creating a object a custom
530:16 - error object and the reason we'll do
530:18 - that because we'll set up multiple if
530:21 - statements now technically you can also
530:24 - manipulate this code and i'll show you
530:27 - in a second why and how but in my case
530:30 - i'll just leave it the way it is so if
530:33 - our error is our custom one basically if
530:36 - it's one of the classes then we'll just
530:38 - right away send back the response if not
530:40 - there's going to be a new custom error
530:44 - object and then as far as the response
530:47 - we'll send back that object instead so
530:50 - let's start working on that and
530:52 - essentially we want to go with some kind
530:54 - of variable in my case i'm going to go
530:55 - with let
530:56 - just so i know that i'm going to be
530:58 - manipulating those values and i'll say
531:00 - custom error and that one is equal to
531:04 - status code and the message so here i
531:07 - want to set up two properties and
531:09 - basically we want to set defaults so the
531:11 - same idea if there's already something
531:13 - provided then of course we'll send back
531:15 - that
531:16 - if not then there's going to be some
531:18 - kind of default and effectively it's
531:20 - going to look something like this where
531:21 - we'll go with the property name so
531:23 - status code and this will be equal to
531:27 - error
531:28 - and then the status code and eventually
531:30 - there's going to be multiple if
531:32 - statements
531:33 - that will manipulate this value so in
531:35 - here i'm just setting up the defaults i
531:37 - say hey listen
531:39 - if in the error i already have the
531:41 - status code
531:42 - then use that if not well then let's set
531:45 - up the generic response let's say status
531:47 - codes and we're looking for internal
531:50 - server error
531:52 - and that of course is going to be 500
531:54 - and let's do the same thing with the
531:56 - message so message property and error
531:59 - and let's just say here message
532:01 - and let's go with two vertical bars
532:04 - and we'll say something
532:06 - something went wrong
532:08 - and let's say try again
532:12 - again later and now of course what we
532:14 - want to do is change this code around
532:17 - where instead of sending this internal
532:19 - server error and json and error of
532:21 - course we'll use these values instead
532:24 - now i will still leave this code meaning
532:27 - i'll just comment this out so copy and
532:29 - paste and comment down just because i'll
532:31 - be sending those error object back to
532:33 - the postman because i find it easier
532:36 - than logging in here and chasing it
532:39 - around the terminal again that is just
532:41 - my preference
532:42 - and essentially what we want to change
532:44 - over here
532:45 - is the error
532:47 - now of course we're looking for
532:48 - custom error and then we want to go with
532:51 - status code and then as far as the json
532:54 - well the same thing we're going to go
532:56 - with message and we'll set it equal to
532:58 - our customer dot and of course we're
533:01 - looking for the message
533:03 - and you'll notice that at the moment
533:05 - there's really no difference so if i go
533:07 - back and again
533:08 - try to register susan
533:11 - even though the email is already news i
533:14 - see this one i see over here a message
533:16 - and this is going to be that mongoose
533:18 - one and of course i still have this 500.
533:22 - so technically
533:24 - nothing changed now of course this is
533:26 - where we'll work on right now where
533:28 - after our custom api instance we'll go
533:32 - here if
533:33 - and essentially if you want to check
533:35 - we'll have to take a look at the object
533:36 - one more time so this is why i'll keep
533:38 - both of these responses because
533:40 - it is hard to find that error over here
533:43 - and essentially i'll be sending back the
533:45 - object just so you can see what is
533:47 - happening and i think for time being
533:49 - i'll get the error so
533:50 - let me just save it here
533:52 - let's send one more time and what you'll
533:55 - notice that of course if we have that
533:57 - duplicate issue this is the error that
534:00 - we're getting back
534:01 - and effectively what we want to do we
534:03 - want to check
534:04 - if the error code exists and the code is
534:09 - equal to this 11 and then three zeros
534:12 - then we want to send back this value
534:14 - this email one so then we want to access
534:17 - this key value and then just come up
534:19 - with some kind of message so it's going
534:21 - to look something like this where we're
534:23 - going to go with if
534:25 - then like i said we're checking for
534:27 - error code and keep in mind that i'm not
534:30 - talking about custom error here
534:32 - i'm saying yeah there is a error object
534:35 - and now i want to check whether it has
534:37 - the code property and if it has then i
534:39 - want to check more specifically if the
534:42 - value is equal to 11 and then three
534:45 - zeros so go over here like this and then
534:48 - if that is the case then i know that i
534:50 - can access of course this key value
534:53 - property and i just need to come up with
534:55 - some kind of message now what we'll do
534:57 - over here like i said we'll modify
535:00 - these values over here so in here we
535:02 - just set up the defaults if the error is
535:04 - not going to match any of our conditions
535:06 - then either we'll use the actual error
535:09 - status code if it exists
535:11 - as well as the message if not then of
535:13 - course we'll have these defaults
535:15 - hopefully that is clear
535:16 - and let's just start by setting up the
535:18 - message now how we can do that well we
535:20 - can go with custom error so that's our
535:23 - object and essentially we're overriding
535:25 - the message correct i'm just saying the
535:28 - message value will be equal and in this
535:30 - case i'm gonna use the template literals
535:34 - because i'll pass in the actual arrow
535:37 - key value and as far as text i'm just
535:39 - gonna say duplicate value
535:41 - and third
535:42 - four and now let's access the value
535:45 - let's say error and again remember we're
535:48 - looking for this property over here
535:50 - correct so say here error and we're
535:53 - looking for key value and then we just
535:56 - want to continue with the text so field
535:58 - please choose
536:01 - another value
536:03 - another value
536:05 - and of course i also want to change the
536:07 - status code so in this case i'll go with
536:09 - custom error
536:10 - and i'm looking for status code property
536:13 - and i'll set it equal to 400 because
536:15 - this is a bad request
536:17 - and since we can clearly see the error
536:20 - object
536:21 - since we already have all of the code
536:23 - that we need again i'm just going to hop
536:25 - around here and i'll comment this one
536:28 - out because i will use this one in a
536:30 - later videos and then we'll go back to
536:32 - this custom one and once we set
536:34 - everything up now of course we can
536:36 - navigate here we can send and of course
536:38 - this is the response so now we have the
536:40 - message we have duplicate value entered
536:42 - for object object and we'll work on this
536:45 - one a little bit later and what's really
536:47 - cool that of course now we have 400 so
536:50 - we can clearly see that it is a bad
536:52 - request
536:53 - now if we don't want to send this object
536:55 - object which of course is not that
536:57 - helpful we'll simply need to use a
536:59 - little bit of javascript but of course
537:01 - we have the object so our key value is
537:05 - an object and in javascript we have
537:07 - object dot and of course in our case
537:10 - we're looking for keys so this will give
537:12 - us a array of keys and of course in this
537:15 - case we'll only have the email so it's
537:18 - going to look something like this where
537:19 - we go with object keys and then we'll
537:22 - pass in our error and key value and as a
537:25 - result we'll get back array of the keys
537:28 - so let's send one more time let's go
537:31 - back over here and now of course we'll
537:32 - have duplicate value
537:34 - for the email field please choose
537:36 - another value and with this in place now
537:39 - we're handling the
537:40 - duplicate error and essentially we're
537:43 - sending back
537:44 - more friendly user response
537:47 - awesome and once we check for duplicate
537:50 - value now let's quickly talk about our
537:53 - custom api ones so our classes
537:57 - and we can actually remove this if
537:59 - statement right now because remember in
538:01 - the custom error we are checking for the
538:04 - status code so if that property is on
538:08 - the object then beautiful we set our
538:10 - status code value and the same goes for
538:13 - a message
538:14 - and in order to showcase that i'm just
538:16 - going to remove this if statement for
538:18 - time being i'll just comment it out just
538:20 - so i can always put it back if i'm wrong
538:23 - and then as far as the route well let's
538:26 - take a look at our auth chairs
538:28 - and i believe we're using it in a login
538:30 - correct we have our bad request error so
538:34 - let's try it out
538:35 - now of course i'm going to go to login
538:37 - user and i'll try to get the token for
538:41 - susan without providing the password so
538:44 - let me remove it let me send it over
538:46 - here and now of course i still have
538:48 - please provide email and password and of
538:51 - course the error code the status code is
538:54 - also good it is 400 which simply means
538:57 - that of course our logic works because
538:59 - again we have this custom error one and
539:02 - essentially we're looking for a status
539:04 - code property on the error object that's
539:06 - coming in because remember in here of
539:09 - course we're setting up a new one and
539:11 - the same goes for a message so you can
539:13 - simply remove this code now i'll leave
539:16 - this one for your reference just in case
539:18 - you want to use it but effectively we
539:21 - don't need to use this anymore and of
539:23 - course with our new setup we don't need
539:26 - to import the custom api our class as
539:29 - well so you can remove it and the code
539:32 - will still work not bad not bad in our
539:35 - current setup we're nicely handling
539:37 - duplicate values
539:39 - as well as our own custom errors so now
539:42 - of course we want to deal with those
539:44 - validation errors which of course is the
539:47 - case for example in the auth
539:50 - when i'm registering the user and i'm
539:52 - right away passing in direct.body so i'm
539:55 - not checking for email or password or
539:59 - name over here i simply let the mongoose
540:02 - handle that and the way we do that is
540:05 - pretty similar to what we have over here
540:08 - we simply want to set up the if
540:10 - statement again we'll have some kind of
540:12 - condition in this case we're going to be
540:13 - looking for
540:14 - validation error and if that is the case
540:17 - again we'll use one of the nifty
540:20 - javascript methods
540:21 - in this case we're not going to be
540:23 - looking for keys we'll be looking for
540:25 - the values and of course we'll send back
540:28 - the nice response and in order to test
540:30 - it out let's just go back again to our
540:32 - postman now i'm not going to do that in
540:34 - login because again in here we have our
540:37 - custom one the bad request one what i
540:39 - want to do is go back to the register
540:41 - user
540:42 - and here i want to remove both the email
540:45 - and the password and yes i'm purposely
540:48 - removing both
540:49 - just so you can clearly see our
540:51 - functionality in action and once we do
540:53 - that once we send i mean we can still
540:56 - see 500
540:57 - so that just means internal server error
541:00 - but the message is already more
541:02 - user-friendly correct we already have
541:04 - user validation failed password and blah
541:07 - blah blah so let me show you the entire
541:09 - object just so you can understand the
541:11 - functionality we're about to set up
541:13 - better and technically i don't even need
541:16 - to comment this one out because if i
541:18 - have my first return of course this is
541:21 - what we'll send back so let me go back
541:22 - to the postman send it one more time and
541:25 - of course this is going to be that
541:27 - giant object that we're getting back and
541:30 - the structure is following where we have
541:32 - this errors object and of course in here
541:35 - we'll have all the values that are
541:38 - missing so of course in our case that is
541:40 - password and the email and this is very
541:43 - very important because of course if you
541:45 - have only one
541:46 - then technically you don't need to worry
541:49 - about multiple keys but that's not our
541:51 - scenario so in our case we do need to
541:54 - worry about multiple keys in that object
541:57 - because
541:57 - maybe the password email and name might
542:00 - be missing and also in that object in
542:03 - the error object not only we have errors
542:05 - we also have the name
542:07 - and essentially in our if block we just
542:10 - want to check whether it is a validation
542:13 - error so let's go back
542:15 - and
542:16 - i'm going to do that above the duplicate
542:18 - one but of course the position doesn't
542:20 - really matter where i'll say error name
542:23 - if it is equal
542:24 - to the validation error so let's go over
542:26 - here with validation error and if you
542:29 - need to copy and paste just so you don't
542:32 - make some silly typos so essentially if
542:34 - you're like me then of course you can do
542:36 - that so let's copy and paste and if that
542:39 - is the case
542:40 - then what i want to do is get
542:43 - all the values
542:45 - for the keys in the errors object so
542:48 - notice
542:49 - of course i have the password correct of
542:52 - course i have the email and what we want
542:54 - to do grab this errors one and just get
542:58 - the actual values
543:00 - of these objects because errors is an
543:02 - object itself then password and email
543:06 - are object so i'm looking for the actual
543:09 - values in there and you'll see what i
543:11 - mean in a second so i have if error name
543:14 - is equal to validation error then let's
543:16 - just go with custom
543:18 - error and we're going to be looking for
543:20 - the message and like i said we're going
543:22 - to go with object and values and then
543:24 - we'll pass in the error
543:27 - and errors
543:28 - so in the error object of course there
543:30 - is errors object and in there i have two
543:34 - more keys we have password and email and
543:37 - i want to turn them into array and then
543:40 - i want to iterate over using map so
543:42 - since we're getting back the area of
543:43 - course i can use my map method and i'm
543:46 - just going to call this item so each and
543:48 - every item i'll call the item and then
543:50 - i'll say item.message so in here you'll
543:53 - notice that of course
543:55 - in there in that values i have a message
543:58 - property correct and then i want to
544:01 - access it and send it back so let's say
544:04 - here item
544:05 - dot
544:07 - message
544:08 - and then we'll just join it back to the
544:09 - string and we'll add a comma so that's
544:12 - going to be our message now as far as
544:14 - the status code again 400 so let's go
544:16 - over here with custom error and we're
544:19 - looking for status code and that will be
544:22 - equal to 400 so once we save and once we
544:26 - send it back now of course we should get
544:29 - a better response but of course we don't
544:31 - because i mean i left my first response
544:34 - in there as well so let me comment this
544:36 - sucker out and then send it here and now
544:39 - of course i have please provide password
544:41 - please provide email which effectively
544:44 - is way more user friendly than the
544:46 - object that we're sending back and also
544:48 - notice the status code of course now
544:50 - we're sending back 400 and if you're
544:53 - confused about the code just go back to
544:56 - the error handler and just log what
544:58 - you're getting back from object that
545:00 - values and it will make total sense so
545:03 - essentially the map and join will make
545:06 - total sense so let's try it over here
545:08 - we'll go with console.log and then we're
545:10 - looking for
545:11 - object dot values and then here we want
545:14 - to pass in error so the error object and
545:16 - then more specifically the errors object
545:20 - so let's save it and back in postman we
545:23 - want to send it of course response
545:25 - doesn't change but in my terminal i can
545:27 - clearly see that what i'm getting back
545:29 - from
545:30 - object.values
545:32 - is array of objects and then i'm
545:35 - iterating over that array and then more
545:38 - specifically in each object i'm
545:41 - accessing the message and then i just
545:43 - join all of them together so i set it
545:46 - back to the string and then i just add
545:48 - comma e in between and once we have all
545:51 - of this in place
545:52 - now of course we can worry about our
545:54 - third instance and that's going to be
545:56 - the cast error
545:58 - and as far as the cast error of course
546:01 - in the auth
546:03 - we're not going to get it because we're
546:05 - not using the ids but
546:07 - in the jobs we should get it
546:09 - so back in where i have the jobs
546:12 - controller
546:13 - if we take a look at i don't know get
546:16 - single job of course i'm passing in the
546:19 - job id that is coming from params
546:21 - correct and here
546:23 - if i cannot find the job
546:25 - that has the job id with the user id of
546:28 - course i send back the not found error
546:30 - however there also might be a case where
546:33 - the syntax doesn't match to whatever the
546:36 - database is looking for and of course in
546:38 - order to showcase that let me just go to
546:40 - get all the jobs so this is going to get
546:43 - me all the jobs that susan has and as a
546:46 - side note
546:48 - i think i logged out so let me log in
546:50 - back as susan
546:52 - so let's say over here password
546:55 - and in my case while i'm testing and
546:57 - pretty much setting everything up as
547:00 - secret so let's send it here yep we have
547:03 - the tokens so let me now send get all
547:05 - jobs okay awesome i'm getting the jobs
547:08 - and now of course whether that's for get
547:10 - single job update job or deletion i will
547:13 - have to provide that id and if i'll just
547:16 - mess up the values that's one thing then
547:18 - we'll get that 404
547:20 - but we also might have that cast error
547:23 - so let's go to i don't know get single
547:25 - job
547:26 - copy and paste the correct id send here
547:29 - okay we should get back the correct
547:32 - response but if i'm going to start
547:34 - adding the values who are removing
547:36 - we should see the
547:38 - casting error now again in our case we
547:40 - just see the string
547:42 - so let me scroll down i know it's a
547:44 - little bit annoying but it's important
547:46 - for me to showcase those big objects
547:48 - just so i can see where we're getting
547:50 - the values from and once i send it of
547:52 - course now i have error and the name is
547:55 - equal to cast error and now we just want
547:58 - to swing back to our error handler and
548:00 - essentially set up the if condition
548:03 - where i'm going to be checking for
548:04 - cast error if that is the case then of
548:07 - course i'll just send back some kind of
548:09 - string
548:10 - with 404 so again that's going to be not
548:12 - found one and i'll just provide the
548:15 - value just so user can understand what's
548:18 - happening so let's go back over here
548:20 - let's say if and i'll just say error
548:23 - name
548:24 - and if it is equal to a cast error and
548:27 - if that is the case i want to go with my
548:30 - custom error then the property name is
548:32 - message and actually i want to set it up
548:35 - as template string so no item found
548:38 - with id
548:40 - and then we're going to be going for
548:41 - error and of course i'm looking for the
548:44 - value one
548:45 - so in the our object there's a valid
548:47 - property and i'm looking for this id so
548:50 - let's say here error
548:52 - value
548:53 - and then the next thing is that status
548:55 - code and in this case we want to go with
548:57 - custom error
548:59 - so custom error here and status code and
549:02 - that is going to be equal to 404 or not
549:05 - found now of course
549:07 - if you want to use the status quo here
549:09 - as well
549:10 - please definitely do so i just thought
549:12 - that it's important for me the first
549:14 - time to show you the actual number
549:17 - status code and then if you want you can
549:19 - use the library instead so let me send
549:22 - it here
549:22 - and of course i should get back the
549:24 - proper response but problem is that i'm
549:27 - still sending back the first one so now
549:29 - let me remove it since we're not going
549:31 - to use it let's save it and then once we
549:34 - send now we have no item found with id
549:37 - and we have the 404 and with this in
549:40 - place of course we can move on to the
549:42 - next topic all right so for all our apps
549:45 - were nice and cute since we only use
549:48 - them in local setup but with this
549:50 - project things are about to get
549:52 - interesting you see this app will
549:55 - actually host on heroku basically
549:57 - deployed on the cloud and what that
549:59 - means that we also need to think about
550:01 - security essentially how we can protect
550:04 - our api from some bad actors
550:07 - and the good news is that with the help
550:09 - of community so think npm and more
550:12 - specifically npm packages we really
550:15 - don't need to do that much just install
550:17 - some packages and add them as middleware
550:20 - in our app and we're good to go yes it
550:23 - is that simple
550:24 - now is our app going to be safe from any
550:27 - possible attack well no most likely not
550:30 - remember our biggest security soft spot
550:32 - is still our user
550:34 - yes of course we should be protecting
550:36 - our api but how are you going to stop
550:38 - the user from storing a token in a
550:41 - unsecure manner there's really no
550:43 - package for that
550:45 - and as far as the packages we're going
550:46 - to use well first we're going to use
550:49 - helmet arguably the most popular
550:51 - security package out there which sets
550:54 - various http headers to prevent numerous
550:57 - possible attacks in fact helmet is so
551:00 - popular it's actually used in many other
551:02 - packages as a dependency after that we
551:05 - want to implement coors library which
551:07 - just ensures
551:08 - that our api
551:10 - is accessible from different domain if
551:13 - you don't have cores installed you'll
551:15 - only be able to access the data from the
551:17 - same domain if you remember in the
551:19 - previous project we did that in
551:21 - javascript file located in the public
551:24 - folder and if you try to access our
551:27 - previous apis from any other frontend
551:30 - apps you'll get a course error now coors
551:33 - stands for cross origin resource sharing
551:37 - and it is a mechanism to allow or
551:40 - restrict requested resources on a web
551:43 - server depending on where the http
551:46 - request was initiated
551:49 - by installing and implementing the
551:50 - course package essentially we make our
551:53 - api accessible to the public after that
551:56 - we want to use xss clean library which
552:00 - sanitizes the user input in reg.body
552:03 - reg.query and reg.params and as a result
552:07 - protects us from cross-site scripting
552:10 - attacks where the attacker tries to
552:12 - inject some malicious code and lastly we
552:15 - want to limit the amount of requests the
552:17 - user can make
552:18 - and we'll do that with the help of
552:20 - express rate limit library if you're
552:22 - using the star all libraries already
552:25 - installed and ready to go but if you
552:28 - want to use it for your own project of
552:30 - course just install them by running npm
552:32 - install and then name of library and
552:35 - also if you want to get more info on any
552:37 - of them
552:38 - a library docs is a very good place to
552:41 - start in later projects we might use
552:44 - some additional libraries or config
552:46 - options but in general as far as the
552:48 - standard security this setup is a very
552:52 - good place to start
552:53 - all right and once we have covered
552:55 - general info about the security packages
552:58 - now we simply want to go to app.js we
553:00 - want to import them one by one
553:03 - and of course we just want to invoke
553:05 - them and in my case i'm going to do it
553:06 - over here where we have
553:09 - express.json and i'm going to start by
553:11 - providing comment extra
553:13 - and let's say
553:14 - security packages
553:17 - and then we're looking for helmet first
553:19 - and we'll set it of course equal to the
553:21 - package
553:22 - helmet then the same for cores so this
553:26 - is the course package and we have one
553:28 - for cross-site scripting so require
553:32 - and the package name here is xss clean
553:36 - and last one is express rate limit and
553:39 - i'm purposely setting this one up last
553:41 - just because there's going to be a
553:42 - little bit of configuration there as
553:44 - well so let's go with require and
553:47 - express rate limit
553:49 - then let's save keep scrolling where we
553:51 - have the json let's start with our
553:54 - helmet so app.use
553:56 - and like i said we just invoke the
553:58 - helmet the same for rest of them so i'm
554:02 - that use and of course in here i'm
554:04 - looking for cores
554:05 - i can just copy and paste
554:07 - then i want to go for cross-site
554:10 - scripting one so xss and again we invoke
554:14 - it and then we add limit1 so again
554:17 - app.use
554:18 - then rate limit and you know what i
554:21 - think i'm going to change the name here
554:23 - i'm going to go with rate limiter not a
554:26 - big deal
554:27 - but just my preference and if we take a
554:30 - look at the package docs
554:32 - effectively what we want to set up
554:34 - is the time
554:36 - so in how long and how many requests and
554:40 - as you can see here they provide an
554:42 - object and properties are
554:45 - window milliseconds so effectively we
554:48 - get this in milliseconds and we just set
554:50 - up time and as you can see this is
554:52 - example for 15 minutes
554:54 - and then how many requests
554:56 - and also if you keep on scrolling you'll
554:58 - notice their responses
555:01 - so by default the message is going to be
555:03 - too many requests
555:04 - and the error response is going to be
555:06 - 429. and once we're clear on setup let's
555:09 - implement it in our own app
555:12 - so first what i want to do is move this
555:14 - rate limiter up so i want to set it up
555:17 - as our first middleware
555:19 - and then in order to speed this up we'll
555:21 - just grab the object here
555:23 - with those milliseconds as well as the
555:26 - max request
555:27 - we'll invoke it here copy and paste
555:31 - and our limiter is in place
555:33 - lastly according to their docs if our
555:36 - application is behind reverse proxy
555:38 - which is going to be our case since
555:40 - we'll push this up to heroku
555:43 - we also want to implement this app.set
555:46 - trust proxy so let's just take this
555:48 - code and place it before the rate
555:51 - limiter and with this in place
555:54 - we have our security packages so now we
555:56 - can move on to our next step just a
555:58 - friendly reminder that we're about to
556:00 - host our project on heroku
556:02 - and if in the mongodb
556:05 - you are using local ip address option
556:08 - you'll need to switch to allow access
556:10 - from anywhere one otherwise mongodb will
556:14 - throw an error
556:15 - and your app won't work
556:17 - awesome and once we have the basic
556:19 - security in place let's complete this
556:21 - project by deploying it on a cloud so we
556:24 - can start utilizing our api from any
556:27 - front-end setup and while there are many
556:29 - hosting providers out there during this
556:32 - course we'll use the following two
556:34 - heroku and digitalocean they both have
556:37 - their pros and cons so just like in most
556:39 - cases at the end of the day everything
556:41 - depends on your own preference
556:43 - and for this project we'll use heroku
556:46 - and since it offers generous free tier
556:49 - in order to follow along you'll only
556:50 - need three things
556:52 - an existing heroku account and of course
556:54 - the sign up is free so just navigate to
556:56 - heroku.com and look for signup option
557:00 - second since heroku utilizes git version
557:03 - control you'll need git installed on
557:06 - your computer and since this is somewhat
557:08 - of an advanced course my assumption is
557:11 - that that is already a case my
557:14 - assumption is that you already have git
557:16 - properly installed and third you'll need
557:19 - a heroku cli a tool to deploy our apps
557:23 - right from our computer
557:25 - and as far as the install for heroku cli
557:28 - you can find the entire setup in the
557:30 - heroku docs so once you sign up for the
557:33 - account this is going to be your
557:35 - dashboard and of course i already have
557:37 - some apps in there and you can find the
557:40 - cli install by clicking on the docs and
557:43 - more specifically the heroku cli link so
557:47 - let's click on a docs and then like i
557:49 - said we're looking for roku cli and in
557:52 - here just pick the operating system and
557:55 - follow the steps once you're done with
557:57 - an install make sure to double check
557:59 - whether everything went smoothly by
558:01 - typing heroku hyphen v in the terminal
558:05 - and if you can see the version number
558:07 - great feel free to proceed to the next
558:09 - video if not if you don't see the
558:11 - version number please troubleshoot since
558:14 - you'll need a working heroku cli in
558:16 - order to follow along with the
558:18 - deployment so if i go back to my
558:21 - terminal and if i type heroku hyphen v
558:24 - of course i can see the version number
558:26 - which means that i have a working cli on
558:29 - my computer and lastly in the next video
558:32 - we'll actually deploy our app and during
558:35 - deployment we will utilize some common
558:38 - standard git commands like init and and
558:41 - commit
558:42 - and since this is not a git course i'm
558:44 - not going to dwell on them too much so
558:46 - if you need to jog your memory as far as
558:48 - the get basics please utilize the search
558:50 - engine all right
558:52 - and once you have installed heroku cli
558:55 - now let's finally deploy our application
558:58 - and in my case what i'm going to do
559:01 - i'm going to look for the entire folder
559:04 - so this is the entire course
559:06 - and then for the jobs api and after that
559:09 - i want to get the final one and
559:11 - essentially i will make the copy just so
559:13 - i can set it up on desktop now of course
559:16 - in your case that is going to be your
559:18 - current application however i do
559:20 - strongly suggest following all the steps
559:25 - and deploying the project as a separate
559:28 - project and here's what i mean so i'll
559:30 - make the copy of the final one here
559:33 - and i'll rename it but before i do that
559:36 - i'll just drag and drop and place it
559:39 - on a desktop so here now it is on
559:41 - desktop and then i'll call this jobs api
559:44 - or whatever again the waste name is
559:46 - really up to you and i suggest doing the
559:49 - same thing essentially if you have been
559:52 - working on starter
559:54 - just make the copy
559:55 - and set it up on desktop or somewhere
559:58 - separately
560:00 - because it's just going to be easier
560:01 - otherwise
560:03 - if you're working in the entire course
560:05 - project in my opinion it's going to be
560:07 - hard to navigate around and set
560:09 - everything up and you also might run
560:11 - into some bugs
560:13 - so let me open up right now my text
560:15 - editor i'll make this one a little bit
560:17 - smaller
560:18 - then i'll drag and drop my application
560:21 - and effectively will follow these steps
560:24 - so let me go back to heroku
560:27 - we'll go to documentation here and then
560:30 - we're looking for node.js
560:32 - and then more specifically we're looking
560:34 - for deploying node.js apps on heroku
560:38 - so these are all the steps we're going
560:41 - to take
560:42 - plus some additional ones
560:45 - that i find useful
560:46 - and first what i want to do is go back
560:48 - to my project and i always always always
560:52 - start by
560:53 - removing the existing git repo just in
560:56 - case there is one and as far as the
560:58 - magnet command is rm
561:00 - then hyphen rf and then git
561:03 - now if you're using windows if you take
561:06 - a look at my twitter if you look around
561:09 - you'll probably find one of my tweets
561:11 - where i share both the command for
561:13 - windows
561:14 - as well as the mac again this is very
561:17 - very important you always want to start
561:19 - from the scratch after that we want to
561:21 - check whether we have that process dot
561:25 - env port variable and by the way by the
561:27 - end of deploy i'll show you where we can
561:30 - actually see the value that is on heroku
561:33 - but this is a must again we can hard
561:36 - code and it nicely works in a local
561:39 - setup but when you deploy you always
561:41 - want to go with process.nv and then the
561:44 - port variable and then heroku picks that
561:47 - port variable and of course spins up our
561:50 - application on that port then we want to
561:53 - set up a simple route so at the moment
561:56 - we have the auth and jobs but what i
561:58 - also like to do is just to set up a
562:01 - simple
562:02 - dummy get road so i know that everything
562:05 - is fine and i have deployed my
562:07 - application and in this case i'm just
562:09 - going to go with app.get then forward
562:11 - slash so of course that's my index and
562:14 - then i'm looking for rec and res
562:17 - and then here let's just send a silly
562:19 - little response where we say res dot and
562:23 - say send and jobs api that's it that's
562:27 - all we have to do
562:29 - and then we will navigate to
562:31 - package.json and this is where we'll
562:34 - take a look at the steps so let's keep
562:36 - on scrolling and they suggest setting
562:38 - the node version and in my case that is
562:42 - node 14 because remember initially when
562:44 - we started the course i installed note
562:47 - 14 but if you install different version
562:49 - push set that one up and just to jog
562:53 - your memory if you want to check your
562:54 - node version just go to node dash nv and
562:59 - again my case that is
563:01 - 14.15 but essentially we'll just go with
563:04 - 14. so in the package json keep
563:07 - scrolling
563:08 - then add a comma and then let's say
563:11 - engines
563:12 - and then inside of it let's go with node
563:15 - and pretty much set up the same code so
563:17 - in order to speed this up i'll just copy
563:19 - and paste and i'm in good shape then
563:22 - let's scroll up
563:24 - and where we have start command we're
563:26 - not going to go with nodemon app.js this
563:29 - is of course only in development
563:31 - effectively we'll go with
563:33 - node
563:34 - and app.js
563:36 - then save it so that should do it for
563:39 - package.json
563:40 - and then lastly as far as the initial
563:42 - setup we want to set up a proc file and
563:46 - then add some values to it now if you
563:49 - want to find more info about the proc
563:51 - file
563:52 - just keep scrolling here
563:54 - blah blah blah
563:55 - and i think i already went past it so
563:58 - let me go up notice here specifying a
564:00 - start script and if you click on this
564:03 - profile you can find more info
564:06 - but effectively what we want to do is
564:08 - create new file now we don't add
564:11 - extension here we just say
564:13 - proc file like so and then inside of it
564:16 - we'll go with web
564:18 - and we'll set node and app.js so pretty
564:22 - much this value is going to be the same
564:24 - as our start command
564:26 - and that should do it for initial setup
564:29 - so now of course we need to start
564:30 - working with git as well and first we'll
564:33 - start by git init so we'll initialize
564:36 - empty git repo
564:38 - then we want to add everything to the
564:39 - staging area so git add and then that
564:43 - and then of course some kind of commit
564:44 - message so essentially in this case i'm
564:46 - going to go with initial
564:48 - commit okay awesome and then this is
564:51 - where the heroku comes in we want to go
564:54 - with heroku and you know let me just
564:56 - clear everything so you can clearly see
564:58 - what's happening so we're gonna go with
565:00 - heroku and login so if you have the cli
565:03 - you'll be able to log in
565:05 - just press any key like this suggest
565:07 - over here
565:08 - and then once you do that they'll ask
565:10 - you to log in okay then of course we
565:13 - want to create a
565:15 - new heroku application and we do that in
565:18 - the following way we go with roku and
565:21 - again let me clear everything let's go
565:23 - with heroku
565:25 - then create and then we need to come up
565:27 - with a name
565:28 - and keep in mind that you cannot start
565:31 - with a number so if you remember in our
565:34 - course project of course i go
565:36 - zero 0605 or whatever
565:38 - in this case i'm gonna have to go with
565:41 - jobs api and then this probably will be
565:45 - taken let me double check yep notice
565:47 - here he's already taken so we need to
565:49 - start from scratch so let's say heroku
565:52 - create and then i'm gonna go jobs iphone
565:56 - api and then zero six again you cannot
565:59 - go zero six and then jobs api it's not
566:02 - going to work because you cannot start
566:04 - with a number so let's set it up
566:07 - now i'm creating that new application
566:09 - awesome and as i said if you just run
566:12 - heroku create
566:13 - it will create a name for you
566:16 - so if that's what you prefer i mean go
566:18 - for it and then i just want to quickly
566:21 - check
566:22 - whether git remote
566:24 - points to the actual repo so let's say
566:27 - here git remote
566:29 - and then hyphen v
566:32 - and if you see these values then of
566:33 - course we are moving in the right
566:35 - direction
566:36 - and before we can push this up
566:40 - we need to of course deal with our env
566:42 - variables correct because if you take a
566:44 - look at the get ignore of course these
566:47 - are ignored and that's how they should
566:49 - be
566:50 - and effectively we have two ways we can
566:53 - do it using command line but i'll just
566:56 - add one value using the command line
566:58 - i'll just go with this lifetime one and
567:00 - then i'll show you another way how we
567:02 - can do that
567:03 - e in the dashboard on the gory because i
567:06 - find gui to be easier as far as setting
567:09 - up the env variables now with that said
567:12 - of course that means that initially when
567:15 - we push our application to the github
567:17 - it's not going to work because our
567:19 - application is looking for all the nv
567:21 - variables but i'm just going to show you
567:22 - one the lifetime one because if you'll
567:25 - try to do this secret essentially in the
567:28 - command line it's just going to be
567:30 - spinning back errors as far as the
567:32 - secret value now of course you can
567:33 - always switch back to string the i don't
567:36 - know secret jwt or whatever but since i
567:39 - want to keep this value i'll show you
567:41 - both setups and after i've been rambling
567:44 - and rambling for about half an hour
567:46 - about it let's go with heroku then
567:49 - config
567:51 - config and then we want to go with a
567:54 - colon and set
567:56 - and essentially this is where we're
567:57 - going to set up those env variables and
568:00 - yes
568:00 - for all the env variables you have
568:03 - you'll have to type this heroku config
568:06 - and send it by typing as always is
568:09 - awesome so let's go with config and then
568:11 - set more properly and then copy and
568:14 - paste and by the way didn't copy this
568:16 - one either
568:17 - my apologies i'm literally on fire so
568:19 - let's go back here and then copy and
568:22 - paste and now of course we're setting
568:24 - that config variable correct so now we
568:27 - have one the jwt lifetime and 30 days so
568:32 - without setting up these ones we'll push
568:34 - this up to the heroku of course our
568:37 - application won't work but then i'll
568:38 - show you another way how we can set them
568:40 - up so now let's go here and in the
568:43 - command line let's clean everything and
568:45 - let's just type git push
568:48 - and heroku and then if you check the
568:50 - docs
568:52 - they say and by the way this is that
568:53 - login screen and close it but if you
568:56 - check the docs
568:58 - they say that you should go with heroku
569:00 - and main
569:01 - now in my case if i type heroku and main
569:05 - i'm basically going to be getting this
569:07 - error if i go with get push
569:10 - roku
569:12 - and
569:12 - master then everything works as expected
569:16 - now our application is being pushed to
569:18 - the github and from there of course the
569:21 - heroical picks it up and now it starts
569:23 - deploy but we need to go back to our
569:26 - dashboard our gui
569:28 - then in here we can refresh we should
569:31 - see the application but again it's not
569:33 - going to work if you go to application
569:35 - if you open app of course you'll have
569:38 - some kind of dummy screen or whatever
569:40 - but i can tell you right away that our
569:42 - application won't work because of course
569:44 - those emv variables are not there
569:47 - now in order to set them up in a gui
569:49 - we'll go over here and we're looking for
569:52 - settings
569:53 - and we'll go with reveal config wires
569:56 - and notice we have the lifetime one
569:58 - correct and now simply what we want to
570:00 - do is add the rest of the values as well
570:04 - so essentially here i'm looking forward
570:06 - to my uri that's going to be my
570:08 - first one copy and paste and the same
570:12 - goes over here
570:13 - so i want to take the value of course
570:16 - and copy and paste let's add this one
570:18 - and the same will do with our secret one
570:22 - and for some interesting reason in the
570:24 - console it spits back errors but in the
570:27 - gui when you add that secret one then
570:29 - everything works like peaches so let me
570:32 - go back here
570:33 - let me grab the value
570:35 - copy and paste and now of course we want
570:38 - to add that var
570:40 - and then in order to spin everything up
570:42 - we just need to go here
570:44 - more and we need to go with restart all
570:48 - dinos so at this point i'll freeze the
570:50 - screen i'll change back to my actual
570:53 - password and then i'll restart dinos and
570:56 - once we restart all the dinos yep that's
570:59 - what we want to do
571:00 - and if we take a look at the logs
571:04 - you'll see how initially
571:06 - our application was on port
571:09 - 43 710
571:12 - so that was the port that the heroku
571:14 - picked then we exited with a status of
571:18 - 143 so basically we had the issue
571:21 - with our process.nv
571:23 - and now of course we're back to
571:26 - 46 and then 97 so that's the port if we
571:30 - open up the application notice i can
571:33 - clearly see my
571:35 - jobs api and of course i was just
571:37 - showcasing the port variable so you get
571:40 - the clear idea of how everything is set
571:43 - up that's why we go here with this port
571:47 - because then heroku picks the port where
571:50 - our application is going to be located
571:53 - and once i have my application up and
571:56 - running we simply want to grab the url
571:59 - and we want to test it out now i'm not
572:01 - going to test it out with all the routes
572:03 - but i definitely want to create or log
572:05 - in the user and see whether i can see
572:08 - all the jobs so in my case i'm going to
572:11 - go to the postman
572:12 - and since i don't want to mess up these
572:15 - routes i'll actually create first a
572:17 - global variable because in here of
572:20 - course yes i have the url
572:22 - but what is the actual url well it is
572:25 - localhost 3000 correct now what do we
572:28 - want to do we want to go with edit
572:30 - then let's write here prod and then
572:33 - underscore url
572:34 - and then let's just copy and paste the
572:36 - value so this is going to be the url for
572:39 - your application now we're still looking
572:41 - for api
572:42 - and then version one
572:44 - so
572:45 - that's not going to change let's save it
572:47 - here and then i can close my globals
572:50 - and like i said i'll create a new route
572:53 - and this is going to be a post route
572:56 - and since i have that one susan user
572:59 - i'll just try to log in and then see
573:02 - whether i can see
573:04 - all the jobs that susan has and in this
573:07 - case we're looking for prod
573:09 - and of course the url okay awesome then
573:12 - we're looking for
573:14 - auth
573:14 - and then forward slash login so that is
573:18 - going to be the url
573:19 - now as far as the credentials well
573:23 - where we have the login user first i
573:25 - want to grab the body here
573:27 - so let's take all of this
573:29 - and again we're just doing that so we
573:32 - don't have to type everything from
573:33 - scratch
573:34 - so json copy and paste okay we have
573:36 - susan gmail password and all that and
573:39 - then remember since i want to set that
573:41 - token automatically
573:43 - what do we need to do well we need to
573:45 - look for tests correct and just take
573:49 - these two lines of code
573:50 - and then back in my production one copy
573:53 - and paste and now i want to send
573:56 - and if everything is correct which of
573:59 - course it is i'm getting back my token
574:02 - and i'm still setting it up in the
574:03 - globals which is just awesome
574:06 - and now of course we just want to create
574:08 - another route now this will get all the
574:11 - jobs that susan has so let's go and go
574:14 - with get route and we're looking for
574:18 - again the production url
574:20 - then jobs and this is going to be the
574:23 - get route that's correct and then in
574:26 - here
574:26 - i mean let's go with authorization of
574:29 - course we're looking for better token
574:32 - and access token and if everything is
574:35 - correct i should see that susan has two
574:38 - jobs one for netflix and one for google
574:42 - and wonderful we have successfully
574:45 - created our application and we have
574:47 - deployed it on heroku as well okay once
574:51 - our app is chilling on a cloud now it's
574:54 - time to set up some nice docs using
574:56 - swagger ui don't get me wrong there are
574:59 - quite a few alternative api
575:01 - documentation options out there
575:03 - but it's hard to compete with a nice end
575:05 - result you get with swagger with that
575:08 - said setting up swagger manually aka
575:11 - writing the code yourself from scratch
575:13 - is no walk in the park it's not that
575:16 - it's hard it's just really tedious and
575:18 - takes somewhat long time
575:20 - and since i don't want to spend three
575:22 - hours on setting up the docs i'll show
575:25 - you a nice shortcut where we can utilize
575:27 - the post mandox and a third-party
575:30 - library to essentially automate the
575:32 - process and as a result
575:35 - save ourselves a ton of time before we
575:37 - continue please let me make it clear
575:39 - this is not going to be tutorial on
575:41 - swagger ui we just want to create
575:43 - working docs and in fact i won't dwell
575:46 - on any of the details if you want to
575:48 - find out more about swagger ui syntax
575:50 - and other options please utilize one of
575:53 - the tons of nice tutorials and blog
575:55 - posts out there and we're going to start
575:57 - our documentation setup with a little
575:59 - detour where i'll show you how to clone
576:02 - an existing heroku app
576:04 - needless to say technically it's
576:05 - optional
576:06 - if you don't want to do that you can
576:08 - just keep using the project we used for
576:10 - deployment
576:11 - but if you're anything like me
576:13 - essentially if possible you don't like
576:16 - keeping the projects on your local
576:17 - machine and instead you want to keep
576:19 - them on a cloud i think you'll find this
576:21 - video useful
576:23 - and i want to start by navigating back
576:25 - to my desktop i'm looking for my
576:26 - terminal first i want to navigate to
576:29 - desktop so let's say here cd desktop
576:32 - then we want to go with heroku so that's
576:34 - the cli then git
576:37 - clone and hyphen a
576:39 - and after that we need to provide the
576:42 - name of that which in my case is jobs
576:45 - api 0 6
576:47 - so either you can copy and paste or you
576:50 - can type it out and in my case i'm going
576:51 - to go with jobs api
576:54 - and 0 6 and now on my desktop i should
576:58 - have the repo and what that means is
577:01 - that the url is pointing back to the
577:03 - heroku so every time we'll make some
577:06 - change of course we'll push it back to
577:08 - heroku and all the changes will be
577:10 - applied
577:11 - now what's missing of course is the node
577:13 - modules as well as the dot env
577:17 - because remember
577:18 - if we take a look at our git ignore
577:21 - this is not pushed up to the github now
577:23 - in order to fix that we'll need to
577:25 - create a file so go with dot env and
577:28 - then we want to provide
577:30 - all three values uri and rest of
577:33 - the two for djwt now where you can get
577:37 - them we'll remember
577:39 - if we navigate to our application then
577:41 - more specifically settings we have our
577:43 - variables correct config vars so just
577:46 - open this up
577:47 - set it up in dot env install all the
577:50 - packages and then you can run npm start
577:54 - and once i'm done setting up my
577:56 - environment variables
577:58 - like i already mentioned we're gonna go
578:00 - with npm install so install all the
578:03 - packages and then let's go with npm
578:06 - start
578:07 - now since i want to make tiny changes
578:09 - here there's not gonna be that much code
578:12 - essentially
578:13 - i will keep in the package just on node
578:16 - objects please keep in mind that
578:19 - if you want to add more changes to the
578:21 - project it's probably more useful to set
578:24 - up the command where you're using the
578:26 - nodemon because if you remember it's
578:29 - quite annoying would know that you have
578:30 - to restart every time you make the
578:32 - change
578:33 - again we'll have only like i don't know
578:35 - six lines of code so it doesn't really
578:38 - matter in our case but in general if
578:40 - this is what you're doing if you're
578:41 - cloning the app back from the heroku
578:44 - just remember to change the start
578:45 - command or set up some kind of command
578:48 - that you can use in dev where
578:50 - effectively you are using nodemon right
578:53 - from the get go and if i can see that
578:55 - server is listening on port 5000 that
578:58 - means that everything is correct and if
579:00 - i navigate to the localhost 5000 in my
579:03 - browser i should have that silly jobs
579:06 - api and with this in place now we can
579:09 - start setting up the docs once our
579:11 - application is running on localhost 5000
579:13 - we want to swing back to the postman and
579:16 - we want to get the documentation and the
579:19 - way we do that we look for our
579:21 - collection and before you do anything
579:23 - just make sure
579:24 - that the global url variable is the same
579:28 - in all the requests in my case i'm using
579:30 - the production one but it doesn't really
579:33 - matter since we'll change that value
579:35 - later anyway so you can use the url just
579:38 - make sure
579:39 - that all the requests have the same
579:41 - value otherwise you might get some weird
579:44 - bugs and in fact postman offers
579:47 - documentation itself the problem is that
579:51 - once you publish it it actually goes to
579:53 - a separate url
579:55 - now what do i mean by that well
579:57 - eventually in our api we'll have the
580:00 - route api docs as you can see and this
580:03 - is where the user will be able to access
580:05 - the docs with postman once we publish
580:08 - the docs they're automatically hosted
580:10 - online but on a separate url and since i
580:14 - want my docs to be on the same server
580:17 - that's why we're doing all this swagger
580:19 - stuff and in order to export
580:21 - documentation just look for the
580:24 - collection again jobs api make sure that
580:27 - the urls are all the same in all the
580:29 - requests and then the option you're
580:31 - looking for is this export one
580:34 - if for somewhere reason you don't see it
580:36 - just sign up for a free postman account
580:40 - it's not gonna cost you anything they're
580:41 - not gonna charge your credit card you
580:43 - just need to use the email and you'll be
580:46 - good to go again this is the case if you
580:47 - don't see the export option if you do
580:50 - then smash the export option like
580:52 - there's no tomorrow afterwards pick the
580:54 - second option
580:55 - then decide on the name and location and
580:58 - in my case i'm gonna go with docs json
581:01 - and i'll save it on a desktop and once
581:04 - we navigate to the location and we can
581:06 - see the json file then of course we can
581:08 - move on to the next step awesome once we
581:11 - have the postman json file we are
581:13 - halfway there we just need to fix a tiny
581:16 - issue you see we cannot pass postman
581:19 - docs directly into swagger ui
581:23 - effectively we need to format our data
581:25 - first just so swagger understands what's
581:28 - happening and in order to accomplish
581:30 - that we'll have to sign up for one more
581:32 - free tool
581:34 - api matic important side note just like
581:36 - other course resources it's free and i
581:39 - have no affiliation to them so in order
581:42 - to follow along the videos go to
581:44 - apimatic.io
581:46 - and sign up for free account assuming
581:49 - that you sign up for the account this is
581:51 - going to be your dashboard and you're
581:53 - looking for the import option and we
581:56 - want to import that docs json
581:59 - in my case i'm going to be looking in
582:01 - the desktop
582:02 - and i want to import yes
582:04 - now don't pay attention to those
582:06 - warnings as long as you don't have any
582:08 - errors we should be good to go so i'm
582:10 - going to click on proceed and once you
582:12 - have the api instance in place
582:15 - before we can ship it to swagger ui
582:17 - we'll need to edit a little bit so this
582:20 - is the case where we'll add the proper
582:21 - url we'll set up the proper
582:24 - authorization and all that cool stuff so
582:27 - we want to click here on edit api
582:30 - and let's just start with basic settings
582:32 - and as you can see we have tons and tons
582:35 - of options but totally honestly we'll
582:37 - just go with a bare-bones setup
582:40 - since i don't want to waste too much of
582:42 - your time and as far as the name i think
582:44 - i'm going to go with
582:46 - jobs api if you want you can add the
582:48 - image that's not what i'm looking for so
582:51 - i'll just save basic settings and this
582:53 - is very very important make sure that
582:55 - you save before moving on to the next
582:58 - configuration options then we're looking
583:00 - for server configuration option the
583:03 - environment will be production server
583:05 - name i'll just leave it as server one
583:08 - and when it comes to url this is where
583:10 - you wanna pass the url that points back
583:14 - to your heroku project so in my case let
583:18 - me double check i'm gonna go back to
583:20 - heroku here i have my jobs api
583:23 - open app
583:24 - so that's going to be my route now one
583:26 - downside with heroku is that yes it
583:30 - takes time to spin up that dyno so
583:32 - that's one thing that you need to keep
583:33 - in mind and i'll just take the url
583:36 - i'll navigate back to the api matic copy
583:40 - and paste and then remember as far as
583:42 - our routes we still want to go with api
583:45 - and then version one and then we'll have
583:47 - auth and jobs again make sure make sure
583:51 - make sure make sure that you save the
583:53 - config settings it's very easy to make
583:55 - some changes and then just forget about
583:57 - it
583:57 - and when it comes to authentication yes
584:00 - we'll use the better token so auth 2.0
584:04 - that stays the same after that we want
584:06 - to move on to the endpoints
584:08 - and here in the endpoints you'll notice
584:11 - that
584:12 - all of them effectively have the
584:14 - authentication and that's not what we
584:16 - want because if you remember as far as
584:19 - our api well these ones the actual
584:23 - auth routes well we don't want to set up
584:26 - the authentication on them correct these
584:28 - are going to be the public ones and only
584:30 - the jobs will be protected and will
584:34 - require that token hopefully we're on
584:36 - the same page we're looking for
584:38 - register user and login user so let me
584:42 - open up this endpoint here then we want
584:44 - to change the group and i'll change it
584:46 - to auth
584:48 - and i want to skip the authentication
584:50 - because by default the authentication is
584:53 - going to be added to all of them so
584:56 - let's save the endpoint
584:57 - and now we should see the auth folder
585:01 - and in there there's going to be a
585:02 - register user and we're skipping
585:05 - authentication this is very very
585:07 - important
585:08 - and the second route that i want to add
585:11 - is the login one
585:13 - so look for the login user and same deal
585:16 - we want to skip the authentication
585:19 - and we want to place it in our auth
585:21 - folder so let's save the endpoint and
585:24 - then for the rest of them we are not
585:27 - skipping the authentication so don't
585:29 - click here but what we want to do is
585:32 - change the folder so for all the routes
585:35 - one by one i'll add group and the name
585:38 - will be jobs and once i say i have jobs
585:40 - folder with create job wrote and i'm not
585:44 - skipping the authentication and
585:47 - essentially what you want to do
585:48 - apply the same group to the rest of the
585:52 - routes get all jobs all the way to
585:54 - delete job and since it's not very
585:58 - useful for you to watch how i do that
586:00 - i'll pause the video and i'll just add
586:03 - this jobs group to the rest of the
586:05 - routes and once i'm done i will resume
586:08 - the video and once you're done you
586:10 - should have two folders the jobs folder
586:12 - with all the jobs routes and again we're
586:15 - not skipping the authentication and auth
586:18 - folder where we are skipping the
586:20 - authentication and we have two following
586:22 - routes register user and login user and
586:26 - if that is the case just navigate back
586:28 - to the dashboard
586:30 - then you're looking for this option
586:32 - you're looking for export api
586:35 - and this is very very very important
586:38 - that you go with open api version three
586:41 - as you can see by default we have
586:42 - version two json you're looking for this
586:45 - one and you wanna go with yaml option so
586:48 - click here and then export documentation
586:51 - and eventually this is what you should
586:53 - see on a screen and if that is the case
586:55 - now we can move on to our next step all
586:58 - right and once our documentation makes
587:00 - sense to swagger ui now let's test it
587:02 - out in their online editor which is a
587:05 - nifty tool that we can use to test out
587:08 - our api docs right in the browser
587:11 - and if necessary apply the changes and
587:13 - as a result save ourselves a ton of time
587:17 - so what i want you to do is go to your
587:19 - search engine and you're looking for
587:21 - swagger error or swagger ui error
587:25 - doesn't really matter and then you can
587:27 - open up two tabs because you'll notice
587:30 - that they do provide some boilerplate
587:32 - code which of course you can use in
587:34 - order to understand the entire setup
587:38 - and this is exactly what i'm going to do
587:40 - so i have one tab open
587:42 - and i'll open up the another one and in
587:45 - there i want to copy and paste this
587:47 - entire thing so let me select it
587:50 - then go back
587:52 - and i want to copy and paste
587:55 - after that we can technically start
587:56 - testing our api
587:58 - but the problem is that we still have
588:01 - the params unfixed and also we have this
588:05 - extra tag and we'll start with the tag
588:08 - where basically navigate to the bottom
588:11 - where you have the tags and just remove
588:13 - the first one
588:15 - so that's done and then let's deal with
588:18 - the query parameters because if you take
588:20 - a look at our project notice we have
588:22 - jobs
588:23 - and then for single job the update job
588:26 - and delete job these are query
588:28 - parameters but at the moment
588:31 - everything
588:32 - is hard coded so how we can set it up in
588:36 - swagger
588:37 - z params well we'll use their docs this
588:40 - is going to be the case where i want you
588:42 - to again use your search engine and just
588:45 - type swagger ui parameters a quick side
588:49 - note if you can't be bothered going
588:50 - through the swagger docs you can always
588:52 - find the correct code in the project
588:55 - readme you're looking probably for the
588:57 - first link
588:59 - then we'll keep on scrolling yep all the
589:01 - details and all that
589:03 - but what we're interested is common
589:06 - parameters for all methods of the path
589:10 - now i don't want you to take the path
589:13 - part
589:13 - but i want you to take everything
589:16 - starting with the user
589:18 - all the way to get
589:19 - so take this code yes we'll modify but
589:22 - this is just going to be faster if we
589:24 - set it up this way go back to your error
589:27 - and what you're looking for are those
589:30 - single routes so go up here where you
589:32 - have the patch remove the hard-coded one
589:35 - including the column this is very very
589:37 - important and the same for get
589:40 - and once you remove the get part just
589:43 - copy and paste this one in this case we
589:46 - don't want to use the user because the
589:48 - route is
589:49 - jobs correct then we have the id yeah
589:52 - that still stays the same
589:54 - and instead of integer this is going to
589:56 - be a string it's going to be required
589:59 - and it's going to be a job id again if
590:02 - you want to find more info
590:03 - please just read their documentation but
590:06 - essentially what we did right now
590:08 - we added that id parameter in all these
590:12 - three routes get single job update job
590:15 - and delete job and once we have this in
590:18 - place now we can start testing our api
590:21 - and i'll start by registering the user
590:23 - now i'm not going to try out all the
590:25 - routes but i think i'm just going to go
590:27 - with a register and maybe i'll try to
590:29 - create a job and then take a look at a
590:31 - single job just so you can see that
590:33 - everything works
590:35 - and the way we do that in a swagger we
590:37 - look for try it out here notice these
590:40 - are the values that we're sending and of
590:42 - course once you already register user
590:44 - you'll have to change these values
590:45 - around but in my case i deleted the bob
590:48 - from my database so i can execute notice
590:52 - this is going to be the sample request
590:55 - this is going to be the url and voila
590:58 - this is the response so that's my token
591:01 - but the deal again in here is that these
591:04 - ones are protected so if i'll just try
591:07 - to access the job or create job or
591:09 - whatever i'm not going to be able to do
591:11 - that so you want to copy the token
591:15 - and you have two options either you can
591:17 - set up in one of them and automatically
591:20 - it's going to be added to all of them or
591:22 - you can just scroll up and same deal
591:24 - just copy and paste the value authorized
591:27 - so now i set up my token so i can close
591:31 - the register i'm good to go now we just
591:33 - want to create a job so let's go to the
591:36 - post request
591:37 - again we're trying it out i'm going to
591:39 - go with the same google and the
591:42 - front-end developer we'll execute
591:46 - we should get back the job the 201 and
591:49 - now if i go to get all jobs
591:53 - and we try it out we just execute we
591:55 - don't need to provide anything we have
591:57 - our jobs array with a counter one and if
592:01 - i want to take a look at single job we
592:04 - want to copy and paste the value
592:06 - and as far as the setup
592:08 - either of these is going to work so
592:11 - either get patch or delete and my case i
592:14 - think i'm going to go with get we want
592:16 - to try it out again after that we want
592:18 - to paste the job id remember as far as
592:20 - the authorization we right away set up
592:23 - the token at the very very start so now
592:26 - of course we're authorized to make these
592:28 - requests so once we execute
592:31 - check it out
592:32 - now i can see my
592:34 - one job and once everything is working
592:37 - now the last step
592:39 - is just setting this up in our
592:41 - application
592:42 - so we'll still need this code so don't
592:44 - remove it or mess it up but the good
592:46 - news is that we're pretty much done with
592:48 - the hardest part
592:50 - so i promise it's going to be a smooth
592:52 - sailing from here on out beautiful and
592:55 - once we have tested our api in a swagger
592:57 - editor
592:58 - now we just want to add it to our
593:00 - application and in order to do that
593:02 - we'll need two packages we'll need yaml
593:06 - js and the swagger ui express now if you
593:11 - can see both packages
593:13 - in the package.json then of course
593:15 - you're good to go but since i added
593:17 - these packages later essentially they
593:20 - were not with initial star you might
593:23 - need to install them yourself so if you
593:25 - don't see them just run the command of
593:27 - npm
593:28 - and i or installed doesn't really matter
593:31 - then go for yaml
593:33 - js and swagger
593:36 - ui
593:37 - ui
593:38 - and express
593:40 - so this one will convert the yaml one to
593:43 - something that the swagger ui can
593:45 - understand and swagger ui express just
593:48 - adds swagger to our application so i'll
593:51 - install both packages even though i have
593:53 - them and i'll start by creating a new
593:56 - file and in my case i'm going to call
593:58 - this swagger and yaml now the name is
594:02 - really up to you just make sure
594:04 - that the extension is yaml
594:06 - and now you want to take this entire
594:09 - thing again this is a little bit
594:10 - different than what we have from api
594:12 - matic this is already a working
594:15 - documentation copy and paste and back in
594:19 - our app.js we want to do two things we
594:22 - want to require the swagger ui express
594:25 - the yaml js and then load the yaml file
594:29 - and then we want to pass it on to the
594:32 - swagger ui so i'm gonna go below the
594:36 - extra packages we'll add comment here
594:39 - i'll say
594:40 - swagger and let's just start by grabbing
594:43 - the swagger ui
594:45 - again we're just coming up with some
594:47 - kind of name
594:48 - and this will be equal to require
594:51 - then we're looking for the swagger ui
594:53 - express
594:54 - and since i have yaml file i also want
594:57 - to do that
594:58 - and that will be equal to
595:00 - require and we're looking for the
595:03 - package and then we want to load the
595:05 - file
595:06 - so in here let's just come up with some
595:07 - kind of name i'm going to go with
595:09 - swagger
595:10 - document
595:12 - and that will be equal to yaml that's
595:15 - the variable
595:16 - then dot and the method you're looking
595:18 - for is load and in here you want to
595:20 - point to the file which of course is in
595:23 - the root so we simply go with swagger
595:25 - dot and yaml and once we have all of
595:29 - this code in place now we just want to
595:31 - scroll down
595:33 - and where we have here the app.get above
595:37 - it below it it's really up to you we'll
595:40 - go with app.use then we need to come up
595:42 - with a path and in my case i'm going to
595:44 - go with forward slash api docs and you
595:47 - know what actually changed my mind i'll
595:49 - place it after the forward slash so
595:52 - let's go here let's say api docs as you
595:55 - can see we're using
595:56 - app.use so it will be a middleware and
596:00 - then as far as the code we want to go
596:02 - with swagger so that's our variable and
596:05 - we're looking for the serve property and
596:08 - then we want to get that yaml file so
596:11 - again we go with swagger ui setup method
596:14 - and in this case we want to pass in that
596:17 - swagger
596:18 - document once all of this is in place
596:21 - now i just want to go to app.get and
596:25 - instead of sending back jobs api
596:28 - what i want to do is send back the
596:30 - heading 1 let's say jobs
596:33 - api i'll close the heading 1 and then
596:35 - i'll just set up some link that goes to
596:38 - api and for some reason
596:40 - i went with api use should be api docs
596:44 - my apologies
596:46 - so let me go here i'm going to go with
596:48 - href
596:49 - and we're going to set it up as forward
596:51 - slash
596:53 - api docs
596:55 - and then let's close the link and let's
596:57 - just say documentation and once we have
597:00 - all of this in place
597:02 - now let's run npm start but i can tell
597:04 - you right away
597:05 - that if you'll try to test this
597:08 - on a local machine it's not going to
597:10 - work basically you'll get a bunch of
597:12 - errors so everything is going to work
597:15 - once we push this up to the get up for
597:17 - now i just want to see whether the basic
597:20 - setup work so let me look for localhost
597:23 - and then i'm looking for 5000 i should
597:25 - see the documentation and once we
597:28 - navigate here voila we have our
597:30 - documentation in place now the only
597:33 - thing we need to do is just go back
597:36 - and then add those three commands we
597:38 - want to look for git add
597:40 - so this is going to add to the staging
597:42 - area then we'll go with git commit let's
597:46 - just say
597:47 - swagger docs
597:49 - added
597:50 - and lastly remember the command
597:52 - get push heroku main or master so in my
597:57 - case it's master now we're pushing
597:59 - everything to the heroku and if there
598:02 - are no weird bugs
598:04 - we should be in good place
598:06 - and the nice swagger door condition
598:09 - should be added to our project and to
598:12 - answer your question yes when you are
598:14 - setting up manually basically when
598:16 - you're typing this yourself you do need
598:19 - to provide all these properties and i
598:22 - just thought that it's much easier to
598:24 - show you how to do that automatically
598:28 - because you need to keep in mind that
598:30 - as we're progressing with the course our
598:32 - projects are going to get more complex
598:34 - and i really don't want to spend five
598:36 - hours on a project and then another five
598:39 - on the documentation because it seems
598:41 - like a big waste of your time so now let
598:43 - me navigate back to my web browser i'll
598:47 - close all of my tabs since i have 10 000
598:50 - of them
598:51 - open
598:52 - i want to go to heroku i want to open up
598:54 - the app i have my documentation awesome
598:58 - and now let's test it out so
599:01 - before we do anything why don't we
599:03 - remove that bob user because i think
599:06 - that that way i don't have to waste too
599:08 - much time on changing the values i'm not
599:10 - going to test every route but i want to
599:13 - test out the major ones so let me delete
599:15 - the user just so i can see that
599:17 - everything works we're looking for a
599:20 - register user option
599:22 - i want to go with try it out of course
599:25 - and we want to execute we should get
599:27 - back the token which is just awesome now
599:30 - let's quickly authorize the route
599:33 - so let's add here copy and paste
599:36 - authorized we'll close it
599:38 - and then let's create a job so let's go
599:41 - here we're going to go with tryout
599:44 - and we'll execute yep we're creating a
599:47 - job and lastly let's just get all the
599:50 - jobs try it out and execute
599:54 - i can see that i have my jobs array with
599:57 - a counter one so that's how we can add
600:00 - swagger ui documentation to our api
600:04 - without typing any of the code ourselves

Cleaned transcript:

improve your node.js skills by building four projects this course is taught by john smilga the wonderful instructor from coding addict what's up everybody this is john from coding addict and welcome to another nodejs video and in this video we're going to make four node js projects while working on the projects amongst other things we'll cover what is mongodb and how to set it up in our app how to get up and running with mongoose how to set up error handling in express and eventually we'll deploy our project to heroku and implement swagger documentation as well just like my other videos we'll start with the fundamentals and slowly but surely move up to more complex functionality this is the second part of node.js tutorial video so my assumption is that you're already familiar with nodejs and express basics if you're interested in the first video node and express tutorial you can find the link in the description in order to follow with a project you will need a starter and the fastest way you can get it is by navigating to johnsmilk.com again the url is johnsmilk.com and once you hit this lovely site look for the projects more specifically node ones and then all of these three links lead to the same repo so you can pick any of them and once you click you'll navigate to the repo node express course and essentially in here just pick your weapon whether you want to download zip or if you just want to clone it i think in my case i'm just going to go with download option then go back to your computer look for your downloads then crack open the zip file and right away open up your favorite editor in my case that is visual studio code i'll drag and drop and during this video will work on following projects so we'll work on zero three task manager store api as well as jw2 basics and jobs api and for all the projects you'll have the same structure where there's going to be a final and a starter so final is a complete project and starter is where we'll do all of our work now keep something in mind where for the final one not only you'll need to install all the dependencies basically run npm install but you'll also need to add some additional info what info well that we will cover during the project so don't be surprised if you just run npm install and npm start in the final folder and you get back bunch of errors that's about it for overall setup and when it comes to project specific setup i'll cover that right after each project intro video so once you've got the repo in your text editor feel free to continue with the video awesome and welcome to our first project task manager api and before we cover the features let me list the main goals of this project and they're following with the help of this project we will learn how to set up and connect to the cloud database so effectively we'll learn how to persist our data to the cloud and not only that we'll also learn how to perform all the crowd operations and crud stands for create read update and delete on our data which is fundamental fundamental to any application also let me mention that since it's a node course we'll only work on a back end so essentially the front end app you see right now is already prepared for you and it's only there so you get the full picture and the same is going to be for the rest of the project i'm probably not going to make front ends for all of them but if i'll see that a matching frontend app can provide more clarity i'll definitely whip up one as well just so you can see the entire request and response cycle not just post my responses as far as the first project on the front end we've got a form analyst and by communicating with our backend meaning by sending requests to our api the user can create read update and delete or destroy tasks again let me stress something this is not your typical todo list app that stores everything in local storage what's fundamentally different is that we're going to be responsible for setting up the api that communicates with the cloud database and persist the data to the cloud and as far as the functionality it goes something like this where we have the form and of course i can enter a new task that's exactly how i'll call it we press submit so we send off the post request and since we're successful we get back all the tasks and the newest task is added to the list now we can also delete task so if i don't want to walk the cat i just removed from the list and then if we want to edit we click over here and first we'll see only the specific data about that one task and then if we want to edit for example if i want to set it up as completed and if i want to rename it as old task then of course we just press edit then we send off the request and now if we navigate back to all the tasks now as you can see it is completed and the name is different as well and as far as the task manager setup like i already previously mentioned we have final folder so this is where you'll find complete project however not only we need to install all dependencies but also if you take a look at the readme you'll notice a text where it says in order to run the project you need to set up dot env and set up the uri connection variable and essentially these are the things that we'll cover during the project so in order to spin up the project yes you'll have to watch some videos where we actually cover that and only then you'll be able to do that now as far as the setup a lot of things should look very familiar so in here we have the public and of course in the public this is where we have our app again everything is already prepared for you and just so we all are on the same page i actually created that with vanilla.js and then of course we have the app.js and here i simply have one line task manager app and then if you take a look at the package.json as far as the packages we have express something we covered in the second part of the course and then you see two more packages dot env and mongoose and of course these ones will cover during the project why they're there and what is going to be the use case now in order to make our dev setup easier i also installed nodemon as a dev dependency and as far as the script well you just need to type npm start and that essentially will spin up nodemon with app.js and then we also have git ignore which we're going to cover a little later once we create the env but long story short this is just a file that prevents specific files being added to the source code and essentially with this setup these two things will be ignored if we decide to push this up to the github so we'll ignore node modules because usually they're pretty big and then dot env because this is where we want to keep our secrets and of course we will cover this one later in the project and once we're familiar with the setup let's kick things into gear and actually start working on project and first thing that you need to do is to navigate to the starter folder again you're looking for the third project the task manager and then more specifically the star folder and i think the fastest way to navigate there is by just typing cd and then grab the star folder and drop it here and then once you're in a starter before you do anything make sure that you install all the packages and of course we do that by running npm install and then once all the packages are in place in order to spin up the nodemon we need to go with npm start unless of course you want to change it to a different command if that's the case then make the changes and then use that command instead so in my case i'll just wait a little bit i mean it shouldn't take too long there's not that many packages in there and then once i have all the packages in place then of course like i said we're gonna go with npm start and if you see task manager in the console we are in good shape and now let's set up the most basic express server which essentially is just going to be listening for one route forward slash hello and it's going to be on port 3000 now if you want to jog your memory and test it up yourself just pause the video and resume once you're done if you don't want to do that just keep on watching the video and the way we set up the most basic express server is by setting up a variable by the name of express then we'll set it equal to require and that's going to be equal to our express package then we need to initialize it so we go with app and that is equal to express and we invoke it and then unlike the previous examples we'll actually set up a variable by the name of port and for time being we'll hard code this to 3000 but eventually there is going to be more code and i'll talk about the reasoning later so for now just set up the variable and we'll be in good shape and in here we need to go with amp.listen of course and first thing we pass in is the port and the second is the console.log so we go here with some kind of text and i'm going to go with server is listening on port and then of course we pass in the port value and i always like to add those three dots as well so i'll do it in this case and then i'll open up my console the moment i have server is listening on port 3000 which is just awesome so now let's also set up that one lonely route so above the port i'm going to go with my comment routes and then we'll just say app.get so this is going to be a get request now what is going to be the url well we'll go with forward slash and hello so that's going to be the path and then of course we have the callback function once the user hits the route and we're looking for iraq and res so request and response and we simply want to go with reg dot send and then we'll pass task manager and app so i'll save it here i'll navigate to the browser and i'm looking for port 3000 of course and then we'll go with hello and if we see task manager app displayed in the browser then of course we are off to the great start beautiful and once we have the bones in place next let's take a look at our application so we can decide what route eventually we're going to have and i can see that i'm getting all my tasks so there will definitely be a get request that gets me all my items now i can also create a new task so there will be a post request that can create a new task now we can also delete one so there will be a route for that and if we click on edit we open up a new page and in here we get info about specific route so there will be a get request that just gets me info about one single task and also we'll have the ability to edit so if i change the completed from true to false if i successfully edit that then if i go back to the tasks of course in here i don't see the check mark which means that i successfully edited the task and what that means is that there's also a route for the update and in summary our routes are going to look something like this where there will be a get request on api version one and then tasks so this will get all the tasks then there will be a post request on api version 1 tasks again the same url however the method is different so total different functionality in this case we'll create a new task and then we have guest route with params so with the id of the task that gets us that single task and of course one for update and one for delete and since there's a lot to unpack over here i'll spend the next video on the reasons behind such api structure all right so let's go step by step and probably your first question is well why do we go here with forward slash api and then version one and essentially that is just a convention we need to understand that on the server we also might have different routes not just the routes for the api so for example you could be serving a index page here on a forward slash meaning there could be a nice index.html page that you're serving up over here and then also on the same server you have the api routes so convention is effectively just to signal that all of these are the api routes now as far as the version well as you're setting up the api eventually you might want to change some things so it's easier if you have this version because that way when you create a new one then you can just direct everybody to api and then version two three or whatever and while we're still on that same note why don't we navigate to a hacker news one the one that i showed you previously with algolia and you'll notice exactly the same setup more essentially they go with domain and then forward slash and then api and then version number one and that leads me to my next point where if you're ever in doubt or if you're just interested on different setups just check out the different apis there's tons of apis out there and you can just look for one then take a look at their setup and then decide if what they're doing makes sense to you then of course you can implement in your project if not then just move on to a different api and eventually you'll find a setup that makes the most sense to you after that you're probably wondering okay i understand the api highend version that kind of makes sense but why do we go here with get and then tasks then we have the post and the same tasks and then for get patch and delete we go to the tasks but then we're looking for the colon why isn't this written in a different way where we're just looking for a single task or something along those lines and to give you a short answer that is a convention but since there's more to it i want to actually cover that in a few videos so i want to set up the basic routes with just some simple responses then i want to open up the postman and do a little bit of setup over there and then right before we start setting up the database i actually want to spend one video on just talking about the convention and then lastly if you remember in tutorial we worked with put and now for the update we're using patch and i know that this might be a little bit frustrating to you but that's also going to be something that we will cover a bit later once we have already a working application because that way i believe that i can give you a solid example of the differences between the put and patch that's about it for the general route structure so now let's start implementing it not bad that bad i think we're good with the general structure so now let's start implementing it and i want to right away set up the router as well as the controllers and if you remember at the very end of the express tutorial i covered why is that necessary and essentially the short answer is that as our application grows bigger it's not going to be very sustainable if we'll just start dumping everything in the app drives and for time being i just want to create this one route now as far as the response it's just going to be a simple string that says hey here are all the items or something along those lines and then once we have that one in place then we'll add the rest of them and then we'll test it out in postman so let's get cracking and i'm going to go with new folder so here will be all the controllers and in this case i'm going to be looking for tasks and i also want to set up a routes folder so in the routes folder we'll go with new file and same thing we're going to go with tasks js and then as far as the setup in the routes we need to look for the express router so say const express and that is equal to require and then again we'll look for express and this should be a refresher because we did cover that at the end of the express tutorial so just to jog your memory if we go back to express tutorial and then more specifically we'll look for the final one the file 13 the router people shows a basic router example and essentially we have two options we can either go with route or get and then add all the controllers one by one or we can actually change them together where we go with router and then user route so this is going to be the main route in our case api version one and then tasks and then we chain get and post and i think i'm gonna go with this setup so first let's start by setting up the router and that is equal to express and then router we invoke it and then eventually we'll import controllers but for now of course we don't have any so let's just leave that one blank and we'll go with router router then route like i said then forward slash and then i want to go with get method and for time being i'll just hard code the response over here so say wreck and res and res dot and send and like i said we'll just start simply so say all items now let's save that one and then all the way in the bottom we want to go with module exports and that is equal to our router so now back in the app.js we want to import the router we want to import our tasks and we want to set up the middleware so in here let's just go with const and then routes and that is equal to require and then like i said we're going to be looking in the routes folder and then more specifically we're looking for tasks and then right after this hello and don't worry we'll change that one a little bit later for time being it can just stay the way it is we'll go with app.use and then of course what route are we looking for well we want to go with api then version one and then tasks so that's going to be that root route for the tasks router and then we just want to go with our routes and you know what let's just change the round but for some reason i went with routes let's just call it tasks i believe it's going to make a bit more sense and since we'll be sending json from our application for example when we're creating a new task and since i want to access that data in my routes what we need to do of course is get middleware that is built into express and that middleware is express json so above the routes we'll go here and i'll try to spell this correctly since that is always an issue hopefully this is correct middleware and then we'll just go with app.use and eventually we'll set up the static one as well but since at the moment we have barely any routes i'm just gonna go with express and json if you remember if we don't use this then we won't have that data in rec.body so i'll save it here and i'll leave the comments just so we all are on the same page and before i test it out in the browser let me just double check so i'm using the middleware where i'm saying that i'm looking for api version one and then tasks and then i pass in my router my tasks router and then in the router effectively i have this root path which just matches whatever i pass over here so again i go with api version one and then tasks and then i set up a get route where i manually pass in my controller and here i just say res.send and i pass in a string of all items and looks about right so let me go here and we're going to go with localhost 3000 since it's a get request of course we can access it then api version 1 and then tasks and we should see a string of all items and if we do then of course we're heading in the right direction so the last thing that i want to do in this video is to first close my express tutorial one and then in the controllers we want to create a new file and we'll call this tasks.js and again just to jog your memory the whole deal why we're setting up separate routes and separate controllers because if i'll try to jam everything in app.js it's going to get messy pretty fast so what i want to do right now is take this logic and place it in a separate file because eventually of course there will be way more logic than just res dot send so i'm going to go to my controllers and effectively i want to create my function the controller function and i'm just going to go with const get all and then tasks and i'll set it up as an r function i'm looking for rec and res and functionality will be exactly the same whereas dot send and we're just going to go with all and then items and then we're going to go with module exports and since i'm going to add more functions in here i'll right away export it as an object so say get all tasks that's when i'm exporting and then back in the routes of course i want to access it so i'll say here that i wanted the structure get all tasks from and of course we need to require it and in this case we're looking in the controllers so i'm going to go two levels up i'm looking for controllers and then more specifically task so instead of hard coding this value of course i'll just pass it in and i'll say get all tasks and if i go back to my url and if i can still see all items then of course we are in good shape and let me just test it out where i'll change this around and i'll say all items from from the file and then if we go back yep we still have the correct result and with this in place now we can set up the same basic structure for rest of the routes as well beautiful and in the same fashion let's set up the rest of the controllers so we have the get one now i want to create one for the post one for get but that's going to be a single item and we also have one for patch and one for delete and pretty much in all of them the setup is going to be exactly the same as far as functionality i'll just send back and i'll say what the controller is doing since of course we haven't connected to the database or anything like that and i just need to come up with a name in my case i'm going to go with create task and again we have rack and res and then we want to copy and paste since i want to speed this up and i'll just say create task create task and why don't we change this one around and we'll say get all tasks now we want to copy and paste and we'll have three more we'll have one for getting task so get task and here we'll say get single task then we'll have one for updating and that's exactly how we'll call it we'll say update task the same is going to be over here and then the last one of course will be delete and then task and you guessed it we also need to change the text and now of course we want to place that in the same object so let's go with create task then get task and we have update task and last one is delete task and then back in the routes of course we want to import them so say here create task get task then update task and delete one and now we just need to set up the routes if we take a look at the app.js these two the get and post are gonna go to api version one and then tasks and then the rest of them are going to be wii d id params so same initial path but then we'll just add the forward slash and then id and that's of course is where we're going to pass the id of the task so where i have the get request to get all the tasks i'll chain dot post and of course which controller are we gonna use of course the create task one and then we can simply go to the next line and we'll go with router then route and like i said we'll go with forward slash and then id and then we're looking for get route and that will be equal to get the single task then we'll set up our patch and that will be equal to update task and then lastly we have delete one and now we'll be equal to delete task now since we know that we can only really test the single task and get all tasks because that's the default method the browser performs we'll stop over here and in the next video we'll spin up the postman to quickly test all of our routes because trust me you don't want to go any further without knowing that at least the basic setup works because you can set up whatever logic you have over here if there's a small bug and you cannot access these strings then you'll spend way more time later searching for that bug nice job and once we have the basic structure for all of our routes now let's test them out in a postman so i'm gonna head back to my desktop i'm looking for the postman and since in this case we'll spend way more time over here i also want to cover some configuration options so for starters i want to switch to a dark mode because i think you'll appreciate that more so if you want to do that as well just go to the cog and then you're looking for the settings here and then in the settings just look for themes and of course we have a dark theme as well so that's the first thing that i'm going to do then we want to create a collection now why would you want to do that well since we'll be setting up multiple routes and they'll reference the same application which is going to be easier as we create more and more applications and in order to create that collection we go here and click on creating the collection and for starters i just want to change the name so i'll click on these three dots over here and of course we're looking for rename and then i'm just going to go with 0 3 and we'll call this task manager now if you're not happy with this name of course pick your own one and once i have the task manager then we want to start by creating a request so we create a new request it's going to be a get request and instead of typing all the time manually here local and then host and we're going to go with 3000 and then of course api version 1 and then tasks what we want to do is set up a global variable now there's multiple ways how we can do that you can actually set up the environment so think of this as a dev environment and then you can have production environment but in our case we'll just set up this localhost and then 3000 api and version 1 simply as a variable and you can do it from here as you can see they even give you a suggestion on all that but i'm just going to go the long route where we click here on that eye and then notice i have already won for the url i have localhost 3000 and then i actually changed it later to forward slash api so now what i want to do i want to showcase how we can remove it so if i go over here and if i remove it and i set up a new one in this case again i'll call this url and then as far as this value well i'm just going to take this whole thing so i'm going to go with localhost and then 3000 and of course we're looking for api and if you want you can also include the tasks but in my case i'll stop right after the version one so let's copy that one again i'm setting this up as a global but you can set it up in the environment as well and then once we add that we should be able to right away access it so now of course we just need to save it and then in order to use it we need to go back and you know what i'll remove everything for now and if we go with these double curlies this is going to give us access to those variables and all the way in the bottom we have the url and of course as you can see it is global so in here i'm going to go with url i'll close it and then i'll go with forward slash and then tasks and once i save i should get back get all tasks and of course that means that our basic setup works and before we continue and do the same thing with the rest of the tasks now of course we want to save it and not only want to save it we want to save it in our collection so let's click over here save as and let's give it a more meaningful name and in this case again i'll say get all tasks and of course we're looking for task manager so this is going to be saved in this collection and we simply click on save so if i take a look at my task manager now of course i have get all tasks where we use the global variable and we can successfully see our string and i'll close few of these tabs because it's getting quite busy and let's do the same thing for the rest of them so in this case i'm going to be testing the create one the one for the post that's why we need to change the method that's the first thing you want to do then we'll go with our url again we'll close it out forward slash and then tasks and remember now we want to send some data correct now we're not doing anything with that data on a server but just for the kicks why don't we send it i'm going to go here with body then we're looking for the raw and of course we're not looking for text we're looking for json we just need to make sure that we use the correct syntax and in this case i'll say name and that will be equal to testing and we just click on send and if we can see create task we are in good shape now since i also want to test out whether my middleware is working i'm going to go back to my controllers i'm looking for create task and in here instead of just going with send we're gonna go with json so now i'll be sending back the json and i'll pass in reg.body so if you want of course you can log it on a server but in my case i think it's going to be faster if i just send back whatever i'm getting from the client so if we go back and if we change this around and we'll say here shake and bake and if we add a comma and then completed we set to true once we send that should be our response and of course the only thing that's left to do as far as the create route is go to save as and then we'll say create task save it and now let's continue again i'll close these ones just so it's not that busy and in this case i want to go with get route then we want to go here with the url again and of course we haven't set up the database so there's no real id but we can definitely test it out if we just go with tasks and then whatever gibberish so in this case i'm going to go with hello so that's going to be my id so we're not sending anything as far as data but we are using the params again if we take a look at the routes we can clearly see that we have forward slash and then id that is going to be our param and if we want to test it out where we have get task of course we have the request and the id is sitting in the params so in here i'll do the same thing i'll say json and we'll just say id and that one is equal to rec params and the id so if we save here and then go back and just use the get route and click send we have the key with the name of id and then the value is hello so if we'll change it around and if we'll say peter of course the value will be peter again same spiel we got save as and we'll name this update task or i'm sorry get single task my apologies get single task we'll save it and then we have two more we have one for update and one for remove and in order to speed this up i don't think i'm going to do any testing anymore we simply want to open up a new route we want to go with patch in this case and again we're going with url and then forward slash tasks whatever value you want to pass in over here so i'm going to go with one two three send and of course i have update task beautiful let's save that one and we'll write here update and task and the last one of course is delete so let's close these two and again your request we're looking for delete method the url is going to be exactly the same and then we want to go with forward slash tasks and then any of the ids that we have already used since we'll change that later anyway and once we send the response should be delete task now if you don't want to go with save as you can simply click on command s that's going to be a shortcut and we go here with delete and then task and of course we save it in the same task manager and once we can clearly see that we can access all our routes correctly then we can move on to our next topic okay and once we're done with the postman before we start setting up our database let's quickly talk about our routes more specifically why we use such structure long story short it's because we're building a rest api and since these days the term api is used pretty much for everything let's just all agree that in our case since we're building a server essentially we want to create a http interface so the other apps most likely frontend ones can interact with our data that's how we view api in the scenario and when it comes to rest it stands for representational state transfer and arguably the most popular api design pattern and essentially it's a pattern that combines http verbs route paths and our resources aka data so effectively rest determines how the api looks like now let me emphasize something it's a pattern not a strictly enforced set of rules so nothing stops you from setting your own api in totally different manner in fact if you have used apis on your frontend apps you know that some of them have totally different structure i guess the best advice i can give you is this whatever pattern you decide on stick with it or in other words be consistent otherwise it's just going to be very confusing for your users and this is a common approach where you have the main list so that could be orders that could be customers that could be items whatever and of course in our case it is tasks and in order to get all the items we go with get method and then if we want to create one it's going to be the same endpoint but we just go with different method and of course in this case it is post and not to be redundant we already discussed this before but just because they have the same url the same endpoint since the methods are different in this case we have get and of course in second scenario we have post these are two totally different requests please keep that in mind and then for individual item you have the same path pretty much so you have api and then tasks orders customers or whatever and then you just use the params to point to that one specific item and then if you want to get the item then of course it is a get method for update you'll use put or patch and then to delete one you'll use the delete method instead and since json is a common format for receiving and sending data in rest api we'll use that approach as well so even though at the moment we use send method in our routes eventually we'll switch to json method instead also i'd like to point out that rest in general is somewhat fuzzy in fact oftentimes you'll deviate a weight from straight up rest since that's what the setup will require one more thing you can probably notice something essentially our api allows our user to perform a crot operations on our data and crud stands for create read update and destroy and it's a common approach where the api interface is built around crud since those are usually or typically operations that users or apps want to perform on a given data whether it is again users orders customers or in our case of course it is going to be a task and we'll return to credit a little later when i can actually show you how it relates to our data lastly there's obviously more to rest and some of that we will discuss in later projects but since i'm not a big fan of long slide videos and i believe we covered all the major points we'll stop right here and move on to our database setup if you remember in express tutorial the route setup was extremely similar to that we have right now with one big caveat we used basic array to store some list of items on our server and based on the request we performed some kind of operation on the list and then send back the response and of course that is not very serious approach to store our data and therefore starting with this project we'll set up and connect to a proper database and pretty much for the remainder of the course we'll use nosql or nonrelational database by the name of mongodb now i'm not going to dwell on differences between nonrelational and relational databases as well as pros and cons for each of them but the major difference is that unlike traditional database where we have rows and columns in mango divi we can simply store everything as json and basically it doesn't care how the data relates to each other instead of tables we have collections which represent group of items and instead of rows we have documents which represent single item and a document is a set of key value pairs and as far as data types we can use strings numbers arrays objects and many more it's very easy to get started and even though you can set it up on your local machine as well we'll right away go for cloud option since that's something you'll probably end up doing anyway we'll use mongodb atlas which is a official option basically it's created by the same people who created mongodb and since they offer generous free tier you'll just have to create an account and you'll be good to go and once we're familiar with mongodb let's set up and configure mongodb atlas so we can host and manage our data in the cloud i have the account already but since i want to cover all the steps in detail i'll set up another dummy account together and remember we can set up the entire thing for free so don't worry your credit card can stay nicely tucked away in your wallet if you get stuck or confused in any of the steps we're about to take here's an awesome resource you can use just google create mongodb atlas and follow this link which actually brings us to official docs and here you'll find a checklist which we're going to use as a roadmap for the following few videos and what is the first thing they want us to do create a new account so let's do this people i'm going to open this up in new tab and then of course you can find bunch of useful info in here yadda yadda you keep on scrolling and i actually want to navigate to a login page and i'm just going to pretend that i don't have the account and we're going to go for sign up and here of course you just need to provide all the necessary info and once you have filled everything out and as i said no don't worry this is not my real phone number then of course just click on sign up and up next they're going to ask for organization and project name and in my case i'm gonna go with node and express course then i'll pick javascript we'll click on continue and we probably can actually skip this but let's just leave it there and up next they want us to set up the cluster now if you take a look at the checklist actually cluster is already second step so let's go back here and pretty much you always want to show for a free one unless of course you want to start paying them so in here we'll just go with create cluster that's going to be the free one then it's using aws okay awesome as far as region i'm going to go with this one then we have cluster tier and additional settings and we'll leave them both as default and lastly i just want to change the name and i think i'm going to go with node express and project and once we're done we just need to click on create cluster and we'll get ourselves a new cluster now as you can see over here they say that it's going to take a little bit of time which is usually the case so i'll stop the video here and i'll see your next one where we'll continue with our steps and once our cluster is ready to go before we start messing around with data so with collections and documents and all that there's a few things that i want to do first and i'm going to start by setting up the database access so effectively in here we'll set who can access our database now i'm not talking about the atlas account no i'm talking about the database and collections we're about to set up and we simply need to click on add new database user and we're gonna go with password and if you get some default values just wipe them clean and i'll simply go with john and as far as the password i'm just gonna go with one two three four please please please do not do that in your own setup the only reason why i'm doing that because you'll be able to see my password anyway and don't worry once i'm done setting up this project of course i will change my password so it's not going to be one two three four and once you're done with the user and password notice we have database user privileges and this user can read and write to any database so i'll leave it the way it is and we'll add a new user that's good i'll close this one and then we want to set up the network access so we want to set up from where we can access our database and you can already imagine that of course once we deploy the project then of course we'll set up that ip address but for time being while we work locally we might as well set up access from anywhere now if you want you can set up your own ip address here so you can just add the current one but in my case i'm going to go allow access from anywhere and i'll just click on confirm and lastly i want to get the connection string that we're going to use once we connect our database to our application and in here what you're looking for is connect so you want to go back to the cluster then connect and then you want to go with connect your application so not the compass one not the shell actually the second one here connect your application and then i'm gonna go with 3.6 or later that's about right and then you just want to copy this one and then navigate back to our project now eventually we'll set it up as the environment variable yes that's going to be the case but for the time being i'll simply create a new folder in the starter and i'll call this db and then instead of the db there's going to be a new file and we'll call this connect gis and then i want to create a new variable and i'll call this connection string and i'll set it equal to that value now we'll have to add some values over here but we'll do that later once we're actually ready to connect our application to the database so just take the string copy and paste set it up in the db and then connect js and now we can start exploring the atlas setup as a quick side note while working in local setup essentially while working on your computer you can use any of these two options so either access from anywhere or our actual ip address but once we go to production more specifically once we deploy our project to heroku you will need to use access from anywhere option otherwise you'll get an error and you won't be able to connect your app to mongodb now this is specific to heroku for example when it comes to digitalocean another popular option for hosting your node apps if you're using your local address while developing once the project is hosted you just swap the ip address from local to production but the way heroku setup works you'll need to go with allow from anywhere option otherwise you'll get an error and once we have set up database access network access as well as the connection string now let's actually explore the data part and we want to click on collections then we're going to go with our own data and then we need to come up with a database name now the first one will be a dummy one and of course once we connect to our application then we'll create a task manager one so the first one i'll just call store and then they ask us to create a collection and don't worry i'll cover what actually our collections and all that but for time being i'm just gonna go with product and then we'll create one and once we have everything in place we are ready to start creating documents so whenever we talk about mongodb we'll have the database so that essentially is going to be that application again in our case eventually this will be the task manager one and then inside of that database we'll have collections now if you're familiar with regular databases you can think of them as tables and in our collections we'll have group of mongodb documents so if i name my one products you can probably already guess that here i'll have list of products and if i'll decide that my store will also have users of course i can go here and create a new collection and as a quick side note we won't have to do this manually i'm just showing you the general setup manually of course eventually all this is going to happen automatically once we connect from our task manager so i have a list of products and then of course i can also create a list of users or list of orders and hopefully you get the gist and once we have our list now let's talk about the individual items so i can go to any of my collections and then once i'm here i can insert a document and document in mongodb effectively represents that one single item and what's really cool that just like javascript object effectively it's a set of key value pairs now by default the moment we create a new document we'll get this underscore id which is going to be that unique id so we don't need to worry about the ids and then of course we need to set up a type so what is going to be the type for our document what is going to be type for the item and if you click over here as you can see these are options we can set it up as an array binary boolean and yada yada and i'm purposely not going to spend too much time on types since eventually we'll set it up from our server anyway and at that point the setup is going to be a bit different since we'll use tool called mongoose now in our case what are we looking for well we're just looking for the string i'm just going to go here with name and then i'll set it equal as first and product so here of course i can insert and now not only i have the product collection but i also have my first item my first document and here comes the biggest gotcha in mongodb documents have a dynamic schema and what that means in plain english is the simple fact that documents in the same collection don't need to have the same set of fields or the structure so if i were to go to insert document and instead of string i'm going to go with array and i'm going to call this colors and then i'll set my first one to be red then second one blue and if i'll save it as far as mongodbe is concerned they're still the same items in this product collection so nothing stops you from doing that now just because you can does not mean you should and therefore we will use additional library by the name of mongoose which will set up that structure for us but as far as straight up mongodb yes both of these documents are still part of this product collection even though their structure might be totally different few videos ago while discussing arrest i mentioned crud create read update and destroy or delete and now i want to quickly show you how is that going to look like with our current manual setup i fully understand that some parts might look really silly especially the read one but in my opinion it's important we start with the basics and hopefully that way we'll have a better understanding of overall principles when we need to implement crud in our rest api so what does crud means in our manual setup well first we want to create an item correct so in here we just find any of the collections and in this case i'm going to stick with products since i already have some items over here and then we simply go with insert document and again we just come up with a type and then some kind of value and my case i think i'm gonna go with another name and i'll just leave it as a string and i'll say test crud i'll insert the document and i'm done so we're done with the first part where we created an item now the second one reading them well we simply stare at the screen and we can see that we have three items so i can see that i have three products again in our application that just means that we'll be able to read the documents that we have in our database when we're working with gui it's very straightforward where you're just staring at the screen then we want to update them and then with the manual approach we just look for this little pencil and we say that we want to change some values around here so in here i could go with another item and i'll say green so now of course i have successfully updated the array as well and you know what let's also add one more and i'll call this orange then i update and i'm done with that part as well so not only we can create read but we can also update and then last one delete well we simply look for another icon in this case we are looking for the trash icon so we just click here and now of course we remove the item so that's the basic approach of crud in our manual setup all right and once our database is ready to go now we need to connect to it from our server and we can definitely use the native mongodb driver and i believe the package name was just that mongodb but a very popular alternative is to use package by the name of mongoose instead which is a object data modeling library and essentially the reason why it's so popular and why we're going to use it in this and rest of our projects is because right out of the box it comes with bunch of goodies that make our development faster now i'm not going to list them in this video since you'll see them in action in all of our projects just let me repeat that yes you can set up your apps with just native mongodb package but the reason mongo's is so popular is because it has extremely straightforward api and it basically does all the heavy lifting for us when it comes to our project i already installed mongoose so we can start using it right away but if you want to use mongoose in your own future project the command is npm install and mongoose and one last thing in this project we're going to be using mongoose version 5 something so if by the time you're watching this if they have a higher version pretty much everything starting from six so if you have five point i don't know 14 15 or whatever you'll be still in good shape but if by the time you're watching this they already have version six their api might also be different and at that point you have two options install this particular mongoose version or just use the latest one and utilize their docs as a quick sign note since i recorded the course mongos did come out with new version version number six now the good news is that as far as i checked the only change that affects our project is the lack of deprecation warnings which we're going to cover in the next video rest of them don't really affect us now i still suggest using mongo's version that's already installed in the starrer while working on these projects but as far as i have tested and the current student feedback you'll have no problem implementing the knowledge in your own project with version 6 instead all right and once we're familiar with mongoose let's kick it up a notch and finally start using our database on our server and the first thing we need to do is to set up a connection and at least a basic setup is going to look something like this where we're going to import mongoose and of course we're going to do that in connect.js so i'm looking for db folder and then more specifically for connect.js and then here at the top above the connection string i'm going to go with const mongos that's the name of my instance and then that is equal to require and of course i'm looking for the markers and once i have the instance then the method name is connect so we go here with mongoose.connect and the first thing we want to pass in is the connection string but if you remember i said that we'll have to make some changes take a look so this is going to be my username correct but then what is the value for the password of course that is some dummy value so in here we need to pass in our actual password so in my case of course that is one two three four but i strongly suggest using more secure one for your application and then here at the very end we have my first database so this is what they set up by default and that's going to be the name for the database if i don't change it and you're probably wondering well wait a minute i mean we didn't set this up on the atlas so why it's here you see if it's not going to be there it's going to be created for you so here you have two options either you can just go with this one or in my case i'm going to remove it and again just make sure that you don't remove more than you should so you want to remove everything starting with the forward slash all the way to the question mark and in here of course you need to come up with a name and in my case i'm going to go with the same name as my application so since i have 0.1 for no tutorial and then task manager is 0.3 that's exactly what i'm going to set up over here so i'm going to go with 0.3 then hyphen and i think i'm going to go uppercase so i'm going to go with 0.3 task and manager again this is going to be the database name and if you haven't created that database already they will create for you and once we add these changes our connection string is ready to go so now we simply need to pass in as a first argument now the second argument is going to be options and effectively this is where we'll pass in some values just to avoid some deprecation warnings and you'll see what i'm talking about in a second but for time being we'll just leave it empty and then this returns a promise so we simply can go with dot then and since i want to see whether i'm successful as far as the connection i'll just pass in the callback function and i'll say log and of course i'll remove the semicolon and i'll say connected connected to the db dot dot and then since there might be an error as well we also want to go with catch and of course we'll just be looking for the error so we have our callback function and i'll say error and we'll simply cancel log the error so we'll say here cancel log and i'm going to be looking for the error and once we save nothing happens and the reason why nothing happens is because we're not executing this function yet but if you remember during tutorial one of the first things that i covered is the fact that if we have a function in a module where the function is effectively executed there and then we only need to import meaning require the module and will right away execute the function so i simply want to navigate to app.js and then this is just temporary because we will change this setup around this one we won't leave it this way i just want to get the connection up and running and therefore i'm just going to go to app.js and then we go with require and notice i'm not assigning this to any kind of variable simply go with require then we look in the db and then more specifically we're looking for the connect and once you save you'll have tons of deprecation warnings and don't worry we'll fix them in a second but all the way in the bottom if everything is correct over here if you pass in the correct password and you grab the correct connection string then you should see connected to the database and if i want to test out the error i'll simply remove the four since i know that that is going to be a wrong password so once i save now of course i'll have this error so i'm just going to keep on scrolling and notice here it's going to say atlas error and of course i already know why because my password is correct and if we'll take a look at our graphical interface in the atlas once we refresh we're not going to see any changes because again we haven't set up any kind of logic so you're looking at it you're like okay i still have one database what's happening don't worry once we start adding the items that database will be created for us in my case 0.3 task manager and even though i will refactor this in the next video because there's some gotchas that i want to talk about before we do that i'll show you how we can remove those deprecation warnings in a console and if you remember we just need to pass in the second argument which is going to be an object and in here we just need to pass in following key value pairs and we'll start with use new url parser and we'll set it equal to true then we'll look for use create index we'll set that one equal to true and then we'll go with use find and modify that one will be false and then lastly we want to go with use unified topology and that one will set equal to true so once i save now i don't have any of those warnings i simply see server is listening on port 3000 and then i have connected to the database and if that is also something that you see in a console you are in good shape and we're ready to move on to the next step nice we have successfully connected to the database and life is great but before we start messing around with the data there's something that's bugging and simply the fact that our server and database connection don't work in sync now what do i mean well let's take a look at the console so first i have console log that our server is listening on port 3000 and only then we're connecting to the database but if we think about it what is really a use for our server if we are not connected to the database whatever we're about to do is going to fail anyway so what i'm trying to say is wouldn't it make more sense if we try to connect to the database and only if we're successful then we spin up the server if not well then we'll just kill the application and in order to do that we need to restructure our code a bit where i'm not going to invoke mongoose connect in the connect.js i'll refactor the code and i'll set it up as a function and instead we will invoke it in the app.js and in order to do that we'll just remove this dot then and catch now options of course stay we're not doing anything with that and here let's create a function we'll say connect and db and that is equal to our function so essentially we're setting up the arrow function and eventually we'll set up the env variable and effectively we'll pass it from the app.js and therefore i'll add the parameter here the url for time being we won't use it we'll do the same thing what we did before where we just passed in the connection string that's coming up in next video and then i want to grab this mongoose connect cut it out and then from this connect db i just want to return that result so effectively what we're returning we're turning a promise correct and then all the way at the bottom we're going to go with module and export so now of course we want to export it and where we want to export of course connect and db so once we have this setup then we'll just have server is listening on port 3000 because now of course we want to assign it to some kind of variable and again the order is really up to you but i'm just going to put it below the task so i'll just move it over here below the tasks and i'll say that that is equal to connect db so effectively i'm just getting that function over here and i'll set it equal to the required one and then once i have access to the function then all the way in the bottom i want to set up one more function by the name of start and in this function we will invoke connect db and then only if we're successful then we'll spin up the server so let's go somewhere here in the bottom and we'll say can't start again we'll use the arrow function and since i know that my connectdb returns a promise correct i can set this function as a sync and that way of course we can use the await keyword and every time we have a synchronous operation it's very useful to set it in the try catch block so that way if there is an error we can handle it as well and in try block we'll pass in a wait so since i know that it returns a promise i'll use my await keyword then i'm going to go with connectdb again eventually we'll pass in the string coming from the env file for time being we just have hard coded e and d connect js and then only if we're successful then we'll spin up the server so i'll move this line of code right below the connectdb and again we'll just spin up the server if the connection is successful if not we're gonna go with console.log and then we'll just look for the error so once we save nothing happens we don't spin up the server because of course now we have a function so all the way on the bottom i'm just going to go with start and then you'll notice that there's a console log for the server now of course we don't have the console log for the connection because we removed that in connect js but if you really want to test it out again go back over here and just mess with your password and you'll right away see that we'll get that error in console and in here it says bad auth authentication fail so we know that our setup works so if of course we will have a wrong password then we won't be successful however if everything goes smoothly then we should see that our server is listening on port 3000 not bad not bad we have set up the connection we have refactor code and we're almost almost almost ready to start tinkering with the data but there's one last thing that i want to do first and that is simply setting up the dot env file now why we would want to do that well let's think about it eventually we might push this up to the github correct and what do you think is going to happen the moment i push this up to the getup of course everyone who takes a look at my repo can nicely grab the string and then tamper with my data and how we can avoid that well the solution is to set up dot emv file where we can keep our secret and then in our application we'll have to use a package by the name of dot env and of course i already installed it for you and then we'll be able to access those secret variables anywhere in our application and once we push this up to the github if we add git ignore so dot git ignore file and then in here we specifically say which files we want to ignore and make sure that you add dot env now i also added node modules because that is common practice since that folder is so big but as far as keeping secret secrets make sure that not only you set up dot env and of course use the package because otherwise you won't be able to access the variables but always always always the moment you set up dot env also set up dot git ignore and that way we'll just push this up to the github and then dot env will be ignored so when people come and see your repo they won't see this secret connection string so let's start here by creating dot env and in my case i'm going to do that in the root so i also suggest you do the same so i'm going to go to the starter i'm looking for new file and i'm going to go with dot and then env and in here we have again key value pairs however we don't need to use the quotation marks and i think i'm going to go with and then uri in this case so i'm not going to go with long name the connection string and then you simply want to take this value so cut it out from the connect js go back to dot env set it equal to my uri and then where i have connect js i can simply remove it and then remember when we were setting up the function i said that i'm going to be looking for the parameter but of course initially we were not using it now of course i want to use it so i'll remove the hardcoded connection string and i'll say url and we'll just save now there's going to be an error don't worry because of course we're not passing that connection string notice over here we have the parameter blah blah blah is undefined okay that was expected now what we want to do is go to the app.js since over here we invoke start and then we want to pass in that value from the dot envy into the connect db and in order for us to access those secret variables we simply need to require that package so i'm going to go below connect db and we'll just say require and notice how we don't have to assign it to any kind of variable we just go with dot env and that's the package name and as i said if you want to install you just go with npm install and then the package name dot env pretty selfexplanatory and then you want to use process dot env and then whatever is the variable name so let me save my dot env and then back in the app.js once we require we just want to go with dot and config so essentially we just want to invoke the config so now if we keep on scrolling where we have the connect db we want to go with process dot envy and remember that was one of those global variables we go with dot env and then we go or whatever the name for your variable is in my case that is uri and we'll save it and of course we're back in business because i have server is listening on port 3000 again very very important if you want to keep your secret variables actually secret set up the dot env get the package and you'll be able to access them anywhere in your application by using process.env and then whatever e is the name of the variable beautiful and once our connection string is a env variable now let's set up the structure for our future documents and assign them to the collection and we're going to do that using schema and model from the mongoose and the way it's going to look like we're going to go to our starter and we'll create yet another folder and in this case we'll call this models and then inside of the models we'll create a new file and we'll call this task.js so i'm going to go here with task.js and then the setup is going to be following where again we import mongoose and we set it equal to require and then mongoose of course and then we're looking for mongoose.schema so we set up a new variable and i'll call this task schema schema and that is equal to new so we're using the constructor and we go with new mongoose and schema and you're probably wondering okay what on earth is happening well if you remember when we were setting up the atlas manually one of the first things that i mentioned is the fact that for our document there is no set structure but that's exactly what i want where for my tasks i only want the name which is going to be a string and a completed property which is going to be a boolean because you would have to agree that it's not going to make much sense if somewhere in my tasks i'll have an array with the color values correct so therefore we go here we go with schema and using schema we'll set up the structure for all the documents that eventually we'll have in our collection and the syntax is following where again we use key value pairs and eventually we'll set them equal to an object and we'll pass in more options but since i just want to get something quickly in our database we'll just start quick and dirty where essentially i want to come up with a key in my case again that is going to be name and completed so those are going to be the two keys and i'll just set up the types so that is a bare minimum where you go with the key name and then the actual schema type so what type of data this is going to be and if you're interested on what options we have just navigate to mongoose official docs and then look for schema types keep on scrolling and then of course you can see string number and yada yada so i'm going to navigate back and i'll say name so that's going to be my first key and i'll just set it equal to string then comma and of course i'm looking for completed completed that is going to be my second key and that will be set equal to boolean again barebones setup will do more complicated a little bit later and then once we have the schema so essentially once we have the structure for the data now we want to set up that model and think of model as a representation for the collection so these guys are sticking in the product so now of course we'll create tasks collection and then all the tasks that we're about to push into our database of course will be added to that specific collection and what's even more cool in mongoose a model is a wrapper for the schema so if the schema defines the structure for the document like the type validations and etc a mongoose model provides an interface to the database so using the model will be able to create update query and delete our documents with great ease since the api is extremely extremely straightforward and you'll see what i mean in the upcoming videos and we do that by creating a model and we right away export so go with module dot exports and that is equal to mongos then model and then model is looking for two things it is looking for the name and then we want to pass in the schema so in here i'm going to go with task and then comma and of course this is the schema that i want to pass in so say here task schema and once we're done with this the only thing we need to do is go to our controllers and start using our model beautiful we have set up our first schema as well as the model and of course we want to start using it and yes we will use it in controllers therefore we'll navigate there and i'm going to be looking for my model and i'll assign it to the task variable i'll say require i'm looking in the models folder and then more specifically task and then before we continue let me just give you a brief overview of what we're about to do so if we navigate back to mongoose docs and more specifically if you're looking for the models we can find here more info you can see that models are fancy constructors compiled from schema definitions an instance of a model is called a document and then they give you this example pretty much everything that we did in last video apart from the fact that of course they have different values and here we have nice explanation that the first argument is singular name of the collection your model is for since mongoose automatically looks for the plural lowercase version of your model name so effectively eventually we'll have the tasks then i mentioned one more time that the instance of the model is called document and there are few ways how we can create one we can go this route or we can use dot create and here they showcase the callback function approach but we can also use a weight and essentially what create is looking for well it's looking for the object with those properties so in our case we have name as well as the completed correct and of course we can pass this manually but wouldn't it make more sense if we just go to create task route and since we know that in there we can access the task data in the request.body why don't we just pipe it through and pass it along to our model create method and it's going to work something like this where i'll grab the body of course it's going to be coming from my postman here shake and break and the value will be true and then instead of sending it back we'll pass it into task dot create now since i'm going to be using a weight on a task dot create of course i want to refactor this and i'll say that this function the create task actually is going to be async so my controller will be async and then instead of the function body i'm going to go with task and i'll set it equal to a weight like i said i'm not gonna use the callback function approach i'll use a weight instead and we'll await for task dot create and like i said if you want you can hard code this here you can say name and then first task and of course we can do the same thing for completed but i already covered why it's going to make way more sense if we just take this rec dot body so whatever we're getting from the postman and then let's just pass that object into task.create and let's see what happens so i'll remove it here and i'll just say rec dot body over here and as far as the response well now i'm just waiting for a task so instead of wrecked that body in response i'll place my task and i also want to add the status and if you remember the correct status was 201 effectively that is if you have a successful post request and then instead of json being equal to rec.body we'll pass in the object and in here we'll pass in our task and then once we save again nothing happens because we haven't triggered the post request but if we go back to the postman and if i click here send what i should see is this i should see the task so that's my object and now check it out we have this underscore id and what that means well that means that we created a new document with the following properties we have name we have completed we of course have the id like i just mentioned and we also have this underscore underscore v so of course these two are created by default every time we create the document and then these ones we provide so if you want to keep on testing we're gonna go with second task and we'll set maybe the completed to false again this is all quick and dirty just because i want to have some data in my database there will be still some modifications to the code but if we can see the successful responses where we have tasks with underscore id what that also means my friends is that when we go to our database and if i refresh check it out now of course i have the task manager like i said that's my database and what do you know of course i have the tasks collection now what do i have in task collection i have documents what documents shake and bake and second task and if you have the same result congrats we're off to the great start nice at this point we can successfully create new tasks and persist them in our cloud database so now it's really just about applying the same concepts to the rest of our routes but before we set up the rest of the four controllers in a similar fashion there are a few important things that i want to cover first for starters i just want to showcase that since we set up our schema only the properties that we specified in our schema will be passed on to the database and everything else is going to be ignored don't believe me let's try it out first i just want to showcase that in our schema we specified two properties name and completed so now if i go back to the postman and i'll just set up testing schema that's going to be my name testing schema i'll leave completed as false but if i try to add some properties that are not on my schema effectively they will be just ignored so my guys i'm just gonna say random is equal to random now i do still need to use the proper jsons index and then i'll just add the amount and i'll set it equal to five now you can add 10 000 properties and again the result is going to be exactly the same so i'll just leave these two and we'll try to send it so here i send and then check it out now what i get back is only the name and only the completed again let me repeat only the properties that you set in your schema will be passed on to the database everything else will be ignored which of course is really really cool because that way we can avoid this mess where if you remember back in the store when i was setting up the products one has name the other one has the colors because there is no structure for these documents when we use schema there is a structure so whatever we set up in a schema is going to be passed on to this database and whatever comes as an extra is just going to be ignored all right and once we've got that out of the way next i want to talk about validation you see even though we only accept the properties that are specified in the schema our current setup has one big doozy there is no validation so essentially we can pass in empty values how is that gonna look like well again we can go back to the postman and in first example i'll just remove completed and i'll pass in the name as an empty string now i do need to fix this comma here but you'll see that actually we're successful so i can create item this way and what's even more interesting is that i can send an empty object and i'll still be successful and you have to agree that actually this is not the best setup correct so that way we can just set up a bunch of empty items now what can we do about it well we can add the validation to our schema now before we continue though let me just say that when it comes to validation since it's a pretty big topic we'll just be scratching the surface the plan is to show you more features as we progress with the upcoming projects since i have a feeling that if we'll spend the next hour or two on just validation understandably a lot of you will lose interest and attention don't worry though the end of the video i will show you where you can get more info so at the moment we have a very minimal setup where we have properties and we just specify the type however we can set up our properties as objects and then we can also set up builtin validators how is that going to look like well i'll remove the string part from the name and then i'll set it equal to an object i'll add a comma of course since i need to keep the proper syntax and here the first property we want to set up is type now it's still going to be a string but now of course we can add more validators now what validators can we use for starters we can go with required so what this is going to do is if i pass in the value the object without my name property then it's going to spit back big fat error now at the very basic level you can set up equal to true or false either it is required or not but if you want a custom message you can actually set it equal to an array where you go with the first value again true or false and then you add a comma and then you pass in that custom message and in my case i'm going to go with must provide and name now what else i can do well i can trim to imagine the scenario in a postman if i go here with name and if i pass in here spaces and then john effectively with our current setup that's exactly how we'll save it in our database and if i don't want that i can simply go back where we have the object and then the property that you're looking for is trim and we'll set it equal to true and what's also really nifty that for strings we can get min values or max values and in my case since i don't want my value to be bigger than 20 characters for the name one i can go with max and property that we're looking for is length make sure that you spelled correctly this is always a doozy for me when it comes to length and again we'll set it equal to an array and i'll say that the value for my string is going to be 20 and then in here we'll just go with name cannot be more than and of course we'll set it equal to 20 and nine characters and essentially we're done with basic validators for name because like i already mentioned i really just want to scratch the surface so you get the main idea and then as we're progressing with the project then of course we'll implement more features and i want to do the same thing for completed where i'm not going to go with required hopefully this is clear and you'll see in a second what kind of error we have if we don't pass the name but for the completed i just want to show you that we can also set some default values and again we want to remove this boolean and we're going to go type we'll set it equal to boolean and then as far as the default value the property is simply default and as far as default in this case for the task property completed i think it's going to make most sense if we'll set it equal to false again just to showcase how is that going to look like in a real project so as i'm adding the task new task by default it's not going to be completed and only when we navigate to a specific task page and i say yep it's completed now we can add it and then of course we can navigate back to all the tasks this was just my setup of course there's a million different ways how you can do that but that's why in here when i'm setting up my validators i set my completed one to be equal to false so now of course we can save it and we can test it out so i'm going to navigate back to my setup here in a postman and as you can see completed is still not required and that is done on purpose so essentially i already set this up as default false so i don't want to set it up as required therefore we don't need to pass it here but i just want to see how it nicely is going to trim and how we also will get errors if we don't pass in any values so in here let me just try with the john and notice once we send we actually get trimmed value back and completed is set to false right away okay that's an awesome start but notice what happens if we send an empty string so let me remove all the values let me click on send and now check it out so we have here this sending request and the reason why we're not getting anything back because we have big fat error in our console we have validation error and there's few things that we need to understand about this error first it is caused in a task schema because we finally set up the valve there and we set it equal to true and of course we're sending empty string so that's the same thing as if i were to send completely empty object over here so if i cancel it and if i send it again notice again we're not getting the response that's point number one number two if you take a look at the console you see that we have this unhandled promise rejection and this error is originated blah blah blah blah and long story short it is caused in our create task because we have a weight keyword however we're not handling this gracefully we don't have the try catch block where we set up the await in the try and if there's an error then of course we do something about it and since this video is already getting quite long i'll actually do that in the next one so just put this one on ice and then in next video we'll set up a proper response and just to recap as far as basic validation we just need to set our property equal to an object then we need to set up still the type and in our case that was the string and then we can go with the required if we want to have a custom message then we just set it equal to an array and the first item is going to be the value whether that's true or false for required and then the second one will be the custom message then for the string we can also use trim and that's just going to make sure that we don't have any white space and you can probably already guess that there's one for the min length as well and in a completed one we covered how we can add a default value as well so for this one we set it equal to false and if one of our validations is going to fail then of course we won't be successful of adding that item and like promised if you want to learn more about validation just head on over to mongoose docs so navigate here and then you're looking for the validation and as you can see there's quite a bit of info here so if your idea of good time is scouring through the docks you won't be disappointed not bad not bad i think we have good general understanding of the basic validation in mongoose so now let's switch gears and talk about how we can handle it more gracefully because at the moment well we're just leaving our user hanging correct so if the user sends some kind of request with incorrect data then of course we have the error here on the server but as you can see the user is just hanging and probably it's not the best approach and again the whole reason for that is because we have a synchronous operation however we're not handling if there is an error and the fix is following where we want to go with try catch and then we want to place our await in the try block and also right away set up my response so if we are successful i still want to send back the response with our task document the one that we're getting back from the model and then the second thing if there is an error what do we do well we could also send back the response and in this case the status is going to be 500 and effectively that is just a general server error and as i said i'm purposely using just a general server error status code the 500 one since we'll discuss errors in greater detail later in the project and then we can go with json and i'll set up the message property and i'll set it equal to my error so now if we save and if i go back and if i send one more time you'll notice that instead of hanging we actually get a response and in here i can see that the status is 500 so it's definitely our response and at this point in time you probably have two questions first do we really need to wrap all our logic in every controller in trying catch since i can give you a hint that in the remaining controllers we'll also use the functions and we'll stick a weight in front of them and the short answer is yes for timing we'll have to do that but then eventually by the end of the project i'll show you multiple ways how we can simplify that and how we can omit this boilerplate code for try and catch then your next question probably is okay we get the response but this error seems a bit lengthy can we make it shorter and my answer again is yes we can and the most basic approach is going to look something like this instead of setting message property equal to another parameter just simply set it equal to generic there was another string value as far as more complex setup i'll discuss it at the end of the project since i want to keep moving along with the rest of the functionality as far as my setup i will keep sending this giant object since that way i can show exact error messages we're getting and as far as our api i think we're actually in pretty good shape where we can create a task we do have some basic validations and if there is any kind of error well we simply send back 500 that there is a server error and we send back error message yes quite long one but at least it's better than leaving the user hanging and if we want to try out the max length and simply go here with name and then i'll just add some gibberish just so it's more than 20 characters so let me type it out here and then once i save again we get the error message where we have name cannot be more than 20 characters that should do it for this video and now we're ready to move on to our next topic and once we're done discussing the validation as well as the need for try and catch since we have a synchronous operation why don't we continue with our controllers and up next i want to work on get all tasks so we know already how we can create a task we know that we have a model in the model we pass in the schema and then in order to get the instance we go with the name of the model and of course the method name is dot create now what about rest of the correct operations and again we'll use our best helper the mongoose docs and if we navigate there and then if we look for queries then we can have this nice text where it says mongoose models provide several static helper functions four and this should be already familiar crud crowd operations and each of these functions returns a mongoose query object now we'll work with query object way more in the next project but for time being we just need to understand that on every model we have these methods that we can use starting with delete menu all the way to update one and the one that we want to use right now is this one the find one and i'll just open this up in a separate tab and then we can see that as far as the parameter we want to pass in the filter object now what does that mean well it means that if i'll leave this filter object empty this is just going to get me all the documents so in our case this is just going to get us all the tasks now if we start supplying the values for example in our case we could say completed equal to true of course that is going to get us what that is going to get us only the documents that are completed again the way i've set up the projects of the next project the second project is the one where we'll take a deep dive into the filtering sorting and all that for time being we just need to understand that if we want to get all the documents which is going to be in our case for the get all tasks controller we simply need to use find now it's also really interesting is the fact that if we go back and if we keep on scrolling we can read that a query also has dot then function and thus can be used a promise now there is a caveat where technically it's not returning a promise that's why i say here used as a promise and essentially what that means for us is that yes we can use a weight so for simplicity we can stick a weight in front of it and we'll be in good shape however if you keep on scrolling you'll read that queries are not promises and there are situations where it's really important but if we keep on reading here they have that then function for async await as a convenience so long story short similarly to how we created task with a weight and we set up try and catch block we'll do it here as well and the way we'll do that we'll go with try catch so in here of course there's going to be an error but if we're successful then of course we'll just send back all the tasks so let's start here with const and i'll set it equal to the tasks and the value will be equal to a weight so use a weight keyword therefore in front of the function i want to set up my sync and then i want to go with task so that's going to be the name of the model and then the static function name is fine and since i want to get all the documents in the task collection therefore i'll just stick here a empty object and then as far as the error well in order to speed this up i'll just copy the error from the create task and pass it here as well and now the only thing is missing is our response if we're successful what do we want to do well we want to go with res dot and then we're looking for the status in this case the status is going to be 200 and then json and in here i'll just say tasks so i'll be sending back the object and then instead of that object there's a property by the name of tasks and as far as the value it's going to be equal to whatever i'm getting back from the find and i'm just using the es6 shorthand where if the property name is exactly the same as the variable for the value well we can omit the second part and effectively it's the same as if i were to write like this so we have tasks equal to tasks and then with es6 we can just shorten this up and once we save and if we go back to the postman and you know let me fix this one i'll say here properly i'll say testing testing task because i want to save that create one so i'll save it here so it stays as our request and i'll close it and then if we go to all the tasks and we simply hit send now what we should see is of course our object and check it out now we have all the tasks so we have our array and then inside of that array we have items of course each item is represented as an object so successfully we have set up the second route as well for all the tasks and here we use the find static function and we pass in the empty object which just gets us all the documents in the collection and in our case of course those are our tasks and then if we're successful if there was no error we just go with res dot status so we set up the status for response and we send back a json and i just jam all my tasks inside of the object and set it equal to the tasks property awesome and once we have set up the controllers for create task and get all tasks next i want to work on get task and effectively in our application that route provides info about specific tasks so in here i can see all the tasks i can create one of course but if i want to edit it i'm going to click on edit button and then notice how i'm getting the info about this specific task of course normally you wouldn't share the id but in this case i just wanted to provide more info so not just the name but also an id so that way you can clearly see that this info is just about this task and similarly i can go to the next one and again i'll get the id i'll get the name and whether it's completed or not now in this video of course we won't set up the edit but at least we'll get that specific info and general the setup is going to be pretty similar to the one we have with get all tasks however we'll also have to implement a specific response if the id that we pass in doesn't match any of the tasks that we currently have and in order to get up and running we'll navigate back to the docs to the mongoose docs and in this case we're looking for the find one static helper function just like we used find in this case we're looking for find one open up new browser window and then notice as far as the parameters we go with conditions so we pass in conditions object and they're very helpful here where they say find one adventure whose country is croatia otherwise no so essentially we use a weight just for convenience we have our model then we have find one and then we pass in the object and in that object we set up what well we set up the condition and in this case they look for the country in our case of course we will look for a task and we'll use the id so i'll say get me the task whose id is equal to whatever i'm getting from the params otherwise we'll get back now so let's now get back i'm looking for get task and remember in here of course i'm getting that params id and before we type anything here in the controller i just want to set it correctly my id because of course initially well i was just passing here repeater but of course that's not the case anymore and since i want to use the id that i'm getting back from the mongol i'm gonna go to all the tasks i'll run it of course i get my list awesome and then pick any of the tasks doesn't really matter which one just look for the id copy this one and then go back to the single task and then of course instead of peter pass in the eddy and send and if you get back the id key with this value with that long string value which is an id then of course we're in good shape and i'm doing this just so we don't have the console log here on the server you can definitely do so but i just think that it's more convenient for us to see those logs here in a postman and then once we have everything in a place i want to go with my get task and here what's the logic well we could start by setting up i sync of course because we'll use the await then we'll go with our try catch block and then i'll move this sucker up and then first we just want to get that id out of the params so of course you can write it the long way but i always like to do the structuring first so we'll go here with const id and then i always prefer giving it somewhat useful alias otherwise you just end up with bunch of ids and then once in a while it's just confusing which id is for what so i'll say grab me the id which is coming from the params but use the alias of task id from now on and then i set it equal of course to rec dot params so it's the same object that i'm getting and then of course we want to use that fine one correct so we're going to go with const this is going to be our document that we're getting back if we're successful and we'll go with await and then task and then find find one and then like i said we pass in the object and in this case i'm going to be looking for underscore id so not the name but underscore id which matches to that in the params so use here task and then id and if i'm successful beautiful we'll send back the task if not then we'll have to send back the 404 response so here we'll go with res dot and we're looking for status so say that everything is correct we were successful and therefore we'll go with res dot status 200 then dot json and then i just want to pass in a task i'll say yep that's the task you're looking for now there also might be a case where there's something wrong with an id where essentially yes we're getting the value from the params but it doesn't match any of the tasks and if you remember documentation then we get null so what is the case then well then i want to check if the task actually is null and then of course i want to send back different response now make sure make sure make sure that you always always always set up here return otherwise what's going to happen well javascript is going to be reading the code and if you don't have the return even though there might be no task well you'll send one response and then you'll send the next one right after that so always always make sure that you have return so that way javascript knows okay so now i just need to return from the function and in here we go with res.status now in this case though of course task that we're looking for doesn't exist and the status code for that is 404 and then again we go with json here and we'll pass in the message in the object and the message we'll be following we'll say no task with id and then colon and then we'll just look for task and then id and eventually of course we also might have the error and i'll talk about these two errors in the next video because that's going to be a common theme that will set up for the upcoming rounds and i kind of want to give it a separate video so in here let's just scroll up and let's just look for that generic one the arrest that status 500 and then we'll just pass in the error copy this one and then scroll down and below where we have the catch of course pass it in so if i go back right now to my postman and if i click on send i should get shaken big because of course that is the id now if you don't believe me we can go back to all the tasks let's keep on scrolling and then i think i'm going to be looking for this testing schema because some of them are actually empty when we were testing out that's when we were setting them up so now grab this id instead go back to single task and then copy and paste and of course now the value is going to be testing schema and like i mentioned previously i'll talk about errors why we have two of them essentially why we have two responses for the errors in the next video but that's how we can set up a route to get a single item so we go again with try catch we set up async and then we use the static function find one and then of course in this case we're looking for the id that has the value the same as in our params if we can find one awesome we send back that specific task if not then we send back 404 and then all the way in a catch block we have our generic error okay so why do we have these two responses where we have four or four with no task with this id and then we still have the generic one well it's simply because we can have two types of errors and in order to show you that we just need to navigate back to the postman and then notice where we have the params where i set up this long id why don't we try changing the last value so instead of b that i have here i'm gonna go with zero and once we send well we should get the message no task with blah blah blah id why well because of course in our database we don't have any item whose id is matching and i can clearly see the 404 that means that of course that that is our response but if we change this around and then instead of keeping the same amount of characters we start removing or adding you'll see this error and the name of this error is cast error so effectively what's happening if we have the correct syntax for the id but we cannot find the item then of course we'll have to deal with it ourselves because essentially there is no task with this id but if the id is actually going to have the wrong syntax meaning it's not going to match the amount of characters that mongoose is looking for then of course we'll get the error from the mongoose and like i already mentioned this is going to be somewhat common setup for us for the upcoming controllers as well because for both of them for update task as well as delete task at the end of the day we'll still have to find that one specific item and if we're not successful then we'll send back the 404 but we'll always have this generic one as well just in case the actual syntax for the id is totally off awesome i think we're moving in nice space and up next i'll actually work on the lead task why well because with update task it's a bit more complicated and i kind of want to leave it as the last one because i promised you that i'll show you the differences between put and patch as well so therefore let's work on delete now most of the stuff is going to be exactly the same so once you're comfortable with delete i think you'll have no problem setting up update tasks as well and just to showcase in our application if we go back to all the tasks if you click on removing the task there we go now of course we just removed the task and the setup is going to be very very similar to getting the task of course the biggest difference is going to be the method or the function that we're going to use and in this case we're looking for find one and delete but everything else pretty much is going to be the same so if you want you can just copy and paste and change the values but in my case since it's going to be a bit more productive why don't we type it out together so i'll go with my sync we go with try catch block now i have simple res dot sends so i'll just remove it all together then we want to look for that id in the params because again setup isn't going to be exactly the same where we pass in the id with our params and we'll call this task id and that one is equal to rec dot params then once we have access to params we just want to go with const task is equal to await again task and then find one and remove or i'm sorry delete so find one and delete and in here we want to pass in the id again so underscore id and that one is equal to our task and then id and then once we have the setup of course then we have two options if such task exists then we send back r200 if the task doesn't exist so essentially if this is equal to null then of course we go with r404 and in this case i will speed this up a little bit where i'll grab the if condition like so and then as far as the response initially i'm gonna go with a json object and i'll set task equal to task but at the very end of the video i'll discuss multiple options that we have so this is the 404 if we're not successful again if that item doesn't exist with that particular id if we are successful we go with res dot and then status and we pass in 200 and then we just go with json and then we pass in the task so essentially that way in a postman we'll be able to see which task we removed and then just like the previous controllers we'll grab our generic one as well and set it up in the catch one so if there is an error there's going to be a message property with that particular so we navigate back to the postman and we're looking for delete task again we have this dummy value in my case that is peter but in your case it might be something else so again we need to go to get all tasks run it so now of course we can see all our tasks and then just pick whichever you want to remove and you know what in my case i'm going to go for those empty ones first because i don't want them in my database anyway so i'll go over here i'll grab the id and then i'm looking for delete task copy and paste and then once i save check it out now of course i can see that i removed this task and i'll remove another dummy one as well so let me run it one more time now i can clearly see that i have only one without a name since i removed the previous one so let me just grab it over here and then back to delete task copy and paste and then send and of course i can clearly see that i removed this one as well and just to showcase again why we have those two errors let's go back to all the tasks let's send and i'll grab the first one for shake and bake and what you'll notice is that if i pass in the id and if i just change the last value so i still keep the same structure then of course we'll get our 404 so no task with id and of course i have 404 now if i'll start adding or removing the items and of course what you'll see is this error so of course this is coming from our catch block hopefully that makes sense and then lastly i just want to mention that as far as this response i purposely set it up here as a task just so we can see in the postman because i think it's a bit useful when we're setting up our first api but by any means you're not limited to sending this type of response why well because usually when it comes to deleting a task you're really not looking for the data here take a look at our front end it really doesn't care what task we're actually removing because the way the functionality works is i click on a button then i'm looking for a response and if the server sends back this 200 then right away on my front end i go like okay awesome i was successful so let me fetch the entire list one more time so it's not like i take that item and then i do something about it no i just say i want to remove the item if i'm successful awesome i'll do one thing if i'm not successful then of course i want to display some error message or something along those lines therefore if you go back and if you change this around to for example and i'll just show you some common ones that you might see in the other apis so let me comment this one out i'll copy and paste and then as long as you go with 200 you can simply even go like this you can say send that's it that's all you have to do and the functionality will still work or you might see something like this where again copy and paste and then if we go with json and some people just go with task and then set it equal to null and you might add a status property here with success and as you can see sky is the limit i'm just showing you what type of responses you might get back because again the main idea is that if you're successful if you're getting d200 already on a front end you know what's happening so most likely you're not going to be looking for that one specific item that you're deleting but again in my case i just set up this task so we can nicely see in a postman what we're moving so i'll remove these two lines of code here and then i'll just set it back to my json where i have task is equal to task and as a quick sign out once we're done setting up the update task route i'll spend an entire video on various options that you have for your responses so just put the pin on that and we'll come back to it a bit later all right and we have successfully arrived at our last controller the update task one and if we are comfortable with getting the single task and setting up the delete task we should be in good shape because yes there's gonna be a bit more functionality because in this case not only are we looking for the id but we'll also need the body since of course we'll be updating something correct and then the second thing we have to pass in some options since by default we won't get right away the validators working and also we won't get the item that we just updated and don't worry of course i'll talk about all of that in detail so for now just to stay consistent i'll move this sucker down i'll move it below the delete task and let's just start simply by accident both of the things let's get the params one and then the body one so we just want to see that we are successful on acquiring both of those things so i'll set this up as async it's just a simple send so i'll just remove it and we're going to go with try catch and for now let's just go with arrest dot and then status we'll set it equal to 200 and then the json one and here i want to grab two things i want to grab my id just double check that i'm getting it properly from the params and also the body so for now above the res dot status let's set up the id one more time we'll say id so we're destructuring from the rec dot params rec dot params and second one is going to be rec.body and if you want you can assign it to a data or whatever but in my case i'm just going to set up the property here and set it equal to directly so let's just say id is equal to a task id and then data is going to be equal to rec.body again why are we going to be passing data well because if we're updating something of course you need that new info correct so if i go back to my application and if i say that instead of walking the dog i want to walk the cat of course i need to supply this name otherwise it's not going to make any sense the same goes for completed i need to pass in that key with the new value and in this case of course it's going to be false so once i click edit notice i'm successful awesome so if i go back to all the tasks now i have lock the cat and in order to test this out again we need to go back to the postman we're looking for getting all the tasks since i want those correct ids and you can pick any of them doesn't really matter i think i like the shake and bake the most so take this one then we need to go to patch the update task one copy and paste and then in response we should see the id correct we're not gonna see the data since we haven't set up anything here in our body at least not right now but we'll do it in a second but of course now we're just getting update task so let's see let me go back here update task probably i didn't save the file my apologies let me run one more time and now i should see the id that matches of course my shake and bake but as far as data there's nothing there why well because i haven't sent anything from my front end right so now let's go to the raw and then we'll set it equal to the json and then we set up our object and remember we're looking for the name and i'll just say testing edit funk functionality i guess and then we're going to be looking for completed and we'll set it equal to let's just double check in here it's true so let's go with false and let's set it here of course now not only i'm getting the id just coming from the params but i also have the data property and in there of course i can clearly see those values again the whole deal why i'm doing this is just so we don't have to console.log on a server and once we have all of this in place now let's roll up our sleeves and actually set up our functionality so i'll remove this one we don't care about this one right now and again we want to go with the task meaning i'll sign up a variable with the name of task and i'll set it equal to await and of course now we're looking for task the model name and then find one and if this one was find one and delete what do you think is going to be this one well it is find one and update and in here we need to pass in a few things first we need to pass in the object where again we set up our condition so in this case again i'm going to go with id matches to that one in the params so underscore id equal to task id that's step number one then of course we need to pass in that new data since we're updating something correct so let's go here with comma and that's going to be the second value so essentially you need to set up the object and set up which properties you're updating but remember we're already getting that as far as wreck that body so reg.body is right away this object so i can simply set up my next parameter like so where i go with reg.body and then we have options object but i first want to show you what happens if we don't use it and then we'll add both of the values in there as well so let's start here again by checking the task because again we might have a situation where there is no task with that specific id and again just speed this up or copy and paste and then if we are successful then of course i want to send back the task i'll say task is equal to task and don't forget the generic error where we go to resdot status and then you already know the rest copy and paste and you'll notice something interesting since we don't have the options you'll notice the following thing where i go with testing edit function okay that's awesome i completed false but essentially what we're gonna get back is the original value so remember the shaken bag effectively this is what we'll get back so once i send notice yeah i get 200 so i was successful but notice the value here it's shaking big and what's more interesting that once i click on getting all the tasks it's actually changed so i was successful so here's the gotcha the reason why is that happening is because we're not passing in the options and as far as the options we want to do two things we want to get the new one back because by default we're getting the old one that's why we were successful but in our update response we got the old value and the second thing what you'll notice is the fact that we're not running the validators so if you remember when we were setting up the model one of the things that i set up for the name was required equal to true now if i try to update item with name equal to an empty string i'm actually going to be successful now again we're getting back the old value and in order to check the new one we just need to run get all tasks notice and i promise you i'll say this for the last time in this video the reason for that is because we don't have the options object and in order to set it up we just need to go back to all the controllers and like i said third parameter is going to be our options and then we simply go with new true so this will always always always return that new item the one that is already updated and then the another property we can run is run validators and we'll set it equal to true so once we do that of course we fixed both bugs so if i for the final time i guess in this video go back to my post man and in here i'm gonna go back to shake and bake and we'll set the value equal to true we should see that right away so i can see shake and bake and if i try to do that without passing anything in the name then of course i'll get my big fat error because when i was setting up the model i said that name is actually required awesome and believe it or not we're actually done with our basic setup as far as the api and in order to showcase that i'll simply go back to app.js and then i want to serve my static files because this is where my app is sitting and of course since our api is up and running we can simply set up those static files the app and the functionality should work and if you remember in order to serve static files we need to use another middleware and we're going to go with app.use we'll pass in express and the name is static and then in here we just simply need to say where the static files are located and in our case of course that is in the public folder and let me just say that if your code is exactly like mine everything is going to work now back in the app.js i don't think we need that hello one anymore so let me remove this one folder out i'll just leave the version one and then tasks and then if i go to localhost 3000 and i removed that hello i should see my app and i can clearly see that these are all the tasks that i currently have and if i want to add new one i'm just going to say testing app and once i add of course i have all the way in the bottom a testing app well effectively i have two but we right away can also practice on deleting so there it is now we can delete the items all the way to second task then if i want to see the single task just click over here notice now i have the task id as well as second task and then eventually if i want to edit well i just click here on completed and i'll say third task third task and if everything is correct we should see task edited now i still need to fix the css but as long as you see the correct text you should be in good shape now of course by the time you're watching this i'll fix this but the idea is following if i try to edit the item without providing the name now of course i'll get error please try again i just need to fix the css more essentially if i'm successful i still get this red color and then once i navigate back now these are going to be my task if you're interested in the actual app just navigate to the public one you'll see that i used vanilla.js just so everyone can be on same page and essentially as far as the logic you're looking for browser objects and i'm not going to show you the entire thing but as far as submitting the new task i'm just listening for submit event then i prevent the default i'm looking for the value in the input and notice that i'm using the axios library and check out the method what is the method name that is post why well because that's how we can pass data onto the server correct now what is the url that should be familiar we have api version one and then of course i'm looking for the tasks and in here i pass in the data so unlike the postman where we were doing that manually now of course i just grab the input and i'll pass it in and if you remember the completed was set to false right from the get go so i don't need to worry about that i just need to pass in the name and again everything is in try catch so if i'm successful then of course what happens well then i add the correct alerts and all that and then i just refetch one more time tasks now if i'm getting the error then of course i'll add different alerts and hopefully you get the gist and just to lastly showcase the delete one if we scroll up a little bit notice the method here and like i previously mentioned the only thing i'm looking for here is the response if everything is correct if i have 200 awesome i just refetch all the tasks if not then there's an error and essentially i don't remove it from my dom that's why i said that technically when you're set up for the delete in most cases you're not going to have to send back that item that you're removing and now it's simply about making this app better because yes we have the core functionality in place we can definitely test it out on the front end and everything is awesome but there's some things that we would want to fix for example i want to remove all these strike catch blocks i don't want to repeat myself in such a way i also want to set up one place where we're dealing with errors and other improvements so in the following videos we'll make our app better so we have the core functionality in place now we just want to make it better all right and up next i want to finally discuss put method versus patch method so why in this api in our routes we used patch and during tutorial we used put so here's the deal yes put and patch are both are both for updating the resource but the assumption is that when you use put you're trying to replace the existing resource and patch is for partial update and since i'm fully aware that this might sound like mumbo jumbo to you let me give you an example so if we go to our postman and then more specifically update task if the id is correct then only the properties that i'll pass in will be updated so in this case if i'm gonna go with shake and bake number two and i'll actually remove completed only the property that is passed in will be updated so if i send check it out now i get the task and i can clearly see that completed is there even though i didn't pass it why well because that's how our functionality is set up in the controller so if i'll pass completed and i'll set it equal to false of course it will be updated as well so if i go here completed and i'll set it to false yes in this case since i'm passing the property of course now i'm going to get the new result now what is the difference with put well let me go the long route and actually set up one more controller but keep in mind that this is going to be just temporary controller so if you don't want you can just sit back and relax and we'll start in our routes where essentially i want to go with my route and in this case i'm still looking for this forward slash and then colon id because again the functionality is going to be almost the same but i'm looking for a different method and i'm looking for put and of course now we just need to create the controller and in my case eventually i'll call this update or i'm sorry edit task just so it's a little bit different so of course i'm not exporting that yet but i'll right away set it here in my structure i'll say edit task and then back in the controllers i just want to go below the update task again this is just going to be temporary but i'll go with const edit and then task and that one is going to be equal to whatever i have over here we simply need to add one more option in the find one and update so let me select this whole thing just so we don't have to type it from scratch and all the way in the bottom we're going to go with edit task and like i said it's going to be temporary so in here i'm not going to save it with all my routes but let me just save my current ones and i'll close all of these windows and let's set up a new route so in this case it's going to be a put route and remember we have our variable so i'm looking for url and then i'm looking for the tasks and of course i want to grab some kind of id so let me get again all the tasks here and i'm going to stick with shaken back because i like that name so much so let me grab this id here then back in tasks i will pass it in and then let's try to recreate the same functionality that we have for now e in the patch and essentially what i really want is just to pass in some data in my body so i'm gonna go here with raw again we're looking for json and we'll set it up name equal to john nothing particularly original and once i save of course now shaken bake has the name of john but here comes the biggest difference between put method that we're using over here and the patch method so idea with put is that if i send only the name my expectation is that all the rest of the properties which of course in our case is just completed will be removed from that item so we will replace that item and how is that going to look like in our controller well here everything is going to be exactly the same but by default mongoose doesn't do that so by default mongoose is going to be like okay so you want to get the item you want to update it awesome just get me the properties you want to update and rest of them will stay the same and if i actually want to remove those properties the ones that i'm not passing in with my request i need to add another option here and the option name is overwrite and we need to set it equal to true so now you'll notice that back in my postman if i send here with name and let's just keep it interesting and pass in peter check it out we have name and the complete is still there now why it's still there well because in our model we have default set to false so there is some default one if i remove it you'll notice that with output method the way the controller works right now if i send it right now then of course i'll just get the name so completed is not there anymore so if i take a look at all the tasks now and the first one actually completed is missing so that is going to be the difference where when we work with put the expectation is that we'll replace the item so we'll just pass in the properties that we want to set up in item and then rest of them effectively will be removed but when we're working with patch we're just updating the properties that we're passing in just remember that in real life you will see the apis where the put method is used with the same functionality as the patch now in our case for the remainder of the project we'll use the patch one instead so therefore i'll remove this edit one and here as well and the same i want to do in routes like i said this is just for demonstration purposes so save it here and i also want to remove this route from my postman just so it's not in a way so say don't save and i'm back to my five routes and of course for the update i'm using the patch one and before we start refactoring our code and adding some extra middleware let's just spend a few minutes on our responses and more specifically on the other options you have when setting them up and i'll use get all tasks route as my example just keep in mind that the same goes for the rest of them and essentially when i was setting up the route i said that you have tons of options here as far as the response so in my case i'm just setting up course djson object and then i set the property tasks equal to tasks but you can also do something like this where i'll copy and paste and i'm going to go with res.status so this won't change we're just talking about the object that we're sending back and instead of simply just sending tasks you could also add the amount of tasks and for this property name of course sky is the limit whatever you want to come up with in my case i'm going to go with amount but you can also call it maybe value maybe the number of hits or something along those lines and here you're just looking for tasks and of course the length like so and also what we could do and i'll just comment these options out just so they can stay for your reference and let me copy and paste so i don't have to type arrest that status also what we could do well i could set up a flag here where i say success is equal to true and then of course we need to keep in mind if that is the case then you also need to add something here where you have the error whether that is 404 error or it's the general 501 so effectively here i just add this extra bit of data where i say yeah the success was true and then you can even place it in the data property and then say tasks is equal to tasks and also maybe add the amount so that's also something that you might see around for example the hacker news api uses the number of hits like so essentially you just get that value and again that is going to be equal to the array that you're getting back equal to a length and once i said of course my response is going to look like this now if you don't like the success one go maybe with status that's also something that you might see around where we set up status is equal to success for the successful responses and then for errors of course we're going to go with status and then fail or error or whatever string value you might want to set up and if you're wondering why am i showing you this is because i want you to be aware of your options so just because i'm setting it this way where i just pass in the tasks of course that's not a rule that's pretty much my preference and why i don't prefer setting up the statuses or successes or the data here that is simply because of the front end so in my experience when we use frontend there's two things that are going on effectively when we have asynchronous responses we already have try and catch and because of that i find the status or success to be a bit redundant because effectively just like i showed you with delete if i'm successful then of course this code will run regardless and then if there's some kind of error then of course i'm gonna have my code e in the cache block and why i don't like setting up the data well because on my front end usually i use axios and if you're familiar with axios it right away returns a data property so it right away has that data object so if you set this response in such a manner where you have data returned in the object then on the front end you'll have data and then in that data object you have another data so essentially on the front end you need to do something like this where there is a data object inside of that data object there's another data object and then you only get the tasks which is of course not the end of the world but in my case again i find it a bit redundant and lastly when it comes tutorials and courses i also enjoy the fact that there's less typing in the setup where i just pass in the tasks so be aware of your options my suggestion is whichever route you pick just stick throughout the api so there's no confusion don't set up one type of response for one route and then go totally different in a different route that's going to be very confusing to whomever is using your api and lastly let me just say this yes you can set up your own api responses however you like but if you want our frontend app the one that's sitting in the public to work properly the responses have to be exactly the same as mine because that's what the app is expecting if you'll set it up willynilly then you might get some bugs not bad not bad once we have discussed our response options next i want to work on route not found so at the moment life is awesome we have our application everything works if i go to index.html of course i can see the application if i go to api then version one and then tasks of course i can see all the tasks what happens if i go with api version one and then hollow so i have cannot get api blah blah blah and i can clearly see in my browser that of course we get 404 error but essentially this is going to be the default one and instead i want to set up the custom one just like they have in algolia one or again if you're looking for some kind of resource and the server can find the resource and essentially we still get the 404 but of course the value here is unknown now it doesn't really matter what you set up as far as the value just want to showcase how we can set up a custom 404 response and the way we do that we go back to our application here and then in the app.js i want to remove these comments because i think we're clear on the rest api and location here is very important so we have the middleware for public and json that still stays the same then we have all our routes for the tasks and then right after that we want to go with app.use and then we'll pass in our middleware function the one that will handle the 404 and send some kind of custom response now we haven't created it yet so let's go back to our starter we'll create a new folder because there's going to be a few middlewares that we'll set up in the upcoming videos so say middleware and then inside of the middleware we want to go with new file and i'll call this one not surprisingly not found and a js and as far as the logic well we'll still have access to erec and res so we just need to come up with function name in my case it's going to be not found and i'll set it equal to rec and res and then as far as the response i'm just going to go with res dot then status and of course in this case it's 404 so the server is letting the user know that it cannot find the resource and then as far as the message i'll just use the simple send and i'll say route does not and exist so now of course we just need to export this and we do that with module then exports of course and we'll set it equal to our not found and then back in the app.js above the app.users we're going to go with const not found is equal to require then we're looking of course e in our middleware so let me say dot middleware and then more specifically we're looking in and not found and then in the app.used we'll just stick not found one and once we save and in this case i'll just use the postman just so you can see that it's gonna work exactly the same and if we're looking for the url and then we'll go with hello now of course we have our custom one we have route does not exist which is pretty awesome and just to showcase that it's going to be the same scenario in the browser as well notice once we refresh we have route does not exist so we set up the middleware folder in there we have not found.js and then back in the app.js we import the function we set some kind of name in my case it's not found and then all the way in the bottom we go with app.use and we pass in the function and in that function we'll have access to rack and res and in our case we're just interested in response and we'll set up a 404 with whatever message we want to send back awesome and up next i want to work on asynchronous wrappers for all our controllers why well because we have asynchronous operations and yes it's very useful to use these try catch blocks but you'll have to agree with me that it becomes somewhat redundant pretty much for every controller setting up try and then catch and as you can see essentially i'm just copying pasting the code around so there has to be a better solution and that better solution is to create a middleware function that essentially we'll wrap our controllers and in there we'll just set up the functionality where we don't have to repeat ourselves and before we continue let me just say that there are some npm packages that do that for us and most likely in the upcoming project we'll use them instead since that way we can save some time on the setup but i think it's very important to have at least a general idea of what the package is doing instead of blindly installing it and therefore in our first project we'll set up the basic logic ourselves and we'll start over here with new file and i'll call this async js and then inside of it i'm just going to go with const async wrapper so i simply create a function at the moment nothing is happening here and then i want to export it so module exports and then a sync wrapper and once we set up the export now of course i just want to go to my controllers and import that middleware so i'm looking in the middleware and i'm looking for async so in here let's just call this a sync wrapper again and that is equal to require then we navigate to our middleware folder and of course we're looking for the async and now what we want to do is wrap all of our controllers now i'm not going to wrap all of them right away i'll just start with get all tasks just so you understand how it is going to work so what we want to do here is just to take this async wrapper this function and just wrap our current controller and essentially it's going to look like this where we go with a sync wrapper and we pass in the controller the current controller as an argument and since we know that we can do that in javascript we are in good shape so we pass it in and then back in the async of course i need to set up the parameter so since i'm passing in already in the controllers my function my controller as an argument back in my sync js my middleware i just need to go with some kind of parameter now you can call this callback you can call this function it doesn't really matter in my case i'm just going to go with fn and what am i trying to do here well i'm trying to avoid this try catch so essentially i want to have my cake and eat it too where i can still use this nice await syntax but i don't have to set up these try catch blocks how can we do that well we set up the try catch blocks inside of the wrapper and the first thing that i want to do from this function is to return another one so in here i'll say return async and then if you remember in the express by default we right away got request response as well as the next so that's what i'm trying to do over here since i wrapped my controller in my middleware and if you pay close attention we're actually invoking the async wrapper right away now of course i want to pass in those request response and next down to my function down to this controller correct because now of course i wrap my controller in my middleware and the way we do that we return another function since i'll use a weight inside of the function body that's why i set it up here as async and please please please keep something in mind where these ones the wreck res and next we'll have access to right away because at the end of the day we return another function from async wrapper and then inside of the function body one of the things that i want to do is pass these rec res and next from express down to this function so hopefully that is clear again we get these ones by default the reason why we have access to them because from our async wrapper we actually return another function so that's how we'll have right away access to them and then in the function body we'll decide what to do with our parameter with our argument which is our current controller and as far as logic i want to go with try catch block and then inside of the try block i'm going to go with a weight and function and here we'll pass in rec res and next and then once we have passed all of these things down to our controller of course now have access to them in here as well and there also since there might be a case for an error we'll go with next and then we'll pass in the error and if you're wondering what's happening over here essentially we're passing this to a next middleware which we haven't set up yet e in our app.js so that's what's coming up in the following videos we'll set up another set of middleware and in this case we'll deal with errors so once we save over here we can go back to the controllers and now i can remove the try catch block so remove the try catch block completely and at this point you should only have these two lines of code where we're waiting to find all the tasks and if we're successful we send back those tasks and as far as the async wrapper we take our controller as a argument and then since we return the function we have access to rec res and next that are coming from the express and we set up the try catch block and in here we have a weight because our controller is still async and we know that by default a sync function will always always return a promise so in here i just have a wait and i'm waiting for that promise to be settled either resolved or rejected and since my controller will still need to access rack res and possibly next since i get them from express i pass it down to my controller and then if there is an error so in here if we trigger some kind of error whether in get all tasks or any of the controllers then of course we'll catch it over here and we'll pass it to a next set of middleware which we haven't set up yet and now of course once we have everything in place now we just want to apply these changes to all the routes now i fully understand that some people are very negative about refactoring the code and to some degree i sympathize with that because i also hold the opinion where it's not very useful if we're all the time refactoring the application but it was important for me to show you the long way first because that way you have a good understanding of how everything works and now we just set up the middleware that actually handles that so let's go back to the controllers and slowly but surely let's add this a sync wrapper to all the routes and the setup is going to be following for all of them where we start with a sync wrapper so we set up our two parentheses here and we need to make sure that second parenthesis the closing one is right after the curly brace correct then we want to remove the try block as well as the catch block and again we'll be just left with wait does that create if we're successful we send back the task and effectively we want to do that for all our controllers so let me go here with a sync wrapper same deal wrap this guy here and then we have try and we remove the catch but we are leaving this one so i will work with this one a little bit later for time being we'll leave it as it is with this response and once we set up our custom error there's going to be some changes here as well let's keep on scrolling we're looking for the async wrapper and again we want to add the closing one right after the curly brace we still pass in the function i'll remove my try i'll remove my catch here and we'll save it and the same goes for updating a task as well so we go here with async wrapper and we'll close it then we want to remove try and we want to remove catch and just to try it out why don't we go to create task and then i'm just going to go with creating task creating task let's try it out everything still works i can create my task but if i'll try to add a task with an empty string value i should get the error and i do but of course this is not the error that we're sending so that's something that we're going to work on in the upcoming videos and once we have set up the async wrapper next i want to work on catching the errors and we're going to start our journey actually in the express documentation so go to expressjs.com and then in search box just type error and first let's take a look at the default one and if you take a look at the first sentence express comes with builtin error handler that takes care of any errors that might be encountered in the app this default error handling middleware function is added at the end of the middleware function stack and if we pass in error to the next and you do not handle it in a customer handler it will be handled by the builtin one why am i telling you this well because that answers this question where is this response coming from well that is coming from the default builtin error handler that's point number one i want to make otherwise you might be wondering well where are we getting this info second next correct that's why in the async wrapper we set up this next and error so we passed it to the next middleware but in our case of course we haven't set up that handler yet so therefore it was just eventually passed down to the builtin one and lastly if we go back and if we say here error so i'll search one more time and in this case we're looking for writing error handlers so this is what we're about to do we'll set up another set of middleware however in this case the middleware will handle errors and you can see that if we want to handle errors we just pass in four arguments and then the first one will be that error and then we want to place that at the very end of our routes so let's just navigate back and of course in the example they showcase how they right away set up the middleware in the app.js in our case since we'll have more code essentially i want to create another file in the middleware so in here i'm just looking for new file and i'll call this error and then handler and inside of the file i just need to come up with the function and i'm going to go the long route where i'll say error handler middleware and that is equal to error again in this case we need to have four parameters request response and we also have next and as far as the logic we'll add more code once we set up our own custom error class but for time being we just want to go with return and res that status and if you remember that's exactly what we had previously e in the try catch block and i'm just going to go to 500 and we'll say json error and error is equal to error now if you want you can cancel log it of course but the result is going to be exactly the same where in here we'll have access to that error the one that is going to be coming in our case from this async wrapper and then we just need to decide what we want to do and i'll just start by setting error equal to error and you're not actually i want to go with message is equal to error and now we simply want to go back to app.js where we have not found let's just copy and paste and now we just need to come up with a name and as you know naming is probably the hardest thing in programming so in my case i'm just going to call this error handler and then middleware and of course that one is coming from the file that we just set up the error handler and then we want to scroll all the way down and right after not found we're going to go with app.use and of course we'll pass in the error handler middleware and once we save and we go back to the postman and try to send the same request meaning the request with a incomplete data then we should get a different response but we don't effectively it looks like i have a bug so let me check the error handler and yes of course i didn't export the function so let me go with module exports and that one is equal to a error handler one and of course if i test it out right now i should see the custom response and we can clearly see that because we have the message now like i already mentioned previously if you don't like these big massive error messages you can simply go back over here and instead of setting the message equal to an error you can just hard code some kind of message so you can go something along the lines of something something went wrong comma try again later this is what we'll see in postman again we send and now of course our message is shorter so essentially this is how we can set up a custom error handler in express where we add another piece of middleware and then in there we have four arguments and the first one is going to be the error and of course in our case the way we pass the errors down to this custom error handler is by using the hsync wrapper and there we have the next so as you remember from tutorial with next we pass it to the next middleware and previously we used the built in default one and now of course we have our own where effectively you can set up whatever logic you want if you want to send this as 200 nothing stops you from doing that but of course a more meaningful response would be with some kind of error code and with some kind of meaningful message whether that is hardcoded string or you can pass in the entire error object and right after we set up our custom error handler let's work on our 404 responses too and essentially i want to set up a custom error class which extends from the general javascript error class and that way we can handle all of our 404 responses in our newly created error handler as well and we're going to start by navigating back to the controllers and the routes or controllers that i'm looking for are following i want to work on update task here we send the 404 then the same is for deleting the task and of course getting the task and let's just start over here with getting the task and simply i want to showcase that we can create a new error object if we run the built in javascript error constructor and we go here with const and no surprise i'm going to call this error and that is equal to new and then we just go with error and here we pass in the message so i can say not found and then next line i'm just going to go with error so now i'm dealing with the object that i just created and i'll set another property on it and i'll say status so that's the name of the property and of course the value will be 404 so now if you want you can console log it here or what we can simply do is use next and pass this guy down to our custom error handler remember that's how it works we call next and then we pass in the error and of course in this case we are creating that error ourselves instead of getting it from the mongoose and the only thing that's missing right now is in our controller because we don't have the next so i want to go here with next and then we need to go with return again i already mentioned why we want to do that because we don't want javascript to keep reading the code now of course we have this one right now but hopefully you get to just where we need to go with return and then next and now of course i want to pass in my newly created error object and once i do that if we go back over here in the error handler and if we simply cancel log we should see our newly created error object so i'm going to go here with console.log and i'll look for my error and now let me go back to the postman and essentially what i want to do i want to get all the tasks and then i'll look for one of the ideas but again i don't want to get that cast error so i still want to keep the same structure i just want to pass in the wrong value so i'll look for single task i'll copy and paste and then instead of three i'm gonna go with four so once we send of course we get our custom error message as vague as it currently is and then of course in console i can clearly see that i have not found so of course that is going to be my message and i understand that it might be a bit confusing but effectively the idea is following where once we create this new our object that property is going to be on there so in order to access the string value we'll have to go over here and simply go with error and then that message and as far as the status well we can clearly see it here we're going to have 404 so now just for kicks what we can do is set up message is equal to error message like i said there's the property on that object and then as far as the status well i can simply change this one around where instead of 500 i'll pass in error and then status and don't worry of course there's more code coming and once i have applied these changes of course we can swing back to our postman and check it out now of course we have 404 and then the message is not found so that's pretty cool now of course we just need to go back to the tasks and set it up in such a way where we don't have to do this all the time manually and the idea is following where again we'll create a new class a new custom error class and we'll extend it from the javascript error and then we'll create a new instance and yada yada and effectively the way we want to do that we want to create a new folder and i'll call this errors pretty selfexplanatory so we're going to go here with new folders and we're going to go with errors and inside of it i'm going to create another new file and in this case i'm going to call this custom and hyphen error and of course i'm going to add the js extension and then instead of my custom error now i want to extend from the error class now here's the deal in this case i'll just write out the code and then i'll go line by line of what's happening because i think that's going to be a bit more productive so let's go here with class and then we just need to come up with a name in my case i'm going to go with the long one i'm going to say custom api and then error now we need to use the extends keyword and since i want to extend from the error class i'm going to go here with error and as far as the functionality we want to go with constructor and here we'll pass in message and status code and then inside the constructor we want to call super then pass in the message and right after i call super i'm going to go with this dot status code and i'll set that one equal to whatever i'm passing in the constructor so in here i'll pass e in the status code and as far as these few lines of code a constructor method is a special method we invoke when we create a new instance of a class and in our case we'll pass in two arguments an error message and a status code then since we're extending basically we're setting up a child class we need to call supermethod which in turn invokes a constructor of a parent class and in our case we pass in our message value as a result we'll have access to all the methods and properties of the parent so in our instance we'll have the message property and with this dot status code we create a status code property as well and that's how we can create our new custom error class and essentially if you want to create new instances you can simply go with custom and then api error and then pass in those two values the message and status code but i actually like to set up a new function that does that for me and here i'm going to go with const create custom and error and this function is going to be looking for two parameters a message and then a status code and what i'm going to do is from this function i'm going to return that new instance so i'm going to go to return new and then we're looking for custom api error and then of course we'll pass in the message here as well as the status code now of course if you want to keep the same parameter names you can definitely do so but in my case i'm purposely setting this up so you can see that this is coming from the function as far as the message and of course i pass e into my custom api error more specifically in the constructor as a message and then of course we just need to export this and we'll have to export both of them and you'll see in a second why so we're going to go with module exports is equal to an object and then we're looking for create custom error and then custom api error and once we have both once we have the class as well as the function and we're exporting both now of course we want to go to the tasks we just need to remember that of course we're exporting object so therefore we'll have to provide a specific name in our case i'm looking here for the function so i'm going to go with const i'll set up my curlies and i'll say create and then custom and error so of course that is my function set it equal to require i do need to go two levels up so in here we're looking for the errors and then more specifically i'm looking for the custom one and then i want to replace all of these three instances and of course i want to remove this manual code as well so start over here and then i'll keep this one for the second just because i want to reuse the same message and the idea is following where we go with return then next and then instead of the next we pass in create custom error and of course we want to pass in the message so that's why i'll just copy this one just because i want to speed this up and then the second thing is going to be my status code which of course is going to be 404 and now we can remove the second line and we just want to copy and paste so it's the same deal over here and the same in the update task as well and once we have all of this in place now we just want to go to error handler so our custom error handler and instead of looking for the function we're looking for the class because in here i want to check if the instance is equal to our customary one then of course i'll pass in the status code and the error message however if there is any other error then of course we'll just go with res.status 500 and whatever we had before so let me go at the top and i'm going to go with const again it is named import so we're looking for custom api and then error and that is equal to require and same deal we go two levels up we're looking for errors and more specific custom error and let's right away set up the default one and this one i'll set it back to 500 here and then as far as the json let's go with the same message i'm just going to say something went wrong please try again and above this return we're going to go with if and then we'll check if the error is the instance of our custom api error then of course i want to go with return and i want to pass in the res dot status and then that will be equal to a error dot status code because of course that's where the value is sitting in that property and then when it comes to the actual message same deal i'm going to go with message and this will be equal to error and then we're looking for the message property and once we save let's go and test it out or essentially if i send it here from the postman of course i'll have no task with this id and if i'm going to mess with the syntax i should get the cast error which of course i do because i can clearly see that something went wrong please try again lastly let me just repeat one more time that error handling and validation is something we're going to return to later most likely in a separate project this is just a general setup just to get you comfortable with overall ideas and later we'll work on more complex validation and error handling approach nice i think we're done with error handling at least for now and now let's talk about deployment and right off the bat i want to say that we're not going to deploy this project simply because we have not covered authentication yet as well as extra packages for security and deploying the project where anyone can tinker with all the data is somewhat irresponsible and it actually can lead to a lot of headaches but with that said there is something deployment related i want to cover and that is our port variable you see hardcoded value like port 3000 or 6000 or 7000 is decent solution in our local environment but when it comes to deployment in many environments the host so the platform where the project is hosted on may want to independently set the port value to whatever makes sense to the platform because as you can imagine it needs to handle more than just one application at the time and in order to make that possible when it comes to port value instead of hard coding to 3000 6000 or whatever we'll have to use the port variable that is available in process.env instead and setup or operator just in case it's undefined and in order to set that up we need to go to our port variable that's why in this case we set it up as a variable and then before d3000 we actually want to go with process and then dot env and then we're looking for the port variable so we go here with port and then if it is set then of course we'll use that value if not then we'll use the or operator and then of course we're going to go with 3000 now of course in a local environment by default it's not going to be set so always go back to the 3000 however once we deploy it's going to be a different scenario now if you want to test it out in local environment you can actually do so and we do that by stopping the server and then we want to go with a port and we set it equal to whatever value you want now my case i'm going to go with 5000 because i believe my final one is using that so i'm going to go with 6000 and then you want to go with node and then what is the name of the file you want to run of course it is app.js and now check it out in a console we should see six thousand now of course i still see three thousand because i didn't save the file my apologies let me stop the server just so you don't think that i'm messing with you and let me run the command one more time and now of course in the console i can see server is listening on port 6000 and one more time as far as our logic we just say set port to whatever is the environment variable by the name of port or 3000 if there's nothing there awesome congrats on completing the project and i'll see you next one all right and welcome to our next project the store api where we'll learn the advanced filtering sorting and dynamically populating our database as well as bunch of other cool stuff while i did not create the front end for this project just because it seemed like an overkill the idea is following imagine we're in charge of store api and we want to provide a bunch of search options for our users everything starting with search by name to filtering based on price amount since we'll cover all the options in great detail during the project i won't do it right now but i do want to showcase where i got the idea from and how that would look like in real life and it's probably not going to be surprised if i tell you that i got this idea from the hacker news api and if you remember they offer quite a few search options for their user now we're not going to implement all of them but we will mimic the major ones and as far as how it's going to look like in real life if you took my react course you probably worked on a store project and during that project we built the entire search functionality on a frontend now imagine once we're done building our api the frontend only needs to make http calls and we send back the data so the same result user can still search for products but only this time the backend does all the heavy lifting and frontend is only responsible for http calls so the user can still search for products whether that's based on name or category or company and of course you can read the rest but the difference is of course that now the front end only makes the http call and then the back end does all the heavy lifting and as far as the project setup again we've got two folders final one and starter one and of course the final one is for your reference and the starter one is where we'll do all of our work and just like in the previous project when it comes to final in order to run it you'll need to complete some extra steps first not just npm install and of course i'll cover all that during the project as far as the starter most of the things should look very familiar since we covered them in the tutorial as well as the previous project and you'll also notice that in order to save some time on a boilerplate i already prepared a folder structure for you now when it comes to files most of them are empty since that's going to be our job during the project but the folders are already there while i understand that some people like creating everything from scratch since we're going to be building quite a few projects in my opinion there's very little benefit to repeat all the steps every single time all right and once we're familiar with the setup now let's kick things into gear and of course let's start working on a project and the first thing we need to do is install all dependencies and we do that by navigating to the starter so again big picture we're looking for fourth project so zero for store api and then more specifically the starter and i think the fastest way is just typing cd and then take the folder drag and drop and of course we're sitting in the folder and then we run npm install and while the project dependencies are being installed let me just mention that in this project we will set up everything from the scratch just like we did in the previous project just so we can keep on practicing on getting our project off the ground but starting with the next project some of the boilerplate code the one that we'll type in this and few of the following videos will be already prepared for you since that way we can right away cut to the chase and don't waste our time on stuff we already covered and once the dependencies are there then of course i just need to check the package.json and i can clearly see that the command is npm start and of course we just spin up the nodemon so we go here with npm start and we are in good place now of course let me navigate to the app.js and here let's start adding the code and the first thing that i want to do is get that package in the env so i have access to environment variables because of course again we'll connect to our database and we simply do that by typing require then we're looking for dot env that's package name and if you remember we invoke config now of course we haven't set up the env yet the file e in the root of our project but we definitely need to use the dot env if we want to access the variables and of course we'll work on that envy once we actually start connecting to the database then i'll add a comment of async errors and you'll see why i do that in a few videos and then of course we want to spin up the express so we go here with const and express is equal to express of course so i go here with require and then express and then once i have the package then of course we want to spin up the app so we go const app is equal to express and then of course we invoke it now i'll start listening for the server a little later now i just want to import two middleware functions that we set up e in the previous project and those are error handler so this one over here more essentially we just catch all the errors and then we decide what is going to be our response and then the second one is not found because this is going to be the case where i don't want to repeat the same stuff we already covered in the previous project so that's the code that i already prepared for you and now we simply need to import both of them and come up with some meaningful names in this case i'm going to go with not found and then middleware and that is equal to require and of course i'm looking in the middle or folder and then more specifically we're looking for that not found one then we'll copy and paste and then just change the name where instead of not found we're gonna go with error and of course the file that we're looking for is also different and i called it error handler and once we have both of these imports in place now of course we can set up the express json middleware as well while we're at it and you know what in here let me just add middleware comment and then like i said we're going to go with app.use and then we'll pass in the express and we're invoking json then we'll set up our one lonely route for time being and essentially this is just for testing so let me add here routes eventually of course we'll set up the router and all that but for time being we're just gonna go with app.get we're going to be looking for the home page meaning the forward slash and then we'll set up rec and res so of course our callback function and here let's say rec and res and as far as the response i'm actually going to be cheating a little bit where i'm going to go with res.send and then since i can pass in some html i'll say heading 1 and name of the project store api and of course now i want to close my heading 1 and then also i want to set up a link that will navigate to the products page the one that we haven't set up yet and here let's just go with ahref and i guess more correctly the product route because technically we'll be sending json it's not going to be a page and here we go with forward slash api and then version one products and i'm purposely keeping this api in version one just because we already have the global variable in a postman and then as far as the text let me just close it here and then close the actual tags and then we'll say product route so that way if we ever need to we can just quickly navigate from the browser as well so let's save this one and let's keep it going and in here i'll add a comment for product route that we'll set up in the upcoming videos and then i want to use both of these middlewares so we have not found an error middleware and i simply want to use app.use but make sure you do that right after the app.get so we'll say here app.use and first let's just look for not found one and then we'll do the same thing with the other one as well so pass here error middleware then i want to set up my start function but initially i'm not going to use that connectdb so simply just go with app.listen but we'll place it in a start because of course eventually we will connect to the database so let's just start over here start and it's going to be async and then as far as the function body let's just go try catch and then eventually we'll connect to db connect db but for time being we just simply want to go with app.listen and then what is the port well we need to create that port variable and if you remember the end of the previous project effectively we'll set this up dynamic where we'll go with const port is equal to process dot env online port if it is undefined then of course we can hard code this value and i believe that in my final one i have 5000 so i'll keep this one as 3 000. and then we'll pass in that variable here the port one and then of course let's set up the console.log just so we can see that everything works and here we'll just say server is listening to the port and then whatever is the port variable so let's say you're here port and then i'll add those three dots and then if there's an error of course we'll go with console.log and the error and now finally we can just invoke start and if you can see in a console server is listening on port 3000 then of course we are in good shape and if you want to test it out in the browser just navigate there look for localhost 3000 and of course this is what you should see the hearing one as well as link now we don't have the route for api version one product but we can nicely test r404 since we can see the route does not exist text and if we have all this in place now of course we can move on to our next topic and once our basic express server is up and running next i want to connect to our database and if you remember we just need to navigate to the atlas and then we're looking for connect so that is going to give us that connection string and of course we'll have to supply here the proper values so let me just grab this one then we're going to navigate back to our project and of course i'll right away set it up in dot env so in the starter make sure it's in root we're going to go with new file and then we go dot env here and then once we have the file then of course we want to create a new variable and since it is a common practice to call this uri we'll do the same where we'll say underscore uri is equal and now of course we copy and paste now as far as the database i'm gonna call my one zero four and then store api essentially the same as the project name but sky's the limit you can choose a different name of course as well and then as far as the password since i changed from my silly one two three four now of course i'll freeze the video so you don't see what is my real password and then once you add your own password then make sure that you save dot env that's a must then we want to restart the server so in my case i'll stop the server with control c and then again we go with npm start and then once everything is in place now of course we just need to go back to app.js and i just want to showcase that of course the function is already there so the only thing you'll need to do is just to invoke it in appdress of course you need to require it and then pass in the connection string with proper values and since we already covered all of this setup in the previous project essentially there's really nothing new that we can learn over here i already prepared all the code so we simply need to grab this function and then pass in the correct connection string so let's go back to app.js and i guess we'll do that somewhere at top so right after app and before the middleware we're just going to go with const and again i'll name it exactly the same connect db and that one is equal to require we're looking in the database folder and then more specifically we're looking for connect now this function of course returns a promise that's why we set up start with our sync and then right above the app.listen i'm just going to go with await connect db and then of course i'm looking for my variable the one that's coming from the dot env and i simply go here with process and then dot env and then of course the variable name was uri and if you see in a console server is listening on port 3000 then of course we are in good shape and we can move on to our next task and once we have successfully connected to the database next i want to set up two routes for the product and you'll see why we have two routes essentially the idea is that one of them the first one is just going to be for manual testing and then since i want to keep on practicing on setting up the router we'll do just that and up here i can notice that i actually have a spelling bug or this should be route and then right after the home route i'll set up my router and i'll do that using add.use and then i just need to come up with that base path or root path for the router and in my case like i already mentioned i'm gonna go with api version one and this is gonna be looking for the product and like i mentioned when we're setting up this route i simply add this api in version one because that way it's easier in postman since we already have that global variable and effectively in here we want to pass in the router but in order for the router to work of course we'll have to set up the controllers as well therefore we'll start in the controllers the file is already created for you and the name is product and for time being we'll simply set up two functions and we'll just send some dummy data back and two functions are going to be following we're going to go with const get all products and the first one i'll call static now this is going to be async since of course we will use the methods that we have on the mongos and here let's look for rec and res of course and then as far as the function body for time being simply want to go with res dot status and i'll set it equal to 200 and then as far as the response i'm going to go json and then instead of the json i'll pass in the object and in here there's going to be a message property and then we'll just write products testing route now let me copy and paste this and then we just want to remove that static part and we also want to remove the testing one so this is going to be actual route and then of course we can export this so let's go with module exports and this is going to be my object and here i simply want to pass in both functions so get all products and get all products static so we set this up then of course we need to navigate to our routes so in here this is where we'll set up our router and then we'll start by getting the express so const express is equal to require and then we want to pass in the express of course again and then once we have that let's set up the router and if you remember the syntax is following where we go with router and then we go with express dot and then with the capital case we go with the router and then of course we invoke it then i want to import both of these functions from my controllers and i'll right away use the structuring so go with const and then the name is get all product of course and then get all product and we'll add a static one and that is equal to require then we're looking in controllers and then of course the file we're looking for is the product and then if you remember we have multiple options and in this case i'm going to go router route and then i'll go with forward slash so essentially this is going to be for that main route here the api version one and product and as far as which controller i want to use i'll use this get all products and please don't mix them up again the controller you want to pass in is get all product and as far as the static one let's copy and paste and then we'll just add that here at the end so this is going to be our main path or root path and then we're going to go with forward slash static and this is where we want to pass in that get all product static and then once we have this setup in place now of course we just need to export this so look for module exports and of course we'll export our router and once we have set up the routes then of course let's just finally navigate back to the app.js of course we do want to import that and come up with some kind of name and in my case i'm going to do that right after the connectdb and we'll just say const and i'll name this product router and that is equal to require and then i'm looking in the routes folder and then more specifically you want to get the product and then let's keep on scrolling and where we have app.use for our middleware now of course we'll pass in our router so let's just say here products and router and once we save i'll spin up the server one more time and if you want to test this out let's just navigate back to the browser so i think you can close this one and then at the moment it says route does not exist but once we refresh check it out of course now we have message product route beautiful and then if we want to test out the static one well we have product testing route and once we have all of this in place now of course we can move on to our next task and since we have both of our routes in place i think it's an awesome time to actually set up a new collection e in a postman and of course set up those routes as well so in here i'm just gonna save pretty much everything from the previous project close all the tabs here i'll say yep save changes and what i'm looking for of course is the new collection so i'll say here new collection then i'll right away rename it and i guess i went for edit should i went for rename and then we're gonna go with or at least i'm gonna go with zero four and then store and then api and then in here we'll set up two routes basically one for the product the api version one and then product and the second one for the static one so at this point i think i can close these tabs here and we're looking for new request now both of them are gonna be get requests so let's go over here url and then we want to go with double curlies and then we're looking for the products let's send and check it out of course we have product route beautiful again save as or you can simply click on command s and this is going to be get all products okay awesome we're looking for store api let's save it over here and now let's just add that static one as well and i'll do that by opening up a new tab again same thing get route and then we're looking for the url one and then once we have the url uh the products and then of course the static one as well so static here let's send because now we have product testing route and as far as the name i'll just call it that i'll say get all products but i'll say testing and once we have both routes in place now of course we can move on to our next topic and once the postman is ready to go and before we deep dive into the mongoose now let me showcase something in our application where if you take a look at the middleware you'll notice that there is no async wrapper and if you remember we needed to use something either we set up try catch pretty much in every route correct or of course the other option was using that async wrapper but when we were setting it up i also mentioned that there are packages that do that for us and that's why if you take a look at the package json you'll notice package the express async errors and essentially the only thing we need to do is just go back to app.js and then where we have a comment for async errors just import the package that's it that's all you have to do so let's go over here acquire and then of course we're looking for the package name of express async errors and just to stay on the safe side i'll stop the server and i'll spin it up one more time and now you'll notice that if i go back to the product one and or i'm sorry the products in the controller i'm actually going to close the routes i don't think we'll need that anymore as well as the app.js we're pretty much done over here and then if in any of the controllers you'll go here and throw the error which you'll notice that will actually be able to access that error in our custom error handler and essentially what that means is that whenever mongoose is going to spit back that error unlike the previous time where initially we set up trying catch and then we built our own async wrapper in this case the package takes care of that so in here let me just go throw and i'll call this new error and i'll say testing package or testing async errors whatever you want testing async errors and just to showcase that in the error handler i have the console log for the error and of course in here i'm sending back some kind of hardcoded message so first what i want to do is from the postman navigate to my static one just to showcase that of course we are catching those errors nicely with our package and then i'll cover the package in more detail so let me go back to the postman unfortunately it's all the way on the lefthand side so there's a little bit of jumping here and i'm looking for the static one i simply wanna invoke the route and now check it out something went wrong please try again and if i navigate back all the way here in the bottom i should see error testing async errors and if you're interested in finding out more about the package just go to google and type express async errors and of course one of the links is going to lead back to their docs and effectively if you want to use it in your own project just go with npm install express async errors then we keep on scrolling and notice how the only thing we need to do is to require it and then we're good to go now one thing you probably noticed that i did not use next and essentially the reason why i didn't do that is because if you read their docs they say that instead of using next we simply need to throw a error and of course since i can see the error in the console that means that i am getting that error in my custom error handler so the functionality still works so long story short instead of setting up try catch instead of setting up our own middleware we effectively just used a package that does all the work for us and as a result we can eat and have our cake too meaning we get the benefits of just using asynchronous code and we don't need to worry about setting up try catches or our own middleware and the package name that does that for us is a sync express errors and we simply need to require it in the app.js and once we have discussed async errors next let's set up the model and before we go anywhere let me just mention that i will keep this console log just because i want to showcase some stuff here and there but of course if you don't want it you can just remove it or you can maybe pass in the error over here where you have the message like we did in a previous project that is totally up to you now let me just navigate to complete project and you know what i'll make this one all the way on the left and what i want to showcase is that of course we have the products and what do the products have well they have some kind of properties correct now featured rating created that and of course you can read the rest and in order to set it up what are we going to need we will need a schema correct and using schema we'll set up a nice structure for our data and we already know how to do that so of course we just need to create a model and therefore we'll right away have a models folder and in there we just have the empty product js and in here we need to start by getting the mongoose and of course i'm looking for my mongoose package so we go here with the require and we're looking for the mongoose then we want to go with our schema and i'm going to call this product schema so that's going to be the structure for my product and i'll set it equal to new mongoose and then of course i'm looking for to schema and then in here we want to pass in the object and this is where we'll set up the properties so this is going to be a good refresher on how we can set up the properties as well as the validations and the properties i want to set up are following i want to first go with name and now we'll have a type of string then we want to go with required and remember we had multiple options and one of them was setting this up as an array and the first values of course is going to be true or false and then the second one will be that custom error message and here we go with product name must must be provided and then in order to save a little bit of time i'll just grab this whole thing copy and paste at least once and then the second property i want to set up is the price and of course this will be a number so let's go over here say number and then as far as the error message let's just say product price must be provided after that we want to set up a feature property and we simply do that by going with featured that's the name of the property again we'll set it up as an object and then type is going to be equal to our boolean and then by default we'll just say that all the products are not featured so that way of course we don't need to worry about whether the product is featured not we simply set all of them as false then we want to go with rating now of course if you do provide featured as true then of course it will be featured but by default all of them will be false hopefully that is clear then we want to go with rating and now we'll be equal to a number so we're going to go here with type number and let's just say that as far as default value it's going to be 4.5 again if the number is provided of course that value will be set up as far as the rating but if there is no number then there is a default value and then we want to go with created at so essentially this is just going to be a date when this product was created and what's really cool that in mongoose we can use date type and we can actually set the current time and we do that by creating the property created at we set it as an object and then instead of the object let's go with type and then date and then if we want to set up the current time we simply go with default and then we go with date dot and then we invoke now so now of course every time we'll create that new product if we don't supply the created ad by default is just going to be a current time and then we have company and company is a little bit interesting where essentially if you take a look of course we have the name for the company but when you're adding the products what we want to do is set up some kind of guardrails where we can only provide specific companies and if you're interested how that would look like in a real project so imagine the scenario you have the product and then as far as the companies these are your possible values that's it it's not like i'm just gonna randomly add here trader joe's or lucky donuts or something along those lines and the way we can set that up in mongoose is following where we need to go with company here and of course i'll set it up as an object then as far as the type yes it's going to be a string but if i want to limit the possible options for this property then we go with enum property and then in this array we provide those options and in here of course you can provide whatever values you want now i strongly suggest adding the same values as me because in the next video we'll dynamically populate our database and if your values will differ then of course you might get the bugs and companies that i chose are following so i went with ikea or in some places in the world they're also called ikea which is very very weird and then let me check the other ones so i have this one then let's keep scrolling i have this one and you know what in order to avoid confusion i'm just gonna avoid actually pronouncing them then we have this one and then let's add a comma again copy and paste and of course in here i added those double quotation marks which is probably not something i want and then i have the last one let's keep on scrolling this one over here so those are the four values that i chose and again for your own project you can set it up however you would like but since we'll be adding those products dynamically in the next video so we don't need to add them one by one i strongly suggest using the same values now what's also really really cool is the fact that we can set up a custom error message if the value doesn't match any of these items in the list and the way we do that is actually following where i'll comment this out just so it stays for your reference and we actually set it up as an object here and then as far as the possible values we go with values property and of course we still use the same values and when it comes to custom error message we go with message and then in order to access the value that the user is providing meaning the one that is coming in with a request the syntax is following where we go with curlies and then value so essentially that will access whatever the user is providing and then we want to go with some kind of message and in my case i'm just going to say is not supported and once we save we have our schema ready to go so now of course we just want to set up our model so we're going to go here module export and we'll set it equal to mongos model and then as far as the name i'm going to go with product and then i want to pass in my schema which of course is the product schema so product schema over here and once we save we're ready to move on to our next task and once we have our schema and model in place before we can start setting up any kind of functionality of course we need to have data otherwise how you're going to set up any kind of filtering if you have no product in a database and effectively we have two choices you either can set up a post route and then just manually add them or a better approach is just to automate this and essentially just have some kind of list and pass it on to your database now lucky for you if you take a look at our project you'll notice the product json and essentially this is just a list of products just so we can start working on the filter functionality and the only thing we need to do is set up populate js where we'll dynamically add all of these values to our database so instead of going to manual route we're one by one we add them we'll right away just add them to our database by actually invoking the populate.js and the way it's going to look like we're going to go over here we'll first grab our dot env so let's say over here dot env then we want to go with config and then what's really interesting that we need to have another connection so yes we have one for app.js of course that still stays the same but since we want to connect to the database one more time we'll have to grab that connect function as well and here i'm just going to go const connect db because that is coming from where that is coming from our db folder correct so we go here with db and then more specifically connect that's the first thing we want to grab then we want to grab the model and you'll see why and we just need to come up with the name in my case i'm going to go with product and then of course we're requiring that it is coming from the models and then more specifically product and then lastly i want those json products because that's the data that i'm going to be passing on to the database so here we need to come up with the name in this case i think i'm going to go json product and we'll set it equal to require and where the file is actually sitting right next to us so just go with forward slash and then we're looking for product json and once we have all of this in place we want to set up that start function one more time however in this case of course we're not going to be setting up app.listen we simply want to connect to the database and then use the model to automatically add those json products the one that we have in the file to our database and the way it's going to look like we're going to go here with const and start and we'll set it equal to a sync and in here we'll set up another try catch like so so let's go try catch and of course eventually we'll invoke it here as well and then i want to go with my await then we want to pass in the connectdb and of course inside of the connectdb we'll pass in the process dot env and of course our variable so and then underscore uri and just because i want to see whether we're going to get some weird bugs i'm also going to type in the catch a log so go over here with log and then we're going to be looking for the error and once we have all this in place we can at least try the connection now there's still some code that's missing but we'll get to it in no time so first what i want to do is stop the server over here and then we just want to go with the start invoke it and then in this case i'm not looking for nodemon i'll simply go with node and then of course i'm looking for the filename so since i'm already in a starter i just need to write populate and then once we run it if our connection again is successful we shouldn't see any errors in the console now if you want to help yourself out of course you can just type here log and let's just say success or something along those lines so let's say here success and an exclamation point let's save it one more time again let's stop it and if you remember from tutorial in order to go back to the last command we simply press arrow key up or down in micros i'm going to press it down and check it out now of course we have the success so we successfully connected to the database now if i want to check out the error i'll comment out the dot env stop the server one more time sorry about the detour but these things are important and then once we run it of course we're not successful connecting to the database because the uri parameter is not provided awesome so let me uncomment the env then clear everything and once we have successfully connected to our database there's two things that i want to do first i want to remove all the products that are currently there and then i want to use the create and just pass e and the json product so if you remember in a previous setup and i think i'm just going to go for final and let me look for controllers and tasks notice here this create we passed here a object correct when we were creating that task now what we can also do is pass in the array so if you take a look at the product and i'm sorry not this one products json you'll notice that this is an array at the end of the day and then since this is an array what i can do i can just pass this in into the dot create and then by doing so of course i'll add all of these products to our database so let's try it out let me navigate to the populate one i have the json product i'm in good shape so now let me go below the await but before the success and in here i want to go with await now i'm not waiting for the actual response and i want to go with my model because model has all those functions and then we want to go with delete many so now i just want to remove all the products that are currently there of course in our case there are no products but i'm just making sure that later if you want to reuse it then whatever gibberish you added or whatever data you currently have you just remove it and then you start from scratch this is technically optional if you don't want to do it you don't have to but in my case i always like to start with scratch and then we want to go with a weight and then product product and then remember the function create so now we're just dynamically creating a bunch of product by passing in json products that's all we have to do here we go with json product and now let's try it one more time and then of course we'll double check in our application so in here i'm going to go back to my console and then i want to go with node and populate and if i'll see the success then i know that i'm heading in the right direction so now let me just go back to my atlas one let me refresh and now where i have my collections i should have more values and effectively i have the store api awesome and in here i have of course all the products now i'm not sure how many i set up it really doesn't matter if you see these products added to your database now of course we can start finally setting up our filter functionality and while we're still on topic actually no there is a method by the name of exit now why that would be useful in our case because well let's think about it so we have our popular js if we're successful then we might as well just terminate the whole process correct i mean we don't need this file to be running and if there's an error then again we'll exit but maybe with a error code and the way we set up the process.exit is simply by navigating to the start here and then probably right after the success we'll set up a process again that is that global variable that we have access to then we go with exit and that's the method name and then if we pass in zero that just means that everything went well and we're just exiting the process however if i take the exit method and pass it in and of course in this case since i'm running it in the catch i want to pass in error code i'll pass in one and then let's do it one more time i'll clear everything and i'll not test it out with an error but let's just go here with node populate and now you'll notice that once we're successful we actually exit the process why well because we have process dot exit and of course the code in this case that we passed in is zero and if you want to double check your data just navigate back to the atlas and you'll see that all your product data is still there and once we have dynamically added products to our database i think i can just close the popular js at least in my case i'm not going to use it anymore the same goes for product js and then the rest of the work will pretty much do over here in the controllers and the first thing that i want to showcase actually this is a refresher where essentially if we want to search for a product in a mongoose meaning for some kind of items in our case of course that is product well we need to go with find method correct so let's just go over here i'm in the mongoose docs and i'm looking for the queries and then we'll keep on scrolling keep on scrolling in this case they show the find one example but the idea effectively is the same that if you go with find and of course if you pass in the mp object then you'll get all the documents and of course in the object you can also pass in some options and if you go with properties then you just need to provide what value you are looking for so in our case if we take a look at our model over here in the product js well these are all our properties correct whether that's name price featured and yada yada so in here let me start up my server and then back in product.js i want to get the model because of course we'll go over the basics first where i'll start by just getting the product and that is equal to require and i'm looking for my model again so i'll go two levels up and then i'm looking for the models and then the product and then let's start in the static one so i'll do a little bit of work here i'll show you the manual approach and then in get all products well this is where we'll set up the real functionality the one that we'll use in our project and then we already know the asynchronous so that's good and now let's just start by saying const product and simply let's take a look if we pass in the empty object so in here let's go with weight and then product that's the name of the model and then find and like i said let's just pass in the empty object and then instead of the message i'm just going to go here with product and then let's test it out in a postman so i'll go back to my testing one i'll send it and i should see my array of products and if that is the case then of course we're heading in the right direction now if i want to be more specific if i want to say hey get me the product where the company is equal to this one or get me the product where the name is equal to this one or maybe get me only the featured one then of course we simply need to go back here and where we have the object well i can say featured featured and then this is going to be equal to what true or false so let's just pass intro and then let's run it one more time and what you'll notice in your static route only the products that are featured are going to be displayed and you know what i think in this case it is going to be very helpful if i'm just going to go with those number of hits and i'll set it equal to my array because that way you can right away see if you're getting the correct set of data so let's go over here and in this case it says something went wrong and of course because for some reason i decided to add number of hits in the find and this is actually something that i'll cover later why we get those errors and how to avoid them so let me remove it this was pretty much an early taste what kind of errors we're going to have so let me run it over here where i have the json response so don't be like me be better than me and don't pass it into the find pass it actually where you are sending the response and let's go back over here let's send and of course i have the products and all the way at the bottom i have number of hits is equal to seven and if you'll take a look you'll see that all the products have featured set true and you can probably already imagine that if i'm just going to go here with name and of course we can combine them and again this is something that we'll cover in more detail in next videos so therefore i'll remove it and i'll just start with scratch i'll say name is equal to whatever i have here my apologies i copied the wrong thing if i have multiple tables and for some reason i just want to look for this one i can just pass e in the value where i say yeah get me the product but the name property needs to have this value and now of course once we send i should get only one that's the only one that has the matching name hopefully we're clear on a basic setup so now of course we can start implementing the get all products where the setup is going to be more complex than just hard coding the name or any of the other property values all right i think we're solid on filter functionality so now let's splice things up and implement the dynamic approach since it's highly unlikely that we'll send our responses based on hardcoded filter values and first let's start with our requests more specifically query params because that's how we will get our data and in order to jog your memory on query string params let's go back to my favorite api at least for this course of course the api is hacker news by algolia api and once we navigate here once we start scrolling and everything and looks like i'll have to refresh you can see that of course we can get the items we can provide the route params that's clear but if we keep on scrolling notice of course now we can start searching for some data and how do they set up the search well they have the domain then of course they have some kind of endpoint that ends with search and then they have a question mark and after the question mark we have key value pairs which essentially are query string parameters and then of course based on what you're looking for whether you intercept the query or you want to look for different page then you pass in the value and hopefully you get the correct result and as far as our setup we first need to understand how we can send those query string parameters from the postman correct so let me open up the postman and then of course i'm going to be looking for get all products so i'll just leave the testing one as it is so essentially in there we'll just hard code all the time but back in get all products not only i'm going to be looking for the product but i can go with question mark and then of course i can add key value pairs now we have two options either you can type it here for example you could say name is equal to john and notice how right away they're being added in this table as well so that's the second option where if you don't want to do it in the url you can just set it up over here and what's really cool you can actually check and uncheck them and what that means is that if i go here with john and then of course i send again the name and if i don't want to send it then i can just remove it and if i want to take a look at the featured ones and of course this is going to be featured and as far as featured i want to start with true and then once we send of course now we just get back the message but if we take a look at our controller we should have access to those key value pairs in rec dot query so let's test it out i'm going to go with simple console.log just so we can see that we're getting data and it is sitting in rec and query and let's do it one more time from the postman so let's send it again we get back the hard coded result but take a look at our console of course i can see that i have the object and then in there i have key value pairs with whatever i'm setting up in a postman and once we have jogged our memory on query string parameters now we simply want to go back to the postman and i'll just use the featured and i'll show you in a second why i want to do that and then i'll send it of course and if i take a look at my app of course now i only have featured so now let's set up the logic where i'll remove the console log and then we'll still be looking for the products and we'll use define of course but in this case instead of hard coding instead of setting up the object and then passing in whatever key and then the value of course will pass in directly direct.query now we will refactor the code because there are some gotchas we need to be aware of but with the most basic setup we'll pass the query directly into the find and let's hope that we'll get some results so let's start the same way we'll go with const products and that is equal to await and then product then dot find and like i said we'll directly pass in rec and query and of course once i get back the results i want to also send them and then in this case i'm going to remove the message and i'll just say the same thing where i'll pass in the product as well as the length of my array so that way i know how much i'm sending so let me go back and then one more time from the postman and again the route is forward slash product not the testing one and now i just pass in featured because that is one of the keys that i have and as far as the value i go with true and then once we send check it out now of course we have the product and the amount of items is equal to seven so if i'll change this to false now of course i'll get a different set of values again let's just quickly cover the logic where we have access to query string parameters in reg.query and since we get back the object we can directly pass it into the find one and then since in this case i'm looking for featured and i'm setting it equal to true that of course returns only the products that are featured and then if we pass into false then of course we'll get only the product where featured is set to false not bad not bad i think our basic setup works pretty nice or there are some gotchas we need to be aware of what do you think is going to happen if in a query string params we're going to pass in some kind of value that doesn't match any of the values that we have currently in the model so remember when we're setting up the model we have name price featured and yadi area but what happens if i send with my request a page which essentially we'll do because that's one of the functionalities we want to add and i guess the best way to showcase that is just by going back to the postman and here of course i still have featured set to false now you can leave it you can remove it that's really up to you what i want you to do is go below featured and then just add another key value pair and then in this case go for something that is not in our data so in my case i'm going to go with page because like i said we use that later anyway and then you can come up with whatever value you want and of course i want to check it here and also as a side note just notice the syntax so if you're going to be setting this up manually in the url just remember that in between them you need to add this ampersand of course postman is already doing that for us but if you're setting this manually just don't forget so now once i send check it out of course i have no values why well if i navigate back and take a look at my product what happens over here well i pass in rec.query directly correct and without even cancel logging we already know that we have a object with featured set to true or false that is really irrelevant and then we're looking for the page with some kind of value now mongoose of course is like well listen i don't have any product where there is a page property and that is actually set to 2 1 or whatever so therefore if i go back and if i do the same thing with the testing one again i'll have zero values back so hopefully that is clear so yes this probably is going to work with the most basic setup but then as your filtering gets more complex there has to be a better approach and that better approach is for starters pulling out only the properties you want to apply to the find now what do i mean by that well i'm going to go with const then i'll destructure from reg.query and in my case i'm just going to be looking for a feature of course eventually we'll add more values but for time being i'm only looking for featured so i can add 10 000 more items in here in a query it doesn't matter i'm just going to be looking for featured and if feature is set to true then i'll add it to define and once we have successfully pulled out the feature out of the query so now of course we're only going to be looking for this value instead of passing this directly into a find a better approach is actually to set up a new object so in here i'm going to go with const and i'll call this query object and that is equal to a new object and now i'll use the if and i'll say if featured is true then what i want to do is to set up a new property in this query object so in my new object i want to set up a new property by the name of featured so let's go over here let's say query object feature that's the property name and in here i'm going to use the turning operator where i'll say if the featured is set to true then of course i'll set this property equal to true now then of course e is going to be false so let's go with featured and then we're checking for true so let's say over here true now of course we use ternary operator and then if this is true then we set it equal to true if not then of course we go with false and once i have this logic i'll save and then instead of passing reg.query what it will do will pass in the query object and then since i want us to be on the same page i'm just going to go with console.log and you'll notice that first we only set featured so we're not going to be setting the page and we'll only do that if it is actually passed e into the query so if it doesn't exist so if the user doesn't send featured then of course this logic won't be applied and of course this is just going to be an empty object and then we get all the items so let's test out one more time so now of course i'm going to go back to all the products and let's send and now of course i get back the value of 16 because i'm looking for all the products that are not featured but notice how the page is not messing everything up so in here i can clearly say yep featured is there the value is equal to false and this is the object that i'm passing e into define but if we have a different request for example if there is no featured and the user is only looking for the page of course we're not handling the page functionality we'll work on that later but for time being what happens we get all the products why well because we have empty object so hopefully this makes sense instead of passing directly reg.query we set up a new object and first we just pull out the properties we're interested so in my case i'm going to be looking for featured i'm going to be looking for name later on and hopefully you get the gist and then we'll check if the property is actually coming in with a request awesome we'll set up a new property on our query object and then of course there's also going to be some kind of functionality in this case it was just straight up turning operator and then instead of passing that property directly we'll pass in the entire query object and that way of course we can avoid that bug that i showed you in the beginning of the video wonderful once we have the general structure in place so effectively once we have the empty object and then we check for the properties that correspond to whatever we have in the model now of course we can continue and add more functionality to our api correct so we want our user to search based on name maybe also based on price as well as rating and company and all that now i can tell you right away that we will purposely work on the number values so the price and rating and all that a little later because probably that's going to be the most complex logic of this project for now i want to work on name and company now company should be somewhat straightforward where we're going to check for the company so say hey is the company property on myrac.query and of course then we'll set up the value in the object and if of course we can find something then we're in good shape if not and of course we return nothing so let's go back and the first thing that i want to do is of course pass it from my postman so in here i'll remove the page hopefully it is clear what happens with the properties that are actually not on our model and then let's set up a new one and here i'll say company company and as far as the values well let me check since it's going to be faster so let's say i'm going to go with this one copy and paste and now i'm going to look for both i'll say hey get me where the feature is false and company is this one so let me send it here and now what you should see is only the product that matches company now of course not yet but that is the eventual goal so let me navigate back and notice again we only get the featured why because that's my logic so let's go back over here and let's say that we're also going to be looking for the company again not to be redundant because this company corresponds to something we have already in the model otherwise we'll have that mess where mongoose is going to be like hey listen what's happening i cannot find anything then of course we want to set up the logic and this is going to be as straightforward as it gets where essentially i'm going to say if the company exists then of course i just want to set up my property on a query object and the name of course will be company and i'll set it equal to my company the one that i'm pulling out of here so once i save and once we try one more time we should get different amount of values and of course in this case we get only six so now we get featured false and company is equal to ikea now if i'm going to pass in some kind of gibberish i'm going to say that i'm looking for a company bbb of course i'm gonna get zero results but that's what we expected so if we're looking for something that doesn't make sense just of course the user is not gonna be successful but if the user provides correct company value then of course we send back the list of products that correspond to that value and if you're wondering well where the user is going to know that info well that's why we have documentation so if you go back to this api you can see how they clearly explain what are our options and essentially how we can work with the api so now of course in our api we handle two things we handle featured and we also handle the company and once we have the first two down i think we already understand the pattern so let's try to do the same thing with the name and we'll start with the most basic setup where essentially i'm gonna go with a name and then whatever value i'm passing in meaning e in the query and then eventually we'll come up with more complex setup where we have the rejects because at the moment we need to understand that of course with our most basic setup we're only going to be looking for the product whose name matches exactly now what am i talking about well let me go back to the static one let me send it from here and i just essentially want to get one of the names and i'll look for this one and what you'll notice that with the most basic set effectively we'll get only the product whose name matches exactly so if i go here and if i send of course now i get only one product but if i mess it up here meaning if i just pass in the first value you'll notice that actually we get nothing so yes it's a good starting point where the value needs to match exactly but then of course we'll make it more complex and add rejects to the mix because that way we'll be able to just pass in some kind of text values and we'll get the product where that value is somewhere in a name so after my long rambling let me just go back over here where we have get all product and what is the property that we're going to be looking for of course that is the name and there's also something that i want to mention where nothing stops you from setting up your own api and saying here that you're going to be looking for the search for example like they have in the hacker's news api nothing stops you it doesn't mean that these properties need to match exactly now of course i'm setting up this way because it's much more easier later when i'm setting up the object properties so these ones definitely need to match whatever we have in a database but as far as what values we're looking from the query this is really up to you and again just to showcase that notice how they in here use query so we can definitely set up our own api with a query or search or whatever the only reason why i'm using the name is because it's just going to be easier when i'm setting up here in the object hopefully that is clear and then let's keep scrolling and we'll start like i said with the most basic setup we'll say if the name exists then i want to go with my query object of course name property and that one will be equal to the name so let me swing back to the postman and again now switch to get all products and since i'm just gonna get one value since at the moment my name is gonna match exactly i'll remove these ones i'll remove featured and company and you know what let me go to complete project and that way i can get the name right away and once i have the name now of course i'm going to be looking for the product and we want to add a new key and in here i'll call this a name and then i'm going to be looking for this value and then once i send of course now i'll get that one product and if we take a look at our query object of course this is what we have so we have a name and of course whatever value i passed in and since i have one product that matches that that's exactly what we get but if you take a look at the mongoose documentation you'll notice that they have these query operators now this one we'll use a little later when we set up our numeric filters but with the name i actually want to set it up as rejects and since mongoose is sitting on top of mongodb we can get those query operators from the documentation so let's search for mongodb query operators then let's navigate here and as you can see we have a long list of the operators now the one that we're looking for is this one the rejects one and essentially the setup is following where we go with rejects and then we have bunch of options now the one that we'll use is just case insensitive and then of course we just need to pass in the pattern so let me try it out back in our application and i think i'm going to start with the static one just so i can show you the setup and then of course we'll set up the more complex one as well so let me go here and i'll scroll above where i have the static product and i'll just set up some kind of value now since i'm not going to be passing this with a query just understand that eventually of course a value will be coming from the query so in here i'm just going to say const and let's call this search and i'll just type aaa now where i'm looking for the name instead of just passing in the value directly we'll set it equal to an object and then the setup is following where we go with dollar sign and then i'm looking for that reject query operator and then as far as the value i'll pass in the search again eventually it's going to be coming from our query here and then i also want to set up the options and therefore i'm going to go with dollar sign and then i'll pass in the options and i'll set options equal to i and you're not instead of 3a's why don't we go with just one so let's save it over here again the way it works we're looking for name property but instead of looking for entire name instead we go with rejects where essentially we're just looking for the pattern and the way we set up we go with rejects operator then we pass in the variable which of course again is going to be coming from our query and then we have the options and in this case i'm passing i which just means for case insensitive and once we navigate back to the postman and run it you'll notice that of course i'll get all the items where there is at least a a and then if we're going to go with a b now of course we're going to be getting a different value so now of course i only have 5. now in order to set it up e and get all product what do we need to do we need to look for a name we already doing that and then where we have here if name exists and then query object name we simply need to change this around where again you want to go with this one instead and in order to speed this up i'm just going to copy and paste let's scroll down and let's just say that if name exists then of course we'll use the rejects instead now in this case of course the search doesn't exist correct so we need to go with name so if you need to pause it here and write it from the scratch please do so because in my case of course i saved a little bit of time and just use the one from the static so once we save again i'm purposely leaving this one just so you can see what is coming in and if we hop back to all the products and of course now i'm just going to go with some kind of text value that is less than the entire name in this case i'm going to go with e then i will look for the company and why don't we keep the same one over here and then i'll also look for featured anvils and notice how slowly but surely now we can search for more options so in this case i'm looking for featured set to false company equal to ikea and then of course e in the name i'm looking 40. so i'm looking for the product where e is in the name and then once i send check it out now of course i have six of them and if you'll double check you'll notice that definitely e is a name the featured is set to false and of course company matches to the one that we have in the query string parameters beautiful at this point our users have three options for filtering featured company and of course the name eventually we'll set up numeric filters as well but like i mentioned previously since it's probably going to be the most complex thing in this project at least in my opinion we'll implement that last for now i want to switch gears and show you how we can sort our data first in final project then the general setup and then of course we'll implement it in our get products as well and something to keep in mind sorting does not affect the amount of items we're returning just the order in which they are displayed so let me navigate to my final project and then as far as the sorting notice right now i'm just getting them based on a date when they were created and of course since we added them dynamically meaning we pass in the entire batch that's why of course pretty much all of them are with the same date but if i want to sort them based on name what do i need to do well i need to go to the url bar because of course i'm not in the postman and then i go with question mark and then i just need to decide which property i want to use and first i want to go to sort and then let me zoom out a little bit and of course we either can go with name we can go with company we can go with also price and all that so let's just start here with the name and then once i pass it in again i'm going to get 10 values because i already have the limit there but you'll notice that the companies or i'm sorry the product are going to be in the alphabetical order so this is going to be my first one then i have the second one and on and on and on now if you want to sort them the opposite way meaning of course now we go from a to z but if you want to sort them z to a let me zoom in here and then you just want to pass in the negative sign here so where you have the name so that's going to be that parameter that you're using and then if you pass in the negative now you'll notice that the first value is the wooden table instead hopefully that is clear now what we can also do is chain them together so for example not only i want to look at the name but i want to also look at the price why would i want to do that well if i take a look at these ones where i have wooden desk notice how the name is exactly the same correct and the only difference between them is the price so if i add here a comma and then i say that i'm also going to be sorting based on a price and since i don't add the negative i'm just going to be looking for the smallest value first notice now i have the wooden desk with 15 dollars first and then i have one for 40. and you can probably already guess i'm sorry for all this zooming in and zooming out but i just think that it's important that you see everything that i type here if we go with negative then of course what is going to happen well we'll have one desk but the largest value is first now of course i can just sort based on price then i just remove the name and then if i go with price notice again we start with the smallest value and then you already know what happens if we pass in the negative now as far as the setup let's just go to the mongoose and i'm actually here where we have the queries and i'm looking for i believe it was over here yeah so general queries not find or refine by the or any of these functions just general queries keep scrolling keep scrolling keep scrolling and then in here they'll showcase two options that you can use now not for sorting but in general for filtering we have two options and we are using this one where essentially we set up the entire json but you also have this approach available as well and this is again just for your knowledge now what we're interested is this notice after defined what do we see over here we see limit sort and select and notice how they are chained after defined so first we set up our filter object correct and we passed into define but when it comes to limit sort and select we actually need to chain them after define and this is gonna become really important a little later on when we work with get all products so first i just want to show you the manual approach where we just go with sort but then when we set up all the products the fact that we need to chain them is going to be very very important so let me navigate back to our project and let's just start with the static approach so remove the search one not going to be looking for name and in order to make it interesting essentially i'm just going to pass in the empty object just so i can get all the product and then remember instead of the method i want to go with string and i want to pass in the name so i'll start simply with the name so if we navigate to the postman again the static now and if we send a request notice of course our response is going to be in the alphabetical order meaning we'll start with a and all the way to w at the very very end and as you can see i have 23 products now if i'll change this around and if i'll say negative here then of course once we send check it out now of course we start with the wooden table and same goes if i want to go with price and syntax is following where we want to create a space and then we type in whatever property we're looking for so in this case again we go with a name but it's going to be z2a and then we'll set up the price of course that is going to be from the smallest to the biggest value let me go back to the postman let me send and of course i start with a w correct but my price for the ones that actually match is gonna be the smallest one first so the smallest price first and then the largest one hopefully that is clear hopefully we understand how we can set up a basic sort so now of course we just need to implement that in get all products nice and once we're familiar with general info now of course let's implement that in get all products and we'll start the same way we'll have to pull this out out of the query since i'm interested in that particular property and of course the property that i'm going to be looking for is the sort one so if the sort is in the query then of course we're good to go but here comes the biggest gotcha where if we take a look at our code right now we are waiting for this one to complete correct and essentially when we go with this fine one we get back a query object but remember in order to sort we need to chain this correct we first go with find and then if you want to implement sort we need to chain it right after find now here's the problem though in my current setup yeah technically i can go here with sort but again remember there might be a scenario where the user is not passing in the sort so we want to do that conditionally and the issue here is following where you can say all right so i'm just going to go with let products and then i'll remove this sort from here and then i'm just going to go with if and then sort exist then of course i'll set products product equal to product and then of course sort and then pass in the value but the problem is following where since we have this await actually here in the product we don't have any more that query object that is going to be returned from the find one we actually already get that list of products so what i'm trying to say that in order for this functionality to work where we actually are chaining the sort if of course it is passed in by the user we need to remove this await and the way it's going to look like instead of setting up the products here we'll go let result and then of course we'll have multiple conditions in this case of course we'll start with sword but then there's also going to be one for fields and we'll also set up pagination hopefully that is clear and only then at the very end we'll get the product so we're going to go below the conditions at the moment we have only sort but make sure that it is always sitting at the very very end and of course in here i'm just gonna go const product is equal to my result and of course i wanna wait for it so i'm gonna say here await and then i'll remove this one so hopefully this is clear where instead of sticking the await over here since we'll chain the sort and fields and limit and all that at the very end of the query object we're getting back that's why we need to remove this await because this right away returns those documents and then set up the await when we have the complete result and i think at this point i can comment out the query object and i think i'll uncomment once we start working on numeric filters and now let's just work with the sort one so for starters let's just see what we're getting back because that way we'll have a better understanding of what kind of functionality we need to set up so let me just check it here a sort and then we want to go back to the postman we're not working in a static one we want to go to all the products and again since i want to get more data i'm just going to remove just keep in mind that of course you can still keep them you can still keep these query params as well because you will get the correct data i mean we saw that we're getting six heads but since i want to have more product i'll just remove them temporarily and we'll come up with a new key and in this case i'll say sort so let's set it up here sort and then as far as the values let's just start simply like we did with name and once we send let's just go back and of course now i can see that as far as my value i have my name now technically we can right away set up the sort and effectively we'll change this to the result but there's one gadget that we need to be aware of if we're sorting based on multiple parameters then of course the value that we can see in the console is going to be different so if i'm going to go here with comma and then price and you can keep the minus or you can just set up the price the result is going to be the same or essentially now we have two values meaning we have one long string but inside of the string of course i have both i have name and price and the idea is that maybe the user decides to chain i don't know three more correct so how we can split them up so we can get the correct values because if you'll try to pass this e into a sort remember the syntax is following where i want to go with a space in between them e instead of the comma so you're not going to be successful now what can we do well we can use the good old javascript where essentially we'll create a variable i'll call this sort list and that is equal to sort and i'll split it i'll say that i want to split it on a comma and then i want to join it back together so essentially i split it into an array and then from the array i join it back together in this case however just with empty spaces and now what we want to do is to go with result remember that is the query object that we're getting back from the find and we want to set it equal to result and then sort and now we want to pass in this sort list in there now what's also really cool is that we can set up some kind of default one so let's imagine the scenario where the user hasn't passed in the sort key but i actually want to sort it based on the time when those items were created how we can do that well we can simply go with else else and here we'll go with the result and that is equal to result of course again and we go with sort and now i'll just hard code the value just like we did over here however which property i'm looking for well let's take a look at our model all the way in the bottom we have what we have created that again since we created all of our projects pretty much at the same time technically you can argue that in our case it doesn't make much sense normally of course that's not going to be the case that's why this is going to work really nicely where we go result and then sort and then we pass in the string and i'm looking for created add and then once we save our functionality should be working so let me try it out i'm going to go over here i have the sort one okay awesome and then once we send of course we start with a products that start with a and then of course as you can see we get the rest all the way to w but if i'll change this around and i'll say that i want to go the opposite direction of course we can send the request notice again we have those two that have the same exact name but since we go here with this minus price that's why we start with the highest value so effectively we have the descending order but if we'll change this around of course we'll have the ascending order instead so that's how we can add the sort functionality to our api and once the sort functionality is in place next i want to showcase how we can select certain fields and i think the easiest way for me to show you that is going to the final project and then i'm just going to go with fields so that's the key please keep in mind that something that i made up the actual method name is different it is select but in the query variables we set up fields so this is just going to showcase which fields we want to see and as far as the values the same as with sort we simply need to pass here the properties that are in our schema and in my case since i want to see only the name property and only the price i'll type name price and hopefully you get the gist if you want to see some other properties just add comma and then the actual property so let's go over here and now of course you can see that in my response i only have the id which is going to be by default as well as the name and the price and if we take a look at the docs we can see that the method name is select and again we have these multiple options where if you want to go with just string you can simply say select and then pass e in the properties so let's try it out in our static one so let's move up we have the sort i think i'm going to remove the sort for now and we'll just say select and then in here i'll do the same thing i'll say name and price and once we go back to the postman which is always tough because it's all the way on the left hand side then i keep forgetting that now of course notice our response only has these two properties it has the two fields of name and price and if we want to implement that in get all products what do we need to do well first we need to come up with the name in a query string again this is what i said before where when it comes to the query string you are setting this up because you'll tell the user in docs hey if you want to search for certain fields then you need to add this property in the query string parameter if you decide that you'll call this shake and bake you're in charge you can definitely do so now in my case i'm not going to be such a rebel i'm just going to go with fields then we're going to keep on scrolling and right after this sort and you know at this point i think it's going to be very useful if i add some comments here and then right after sort but before the product would check for the fields again we'll say if the fields exist then we'll do the same thing where we want to split them up and of course join them back together in the process we'll remove that comma and then of course we just need to chain the select method so in this case in order to speed this up i'm just going to copy and paste this is now going to be a sort list we'll call this fields list and then instead of sort we're going to be looking for fields functionality is going to be exactly the same we split it up we join it back together and then as far as the result of course i don't want to sort it anymore i want to use select and i want to pass in the field list like so so go over here and then let's navigate to the postman and of course in this case we're not looking for the static one anymore we want to go with all the products here and then let's just add both of them together so i have the sword i'll keep that one and then i'll create a new key i'll call this fields fields and then as far as the values let's just say we're going to be looking for the company and also i just want to see the rating over here so let's pass these two and of course we'll notice that we only get the rating as well as the company in our response all right and once we have covered how we can select certain fields next i want to show you how we can skip and limit and by using both of those things you can actually set up a option for the user to choose a page now how's that going to look like well in our final project we can go here with limit and then just decide how many products you want to get back and i believe again we have 23 products so of course if you'll go with 30 then we'll just get all of them so just to showcase that notice of course now we have 23 but if i'm gonna go less so if i'm going to go with limit and then for example four then of course i'll get only four items and if i don't pass anything in then of course by default we'll get 10. that's where we have number of hits and that is equal to 10. so hopefully that is clear and as far as getting the correct page just like they have over here where you pass in the page and that is going to return that exact page number we have to combine limit with skip which is another option we have and before we go any further let me just showcase how is that going to look like in our manual setup so in here i think i'm going to stick with select i mean it can stay there it doesn't really matter and then as far as limit we simply need to go with a method and again we chain it and hopefully by now it's clear that ian get all products we'll have to do that before we await for the result and then in here we simply need to pass in the value so if i want to limit my response here to 4 then of course i can go back to the postman now i'm looking for the static one i send it and of course i'm only gonna get four of them now if this value is gonna be bigger than all the items i have of course i'm just gonna get all the items that i have in my list and essentially skip works exactly the same way but the difference is that it just skips the first items in response so let me just limit this by 10 and i'll make sure that we actually sort a to z so that way of course you can see exactly what we're getting back so let me go here and i'll chain that sort and i'm just going to be looking for the name and of course now we have a setup where we're alphabetically sorting our responses as well and in order to show you how so it works first let's take a look at our basic response so if we go here notice i'm getting 10 items correct because that is my limit and then i start with this item and then i have the next one next my next one so if i'm gonna go here with skip and for starters i'm just gonna say skip one notice that of course now we start with our second item so the item that was second in a previous response and if we keep making skip bigger you can probably already guess that we're just going to be skipping the items in our response so now of course we right away start with a letter b and once we understand the manual approach now of course we'll have to implement that in get all product and the goal is to use skip and limit to set up a pagination functionality nice and once we have discussed limit and skip now let's see how we can implement them to set up the pagination and in this case i'm not going to be looking for those values in reg.query meaning i'm not going to structure them because we'll set up the variables with the same name so i think it's just going to be easier if we'll go with rec query and then the page as well as the limit and all that so let's just scroll down again we're working right now in get all products i'll make this one smaller and we keep on scrolling keep on scrolling and then right after the fields we want to set up three values we want to go here with const and page so this is what the user is going to pass in same as they have here notice we go with page and then we just set up the page number now by default i do want to set up where we get the first page that's why you go here with page and then remember whatever is coming from the rec.query actually is a string and again just save some time i'm not gonna cancel log because we did the console.logs before and notice page is actually two correct but it is a string of two so of course before we do anything we need to turn it into a number so let me scroll back down and then i'll do the same thing over here where i scroll to the page and then we'll start with the number and then i'll say that i'm going to be looking for rec query and then the page now if the user doesn't pass the value then i'll simply use the or operator and i'm just going to say that it is going to be equal to one and the same is going to be for the limit i'll say that yes in the query there might be a limit since again it's going to be a number i need to use this number meaning since i want this to be a number but it's going to be a string we need to go with number and then we pass in rec query and then limit and if no limit is passed then we go with 10. that's why in a complete project you'll see this one where by default essentially we're just getting back 10 products hopefully we are clear on this one so if the value is passed in awesome we'll use this value if not then we have some defaults and now of course we just want to set up the logic and the way we set up the logic we go here with const skip and that is equal to page minus one and then we multiply this by limit and i'll show you with actual comment example just so we are on the same page so i'll set up the skip and now of course i just want to chain the skip and limit to my result remember we're still working on the result so once i have all of this functionality in place then we'll simply go with result is equal to and then we go with a result and then we change the skip we pass in the skip variable and then we chain limit and of course we pass in the limit variable now it's going to be kind of hard to see in our response so let me just set up some comments just so you understand how everything works so at the moment we have 23 products correct so if i decide to limit my response to only seven items how many pages i have well we need to divide 23 by seven and effectively we'll have four pages so we'll have seven seven seven so that's going to be 21 and then the last page actually is going to have only two items so we have total four pages and the way the logic works is following where the user will pass in some kind of value so maybe for the page is gonna go for 2 because remember by default it's always going to be 1 and then we multiply this by the limit that's the key over here so if we just have a default page we'll have 1 subtracted by one of course that is going to be zero and then multiplied by the limit still gonna be zero so effectively we'll skip zero items and then we'll just limit our response to seven however if the user is going to be looking for the second page then of course we'll have 2 minus 1 so have value of 1 and that is multiplied by the limit so in this case since i'm looking for page number two i'll skip seven over here and then i'll have the limit of seven so that's how i can see the second page and in order to showcase that let me just go to the static one and i want to get all the items just so you can see over here and i think i'll keep this as name and price like so and i'll sort this based on name and then let's do the same thing here so let me send it this is my entire list and then if i go to all the products now let me set it up everything correctly where i do want to still sort and i actually want to start i guess with a name and then i'm going to remove the price i don't really care about that i think so i mean let me just double check so select yeah so i'm only sorting by the name so let's see let's see so we have products i'm only sorting by the name and then when it comes to fields i only want to see name and then price and by default of course we're only going to get 10 because we already have that limit of 10. so therefore let me add here limit and i'm just going to go with a limit of 30. of course that is way more than we have the product so now of course i'll have all the products if i check it out here i have 23. now if i'm gonna be looking for page number two and i'll set up the limit where i wanna see only the four items or three or two or whatever then of course you'll notice that in here effectively we'll just skip whatever items we have in a limit so in this case if i go with limit off to just to make it simpler and then if i go for page number two so here we'll pass in the value of two you'll notice how we'll skip the first two items and we'll right away go for this one the albany sectional so let me send it here and check it out now of course we have albany sectional and i purposely set them up both the same just so you can see how it works so now of course we're looking at this page and as i'm changing the limit i'll be changing how many items i'm getting back and how many items i'm skipping and then when it comes to page of course it affects the amount of items we're skipping as well because if i go with three then of course we will skip two times whatever is the limit and those are the items we're skipping and of course that is going to return us that third page all right we're almost done with the project functionality the only thing left is to set up numeric filters or in other words provide a option for the user to search based on the number condition for example get only the product where the price is more than 30 or less than 30 and hopefully you get the gist but since there's going to be quite a bit of logic i will split this up in multiple videos and hopefully that way you won't be overwhelmed now just to showcase how is that going to look like i'm going to go to my final project and in here i want to go with numeric filters and of course i'll explain why we have this type of key and then we want to go with whatever property we want but of course it will make more sense if we're just going to go with the properties that actually have numbers as values so in our case of course we have price and then we'll go greater than and then of course we'll pass in the value so since i'm not using sort it's probably harder to see but it's definitely only the product where the price is more than 30. now just to showcase that let's go with ampersand let's add short and let me zoom in and then we're looking for the actual value and of course in here i want to pass a and d price so say here price and then let's check it out what we have of course we have 31 then 39 and on and on and on so this is how our api is going to look like now as far as the mongoose we'll have to use again those query operators and in this case for the greater one we go with dollar sign and then greater than and the same goes for less than but of course here we type lt now i'll show you all the ones that we're going to use in the next video now let's just try it out in our manual setup where we want to navigate back we're looking for the product and at the moment i have fined so let's go with price so let's go here with price and we set it equal to an object then we're gonna go with the dollar sign and then we'll pass in sorry not get gt so that's going to be greater than and then of course as far as the value well let's set up the same 30. and once we save of course and if we go back to our static one we should i mean we should let's see so at the moment i find name price and for some reason not returning any kind of value so let me send it one more time there must have been some kind of bug and now of course i can see only the items where the price is more than 30. and just so we can keep on practicing i'm going to go with sort and place here price let's see so that should be the ascending order and you can clearly see that we start with the product where the price is more than 30. so that is the manual setup and that's the general idea and now of course we can start working on get all products because in here we'll have way more logic nice and before we start typing away in get all products let me just showcase where i got the idea from and what are we actually shooting for and it's not going to be a surprise where i'm using again my api and as you can see here the key in the query string is numeric filters that's why we use the same one and then as far as the options of course they provide following so these are the ones where they have numeric values correct and we'll do the same so therefore in our case we'll just have one for the price and one for the rating and as far as conditions we'll notice how they use actually more userfriendly ones correct the ones that we're using in the final one and if we take a look at the mongoose one of course they have this dollar sign greater than and less than so pretty much that's going to be the biggest deal converting these userfriendly ones that we can simply pass in the url to the mongoose ones and in order to do that we'll have to do a little bit of regular expression magic but don't worry the code is pretty straightforward and of course i already got it for you and first thing we need to decide what is going to be the name for the key in the query string parameter and again i'll copy my favorite api at least for this course and i'll name this numeric filters so say here that i'm going to be looking for numeric and then filters now once i have access to the numeric filters i just want to scroll down and we'll do the same thing where again we'll set up a if condition and in this case i'll uncomment the query object because there's going to be times where i do want to showcase what we're getting back and let's just say with numeric filters and then as far as what i want to pass in well first let's go to get all product and again just to kind of keep this nice and sweet i'll remove rest of them and then at the end if we want we can add all of them but i'll just remove these ones and then we want to go with numeric filters because that's the name that i came up with meaning that's the one that you'll showcase in documentation and then as far as the values well let's simply go with price is bigger than i don't know 40 and then comma and what was the other one i believe that was rating and then let's set rating bigger or equals to four so let's send it to all our products and of course i didn't save it very very smart so let me go back over here i'm going to go with log and actually i didn't cancel log it either so let me look for numeric and we're going to be looking for of course the filters if they exist we want to console log them so let's go back over here and now of course i have empty query object because i didn't pass anything in and here i have one string i have price is bigger than 40 and rating is bigger or equals to four and the first thing we want to do is set up the operator map now what does that mean you'll see in a second so in here let's go with const operator and that map and in here i want to map the userfriendly ones to the ones that are understood by the mongoose so i'll say bigger than and then as far as the mongoose it understands the dollar sign and then we have greater than and once we have the first one of course we just want to add the comma and i'll copy and paste this four times and as far as the second value i'm going to go with greater than or equal and when it comes to mongos we just need to add this e at the very end then as far as the equal well we simply go with equal sign and then here we say equals and of course we'll do the same thing with less than and less than equals so in here let's go less than less than equals and as far as the mongoose values it's lt and then lte so once we have the map then this is where the regular expression magic happens where first i want to set up the regular expression and then we want to run the replace method where we pass in that regular expression and if it is a match then of course we'll change the value from the userfriendly one that we're getting in the numeric filters e into the one that is understood by the mongoose and when it comes to regular expression we just go with const and i'll call this rejects noun is equal to the regular expression and this one i got from the stack overflow so please don't overthink it you can always find those values you really don't need to come up with them yourself and inside of the regular expression we just want to go here with b and then set up the parenthesis and then you just want to pass in all of these values separated by the vertical bars so in here we go with less than then greater than and hopefully you get the gist and once i have all the values then we want to add one more b so let's go over here we add b and then we're going to go with a g flag and once i have my regular expression then i want to go with the replace method where essentially i call numeric filters which of course is going to be my string and then i'll pass the regular expression and if there is a match then of course we'll convert from the userfriendly one to the one that is understood by the mongoose so in here let's call this let filters and that one is equal to our numeric filters then we go with replace method and then as far as the first argument we want to pass in our rejects and the second one will be the callback function if there is a match so what we could do here i can access the match if there is one and as far as the functionality well i want to take this match and then i want to get the value that corresponds to something that is understood by the mongoose so here i'll return a string and i'll purposely use the template literal here and i'll purposely also add these hyphens and you'll see later why we want to do that so there's going to be two hyphens one at the start and then one at the end and then we want to access the actual value and now i want to go for my operator map and then i want to look for the match and hopefully you understand how this works so essentially i have the object object has the properties correct and then if there is a match over here then i just say hey get me that key and effectively i will swap the values and just so you can see how everything works instead of numeric filters why don't we look for the filters over here and then let's go back to the postman and send a request one more time and now of course you'll see the result so notice instead of this one where we have price is bigger than 40 and rating is bigger or equals to four now of course we have this we have price and then this is going to be that amongst value and the same goes for the rating and since i don't want to overwhelm you we'll stop over here and we'll continue with the logic in next video we have successfully converted our values to the ones that are understood by the mongoose but we're not done because of course i cannot pass this one into my query object we need to do a bit more data massaging and the way it's going to look first i want to come up with options because if you take a look at their api like i mentioned previously you can only do that on certain properties because these properties of course have number values and essentially we want to do the same where i'm going to go with options and that's just going to be an array and here i'll pass into string values i'll say price and rating because of course those are the two properties that use the number value and then we want to go with filters and set it equal to the filters and first again we'll use the split method remember that's the method that's splitting string into an array and i'll say that i want to split it where's the comma so of course now i'll have two items in my array i'll have this one and i'll have this one hopefully that is clear and then after that we want to go with four each so now iterate over that array and then in the callback function i'll have access to that item again it's going to be a string of price and yada yada and the same goes for the rating and then we want to do more splitting over there and effectively i'm going to split it into array and then remember we also have array destructuring where i can pull out the values and i'm just going to set it equal to item split and remember that when we were setting up our regular expression i purposely added here these hyphens so now each item so price and the rating i actually want to split it on that hyphen so say here split it on hyphen and the way the array destructuring works instead of object where we say a specific property whatever i'm going to type here first is going to match this price because of course we're splitting on hyphen the second one is going to be of course my operator and the third one is going to be the value so in here i can just go with field and then operator and as i said not if you need to catch up on the array of structuring i have that video in my javascript nugget series so let's go over here with the value so this is going to be the actual value and then only if the field so only if the price and rating is actually in my options only then i want to add a new property on that query object so in here right after that i'm going to go with if and then the name is options and we can use this includes method and if it includes the actual field then inside of the block i want to go with query object and then i want to set up the field so now again i'm dynamically setting up the property on my query object and since we're cancel logging of course you'll be able to see that and then as far as the value well again we need to go with object of course so let's set it here equal to an object and then we go with operator again this is dynamic of course because this operator will change in one case we have greater than in other case we have greater or equals so therefore again we go with operator that is coming from here and then as far as the value well we're still getting this as a string correct so we need to go again with number and then pass in the value so now of course once i save since we're constant logging you'll be able to see actually what we have in a query object so let me go back let me send it one more time and what you'll notice is this query object we have price and of course we have greater than and as far as the rating we have greater than or equals so what's really cool of course now we get the correct values where we only get the ones that have the price bigger than 40 and rating is bigger or equals to four so if i'll change this around and if i'll just say that i'm looking for a rating that is bigger or equals to 4.5 and then maybe the price is going to be bigger than 90 then of course once we save check it out we have only how many seven products correct so that's how we can set up these numeric filters in our api and once we have the numeric filters in place we're pretty much done with the project hopefully everyone enjoyed it and i'll see you in the next one all right and welcome to our next adventure the json web token basics project so far in our projects all the routes were public meaning anyone can access them and use them however they please but of course that's not how we want to set up apps in real world i don't want random people to access my data and i bet you probably feel exactly the same way so how we can restrict the access well i'm glad you asked a very popular method is using jwt or json web tokens and for the sake of simplicity just think of them as long strings now of course they're way more complex than that but let's just not worry about that right now and the idea is following imagine we have two routes a dashboard and a login or register route now dashboard is protected so i can click all day long on get data but i'll have no access to the info and only if i log in i get the token and only once i have the token i can access the secret info which in this case is just going to be a random number so let's try it out i have the dashboard clearly says here no token present and check it out not authorized to access this route and again i can click all day long and i can showcase that in the console where notice we're getting these 401 errors but i'll have no access to the data now in order to access the data of course i need to log in and of course this is just going to be a simple version where i just need to provide some kind of values if i won't provide the values then i'll get the 400 one so this is going to be a bad request and i still don't get the token so let's go up i'll say user name and i'm just going to go with my john and again you just need to provide some kind of values it doesn't really matter in a later project of course it will matter what we provide there but in this case we just need to provide something and only if i do that then i send it here notice user created so now of course i have no errors and also in the local storage i'm going to get the token now don't worry about the front end local storage and all that i'll talk about it in more detail later just think that you're getting the token and once the token is present and of course we can clearly see that here with the text of token present then we can make as many requests as we want in order to get our data again as long as the token is valid we are good to go now if again i'll try to submit and then i'll remove the token then again we're back to the not authorized this route now the reason why i made this project so simple and straightforward is because it's crucial that you grasp the main concept if you do i guarantee you you'll breeze through the upcoming projects even though they will be way more complex than this just always remember if a valid token is present in the request the user can access specific info now not all of the info of course you can only access the info that belongs to you so you cannot just randomly come here and get my data but still if the token is present you can get that specific data but if we have a restricted route so keep in mind that login is not restricted anyone can try to log in but if we do have the restricted route like we have with dashboard if the token is not present or it's not valid then the server in this case that's of course us will kick back the error response and that's how essentially we restrict access to certain routes aka certain resources and as far as the setup again we've got the folders final where you'll find the complete code and a starter where we'll do all of our work and when it comes to final you'll be able to spin it up once we cover gwt or json web token basics since you'll need to set up a variable in.env and when it comes to starter all of it should look very familiar and like i promised in a previous video in order to save some time on a boilerplate i already set up a basic express server for you so let me install dependencies and then i'll show you our app.js so let me zoom out i'll open up my terminal i'll clear everything and then of course first i want to navigate to the star one so grab it over here and then we're gonna go with npm install and then of course you will also spin up and pm start now when it comes to package json of course there are few other packages as well and i'll talk about them once we get there and when it comes to app.js essentially first i require dot env and of course that is in order to access the env variables then we have express async errors and if you remember we use that package just so we don't have to set up our own async middleware then we grab the express from express and we invoke it and we set it equal to app then we're looking for two middlewares not found one an error handler one and if you take a look at the folder the middleware one of course you'll see the error handler this is the one that we used all the way in the project number three this is essentially what we set up where we have the custom api error and of course we're looking for that instance and then if that is the case then this is the response if not then we just send back the 500 one the generic one and of course since we're using our own error class of course we also have it in the errors so if you take a look at the custom error one of course you can see that we have the class that is extending from the error and we'll do that because of course there's going to be some instances where we'll implement our own class instead and of course i'm importing both of them from the middleware like i said and then you can find the other one the not found here as well and then we'll also work on the authentication middleware that's what we'll find here the empty file then we keep on moving and we can see that we have app.years so we implement the middleware and in this case i'm looking for a static one so essentially we're serving static files because this is where our frontend app lives notice over here again we have index.html style css as well as the browser app.js and then of course we have express json and that is simply because one of the routes is going to be a post route and i want to access request.body so i want to get that data that's going to be coming in and then of course we implement both middlewares the not found one as well as error handler one and then we have the port variable we set it equal to process.env port or 3000 and of course in the final one it's a little bit different i believe it's 5 000 just so we don't have the port issues meaning just so we don't have two apps trying to access the same port and then of course i have a start one however you'll notice that in this case we're not connecting to the database so i simply wanted to showcase how everything is going to work without database and of course the next project will implement the database because of course that will add an extra layer of complexity and of course in here i just call app.listen set up the port i set up the console.log and if there is an error i log one now if you're wondering why i kept this db folder with connect1 just so you don't forget the setup again in the next project of course a major part of the application is going to be setting up everything once the database in this case i just wanted to showcase how everything is going to work in isolation and if you can see server is listening on port 3000 you can bravely navigate to your browser and we're looking for localhost 3000 and of course you'll see the app now nothing is going to work i can guarantee you that because of course we have no routes but you should see the ui so you should see the form as well as this g brush here in the bottom and if you do then of course we're in good shape and now we can start working on the project beautiful and once we're done with the setup next i want to set up our two lonely routes so we'll have one fake one for the login register and sign up and please understand that of course in the following projects there's going to be a huge distinction whether we're registering or we're actually just logging in but in this case we'll jam both of them together because our main concern is going to be that jwt or json web token and as a quick side note in the following videos when i use term jwt of course i'm talking about the json web token and then basically what we want is to set up those two routes and we already know how to do that so of course we have the routes folder in there eventually we'll have the router and then we'll also have the controllers so in this case let's just start with controllers so i'm going to go here with const and effectively i'll set up both of these functions and i'll go with this sync because remember we have the package that handles that the express async error so we don't have to set up the try catchers or our own middleware and we can simply go with rec and res and as far as the response we'll just go with the res dot and then send and here i'm just going to say fake login register and then of course d sign up and like i said normally of course there's going to be a difference whether we're logging in or we're registering however in this case we'll just mush all of them together and then we'll say we're out here that's for the login and when it comes to dashboard this is where we want to share that secret or authorized data so let's just say here dashboard and that will be equal against your sync rook and res and here let's do it a little bit more interesting where i just want to set up some random number and i'll call this a lucky number and of course that will be equal to math random which is coming from the javascript we'll multiply this by i don't know maybe 100 and then let's wrap everything in the math floor and essentially we should get the random numbers between 0 and 100 and then once we set up the lucky number let's just go with the res dot status and of course eventually this route will be protected but of course for time being we'll just go with res dot status 200 and then i'll say json and we'll be sending back the object i'll say message here and eventually it's going to be the name of the user and therefore i'll place everything right away in template string but for now since we don't have the user i'm just going to say john doe and then the other property on the object is going to be a secret so let's say here comma secret and again we'll use the template string and we'll say here is your authorized data your lucky number and then of course we'll access the variable and once we have all of this in place once we have the first string as well as the second one with lucky number now of course we just want to export them and i think for now i can just close the console as well as the sidebar and we'll just go with module exports and of course we're exporting the object and we're looking for two functions login and dashboard and it looks like i made a big old doozy where essentially i set up my code in the router instead of the controllers my apology so take all of this code cut it out from the routes and you're actually looking for the controllers we copy and paste and then back in or out of course this is where we want to set up the router so in here we're looking for express just like we did before we go with require we're looking for the express package of course then we want to set up the router so const router is equal to express.router router we invoke it and then we're looking for both of the controller functions and those are login and dashboard and both of them are coming from the controllers so hopefully you're able to fix my bugs and essentially we want to go two levels up and then we're looking for the main and then once we have all of this in place eventually there's going to be a middleware for authentication as well but for time being we'll just go with a router and then in here let's go with dashboard first so dashboard and this is going to be a get route and we'll simply pass in the dashboard controller now the login one is going to be a post one because of course we want to get those user credentials the username as well as the password so we go here with router then route then forward slash login and of course in this case we go with post method and then we'll pass in login and then last thing we want to do is of course export this so module exports and we set it equal to the router and then once we have all of this in place we go back to the app.js we're looking for the main router so i'm going to go above both the middlewares and i'll say here main router now that is coming from my route so require and it's in the same folder essentially it's in the root so we simply go with forward slash we're looking for the routes and more specifically main and then where we have the middleware for not found one and all that above it we'll just go with app.use and again what is going to be that root endpoint well in my case again i'm going to go with api and then version one because that's the setup that i have of course e in the postman and then of course we'll just set up that every time we get a request on this root endpoint we'll just go with main router so we go with main router and of course in the main router we have the dashboard so that one will be api version one forward slash dashboard and then for the login you already can imagine that it's going to be api version one and login and once the basic controllers as well as the routes are in place now of course we can move on to our next task nice and once we have our basic controller setup in place now let's also test it out e in the postman so in here we want to go with another collection and of course i'll give it another name and i'm going to go with 0 5 and pretty much the same as the app name so say here jwt basics and then in here we'll have two routes one like you just saw is going to be to get one and we're just going to be looking for the url then we'll go with forward slash and then we're looking for the dashboard of course so that's going to be our get route once we send the force we should see hello john doe yadda yadda the lucky number is 90 and notice how every time we send of course we'll get a different value and this is done on purpose just so you can see that we are getting a new request out and then of course i just want to save it so let's say over here and of course i want to save it here in my latest collection and then i want to do the same thing with my other route with log in one but of course that one is the post one correct so let me close this one and we'll just start with post then we're looking for the url and of course the route is logging here and just to jog your memory when it comes to the post route of course we want to send some kind of data to the server because effectively we want to create a resource on a server so therefore we go with body we'll go with raw and we'll set it equal to json and in here let's just go with username because this is what we'll be sending from our frontend application as well as the password and of course since we're just testing everything out we can go with whatever values you want and as a side note in general we'll only check if the values are provided now in the following project of course this is where the things are going to get way more interesting than that but for now you just want to send username and then comma and of course the password and as far as the password i think throughout this project i'm just gonna stick with secret and then once we send of course we have fake login blah blah blah which means that everything is correct and once we have tested both the routes and once we have properly saved them in our collection so here let's just call this login register and of course we can start focusing on the real logic therefore in here i'm just going to save it and we can start working on our next task and before we continue let me just give you a big picture of what we're about to do so first we know that we have a post route the login one and essentially since we want to log in or register user in this case we're going to be looking for two things we're going to be looking for username as well as the password and we already know that it's going to be available in reg dot body now if both of them exist we want to create a new jwt if not then we want to send back the error response then we want to say hey listen please provide email and password now if we're good if we create a new json web token then of course we want to send it back to the front end since frontend needs to access it in order to send another request in order to send the get request where essentially we display this secret information and on our end we want to set up the authentication so only the request with jwt can access the dashboard otherwise if you go currently to our front end notice and click here and i can actually access the data but that's not what we want what we want on the front end here or from the postman doesn't really matter but of course with front end it's just easier to see we want to provide username and password and only if both values are provided then we get back the token and only with our token we can make a successful get request and eventually display our secret data on a front end otherwise we get an error since the dashboard route is restricted and only accessible by authenticated users or in other words only by the requests where json web token is present and if we take a look at the comments the first thing we want to do is check for username and password and since it's a post route we already know that data is going to be indirect.body so here we go with const and then looking for both things username password and this is going to be the case where i will log them out so i'll set up here log and i'm going to be looking for both user name and password this is the case where you can send those requests from the front end but i highly encourage you to do that from the postman first and only do that later once our jwt functionality is in place so my case i'm going to navigate to my postman i'm looking for the login one i have the body yeah that's awesome and then i'll send it and back in my application if i take a look at the console of course i have john and secret there also could be a case where the user is trying to log in with just empty values correct so he or she can send this type of request and now on the console i can see that i have nothing and before we issue the token which eventually will allow the front end to access the route i want to check whether the username and the password have been provided now eventually once we work with database effectively we have three options first option remember when we use mongo's required validation it checks that for us if the value is not present it simply spits back the error so that's definitely one route that we can take once we introduce a database but in this case remember we're not connecting to the database another option we have is to set up the entire additional layer of validation which is going to be sitting in front of all of our requests and in order to accomplish that task we'll utilize another package by the name of joy but i only want to do that in a later project once we have a solid understanding of the json web tokens now the third option is actually checking for both of these values over here where i can say hey if the username or the password have not been provided then i'll send you back a a response now in our case what's really cool we have that package that wraps all of our routes and we simply want to throw a error what error well our custom one where we say hey listen you did not provide both values so therefore we'll send back a 400 response which essentially is a bad request so let's try it out i'm going to go back to my controllers and here i'll say if and then if there's no username username and the setup let me move these ones up and i'll add that comment check in the controller in the controller and once we're done i'll actually show you how we could have used that in task manager as well so let's go down and then we have username if it doesn't exist or if the password doesn't exist so essentially if one or both are missing then we want to throw that error why well because that's what we can do since we have that express async errors now what error are we looking for of course that is our own one so in the controllers what we want to do is import our custom error so let's go here with const custom api error now that is equal to require we're looking in the errors in this case and more specifically we're looking in the custom one and if the user hasn't provided the values of username and password then of course we can simply throw a new error and remember this is going to be handled in our own error handler middleware correct the middleware that we set up it's going to check for our own api error and if that is the case then we'll send back the status with the status code as well as the error message so now we simply want to throw new custom api error my apologies i started typing error actually we need to go with custom api error and here we'll say please provide email and password and as far as the error code it's going to be 400. so 400 stands for bad request and once we have the code to throw the error now i can remove this cancel log and let's just go back to the postman and test it out so if i haven't provided anything i should have please provide email and a password and status code should be 400. again if you already forgot how the custom api error works and all that please go back to the previous project i believe we set it up in task manager where i covered all of this e in great detail so essentially if these two values are not provided we have three options we can either use and you know just so it's less confusing i'll write here mongoose validations or we can set up another validation layer with the help of package by the name of joy which we'll do later or we can simply check in the controller and just to showcase if you take a look at the task manager so remember that was our third project where we essentially just started working with database more specifically if we're looking in the controllers and then create task remember we handle this with the help of mongoose correct because if you take a look at the models you'll see the name and this one is set to required now the same way we could have just checked e in the controller we could have just said okay check if the task exists if it doesn't exist we throw the error in this case it was a little bit different we used next since we used our own async wrapper the general idea doesn't change we're still throwing the error and if everything is great then we're creating a task and the only reason why i'm telling you all of this is just so i understand that you have multiple options you're not limited to just setting up the validations in the mongoose yes you should do it it doesn't mean that you should skip that part just be aware that there's extra layers of validation that we can add and in our case we simply set them up right in the controller so if the username or a password is not provided just throw the error which gets handled in our own middleware in the error handler one and here we just check for the custom api and then we send back the response and of course if that is the case we don't send back this string we send back the error all right we check for empty values now what well now we need to create a json web token and send it back but before we do that let's back up a little bit and take a look at the big picture one more time so far we have been setting up all our routes in the following fashion as long as the endpoint exists user just needs to make a request and our server will send a response but that's about to change from now on we'll have two types of routes the public ones accessible by anyone and restricted ones accessible only with correct signed jwt or json web token so back to our app if the user provides correct credentials meaning in our case of course those are just some values in the username and password we send back the signed json web token and in order to access dashboard wrote he or she basically a frontend needs to provide the same token otherwise we'll kick it back with an error response and before we analyze the structure of the json web token let's talk about some big picture things first and let's start with general concept json web token is just a way to exchange data between two parties and probably the most common example for such parties is a frontend app and our api now why using jwet is far better than just some random string simply because jwt has a security feature where we can be sure about the integrity of our data if the token passes the validation it means it's the same token we sent to the client and the data wasn't tampered with second for now don't worry how and where the front end will store the token i'll discuss it in more detail in a few videos and third please keep in mind that one of the features of http is that it is stateless and that simply means that server does not know or you can think does not remember any previous requests sent by the same client and as a result yes even after the first second or even the 200 successful dashboard request frontend will still need to provide the valid token otherwise the axis will be denied remember how i suggested to think of jwts as long strings well of course it's way more complex than that so now let's spend few minutes on the jwt structure and then of course we'll dive back into the code and a very good resource is cite by the name of jwtio again the url is jwt io and more specifically we're interested in two pages the introduction one and the debugger and i'll start with introduction and i'm not going to read the entire thing line by line that just seems a big waste of your time but i do want to point out some things here and there as always if you are interested in learning more you know already where to find it and the first thing that i want to point out is this sentence where it says this information can be verified and trusted because it is digitally signed so this is what i was saying in a previous video essentially we do that using the secret and the algorithm and we'll learn more about them in a few seconds so let's just keep on scrolling they say when you should use tokens okay and this is going to be the structure for the web token and like i said the result is going to look like a large string but of course it's way more complex than that and essentially in the json web token we have the header payload as well as the signature and when it comes to header consists of two parts and one is going to be the type of token and of course we're going to go with jwt and the second one is going to be the algorithm that is used of course to create that signature then this one gets encoded with base64 url so we'll code this one and then we have the payload in the payload this is where we'll place the information and as an example we can place here the id of the user that just signed on or logged in or registered or whatever then we send back the token the entire token with that payload back to the front end then the front end sends it back to us and then when we decode we get that id and essentially what that means is that if the user has some kind of resource we access right away resources that belong to only that user so essentially if you create some kind of resource only you can access it or modify modified or whatever then we keep on scrolling keep on scrolling and i'll talk about the payload of course when we actually create our own token this is just an example of what we can send back again this also gets encoded with base64 url and then lastly we have the signature and as far as the signature this is where the algorithm is used the one that is specified in the header and then we add here the secret to sign our token and as far as the secret this is something that we'll have to keep on the server and again i'll talk about when we actually create our own signature so once we set up our first token then i'll talk about it how and where we should store the secret value and the idea is we have the algorithm we have the encoded header as well as the payload then we take the secret string value that is always going to be only on the server and then we sign this one and then once we sign this is going to be a result so essentially this is what we're sending back to the front end and after that we have a bunch of useful information of how we can send back the token from the front end and this is something again we'll cover a little bit later once we already create our token so we'll swing back and i'll discuss what is the better and all this cool stuff and as far as the structure i think we're pretty much done i just want to showcase in debugger that of course we have the token like i said this is the signed token the encoded one and this is what we're sending back to the front end so this is what the front end will receive now once we decode there you go you'll have information about that user so you'll have some kind of id maybe a name and when it was issued and of course later we'll do something with that data so this is that id that we're looking for the user id and then we can use this id to access the database resources and all that cool stuff hopefully we're clear on the structure so now we can take a look at the package we'll use to sign and decode our tokens when it comes to signing and decoding our tokens there are quite a few packages out there so you definitely have plenty of options but for my projects i usually use package by the name of json web token of course if you're using starter i already installed it for you but if you ever want to use it in your own project just run this command and as far as the docs since we'll use only two methods i'm pretty sure i won't return here but of course if you ever need more info just utilize the search engine nice and once we have discussed the general principles of jwt now let's try to issue one in the project and first what we want to do is import the package and again the package we're looking for is this one the json web token and of course we want to assign it to some kind of variable so i'm going to go with jwt is equal to require and of course we're looking for the package and once we have the package after the if assuming that both of the values are provided we want to create a new token and we do that in following way so we come up with some kind of variable in this case again it's going to be a token pretty straightforward and then we go with jwt so the package name and then we're looking for the sign method and then in the sign method we want to provide three values we want to provide a payload a jwt secret essentially is just a secret string and then the options now when it comes to payload you go with object and pretty much in here you can pass whatever you want sky's the limit now please remember one thing you don't want to send back some kind of confidential information so don't stick a password over here that is a very very very bad practice now what normally gets sent back well if we're creating a user a id is very helpful because then later on when we're authenticating the request we can check for the user if i'm creating a user and that user is i don't know checking for some kind of resources we only provide resources that belong to the user so in our task manager application we only provide tasks that belong to the user and as a result only the user who created task for example can view it or it and hopefully you get the gist so in here i'm just gonna go with username that was already provided over here so that's what i'm sending back and like i said normally send back the id but since we don't have the connection to the database i'll create a dummy one from scratch i'll simply go with id and then i'll go with new date and i'll say get time and let me just add a comment just so it's clear that this is only for demo and once i have both of the comments first i'll add the id and then i just want to mention here that when it comes to payloads it's a good idea to keep them small because the bigger the payload the more data you're sending over the wire and of course as a result for someone with bad internet connection the user experience might not be the best one so that's about it for the payload and then we want to provide that jwt secret so we go here with a comma and we right away want to set it up in our dot envy so of course we need to create one from the scratch and in the star we're going to go with new file dot env and then we need to come up with a variable name and in my case i'm going to go with jwt underscore secret and when it comes to value in this application i'm just going to go with something really simple as jw secret but let me grab the comment that i left here just for a demo in production use long complex and unguessable string value and when it comes to more complex projects i'll show you how we can create one so let me just take this one out and then i think i'll just leave that in the controller there right below the payload small comment where again you always always when it comes to production you want to have them long complex and unguessable in this case we're just cheating because i don't want to bother with that so we go with variable and then some kind of value and now of course we just need to go back to the controller here and then remember we can access it with process dot env and then more specifically we're looking for jwt and then underscore secret and if you're confused or just wondering why we're so fussy about this jwt secret string if you recall the json web token structure video this is the secret that is used to sign r tokens and therefore it's a good practice to only keep it on the server and make it more complex than our current jwt secret just keep in mind that if someone gets a hold of your key they can start signing tokens on your behalf and that's definitely not the spot you want to be in as you can see even in the docs they suggest your 256 bit secret and like i already mentioned in the following project i'll show you where and how we can set up a proper secret value in no time and then the last thing we want to provide is options and we're going to go with expires in option and i'll set it equal to 30 days and i'll come back and talk about the expirations and all that a little bit later so once we have the token now of course we want to change our response where instead of the string we're going to go with actual status so set it up over here 200 then that and of course we're going to be looking for the json here and then let's just add here a message and we'll say user created user created and this is the case where the front end is using that message so i strongly suggest keeping it the same way and then we'll go with token so effectively we have our token and now we just want to send back to the user so once we save we're going to go back to the login one and in this case i'll try one more time providing empty values and of course in that case i get back my error one but if i go here and if i say john and secret i should get back my json web token and of course i do and what's really cool if you take this value and just head back to the website and just copy and paste what do you know of course now i have username some kind of fake id and this is going to be the expiration so as you can see this is the payload that we're sending not bad not bad we signed a token sent it back to the front end now well first we need to understand how the request with the token already present is going to look like but before we continue let me just emphasize something since it's a backend course we're not going to dwell too much on do's and don'ts on the proper jwt storage on a front end yes of course there are best practices and don't get me wrong they are important but our current goal is to secure resource access on the server and therefore we're only really interested in how the request is going to look like so we can implement the correct functionality on our end and if you keep reading the introduction you'll see that a common approach on a frontend is to set up the authorization header in your request so of course in our case that is going to be a get request and then add the bearer schema essentially what that means is that we have the header by the name of authorization then we go with bearer and then space and then the token and in this video i'll show you how it looks like on the front end as well as the front end code and then in the next video we'll do it together in a postman and basically the idea is following where i have the username password and all that and i just go here with peter and then i pass in my secret and what i want you to see is the local storage because of course at the moment we have nothing in there and the idea is following where i will get back to token because of course i'm providing some kind of values in the username as well as the password and now check it out here i have token so now of course when i'm making that next request so if i go here with get data of course in my code i just grab the token from the local storage and of course i'm successful and if we take a look at the network requests so again this is going to be for the login this is to get the token and then of course as far as the dashboard just open it over here and notice the headers so we keep on scrolling the request headers blah blah blah and what we're looking for of course is this authorization one so that's the one that we want we have authorization then we have the bear and then of course we have the token and if you're interested in a code just navigate to browser app.js and first what you want to do is to look for the form event listener we're listening for the submit event and then in here i have try and catch and in the try and catch i'm using axiorys library with a post request and surprise surprise i'm sending this post request where to a login one and what am i passing in passing in username and password and what happens if i'm successful notice this line of code we go with local storage set item token and then whatever i got back from the server so i right away save this token in the local storage now there's also a catch and in this instance i just removed the token now again this is just my preference just so i can demonstrate things but hopefully you get the overall idea that of course on the front end you'll store this token somewhere and then of course when it comes to actual request i have the button i have the event listener the click event listener and then i'm issuing a get request of course where is it going it's going to the dashboard and the way we add the headers again this is just for axiorys library but the idea is going to be exactly the same for fetch or any other ajax library where you'll go with headers and then of course the name is authorization and then like i said we go with bearer schema and then we add the space and then we pass in a token and as you can see i'm getting this token from the local storage and of course let's take a look how we can send the same request with a postman and once we have discussed in theory how we can send back the token let's try doing that in the postman so in a login every time i send a successful request meaning where the username and password are valid values instead of empty strings then of course we're getting back the token and of course all this time i'm creating with john but just understand that every time we're getting that unique token and what we want to do take this token so copy this one and of course don't worry later we'll set it up with different usernames at the moment there's really no need for that and then back in the dashboard so in our get request we're not looking for the body we're looking for the headers and in the following project i'll show you how i can do that dynamically in postman because of course when it comes to bigger project is going to get annoying really fast if you have to all the time copy and paste those tokens just to test something out but in this project yes we'll do this manually so again we are in the dashboard that's the route of course it is get and all that and then we're looking for the headers and header name is going to be the authorization one then we want to set it equal to bearer that's the name and you have to follow this to the t so bearer and then copy and paste the token so now of course if we send yeah we get the value blah blah blah we have the number but what's more interesting if we go back to the dashboard and if you log request headers you'll see something really cool where if i go with request and like i said headers now let me send one more time again the token is still valid we have 30 days so everything is going to work if i scroll up check it out we have authorization header and then of course i have the bearer and then this is the value and this is what we'll do in the following videos we'll extract this and actually validate it and if it is valid only then we'll send back the data with the actual username the moment of course we just have john doe but eventually we'll set up where whatever username gets sent back to the frontend well that one will send back here because that way we'll showcase that we only access the specific resources that the user has not just some random ones beautiful and in order to get to this value we'll just have to do a little bit of javascript magic and we'll also have to throw a few of the errors if the values are not provided so in dashboard first i want to assign that authorization header to some kind of variable and in my case i'm going to go with auth header and then i'm looking for a request and then of course headers like i said and then we're looking for the authorization one so once i have access to the header then i want to check whether it actually exists because maybe user is sending a request without the header altogether and if it exists whether it starts with a better and then the space again this is very very important that the syntax is exact because if it's not going to be exact then of course all of this loses the meaning so let's say here if and then off header so if it doesn't exist or the auth header and then starts with that's the method that we can use on javascript strings and in here i just want to say if it doesn't start with the bearer then of course we'll throw the error so if there is no authorization header or it doesn't start with bearer then of course we'll throw our custom error so i'll just add here bear and then the space now if that is the case what we can do well we can throw our own custom error and in order to speed this up i'm just going to copy and paste we're throwing the error and normally you're going to be way more awake than this but in this case since we're of course just testing the jwts i'll say here no token provided in that case if you hit some kind of roadblock at least you know where the error is coming from and when it comes to text normally it's going to be along the lines of invalid credentials to access this route and as far as the status code instead of 400 it's going to be a 401 so that is not a bad request that is actually the authentication error but again in this case just to make it easier if you need to debug i'm gonna go with no token provided and then as far as the error we're gonna go with 401 and of course in order to test it out why don't we go back and then i'm just gonna uncheck the authorization just so we can actually see what we get back and once we click check it out now we have message no token provided and what is the error of course error is 401 now if i go back to the authorization header and if i send now i can see something went wrong try again later that's interesting so let me double check my code and yes of course it starts with not start with so let me try one more time let's send and there you go now of course we have hello john though and of course the secret as well and once we have passed the first stage now i just want to get that token and we can access it in a following way where i'm going to go with cons token is equal to auth header and then we want to split it again this is a string so we split it on a space and we're looking for the second value and if you want to double check let's go with token and let's cancel log it just so we are on the same page so let's send one more time and as i know there's a tiny bug there as well and you should see in the console a token and i'm also going to fix it over here what i'm going to say your lucky number and once we have all of this in place now of course we just need to set up the verification where yes we got back the token from the front end however now we want to verify whether the token is actually valid and as far as verification goes something like this where if you take a look at the docs of the package the json web token one you'll see that one of the options we have is using try catch and then we just need to come up with some kind of variable name in my case i'm going to go with decoded and that is equal to the package so jwt now the method name is verify and here we need to pass into values we need to pass in the token and then the second value is that secret string so again we go with our process dot env and then the jwt and if there's some kind of error for example the token might be expired we'll handle that in the catch block and what do we want to do well we want to throw another custom error and this is going to be the case where i'll show you that vague response where again we'll throw custom error if we're not able to verify the token and as far as the response will say not authorized to access this route hopefully this is clear so we try to verify if there's any kind of issue we throw another custom error and in this case we go with not authorized to access this route and again the code is still 401 because that is authentication error and then of course if we're successful then we just keep on typing because all the data is going to be in this decoded now what data you might ask well let's go to console.log and let's check it out together so let's cancel log one more time let's send it here and now of course you can see that i get back my id username as well as other two properties issued at and expiration and of course all of this is coming from our payload the one that we passed over here when we signed the token so of course you can already imagine that if the name is going to be different for the user name of course this value will also change and by accessing that value now of course we can set up a dynamic response so what do we do over here we just say okay we have access to the decoded one so let's take our code and just move it up place it in the try block and then instead of just console logging i'll keep the random one and all that don't worry there's gonna be a little bit different setup in a second anyway but instead of john doe we'll go over here with decoded and what is the property that i'm looking for on the object of course that is the username so we just go back over here to the username and if i navigate back to the postman now of course once i send i'll get back to john so let's go over the steps in the postman first and then we'll try it out in the front end in our application so first let's go with login again i'll try to log in without providing the username for example i'll send it over here now of course i have please provide email and password so that was that first check so if we are successful here if i provide peter then of course i'll get back my token awesome and i can see that the user has been created then we want to go to the dashboard and where we have authorization header now i want to change this around where instead of this value again just make sure there's that space that's a big deal here we'll provide this value instead and now of course i have hello peter and then again some random lucky number and if everything works in a postman it should also work on the front end so let's try it out over here let's refresh of course we can see no token present and here i'll just try to get the token without providing the values and of course not successful so i get back the error and therefore i'm going to go with anna and then again some kind of dummy password we send it now we're successful user has been created of course i can see that token is present oftentimes the token is going to be in local storage and of course it is so now of course when we're making those following requests now the token is present so we're successful now we can clearly see our username and then we're getting those random values so all the following requests are going to be successful as long as we provide a token and since token is in the local storage of course we can always access it when we make it and then we're good to go now if we remove it and in this case i just set up the functionality that if the user tries to get the token without providing the values then i just wipe out the token in the local storage so if we go back notice it's actually empty now i'm not saying that that's always going to be set up on the front end it's just something that i used in this case so now if we go back again we don't have the token so we get this not authorized to access this route nice work we're actually done with the main functionality but just like in a previous project once everything is in place let's also work on some improvements which we'll use heavily in the following projects and first i want to set up the authentication middleware and essentially the idea is following where yes at the moment we have the dashboard route and in there we're successfully checking whether the json web token has been provided and of course if it's there then we send back the lucky number if not then we throw the error but we need to understand that in a more realistic application of course there's going to be multiple routes that use this functionality and what are we going to do are we really going to copy and paste for every route that needs it or it just makes more sense to take all this code stick it in the middleware and then just choose which routes need to be authenticated and of course the answer is setting up our own middleware so first let's go to the middleware directory in there you'll find auth.js and we'll just start very simply by creating a function that function of course is going to be a sync and we'll be looking for rec res and next and next is very very important because otherwise our whole cycle is going to break and then of course we just want to cancel log so in the beginning we'll just cancel log and then we'll set up the functionality let's go over here as always naming is really up to you i'm gonna go with authentication and then middleware and that is equal to like i said async then we go with request and response and then next because remember in order to move on to the next middleware which of course in our case is going to be a dashboard route we'll have to call next and i'm going to go with console.log then i'm looking for rec headers and then more specifically i'm looking for the authorization one i just want to check whether it exists and then i want to go next like i said and then of course we invoke it now we just need to export this so we're going to go here module and export and that will be equal to my authentication middleware function and now another million dollar question so where are we going to use this middleware now in a later project we'll actually use it on multiple routes but in this case we only have dashboard that needs it correct so as far as the login this is going to be for public access but when it comes to dashboard this is going to be protected by that authentication middleware so therefore in the router in the managers we're going to go here const and then of course i'm looking for my function and in this case i'm just going to call this auth middleware and that is equal to require of course then we had the middleware folder and the auth file and the syntax is following where where we have this get method before the dashboard i actually want to stick my middleware so i'm going to say auth and then middleware and i'll add comma so now of course every time someone's going to be hitting this route first they'll go through the middleware and of course in the middleware since i have next then i'll pass to the dashboard and in order to test it out i'm just going to navigate to the browser so this is where i have the working application and it doesn't really matter whether you're logged in or not just go here to get data and of course in my case i haven't logged in i have no token so therefore i'm getting back this not authorized access this route but what i'm more interested is back in my application in the console i can see bearer and that is set to null so now i know that all the requests that are going to the dashboard are actually hitting this off middleware first so now of course we just need to add the functionality and we'll be in good shape beautiful and once our bare bones setup is in place now we simply want to go back to the controller the main one and we'll need to copy and paste two things and again i'm just doing this just so we can get to the functionality and you're looking for jwt because of course we'll implement that functionality as well as the custom api error and as i said not in the following videos we'll work on more errors so essentially we'll create here more error classes so i'll have to do some refactoring as well but for time being we'll just grab these two lines of code we want to go back to the auth we want to make sure that the paths are correct so as far as json web token of course it doesn't really matter i mean that's the package we installed we just want to make sure that this path is correct and it looks about right so now of course let's go back to the controllers let's keep scrolling keep scrolling so of course that was the previous route the login one and as far as the dashboard we simply want to take this logic where we're looking for the header and if there's some kind of issue of course we just throw the custom api error then we get the header and if everything is great if we can verify the token then instead of setting up right away response in our middleware we're actually going to set up a property on a request object and the property is going to be user and then we'll pass it to the next middleware which of course is going to be this dashboard route so let's go step by step let me take these i mean what is it five lines of code take it out so everything up to try and catch you want to go back to the auth js now you want to remove the console log and just keep the next because that is very very important then back in the controller you also want to take the try block but we'll have to do a little bit of acrobatics here because i'll actually need these lines of code so let's go back over here take the try catch as well step by step and then copy and paste and here the logic is following where you want to remove this response with lucky number so these things go you want to cut it out and go back to your controller and set it up in the dashboard so this logic stays of course the same where we have lucky number we generate that and of course we only send that response if we're successful now back in the author js like i said we're still checking for the header we're checking whether it starts with bear if not we throw the custom api error that's why we import it over here then we keep on scrolling we get to the split we get the token and now of course we have try and catch where we are invoking the verify method we pass in the token that we're getting back as well as the secret one and then if we're successful then instead of sending a response since we're working in the middleware the logic is going to be following where i'm going to go with const and then i'm looking for two things i'm looking for id and the username here and that one will be equal to decoded so of course if i'm successful this is going to have some kind of value if not we'll throw the error and then if that is the case i want to go with and i'll just set it up to the object where i'll have id and username and of course once i have set up the user property with this object value now of course i want to call next so we'll move this next up over here and what happens in the controller in the request we'll have that user property and now instead of looking for decoded of course we'll look for the user now in order to make it a bit more explicit i'll actually cancel log it just so you can see where it's coming from so i'm going to go here with rec and user so you can clearly see that we're getting that from our middleware of course and then instead of looking for decoded we're going to go here for user and username now in this case i also need to add direct since of course i didn't destructure it so on the request object and i have the user property and in there i'll have the username as well as id and let's just test it out one more time to functionality so again i'm gonna be on localhost 3000 i don't have the token so now of course i shouldn't see anything in the console and i don't because remember we only get to the dashboard if we're authenticated so let's try it out here where i'll say peter and then again my secret password i'll submit okay i created a user token as present and then once i click on getting the data now of course i have hello peter and i'm getting the lucky number and now if i take a look at the console check it out now of course on the request object once we get to the dashboard we actually have the user with id and username peter and of course this is coming from our middleware where essentially again we check for the authorization header then we check for the bearer we split it up we get the token then we use try and catch because we want to run the verify method and then we pass in a token we pass in the secret and then from the decoded we get the id and username and since we want to pass it to the next middleware essentially we create a new object we say user object on the request and then pass it on to the next middleware and of course if we're not able to verify the token then we send back our custom api response and again the end result is following where you can set up whatever amount of route you want and in front of all of them you can just stick off middleware and then you don't have to repeat this code the code is sitting in one place and check for token if the token is not present then you just send back the error response and once we have the middleware in place now i want to switch gears and talk about the errors and if we take a look at our application at the moment we have two types of custom errors we have one for 400 that's going to be the bad request and then we have another one for authentication where of course we have 401 and technically we have been doing fine with just this one custom error but there's actually a better approach where yes we have custom api error that extends from the error so this logic stays the same but instead of just using this one class will actually extend from this custom api error and then for every type of error we have which again in our case r2 we have one for battlequest and the second one for authentication we set up two more classes and then in those classes we right away hard code the status code and i fully understand that this might sound confusing so let's just start working on it and in the process you'll see what i mean so first what you want to do in the custom api error just remove the status code we'll set them up in separate classes and then we want to create three more files and we're going to start with index.js and you'll see at the very end of the video why we want to use that then we want to set up two more and we're looking for bad request and we'll go with js and then i'll set up another file by the name of on authenticated and then of course it is js and then in the bad request what we want to do is pretty much take the code that we have in the custom error one pretty much just copy and paste because we'll just change some things around so copy and paste over here and then i want to close this one so i'll say close saved and then instead of the custom api error we're going to go with bad request that request and of course this is going to be extending not from the error actually it's going to be extending from our custom api error so let's go here with const and we're looking for custom api error now this is in the same folder correct so we just go here with the require and then we pass in the path so the path of course is custom api error and instead of like i said extending from the error we're standing from custom api error and then we still have the constructor we don't want to use the status code over here and as i said not you know what in customer i also want to remove it so we just have the constructor and super here as far as the message and then in the bad request this is where not only we have super method with a message but it will also go with this dot status code status code and we'll set it equal to some kind of hardcoded value now for the battlequest what value we're going to use well we're going to go with 400 and then of course instead of exporting custom api error we're going to go with bad request and now we simply want to take all of this code copy again just so we can save a little bit of time and paste in the authenticated one and then of course again i'll have to change some values around where this is going to be the unauthenticated error so let's go over here on authenticated and we'll call this error of course we're still looking for the custom one so we're still extending from this one now the status code is going to be 401 and here we'll also say that we're exporting on authenticated error and then we want to go to index.js and here we'll import all three of them the custom error the bad request as well as the unauthenticated and then we'll export them as one big object and you'll see once we start factoring the application why it's more useful so essentially if you want you can technically leave it the way it is just remember that every time you'll need to use one of these you'll essentially need to look for that specific file if we set up this index.js first of all you'll be able to look just in the errors because by default the index.js will be served and in there we'll have all of the errors so let's start here with const and then custom api error and of course i'm looking for the file by the name of custom api error then we copy and paste and we just want to change these values around so of course this will be the bad request one and then last one will be that authentication one and of course we just want to change these files around so this will be the bad request one and then the last one will be equal to our authentication one and then we want to set up the object we'll say module exports and that is equal to our custom api error and then the battery quest one as well as the authentication one now of course at the moment our imports are a little bit different but before we do that i also want to talk about the status codes so let's just fix the status codes first and then we'll do both things we'll import the proper error classes in our application and also right away set up the status codes using the external library all right so far in our application every time we need a status code we just type the number value which is kind of okay but there's actually a better approach and that better approach is using the library by the name of http status codes and of course we need to install the library so this is the code if you need it for your own project in my case of course i already installed in the stars so that's why it's available and then we simply want to get the status codes from the library and then this is an object and then as far as the properties we just need to look for the text values for example for 200 we're going to go with ok now if you want to take a look at the codes of course just keep on scrolling and you'll notice that if we want to go with 200 response of course then we just type okay if we want to go with battlequest then we just type it and this is going to be 400 and hopefully you get the gist and as a result we'll accomplish two things it's going to be easier to understand what is happening as far as our responses instead of juggling the 400s and 401s and all that in your head and the second thing of course we'll have more consistency so let's try it out and in this video i'll just try it out here in the error classes and then of course in next video when we'll be refactoring our code since of course we have different setup for the errors then we'll also implement those status codes there as well and what we want to do is go to the bad request and then below or above the custom api error again this part doesn't really matter we're just going to go with const and then we're looking for status codes now this is a named import so make sure that the name is exactly the same status codes and then that one is coming from our library http status codes and then instead of this 400 we're going to go with status codes and then we're just going to be looking for bad requests notice how they right away give you all of these suggestions again it's easier to read it's easier to understand what is happening and second we'll have the consistency and we want to do the same thing in on authenticated as well so let's navigate to this file again we'll copy and paste just so we can speed this up so copy and paste we get the status codes and in this case of course we're not looking for the bad request which one we're looking for unauthorized so let's go over here let's say status codes dot and then we're looking for the unauthorized one and once we have fixed the error classes using the status codes now of course we just need to hop back to our application and refactor it since of course our error handling has changed as well awesome and as far as the refactoring we actually need to work in three files we want to look for our middleware so of course that is going to be the other one so let me just close all of them for now and then let's start from the scratch so like i said we're going to be looking for the auth middleware that's the first one then we also want to work in the main.js we'll have to change the code here as well and then lastly of course it's also going to happen in the error handler so where we have middleware for her handler we'll have to change some things around here as well so first let's start in the auth chairs now what error are we throwing over here well at the moment it is custom api error but actually what error is it well of course it is the authentication error correct and we already have the class for that which has the unauthorized status code so what we simply want to do is look for index.js so of course this is going to be the errors folder and then more specifically we want to look for this error i'm just going to copy this value and then back in the auth now of course we're exporting as named exports so we need to change this around where i'll say okay i'm expecting here the object and this is not going to be coming from the custom error it's actually going to be coming from the errors copy and paste and now of course i just get the unauthenticated error and then instead of the custom api error we're going to go here and we'll say on authenticated error and now of course we don't need to pass in that status code correct we just need to provide the message so let's remove it over here and then we want to do the same e in the catch correct so the functionality is going to be exactly the same and just so we can speed this up maybe let me grab the first part over here and copy and paste and then again we don't need the status code we just remove it and we'll be in good shape so that's the first file we want to fix then we want to go to the main.js e in the controller and pretty much it's the same thing where at the moment i have custom api error but effectively what error i want to throw here well i want to throw the battery quest one correct pretty much everything after that is just for successful responses and i think i'm going to remove the console log since we already covered that and then let's scroll up again we want to change what we're actually requesting so in this case i'm looking for this bad request error so let's go back to the main.js and we'll set it up as an object over here and then again we're not looking in the custom error we're looking in the errors and keep in mind that since we're exporting as object if you have multiple errors we simply want to add comma and then just get them so now we're looking for bad request error and instead of custom api error we'll exchange it for bad request error we already have the status code so we can remove that and then finally let's go to the error handler one and in here of course i'm still looking for the custom api error so as far as the instance this doesn't change because both of them the bad request as well as the unauthenticated extend from our custom api so this will be still true the difference of course is that we're looking for the object in this case and we're looking in the errors that's number one and the second thing we want to do is get those status codes and that is coming from the http package so let's say here http status codes and in the if block everything is going to stay exactly the same because of course we're getting the status code from the object correct and then as far as the message it's also there but when it comes to this 500 you can change this around and say that we'll be looking in the status codes and this is going to be equal to the internal server error and when it comes to message i guess it can stay the same and with all of this in place let's just navigate to the browser and then let's test it out let me refresh let me remove that token so we're not cheating here so let me remove it from the local storage and let's try it out and let me refresh one more time we have no token okay that's awesome i can see not authorized to access this route so i can clearly see that my functionality works at least for now and then of course if i wanna see something i'm gonna go with anna and then i say secret and then we submit and user is created token is present so now of course let's get data and of course the user is still the same and everything is correct and if you want to try out setting up the user without any kind of values let's try it out we have please provide email and password and if we inspect we should see in the console bunch of errors meaning we have one for 401 and then we have one for bad request and again not to be redundant but all of this code refactoring and then introducing new packages as well as setting up more error classes is going to make way more sense as we progress to more complex projects my idea is following where i want to show you the simple setup first and then show you these changes on a small project because that way i believe that it's going to be easier for you to follow along because now we have only what six seven files something like that correct but as our projects grow we'll still rely on these topics we'll still rely on multiple error classes we'll rely on status codes as well as setting up the middleware but of course then it's going to make way more sense because we'll have way more routes and way more functionality and with all of this in place we're done with the project hopefully everyone enjoyed it and i hope to see you next one all right and welcome to our next project the jobs api where we'll finally combine our auth knowledge with crud functionality and as a result we'll have an api where users can log in and manage their job search during the project we'll also learn how to deploy our app to heroku so host our apps on the cloud and set up nice documentation with swagger ui for this project i still managed to build a matching frontend app but moving forward so in our future apps i'll exclusively use documentation to showcase the end result since building a frontend project for every api is just too timeconsuming and before we take a look at the features let me stress one more time our job will be setting up the api so the back end the front end is there just to give you a better overall perspective on how the api is going to be consumed in real life and basically the idea is filing where we have some kind of frontend application and we can log in or register so of course if i haven't created my account then first i would need to register so i go over here and then i'll type some kind of gibberish i'll say that i'm peter the email will be peter gmail.com and then we go with secret now regardless whether you're logging in or registering will be sending the token the json web token and then on the front end will right away be able to showcase the user account so if i go here and if i say that i want to register and if i submit if i provide the correct values now i can see my dashboard since i just created my account i have no jobs so of course in here i just need to provide the values i'm going to go with apple again and i'm going to be looking for front and position i submit now i have my job i can delete the job i can edit the job and i can also take a look at the single job so in this page i'm actually fetching data about that one single job and i have functionality to edit once i change some values now when i'm sending this http request this is going to be a patch request so here i edit and if i provided the correct values then i successfully modified the job so now i can go back to the dashboard and i see that i have my job but in this case instead of pending which is going to be the default case we have the interview and if i'm no longer interested or maybe they sent me a rejection i can also remove the job and once i do that i have no jobs to display and as a quick side note if you're just interested in the frontend project just navigate to johnsmilk.com and at this point it is still on home page but if you don't see it there it's always going to be available in the projects page and you can quickly find it if you look for youtube now youtube doesn't mean that the project is going to be on youtube i'm just grouping my projects that way and then in here you can take a look at the application if you click on this massive master button and if you want to take a look at the source code just look for star files or complete both of them actually go to the same repo and then in the source you'll be able to find everything and a few things to know about the project when it comes to the url of course i'm using my api so if you want to clone the project and test it out on your backend you just need to change the url and that is in the ax usgs so in the source i have axios.js and as you can see the url is pointing to my backend but if you want to test it out on yours you just need to change the url and lastly keep in mind that i recorded this in july of 2021 so eventually once the react 18 is stable i might refactor the code to take advantage of the new features all right and as always we'll start with the setup and essentially we're looking for the folder number six of the jobs api and then more specifically we have two more directories we have the final one as well as the third and of course we'll do all of our work in star and then final is for your reference so this is the complete project now at this point you should be able to already spin up the final project if you want to just look for readme and then here you'll find the info where we do need to create a dot env file in a root and then set up two variables the uri as well as jwt secret one and of course this is gonna be the connection string the uri which you're getting from mongodb you just need to set up the proper password as well as database you want to use and as far as the jwt secret one for time being you can set up some kind of silly value like we did in a previous project because in the jobs one i'll show you where to get a proper jwt secret value and after that just run npm install and npm start and the final project should be good to go now as far as the starter we'll just navigate here to the folder and first thing that i want to do is go with cd and then drag and drop the star and before we do anything let's just go with npm install and npm start so that should install the dependencies and spin up the dev server and as far as the setup in this case we're going to have two controllers one for authentication and the second one for the jobs again we have db1 where we're connecting to the database that should be already familiar then we have errors folder with all our classes so we start with our custom api one and then we have one for bad request we have one for not found on authenticated as well as index.js where we essentially pull in all the classes and then we can start using them around the project since we have index.js we simply need to reference the errors folder and that will be the default export and then we have middleware one where we've got a authentication one so essentially this is going to be exactly the same like we did in the previous project however this one i want to retype from the scratch because we only did it once and then probably in the upcoming project we will reuse this one as well and then of course we have error handler one so this is where i got the custom api one and then i'm just checking if that is the case if that's our custom api we send the response with the status code as well as the error message and i'm using the status codes library and i prefer using this package because in my opinion it adds a bit more consistency to our application as well as it's easier to understand what's happening with a status code in this case we have internal server error and also during this project we'll do more work here in the error handler one because i want to show you how we can check for multiple mongoose errors instead of sending back always this 500 one with the long error message then we have not found so if the user is looking for the route that doesn't exist we send back 404 and then route does not exist after that we have two models so we'll have job and user and also the same goes for routes we'll have the auth as well as the jobs and then eventually we come to app.js where again we have two packages that we have used quite extensively dot env as well as the express async errors i don't think i need to repeat what they're doing then we're looking for express we invoke it and we set it equal to the app we have two middlewares we have not found one as well as the error handler one that we invoke dot json because there's going to be some post routes and we want to access data in reg.body there's a simple route app.get just a forward slash so this of course is going to be to our homepage just so we can test it out whether that's the postman or the browser and i pass in the not found one as well as the error handler one in app.use and i set up the port in this case i'm going to go with 3000 i believe the final one is 5000 and then we have a start function where we just invoke app.listen and eventually we'll add here more code if you can see clearly in console server is listening on port 3000 and if you navigate to the browser and go for localhost 3000 you can see the jobs api we are in good shape and we can start setting up our application all right and once our basic app is up and running let's start setting up the structure and we'll start with our controllers so essentially in here we want to set up the functions that eventually will be controllers for our routes and i want to start with auth and again this is just going to be a structure so we'll just add some dummy code like registered user or login user and that sort of stuff so let's go here with const register so this is going to be our first function and again it's going to be async rec and res and in the body like i said i'm just going to go to rest.send and we'll go the register user register user and then as far as the author out the second one will be a login one so let's just copy and paste and i simply want to change here the name for the function as well as the string so let's go with register login or i'm sorry we're going to go with login user my bad so login and let's go with user since i have the controller i also want to export it so we're going to go with module then export and i'll set it up as an object and we'll go to register and log in and essentially in order to speed it up i just want to take this whole thing copy and then back in the jobs we're gonna go with get all jobs get job create job update job and delete job essentially we have a crud functionality so i can just remove the second function as well as the login one we will rename them and let's just start with get all jobs so this is going to be a get route that gets me on the jobs so i'll say the same thing in string so get all jobs let's just change what function we're exporting and now we want to copy and paste this four times i believe one two three and four so we'll go here with get job this is going to be a route to get a single job then we have one for creating a job so create and job as far as the string we'll go with create job then we have one for updating the job update job and let's do it over here as well update job and lastly we have one for deleting job so let's say delete and job the same goes for the string so delete job and now i just want to add the rest of the functions in my object the one that i'm exporting so go with get job then we're looking for create job the update job so comma update job and delete job and once we have the basic controller structure in place now of course we can do the same thing with our routes and as far as our routes let's start with auth js and of course we need to set up the router so let's go with const express easy equal to acquire acquire and of course i'm looking for express remember we need to go with some kind of variable and micros router and we'll set it equal to your express dot and router we invoke it and then we'll import both of the functions from auth controller and remember the names were register and login so let's go over here login and register and both of these things are coming from our controller the auth one so let's navigate over there we have controllers and of course the auth one and once i have my imports in place now of course we just need to set up the routes and if you remember we also had an option of router and then that and then whatever is the method and both of these are going to be the post routes so i'll simply go with router that post and then we go with forward slash register and then of course we'll pass in our controller after that we'll copy and paste again router.post in this case we're looking for the login one and of course the controller will invoke he is also going to be a login one and then at the very very end we'll just go with module exports and that is equal to the router so that should do it for auth.js and before we navigate to app.js and import it and set it up let's also do the same thing with the jobs router because essentially the idea is exactly the same where i want to go to jobs and again in order to speed it up let's just take these two lines of code and i'm sorry i navigated to the wrong file so here in the jobs i set up the router yep that stays the same and now we just want to go with const and we want import we want to import get all jobs get job also i'm going to be looking for create job create job then we want to update the job and lastly we want to get a job or i'm sorry not get job delete job delete and job and all of that is coming again from the controllers correct so go with require and we'll set it equal to the controllers folder and of course we're looking for the jobs and once we have these imports in place now of course we'll do the other way where we go with router dot route and then we'll have post and get on a forward slash and then we'll have the get delete and patch on forward slash and then the route param so let's go with router dot route and this is going to be the forward slash of course and therefore we'll go with post so this is going to be to add the job and get all the jobs remember that was the structure for rest api and we're looking for the controller of create job of course let's go with dot and then get and this is going to get me all the jobs then we'll copy and paste and i'll add here the id remember the route params and in this case we're not going to have post so i can remove this one and we'll start with get now this is going to get me the single job here then we're gonna have one for delete of course the controller is delete job and then lastly we have one for patch and here we'll pass in update job and then at the very very end of course i want to go with module dot exports and the router now of course if you prefer this index you can also use it here in auth js i just thought that this is a nice refresher where of course we can set up our routes this way as well and once we have both of the route files in place now of course we just need to go to app.js we need to import both of them and again as always this is really up to you but i'm gonna do that above the error handlers because there's also going to be a connectdb here so connect db is still coming up let's just go with routers and here let's say const auth router and that of course is equal to require and we're looking in the routes and then more specifically of course i want to access the auth one copy and paste and this is going to be a jobs router of course this is coming from routes and forward slash and jobs and then i don't think we need a dummy one anymore i think we are pretty clear on what's happening so now of course let's remove it let's say app.use and as far as the path i'm going to go with api version 1 again that's my setup in postmatch so we might as well continue using that one and as far as the auth i'm going to go with forward slash auth and of course what that means in here we have the full path of api version one auth and then register and the same goes for the login and as far as the jobs will do exactly the same we'll go with api version jobs and then the forward slash is just going to have the create one and get all of them and then the route params will have the rest of the three hopefully that is clear because again we pretty much keep repeating the same thing so let's go with api version one and then auth and then let's just pass in the auth router so now of course we just need to copy and paste and let's go with jobs1 and of course now we want to implement the jobs router so i'll say over here and i don't think i'm going to do any kind of testing since it doesn't make sense at the moment i'm just going to check my error so it says over here router.post requires a callback function but it's not given so let's see let's see let's see maybe i didn't export something so let's go to jobs that's the router and of course i'm looking here for the auth one for some reason so let's remove this one and then as far as create job looks like i didn't export it or something along those lines so let me take a look at the jobs of course there's a naming issue it's a create job so create job and of course i need to do it over here as well so once i fix this tiny bug now we should be heading in the right direction where we have the routes we have the controllers so now of course we just need to start adding the logic and the reason why i'm not testing anything right now because of course we'll work in each of the controllers quite extensively and before we do anything of course we'll just check whether we're getting this silly string response and if we do then of course we'll work on our logic all right and before we can start registering our users the last thing that we need to do as far as the general setup is to set up connection to the database and of course we have the function we already have connect js we have the functionality where of course we use the mongoose we set up to connect we pass e in the url and of course these are going to be our options to remove those depreciation warnings and the only thing we need to do is set up in a star dot env and here let's go with underscore uri and of course you want to pass in your connection string so let's go to connect we're looking for connect your application i'll take this one over here and copy and paste and as far as database i mean it's not going to be a surprise if i go over here with 0 6 and i'll call this jobs api and then of course i just need to provide my password and once you do that just navigate to app.js so let me close everything just so it's not so busy and i guess in the app js i'm going to go above the routers i'll say const connect and then db and that will be equal to require of course and we're looking for our function and that is located in the db folder not the error sorry the db one and now we're looking for connect and then we'll just scroll down where we have the start and we'll go with await and we'll invoke the connectdb and now of course we want to go process dot env and then the underscore and uri so underscore and uri and once i save and if i can still see servers listening on port 3000 that means that our connection is ready to go and now can finally start setting up our authentication all right and once the database connection is in place the first thing we want to do is to create a user model and in a process we'll learn a few more built in mongoose validators and as xenon if you need to reference the steps we're about to take just navigate to the readme in the root so in the star route look for readme and here you'll find all the steps and since i want to show you more validators let me open up the mongoose docs so in here we're looking for a validation and then more specifically just look for the string one because in the user pretty much all of them are going to be strings so just click on any of these ones and here and there i'll just use this as a reference just to showcase what's happening and essentially we want to navigate of course to the user model so the file is over here and remember we're looking for the is of course so const mongos is equal to require and of course i'm looking for the mongoose and after that we will add two more packages the jwt one the json web token one as well as bcrib js but of course that is still coming up and i want to start by creating a schema so let's go here let's call this user schema not as equal to new mongoose and of course we're looking for the schema here in this case and i want to go with parentheses pass in the object and as far as the properties will have three we'll have name email as well as the password so let's go over here with the name that's going to be the first one i think i can close the sidebar just so i have a little bit more real estate and we'll start with type type will be equal to string then we'll right away set it equal to required and then we'll set it equal to array remember the first value is whether it is true or false of course in my case i'm going with true and then we'll say please provide a name so of course that is our required validator and after that i just want to showcase that in the mongoose docs we can see that we have min length and max length now of course as far as the values that's really up to you my case i'm going to go with min length and i'll set it equal to 3 and of course i'm going to also set up a max length and i'm just going to say 50. then i want to go with email and in order to speed this up we will copy and paste and of course i'll change the name here this is going to be an email then i'll still set it as required so that's going to stay the same let's set it over here and then we also have a match one which pretty much creates a validator that checks if the value matches the given regular expression now why we want to use that because i want to use the regular expression to check for the valid email there's plenty of suggestions out there most likely the first answers that are going to pop up are going to be from stack overflow just pick the one that makes the most sense to you and you'll be good to go now as far as this project you have two options you can either get the code in the readme or just look in the final one so in the final of course i have the models and all that and then just look for the user one and you can take the entire property that's really up to you so in my case i'm just gonna navigate to the readme i'll take here this code and then i want to go back to the user and more specifically the email i want to remove both of these the min length and max length and then we want to go with match and we pass in the array so essentially that's the syntax and then we want to pass in the regular expression then comma and then whatever error message we want to provide and in this case it's pretty much going to be the same i'm just going to say please provide valid email and once i have the match in place the last thing i want to set up for the email is unique and true and essentially what unique does it creates a unique index and this is something you need to be aware of where technically it's not a validator and that becomes important when we run validate method manually which we haven't done so don't lose your sleep over that and when you're writing automated tests and of course you can read more about it in the docs but the way it works it just creates that unique index so if i'm trying to save a user but there is already a email news then i'll get the duplicate error message and lastly i want to go with password and here i think i'm going to take the name because pretty much is going to be exactly the same where i'm going to go with password password and then required will be true now of course the error message is going to be a little bit different say here password and then as far as the middle length and max length i think i'm going to go with 6 and no longer than 12. so let's set it up this way we have the user in place the only thing left to do is of course export it so let's go with module and export and i'll set it equal to our mongoose model and of course we want to pass in our name and my case i'm going to go with user as well as the user schema so user and schema and once we save now of course we can start setting up our register controller beautiful our user model is in place so now of course let's set up the first route and steps are going to be following where first we want to validate a name email and password whether of course the user has provided the correct values and in this case i'll purposely go with mongo's option just because i want to show you how we can send back nice error responses instead of those big objects then we want to hash the password and don't worry if this looks like gibberish to you right now of course i'll cover it extensively a little bit later after that if we're successful if we can hash the password if the values have been provided then of course we create the user and once we have the user we want to create that token that's going to be associated with that user and with that token the user can start creating resources which of course in our case is going to be jobs and in order to get that token to the user of course we will include it in our response so let's get cracking and of course we're looking for the controllers in this case and of course i have the final open so i'm actually in a wrong folder so let me look for controllers we're looking for the auth and of course more specifically the register one we can start by importing the model so in here i'm going to set up a user and that is going to be equal to require then we're looking two levels up and of course i'm looking for the models and then more specifically a user model and once i have the model before we do anything here let's just check in the postman whether we're getting this silly string because if we don't then of course we do need to troubleshoot so let me navigate back of course here i have all my workspaces and i'll create a new one that's not a surprise i will rename it and i'll say 0 6 and let's call this jobs api now the url of course is going to stay the same remember that global variable so that saves us a little bit of time and i want to go with new request this is going to be a post request and here i'm going to be looking for my url of course so url and then remember we're looking for auth and register hopefully that is correct let me just double check so in the here i have api version one so that should be still in my global variable in the postman and then more specifically auth and then if we take a look at the routes in here in the auth of course i have the register and like i said both of them are going to be post routes so why don't we start by selecting a body then we're going for raw we want to go with json and then let's just set up the name and it's not going to be surprised if i'm going to go with john then as far as the email let's just go with the dummy one so i'm going to say john gmail.com and then lastly we want to go with password and i'm just going to stick with secret because that's the most simplest one in my opinion so i have name email as well as the password and of course once i send i should get register user if you don't then again please troubleshoot because otherwise anything we're about to do it's not going to make sense and before we move along let me just save this one and i'm going to look for my jobs and let's just call this register and user so let's save it over here and let's right away test whether we're getting back the correct values meaning whether i can access them in a reg dot body so change this one around where we'll say res.json and i'm just going to pass in reg.body again in this case i'm just checking whether my middleware is correct and if i can see all the three values that i'm sending from my postman then of course we are in good shape now i also want to get these status codes remember that was the library that we used before so let's go over here let's say const and we're looking for status codes and that is coming from our library the http status code so require require and we're looking for the http status codes and then in here i want to set up the status status and of course dot json after that and let's just go with status codes and then we'll set it up as created because remember we are creating a resource so this will send back the 201 and once we have all of this in place now of course we can create that new user correct so let's go here let's say const user and we'll go with a weight because of course this is asynchronous then the model name user and we'll go with create method and in the create method since i want mangoes to do all the validation i'll simply pass in rec.body just like we're doing over here so now of course i can remove it from my json and for them being i'll just send back the user our current code actually is a big big mesh because we're saving the passwords as they come in as strings and that's a very very bad practice and don't worry we will fix that a little bit later for now i just want to see whether everything works and once we hop back to the postman we should be able to send a request and in my response i can see that i created a new resource in a database since i have that underscore id and then the rest of the properties that i provided in my request and with this in place now of course we can move on to our next step beautiful we can save our user and before we cover why it's such a bad practice to save our password as a string now let me remind you about the error checking and more specifically let me just jog your memory on the fact that we can check for the empty values right in the controller because keep in mind that at the moment we are doing that using the mongoose so first let me show you how we can do that in the controller and then i'll talk about it while we're checking in the mongoose essentially what i'm trying to accomplish and if you remember we simply check it in the following way where we go with name email and password now all of that is coming from rec that body of course and then we want to go with if and if one of the values is missing then we'll throw our own custom error more specifically the bad request one so let's say over here email and then we'll do the same thing for the password so if one of them is missing then of course we'll throw the error and of course we need to import that so say here const and we're looking for bad request quest and error so that's the one we're looking for now if you don't want to make the typo then of course just navigate to the errors folder more specifically index.js and then just grab this value so that way you'll avoid some unnecessary typos so let me just make sure that the name is correct looks about right and then we want to go with require of course we're going two levels up and we're looking for the errors and since we have index js over there of course we don't need to be more specific by default we'll get back the index.js and once i have the import in place now of course we just want to throw the error in the if block where it'll say throw new and of course i'm looking for bad request one and then we just need to pass in the message because remember the status quo is already there and let's just say please please provide name email and password and password and once i save and once we navigate back to the postman if i'll remove the password completely and if i'll just send notice now of course i will get the message now our functionality will still work because of course we're using the mangos validators even if i remove this code so if i comment this one out and if we go back and if we send without a password or without any of these two values as well of course we'll get back there now the reason why i'm using the mongoose validator because during this project i also want to show you how we can send back more meaningful response because at the moment of course i'm sending 500 which technically isn't the case because of course now we have a bad request instead of internal server error and also notice these massive objects probably would be better if we would send just please provide the password or the email or the name and therefore in this project we will use mongoose validators quite a bit just because of course i want to show you how we can send back more meaningful messages but that doesn't mean that we're not going to check in the controller so of course this one is optional but there's going to be some cases where yes we will have to set up that check directly in the controller so this one i'll remove because this pretty much is a repetition here but when it comes to different routes yes there might be some cases where we check directly in the controller hopefully that is clear so now we can start tackling the password issue not bad not bad if we take a look at our database we should see user's collection and overall life is great if only not for one big doozy notice how we store password as string so now if someone breaks into my database he or she can easily ruin the life for all my users since in most cases people use the same password for everything so if there's one thing i want you to take away from this course please never ever store user passwords as strings trust me they will thank you for that later okay well what's the solution well we want to hash them instead which in simple terms means generating random bytes and combining it with the password before we pipe it through the hash function a mathematical algorithm that maps data of any size to a bit string of fixed size something to remember hashing is a oneway street meaning it cannot be reversed also if the input changes even tiny bit the resulting hash will be completely different which is really really good for storing passwords since we can accomplish two things at once store passwords in a form that protects them even if the password itself is compromised and at the same time being able to verify the correct user password both of which will cover extensively in the upcoming lessons when it comes to password hashing for this and following projects we'll use a library by the name of bcrypt.js again the library is called bcrypt.js and if you're using a star i already installed it for you so we can start using it right away and as far as the syntax for hashing the password it goes something like this where first we want to import the library of course and we're looking for the bcrib js again please keep in mind that the library name is bcrypt.js don't install the beaker one and then wonder why you have bugs so again the name of the library is be crypt.js and the only reason why i'm telling you that because i fully understand that it's very easy to mix them up and once we have access to the library instead of dumping the entire body with our name email and password we want to create a new temporary user object and in here i'll just pull out the values from direct that body so my apologies we already had this code but i removed it with a bad request so now i'll have to retype it one more time so we'll look for name email and password and all of that is coming from rec.body and then i want to set up the temp user object and of course keep in mind that in the temp user all three properties need to be there otherwise we'll get back the error so of course in here i'm passing reg.body now i want to set up a new object and you'll see why i'm telling you that in a second and effectively i first want to set up the hashed password and then i'll go over line by line and explain what's happening so let's start over here with const temp user and we'll use the es6 thing where i'll go with name is equal to name and emails equal to email and what i want to do here is set up also a password but password will be equal to a hash password which of course at the moment we don't have and in order to set up the hashed password we need to run two methods we need to run gensalt and then the actual hash method and first i want to create a variable and i'll say salt and we have an option of running them asynchronously so just go with a weight then i'm looking for bcrypt and like i said the method name is jen salt and then we want to pass e in the number value again i'll explain all of this in great detail in a second and then once we have the salt then we want to create that hashed password so let's say over here hashed and password and we'll go with await then bcrypt again decrypt and the method name in this case is hash and we need to pass in two things we want to pass in the password we want to hash as well as the random bytes which essentially is that sold so let's start over here with password then comma then we pass in the salt and now where we have the password in the temp user instead of directly using the password we'll go with hash password and now of course instead of dumping the entire body we'll go with dot dot again we want to spread them out and then we'll go with temp user and once we save all of this now let's hop over to the postman and let's try to send the request so in here we need to keep in mind two things first the fact that we have set up four unique emails so if we'll try to send the same email we'll get the a response that's number one number two remember when we're setting up the password the basic password we also add the max length since i wanted to showcase that we have that valve there now in this case of course we will get an error because the hashed value is going to be way longer than 12. so let's try it out let's send and like i said we will get an error where the max length is 12 and of course this is the hashed password value and in order to fix that of course we just need to go to our user model and then remove the max length like i said i added this just so you can see that we have this option but of course in our case we are not going to use it and then once i fix that then the another bug is going to be that we have a unique email so if i send with john gmail.com of course i'm going to get an error which pretty much tells me that i have error and more specifically there's an issue with an email and this is the case where again we'll work on these custom error messages in a second now we simply want to change the john to john 1 at gmail.com and once i send check it out now of course i'm getting back the user now it's still not a good idea to send back the password so that's also something that i will work on a little bit later now the good news is that if we navigate right now to our mongodb and if we take a look we'll see our second user with a email of john 1 and of course now the password is hashed and what that means is that even if someone breaks into our database and steals all the data instead of actual password values they'll get the hashed ones which prevents them from easily reusing them later now that doesn't mean that you shouldn't protect your database of course not that's not what i'm saying just make sure that you always always hash your passwords and never ever ever store them as strings and as far as the code if we take a look at auth.js in line 9 we generate salt which essentially just means random bytes and we do that by running the method gen salt and in there we provide a number of rounds so how many random bytes we'll get and of course the bigger the number the more random bytes we'll get and of course that also means that the more secure our password is going to be but we also need to keep in mind the more rounds you have the more processing power is going to require and therefore i just went with 10 which i believe is a default one and trust me that is already a very very secure password and then of course we take that salt so there's random bytes and we pass in the hash method and hash method is simply looking for the password so the password we want to hash as well as the result and once we provide both those values as a result we get back that hashed password and of course that one we can safely store in our database so we just add it to our user and we're good to go beautiful we now know how to hash user passwords and if we take a look at our register user steps essentially we just need to generate a token which should sound already familiar since we spent the entire project on that and we'll be good to go right well yes and no that's true we don't have much left but if we take a look at our controller it's getting somewhat busy so if we'll keep on adding more functionality and just keep jamming the code in the controller eventually it's going to get bloated and way harder to manage now what's the solution you might ask well another set of middleware only in this case we're talking about the mongoose middleware but just keep one thing in mind the end result is going to be exactly the same will still hash users passwords it's just the logic will be stored nicely in a separate place and since i want to show you the entire documentation i'm going to navigate back we're looking for the middleware and of course you can read yada yada yada we have pre and post so before and after hooks and essentially we're looking for pre and more specifically pre save and the way we set it up we have the schema so in our case of course that is going to be our user schema then we go with pre so that's the syntax and we're looking for save so before we save the document and then in the callback function this is where we can access the properties in a document and do some exciting stuff and of course since this is a middleware then we just go with next and once we're done we pass it on to the next middleware now i'll also show you with async weight so this is coming up first let's just focus on this next one over here and essentially what we want to do is take the bcrypt we'll just save a little bit of time and we will go to our models we're looking for user one of course and then here let's copy and paste we have the bcrypt let's keep on scrolling okay that's our setup and here this is where we want to go with our schema so before we set up the model we'll go with user schema that's the name of course then we're looking for pre and then save so presave and since we'll use a weight we'll right away set it up as a sync and then let's go with function and i highly highly highly suggest using the good old function keyword value because that way this will be scoped to our document so if you'll go with arrow functions if you're familiar with them you know that as far as scoping this there's different set of rules in this case if we use the good old function that's why you'll see that in the docs as well this will always point to our document so in here let's go with our function and it is a sync nice then let's pass in the next of course and then remember the functionality what are we looking for over here well i want to generate the salt correct and of course i want to get the password and just so we get comfortable let's write it from the scratch so let's go to the user one and essentially i want to go with const salt so now we're generating those random bytes so let's just go over here with a weight and then be crypt and of course the function name was gen salt and i'm not going to go 20 rounds i'm going to go with 10 here and then as far as the password well this is where the callback function comes into play where in this function this will point to the document so when we type this over here basically what we're talking about is our document before i want to save the document what do we want to accomplish well we want to hash the password correct so what we can do we can go with this dot and we're looking for password so of course this is over here and we simply want to go with await and we want to hash it we want to go with await then bcrypt and then of course the method name is hash and then we're looking for this.password so our current password for saving and then we pass in salt and that's it that's all we have to do and once we're done with the functionality what's left well we want to pass it on to the next middleware so we just go with next and we invoke it and now check it out if we take a look at our controller since we're not sending the bad request here anyway i don't really need all these lines of code that's it i simply want to take my body just like we had before with dot dot erect.body and everything else is taken care of over here and you have to agree that this is much cleaner and nicer to work with so let's go back and then like i said i'm not interested in any of these things over here and we'll simply go with dot dot correct that body i'm still sending the user just because i want to showcase that will be hashing the password but don't worry that's also not a good practice to send back the password so we won't do that in a few seconds so let's go back to our postman we want to send it and check it out we have john with john blah blah blah and of course we have our hashed value so our functionality still works and the last thing that i want to cover in this video notice the docs in mongoose 5.0 blah blah blah next we can go with async await well that simply means that back in our user one can just remove it and what they're telling us in the docs that it's still going to work so let's test it out in this case i'm going to go with john 2 since remember we have those unique emails let's send it and we still get the response so we know that that works and if i go to my database now of course i should have quite a few users already there with hash passwords apart from the first one of course that is where the secret is and now i can remove it and we are good to go now we can hash the password but we're doing that using the mongoose middleware nice we're a little bit familiar with mongoose middleware so now let's continue with our steps we're saving the user so we're good on that and now of course we just want to generate the token and send back the response and we'll first set up functionality again in the controller so we're clear on what's happening and next video i'll show you another nifty setup that we can use with mongoose and like i already previously mentioned this should feel familiar because we spent the entire project on that the jwt basics so if we go back to the controllers in the fifth project meaning the folder name is five of course this is not the fifth project and if we take a look at the main check it out we go with jwt sign correct and of course that is coming from our library the json web token one then we pass in whatever we want to pass it on to the front end and of course later we'll use the id to access the resources that are associated with that user then we pass in the jw secret one and in this project i'll show you where we can get a proper value and eventually we pass in the options and we just say in how long it expires so let's try to recreate that back in the auth.js and what are we looking for here we're looking for the library of course now i can remove the bcrypt because everything is already set up in model so let's go over here with jwt we will set it equal to require of course and then we're looking for the package the json web token one and then once we create the user this is the case where we want to create that token correct so let's go over here with const and then we'll go with token and for time being i'll just pass in some random string and then we'll set up properly everything after that so let's go here with jwt then we go with sine of course and we want to pass in the data we want to send back and in my case again we'll go with id and name so let's start with user id that's just how i decided to call my property here so user id is equal to user so that's the user that i'm getting back over here and remember on that object we have id property correct and if you want to double check it's right over here this is what we're currently sending back and we go with underscore of course and then we'll go with id and again that's just my preference to kind of separate the two otherwise you have job id you have user id and many more ids and then if you just keep using this underscore in my opinion is just harder to manage everything so that's why i always go with user id job id or whatever so that's the first thing that i'm sending and next i want to send the name so i go with name and then again user that's my object and the name and like i said i'm just going to pass in some jwt secret right away so i'm just going to be cheating a little bit over here and then we'll add a comma and then let's go again with expression remember this one was expires in 30 days so use the same value and of course a little bit later i'll talk about other options as well so let's go here let's say expires and in and i'll set it equal to 30 days then we save and of course instead of sending back the user i want to send back the token and this is the case where as always there's multiple setups that you can have you can send back maybe only the token or you can be like hey maybe my front end needs the name directly now what am i talking about if i go back to the application that i built for this project if i go to login and of course more specifically i'm going to be looking for register and then i'll try to use some kind of values here that are not already a database so i'm going to go with anna and maybe let's add a tube because then for sure everything is going to work once i submit not only i'm going to get back token i'm going to say here never i'll also get back the name but again this really depends on the setup that you have on a front end you can send back only the token and actually there are setups where the front end decodes the token instead instead of me sending here a name and set it equal to username front end decodes the token now it's not going to be our case but just keep in mind that's why you don't ever want to store anything here as far as the secrets because as far as the coding you can actually do that now of course when it comes to verifying that's where you need that jwt secret but as far as decoding yes there are some setups where frontend just decodes and gets whatever property it needs so in my case the jobs app i'm also looking for the user and more specifically the name property but hopefully it is clear that in this case it's just my preference when i was building the frontend app when it comes to response what you definitely want to send back is the token because that of course will allow that user to access resources on the server later on so my guess i'm going to go with user so that's going to be another property i'm sending and in this case of course i'll access my user object and i'm just going to be looking for a name so i'll have another property there by the name of name and then i'll set it equal to user and then name and of course now i just need to add a comma and we're successfully sending the token and again let's test it out in a postman first so i'm gonna go here with john3 at gmail.com we send it back now notice we're not sending back the password anymore and of course i'm getting the user as well as the token and just to reiterate on the front end of course i'm using the ana over here so in react i set the state and i set up the state value just to showcase that notice over here i have my reducer blah blah blah i have user and notice the name of course that is anna and i'm accessing that right from the response and then when it comes to the token you'll have multiple options and one of them is going to be storing it in a local storage so now of course in the local storage not only i have the name so that way when i refresh of course i can still showcase data but i also get the token so when i'll be making future requests on behalf of anna of course i'll have the token hopefully it is clear and now of course we can take a look at another solution that mongoose provides to make our code cleaner awesome and to complete our register functionality let's learn about schema instance methods in mongos so i'm going to navigate to the docs in this case we're looking for schemas and if we take a look at the list we see this instance method and essentially what happens every document we create we can have functions on them so these are going to be instances of course of our schema correct and the way we set up those functions we go with the schema name then methods and then whatever function you want so essentially once i create that user over here in the register that user will have a function and you can probably already guess that we'll create a function that just generates that token and of course in that function we'll pretty much have the same code and therefore we won't have to bother with that in the actual controller in the register controller and let's start somewhat silly where i want to go back to my model the user one and let's just go with user schema so of course that is the name that stays the same then we go with methods and then let's just say get name so let's imagine that we're just lazy getting the username and we have multiple options we can set it up as async or we can just set it up as a regular function so in this case we'll just go with a regular function so no async keyword but again we do want to use this function keyword not a our function because that way this will always point to our document and with get name simply what do i want to do i want to return this dot and name and now of course we just want to go back to auth.js and where we have user.name let's just invoke let's say user and we're going to be looking for get name so invoke this one and now let's go to the postman and let's try to send it so i'll navigate back i'll send it and because i wasn't careful of course i didn't pay attention to my email so of course i need to change it to john4gmail.com and i can clearly see that i still have the name so if i'll change this one around then if i'll say anna and maybe i'll go with anna gmail.com then i'll still be able to access the name and what that means is that we can generate the token using the instance method instead so again we're trying to keep all our logic in one place where we have the user schema instead of scattered around our controllers and let's just fix everything back we'll say username we'll stay with that for time being of course we can cut it out and i think we'll retype one more time from scratch just so we can get comfortable with jwt now i'm not gonna need the import here for the token anymore so i can definitely cut it out i have my user awesome and eventually i'll invoke a method that will get me that token so now let me save auth.js back in the user of course the name is not going to be get name and you know what i'll just set up everything from scratch i'll say user schema then again the syntax is methods and then we're looking for the function name and in this case i'll call this create jwt and again it's going to be a simple function here and as far as the logic we'll just return right away jwt sign and of course in here i need to get the library so let's go with jwt at the top and then jwtc sign and again remember in the function we can access the document how well by using this correct and as far as the payload again i'm going to go with user id then i'll set it equal to this and underscore id so this points to the document and then we're going to go with comma name and then we'll just go with this dot name and again we'll just cheat a little bit where i'll say jwt secret and then as far as the expression again we'll keep it at 30 days so expires and we'll set it equal to 30 days so now if i go back to auth.js i simply want to call create jwt that's it that's all we have to do so once we create the user of course we have that instance method and here i can just say token and i'm going to go user and of course the name of the method is create and jwt we invoke it and now of course we can go back to our postman now we already have one anna and let's just change the name just so we can see that it works we'll go maybe with peter and i'll set it here as peter as well and then once we send of course now i have the peter as well as the token and of course that means that everything works and successfully we're done with our register controller and in the process we learned about hashing the passwords setting up the mongoose middleware as well as the instance methods on a schema all right and once we're good with register route like promised let's swing back to the json web tokens and the first thing i want to talk about is the expression so remember in options we go with expires in and as far as default setup so if we just provide a number this is going to be in seconds now if we provide a string then we need to make sure that we add time units whether that's days hours and all that otherwise it's going to be interpreted as milliseconds so if you go something like this string of 120 it's going to be equal to 120 milliseconds and of course we'll return to this one once we start refreshing the tokens and all that cool stuff for now just be aware that by default it's going to be seconds unless you provide a string with a time unit that should do it for expires in and as far as that secret string yeah you can get away with jw secret but of course a more proper setup is generating some kind of more secure key and i prefer using all keys generator dot com again this is a free one of course if you want you can donate and all that but you can use it for free you're looking for encryption key and then more specifically you're looking for 256 bit one and then of course you can get the value and just take that value and stick it in the dot env file and as a side note we can also set the expires in ind ind.env as well and actually this is exactly what we'll do right now so let's navigate back to our project i'm looking for dot envy and then i want to set up two values i want to go with jwt underscore secret and that is going to be of course equal to my encrypted one and then the second thing that i want is that expiration and as far as the name i think i'm going to go with jwt jwt underscore and lifetime and now of course once i have both of these things and as i know of course i need to set it to some kind of value so in my case i'm going to go back to my 30 days and once i save both of them now of course i just need to spin up the server and i'll be able to access that in my user model and once my server is up and running i can just go back over here and instead of hard coding simply go with process dot env and in this case of course i'm looking for jwt underscore secret and then as far as expires in i'm gonna go with my value and again we're looking for process dot env and we're looking for jwt and lifetime or however you called your variable and once we have both of these in place now of course let's test it out just to make sure that we don't have any silly bugs and let's go with peter and we'll set it up as 23. i send and everything is correct so once i have all of this in place now of course we can switch gears and set up the login functionality beautiful once we can successfully register the user now of course let's worry about the login functionality and honestly we have covered pretty much all of the things apart from checking the password so of course since we're using a library to hash the password of course we want to compare it as well now since that involves creating another instance method we'll actually do that in next video in this video simply want to check whether we're getting the email and the password with some kind of values because that's the whole setup for the logging in in this case they don't need to provide name they just need to provide email and a password if they don't we send back the bad request one after that we'll check for the user in our database so basically we'll go with our user and find one and we'll pass in the email and if we can find one then of course we'll send back the user and if not then of course we'll send back another error and let's start here by removing that not send i'll close the sidebar here and let's start by const email and password and this is the case where i'll do the checking the initial checking right in the controller and i'll actually cover why that's my preference in this case once we're done setting up compare passwords functionality so first in the request i'm looking for email and password and right out of the gate i'll say if no email or if no password then of course we'll go with our bad request and of course we'll do that in if block and we'll say throw new and we already have the import for battlequest so we just go with bad request error and we just need to provide a message please provide email and password and once i have this one in place then of course we want to check for the user correct how do we check for user well we have the model we have the user model and on it we have a method by the name of find one so let's come up with some kind of variable name and microsoft's going to be user and we'll go with await of course it is asynchronous then we go with user dot and find one and then instead of passing in the id and all that we'll pass in the email so whatever we're getting from the user we'll just pass it in here and effectively at this point we have two options if the user exists awesome then of course we can send back the response with the username as well as we can create token of course now if the user doesn't exist then of course we want to throw another error now in this case though we're not going to be throwing bad request error in this case if there is no user then of course we'll send back the unauthenticated error because in this case the user is not providing valid credentials and that's a big difference so let's go back to auth.js of course we want to import that so in here let's go with on authenticated error that's the class we're looking for and in here let's check and eventually there's also going to be code for comparing the password but like i said we'll do that in next video so that is still coming up for now we'll just say if there is no user then please throw that error throw new and again we're looking for our auth error and we'll simply say invalid credentials credentials and once we have taken care of this now of course we want to create the token because if we go past this error that means that user is there user exists and remember the instance method we created in the previous videos the create token one or create jwt don't remember i believe it was create jwt of course we want to invoke it and essentially we want to send back the same response so the same response as we sent when we registered the user so if user exists let's create that token and of course we'll go with user create jwt we invoke it we get back to token and now it's the same deal we go with status now in this case we want to go with status codes and it's not going to be 201 it's going to be 200 and of course that one is the okay one and then as far as the json same deal also in my setup on my front end i'm looking for the name property so not to be redundant but you always want to send back the token but optionally you want to include some more things as well and in my case those more things is just a username so go with user for name of course the property and then username and then comma and of course in here we're looking for a token so right after the name we'll go token and of course that is equal to the token that we're getting back from create token and now of course we can go and check it out in the postman so let's go back over here i believe we just created peter 23 so now let's just test it out i'll create a new route so let's say here new route it's still going to be a post route of course and as far as the url again we're looking for our global variable forward slash and it's going to be auth and of course in this case it's a login one and then let's just grab these values over here let's say that we'll take the name email as well as the password and of course we won't use the name but we can nicely copy and paste just to save a little bit of time copy and paste and of course forgot about my curlies so let's place it here properly everything and this is turning out to be a mess okay i set up everything correctly over here and i don't need the name and i'm just going to be sending the peter 23 with a secret again for time being we're really just checking whether that secret is there i'll save it and i'll say in the jobs one and we'll say login user and then let's test it out cursor here still have the body yes everything is correct and of course i'm getting back to peter now if i'll do some mistakes if for example i'll remove the password we should get the 400 one and that's the please provide email and password okay that's good let me add the password and now let's mess up the email instead of 23 i'll go to and now of course i have invalid credentials and of course the error in this case is 401 so our base functionality works really great the only thing that's left to do in here is just to compare the password using our library and if you remember the library name was bcrypt js not bad not bad we can register user we can almost log in and the reason why i say almost because of course the moment as long as there's some kind of value for the password we're actually sending back the token so now let's fix that let's actually compare the password and this is that interesting thing where you might be like okay but wait a minute back when we were registering of course we were hashing this password correct we went with gensalt and then hash and the deal is following where essentially we have our library we have the package dbcrypt1 and in the beaker package of course there is a function by the name of compare and it compares the hashed passwords so again it's a oneway street once we hash the password that's it but with compare method we compare those hash passwords and of course if they match awesome we send back the token and user has successfully logged in and of course keep in mind that we can set up this functionality right over here but why we would want to do that if we already know how to set up the instance methods so instead of jamming more code in the login controller we'll simply go over here and i'll say user schema and of course we need to go with methods and then as far as the name i'm going to go with check password or compare password again naming is really up to you in my case i'm gonna go maybe with compare password sounds a little bit more sophisticated and this is going to be a sync function and then this function is going to be looking for one argument and that of course is going to be the password that's coming with a request and i'm just going to name this one candidate password and password and then as far as the function body i want to come up with some kind of variable and in my case i will call this is match and we'll set it equal to a weight because we can run the compare method asynchronously and we'll say await again the package name is bcrypt of course and then the method name is compare and then in the compare we'll pass in two things we'll pass in the password so the candidate password essentially the password that is coming in with a request and after the comma of course we'll get the password from the document of course the one that is already saved in a database so let's go back to the compare and we'll just go with candidate password so again the one that's coming in with the request and of course in order to access the document password we simply go to this dot and we provide the password and then what we want to return from the function is the match so let's say here returned and is match and once we have the function in place now we simply want to go back to auth.js and if we can see that we have the user we also want to set up one more if statement where we'll check the password so now of course i can move this comment down and i can say if there is a user i also want to check whether the password matches and we can do that by going with const and then come up with some kind of variable is password correct and of course we need to go with a weight because our function is asynchronous then we're looking for the user so of course this only happens if we have a user if we don't have the user then we right away send back invalid credentials and here we'll go with check or i'm sorry compare password of course i went with sophisticated name then we pass in the password that we're getting from the user and now of course we want to do the same thing where we want to check if the password is correct then of course we just return a token and all that if not then we'll throw the error and i'll just speed this up and we'll copy and paste and we'll do the same thing if the password is false meaning if we get back is match as false then of course we'll just throw this error and now let's go and test it out in the postman so at this point i have email as well as the password and they should be correct so let's send it here and of course i get back the response but if i start messing with the values for example if i go with a wrong email now of course i'll get invalid credentials so let's set it back to 23 and then if we do the same thing with the password we'll also get back the same message so notice here we have this invalid credentials now if i provide the correct values the correct email as well as the password then of course everything is great and we get back the token now lastly you're probably wondering okay but why did you check over here right in the controller because technically we need to understand that yes if there is no email of course we'll get that mongo's error correct well let me showcase something so i'll comment this one out so basically now we're not checking for empty values and let me provide the correct one let me say that yeah the correct email is going to be peter 23 yay area but i'll remove the password and essentially once i send i get back this error response but it is empty so let's go over the reasons why is that happening well if we take a look at the user of course we have the compare one and this one will throw an error it will throw an error because of course we're passing in the empty value correct back in auth.js we're getting back the password but password is just empty string and we are getting the error and we are actually handling that error in our error middleware so let's go back over here the error handler we are handling it over here and i can actually showcase that can go with log and we can cancel log the error and again let me send one more time and in the console you'll see the error and again it is thrown by our library notice here legal arguments undefined and i just find it easier to check it right over here or something we'll learn later to set up a validation layer and again that is all coming up for time being i just find it easier to check for that error right here for those empty values and then just send back the response instead of chasing it in error handler can that just my preference of course if you don't like this setup you don't have to use it but that's my explanation for using this bad request over here hopefully everything is clear as far as the register and login and now of course we can move on to our next step all right and once the login register are in place as far as auth the last thing we need is auth middleware where we can verify the token and if everything is correct and get the user id and pass it along to the job routes now the functionality is going to be exactly the same like in the previous project i might just use different variable names here and there and to answer your question yes i'll purposely retype everything from scratch just because i find repetition to be very important aspect of learning now if you don't agree with my opinion essentially you have two options you can just copy and paste the code from the previous project and i'll show you of course where you can get it in a second or make this a challenge and try to recreate everything from scratch yourself and of course if you get stuck utilize the previous project code or this video lecture and of course the code that i'm talking about is this one if you navigate to folder number five the jwt basics one and then more specifically if you look in the middleware of course you'll find the middleware that we are about to set up and now of course i'll close everything and i'll start from scratch so i'm looking in the star looking for the middleware and i'm going to go for my authentication one and first let's start with imports and essentially we're looking for the user first so that's going to be our model so let's go with require and i believe this was two levels up so let me look in my models and of course user okay that's good then i want to go with my jwt because of course we want to verify the token so let's go over here with require and the package name is jsonwebtoken and the last thing that i want is the unauthenticated error which of course is coming from my errors and this is the case probably where it's going to be faster if i just copy and paste so let me take a look at index.js and of course the name is right here so let me import this from my errors and again i think i'll have to go two levels up so let me take a look at require and we're looking at the errors folder and since we have index.js you already know that we don't need to specify the path we just simply say errors and with all of this in place now of course what we want to do is go with const auth so that's going to be our middleware and of course it's going to be a function and it's going to be looking for three things the iraq res and next and then as far as the function body remember the first thing we want to do is check for the header so let's add here the comment and we're looking for a header first for the authorization one and then we want to check whether it starts with bearer so first i'm going to set up the variable and i'll say auth header and that is equal to require errors and the authorization one of course and then after that i'm looking for if statement and in here i want to check if it doesn't exist if there is no header then of course we'll throw the error or if it doesn't start with better so let's go over here with mouth header and we'll go with starts with so of course that's the javascript method that we can use on a string and then we go with better and in some setups you'll see this space added as well but honestly it doesn't really matter because remember once we are done with if statement we're still getting the token and if there's going to be no space then of course the token won't make sense we won't be able to verify the token we're splitting the token anyway and let's go over here with throw new and of course we're looking for on authenticated error and as far as the text let's go with authentication and invalid and you know we'll also need to add here async so let's add over here async now we're checking for the header as well as the bearer and if one of them is false then of course we throw the error and once we're done with that let's go with our token so let's say kant's token is equal to auth error and then remember we're splitting it and we're splitting it on the empty space and then we're looking for the second value that's why we go with one so we turn this into array and then we're looking for the second item in array and this is what i'm saying so even if you omit this and if you just check for the better if the user has sent bearer and then right away token well this one won't make sense because basically this will be undefined we won't be able to split the string and of course if that's the case we won't be able to verify hopefully that is clear so let's go over here with try catch and then as far as the try block we'll try to get the payload so let's say over here payload and remember the method name is jwt and verify and here we want to pass in two things we want to pass in the token comma and then of course we're looking for process dot env and then jwt underscore secret and now of course once i have the payload i just want to pass it along to the job routes and in order to do that we'll first add a comment attach the user to the job route and then as far as the logic we can simply set up a reg.user so i'm right away setting up the property on a request object and as far as the value is in there i'm going to go with user id again that's just my preference and then i'll go with payload so this is what i'm getting back from the verify and of course in there i'll have the user id as well and technically we won't use the name but just for testing i'll pass in the name as well so let's say here name and again we're looking for payload and then that name and again if you're a little bit confused essentially in here we're just getting the payload that we're setting up in the route so if we take a look at our index routes i'm sorry not the index roads if we're looking at the author outs and notice here when we're creating the json web token right now of course the functionality the actual functionality is in the model so let me go over there in the user essentially this is what we're passing in we're passing in the user id as well as the name so in the authentication middleware of course this is what we're getting back and again this is just for testing essentially in our controllers in the job controllers of course we'll just use the us id but since i want to showcase that this is actually the same user also pass in the name here as well and then as far as the catch well we have the error and we can just throw it we can just say over here throw new and we'll go with our error and essentially the text is going to be exactly the same so i'll just take it from here and copy and paste and before i let you go of course remember that we need to do two things we need to export the auth as well as we need to invoke the next because otherwise we won't get to the job routes anyway so let's go over here with next first so now of course we pass along the user to the job routes and we need to go with module exports and then we're looking for auth and i'll set up the actual middleware as well as test it out in next video all right and once the auth middleware is in place now of course we just need to decide where we're going to place it because if you remember the previous project we only had one authenticated route and of course we just used the router for that and technically we can do the same thing over here in jobs but we just need to understand that of course in this case we want to authenticate all the routes so basically we want to protect all of them because if i create a job i only want to look at my jobs and i don't want you to modify my jobs or you probably don't want me to modify yours so essentially what i'm saying we want to add that protected route for all of them so we want to protect all of our routes as far as the jobs not just one of them so technically you can say yeah well okay we can import and then we can just add them one by one and technically it is an option but there's actually a better one if we go to app.js take a look we have app.use and then of course we have all the job routes and in this scenario what we can do we can just get the middleware and then stick it in front of the jobs router and with that in place all of our jobs routes will be protected so instead of going one by one we just do that in app.js and as a result we'll protect all the job routes so let's do it we're going to go where we have the connect and above or below doesn't really matter i'll say authenticate user and we'll go with require and of course i'm looking for my middleware and in there i'm looking for authentication one and then we scroll down we go with authenticate user pass the comma and we're good to go and in order to test it we'll go to the controllers over here and since we'll start working in create job anyway i'll look for create job and we'll just test it out and we'll test it out in the following way where i'll go with res.json and let's just pass here rec dot user so i'm getting that user from my auth one if everything is correct and of course i should be able to see the user as well as the id so let me save it over here and as a side note i actually removed all my current users e in the database just so we can start nicely from scratch because as we were setting them up we used the dummy string and then we set up the proper one just so we don't get any dumb bugs i also suggest to do the same work remove all the users and we'll start everything from the scratch so now of course i want to go to the postman i already have the register route correct so let's just get the token first so of course i go with name email and password i get the token awesome that's what i wanted and now of course we want to set up a new route now again this is going to be a post route to create a job so let's go over here let's say new route we're looking for the post method and we use the same url of course and then if you remember the difference was that for jazz we just go with forward slash and jobs and if you want to double check just go to app.js first notice that's the path again this is already part of our variable the url one then we have the jobs and then of course in the routes as far as the post well that's going to be a route anyway so that's going to be the forward slash now for getting the single job deleting and all that then of course we'll pass in the route parameters as well but for the post it's simply forward slash which just means that we go with url and then the jobs now we're really not concerned with the body because we're just testing whether our authentication works but what we do need to get is authorization over here and my apologies i'm actually looking for the headers and the reason why i'm showing you the authorization because at the end of this project or maybe in few videos i'll show you how we can set this up dynamically so you don't have to every time just copy and paste the user token because we need to understand that of course we can use multiple users correct and you don't want to copy and paste every time that token so i'll show you a dynamic way how we can set that up but not yet so let's go here where we have the headers again we're looking for the authorization one and then we want to go with bearer and we want to pass in the token and once i send if everything is correct check it out i have the user id which should match to whatever id i have in the database and of course i'm not going to check value by value but hopefully you understand the idea where these ones should match this one and the one that i have over there on the postman and i can clearly see the name so what happens if i go with different user if i register this user instead and let's go with anna here again the same secret we get different token and now of course we should get different name correct so in the jobs i'll remove the john token and i'll paste the ana one once i send of course now i get back the ana so what that means in any of the job routes i'll have anna's id or john's id or whichever token i'm getting and when it comes to any of these functionalities will only deal with the resources that are associated with a user hopefully we're on the same page and now of course we can start setting up the functionality and once we're done setting up our auth middleware i also want to mention something where as you're looking at someone else's code you might come across this syntax where instead of creating a object like we are doing in line 20 what they do is they look for the user in the database so they take the model the user model and then either find by id or find one that also works and then of course they just pass in the id that is coming from the token and in most cases they will use the select to remove the password there's really no point to pass this password to the upcoming middleware meaning our request and therefore they just use the select and remove it and then when it comes to reg.user well i just set it equal to this variable and it's definitely an option but the reason why i'm not doing that in this project is simply because if we just think about it we really have no functionality to remove that user anyway so if i'm getting my id from the token i'm pretty sure that there is a user on the other side again you might see this code and yes we might implement ourselves in a future project but not in this case i really didn't see the point of looking for the user since we have no functionality to remove it in the first place now if you do decide to go with this logic then of course just make sure that you remove line 20 because otherwise you're overriding with our current setup anyway awesome and once our auth is working now essentially we want to set up a model for the job and of course work on rest of the routes now before we set up the model though let me also quickly save it so this is going to be create job so let's set up the name create job and of course i'll set it in the jobs one and i also want to test it out really quickly where if in headers i make that mistake and i don't add the space what response i get of course i have authentication error so again this just proves the point that i was making before where essentially even if we omit the space over here we still check the token and of course in that case we're not able to split it meaning we are splitting it but we're just getting undefined and as a result our token is undefined as well so hopefully that is clear so now let me just navigate to the models and i want to create a job model and the first thing that i want to do is set up the mongoose and of course that is equal to require and we're looking for a package the mongoose one and after that let's just set up our schema so let me close the sidebar just so we have a little bit more real estate so job schema and that is equal to new mongoose and schema schema and here let's pass in the object and as far as the properties i'm going to have the company and that will be equal to an object of course type will be set to string then required will be true and essentially we'll set it up as an array of course and let's just say true and as far as the message we'll go with please provide company and name and last thing that i want to set up for the company's max length that we can use on strings and in here we'll set it up as 50. of course if you want to go a different value be my guest so let me take the company and we'll copy and paste this one one time and the second property we want to set up is the position it's going to be a string again it will be required and in this case of course we'll say position please provide position as far as the max length in this case let's maybe increase it in my case i'm going to go 200 and then as far as the job interview well there's always this status whether it's pending so whether we're waiting for response whether we already have the interview or it was declined correct and essentially we want to do that using the status property so comma status and then again it's going to be an object it's going to be a string but we'll use that enum remember option where we can set up the array with a possible values so let's say here enum and as far as possible values like i said we'll go with interview then declined declined and then last one will be pending and this is going to be the case again where on the front end will just provide these two values the company one and position when we are creating the job so these are going to be the values that are required however the status one we will manipulate when we are modifying the job so therefore we'll go with status these are our options and then like i said lastly we'll go default and we'll set it equal to pending that's the setup i'm going to have and then probably the most most important property that we haven't set up is the created by why well because in here we'll tie our job to the actual user and the way it's going to look like we'll go here with created by again the name is really up to you but that's set up that i have created by and then type is not going to be string or a number in fact it's going to be a mongoose then types and then we're looking for object and id so this is very very important so essentially now we're tying our job model to the user one so we have the user model over here correct so this is where we're creating a user so every time we'll create a job we will assign it to one of the users and as a result of course our functionality will work because every job that we will create will be associated with a user so first we have a type and we need to go mongoose types and then object id that's going to be the type for our property and then we need to go with ref and we need to specifically say well which model are we referencing and in this case we'll go with user of course so i want to tie the job to the user hopefully that is clear and then of course we want to go with required as well because we don't want to create a job without a user we'll set it equal to true and then as far as the value again let's just go with please provide and user and then lastly right after the schema object the first option that we have over here i want to go with comma and we'll set up timestamps and true and i'll showcase them once we actually start sending requests from the postman because you'll see the benefit of using timestamps right in the response so don't worry about them for now i'll show you once we start getting back the responses and of course eventually what we want to do is just go with module exports and we want to set it equal to mongos then model and then as far as the name i'm just going to go with job and then we'll pass in the job schema and once we have all of this in place now of course we can focus on routes and i guess let's start with the create job one nice we have the model so now let's just set up the functionality for creating the job and then one by one we'll deal with the rest of the controllers as well and in order to set everything up first of course from the postman we need to send the data and what data are we looking for again let's jog our memory we have the job model and here i'm looking for the company name as well as the position now let's not worry about the created by yet since that one we will get from our auth middleware and in here let's just set up some kind of values in the body so let's go with raw and we're going with json of course and then here let's say company company and then i'm just gonna go with google because why not and then as far as the position well let's just go with intern so position and then we pass in the intern now let's go back to our controller where we have the jobs one create job and instead of sending back the user i want to send back the wreck that body again just so we can test whether everything works so i have create job route i send it here and of course i have invalid authentication because i didn't fix my better one so let me go back and let me just add that space and now everything should work where of course i'm getting the values for the company as well as deposition so now what's left to do is go back to create job and of course in here we want to import finally our model correct and we want to create a new one so let's do that we're going to go at the top here and we'll create our imports and effectively we're looking for three things i want to get the status codes i want to get the job model as well as the requests and for requests we have two options we have bad request error as well as not found one so let's go with khan's job so that's going to be my model so require and of course we're looking in the models here and more specifically job then we want to get the status codes so const and then status codes now that is coming from our library of course so require an http status code and then lastly we have those two errors so let's go here with bad request an error and the second one will be the not found one so not found error and both of them are coming from and of course the errors so let's go two levels up and we're looking in the errors folder and once we have all the imports in place we'll swing back to create job and essentially the idea is following where of course at the moment i'm just passing in the ragdot body e and the json response correct and if you remember what was the method name to create new document well that was of course create and of course in this case we're looking for the job one correct so the way the setup is going to look like we're going to go with job then we'll await of course and then we go with model name and create and we pass indirect that body but the moment what we're missing is that user and where is the user located of course it is located in the rec dot user now what are we really looking for is the id correct so what we want to do here is just go with rec dot body again if you want a console log of course you can definitely do so but i'm just going to skip that part and we'll go with reg.body then we want to create onrec.body a new property by the name of created by why well because in our job model that's how i called my property so i add this property onrac.body and where is it located it's located in rec user and the property name is user id like so so now of course once we pass indirect that body will still have the validations but if everything is correct we create a new job and now of course we just need to handle that as far as response so let's just set up res.status now again this is going to be the created one so let's go with status codes status codes then we go with comma or i'm sorry d dot and then we go with created and then as far as the json i just want to send back the job so let's go over here and let's test it out so now i'm getting back the company and position but if everything is correct i should get way more than that and once we send unfortunately instead of getting back to job i get back the error where it says created by and it is a validation error which actually just showcases that our validation still works which is really really good and the problem of course is in here where i went with reg.body and it should be created by not created by so let me save and let me test it out one more time and once i send now of course i'm getting back the job and as far as the job i have the status so like i said by default it's going to be pending so this is going to be the job id and this is very very important that's why on the auth i set up that user id and that's why also when i was setting up djs and web token i prefer using that user id once you start building a bigger application you'll get bunch of these underscore ids and it gets confusing quite fast and therefore i prefer setting up that extra piece of code where i go with user id or job id or whatever and if you keep looking at it okay you can see the google you can see the position all that is nice but you're also probably noticing the created by and essentially this points to anna and of course what that means is that now this job will always always be tied to anna so once i register and log in and get my token and all that i won't be able to modify look at it or whatever and you're probably noticing these ones as well the created at and updated that and effectively we get them by default once we set up timestamps as true so mongoose schemas have that timestamps option that tells mongoose to automatically manage create that and update it at properties on our documents so that means is that of course we don't need to set them up manually and you can probably already guess that this one will always point to the time when the document was created and this one will change as we're updating and of course we can use these properties for example in filters and essentially this is exactly what we'll do when we're getting all the jobs and once we can successfully get back our first job i want to congratulate you on pretty much getting over the biggest hurdle because from now on everything is going to be exactly the same like we worked in the previous projects the only difference of course as far as the controllers will always always get that user id as well because of course we'll need to use it to search for jobs to update jobs and all that cool stuff awesome and once we can create the job now of course let's worry about the rest of the functionality and let's do it one by one so next one up we have get all jobs now in order to get the jobs we already know the method that is find which is of course available on the model however in this case when it comes to the filter object of course we'll pass in created by property and we'll set it equal to the user because what we want is to get only the jobs that are associated with the user and i know that i keep pretty much repeating the same thing and my apologies for that but that is very very crucial in this case we're not looking for all the jobs like we did in a task we're only looking for the jobs that are associated with this user and as far as the functionality it goes something like this where we'll go with jobs that is equal to a weight and then we'll go with job find and remember the filter object and remember if it was empty then of course we're just getting all the jobs but that's not what we want in here we want to say created by and we want to set it equal to rec user and user id again that user property here is going to be on every request since in the app.js we placed our off middleware in front of all of our jobs routes and then let's also sort quickly and let's sort based on creator that remember this property the creator that let's sort based on that so let's say here dot sort and let's just pass in the property created at and as far as the response well let's just go with res dot status and as far as the status codes of course we'll be looking for okay one still status codes and then okay and when it comes to json response i want to send back the jobs as well as the count because that's what i'm looking for on my front end again this is really optional you can of course send just jobs but in my case i want to send both and once i have all of this in place now of course we can go back to the postman i'll save both routes the register user as well as create job and you know what why don't we create a few more jobs so in here we'll say apple and we'll say frontend developer developer and then let's create one more and this one will be facebook as far as the developer let's just say backend one so let's send it here and once i send i want to check my database and there i have jobs okay that's good and as far as anna i believe i'm setting up everything as anna i have the one for google one for apple as well as the facebook and once i have all of these jobs in place now of course we can create a new route so let me save it over here and let's just go with get route in this case of course and we're looking for url and this is going to go to the same one as create job so we simply go with forward slash and jobs and of course we just send it and if everything is correct we should get authentication invalid why because of course we do need to include the header so let me go back to the headers let's go to authorization so now of course we know that our middle works we cannot just randomly access all the jobs you can only access your jobs and then let's go with bearer and then let's pass in the token that we have for anna again i'll show you in a second how we can set this up programmatically so we don't have to copy and paste every time so let's say here bearer let's send and now of course i have jobs array with the count off three and i can clearly see that all the info is correct all right and once we can create the job as well as get all jobs why don't we set up that token dynamically in the postman because as we'll be creating more users and of course add more functionality it's going to get annoying quite fast if we'll have to copy and paste each and every time that token value and first what i did is saved the request the get all jobs one and as you can see that's the name and of course i saved it in jobs api and as far as the setup it's going to go something like this where we'll start in login user and then we'll repeat the same in register but for time being i just don't want to worry about setting up those unique emails so let's go over here where we have the login user and we're looking for a test and we just need to add a little bit of code first we want to access the response that we're getting back notice of course if we're successful if we have logged in then of course we'll get back to token correct and in order to get that we'll just set up some kind of variable in my case i'm going to go with json data and we need to go with pm so postman and then dot and we're looking for response and in there we have a function by the name of json and then let's just go with our token value and let's set up our global variable and notice here on right hand side we actually have snippets so if we want to set up a new global variable we just click it and now we just need to provide the values and effectively the name is going to be access token and then as far as the value this is where we go with json data dot and of course i know that in my responses token is going to be located in token property so simply go with a token and now of course once we send we should see in the globals a new variable and of course we do and the only thing that's left to do is to go to either get all jobs or create job doesn't really matter we can go here and instead of authorizing that manually i'll unclick it and then we're looking for authorization then we want to go with bearer so probably you have by default here this inherit just go to better token one and then as far as the value well this is where you want to access that global one correct so you just go here with access token and now once we send we should get back the job now of course i created with the same values if i check the body so i have facebook and backend developer so if i take a look at my database and if i refresh i should have two values i'll have one that i created before and the second of course was created when we're testing this dynamic setup and of course we can do the same thing with get all jobs as well so let's take a look we have the headers here and i'm sorry i'm looking in the wrong place so we have the headers here let's remove it let's check the authorization again we have better token we're using access token and then once we send in the body now we should get four jobs and in order for everything to work we also need to do that in the register user so let's go back quickly to the login one let's grab these two lines of code then we'll go to register one again we have the tests let's save it here as well and now let's try to create another user so let's go to i believe in the body right this is where we were creating a new user and i'm going to go back to my good old peter peter at gmail.com we send we get back the token and now the moment of truth if i create a job and let's just say in this case netflix and then it's still going to be a backend developer now this one should be created for peter and again notice how we don't need to worry about those headers anymore so let's go back to our database let's refresh and if everything is correct i should have a user by the name of peter that i created of course there it is there's my peter and if i take a look at the jobs peter should also have a job so i keep scrolling and yes there is i have the netflix one and of course it is a backend developer so if i take a look at get all jobs now of course i should get only one that is associated with peter so let me go back to get all jobs let me send and now of course i have count of one so hopefully it is clear that now we're dynamically setting that access token so you don't need to manually do that each and every time and once we have all of this in place now of course we can continue with our application beautiful and once we can set up the access token dynamically in the postman now of course let's keep on working on our routes and next one up we have get job and i think this is going to be the case where i'll actually log in back in as anna so where i have the login user out i'll just go with anna now of course i get this token just because she has more jobs now let me save all of these routes since i don't want to set up everything from the scratch and then once i have logged in as anna let me just double check get all the jobs yep i have four of them and then remember for get job what we'll need to pass of course that is going to be the route parameter correct this is where we'll provide the id and if you want to double check that just go back to the routes we're looking for the jobs one and notice so the post and get all jobs is for the root and then we have the forward slash and then colon and then the eddy of course this is going to be that route parameter which will get me that single job make sure that i can delete one as well as update one and in order to test it out whether our basic functionality works essentially whether we can get that silly string we need to go back to the postman and i think i'll just leave the login user one and then i'll open up a new tab we're looking for get request of course then we go over here with our url and then forward slash and this is where i want to pass in the eddy so in get all jobs as far as the response of course will get back those ids correct and now if i want that one single job i just need to take underscore id again you're not looking for the user here you're looking for underscore id which just signals a job id so copy this one then go back to the get one the one will get the single request and remember we still need to go with authorization we need to set up better token and of course we'll use the access token and once we send if everything is correct of course we should get route doesn't exist because i was pretty smart and i forgot to add the jobs one so let's go over here and let's say jobs and then once we send now of course we have get single job so we know that this functionality works and of course now we just need to go back to our controller and in here i'm going to be looking for two things in the request first we need to remember that as far as the jobs we can access it in the params object that's going to be the job id and when it comes to user of course that one is located in the user object that we're getting from the middleware so let's destructure both of these things because as our functionality gets more complex i think it's easier if we can clearly see where we're getting those values from so i'm going to structure my request object and in there i'm looking for two things i'm looking for the user object and remember in the user object i have the user id so now of course we're doing the nested destructuring so i'm looking for that first and then what i want is the params so this one of course is provided by the express and then more specifically we're looking for the id now why we're looking for id because that's how i called it over here and then since i want to have more clarity on which one is which i'll right away give it an alias of job id like so so now we have both we have the job id from the params so this one is coming from here and then since we have the access token now of course we can also access the id of anna and then it's simply a logic of finding that one job where the id is the job id as well as created by is equal to the user id and if the job doesn't exist then we'll throw this error because remember we have two types of error either we'll get a casting error where the syntax doesn't match to that of the mongoose object id or simply we just pass in some kind of wrong job id and then of course if everything is correct then we send back the job so let's try it out we're going to be looking for the job and that will be equal to a weight of course then we go with our model name and then we go with find one that's the method name and then in here in the filter object we pass in underscore id which is equal to our job id first now of course in here the order is not important but we do want to check for both otherwise somebody can just get the id and then they can access the job so let's go to created by and we'll set it equal to our user id and then like i said we have two options for errors either we have a casting error which will handle a little bit later as far as the nice responses or we simply have a case where we provided some wrong id and we'll simply check that by saying if there is no job then we'll throw our new error and of course we're looking for not found one and then we'll pass in the actual text with the job id so let's say no job with id and since i'm using template string i can right away access it and i'm going to be looking for my job id now if everything is correct then of course we'll get back the entire job so say here res dot status which we're looking for are status codes then we'll go with okay and then we'll go with json and i'll send back the job now of course we can just test it out in our postman where instead of this get single job i should get the job that matches that id in this case i'm getting the google one so now let me double check where i have all the jobs and i'm gonna be looking for well these ones technically are both the same so let me look for the apple one and i'll grab the id that's the job id again keep that in mind that is very very important we're not looking for the user id and once i send of course i should get back the apple and if you get the same results then of course we can move on to our next step awesome and up next we have update job and essentially i can tell you right away that a lot of the stuff that we already wrote in get job will repeat over here so therefore in order to speed this up a little bit of course i will do some copy and pasting here as well and in order to test it out i'm just going to navigate again back to the postman this is where i'll start i'll save this one first the single job one so get single job single job and then let's create one for patch meaning one for update but of course the method will be patch and i'll leave get all jobs since i want to keep using those ids of course and i think i can close the login one for now because we already have logged in as anna and then let's look for the patch method and ascended i'm messing up the get single job my apologies so let me open up the new one and i'm gonna go with patch we're looking for the url one and again we'll be looking for the jobs and then we wanna go with that route parameter and of course this is going to be that job id so let me get all the jobs and you know what i'll work with that last one since we have repeating values so let me grab here this id and then pass it here and remember authorization we go with better token and we have access token and if i send and if i get update job then of course we know that we can start setting up the functionality and as far as the logic like i already said i mean most of it is going to be exactly the same the difference of course is the mongoose method we're going to use and the fact that i'll check for both i'll check for company as well as the position and i'll check whether they are not empty and you'll see what i mean in a second so where i have the update job let's just start working and first same deal i'm going to be looking for the user as well as the params so that won't change because remember in the routes i mean all of them are looking for that route parameter correct so let's take this one there's really no point to repeat ourselves in this case so let's copy and paste however the difference is that in this case since we're updating also in the body we'll provide some info and in my case i'm going to be looking for both i want to get the company as well as the position so let's go here with raw and we'll go with json here and if you want to speed this up you can actually go to create job and just take these values so that's going to be our patch one copy and paste and we just need to remember to add the curlies here and as far as the values well let's come up with some kind of company and i'll call this random and then it's not going to be a backend developer so it's going to be a full stack and then back in my controller we also want to add it over here so i'm still the structuring the request object correct and in there i have params i have the user now as well as the body because remember in here we're sending that in the body so let's go back and let's say body and in the body we'll be looking for company company and position don't forget to add the comma and right after we structure everything i also want to check whether the company or the position is empty and if that's the case i want to send back the bad request so say here company is equal to an empty string or position is equal to an empty string and if that is the case i'm going to go with throw new and we're looking for bad request of course so bad request error and we'll say company or position fields cannot be empty let's save it here and then of course we want to use our find one and update and remember we need to basically pass in three things we want to pass in what we want to update we want to pass in which job we're looking for and then of course we also have options where i want to get back the updated version as well as i want to run the validators so let's do that however there is a tiny bug over here and essentially i'll come back to this one why i prefer setting up the check in the controller once we start talking about the mongoose errors and let's just go with cons job and we'll set it equal to a weight then job of course that's the model find one and update and then like i said first we want to pass in well which job are we going to update and the setup is going to be exactly the same where i want to look for underscore id as well as who created it so let's go here let's say underscore id is equal to my job id of course job id then we want to pass in the comma and we'll go with created and then buy now that is equal to my user id and then of course we want to pass in what we want to update so let's just go here with the rack and body and then we want to pass in the options and i'm going to go with new true so we'll be getting back that updated job and then i also want to right away run my validators and of course the property for that is run validators and we'll set it equal to true now if the job doesn't exist we already know what we can do we can simply throw a not found there and if everything is correct and of course we return the job so let's scroll down copy and paste and our functionality should be working where if everything is correct i'll get back the updated job if not then of course i'll get back the error so let's test it out right now in the postman so i'm going to go with full stack developer and you know before we send the correct request why don't we remove that last value in the id let's send it here and now of course we're getting back that massive mongoose error that we'll work on a little bit later and then if i just change it around to four then of course i'll get back no job with id such and such so let me change it back to three i think that was the correct one and now once i send now of course i am the company and the position is full stack developer and with this in place we only need to worry about remove job functionality beautiful so now let's just set up remove jump functionality and i guess let's start by saving our request in the postman so again we go with save as or just control or i believe command s and then let's just write up the job update job and of course we want to set up the same thing for delete job and let's just start everything from scratch again we have a new request we're going to go with delete and then the url is going to be our global variable then forward slash jobs and now back in get all jobs why don't we remove that random one so if i go with get all jobs i can clearly see that i'm getting back the random job that's the one that we just updated so why don't we remove this one so again i'm looking for underscore id i'll right away set it up as my route param and as far as the logic well we're not going to be setting up anything in the body we really don't need to what we're looking for of course is the authorization again want to go with pair token access token awesome let's send we should get back delete job and as far as the functionality again we're going to be looking for user and params both of them are located in the request correct so one is coming from auth middleware and the second one is coming from the params again i know this is a repetition but it's very very important that we understand that then let's copy and paste so we have access to both of these ones then as far as the method name we're looking for find one and remove so let's go here with const and we'll set it equal to job and we'll set it to a weight and of course like i said job and then find one and remove that's one we're looking for and as far as the filter object let's just go again with underscore id and then job id of course and the same goes for the user id created that or sorry created by and then we set it up as user id and the same deal if the job doesn't exist then we send back the error and if everything went smoothly then we simply want to send back 200 that's all we have to do and i'll do that by cheating a little bit where i'll take this code from the update one and just copy and paste so we're throwing the error if there is no job or if everything is successful we don't need to actually send back the json again that's really going to depend on your front end but in my case i'm just looking for that 200 so if there's some kind of error then of course i have one functionality on my front end however if everything went smoothly if i remove the job then of course i'm just getting back that 200 that's it so now of course let's test it out in our postman where we have the job we want to remove it let's send it here as you can see i'm not getting anything back but i have 200 which is always a good sign so now of course let's go to get all jobs or you know what let's save this one first let's say save as and say remove or delete job it's really up to you delete job save it and then when it comes to get all jobs of course i can send it and count is back to three when it comes to anna and with this in place let's just quickly try out to log in as peter so we just simply want to change the name here i'm going to go with peter the password is still the same and of course i just need to be correct with my email i send it yep i get the token and now let's take a look at all the jobs that peter has and of course it's only one so now let me grab this id and first i'll change it so first we'll go with update and as far as the body i'll just pass in random and when it comes to your position i'm gonna go back to the internal one in turn here so let's send it that's the response i have company random and of course i want to also see whether i can delete it so when it comes to delete job i'll take the same id i'll go back here i'll copy and paste and once we run get all jobs for the peter now so let's go back to all the jobs and once we run it now of course we have jobs this empty array and count is zero but keep in mind this is still a successful response it's just peter hasn't created any jobs or in our case we created it and then of course we removed it and with this in place we're done setting up the core functionality for our application beautiful and before we worry about deployment let's make our mongoose error responses more userfriendly and before we start let me just say that just like our error classes we will only do this once and after that we'll bring it from project project so if at some point you get bored just remember we only need to do that in this project and then for remaining projects of course we'll just reuse the code and the idea is following where currently we have three mongoose errors we have validation one remember that is if the user doesn't provide one of the values then we have the duplicate issue where email is unique and of course we also have the cast error and if you remember that's when the id syntax doesn't match exactly to what the mongoose is looking for we want to go to the middleware and more specifically we want to go to the error handler and of course at the moment i'm logging the error and in here i'm just sending back this generic response so internal server error and i'm just passing in the object and if i take a look at the postman i'm going to be looking for register route and then if i have already a user in this example susan so if i already have that email and if i try to register one more time of course i'm going to get that duplicate error correct because i already have the email in the system and essentially the goal is following where we want to send back more userfriendly response and also we want to change the status code because at the moment we're just sending 500 but of course this is 400 this is bad request and the way we do that we navigate back to error handler material and we'll start by creating a object a custom error object and the reason we'll do that because we'll set up multiple if statements now technically you can also manipulate this code and i'll show you in a second why and how but in my case i'll just leave it the way it is so if our error is our custom one basically if it's one of the classes then we'll just right away send back the response if not there's going to be a new custom error object and then as far as the response we'll send back that object instead so let's start working on that and essentially we want to go with some kind of variable in my case i'm going to go with let just so i know that i'm going to be manipulating those values and i'll say custom error and that one is equal to status code and the message so here i want to set up two properties and basically we want to set defaults so the same idea if there's already something provided then of course we'll send back that if not then there's going to be some kind of default and effectively it's going to look something like this where we'll go with the property name so status code and this will be equal to error and then the status code and eventually there's going to be multiple if statements that will manipulate this value so in here i'm just setting up the defaults i say hey listen if in the error i already have the status code then use that if not well then let's set up the generic response let's say status codes and we're looking for internal server error and that of course is going to be 500 and let's do the same thing with the message so message property and error and let's just say here message and let's go with two vertical bars and we'll say something something went wrong and let's say try again again later and now of course what we want to do is change this code around where instead of sending this internal server error and json and error of course we'll use these values instead now i will still leave this code meaning i'll just comment this out so copy and paste and comment down just because i'll be sending those error object back to the postman because i find it easier than logging in here and chasing it around the terminal again that is just my preference and essentially what we want to change over here is the error now of course we're looking for custom error and then we want to go with status code and then as far as the json well the same thing we're going to go with message and we'll set it equal to our customer dot and of course we're looking for the message and you'll notice that at the moment there's really no difference so if i go back and again try to register susan even though the email is already news i see this one i see over here a message and this is going to be that mongoose one and of course i still have this 500. so technically nothing changed now of course this is where we'll work on right now where after our custom api instance we'll go here if and essentially if you want to check we'll have to take a look at the object one more time so this is why i'll keep both of these responses because it is hard to find that error over here and essentially i'll be sending back the object just so you can see what is happening and i think for time being i'll get the error so let me just save it here let's send one more time and what you'll notice that of course if we have that duplicate issue this is the error that we're getting back and effectively what we want to do we want to check if the error code exists and the code is equal to this 11 and then three zeros then we want to send back this value this email one so then we want to access this key value and then just come up with some kind of message so it's going to look something like this where we're going to go with if then like i said we're checking for error code and keep in mind that i'm not talking about custom error here i'm saying yeah there is a error object and now i want to check whether it has the code property and if it has then i want to check more specifically if the value is equal to 11 and then three zeros so go over here like this and then if that is the case then i know that i can access of course this key value property and i just need to come up with some kind of message now what we'll do over here like i said we'll modify these values over here so in here we just set up the defaults if the error is not going to match any of our conditions then either we'll use the actual error status code if it exists as well as the message if not then of course we'll have these defaults hopefully that is clear and let's just start by setting up the message now how we can do that well we can go with custom error so that's our object and essentially we're overriding the message correct i'm just saying the message value will be equal and in this case i'm gonna use the template literals because i'll pass in the actual arrow key value and as far as text i'm just gonna say duplicate value and third four and now let's access the value let's say error and again remember we're looking for this property over here correct so say here error and we're looking for key value and then we just want to continue with the text so field please choose another value another value and of course i also want to change the status code so in this case i'll go with custom error and i'm looking for status code property and i'll set it equal to 400 because this is a bad request and since we can clearly see the error object since we already have all of the code that we need again i'm just going to hop around here and i'll comment this one out because i will use this one in a later videos and then we'll go back to this custom one and once we set everything up now of course we can navigate here we can send and of course this is the response so now we have the message we have duplicate value entered for object object and we'll work on this one a little bit later and what's really cool that of course now we have 400 so we can clearly see that it is a bad request now if we don't want to send this object object which of course is not that helpful we'll simply need to use a little bit of javascript but of course we have the object so our key value is an object and in javascript we have object dot and of course in our case we're looking for keys so this will give us a array of keys and of course in this case we'll only have the email so it's going to look something like this where we go with object keys and then we'll pass in our error and key value and as a result we'll get back array of the keys so let's send one more time let's go back over here and now of course we'll have duplicate value for the email field please choose another value and with this in place now we're handling the duplicate error and essentially we're sending back more friendly user response awesome and once we check for duplicate value now let's quickly talk about our custom api ones so our classes and we can actually remove this if statement right now because remember in the custom error we are checking for the status code so if that property is on the object then beautiful we set our status code value and the same goes for a message and in order to showcase that i'm just going to remove this if statement for time being i'll just comment it out just so i can always put it back if i'm wrong and then as far as the route well let's take a look at our auth chairs and i believe we're using it in a login correct we have our bad request error so let's try it out now of course i'm going to go to login user and i'll try to get the token for susan without providing the password so let me remove it let me send it over here and now of course i still have please provide email and password and of course the error code the status code is also good it is 400 which simply means that of course our logic works because again we have this custom error one and essentially we're looking for a status code property on the error object that's coming in because remember in here of course we're setting up a new one and the same goes for a message so you can simply remove this code now i'll leave this one for your reference just in case you want to use it but effectively we don't need to use this anymore and of course with our new setup we don't need to import the custom api our class as well so you can remove it and the code will still work not bad not bad in our current setup we're nicely handling duplicate values as well as our own custom errors so now of course we want to deal with those validation errors which of course is the case for example in the auth when i'm registering the user and i'm right away passing in direct.body so i'm not checking for email or password or name over here i simply let the mongoose handle that and the way we do that is pretty similar to what we have over here we simply want to set up the if statement again we'll have some kind of condition in this case we're going to be looking for validation error and if that is the case again we'll use one of the nifty javascript methods in this case we're not going to be looking for keys we'll be looking for the values and of course we'll send back the nice response and in order to test it out let's just go back again to our postman now i'm not going to do that in login because again in here we have our custom one the bad request one what i want to do is go back to the register user and here i want to remove both the email and the password and yes i'm purposely removing both just so you can clearly see our functionality in action and once we do that once we send i mean we can still see 500 so that just means internal server error but the message is already more userfriendly correct we already have user validation failed password and blah blah blah so let me show you the entire object just so you can understand the functionality we're about to set up better and technically i don't even need to comment this one out because if i have my first return of course this is what we'll send back so let me go back to the postman send it one more time and of course this is going to be that giant object that we're getting back and the structure is following where we have this errors object and of course in here we'll have all the values that are missing so of course in our case that is password and the email and this is very very important because of course if you have only one then technically you don't need to worry about multiple keys but that's not our scenario so in our case we do need to worry about multiple keys in that object because maybe the password email and name might be missing and also in that object in the error object not only we have errors we also have the name and essentially in our if block we just want to check whether it is a validation error so let's go back and i'm going to do that above the duplicate one but of course the position doesn't really matter where i'll say error name if it is equal to the validation error so let's go over here with validation error and if you need to copy and paste just so you don't make some silly typos so essentially if you're like me then of course you can do that so let's copy and paste and if that is the case then what i want to do is get all the values for the keys in the errors object so notice of course i have the password correct of course i have the email and what we want to do grab this errors one and just get the actual values of these objects because errors is an object itself then password and email are object so i'm looking for the actual values in there and you'll see what i mean in a second so i have if error name is equal to validation error then let's just go with custom error and we're going to be looking for the message and like i said we're going to go with object and values and then we'll pass in the error and errors so in the error object of course there is errors object and in there i have two more keys we have password and email and i want to turn them into array and then i want to iterate over using map so since we're getting back the area of course i can use my map method and i'm just going to call this item so each and every item i'll call the item and then i'll say item.message so in here you'll notice that of course in there in that values i have a message property correct and then i want to access it and send it back so let's say here item dot message and then we'll just join it back to the string and we'll add a comma so that's going to be our message now as far as the status code again 400 so let's go over here with custom error and we're looking for status code and that will be equal to 400 so once we save and once we send it back now of course we should get a better response but of course we don't because i mean i left my first response in there as well so let me comment this sucker out and then send it here and now of course i have please provide password please provide email which effectively is way more user friendly than the object that we're sending back and also notice the status code of course now we're sending back 400 and if you're confused about the code just go back to the error handler and just log what you're getting back from object that values and it will make total sense so essentially the map and join will make total sense so let's try it over here we'll go with console.log and then we're looking for object dot values and then here we want to pass in error so the error object and then more specifically the errors object so let's save it and back in postman we want to send it of course response doesn't change but in my terminal i can clearly see that what i'm getting back from object.values is array of objects and then i'm iterating over that array and then more specifically in each object i'm accessing the message and then i just join all of them together so i set it back to the string and then i just add comma e in between and once we have all of this in place now of course we can worry about our third instance and that's going to be the cast error and as far as the cast error of course in the auth we're not going to get it because we're not using the ids but in the jobs we should get it so back in where i have the jobs controller if we take a look at i don't know get single job of course i'm passing in the job id that is coming from params correct and here if i cannot find the job that has the job id with the user id of course i send back the not found error however there also might be a case where the syntax doesn't match to whatever the database is looking for and of course in order to showcase that let me just go to get all the jobs so this is going to get me all the jobs that susan has and as a side note i think i logged out so let me log in back as susan so let's say over here password and in my case while i'm testing and pretty much setting everything up as secret so let's send it here yep we have the tokens so let me now send get all jobs okay awesome i'm getting the jobs and now of course whether that's for get single job update job or deletion i will have to provide that id and if i'll just mess up the values that's one thing then we'll get that 404 but we also might have that cast error so let's go to i don't know get single job copy and paste the correct id send here okay we should get back the correct response but if i'm going to start adding the values who are removing we should see the casting error now again in our case we just see the string so let me scroll down i know it's a little bit annoying but it's important for me to showcase those big objects just so i can see where we're getting the values from and once i send it of course now i have error and the name is equal to cast error and now we just want to swing back to our error handler and essentially set up the if condition where i'm going to be checking for cast error if that is the case then of course i'll just send back some kind of string with 404 so again that's going to be not found one and i'll just provide the value just so user can understand what's happening so let's go back over here let's say if and i'll just say error name and if it is equal to a cast error and if that is the case i want to go with my custom error then the property name is message and actually i want to set it up as template string so no item found with id and then we're going to be going for error and of course i'm looking for the value one so in the our object there's a valid property and i'm looking for this id so let's say here error value and then the next thing is that status code and in this case we want to go with custom error so custom error here and status code and that is going to be equal to 404 or not found now of course if you want to use the status quo here as well please definitely do so i just thought that it's important for me the first time to show you the actual number status code and then if you want you can use the library instead so let me send it here and of course i should get back the proper response but problem is that i'm still sending back the first one so now let me remove it since we're not going to use it let's save it and then once we send now we have no item found with id and we have the 404 and with this in place of course we can move on to the next topic all right so for all our apps were nice and cute since we only use them in local setup but with this project things are about to get interesting you see this app will actually host on heroku basically deployed on the cloud and what that means that we also need to think about security essentially how we can protect our api from some bad actors and the good news is that with the help of community so think npm and more specifically npm packages we really don't need to do that much just install some packages and add them as middleware in our app and we're good to go yes it is that simple now is our app going to be safe from any possible attack well no most likely not remember our biggest security soft spot is still our user yes of course we should be protecting our api but how are you going to stop the user from storing a token in a unsecure manner there's really no package for that and as far as the packages we're going to use well first we're going to use helmet arguably the most popular security package out there which sets various http headers to prevent numerous possible attacks in fact helmet is so popular it's actually used in many other packages as a dependency after that we want to implement coors library which just ensures that our api is accessible from different domain if you don't have cores installed you'll only be able to access the data from the same domain if you remember in the previous project we did that in javascript file located in the public folder and if you try to access our previous apis from any other frontend apps you'll get a course error now coors stands for cross origin resource sharing and it is a mechanism to allow or restrict requested resources on a web server depending on where the http request was initiated by installing and implementing the course package essentially we make our api accessible to the public after that we want to use xss clean library which sanitizes the user input in reg.body reg.query and reg.params and as a result protects us from crosssite scripting attacks where the attacker tries to inject some malicious code and lastly we want to limit the amount of requests the user can make and we'll do that with the help of express rate limit library if you're using the star all libraries already installed and ready to go but if you want to use it for your own project of course just install them by running npm install and then name of library and also if you want to get more info on any of them a library docs is a very good place to start in later projects we might use some additional libraries or config options but in general as far as the standard security this setup is a very good place to start all right and once we have covered general info about the security packages now we simply want to go to app.js we want to import them one by one and of course we just want to invoke them and in my case i'm going to do it over here where we have express.json and i'm going to start by providing comment extra and let's say security packages and then we're looking for helmet first and we'll set it of course equal to the package helmet then the same for cores so this is the course package and we have one for crosssite scripting so require and the package name here is xss clean and last one is express rate limit and i'm purposely setting this one up last just because there's going to be a little bit of configuration there as well so let's go with require and express rate limit then let's save keep scrolling where we have the json let's start with our helmet so app.use and like i said we just invoke the helmet the same for rest of them so i'm that use and of course in here i'm looking for cores i can just copy and paste then i want to go for crosssite scripting one so xss and again we invoke it and then we add limit1 so again app.use then rate limit and you know what i think i'm going to change the name here i'm going to go with rate limiter not a big deal but just my preference and if we take a look at the package docs effectively what we want to set up is the time so in how long and how many requests and as you can see here they provide an object and properties are window milliseconds so effectively we get this in milliseconds and we just set up time and as you can see this is example for 15 minutes and then how many requests and also if you keep on scrolling you'll notice their responses so by default the message is going to be too many requests and the error response is going to be 429. and once we're clear on setup let's implement it in our own app so first what i want to do is move this rate limiter up so i want to set it up as our first middleware and then in order to speed this up we'll just grab the object here with those milliseconds as well as the max request we'll invoke it here copy and paste and our limiter is in place lastly according to their docs if our application is behind reverse proxy which is going to be our case since we'll push this up to heroku we also want to implement this app.set trust proxy so let's just take this code and place it before the rate limiter and with this in place we have our security packages so now we can move on to our next step just a friendly reminder that we're about to host our project on heroku and if in the mongodb you are using local ip address option you'll need to switch to allow access from anywhere one otherwise mongodb will throw an error and your app won't work awesome and once we have the basic security in place let's complete this project by deploying it on a cloud so we can start utilizing our api from any frontend setup and while there are many hosting providers out there during this course we'll use the following two heroku and digitalocean they both have their pros and cons so just like in most cases at the end of the day everything depends on your own preference and for this project we'll use heroku and since it offers generous free tier in order to follow along you'll only need three things an existing heroku account and of course the sign up is free so just navigate to heroku.com and look for signup option second since heroku utilizes git version control you'll need git installed on your computer and since this is somewhat of an advanced course my assumption is that that is already a case my assumption is that you already have git properly installed and third you'll need a heroku cli a tool to deploy our apps right from our computer and as far as the install for heroku cli you can find the entire setup in the heroku docs so once you sign up for the account this is going to be your dashboard and of course i already have some apps in there and you can find the cli install by clicking on the docs and more specifically the heroku cli link so let's click on a docs and then like i said we're looking for roku cli and in here just pick the operating system and follow the steps once you're done with an install make sure to double check whether everything went smoothly by typing heroku hyphen v in the terminal and if you can see the version number great feel free to proceed to the next video if not if you don't see the version number please troubleshoot since you'll need a working heroku cli in order to follow along with the deployment so if i go back to my terminal and if i type heroku hyphen v of course i can see the version number which means that i have a working cli on my computer and lastly in the next video we'll actually deploy our app and during deployment we will utilize some common standard git commands like init and and commit and since this is not a git course i'm not going to dwell on them too much so if you need to jog your memory as far as the get basics please utilize the search engine all right and once you have installed heroku cli now let's finally deploy our application and in my case what i'm going to do i'm going to look for the entire folder so this is the entire course and then for the jobs api and after that i want to get the final one and essentially i will make the copy just so i can set it up on desktop now of course in your case that is going to be your current application however i do strongly suggest following all the steps and deploying the project as a separate project and here's what i mean so i'll make the copy of the final one here and i'll rename it but before i do that i'll just drag and drop and place it on a desktop so here now it is on desktop and then i'll call this jobs api or whatever again the waste name is really up to you and i suggest doing the same thing essentially if you have been working on starter just make the copy and set it up on desktop or somewhere separately because it's just going to be easier otherwise if you're working in the entire course project in my opinion it's going to be hard to navigate around and set everything up and you also might run into some bugs so let me open up right now my text editor i'll make this one a little bit smaller then i'll drag and drop my application and effectively will follow these steps so let me go back to heroku we'll go to documentation here and then we're looking for node.js and then more specifically we're looking for deploying node.js apps on heroku so these are all the steps we're going to take plus some additional ones that i find useful and first what i want to do is go back to my project and i always always always start by removing the existing git repo just in case there is one and as far as the magnet command is rm then hyphen rf and then git now if you're using windows if you take a look at my twitter if you look around you'll probably find one of my tweets where i share both the command for windows as well as the mac again this is very very important you always want to start from the scratch after that we want to check whether we have that process dot env port variable and by the way by the end of deploy i'll show you where we can actually see the value that is on heroku but this is a must again we can hard code and it nicely works in a local setup but when you deploy you always want to go with process.nv and then the port variable and then heroku picks that port variable and of course spins up our application on that port then we want to set up a simple route so at the moment we have the auth and jobs but what i also like to do is just to set up a simple dummy get road so i know that everything is fine and i have deployed my application and in this case i'm just going to go with app.get then forward slash so of course that's my index and then i'm looking for rec and res and then here let's just send a silly little response where we say res dot and say send and jobs api that's it that's all we have to do and then we will navigate to package.json and this is where we'll take a look at the steps so let's keep on scrolling and they suggest setting the node version and in my case that is node 14 because remember initially when we started the course i installed note 14 but if you install different version push set that one up and just to jog your memory if you want to check your node version just go to node dash nv and again my case that is 14.15 but essentially we'll just go with 14. so in the package json keep scrolling then add a comma and then let's say engines and then inside of it let's go with node and pretty much set up the same code so in order to speed this up i'll just copy and paste and i'm in good shape then let's scroll up and where we have start command we're not going to go with nodemon app.js this is of course only in development effectively we'll go with node and app.js then save it so that should do it for package.json and then lastly as far as the initial setup we want to set up a proc file and then add some values to it now if you want to find more info about the proc file just keep scrolling here blah blah blah and i think i already went past it so let me go up notice here specifying a start script and if you click on this profile you can find more info but effectively what we want to do is create new file now we don't add extension here we just say proc file like so and then inside of it we'll go with web and we'll set node and app.js so pretty much this value is going to be the same as our start command and that should do it for initial setup so now of course we need to start working with git as well and first we'll start by git init so we'll initialize empty git repo then we want to add everything to the staging area so git add and then that and then of course some kind of commit message so essentially in this case i'm going to go with initial commit okay awesome and then this is where the heroku comes in we want to go with heroku and you know let me just clear everything so you can clearly see what's happening so we're gonna go with heroku and login so if you have the cli you'll be able to log in just press any key like this suggest over here and then once you do that they'll ask you to log in okay then of course we want to create a new heroku application and we do that in the following way we go with roku and again let me clear everything let's go with heroku then create and then we need to come up with a name and keep in mind that you cannot start with a number so if you remember in our course project of course i go zero 0605 or whatever in this case i'm gonna have to go with jobs api and then this probably will be taken let me double check yep notice here he's already taken so we need to start from scratch so let's say heroku create and then i'm gonna go jobs iphone api and then zero six again you cannot go zero six and then jobs api it's not going to work because you cannot start with a number so let's set it up now i'm creating that new application awesome and as i said if you just run heroku create it will create a name for you so if that's what you prefer i mean go for it and then i just want to quickly check whether git remote points to the actual repo so let's say here git remote and then hyphen v and if you see these values then of course we are moving in the right direction and before we can push this up we need to of course deal with our env variables correct because if you take a look at the get ignore of course these are ignored and that's how they should be and effectively we have two ways we can do it using command line but i'll just add one value using the command line i'll just go with this lifetime one and then i'll show you another way how we can do that e in the dashboard on the gory because i find gui to be easier as far as setting up the env variables now with that said of course that means that initially when we push our application to the github it's not going to work because our application is looking for all the nv variables but i'm just going to show you one the lifetime one because if you'll try to do this secret essentially in the command line it's just going to be spinning back errors as far as the secret value now of course you can always switch back to string the i don't know secret jwt or whatever but since i want to keep this value i'll show you both setups and after i've been rambling and rambling for about half an hour about it let's go with heroku then config config and then we want to go with a colon and set and essentially this is where we're going to set up those env variables and yes for all the env variables you have you'll have to type this heroku config and send it by typing as always is awesome so let's go with config and then set more properly and then copy and paste and by the way didn't copy this one either my apologies i'm literally on fire so let's go back here and then copy and paste and now of course we're setting that config variable correct so now we have one the jwt lifetime and 30 days so without setting up these ones we'll push this up to the heroku of course our application won't work but then i'll show you another way how we can set them up so now let's go here and in the command line let's clean everything and let's just type git push and heroku and then if you check the docs they say and by the way this is that login screen and close it but if you check the docs they say that you should go with heroku and main now in my case if i type heroku and main i'm basically going to be getting this error if i go with get push roku and master then everything works as expected now our application is being pushed to the github and from there of course the heroical picks it up and now it starts deploy but we need to go back to our dashboard our gui then in here we can refresh we should see the application but again it's not going to work if you go to application if you open app of course you'll have some kind of dummy screen or whatever but i can tell you right away that our application won't work because of course those emv variables are not there now in order to set them up in a gui we'll go over here and we're looking for settings and we'll go with reveal config wires and notice we have the lifetime one correct and now simply what we want to do is add the rest of the values as well so essentially here i'm looking forward to my uri that's going to be my first one copy and paste and the same goes over here so i want to take the value of course and copy and paste let's add this one and the same will do with our secret one and for some interesting reason in the console it spits back errors but in the gui when you add that secret one then everything works like peaches so let me go back here let me grab the value copy and paste and now of course we want to add that var and then in order to spin everything up we just need to go here more and we need to go with restart all dinos so at this point i'll freeze the screen i'll change back to my actual password and then i'll restart dinos and once we restart all the dinos yep that's what we want to do and if we take a look at the logs you'll see how initially our application was on port 43 710 so that was the port that the heroku picked then we exited with a status of 143 so basically we had the issue with our process.nv and now of course we're back to 46 and then 97 so that's the port if we open up the application notice i can clearly see my jobs api and of course i was just showcasing the port variable so you get the clear idea of how everything is set up that's why we go here with this port because then heroku picks the port where our application is going to be located and once i have my application up and running we simply want to grab the url and we want to test it out now i'm not going to test it out with all the routes but i definitely want to create or log in the user and see whether i can see all the jobs so in my case i'm going to go to the postman and since i don't want to mess up these routes i'll actually create first a global variable because in here of course yes i have the url but what is the actual url well it is localhost 3000 correct now what do we want to do we want to go with edit then let's write here prod and then underscore url and then let's just copy and paste the value so this is going to be the url for your application now we're still looking for api and then version one so that's not going to change let's save it here and then i can close my globals and like i said i'll create a new route and this is going to be a post route and since i have that one susan user i'll just try to log in and then see whether i can see all the jobs that susan has and in this case we're looking for prod and of course the url okay awesome then we're looking for auth and then forward slash login so that is going to be the url now as far as the credentials well where we have the login user first i want to grab the body here so let's take all of this and again we're just doing that so we don't have to type everything from scratch so json copy and paste okay we have susan gmail password and all that and then remember since i want to set that token automatically what do we need to do well we need to look for tests correct and just take these two lines of code and then back in my production one copy and paste and now i want to send and if everything is correct which of course it is i'm getting back my token and i'm still setting it up in the globals which is just awesome and now of course we just want to create another route now this will get all the jobs that susan has so let's go and go with get route and we're looking for again the production url then jobs and this is going to be the get route that's correct and then in here i mean let's go with authorization of course we're looking for better token and access token and if everything is correct i should see that susan has two jobs one for netflix and one for google and wonderful we have successfully created our application and we have deployed it on heroku as well okay once our app is chilling on a cloud now it's time to set up some nice docs using swagger ui don't get me wrong there are quite a few alternative api documentation options out there but it's hard to compete with a nice end result you get with swagger with that said setting up swagger manually aka writing the code yourself from scratch is no walk in the park it's not that it's hard it's just really tedious and takes somewhat long time and since i don't want to spend three hours on setting up the docs i'll show you a nice shortcut where we can utilize the post mandox and a thirdparty library to essentially automate the process and as a result save ourselves a ton of time before we continue please let me make it clear this is not going to be tutorial on swagger ui we just want to create working docs and in fact i won't dwell on any of the details if you want to find out more about swagger ui syntax and other options please utilize one of the tons of nice tutorials and blog posts out there and we're going to start our documentation setup with a little detour where i'll show you how to clone an existing heroku app needless to say technically it's optional if you don't want to do that you can just keep using the project we used for deployment but if you're anything like me essentially if possible you don't like keeping the projects on your local machine and instead you want to keep them on a cloud i think you'll find this video useful and i want to start by navigating back to my desktop i'm looking for my terminal first i want to navigate to desktop so let's say here cd desktop then we want to go with heroku so that's the cli then git clone and hyphen a and after that we need to provide the name of that which in my case is jobs api 0 6 so either you can copy and paste or you can type it out and in my case i'm going to go with jobs api and 0 6 and now on my desktop i should have the repo and what that means is that the url is pointing back to the heroku so every time we'll make some change of course we'll push it back to heroku and all the changes will be applied now what's missing of course is the node modules as well as the dot env because remember if we take a look at our git ignore this is not pushed up to the github now in order to fix that we'll need to create a file so go with dot env and then we want to provide all three values uri and rest of the two for djwt now where you can get them we'll remember if we navigate to our application then more specifically settings we have our variables correct config vars so just open this up set it up in dot env install all the packages and then you can run npm start and once i'm done setting up my environment variables like i already mentioned we're gonna go with npm install so install all the packages and then let's go with npm start now since i want to make tiny changes here there's not gonna be that much code essentially i will keep in the package just on node objects please keep in mind that if you want to add more changes to the project it's probably more useful to set up the command where you're using the nodemon because if you remember it's quite annoying would know that you have to restart every time you make the change again we'll have only like i don't know six lines of code so it doesn't really matter in our case but in general if this is what you're doing if you're cloning the app back from the heroku just remember to change the start command or set up some kind of command that you can use in dev where effectively you are using nodemon right from the get go and if i can see that server is listening on port 5000 that means that everything is correct and if i navigate to the localhost 5000 in my browser i should have that silly jobs api and with this in place now we can start setting up the docs once our application is running on localhost 5000 we want to swing back to the postman and we want to get the documentation and the way we do that we look for our collection and before you do anything just make sure that the global url variable is the same in all the requests in my case i'm using the production one but it doesn't really matter since we'll change that value later anyway so you can use the url just make sure that all the requests have the same value otherwise you might get some weird bugs and in fact postman offers documentation itself the problem is that once you publish it it actually goes to a separate url now what do i mean by that well eventually in our api we'll have the route api docs as you can see and this is where the user will be able to access the docs with postman once we publish the docs they're automatically hosted online but on a separate url and since i want my docs to be on the same server that's why we're doing all this swagger stuff and in order to export documentation just look for the collection again jobs api make sure that the urls are all the same in all the requests and then the option you're looking for is this export one if for somewhere reason you don't see it just sign up for a free postman account it's not gonna cost you anything they're not gonna charge your credit card you just need to use the email and you'll be good to go again this is the case if you don't see the export option if you do then smash the export option like there's no tomorrow afterwards pick the second option then decide on the name and location and in my case i'm gonna go with docs json and i'll save it on a desktop and once we navigate to the location and we can see the json file then of course we can move on to the next step awesome once we have the postman json file we are halfway there we just need to fix a tiny issue you see we cannot pass postman docs directly into swagger ui effectively we need to format our data first just so swagger understands what's happening and in order to accomplish that we'll have to sign up for one more free tool api matic important side note just like other course resources it's free and i have no affiliation to them so in order to follow along the videos go to apimatic.io and sign up for free account assuming that you sign up for the account this is going to be your dashboard and you're looking for the import option and we want to import that docs json in my case i'm going to be looking in the desktop and i want to import yes now don't pay attention to those warnings as long as you don't have any errors we should be good to go so i'm going to click on proceed and once you have the api instance in place before we can ship it to swagger ui we'll need to edit a little bit so this is the case where we'll add the proper url we'll set up the proper authorization and all that cool stuff so we want to click here on edit api and let's just start with basic settings and as you can see we have tons and tons of options but totally honestly we'll just go with a barebones setup since i don't want to waste too much of your time and as far as the name i think i'm going to go with jobs api if you want you can add the image that's not what i'm looking for so i'll just save basic settings and this is very very important make sure that you save before moving on to the next configuration options then we're looking for server configuration option the environment will be production server name i'll just leave it as server one and when it comes to url this is where you wanna pass the url that points back to your heroku project so in my case let me double check i'm gonna go back to heroku here i have my jobs api open app so that's going to be my route now one downside with heroku is that yes it takes time to spin up that dyno so that's one thing that you need to keep in mind and i'll just take the url i'll navigate back to the api matic copy and paste and then remember as far as our routes we still want to go with api and then version one and then we'll have auth and jobs again make sure make sure make sure make sure that you save the config settings it's very easy to make some changes and then just forget about it and when it comes to authentication yes we'll use the better token so auth 2.0 that stays the same after that we want to move on to the endpoints and here in the endpoints you'll notice that all of them effectively have the authentication and that's not what we want because if you remember as far as our api well these ones the actual auth routes well we don't want to set up the authentication on them correct these are going to be the public ones and only the jobs will be protected and will require that token hopefully we're on the same page we're looking for register user and login user so let me open up this endpoint here then we want to change the group and i'll change it to auth and i want to skip the authentication because by default the authentication is going to be added to all of them so let's save the endpoint and now we should see the auth folder and in there there's going to be a register user and we're skipping authentication this is very very important and the second route that i want to add is the login one so look for the login user and same deal we want to skip the authentication and we want to place it in our auth folder so let's save the endpoint and then for the rest of them we are not skipping the authentication so don't click here but what we want to do is change the folder so for all the routes one by one i'll add group and the name will be jobs and once i say i have jobs folder with create job wrote and i'm not skipping the authentication and essentially what you want to do apply the same group to the rest of the routes get all jobs all the way to delete job and since it's not very useful for you to watch how i do that i'll pause the video and i'll just add this jobs group to the rest of the routes and once i'm done i will resume the video and once you're done you should have two folders the jobs folder with all the jobs routes and again we're not skipping the authentication and auth folder where we are skipping the authentication and we have two following routes register user and login user and if that is the case just navigate back to the dashboard then you're looking for this option you're looking for export api and this is very very very important that you go with open api version three as you can see by default we have version two json you're looking for this one and you wanna go with yaml option so click here and then export documentation and eventually this is what you should see on a screen and if that is the case now we can move on to our next step all right and once our documentation makes sense to swagger ui now let's test it out in their online editor which is a nifty tool that we can use to test out our api docs right in the browser and if necessary apply the changes and as a result save ourselves a ton of time so what i want you to do is go to your search engine and you're looking for swagger error or swagger ui error doesn't really matter and then you can open up two tabs because you'll notice that they do provide some boilerplate code which of course you can use in order to understand the entire setup and this is exactly what i'm going to do so i have one tab open and i'll open up the another one and in there i want to copy and paste this entire thing so let me select it then go back and i want to copy and paste after that we can technically start testing our api but the problem is that we still have the params unfixed and also we have this extra tag and we'll start with the tag where basically navigate to the bottom where you have the tags and just remove the first one so that's done and then let's deal with the query parameters because if you take a look at our project notice we have jobs and then for single job the update job and delete job these are query parameters but at the moment everything is hard coded so how we can set it up in swagger z params well we'll use their docs this is going to be the case where i want you to again use your search engine and just type swagger ui parameters a quick side note if you can't be bothered going through the swagger docs you can always find the correct code in the project readme you're looking probably for the first link then we'll keep on scrolling yep all the details and all that but what we're interested is common parameters for all methods of the path now i don't want you to take the path part but i want you to take everything starting with the user all the way to get so take this code yes we'll modify but this is just going to be faster if we set it up this way go back to your error and what you're looking for are those single routes so go up here where you have the patch remove the hardcoded one including the column this is very very important and the same for get and once you remove the get part just copy and paste this one in this case we don't want to use the user because the route is jobs correct then we have the id yeah that still stays the same and instead of integer this is going to be a string it's going to be required and it's going to be a job id again if you want to find more info please just read their documentation but essentially what we did right now we added that id parameter in all these three routes get single job update job and delete job and once we have this in place now we can start testing our api and i'll start by registering the user now i'm not going to try out all the routes but i think i'm just going to go with a register and maybe i'll try to create a job and then take a look at a single job just so you can see that everything works and the way we do that in a swagger we look for try it out here notice these are the values that we're sending and of course once you already register user you'll have to change these values around but in my case i deleted the bob from my database so i can execute notice this is going to be the sample request this is going to be the url and voila this is the response so that's my token but the deal again in here is that these ones are protected so if i'll just try to access the job or create job or whatever i'm not going to be able to do that so you want to copy the token and you have two options either you can set up in one of them and automatically it's going to be added to all of them or you can just scroll up and same deal just copy and paste the value authorized so now i set up my token so i can close the register i'm good to go now we just want to create a job so let's go to the post request again we're trying it out i'm going to go with the same google and the frontend developer we'll execute we should get back the job the 201 and now if i go to get all jobs and we try it out we just execute we don't need to provide anything we have our jobs array with a counter one and if i want to take a look at single job we want to copy and paste the value and as far as the setup either of these is going to work so either get patch or delete and my case i think i'm going to go with get we want to try it out again after that we want to paste the job id remember as far as the authorization we right away set up the token at the very very start so now of course we're authorized to make these requests so once we execute check it out now i can see my one job and once everything is working now the last step is just setting this up in our application so we'll still need this code so don't remove it or mess it up but the good news is that we're pretty much done with the hardest part so i promise it's going to be a smooth sailing from here on out beautiful and once we have tested our api in a swagger editor now we just want to add it to our application and in order to do that we'll need two packages we'll need yaml js and the swagger ui express now if you can see both packages in the package.json then of course you're good to go but since i added these packages later essentially they were not with initial star you might need to install them yourself so if you don't see them just run the command of npm and i or installed doesn't really matter then go for yaml js and swagger ui ui and express so this one will convert the yaml one to something that the swagger ui can understand and swagger ui express just adds swagger to our application so i'll install both packages even though i have them and i'll start by creating a new file and in my case i'm going to call this swagger and yaml now the name is really up to you just make sure that the extension is yaml and now you want to take this entire thing again this is a little bit different than what we have from api matic this is already a working documentation copy and paste and back in our app.js we want to do two things we want to require the swagger ui express the yaml js and then load the yaml file and then we want to pass it on to the swagger ui so i'm gonna go below the extra packages we'll add comment here i'll say swagger and let's just start by grabbing the swagger ui again we're just coming up with some kind of name and this will be equal to require then we're looking for the swagger ui express and since i have yaml file i also want to do that and that will be equal to require and we're looking for the package and then we want to load the file so in here let's just come up with some kind of name i'm going to go with swagger document and that will be equal to yaml that's the variable then dot and the method you're looking for is load and in here you want to point to the file which of course is in the root so we simply go with swagger dot and yaml and once we have all of this code in place now we just want to scroll down and where we have here the app.get above it below it it's really up to you we'll go with app.use then we need to come up with a path and in my case i'm going to go with forward slash api docs and you know what actually changed my mind i'll place it after the forward slash so let's go here let's say api docs as you can see we're using app.use so it will be a middleware and then as far as the code we want to go with swagger so that's our variable and we're looking for the serve property and then we want to get that yaml file so again we go with swagger ui setup method and in this case we want to pass in that swagger document once all of this is in place now i just want to go to app.get and instead of sending back jobs api what i want to do is send back the heading 1 let's say jobs api i'll close the heading 1 and then i'll just set up some link that goes to api and for some reason i went with api use should be api docs my apologies so let me go here i'm going to go with href and we're going to set it up as forward slash api docs and then let's close the link and let's just say documentation and once we have all of this in place now let's run npm start but i can tell you right away that if you'll try to test this on a local machine it's not going to work basically you'll get a bunch of errors so everything is going to work once we push this up to the get up for now i just want to see whether the basic setup work so let me look for localhost and then i'm looking for 5000 i should see the documentation and once we navigate here voila we have our documentation in place now the only thing we need to do is just go back and then add those three commands we want to look for git add so this is going to add to the staging area then we'll go with git commit let's just say swagger docs added and lastly remember the command get push heroku main or master so in my case it's master now we're pushing everything to the heroku and if there are no weird bugs we should be in good place and the nice swagger door condition should be added to our project and to answer your question yes when you are setting up manually basically when you're typing this yourself you do need to provide all these properties and i just thought that it's much easier to show you how to do that automatically because you need to keep in mind that as we're progressing with the course our projects are going to get more complex and i really don't want to spend five hours on a project and then another five on the documentation because it seems like a big waste of your time so now let me navigate back to my web browser i'll close all of my tabs since i have 10 000 of them open i want to go to heroku i want to open up the app i have my documentation awesome and now let's test it out so before we do anything why don't we remove that bob user because i think that that way i don't have to waste too much time on changing the values i'm not going to test every route but i want to test out the major ones so let me delete the user just so i can see that everything works we're looking for a register user option i want to go with try it out of course and we want to execute we should get back the token which is just awesome now let's quickly authorize the route so let's add here copy and paste authorized we'll close it and then let's create a job so let's go here we're going to go with tryout and we'll execute yep we're creating a job and lastly let's just get all the jobs try it out and execute i can see that i have my jobs array with a counter one so that's how we can add swagger ui documentation to our api without typing any of the code ourselves
