With timestamps:

00:00 - what is up guys fah here here from
00:02 - awesometoots.com
00:05 - let us now import the assets for our new
00:07 - game that we are going to create as you
00:09 - can see i have a brand new project this
00:12 - is a 3d project so when you create a new
00:15 - project check the check box or the radio
00:18 - button for 3d
00:20 - name your project save it in any
00:23 - location where you want to save it and
00:25 - create it
00:27 - here i only have the scenes folder with
00:29 - my gameplay scene which is this scene
00:31 - right here which is completely empty i
00:33 - did not import anything i was waiting
00:35 - for you to watch this video so now we
00:37 - are gonna go in our assets folder that
00:41 - you can download in the link below and
00:44 - select all of these assets so we have
00:46 - fonts materials models prefabs sounds
00:49 - and textures so drag and drop them right
00:53 - here inside of the project tab and of
00:55 - course we will need to wait for unity to
00:59 - take mercy
01:01 - upon us and
01:03 - import all of these assets so
01:07 - let us wait one moment more no no no no
01:10 - no no and finally they are here
01:13 - so in this video i'm going to set up our
01:17 - main or gameplay scene and we're going
01:20 - to do that by going inside of the
01:21 - prefabs folder and here we have our
01:24 - level and here it is i'm simply going to
01:26 - drag and drop it here in the hierarchy
01:28 - panel and voila this is our level i'm
01:30 - just gonna go here with my mouse and see
01:34 - it
01:34 - and this is our level now of course it
01:38 - looks like it's a little bit dark but
01:40 - now it's a little bit white again so i'm
01:42 - gonna go quickly inside of this
01:45 - lightning tab and i'm gonna uncheck this
01:47 - out to generate and the lightning tab is
01:51 - under window
01:52 - and then here you will see lightning and
01:55 - then you're gonna click on settings
01:56 - which will open this tab right here it
01:59 - will probably be floating for you let me
02:01 - try if i can make it float no apparently
02:04 - not here yeah finally so it will finally
02:07 - it will probably not finally be floating
02:09 - for you like this
02:11 - i dock it usually right next here to the
02:14 - inspector panel on my right side
02:17 - and when you select the lightning tab
02:19 - you're gonna go right here
02:21 - inside or the bottom
02:23 - of this lightning tab and you're gonna
02:26 - uncheck this auto generate now this auto
02:28 - generate notice here when i hover over
02:30 - it says automatically generates lighting
02:32 - data in the scene when any changes are
02:34 - made to the lighting system this means
02:36 - if we take this directional light and if
02:39 - i even change it a little bit so if i
02:41 - change the rotation from 50 to 71 it
02:45 - will rebake lightning it will try to
02:47 - simulate lightning and that takes time
02:50 - that's the reason why i have turned this
02:54 - off it will try to rebuild the lightning
02:57 - settings
02:58 - which will take a lot a lot of time for
03:02 - us and we will need to wait your
03:04 - computer will get hot so on and so forth
03:06 - that's why i am going to turn it off
03:09 - now we are going to duplicate this
03:12 - directional light but first of all for
03:14 - this light i'm going to set the rotation
03:17 - to 10
03:18 - like this
03:19 - and it already looks pretty nice
03:22 - and the intensity i'm gonna set it at
03:25 - one we can set it 1.5 for example
03:28 - but one will do and i'm going to
03:30 - duplicate it so i'm going to quickly
03:33 - duplicate it here and this is
03:34 - directional light
03:36 - one and also for this one i'm gonna set
03:38 - the rotation for the y-axis at zero so
03:42 - the position x is zero position y is
03:45 - three z rotation is zero rotation x is
03:49 - ten
03:49 - y is zero and z is zero this is for our
03:53 - directional light one for our direction
03:56 - light two so this one right here i'm
03:59 - going to set the y rotation at 43
04:02 - and do we want to set here
04:05 - point
04:06 - three for the intensity or something
04:09 - like this
04:10 - because now we're casting shadows here
04:12 - on the side and of course this all
04:13 - depends on the intensity it depends on
04:16 - the lighting i can also pump up the
04:18 - intensity which will be something like
04:19 - this which is something you use to kill
04:21 - vampires in your game anyways i'm not
04:24 - gonna go too much into lightning because
04:28 - it is a separate topic on its own i talk
04:30 - about this in the ultimate game
04:32 - development academy in a whole section
04:35 - with a brand project or brand new
04:37 - project so a separate project for
04:40 - talking about lighting demonstrating how
04:42 - lighting works so it's a separate topic
04:44 - for itself but here i've just used this
04:47 - directional light i can actually remove
04:50 - this one so we can leave it at one you
04:52 - can play with intensity if you want to
04:54 - but i will leave it at 1 and the
04:56 - rotation is perfect i have turned off
04:58 - the duplicate by the way and it looks
05:00 - nice it looks pretty nice if i go in the
05:03 - game this is how it looks like and by
05:05 - the way for the main camera
05:08 - here it is
05:09 - the z-axis is going to be zero
05:12 - the y-axis is going to be one something
05:15 - like this and also the far for clipping
05:19 - planes i'm going to set it at 10
05:21 - something like this
05:23 - this what i did for the clipping planes
05:25 - it will simply if i pump it up pay
05:28 - attention to these parts right here let
05:31 - me just demonstrate which parts do i
05:33 - mean
05:34 - come on highlight tool where it is here
05:37 - it is you see this from camera this
05:39 - right here and this right here like what
05:42 - the camera is seeing so pay attention to
05:44 - that if i take my clipping place and
05:47 - place it far it means it will see as
05:50 - long as the camera is stretching you see
05:52 - as long as the camera is stretching we
05:54 - don't need that much we only need 10
05:57 - to stretch the camera right
05:59 - here where our plane is or our game
06:02 - field is and this looks pretty nice this
06:04 - looks pretty nice i'm pretty satisfied
06:06 - with this
06:07 - so we're not gonna touch this anymore
06:09 - but we are going to go and create our
06:12 - snake and i am going to right click here
06:15 - and create an empty game object like
06:18 - this zero zero zero
06:21 - and this game object is going to be our
06:24 - snake so i'm going to name it snake
06:27 - now
06:28 - for our snake we need to filter for our
06:32 - mesh which is our eyeball mesh and here
06:35 - it is eyeball i know i'm using an
06:37 - eyeball for our snake but hey nobody's
06:40 - perfect so don't judge me
06:42 - and i am simply going to take this
06:44 - eyeball and put it here inside of our
06:47 - game and we already see it is casting
06:50 - shadows let me just clear this console
06:52 - and here it is this is our eyeball
06:55 - i'm going to take this one the the
06:58 - child one i'm going to remove this one
07:00 - which is the parent one and i'm going to
07:02 - put it as a child under our snake
07:05 - and let me just position so zero zero
07:07 - zero
07:08 - for our rotation i'm going to see here
07:12 - or set it negative
07:14 - nineteen so negative 90 0 for the y
07:17 - 180 for the z
07:20 - for our skill one one and one and by the
07:24 - way our snake here
07:26 - we need to set the z axis let me just
07:29 - 5.8 something like this for 5.8 so now
07:33 - it is visible and for our eyeball which
07:36 - is going to be the head of the snake so
07:37 - here i'm going to say head
07:39 - i'm going to set it to point 12.12
07:44 - and i'm saying i'm going to set it to
07:45 - 0.12 but i'm setting the scale i did not
07:47 - set what i'm going to set i'm going to
07:51 - set the scale so select it and the scale
07:54 - is going to be
07:56 - 1.12 1.12 1.12
08:00 - now this is for the head of our snake
08:04 - we are also going to duplicate the head
08:06 - and i'm going to put it here and this
08:08 - one is going to be our node one i'm
08:10 - going to name node
08:12 - and let me just move it right here and
08:15 - this node i'm going to say it's
08:18 - 0.1.1.1 it needs to be smaller than our
08:23 - head
08:24 - and let me just duplicate it one more
08:26 - time and i'm going to put one note as a
08:28 - child of our snake parent game object
08:32 - and this note
08:34 - i'm going to put it somewhere here
08:36 - something like this
08:38 - now the another the other node you can
08:41 - move it here
08:43 - let me just move it below
08:45 - so let me just put this one a little bit
08:47 - closer to our snake yeah this works
08:50 - pretty nice
08:53 - and the last one is going to be our tail
08:56 - so this is why i have removed this one
08:59 - or this one is going to be our tail and
09:02 - for the tail i'm quickly going to add a
09:04 - sphere collider and i'm going to attach
09:07 - a rigid body on it so attach a sphere
09:10 - collider on this game object this one
09:12 - that we named tail
09:14 - and attach
09:16 - a rigid body on it now uncheck this use
09:19 - gravity because we don't want to use
09:20 - gravity and duplicate it one more time
09:23 - i'm going to rename it to simply tail
09:26 - and put one of these as a child of our
09:29 - snake
09:30 - now let me just zoom in
09:33 - and for our tail here i'm going to set
09:35 - it at 0 0 and
09:38 - position it here something like this so
09:40 - we are going to position it to be as a
09:43 - tail of our snake and for this one we're
09:46 - going to save it in prefab so i'm going
09:47 - to go here and create a folder that i'm
09:50 - going to call snake
09:52 - and inside of the snake folder i'm going
09:54 - to drag and drop this tail and now we
09:57 - can safely remove it so tail can be
09:59 - removed
10:01 - and now this is our snake if i go in the
10:03 - gameplay scene you see this is our snake
10:05 - so the tail is here it has a sphere
10:08 - collider and a rigid body the node
10:11 - can also have or it needs to have a
10:13 - sphere collider but we can uncheck it
10:16 - for this node so for the second one the
10:19 - one after the head we don't need the
10:21 - sphere collider to be checked and the
10:23 - rigid body we are also going to add it
10:26 - and uncheck use gravity
10:28 - by the way for the tail also make sure
10:30 - that you check this is trigger and do
10:33 - the same thing for this tail right here
10:35 - check it to be a trigger the tail
10:37 - right here i meant the one that we
10:39 - dragged and dropped into the snake
10:41 - prefabs folder and for the snake's head
10:45 - which is
10:46 - this dude right here now for this one we
10:49 - are also going to attach a sphere
10:51 - collider so sphere collider
10:54 - make sure it is a trigger
10:57 - and i am also going to attach a rigid
11:00 - body
11:01 - and for this rigid body i'm going to
11:03 - uncheck use gravity because we do not
11:06 - need to use gravity for the rigid body
11:09 - which we will see later on we will
11:10 - demonstrate that when we start moving
11:13 - because we are going to move from our
11:15 - code and if we let gravity do the thing
11:18 - it will pull us down which is something
11:20 - that we don't want
11:22 - now for this
11:24 - sphere collider for the head we can
11:26 - actually also uncheck it so you can
11:28 - uncheck it because the top game object
11:30 - the top pair and this one the snake it
11:32 - will have a sphere collider
11:35 - and this sphere collider's radius is
11:37 - going to be 0.1 or actually it is going
11:40 - to be one
11:42 - and the center
11:44 - is going to be let's
11:47 - see where it is just quickly let me see
11:49 - where my sphere collider is so here it
11:52 - is
11:53 - yeah it is large actually i need to
11:55 - resize a little bit more
11:57 - going here
11:59 - moving our sphere collider yeah
12:02 - something like this i need to resize it
12:05 - more let's say 0.1
12:07 - 12 just so that i can see where it is
12:10 - you see this green line this is where
12:12 - our sphere collider is
12:14 - if i set it at zero i think this is
12:16 - perfect yeah
12:17 - point one or point one one
12:20 - is where we want the sphere collector to
12:22 - be i also i am going to make it a
12:25 - trigger i think this is okay let me just
12:27 - try to resize it a little bit soak it so
12:30 - that i can see where it is radius yeah
12:33 - 0.11
12:35 - is for our radius of the sphere collider
12:39 - i'm also going to click on add component
12:41 - and attach a rigid body on this dude
12:43 - right here and i'm also going to uncheck
12:46 - this use gravity because we do not need
12:49 - it we don't need it
12:52 - and this is it this is preparation for
12:55 - our game we have the snake we have the
12:57 - level i'm gonna drag and drop the snake
12:59 - in the snake prefab folder so for the
13:01 - snake we have an empty parent top game
13:04 - object we also have the head
13:07 - which is this one right here or this one
13:10 - right here the top one or the largest
13:12 - part of the snake we have the no this
13:14 - one i just named node because it's the
13:17 - second body part of the snake and we
13:19 - have the tail so every next
13:22 - game object that we add because you know
13:24 - when we eat
13:25 - our fruit the game object or the snake
13:28 - will grow larger it's the same as on old
13:31 - nokia phones when you use that snake and
13:33 - you ate more and more the snake go grows
13:37 - larger and larger so
13:41 - all of those other objects that we're
13:42 - going to add so larger and larger
13:45 - objects are our tails so the tail needs
13:48 - to be named like this so that we can
13:49 - differentiate it we have the head we
13:52 - attach sphere colliders on all of them
13:54 - so the tail and the sphere collider for
13:56 - the tail needs to be checked it needs to
13:58 - work because we can collide with the
14:00 - tail you know the snake can kill itself
14:01 - if it touches itself so this is for the
14:04 - tail for the note it does not matter
14:06 - because we are not going to do that for
14:08 - the note which is the next part after
14:10 - the head
14:11 - head here it's also going to have a
14:13 - rigid body all of these game objects
14:15 - have a rigid body except for the head
14:17 - and the node the sphere collider must be
14:20 - turned off or we can also remove it and
14:23 - for the snake we have the sphere
14:24 - collider rigid body which is the top
14:26 - most game object and this is preparation
14:30 - for our snake moving forward with our
14:33 - game we have prepared our level we added
14:36 - our snake we added two directional
14:38 - lights we turned one off now you can
14:41 - turn it back on or turn it off this all
14:44 - depends on you however you want to do it
14:46 - you can also turn the first one or the
14:48 - second one off and probably pump up the
14:51 - intensity on the first one however you
14:54 - want to do it it's up to you so i'm not
14:58 - gonna touch that i will turn the second
14:59 - one on so both of them are turned on
15:02 - this is our snake in the middle of our
15:05 - screen and we need to start moving the
15:07 - snake
15:08 - in order to do that we need to go in our
15:12 - project tab and right click and create a
15:15 - new folder and this one is going to be
15:17 - our scripts folder and inside of this
15:20 - one
15:21 - right click and i'm going to create here
15:24 - folder for helper scripts
15:28 - now for our helper script the first
15:30 - script that we need to create is our
15:33 - script that's going to hold our tag so
15:35 - i'm going to name it tags and first of
15:38 - all right click create a c sharp script
15:41 - you are going to double click it and
15:42 - open it in visual studio mana develop
15:44 - whichever one you are using
15:47 - now since in our tags class as you
15:49 - already know or assume
15:52 - we will add tags and default variables
15:55 - that we are going to use throughout our
15:56 - game so i took the liberty to copy them
15:59 - simply here and now you can pause the
16:01 - video and simply paste them but before
16:04 - you do that i am going to explain what
16:06 - they are now here it's
16:08 - playerdirection.direction
16:10 - without n anyways
16:13 - the tags here will represent the tags so
16:15 - we have the walls so when we collide
16:17 - with them we will check if the collision
16:19 - happened with a game object that has a
16:21 - tag wall when we pick up a fruit we will
16:24 - check that with the tag as well so these
16:26 - are the tags for our game object and
16:29 - here we can say tail with small t or a i
16:33 - l i wrote it all caps and for our
16:36 - metrics so these are the metrics that we
16:39 - are going to use to position and move
16:41 - our nodes inside of our game or to move
16:44 - the snake we will see that do not worry
16:47 - about that
16:49 - and this is a public enumeration to
16:51 - determine if we are moving left
16:54 - up right down and this is the count eg
16:58 - or
16:59 - it will show us how many movements do we
17:02 - have so one two three and four so we
17:05 - have four
17:06 - movements now as you can see in our
17:09 - public enum we can say left is equal to
17:11 - zero
17:12 - up
17:13 - is equal to one right is equal to two so
17:16 - we can do that as well this is something
17:18 - that we did not do before so i am
17:20 - showing you that we can do it and why
17:23 - are we doing it like this because later
17:25 - on we will use these values so 0 1 2 and
17:29 - 3 to access indexes in our array so
17:33 - don't worry about that you can pause the
17:35 - video now
17:36 - and copy all of these tags
17:40 - metrics and player direction
17:44 - and now i i'm i am assuming that you
17:47 - have copied all of those and i'm gonna
17:49 - move forward and go in unity and in
17:51 - scripts i'm going to write click and
17:54 - create a new c sharp or actual new
17:57 - folder and this one is going to be our
17:59 - player scripts and inside of this folder
18:02 - i'm going to right click and create a c
18:04 - sharp script
18:05 - now this one is going to be our player
18:07 - controller this is the dude who needs to
18:10 - be attached on our snake so select the
18:14 - snake drag and drop our player
18:16 - controller just like this i'm going to
18:18 - double click it and open it here in
18:20 - visual studio let me just
18:22 - do my thing as always and this is going
18:26 - to be the script that's going to move
18:28 - the player we are going to create
18:29 - another separate script for getting
18:31 - input that means we will move the snake
18:34 - or the player left right
18:37 - up and down
18:38 - and for that we will use a separate
18:40 - script this script is the one that is
18:42 - going to move the player and of course
18:43 - we need here a couple of variables the
18:46 - first one is going to be our public
18:48 - player direction which i'm going to
18:50 - simply call direction and since it's
18:52 - public it will be visible in the
18:54 - inspector panel i am going to hide it in
18:57 - the inspector we don't need it to be
19:01 - visible in the inspector panel but we
19:02 - need it to be public
19:05 - next we also need here and hiding
19:08 - inspector
19:09 - public float step
19:11 - length which is going to be equal to 0.2
19:14 - f now this is the movement interval so
19:18 - we are going to move our game objects or
19:21 - the snake by this movement in terrible
19:24 - so 0.2
19:27 - now we don't want to move our snakes
19:30 - every frame that is 60 frames in a
19:32 - second so we don't want to move it every
19:34 - frame so we need a movement frequency so
19:36 - here i'm going to say public float
19:38 - movement
19:39 - frequency like this which is going to be
19:42 - equal to 0.1
19:44 - and i'm also going to hide this bad boy
19:47 - in the inspector now you see we're going
19:49 - to move our snake every 0.1 of a second
19:53 - instead of moving it every single time
19:56 - or 60 times in a second that's why we
19:59 - need this movement frequency now we also
20:01 - need a private game object which is
20:04 - going to be our node prefab or actually
20:06 - our tail prefab so you can name it tail
20:09 - you can name it node however you want it
20:12 - it is private it will be only accessible
20:14 - here but we need to make it serializable
20:16 - or serializable or serialize field
20:20 - because we want to drag and drop our
20:23 - tail if we go back here in unity
20:26 - and notice here in the inspector we will
20:28 - see an empty field to drag and drop this
20:30 - game object for in it is located in the
20:33 - prefabs and snake
20:35 - select here the snake and drag and drop
20:38 - the tail right here i'm also going to
20:40 - hit apply to make changes to this prefab
20:43 - now this is why we need to make it a
20:45 - serialized field because we want it to
20:48 - be private but still we need to drag and
20:50 - drop that game object inside
20:54 - now we also need to store the next
20:56 - position displacement based on player
20:58 - direction and for that we are going to
21:00 - use a private list of vector 3's which
21:03 - we are going to call delta position this
21:07 - is where we are going to store the
21:08 - previous movement of our player don't
21:10 - worry we will see everything in action
21:13 - we also need a private
21:16 - list of
21:18 - rigid bodies which i'm going to call
21:20 - notes and this is going to be every
21:22 - single separate node inside of the
21:24 - snake's body that is snake's head
21:28 - and snake's tails so on and so forth
21:32 - we also need a private
21:34 - vector three and for this one fruit
21:39 - note actually we don't need this one so
21:41 - we are not going to use this one but we
21:43 - are going to use a private rigid body
21:46 - for main body
21:48 - a private rigid body for the head body
21:52 - and a private transform tr for our own
21:56 - transform store tr
21:58 - not transform
22:00 - we also need
22:02 - a private
22:05 - float
22:06 - counter and a private bull move now this
22:10 - counter we will use it with the movement
22:12 - frequency to allow the player to move
22:15 - and we can
22:17 - put these two right here so that they
22:20 - are put with the appropriate or right
22:23 - below the appropriate variable that will
22:25 - accompany them later on and the last
22:28 - variable that we need is a private bool
22:31 - create node at tail this will tell us do
22:36 - we need to create a node at our tail
22:38 - that is when we eat a fruit do we need
22:41 - to create a note or not
22:44 - now instead of me explaining all of
22:45 - these variables one by one what they are
22:48 - i will demonstrate that so in the awake
22:50 - so i'm going to change start to awake in
22:52 - the awake the first thing that we are
22:54 - going to do is we are going to say our
22:55 - tr is equal to our transform tr is this
22:59 - one right here so we're going to get it
23:02 - with our or our transform is equal to tr
23:05 - next thing our main body is going to be
23:08 - equal to get component and get the rigid
23:10 - body component from our player and that
23:14 - is the top head or the top main body of
23:17 - the snake so the top parent which is the
23:19 - empty game object so this one right here
23:21 - that we currently have selected in the
23:23 - hierarchy
23:24 - we have that one selected that is the or
23:28 - the one that we are getting its rigid
23:29 - body by using get component
23:32 - the next thing that we need to do is we
23:34 - need to call here init
23:36 - snake nodes now this is a function that
23:38 - we still did not create and right below
23:41 - that function we are also going to call
23:43 - init player
23:44 - and this is also a function that we
23:46 - still did not create now let us go and
23:49 - create that right below the update we're
23:52 - going to create void init
23:54 - snake nodes now in this one we are going
23:58 - to initialize the nodes that means every
24:00 - single separate part of the snake as you
24:03 - can see
24:04 - if i go inside of the scene view you see
24:08 - we need to get all of these notes so we
24:09 - need to get the head of the snake so
24:12 - this one we also need to get this node
24:14 - the middle one and the tail one so we
24:17 - need to get all three of these
24:20 - so here in our init snake nodes we're
24:22 - going to say nodes which is our array of
24:25 - rigid bodies or a list you see here of
24:28 - rigid bodies and we are going to make it
24:31 - a new list of rigid bodies
24:34 - and below here we're going to say
24:36 - nodes.add to add to that list and we're
24:38 - going to say tr which is our transform
24:41 - get child and we're going to get the
24:44 - child that's at the zero index dot get
24:47 - component
24:48 - so it's get component
24:51 - rigid body component just like
24:54 - this close parentheses and we're good to
24:56 - go
24:57 - copy paste copy paste and we're going to
24:59 - say child one and child two and what is
25:02 - going on here now before i explain the
25:05 - last thing that we need to do is our
25:07 - head body is equal to nodes and the
25:10 - element that's at index number zero
25:14 - what is going on here you see here we
25:16 - are using tr which is our transform you
25:18 - see here our tr is the transform get
25:21 - child and we are getting the child what
25:24 - does this mean
25:25 - you see our transform the topmost
25:28 - transform from our snake it has children
25:30 - so we have the node or the head the node
25:32 - in the tail and we know that or the
25:35 - transform knows that we have children
25:37 - assigned to it so we can use or access
25:40 - those children's by using
25:44 - indexes so you can say get child 0 which
25:47 - means it will get the first child or the
25:50 - child that's at element 0 which is in
25:53 - our case head
25:55 - get child one in our case it's the node
25:58 - get child two in our case it is the tail
26:03 - and here notice the head body
26:06 - it is the rigid body of the head snake
26:10 - so the rigid body of the head snake and
26:11 - we know the head is set at index number
26:14 - zero which i explained a moment ago
26:18 - now in order to initialize our player so
26:22 - right here below we are going to create
26:23 - init
26:24 - player
26:26 - simply here we are going to make sure
26:29 - where our player is moving left right or
26:32 - up or down so switch so we're going to
26:35 - use switch and we're going to use
26:37 - direction and we are going to use cases
26:40 - in our switching case so we're going to
26:41 - have case
26:43 - player direction right
26:45 - and here we're going to use break i'm
26:47 - going to copy this and paste it so we
26:49 - are going to have direction
26:51 - left
26:52 - up
26:54 - and
26:55 - down
26:56 - and here i'm going to simply say down
26:59 - so based on the direction we are going
27:00 - to position all of our nodes or shift
27:04 - them to that position so if we need to
27:07 - or if our starting position is the right
27:10 - position we're going to
27:12 - do this so we're going to say nodes and
27:14 - the element that's at index 1
27:16 - that position is going to be equal to
27:19 - nodes and the element that's at index 0
27:23 - minus
27:24 - nu
27:25 - vector 3
27:27 - and here for our x we are going to say
27:30 - metrics dot node
27:33 - and 0f0f
27:36 - and for our
27:40 - for our nodes number two or the element
27:42 - that's a number two and by the way here
27:44 - we need to say node zero that position
27:46 - so the position of our node zero and by
27:48 - the way inside of our nodes we are
27:50 - adding rigid bodies so when we say
27:52 - position we are getting the position of
27:54 - the rigid body you see here when i hover
27:56 - over it says the position of the rigid
28:00 - body so we're getting the position of
28:02 - the rigid body and here we're going to
28:04 - say nodes and the element that's at
28:06 - index 2 now
28:08 - we're going to say that position is
28:10 - equal to and we're going to use nodes an
28:12 - element that's at 0 that position minus
28:15 - nu vector 3
28:17 - and for our metrics so we are going to
28:19 - say metrics dot node and we're going to
28:22 - multiply that by two and zero f zero f
28:26 - what is going on well when we start our
28:30 - game to the right we need to shift the
28:33 - positions of our game objects to the
28:38 - right side and in order to do that we
28:40 - need to get the node 0 which is the head
28:44 - what we need to do essentially if we are
28:46 - starting to the right side that means
28:48 - when we start our game that means when
28:51 - we start our game we will start moving
28:53 - to this side what we need to do we need
28:56 - to shift the position of this node over
28:58 - here
29:00 - and this node over here because then we
29:03 - are going to move to the right or
29:05 - actually to the left side excuse me i'm
29:07 - moving to the left but
29:08 - assume that i said left so if we are
29:10 - moving to the left side we shift their
29:14 - positions to the right side
29:17 - by using plus now let me demonstrate
29:19 - that so i'm going to move them back here
29:21 - and notice here if we are going to move
29:23 - to the left side i'm simply going to
29:25 - copy these lines of code and paste them
29:27 - here instead of typing here minus we're
29:30 - going to say plus
29:32 - you see here we are doing the same thing
29:34 - except here we are doing that with the
29:37 - plus sign so let me go back here and
29:40 - demonstrate that with the left position
29:42 - if we need to start moving to the left
29:44 - position with our snake that means we
29:46 - are going to this side and we know that
29:48 - the head so this bad boy over here he
29:51 - needs to be at the top so he needs to be
29:54 - the leading node in our snake in order
29:58 - to do that we need to shift this node
30:00 - over here and we need to shift this node
30:03 - over here and this is exactly what we
30:05 - are doing right here so if
30:08 - we need to move to the left side use the
30:11 - node that's at element one and use the
30:14 - element zero node which is the head and
30:16 - add to its position the metrics node
30:19 - which is the displacement that we saw
30:21 - here this is the displacement of our
30:24 - nodes so this is how far away they are
30:27 - from each other
30:29 - and do the same thing for our second
30:31 - node essentially this code right here
30:34 - is going to position these nodes
30:36 - relative to the node 0 meaning and let
30:39 - me just go back here meaning our head is
30:42 - the relative position so our node here
30:45 - this code right here is going to move
30:48 - this node over here
30:50 - and this code right here is going to
30:53 - move this tail node over here this is
30:57 - what we are doing essentially now we are
30:59 - going to do or everything that we
31:01 - explained here for the left side applies
31:03 - to the right side except well the right
31:05 - side is opposite to the left for our up
31:08 - side we are going to do the same thing
31:10 - except for the y axis so for the y side
31:13 - we are going to say minus but our
31:15 - metrics node is going to be on the y so
31:18 - zero for the zero f for x and we are
31:21 - going to move that one on the y and same
31:24 - thing here so we're just going to take
31:26 - this and zero f for the x and for the y
31:30 - matrix node multiplied by 2 y multiplied
31:33 - by 2 because our node at second position
31:37 - is our tail node so we need to multiply
31:41 - that by 2 because our head is here our
31:45 - node is here we need to multiply this by
31:47 - two so one
31:48 - head is one node is two and multiply
31:52 - that by two moving that
31:53 - right over here this is why we are
31:57 - multiplying with two
31:59 - for our down position simply copy
32:03 - this code from the up position paste it
32:05 - here and for the down we're going to say
32:07 - plus like this and voila we are good to
32:12 - go now of course we need to create one
32:15 - more function so right here above our
32:17 - init player we're going to create void
32:19 - set direction random
32:22 - and here we're going to say in direction
32:25 - random or die d i r random is going to
32:29 - be equal to random dot range from zero
32:33 - up to and we need to say here int and
32:35 - we're going to say player direction
32:38 - dot count to convert
32:40 - the count to an integer because if we
32:43 - use it like this without casting it to
32:45 - an integer and we go back in unity we
32:47 - will see here best of overloaded method
32:51 - match for random rage float float we
32:53 - need to put this into a float or an
32:55 - integer so i'm going to use it like this
32:58 - because our count if you remember has a
33:00 - value of 4 but this is an enumeration
33:03 - and we can cast this enumeration to an
33:06 - integer i've talked this already once in
33:09 - one of my tutorials can't remember which
33:10 - one but anyways
33:13 - we can cast it into an integer because
33:15 - as i said the value is four
33:17 - so the direction random will be based on
33:19 - random range and notice here we are
33:22 - casting this value to an integer and
33:24 - simply here we're going to say direction
33:26 - is going to be equal to d i r random now
33:29 - same way as we can cast
33:32 - these enums to an integer we can use
33:35 - enumerations to cast integers to enums
33:37 - so we can see here player direction
33:40 - now based here on the random value let's
33:42 - say random value is equal to one so this
33:45 - d i r int or d i r random value will
33:49 - have a value of one when we convert that
33:52 - into our into our enumeration player
33:54 - direction and we go back here the value
33:56 - one is up
33:59 - it will be the same if the value is two
34:01 - so value two is right
34:04 - if the value is let's say three then the
34:06 - direction will be down now we do need to
34:10 - call this right here so set direction
34:13 - random we need to call it right above
34:16 - our switch in case statement so we need
34:18 - to call it right there and we need to go
34:21 - back here and we can unposit or
34:24 - uncomment almost said on position we can
34:26 - uncomment these functions now now pay
34:29 - attention if we go back here i am going
34:31 - to clear the console and we go here in
34:34 - our game pay attention how the snake is
34:37 - positioned snake has been positioned
34:40 - with
34:41 - right direction in mind so
34:43 - it looks like it's going to start moving
34:45 - this direction notice now when we run
34:47 - the game so i'm going to hit the play
34:49 - button you see now it is positioned like
34:51 - it is going to go
34:53 - downwards you see
34:55 - and if i
34:56 - remove or stop the game and play it
34:58 - again
34:59 - you see now it is positioned again to
35:01 - the right side stop and rerun the game
35:04 - it will be positioned now you see like
35:06 - it is going upwards so this is how we
35:10 - are moving these nodes relative to the
35:13 - head node this is how are we positioning
35:16 - these nodes by using these lines of code
35:20 - right here now we are still still not
35:22 - done here with the awake function we
35:24 - need to create our delta position or
35:26 - which to go or position in which where
35:28 - we are going so our delta position is
35:30 - going to be equal to new list of vector
35:32 - threes
35:34 - like this open close these curly
35:36 - brackets and here i'm going to pass a
35:39 - new vector three
35:40 - and here i'm going to say comma now for
35:43 - the x i'm going to say negative step
35:45 - length
35:46 - comma
35:48 - zero f for the y i'm going to copy this
35:50 - and paste it below
35:52 - and here i'm going to say zero f first
35:55 - so zero f and here i am going to say
35:58 - step length comma here
36:01 - paste this one right here now here we
36:03 - are going to have positive step length
36:05 - and i'm going to copy this and paste it
36:07 - here now another comma here remove this
36:10 - comma and here we're going to have the
36:11 - negative length now right here i am
36:14 - going to add
36:16 - comments and here we need to end this
36:17 - statement with
36:19 - our semicolon so i'm going to add
36:21 - comments here like this so this one is
36:23 - going to be our negative dx or
36:26 - going to the left side
36:29 - here
36:31 - i'm going to put it like this this one
36:32 - is going to be our d y
36:34 - or
36:36 - going to the up
36:37 - direction right here i am going to say
36:41 - this one is going to be dx or going to
36:44 - the right side and this one and let me
36:46 - just move all of these by one and this
36:48 - one is going to be our negative
36:51 - d y or this means going to the down
36:55 - direction so you see here this step
36:58 - length
36:59 - this one right here is actually the
37:03 - value or we are going to move by that
37:06 - value so this is the time interval that
37:08 - value
37:09 - when we move we will move by 0.2 units
37:12 - this is what i'm trying to say
37:14 - so when we have this right here this
37:16 - means negative d y we're going to the
37:19 - left side or negative x so to say here
37:23 - we have the positive y meaning up here
37:25 - we have the positive x meaning right and
37:27 - here we have the negative y going down
37:29 - and you see here negative y positive x
37:32 - positive y negative x so this position
37:36 - right here means we're going to the left
37:38 - up right and this one is going down now
37:42 - in order for us to actually move we need
37:45 - to create a function that is going to
37:47 - move us but before that we also need to
37:49 - create a function
37:50 - here we need to create a function that
37:52 - is avoid
37:54 - check movement frequency
37:57 - and for this function
37:59 - we are going to say here our counter so
38:02 - counter plus equals time dot delta time
38:06 - we know the time that delta time is the
38:08 - difference between every frame so it's
38:11 - the time it takes from one frame to go
38:14 - to another frame and we're going to say
38:16 - here if our counter is greater or equal
38:19 - to movement frequency
38:23 - what we are going to do we are going to
38:24 - say our counter is equal to zero to
38:27 - start counting from zero again
38:29 - and here we are going to say move is
38:32 - equal to true to allow our game object
38:36 - to move now in order to make it move
38:40 - we are going to say here void move or
38:42 - create a function that is going to allow
38:45 - us to move and not on animator move no
38:49 - simply void move and inside of this
38:52 - function we are going to create here a
38:55 - vector3 d position this is the delta
38:58 - position we're going to use here delta
39:00 - position so it's actually delta position
39:04 - and we are going to use that by using
39:06 - here an int
39:08 - and we are going to pass here the
39:09 - direction so the delta position or
39:12 - deposition is our delta position we are
39:14 - casting the integer or direction to an
39:16 - integer to get it as an index so
39:19 - depending on the index if we are going
39:21 - to the left side for example if we're
39:23 - going to the left side index will be
39:26 - zero meaning we will access element
39:28 - that's at index zero in the dental in
39:30 - the delta position and if we go here in
39:33 - the delta position element that's at
39:34 - index zero is left as you can see right
39:38 - here
39:39 - so now that we have our delta position
39:42 - what is the next thing to do first of
39:44 - all we are going to create here a vector
39:45 - 3 parent pos of parent position
39:49 - head body dot position
39:51 - and right below here we're going to
39:53 - create a vector 3 prev position or the
39:56 - previous position and below here
40:00 - we are going to say main body
40:02 - that position is equal to
40:05 - main body position plus d position
40:08 - right below we're going to say head body
40:10 - that position is equal to head body dot
40:14 - position plus the position again
40:17 - now we are also going to move all the
40:19 - snake nodes so we're going to say for
40:21 - int i which is equal to one as long as
40:24 - one or i is less than nodes dot count
40:28 - our i is going to be plus plus
40:31 - and we are simply going to see here
40:32 - previous position is equal to
40:35 - nodes
40:36 - element that's an index i that position
40:39 - storing the previous position
40:41 - nodes
40:42 - and element that's at index i that
40:44 - position is equal to parent position
40:47 - and parent position is now equal to
40:50 - previous position now don't worry if i'm
40:52 - not explaining everything in detail
40:54 - right now because we will test it out
40:57 - soon do not worry after we do all of
41:00 - this we need to check if we need to not
41:04 - trigger its check
41:06 - if
41:07 - we
41:08 - need to create a new node
41:13 - because we
41:15 - ate a fruit we will do that later on and
41:18 - for that we're simply going to say if
41:19 - create node at tail then we are going to
41:21 - write the code to do that for us now
41:24 - practically we are done for now and we
41:27 - can test it out by going here in the
41:29 - update function we are going to call
41:32 - check movement frequency which is this
41:35 - one right here
41:36 - come on go down
41:38 - this is check movement frequency in the
41:41 - update we're going to calculate
41:44 - our counter by adding to it delta time
41:46 - and if the counter is greater or equal
41:48 - to movement frequency then we will allow
41:51 - the movement and in the fixed update
41:54 - right below here so void fixed update
41:57 - and let me just remove this private
41:59 - because i like it to be void simply and
42:02 - in our fixed update we're going to check
42:05 - if move so if we can move
42:08 - then move
42:09 - is equal to false and we're going to
42:12 - call the function move
42:14 - not fog mode move
42:16 - like this thank you
42:20 - like this
42:21 - so
42:23 - in the update function we are checking
42:27 - for the frequency so counter plus equals
42:29 - time that delta time if the counter is
42:31 - greater or equal to the movement
42:32 - frequency then we are going to say
42:34 - counter is zero so that we can count
42:36 - from the beginning from zero and move is
42:38 - equal to true
42:40 - in the fixed update if move is equal to
42:42 - true move will be false and move the
42:44 - snake by one increment and in the move
42:47 - here this is where we are going to move
42:50 - the snake now in order to test that and
42:51 - see it in action i am going to go back
42:53 - here in unity and run the game and we
42:55 - are going to see the movement of the
42:57 - snake and then we will go and break it
42:59 - down line by line so when i hit the play
43:01 - button pay attention to the snake you
43:03 - see snake is moving by one increment it
43:04 - is gone we cannot control the snake
43:07 - notice now if i hit the play button now
43:09 - snake is going downwards just a moment
43:11 - ago first time when we tested out snake
43:13 - was moving upwards
43:15 - i'm going to hit the play button again
43:16 - hopefully it will move left or right and
43:18 - now again it is moving down or up
43:21 - come on try to move left or right just
43:24 - for once okay now it is moving to the
43:26 - left side and you can test it out as
43:29 - long as you don't see it moving left
43:31 - right up and down but this definitely
43:33 - works we see it now let me try one more
43:35 - time hopefully it will go to the right
43:37 - side no
43:38 - anyways let's go break it down line by
43:41 - line
43:42 - so these here are now getting
43:44 - a clear picture or we are understanding
43:47 - for what we are using this direction is
43:48 - going to determine in which direction
43:50 - our snake is going to go step length is
43:53 - the frequency or the units measurement
43:56 - unit by how much units we are going to
43:58 - move every node that is 0.2 units
44:02 - movement frequency is the
44:04 - how many times we can move in a second
44:06 - so every point one of a second we can
44:09 - move counter is used to test that out so
44:12 - we are adding to our counter the delta
44:15 - time we know that is the it's a very
44:18 - small number so the difference or the
44:19 - time it takes from one frame to go to
44:22 - another frame so that's a very small
44:24 - number
44:25 - and
44:26 - when that counter value is greater or
44:28 - equal to the movement frequency which is
44:30 - this value right here
44:33 - then we will allow our snake to move so
44:35 - counter is reset back to zero and move
44:38 - is equal to true
44:40 - and moving forward
44:43 - this is our tail prefab which we'll use
44:45 - later on when we eat a fruit or when the
44:47 - snake eats the fruit we will add to the
44:49 - snake so it's get it gets larger and
44:52 - larger
44:53 - this is the delta position and you see
44:55 - here delta position is the direction
44:58 - where we are going is it left is it up
45:01 - right or down and we're using that by
45:03 - well using the step length and these
45:07 - values right here you see here the
45:08 - negative step length is negative x
45:10 - meaning we're going to the left side
45:14 - positive y that means up
45:16 - and positive step linked that means
45:20 - going to the right side the negative y
45:22 - means we're going down
45:24 - now here are the nodes that we are going
45:26 - to get when we initialize the snake
45:28 - basically these are the rigid bodies of
45:30 - every part of the snake so the head the
45:34 - node in every part of the tail so we can
45:36 - have 20 tails when we eat 20 fruits
45:39 - every single one of those tails is going
45:42 - to be added to this node array you see
45:45 - here we're using the transform to get
45:47 - the childs
45:48 - so we are getting the child at index
45:50 - zero one and two
45:52 - child at zero
45:54 - index or at zero index is our head so we
45:57 - are doing or assigning that
45:59 - right here
46:01 - and moving back here we have the main
46:03 - body head and the transform so the main
46:06 - body is our main body or the top parent
46:10 - or the parent of all game objects so
46:13 - this one right here the snake that's the
46:14 - main body
46:16 - our tr is the transform and here we are
46:18 - initializing the snake notes by getting
46:20 - the rigid bodies from every child
46:23 - next we are initializing the player that
46:26 - means we are setting the direction the
46:29 - initial direction of the movement of the
46:31 - snake we're doing that with this
46:34 - function which is this one right here so
46:36 - you're using a random range from zero
46:38 - and direction dot count so player
46:41 - direction count we are casting that to
46:43 - an integer because the value here of the
46:45 - count is equal to four as you can see
46:47 - here count is equal to four so when we
46:51 - cast it to an integer it will display
46:53 - that value so it will display four which
46:55 - means a random range from zero or
46:57 - between zero and four
46:59 - and when we get that random range let's
47:01 - say that number is three
47:03 - we will cast it back to player direction
47:05 - so if the value is three
47:07 - three is down if the value is for
47:10 - example 2 then 2 is right and you get
47:14 - the picture
47:15 - so we are assigning that to the
47:17 - direction now when we do that in this
47:19 - function based on which direction we
47:21 - have is it right left up or down
47:24 - we will displace these nodes and we saw
47:27 - that we have previewed that so let's say
47:29 - for example if the initial position is
47:32 - moving to the left side if i hit here
47:34 - pause and i'm going to zoom in on our
47:37 - snake i'm going to hit the play button
47:39 - you see here the initial direction was
47:42 - left side which means both of these
47:44 - nodes
47:45 - this one here and this one here shifted
47:49 - to the right side by using these lines
47:52 - of code so using the
47:54 - head position of our
47:57 - snake as orientation and we're adding to
48:00 - that position this value here now
48:02 - metrics node is this one right here this
48:05 - is the increment or the stepped length
48:07 - this is the same as step length
48:10 - and for our second node we need to
48:12 - multiply that by two because we need to
48:14 - also place it after our middle node
48:18 - because we have three nodes same applies
48:20 - for right up and down now moving forward
48:24 - here we have our check movement
48:26 - frequency we have explained this so we
48:28 - are adding to the counter delta time
48:30 - when the counter is greater or equal to
48:32 - the movement frequency reset counter
48:34 - move is equal to true this happens in
48:36 - the
48:37 - update function
48:39 - in the move function we are getting the
48:41 - delta position meaning the direction
48:43 - where we are moving so we are moving by
48:46 - using delta position which is our array
48:49 - that we create right here
48:51 - and we are casting to an integer the
48:53 - direction if the direction is for
48:55 - example or the value of the direction is
48:57 - 2
48:58 - that means we are moving to the right
49:01 - side
49:02 - next we are getting the parent position
49:04 - which is our head body position and we
49:06 - are storing the previous position now
49:08 - first we need to start moving the main
49:10 - body which is the main body of our snake
49:12 - the top parent holding all nodes and
49:15 - we're going to move it by using or
49:17 - setting its position to be equal to its
49:19 - current position plus the delta position
49:22 - or the direction where we are going so
49:24 - the direction position
49:26 - we're doing the same thing with the head
49:28 - body so head body's position is equal to
49:31 - head body's current position plus the
49:33 - direction where we are going now
49:35 - depending on if we are going to the left
49:37 - we are going to plus
49:39 - and the value for the left let me just
49:42 - see here the value for the left is the
49:44 - negative step length and 0 for the y so
49:46 - it will move it to that direction
49:51 - now we have to move all of our nodes we
49:53 - moved our head already that's why in i
49:56 - is equal to 1 because here if you paid
49:59 - attention the element or the first node
50:02 - is the node at element 0 which is our
50:05 - head node and we already set the head
50:08 - body or the head node we moved it so now
50:11 - what we need to do is move all other
50:13 - nodes that's why i starts at one and not
50:16 - at zero and we're going to move how many
50:19 - nodes we have if we have 100 nodes then
50:21 - we're going to use count which will be
50:23 - 100 so we will move 100 nodes
50:26 - now the previous position and we are
50:28 - getting that by using the node
50:31 - at the current i index in its current
50:33 - position this is the previous position
50:35 - the new position for that node is the
50:37 - parent position so the parent position
50:40 - that we had here for our head
50:43 - and now the parent position is equal to
50:45 - the previous position because the next
50:47 - node
50:49 - will be repositioned by using that same
50:53 - position and the outcome for that is if
50:56 - we go in our unity and if we hit the
50:59 - play button you will see how our snake
51:02 - is moving come on unity
51:04 - please have mercy upon us so if i hit
51:07 - the play button again you will see that
51:09 - the snake will move in the increment or
51:12 - using incremented values or if we go
51:16 - here the step length that is this is how
51:19 - many units it will use to two moves
51:21 - moving forward with our game we have the
51:24 - snake moving and it is moving in a
51:26 - certain direction the problem is that we
51:28 - cannot control that we cannot control
51:31 - the movement of the snake when the game
51:33 - starts so when we press any button we
51:35 - will not change the direction of the
51:38 - snake so in order to fix that inside of
51:41 - our player scripts folder we need to
51:43 - right click and create a new c sharp
51:46 - script which we are going to call player
51:49 - player input
51:51 - and this script we need to attach on our
51:54 - snake right here so drag and drop our
51:56 - player input
51:58 - hit apply so that this change applies to
52:01 - the prefab and double click it and open
52:03 - it in visual studio man i miss saying
52:07 - open it in mono develop but hey
52:09 - people change so now i'm using visual
52:11 - studio i have changed anyways moving
52:14 - forward
52:15 - what do we need for our player input the
52:18 - first thing is our player controller so
52:20 - we need a private
52:22 - player controller that we are going to
52:24 - call player controller of course
52:27 - this is because we need to inform the
52:29 - player controller that
52:31 - we change the direction where the snake
52:34 - needs to move now we are also going to
52:36 - create a private int horizontal
52:40 - which by default is equal to zero and
52:43 - vertical which by default is equal to
52:46 - zero as well we also need to create a
52:49 - public enumerations of public enum that
52:52 - i'm going to call axes
52:54 - and you can assume which axes do we have
52:56 - so we have horizontal and we have
53:00 - vertical because well we have two axes
53:03 - now inside of our start function we can
53:07 - get our player controller so player
53:10 - controller
53:11 - is equal to get component
53:14 - get component
53:17 - player controller component like this
53:21 - and this can be done in the awake
53:23 - function as well so you can choose to
53:25 - put this in the awake if you want to we
53:27 - can leave it at awake because we are
53:29 - only getting here our player controller
53:32 - because i like to initialize my
53:33 - variables in the awake function more
53:36 - than i like to initialize them in the
53:38 - start function
53:39 - now inside of the update the first thing
53:42 - that we need to do is that we need to
53:45 - get our player input but before that we
53:48 - need to say horizontal is equal to zero
53:51 - and vertical is equal to zero to reset
53:55 - their values and now in order to get
53:58 - that input we need to call a function
54:00 - that we did not create and i'm going to
54:03 - call it get keyboard input like this
54:08 - and right below here we're going to
54:10 - create it by
54:11 - typing void in the name of the function
54:14 - which is get keyboard input
54:17 - and now
54:19 - inside of our keyboard input we're
54:21 - simply going to say horizontal is equal
54:23 - to
54:24 - and we need to say input dot
54:26 - get axis raw
54:29 - and here we are going to say horizontal
54:32 - and for our vertical we are going to say
54:35 - vertical is equal to input dot get axis
54:39 - or raw and it is going to be vertical
54:42 - but we have an error what is this error
54:45 - if i hover over it says cannot
54:47 - implicitly convert type float to an
54:49 - integer
54:50 - the problem is that this returns a float
54:52 - you see this right here this input get
54:55 - axis raw returns a float so we need to
54:57 - cast it to an integer by typing in
54:59 - parentheses in
55:01 - in front of it and the same thing we
55:03 - need to do it right here so we are
55:05 - casting or converting this float
55:09 - into an integer
55:13 - so we have here our horizontal and
55:15 - vertical we do need to test if our
55:18 - horizontal is not equal to null then we
55:22 - need to say our vertical
55:24 - so vertical is going to be equal to zero
55:27 - like this and why
55:30 - do we
55:31 - why did we type this here well if we
55:33 - move horizontal we need to set vertical
55:35 - at zero
55:36 - and
55:38 - this is to prevent double movement so
55:40 - just to prevent double movement this is
55:42 - why we are doing it like this
55:45 - now in order to test this out we need to
55:47 - create a function that we well still did
55:50 - not create and this function let me just
55:52 - type this out here i remove this curly
55:54 - bracket now right below our get keyboard
55:57 - input we need to create void set
56:00 - movement and inside of our set movement
56:02 - we are going to move our game object but
56:05 - we are going to do it or call it right
56:07 - here right below our get
56:10 - keyboard input
56:12 - now inside of our set movement
56:14 - here we are going to say if our vertical
56:17 - is not equal to zero
56:21 - then we are going to call our player
56:23 - controller to change the movement but in
56:26 - order to change that movement we need to
56:28 - go here in our player controller
56:30 - right below our check movement frequency
56:33 - we need to create a public void
56:36 - set
56:37 - input
56:38 - direction
56:39 - which takes a player direction dir as a
56:44 - parameter
56:46 - now first of all in this function we
56:48 - need to prevent movement in the opposite
56:51 - direction what does that mean it means
56:53 - that if we are moving up we cannot start
56:56 - moving down we cannot start moving down
56:59 - or if we are moving left we cannot start
57:02 - to move to the right side and vice versa
57:05 - so we need to say here if our dir is
57:08 - equal to player direction up
57:11 - and our direction is equal to player
57:15 - direction down
57:17 - or if our dir is equal to player
57:21 - direction dot down
57:23 - and
57:25 - our direction is equal to player
57:27 - direction up you you see my point
57:30 - because we cannot move in the opposite
57:32 - side because if the let me quickly go
57:35 - here in unity
57:37 - and if i take my
57:40 - snake in the scene let's assume snake is
57:42 - moving in the right side like this we
57:44 - cannot
57:45 - press left and it will start moving left
57:47 - now we cannot do that we need to start
57:49 - moving up and then move left or down and
57:52 - then move left this is my point that's
57:55 - why we are testing this and we need to
57:58 - say here as well if d i r is equal to
58:01 - player direction dot right and
58:04 - direction is equal to
58:08 - player direction dot left or if d i r
58:12 - is equal to player direction dot left
58:16 - and direction is equal to player
58:19 - direction right so if this is true
58:24 - if some of these is true then we're
58:27 - going to hit return not a rect
58:29 - transformer whatever that was if one of
58:32 - these is true and notice we are using or
58:34 - so only one of these needs to be true so
58:37 - if direction is equal to or d i r is
58:41 - equal to up and d i r is the parameter
58:44 - so if d i r is equal to up and direction
58:47 - is equal to down
58:49 - then that is true we cannot move to the
58:51 - opposite side same thing goes for down
58:53 - and up
58:55 - right and left left and right
58:57 - but if this right here is not true then
59:00 - we are simply going to say direction is
59:02 - equal to d i r now direction is our own
59:07 - variable that we are using here let me
59:09 - just find it here it is our direction we
59:12 - talked about it in the previous video
59:14 - so
59:15 - direction is equal to the parameter that
59:17 - we put here now we also need to force
59:20 - move so we need to see here force move
59:24 - our game object or our snake now our
59:27 - force move we're going to create it so
59:30 - force move and simply in our force move
59:33 - we are going to say counter is equal to
59:36 - zero
59:37 - move is equal to false and move
59:40 - call our function to
59:43 - move the snake immediately without
59:45 - waiting for the next movement frequency
59:48 - threshold why well because
59:51 - when we press the button we want to move
59:53 - the snake right away we don't want to
59:54 - wait for the movement frequency
59:56 - threshold to kick in so that we can
59:59 - actually start moving the snake so right
60:03 - away when we press the button and this
60:04 - is what we are doing here so we are
60:06 - resetting the counter move is equal to
60:08 - false and we will call move to right to
60:12 - move the snake right away
60:14 - now going back to our set movement now
60:17 - if our vertical is not equal to zero we
60:20 - are going to say player controller dot
60:22 - set input direction and here we are
60:25 - going to test
60:27 - if our vertical
60:29 - is equal to one question mark
60:32 - then we are going to say player
60:34 - direction
60:35 - dot up
60:37 - colon
60:38 - player direction dot down what are we
60:42 - doing here what is going on well you see
60:45 - here we are testing if vertical is equal
60:48 - to null this essentially this code right
60:51 - here and let me just take this code so
60:53 - this code right here that we did and let
60:55 - me just put it right here so that we can
60:57 - actually see it this is what we are
60:59 - doing
61:00 - pay attention here
61:02 - so
61:03 - if our vertical is equal to one and we
61:05 - are
61:06 - using or questioning that or asking that
61:09 - with a question mark so if it's equal to
61:10 - one and that is true
61:12 - then the value will be up otherwise the
61:15 - value will be down this is essentially
61:17 - if as if we are doing this let me just
61:19 - put like this and this is essentially
61:22 - the same as if we typed if vertical is
61:25 - equal to 1
61:26 - then our player direction
61:31 - is equal to player direction up so
61:34 - player direction up else if vertical is
61:37 - not equal to one then player direction
61:40 - dot down this is what we are asking
61:44 - with this right here so if the
61:45 - vertical's value is equal to one then we
61:49 - will set direction up which is logical
61:52 - because vertical that means that we will
61:54 - go upwards on the y-axis if and just go
61:58 - back what
62:00 - why is it taking me over there anyways
62:02 - otherwise if our vertical is not equal
62:05 - to one this is
62:07 - for this we are using this column so if
62:09 - it's not equal to one and let me just go
62:12 - back here so if it's not equal to one
62:14 - that means that
62:16 - we will use direction down for the value
62:19 - meaning we will go down now here we are
62:22 - going to say else if
62:24 - so else
62:26 - if our horizontal is not equal to zero
62:30 - we're going to do the same thing so
62:32 - we're going to say player controller
62:33 - playercontroller.set input direction
62:36 - and here we're going to say horizontal
62:38 - is it equal to one
62:40 - question mark and right here we're going
62:42 - to say playerdirection.right
62:46 - colon
62:47 - playerdirection.left it's the same thing
62:50 - except for our horizontal so it's
62:52 - exactly the same thing
62:56 - now we can test this out but we will
62:59 - have one problem and we will see what
63:01 - that problem is
63:03 - so if i go back here i am going to clear
63:06 - the console and i'm going to hit the
63:08 - play button and notice now we can change
63:10 - the direction see we can change the
63:11 - direction but you see the snake is
63:13 - moving like crazy as long as if we are
63:16 - holding our
63:18 - mouse or actually our keyboard i'm
63:20 - pressing w key asd or left arrow right
63:25 - arrow up you see the snake is moving
63:27 - like crazy like some crazy parasite that
63:30 - came from out of earth you know alien
63:32 - parasite and it's trying to get into you
63:35 - now we don't want this we don't want
63:38 - this kind of movement
63:39 - we have this movement because we are
63:41 - using input get axis raw now this is not
63:44 - something that we want so i'm going to
63:45 - comment this out we need to create
63:47 - another function
63:49 - that will get us the movement of the
63:53 - snake now here we're going to create a
63:55 - function that will return an integer and
63:57 - we're going to call it get access raw
64:00 - which takes an axis and i'm going to
64:03 - call it axis as a parameter and it takes
64:05 - this axis that we created this
64:07 - enumeration right here
64:10 - now right at the bottom of this function
64:12 - we are going to return zero if nothing
64:15 - happens because we need to return an
64:17 - integer but what we are going to do here
64:19 - is that we are going to test if
64:22 - our axis is equal to
64:25 - dot horizontal so we need to check for
64:27 - the horizontal axis
64:30 - then we're going to say bull left is
64:32 - equal to input dot get key down did we
64:37 - press a key down and that is going to be
64:39 - key code
64:41 - key code dot left arrow
64:45 - and ball right is going to be input dot
64:50 - get
64:51 - key down and this is going to be key
64:54 - code dot right
64:57 - arrow
64:58 - like this
65:00 - so we are going to get here the boolean
65:03 - for the left and the right now you can
65:06 - do the same thing for our w
65:10 - asd i'm using here arrows so pay
65:12 - attention because we will use arrows
65:15 - left arrow right up and down arrow on
65:17 - your keyboard to move our snake now you
65:20 - can do the same thing for w key asd
65:23 - and to move that
65:25 - that snake with those keys so here i'm
65:28 - going to say if left meaning if we
65:30 - pressed
65:31 - the left arrow key then here we are
65:34 - going to say return
65:36 - return negative one because we are
65:38 - moving to the left side
65:40 - if right then we press the right arrow
65:43 - key we are going to say return one like
65:45 - this otherwise we are going to say
65:48 - return
65:49 - no
65:50 - like this
65:52 - else if
65:54 - so
65:55 - else if our axes is equal to x is that
65:59 - vertical so we need to check for the
66:01 - vertical axis then we're going to say
66:04 - ball up
66:05 - is equal to input dot get key down and
66:08 - we are testing for key code so get key
66:11 - down and it's key code dot
66:15 - up arrow
66:17 - our ball down is equal to input dot get
66:20 - key down and key code.down
66:25 - arrow
66:26 - and same thing so we need to test it
66:28 - like this so we need to say here if up
66:32 - so if up we pressed the up arrow key we
66:36 - are going to return one
66:39 - if
66:40 - down then we are going to return
66:44 - negative one
66:45 - so return minus one
66:47 - otherwise return zero or return null i'm
66:51 - saying null for zero but actually it's
66:53 - return zero so this is what we are doing
66:56 - and let's go inside of our keyboard
66:59 - input and right here our horizontal is
67:01 - going to be equal to get
67:04 - access raw
67:05 - passing here access dot horizontal
67:09 - our vertical is going to be equal to get
67:11 - access raw passing
67:14 - our access dot
67:16 - vertical so it's vertical like this
67:20 - voila
67:21 - so if we go back now in our unity and if
67:25 - i
67:26 - press the
67:29 - play button and notice now if i try to
67:31 - move you see the snake i'm holding the
67:34 - up button so i'm holding these buttons
67:36 - that i'm pressing for the snake to move
67:38 - but the snake is not moving like crazy
67:40 - like you did a moment ago and notice
67:43 - here pay attention now you see the snake
67:45 - is moving and let me just go and
67:47 - demonstrate this so in our player
67:49 - controller if i uncomment or actually
67:52 - comment these lines of code out you will
67:54 - see how
67:55 - this helps us preventing the snake's
67:58 - movement so pay attention now if the
68:01 - snake is moving you see now we cannot
68:03 - move it like this you see it's moving to
68:04 - the left and now we're changing it to
68:06 - move it to the right or now down and now
68:08 - it's moving up you see we cannot move it
68:11 - like this we cannot move the snake like
68:13 - this because the snake then will hit
68:15 - itself and it will die because remember
68:18 - if the snake or in the snake game on old
68:22 - nokia phones or any snake game when the
68:24 - snake hits its own tail it is that gone
68:28 - kaput bam wow however you want to call
68:30 - it anyways it is dead the game is over
68:33 - so that's why we are preventing the
68:36 - movement in the opposite direction
68:37 - because now if i am moving for example
68:39 - to the left side i cannot press right to
68:43 - move so i'm moving to the right and i'm
68:45 - pressing left it's not working i'm
68:46 - moving to the left pressing right we're
68:48 - moving up pressing down it is not
68:50 - working we need to turn left or right
68:53 - and then move to that side where we want
68:56 - to
68:57 - move and also let's go and briefly break
69:01 - down all of these codes now this right
69:03 - here it's pretty clear this is clear
69:05 - what it is this right here as well here
69:08 - we are resetting horizontal and vertical
69:10 - every time after the input and here
69:12 - we're getting that input
69:15 - now pay attention here we are using
69:17 - horizontal and our function get axis raw
69:20 - and here get axis raw here horizontal
69:22 - here vertical this is clear as well so
69:25 - here when it's horizontal we are
69:27 - checking for get key down if we press
69:30 - our key code down
69:32 - for the left arrow or the right arrow we
69:35 - will store that in these booleans if we
69:38 - press the left or if we pressed right we
69:40 - will return negative one or one
69:44 - depending on which one of these we have
69:46 - pressed otherwise we will simply return
69:48 - zero same thing for the vertical axis if
69:52 - we press key code up or down
69:55 - this will trigger or it will set the
69:57 - appropriate boolean out of these two to
69:59 - be true if we press up we'll return one
70:02 - if we press down we will return negative
70:05 - one because down on the y-axis is
70:08 - negative up is positive on the left side
70:10 - for the horizontal left is negative
70:13 - right is positive we did this probably
70:15 - thousands of times in my tutorials on
70:18 - youtube channel in the ultimate game
70:19 - development academy
70:20 - and i talked about this
70:23 - thousands of times and this is basic
70:25 - math if you go to the left side on axis
70:28 - it is the negative side right side is
70:31 - the positive up is positive down is
70:34 - negative
70:35 - so
70:37 - moving back inside of our get keyboard
70:40 - input we are storing that value in the
70:42 - horizontal so it will be either one or
70:44 - negative one or zero and here we are
70:48 - checking if our value
70:51 - is not equal to zero so we need to check
70:53 - if it's not equal to zero because if
70:55 - it's equal to zero we are not moving so
70:57 - we are not moving if it's equal to zero
70:59 - so if it's not equal to zero it's either
71:01 - one or negative one
71:03 - if vertical is equal to one then we will
71:06 - set it up which means positive if it's
71:08 - not equal to one meaning it's negative
71:10 - one then it's down same thing for the
71:13 - horizontal
71:14 - and in our player controller we created
71:16 - set input direction we are preventing
71:19 - here movement to the opposite side and
71:21 - we tested this out a moment ago and when
71:24 - that happens we're setting the direction
71:26 - to our own or dir this parameter to our
71:29 - own movement direction and then force
71:32 - move the snake just so that it moves
71:35 - right away instead of waiting for the
71:38 - threshold of the movement frequency
71:41 - moving forward with our snake we can
71:44 - move it
71:45 - and we can control it so let us now
71:48 - detect collision on the walls and also
71:51 - add our collectibles now first of all
71:53 - we're going to start with our walls and
71:55 - if we go here in the level we have these
71:58 - walls right here so all of these walls
72:01 - and let me select all of them so we have
72:03 - top walls we have bottom walls left and
72:05 - right walls select all of these walls
72:08 - except
72:10 - don't select their parents so bottom
72:12 - walls this one right here left walls and
72:15 - right walls we don't need to select
72:17 - these so select all of the walls except
72:20 - for their parents as you can see i did
72:22 - not select top walls game object bottom
72:25 - walls left walls and right walls because
72:28 - we are using that as a parent to store
72:30 - all of these children
72:32 - so now when we have all of these we are
72:34 - simply going to click on add component
72:36 - and we are going to add a mesh collider
72:39 - so mesh collider component on all of
72:41 - these so that we can detect collision on
72:43 - them
72:44 - and i am going to tag them so click here
72:47 - on add tag and i'm going to create a
72:49 - wall tag i'm also going to create a
72:52 - fruit tag and a bomb tag so select again
72:57 - all of these walls except for their
73:00 - parents so select them except the
73:02 - parents and tag them with the wall tag
73:06 - and voila we're good to go and also for
73:09 - these obstacles here which are these as
73:13 - you can see so these right here if i
73:14 - turn them off so these
73:16 - also set their tag to be wall
73:20 - and i'm going to
73:22 - select the 11 level and hit apply so
73:25 - that this change applies to the prefab
73:27 - and if we go inside of our player
73:29 - controller and right here inside of our
73:32 - void
73:33 - on trigger enter
73:36 - in our ontrigger enter we can test if we
73:38 - collided with the wall except here for
73:40 - other i'm going to say target because i
73:43 - like to name this parameter target and
73:45 - i'm going to say if our target dot tag
73:48 - is equal to tags dot wall
73:51 - we are simply going to print here so
73:54 - print
73:55 - touched wall like this so we touch the
73:58 - wall and that is that this is just for
74:00 - testing purposes we will fix this later
74:03 - on do not worry about that so if i go
74:06 - back here in unity
74:08 - and if i try to collide with some of
74:11 - these wall obstacles pay attention in
74:13 - the console so now when i hit one of
74:16 - these bam we should see inside of our
74:19 - console that we have collided with the
74:21 - wall now of course we collided with the
74:24 - top walls but we are not colliding with
74:26 - the obstacle walls that is because we
74:28 - need to select them as well and attach a
74:31 - mesh collider on them we forgot to do
74:34 - that so if i hit the play button again
74:37 - and if i go through these walls that are
74:40 - obstacle walls bam you see touched wall
74:43 - touched wall touched wall when we go
74:45 - through all of these so this is working
74:48 - we are detecting collision between our
74:50 - walls and now
74:52 - moving back in our project we are going
74:55 - to import the bomb and the fruit now
74:58 - here i'm going to filter for the eyeball
75:00 - in our project and drag and drop the
75:02 - eyeball right here and i'm going to
75:05 - filter for the bomb and i'm going to
75:07 - drag and drop the bomb also in our
75:11 - hierarchy panel and inside of our
75:14 - prefabs i'm going to right click and
75:16 - create a folder and this is going to be
75:19 - our pickups so pickups where we are
75:22 - going to store the eyeball and the bomb
75:24 - and here actually i'm going to name the
75:26 - eyeball to fruit and bomb balls simply
75:29 - to bomb i'm going to tag the fruit with
75:32 - the fruit tag and bomb with the bomb tag
75:36 - i am also going to remove the animation
75:38 - from the bomb and for the fruit remove
75:40 - the animation as well
75:42 - i am going to change the scale of the
75:44 - fruit to 0.1.1
75:47 - 0.1
75:48 - the z-axis is going to be
75:51 - 5.8
75:53 - and we are going to attach a sphere
75:56 - collider on it and actually let me just
75:58 - take this fruit so eyeball this fruit
76:00 - right here and i'm going to name this
76:03 - game object here as fruit and this one
76:06 - i'm going to say
76:08 - 0.1.1.1 rotation i'm going to say 0 this
76:11 - rotation negative 90.
76:14 - and on this one i'm going to attach a
76:16 - sphere collider make it
76:18 - a
76:19 - trigger and let me just see where it is
76:22 - here it is this is our eyeball or our
76:25 - fruit that we are going to use as a
76:26 - fruit that is and i'm going to tag it
76:28 - here with the fruit tag
76:31 - come on select it where it is fruit not
76:34 - bomb what is wrong with me so tag it
76:36 - with the fruit tag and for the bomb i'm
76:39 - also going to change that so i'm going
76:41 - to say 0.2.2.2
76:45 - the z position 5.8 for the bomb and here
76:49 - is our bomb we are also going to attach
76:52 - a sphere collider on the bomb and voila
76:55 - this is it so if we go inside of our
76:59 - prefabs and pickups i'm going to drag
77:02 - and drop the fruit and i'm going to drag
77:04 - and drop the bomb prefab
77:07 - if we go back in unity here if we touch
77:11 - the wall i'm also going to see or if our
77:13 - target tag is equal to tags so tags
77:18 - come on tags dot bomb we are also going
77:21 - to print now touched bomb because we are
77:24 - going to
77:25 - check if we touch the bomb now for our
77:28 - fruit we are going to do the same thing
77:29 - so we are going to say if our target dot
77:32 - tag
77:34 - is equal to tags dot fruit tag
77:38 - and here we are simply going to
77:40 - deactivate it so we are going to say
77:42 - target dot game object set active is
77:44 - false and we need to say create node at
77:48 - the tail is now equal to true because
77:50 - remember here we are going to create a
77:54 - tail because we picked up a fruit so we
77:57 - need to create a tail now first of all
77:59 - we are going to test if this actually
78:01 - works and then we will see
78:02 - how can we create that tail so first of
78:05 - all we are going to pick up the bomb and
78:07 - see if we are printing in the console
78:10 - that we are picking or picked up the
78:12 - bomb so bam we touch the bomb that is
78:14 - good we will end the game when we touch
78:16 - the bomb now we are going to pick up the
78:18 - fruit and when we pick it up bam it is
78:20 - gone
78:21 - but we need to create a node at tail or
78:27 - make the snake larger because we are
78:32 - we picked up a fruit so if i go back
78:34 - here in visual studio
78:36 - this now is true create note a tail is
78:39 - now true
78:40 - so when we go back here this is where we
78:42 - need to create that so first of all
78:45 - when this is true we are going to say
78:47 - create node a tail is now equal to false
78:50 - because we only want to create node at
78:52 - tail once we don't want to create it
78:55 - multiple times
78:57 - and
78:58 - if we continue what is the next thing to
79:00 - do is that we need to create a game
79:02 - object so we need to say game object and
79:05 - we need to say new node is equal to
79:07 - instantiate
79:09 - and we are going to instantiate the node
79:12 - prefab or tail prefab and we can say
79:15 - here new
79:16 - tail or new tail or new node actually
79:19 - new node tail prefab and we are going to
79:22 - instantiate it where where we are going
79:24 - to instantiate it using nodes and we are
79:27 - going to say nodes.count
79:29 - minus 1
79:31 - dot position
79:32 - so position dot quaternion identity like
79:36 - this and let me just move quaternion
79:38 - identity here what are we doing here we
79:40 - know that in our instant sheet we need
79:42 - to pass a game object that we want to
79:44 - instantiate or create a copy out of that
79:47 - game object we need to pass a position
79:49 - and we need to pass a rotation rotation
79:52 - is not important quaternion identity
79:54 - zero zero zero what's important is the
79:56 - position notice here i'm using nodes and
79:59 - nodes count minus one dot position this
80:02 - is the last node in the nodes array that
80:05 - we are storing here and remember in the
80:08 - beginning we
80:10 - stored three nodes our head our middle
80:13 - node and our tail and i said every new
80:15 - tail node will be stored inside of this
80:18 - nodes array because we need to keep
80:20 - track how many do we have and if i go
80:22 - back here what is the next thing to do
80:24 - we need to say new node dot
80:28 - transform.setparent and we need to set
80:30 - our own transform and here we're going
80:33 - to say true you see here world position
80:35 - if world position stays true the parent
80:38 - relative position scale and rotation are
80:40 - modified such that the object keeps the
80:43 - same world space position rotation and
80:45 - scale as before
80:46 - so when we say here true it will simply
80:49 - make this node keep the same position
80:53 - same skill and everything relative to
80:55 - its parent
80:57 - and here we are simply going to say
80:59 - nodes add and we are going to append to
81:01 - it new node
81:04 - dot get component and we're going to
81:06 - append the rigidbody component like this
81:09 - because i said we are going to add every
81:12 - new node inside of this array now we can
81:16 - see this the best way to see this is if
81:19 - i copy and paste a little bit or
81:22 - multiple of these fruits so we can have
81:24 - one fruit here i'm going to duplicate it
81:26 - one fruit here one fruit here for
81:28 - example one fruit here and one fruit
81:32 - here just so that we can see that our
81:34 - snake is growing larger so now we have
81:37 - three of our snakes so three parts of
81:40 - our snakes now we should have four you
81:42 - see now we have four and five you see
81:44 - the snake is bigger and notice now again
81:46 - picking up these you see the snake gets
81:49 - bigger and bigger again picking one one
81:51 - more one more the snake is bigger and
81:54 - the bigger we picked up all of these you
81:57 - see we picked up all of these notes and
82:01 - you can see that every single one of
82:04 - those notes or actually those fruits are
82:07 - being appended at the end of the snake
82:09 - because we are using nodes and nodes
82:12 - count we are getting the element that's
82:14 - at the count minus one which is the last
82:17 - element inside of that array so the last
82:20 - element inside of that array we are
82:23 - getting that and we are positioning we
82:26 - are positioning that node at that
82:29 - position
82:30 - so if the last node let's say if i
82:33 - highlight or use my highlight tool so
82:36 - this is the head of the snake this is
82:37 - the node this is the tail and this is
82:40 - another tail so let's say we
82:42 - eat a new node or new fruit here so we
82:45 - eat it
82:47 - and now we want to append it to the
82:49 - snake so the snakes position or the
82:51 - snake grows larger so this node needs to
82:54 - go here that's why we are using this
82:56 - right here nodes count so this right
82:59 - here position which is the last position
83:02 - count minus one it's the last element in
83:04 - the array which is this one and its
83:06 - position so we are using its position to
83:10 - set it so append that right here so
83:13 - append it right after that position this
83:17 - is what we are doing
83:20 - and basically that is that what we can
83:23 - also add here is that now we can say if
83:27 - so here we can say or if our target dot
83:30 - tag is equal to tags dot tail tag so if
83:34 - we touch our tail so you're also going
83:36 - to say print
83:38 - snake
83:39 - touched tail and if i go back here we
83:42 - need to make sure that our snakes last
83:45 - part has a tail you see here it needs to
83:48 - have a tail tag so add tag and here we
83:52 - are going to say tail tag so select it
83:54 - and this one will have a tail tag
83:57 - hit apply
83:59 - and if we go back here for our snake if
84:03 - i select it and the tail that we add
84:05 - here this tail also needs to have the
84:07 - tail tag because the snake will die if
84:10 - it hits itself and notice if i pick up
84:14 - some of these
84:16 - fruits and when we pick it up the snake
84:19 - will get larger and larger so then we
84:22 - can
84:23 - touch our own tail notice now we touch
84:25 - our own tail you see here snake touch
84:27 - and i spell touch with touch so snake
84:30 - touched tail you see we touched tail
84:32 - and bam
84:34 - we should die when we touch our tail but
84:37 - we will do that later on don't worry
84:39 - about that the point is that this all is
84:41 - working we can remove all of these
84:43 - fruits
84:44 - so let me select all of these fruits we
84:46 - can remove them
84:48 - we are only left to create our gameplay
84:51 - controller who is going to spawn all of
84:52 - these fruits in our level so on and so
84:55 - forth and also create audio effects but
84:58 - before we end this video i'm also going
85:01 - to create our ui quickly because our ui
85:04 - is not going to be that large so if i go
85:06 - here in our game
85:08 - our canvas is going to be set on screens
85:11 - play screen space overlay i'm going to
85:14 - scale it with screen size 180 by 720 and
85:18 - i'm going to match the width and height
85:20 - equally
85:21 - i'm going to take the image this is
85:22 - going to be our icon so snake icon
85:26 - and i'm going to set the
85:28 - anchor at the top middle i am going to
85:31 - set here for the source image this snake
85:34 - portrait or however we are going to call
85:37 - it
85:37 - the
85:38 - width and height is 8080 for this snake
85:41 - the position x is negative 99 and the
85:44 - position y is negative 5 8 like this
85:49 - and the next thing we are going to add
85:51 - our separators so i'm going to take here
85:54 - i'm going to actually rename this one as
85:56 - well ui canvas i'm going to hit here
85:58 - right click and ui text
86:00 - now this text is not going to be a child
86:03 - of our snake icon it is going to be a
86:06 - regular text i'm going to call it
86:08 - separator separator and i'm going to
86:10 - simply add this line to separate and we
86:13 - will see what we will separate
86:15 - i'm going to set the font at ariel
86:18 - and let me just resize it i'm going to
86:21 - set the anchor at the top middle
86:24 - the width is 29 and the height will be
86:27 - 135
86:29 - the position x will be negative 32 and
86:32 - the position y is negative 49.
86:36 - the scale or the font size is 103 and i
86:40 - am going to set the color to white and
86:43 - voila this is it
86:45 - and actually we can move it just a
86:48 - little bit down something like this yeah
86:50 - this can do so negative 62
86:54 - negative 62 can do and voila this is our
86:56 - separator
86:58 - now i named it separate torn it's
87:00 - separator
87:02 - and we're also going to create a score
87:04 - so here instead of separator i'm going
87:06 - to call it score now for the score top
87:09 - anchor the width is going to be 303 the
87:13 - height is going to be 83
87:16 - the position x is going to be 1 5 1 and
87:20 - the position y is going to be negative
87:23 - 60.
87:24 - and here i'm simply going to say score
87:27 - like this 0 and let me just find it
87:29 - where it is so where is my score where
87:31 - did i put it
87:33 - yeah here it is here is my score
87:36 - and let me just resize the font
87:39 - something like this so the font can be
87:41 - 50 here in this case i'm going to set
87:43 - the font at 50 and maybe just move the
87:45 - score a little bit down
87:47 - negative 72. so negative 72 for our
87:52 - score now the font for our score is
87:54 - going to be our open sun's regular open
87:57 - sun's regular here it is and voila that
88:01 - is practically that this is going to be
88:03 - our score or maybe just move a little
88:05 - bit up so negative 6 9 this works
88:08 - perfectly so this is our ui here is
88:10 - where we are going to keep track of the
88:12 - score this is our snake image this is
88:14 - the separator between the snake image
88:16 - and the score not that fancy because the
88:19 - point is not to create fancy ui the
88:22 - point is to create our snake game also
88:24 - make sure that you attached or dragged
88:26 - and dropped the bomb inside of our
88:30 - pickup so drag and drop the bomb and the
88:32 - fruit to make them prefabs
88:35 - let us wrap things up starting with our
88:38 - gameplay controller so in the scripts
88:40 - folder and helper scripts
88:43 - i am going to right click and create our
88:45 - gameplay controller like this and i am
88:48 - going to right click here in the
88:50 - hierarchy and create an empty game
88:52 - object
88:54 - which i'm going to name gameplay so it's
88:57 - gameplay
88:59 - controller so gameplay controller and
89:01 - i'm going to attach the script on the
89:03 - gameplay controller what do we need well
89:06 - as always we need a couple of variables
89:08 - to start with and
89:10 - let me do my thing so let me tag the
89:13 - class
89:14 - give a little bit of space
89:16 - the first thing we are going to make our
89:18 - gameplay controller an instance so
89:20 - public static
89:22 - gameplay controller instance like this
89:25 - and for our instance
89:28 - right here instead of our update i'm
89:30 - going to click create create make
89:33 - instance
89:34 - and inside of this one i'm simply going
89:36 - to say if instance is equal to null
89:40 - meaning it's not pointing anywhere i'm
89:42 - going to say instance is equal to this
89:45 - and voila we are good to go i'm also
89:48 - going to call this function in the awake
89:50 - function as always so this is nothing
89:53 - new we did this probably thousands of
89:56 - times so far
89:58 - before moving forward i am also going to
90:01 - type here using
90:03 - unityengine.ui because we need to get
90:05 - ourselves a reference to the text
90:08 - displaying the score to our user and we
90:12 - are going to display the score every
90:13 - time our snake eats a fruit
90:16 - so here we also need a public game
90:19 - object for our fruit pick up
90:23 - no this is not a pickup truck it's
90:25 - simply a fruit and we also have a bomb
90:28 - pick
90:29 - up like this
90:30 - now also we are going to have a private
90:33 - float this is going to be our minimum
90:35 - underscore x which is equal to negative
90:37 - 4.25 f
90:39 - we are also going to have maximum x
90:41 - which is equal to
90:43 - 4.25 f now the minimum is negative and
90:46 - the positive or the maximum is positive
90:50 - minimum y which is equal to negative
90:52 - 2.26
90:54 - f and positive or maximum y which is
90:58 - equal to 2.26 f
91:01 - and also our private
91:03 - float
91:05 - z
91:06 - underscore p o s which is equal to 5.8 f
91:11 - what is all of this here what did i just
91:14 - type am i going crazy or not well first
91:16 - of all
91:17 - we need to make sure that we are going
91:19 - to spawn
91:21 - our fruits and the bomb between our game
91:24 - objects here let me just find the level
91:26 - here it is so between when i said
91:28 - between our game objects i meant between
91:31 - here and here
91:33 - so as you can see this point let me just
91:36 - take it again so this point here is four
91:39 - point oh let me just find it it's
91:41 - negative 4.25
91:44 - so negative 4.25 which is somewhere
91:46 - around here and this one is positive
91:49 - 4.25 which is somewhere around here
91:52 - how did i find these values well i just
91:56 - did as you just saw i took this fruit or
92:00 - this eye and i positioned it here and
92:03 - saw which position that was then
92:05 - positioned it here and saw which
92:06 - position that was did the same thing for
92:09 - y axis and voila this is how i got them
92:13 - now our fruit and bomb in the scene we
92:14 - can remove them because we are going to
92:16 - drag and drop if i select the gameplay
92:18 - controller we will go in prefabs and
92:20 - pickups
92:22 - and we will drag and drop these from our
92:24 - prefab so fruit pickup will go here and
92:27 - bomb pick up will go right here
92:31 - so moving forward or going back here and
92:34 - z position is same as for all of our
92:36 - game objects you can see snake has z
92:39 - position 5.8 so does every other game
92:42 - object that we want it to be visible
92:46 - so moving forward we also need a private
92:48 - text which is going to be our score text
92:52 - and we need a private int which is our
92:54 - score count
92:57 - now inside of the start function we are
93:00 - going to say so void start
93:04 - and here we are going to say our score
93:06 - text is equal to game object
93:09 - find the game object with the name score
93:12 - get the component text from that game
93:14 - object
93:15 - like this and we are good to go now you
93:17 - need to make sure that the name of that
93:20 - game object is indeed score so in our ui
93:23 - here so ui canvas here it is score so
93:27 - make sure the names match up or
93:30 - otherwise this will not work
93:33 - now we are going to create functions
93:35 - that are going to start spawning our
93:40 - pickups be that a bomb or our fruit so
93:44 - first of all we are going to create an i
93:45 - enumerator a co routine as you might
93:49 - assumed and we're going to call it spawn
93:52 - pick ops like this so start spawning
93:55 - pickups and here we're going to say
93:56 - yield return new
93:59 - wait for seconds and we are going to
94:02 - wait from random dot range
94:06 - between 1f and 1.5 f so between one
94:09 - second and 1.5 of a second we're going
94:12 - to wait and then we will spawn
94:14 - either a fruit or a bomb and we're going
94:16 - to do that using a random value so if
94:20 - random range from 0 to 10
94:24 - is greater or equal to 2
94:27 - then we are going to instantiate a fruit
94:30 - so here we're going to say instantiate
94:33 - and we're going to pass here our fruit
94:35 - pickup at the position new vector 3 like
94:39 - this
94:40 - and for our x we're going to say
94:44 - random.range from minimum x to maximum x
94:48 - this is for the x position
94:51 - for the y position random dot range from
94:54 - maximum or minimum y to maximum y
94:59 - and
95:00 - our z position so zpos
95:03 - comma
95:04 - quaternion
95:06 - identity and we are good to go
95:09 - so let me just put quaternion identity
95:11 - right below here and voila we are good
95:13 - to go this is for spawning r and
95:17 - actually i'm also going to put new
95:18 - vector 3 right here
95:20 - and put this right here so it works
95:23 - perfectly like a charm so instantiate
95:26 - the fruit pickup on the random range
95:28 - between minimum x and the maximum x
95:31 - minimum y and the maximum y and i've
95:33 - explained this it will instantiate our
95:36 - game objects
95:39 - so i'm going to take it like this and
95:41 - zoom in on our level just a little bit
95:43 - something like this and i'm going to
95:45 - take the highlight tool just so that i
95:48 - can demonstrate that this is the minimum
95:50 - x and this is the maximum x value
95:52 - minimum or maximum y and this is the
95:55 - minimum y so between
95:58 - random range between minimum and maximum
96:00 - that's this range so between here so
96:02 - between these two values here it will
96:05 - spawn it on the x-axis and on the y-axis
96:07 - it will spawn them between these values
96:10 - as i explained a moment ago
96:12 - how are we in stenching or how did i get
96:15 - those random values
96:17 - so this is if random range is
96:20 - greater or equal to two because there is
96:22 - only twenty percent chance that we will
96:24 - spawn a bomb if that happens then here
96:27 - we are going to copy this line of code
96:29 - and here in the else statement instead
96:31 - of fruit pickup we are simply going to
96:33 - say bomb pickup and voila that is that
96:37 - but we need two more functions because
96:39 - here above we are going to create void
96:42 - start spawning like this so start
96:45 - spawning and here we're simply going to
96:48 - say start co routine and we are going to
96:50 - start our spawn pick up school routine
96:53 - which will start well this co routine
96:56 - but here inside of this co routine we
96:59 - are also going to call invoke and we are
97:02 - going to invoke this function like this
97:05 - so you see here we are invoking this
97:08 - function this one right here that will
97:10 - call our co routine and again over and
97:13 - over and over and over until we create
97:16 - here a public void
97:19 - spawning
97:22 - and in our cancel spawning we are simply
97:24 - going to cancel so cancel invoke passing
97:28 - here the start spawning invoke co
97:31 - routine that well we are going to cancel
97:36 - and when we start our game right here in
97:40 - the start function we are going to spawn
97:42 - it after 0.5
97:44 - seconds so 0.5 of a second and we will
97:47 - start
97:48 - spawning and spawning and spawning now
97:50 - before we test this out and see if this
97:53 - actually works and it will work we are
97:56 - going to go here
97:58 - and we're going to create a public void
98:00 - increase so increase score
98:04 - and here simply we're going to say score
98:06 - count plus plus and our score text dot
98:10 - text is equal to score column
98:13 - plus
98:15 - score count
98:17 - and this right here will be called
98:19 - inside of our snake so when we go in our
98:21 - player controller when we pick up a
98:23 - fruit you see here we are going to call
98:25 - our gameplay controller so gameplay
98:28 - controller that instance that increase
98:31 - score just like that so simply call it
98:34 - to increase the score and by the way
98:37 - notice here if i go and run our game i'm
98:40 - going to hit the play button
98:42 - so now after 0.5 of a second you see
98:45 - here we have a bomb we have a fruit so
98:47 - here i'm going to pick up a fruit
98:49 - another bomb fruit right here let me try
98:52 - to pick it up so fruit here now one
98:54 - thing that you are probably noticing is
98:57 - that these game objects are staying in
99:00 - the scene they are not being deactivated
99:02 - until we pick them up or until we touch
99:04 - the bomb and eventually we will run out
99:07 - of places where we can
99:09 - walk or move because of the bomb now
99:12 - because of that we need to go in our
99:14 - scripts and here i'm going to create a
99:17 - new folder for our pick up
99:20 - scripts
99:22 - and simply here i'm going to create the
99:24 - activate pickup so
99:26 - c-sharp script deactivate
99:29 - pick up
99:31 - inside of this script we are simply
99:33 - going to create two functions or
99:36 - actually one function called void
99:39 - the activate
99:41 - which is going to do what game object
99:44 - set active
99:46 - so that
99:47 - set not gameplay controller game object
99:50 - and this is what i hate
99:52 - so visual studio crashed on me for some
99:55 - reason so we need to wait for it to
99:59 - reload again when this happens i simply
100:01 - close visual studio this happens also
100:04 - with mono develop i hate it when this
100:07 - happens it simply freezes it will not
100:10 - take into consideration
100:12 - mono behavior monodevelop whatever but
100:15 - now it works because now you see i can
100:17 - call our game object set active is false
100:21 - and in the start i am going to invoke
100:24 - our deactivate
100:27 - after random range so random dot range
100:30 - between three seconds and six seconds so
100:34 - between three seconds and six seconds we
100:36 - are going to
100:38 - deactivate our game objects now as we
100:43 - did or did we go here in our gameplay
100:45 - controller and we called here increase
100:47 - score actually i did not
100:49 - even tested that out i didn't did not
100:51 - see we were looking at our fruits but
100:54 - pay attention now so pay attention to
100:56 - the score when you start picking out
100:57 - fruity c score is now one
101:00 - and let us try to pick this up and now
101:03 - score is two and again our fruits and
101:06 - our bombs are not being deactivated
101:09 - because silly me
101:11 - select them right here in the prefabs
101:13 - and attach the deactivate pick up script
101:17 - so if i hit the play button now
101:20 - and pay attention to the score again so
101:22 - when we start picking up roots we will
101:25 - start also counting the score so now
101:28 - score is one score is two and you see
101:32 - the fruits are disappearing i almost cut
101:34 - that one on did i cut this one i think i
101:37 - did okay this one i missed
101:39 - four okay this one i missed
101:42 - five and you see it is working so we are
101:46 - counting the score everything is going
101:48 - perfectly well
101:50 - what we need to do now is actually stop
101:53 - the game when we hit one of these so
101:55 - either wall bomb or tail so when we hit
101:59 - one of these we simply what are what we
102:02 - are going to do is we are going to say
102:03 - time not tone but time that time skill
102:07 - is zero
102:08 - we are going to stop our game then you
102:10 - can restart the game by using your code
102:13 - or either press the button and restart
102:14 - it because i'm not gonna go
102:16 - we did this already in mary's of times
102:18 - restarting the game we created menus i
102:21 - do this extensively in
102:24 - the ultimate game development academy so
102:27 - you have all of the resources you need
102:30 - to create your own mechanism for
102:32 - restarting the game so on and so forth
102:35 - because what i'm going to do now is go
102:38 - in unity
102:39 - and i'm going to hit here or double
102:42 - click and create an audio manager script
102:46 - and going back in our scripts folder
102:50 - and helper scripts right click i am
102:52 - going to create a c sharp script which
102:54 - i'm going to call audio manager
102:58 - and attach it on the audio manager game
103:02 - object so simply drag and drop it on the
103:04 - audio manager and what do we have in our
103:07 - audio manager well first of all let me
103:09 - just tag the class give a little bit of
103:11 - space
103:12 - we are also going to make him an
103:14 - instance so we are going to say here
103:16 - public
103:18 - static
103:19 - audio manager instance instance like
103:23 - this
103:24 - and here we are simply going to create
103:27 - void make instance
103:31 - so if instance is equal to null
103:34 - we're simply going to say instance is
103:36 - equal to this
103:38 - in our awake function we are going to
103:40 - call make instance and that is that
103:44 - this is for our instance and we are also
103:46 - going to have our public audio clip for
103:49 - our pick up
103:51 - sound and for our dead
103:53 - sound
103:54 - and for these two we are simply going to
103:56 - have a public void play
103:59 - why are you correcting me so public void
104:04 - play
104:05 - underscore
104:06 - pick up
104:08 - sound like this and we are going to call
104:11 - here audio source
104:13 - play clip it point the clip is pick up
104:17 - sound at point transform that position
104:21 - and i'm going to duplicate it paste it
104:24 - here this is going to be play
104:26 - dead sound
104:28 - and simply here instead of the pickup
104:30 - sound we are going to paste our
104:32 - dead sound and it's simple like that and
104:36 - for our sounds
104:38 - go in the audio manager
104:40 - and for our pickup
104:42 - so pick up sound is going to be our eat
104:45 - fruit sound and for our dead sound we
104:48 - are going to have game over sound too so
104:51 - game over sound number two this is what
104:54 - we have for our sounds
104:57 - moving back in our script for the player
105:00 - controller here when we increase the
105:02 - score we are also going to call our
105:04 - audio manager dot instance to play the
105:06 - pickup sound
105:08 - and here we are going to call our
105:10 - audiomanager.instance
105:13 - to play the dead sound
105:16 - practically we are done with our game
105:20 - if i go back here and i'm going to pump
105:23 - up the volume so that we can hear the
105:25 - sounds so now when we pick up our fruit
105:28 - pay attention let me just try to pick
105:30 - one of these up
105:32 - it's like an eating eating sound you see
105:34 - i had to stop there because i was about
105:36 - to pick up a fruit and again
105:39 - and again and again and we can pick them
105:42 - up and notice when i hit the wall
105:45 - the game is stopped
105:47 - we don't spawn anything anymore you can
105:50 - we did create here a function in our
105:52 - gameplay controller so we created this
105:53 - to cancel our spawning we did not call
105:56 - it because we're using here time scale
105:58 - in our gameplay controller when the time
106:00 - scale is set to zero instantiate will
106:02 - not work but if you want to implement
106:05 - something else you can call cancel
106:06 - invoke you can stop the game with the
106:08 - boolean whatever you
106:10 - choose and that is that basically so in
106:14 - our gameplay controller we did nothing
106:16 - new we just created here our instance we
106:20 - attached our pickup prefabs i've
106:22 - explained how i got these values this is
106:26 - the text for the score and the score
106:28 - count here we simply have a co routine
106:30 - that based on the random value will
106:33 - either
106:34 - spawn a fruit or spawn a bomb
106:37 - invoke spawning which will call this
106:39 - function again to start the same co
106:41 - routine increasing the score here for
106:44 - our audio manager simply playing the
106:46 - pickup sounds and the dead sound by
106:48 - using play clip at point
106:50 - we created also a script to deactivate
106:53 - our pickups after three or six or
106:56 - between three and six seconds
106:58 - here for our player controller simply we
107:01 - called those functions
107:03 - to
107:04 - play the sounds and to display the score
107:08 - and we explained everything else in the
107:09 - previous videos so again i'm going to
107:12 - hit the play button so that we can see
107:14 - this in action one more time so here is
107:16 - one of our pickups i'm going to try to
107:18 - die this time by eating or touching my
107:20 - own tail so i've ate this come on come
107:23 - on come on
107:24 - this and this and this this also oh i
107:27 - missed that one
107:29 - yeah i died now you see here you see how
107:32 - he died we should have passed this here
107:34 - the reason for this is because my
107:36 - collider for my eyeball or this one the
107:40 - dude the first the snake's head is too
107:42 - large you can resize it so the radius is
107:45 - set at one
107:47 - or actually for this snake this dude
107:49 - right here excuse me so the radius is
107:52 - set at 0.11 you can resize it let me
107:55 - just go in the scene and search for the
107:57 - snake you can resize it to something
107:59 - like
108:01 - 0.09
108:04 - which is smaller so if i hit the play
108:07 - button so now our
108:09 - collider is smaller we can still pick
108:11 - things up so we can eat here the fruit
108:13 - as you just saw so we can eat the fruit
108:16 - but when we try to pass our own tail
108:19 - then it will work because let me just
108:22 - try to make the snake a little bit
108:23 - bigger to demonstrate that so we ate
108:25 - this we ate this and let me just ate
108:28 - this or eat this as well
108:30 - and let me try it
108:32 - okay now it works you see now we are not
108:34 - dead by going right near our tail but we
108:38 - will be dead if i do this and bam we
108:41 - have died
108:43 - again this is our small 3d snake game
108:46 - this is how simple it is if you had this
108:49 - idea when the nokia phone came out
108:50 - probably we will be millionaires but hey
108:53 - we did not came with that idea first so
108:56 - just learned something from this
108:58 - tutorial in this game that we have
109:00 - created
109:01 - fi here here from awesomedudes.com i
109:03 - will see you guys in the next video

Cleaned transcript:

what is up guys fah here here from awesometoots.com let us now import the assets for our new game that we are going to create as you can see i have a brand new project this is a 3d project so when you create a new project check the check box or the radio button for 3d name your project save it in any location where you want to save it and create it here i only have the scenes folder with my gameplay scene which is this scene right here which is completely empty i did not import anything i was waiting for you to watch this video so now we are gonna go in our assets folder that you can download in the link below and select all of these assets so we have fonts materials models prefabs sounds and textures so drag and drop them right here inside of the project tab and of course we will need to wait for unity to take mercy upon us and import all of these assets so let us wait one moment more no no no no no no and finally they are here so in this video i'm going to set up our main or gameplay scene and we're going to do that by going inside of the prefabs folder and here we have our level and here it is i'm simply going to drag and drop it here in the hierarchy panel and voila this is our level i'm just gonna go here with my mouse and see it and this is our level now of course it looks like it's a little bit dark but now it's a little bit white again so i'm gonna go quickly inside of this lightning tab and i'm gonna uncheck this out to generate and the lightning tab is under window and then here you will see lightning and then you're gonna click on settings which will open this tab right here it will probably be floating for you let me try if i can make it float no apparently not here yeah finally so it will finally it will probably not finally be floating for you like this i dock it usually right next here to the inspector panel on my right side and when you select the lightning tab you're gonna go right here inside or the bottom of this lightning tab and you're gonna uncheck this auto generate now this auto generate notice here when i hover over it says automatically generates lighting data in the scene when any changes are made to the lighting system this means if we take this directional light and if i even change it a little bit so if i change the rotation from 50 to 71 it will rebake lightning it will try to simulate lightning and that takes time that's the reason why i have turned this off it will try to rebuild the lightning settings which will take a lot a lot of time for us and we will need to wait your computer will get hot so on and so forth that's why i am going to turn it off now we are going to duplicate this directional light but first of all for this light i'm going to set the rotation to 10 like this and it already looks pretty nice and the intensity i'm gonna set it at one we can set it 1.5 for example but one will do and i'm going to duplicate it so i'm going to quickly duplicate it here and this is directional light one and also for this one i'm gonna set the rotation for the yaxis at zero so the position x is zero position y is three z rotation is zero rotation x is ten y is zero and z is zero this is for our directional light one for our direction light two so this one right here i'm going to set the y rotation at 43 and do we want to set here point three for the intensity or something like this because now we're casting shadows here on the side and of course this all depends on the intensity it depends on the lighting i can also pump up the intensity which will be something like this which is something you use to kill vampires in your game anyways i'm not gonna go too much into lightning because it is a separate topic on its own i talk about this in the ultimate game development academy in a whole section with a brand project or brand new project so a separate project for talking about lighting demonstrating how lighting works so it's a separate topic for itself but here i've just used this directional light i can actually remove this one so we can leave it at one you can play with intensity if you want to but i will leave it at 1 and the rotation is perfect i have turned off the duplicate by the way and it looks nice it looks pretty nice if i go in the game this is how it looks like and by the way for the main camera here it is the zaxis is going to be zero the yaxis is going to be one something like this and also the far for clipping planes i'm going to set it at 10 something like this this what i did for the clipping planes it will simply if i pump it up pay attention to these parts right here let me just demonstrate which parts do i mean come on highlight tool where it is here it is you see this from camera this right here and this right here like what the camera is seeing so pay attention to that if i take my clipping place and place it far it means it will see as long as the camera is stretching you see as long as the camera is stretching we don't need that much we only need 10 to stretch the camera right here where our plane is or our game field is and this looks pretty nice this looks pretty nice i'm pretty satisfied with this so we're not gonna touch this anymore but we are going to go and create our snake and i am going to right click here and create an empty game object like this zero zero zero and this game object is going to be our snake so i'm going to name it snake now for our snake we need to filter for our mesh which is our eyeball mesh and here it is eyeball i know i'm using an eyeball for our snake but hey nobody's perfect so don't judge me and i am simply going to take this eyeball and put it here inside of our game and we already see it is casting shadows let me just clear this console and here it is this is our eyeball i'm going to take this one the the child one i'm going to remove this one which is the parent one and i'm going to put it as a child under our snake and let me just position so zero zero zero for our rotation i'm going to see here or set it negative nineteen so negative 90 0 for the y 180 for the z for our skill one one and one and by the way our snake here we need to set the z axis let me just 5.8 something like this for 5.8 so now it is visible and for our eyeball which is going to be the head of the snake so here i'm going to say head i'm going to set it to point 12.12 and i'm saying i'm going to set it to 0.12 but i'm setting the scale i did not set what i'm going to set i'm going to set the scale so select it and the scale is going to be 1.12 1.12 1.12 now this is for the head of our snake we are also going to duplicate the head and i'm going to put it here and this one is going to be our node one i'm going to name node and let me just move it right here and this node i'm going to say it's 0.1.1.1 it needs to be smaller than our head and let me just duplicate it one more time and i'm going to put one note as a child of our snake parent game object and this note i'm going to put it somewhere here something like this now the another the other node you can move it here let me just move it below so let me just put this one a little bit closer to our snake yeah this works pretty nice and the last one is going to be our tail so this is why i have removed this one or this one is going to be our tail and for the tail i'm quickly going to add a sphere collider and i'm going to attach a rigid body on it so attach a sphere collider on this game object this one that we named tail and attach a rigid body on it now uncheck this use gravity because we don't want to use gravity and duplicate it one more time i'm going to rename it to simply tail and put one of these as a child of our snake now let me just zoom in and for our tail here i'm going to set it at 0 0 and position it here something like this so we are going to position it to be as a tail of our snake and for this one we're going to save it in prefab so i'm going to go here and create a folder that i'm going to call snake and inside of the snake folder i'm going to drag and drop this tail and now we can safely remove it so tail can be removed and now this is our snake if i go in the gameplay scene you see this is our snake so the tail is here it has a sphere collider and a rigid body the node can also have or it needs to have a sphere collider but we can uncheck it for this node so for the second one the one after the head we don't need the sphere collider to be checked and the rigid body we are also going to add it and uncheck use gravity by the way for the tail also make sure that you check this is trigger and do the same thing for this tail right here check it to be a trigger the tail right here i meant the one that we dragged and dropped into the snake prefabs folder and for the snake's head which is this dude right here now for this one we are also going to attach a sphere collider so sphere collider make sure it is a trigger and i am also going to attach a rigid body and for this rigid body i'm going to uncheck use gravity because we do not need to use gravity for the rigid body which we will see later on we will demonstrate that when we start moving because we are going to move from our code and if we let gravity do the thing it will pull us down which is something that we don't want now for this sphere collider for the head we can actually also uncheck it so you can uncheck it because the top game object the top pair and this one the snake it will have a sphere collider and this sphere collider's radius is going to be 0.1 or actually it is going to be one and the center is going to be let's see where it is just quickly let me see where my sphere collider is so here it is yeah it is large actually i need to resize a little bit more going here moving our sphere collider yeah something like this i need to resize it more let's say 0.1 12 just so that i can see where it is you see this green line this is where our sphere collider is if i set it at zero i think this is perfect yeah point one or point one one is where we want the sphere collector to be i also i am going to make it a trigger i think this is okay let me just try to resize it a little bit soak it so that i can see where it is radius yeah 0.11 is for our radius of the sphere collider i'm also going to click on add component and attach a rigid body on this dude right here and i'm also going to uncheck this use gravity because we do not need it we don't need it and this is it this is preparation for our game we have the snake we have the level i'm gonna drag and drop the snake in the snake prefab folder so for the snake we have an empty parent top game object we also have the head which is this one right here or this one right here the top one or the largest part of the snake we have the no this one i just named node because it's the second body part of the snake and we have the tail so every next game object that we add because you know when we eat our fruit the game object or the snake will grow larger it's the same as on old nokia phones when you use that snake and you ate more and more the snake go grows larger and larger so all of those other objects that we're going to add so larger and larger objects are our tails so the tail needs to be named like this so that we can differentiate it we have the head we attach sphere colliders on all of them so the tail and the sphere collider for the tail needs to be checked it needs to work because we can collide with the tail you know the snake can kill itself if it touches itself so this is for the tail for the note it does not matter because we are not going to do that for the note which is the next part after the head head here it's also going to have a rigid body all of these game objects have a rigid body except for the head and the node the sphere collider must be turned off or we can also remove it and for the snake we have the sphere collider rigid body which is the top most game object and this is preparation for our snake moving forward with our game we have prepared our level we added our snake we added two directional lights we turned one off now you can turn it back on or turn it off this all depends on you however you want to do it you can also turn the first one or the second one off and probably pump up the intensity on the first one however you want to do it it's up to you so i'm not gonna touch that i will turn the second one on so both of them are turned on this is our snake in the middle of our screen and we need to start moving the snake in order to do that we need to go in our project tab and right click and create a new folder and this one is going to be our scripts folder and inside of this one right click and i'm going to create here folder for helper scripts now for our helper script the first script that we need to create is our script that's going to hold our tag so i'm going to name it tags and first of all right click create a c sharp script you are going to double click it and open it in visual studio mana develop whichever one you are using now since in our tags class as you already know or assume we will add tags and default variables that we are going to use throughout our game so i took the liberty to copy them simply here and now you can pause the video and simply paste them but before you do that i am going to explain what they are now here it's playerdirection.direction without n anyways the tags here will represent the tags so we have the walls so when we collide with them we will check if the collision happened with a game object that has a tag wall when we pick up a fruit we will check that with the tag as well so these are the tags for our game object and here we can say tail with small t or a i l i wrote it all caps and for our metrics so these are the metrics that we are going to use to position and move our nodes inside of our game or to move the snake we will see that do not worry about that and this is a public enumeration to determine if we are moving left up right down and this is the count eg or it will show us how many movements do we have so one two three and four so we have four movements now as you can see in our public enum we can say left is equal to zero up is equal to one right is equal to two so we can do that as well this is something that we did not do before so i am showing you that we can do it and why are we doing it like this because later on we will use these values so 0 1 2 and 3 to access indexes in our array so don't worry about that you can pause the video now and copy all of these tags metrics and player direction and now i i'm i am assuming that you have copied all of those and i'm gonna move forward and go in unity and in scripts i'm going to write click and create a new c sharp or actual new folder and this one is going to be our player scripts and inside of this folder i'm going to right click and create a c sharp script now this one is going to be our player controller this is the dude who needs to be attached on our snake so select the snake drag and drop our player controller just like this i'm going to double click it and open it here in visual studio let me just do my thing as always and this is going to be the script that's going to move the player we are going to create another separate script for getting input that means we will move the snake or the player left right up and down and for that we will use a separate script this script is the one that is going to move the player and of course we need here a couple of variables the first one is going to be our public player direction which i'm going to simply call direction and since it's public it will be visible in the inspector panel i am going to hide it in the inspector we don't need it to be visible in the inspector panel but we need it to be public next we also need here and hiding inspector public float step length which is going to be equal to 0.2 f now this is the movement interval so we are going to move our game objects or the snake by this movement in terrible so 0.2 now we don't want to move our snakes every frame that is 60 frames in a second so we don't want to move it every frame so we need a movement frequency so here i'm going to say public float movement frequency like this which is going to be equal to 0.1 and i'm also going to hide this bad boy in the inspector now you see we're going to move our snake every 0.1 of a second instead of moving it every single time or 60 times in a second that's why we need this movement frequency now we also need a private game object which is going to be our node prefab or actually our tail prefab so you can name it tail you can name it node however you want it it is private it will be only accessible here but we need to make it serializable or serializable or serialize field because we want to drag and drop our tail if we go back here in unity and notice here in the inspector we will see an empty field to drag and drop this game object for in it is located in the prefabs and snake select here the snake and drag and drop the tail right here i'm also going to hit apply to make changes to this prefab now this is why we need to make it a serialized field because we want it to be private but still we need to drag and drop that game object inside now we also need to store the next position displacement based on player direction and for that we are going to use a private list of vector 3's which we are going to call delta position this is where we are going to store the previous movement of our player don't worry we will see everything in action we also need a private list of rigid bodies which i'm going to call notes and this is going to be every single separate node inside of the snake's body that is snake's head and snake's tails so on and so forth we also need a private vector three and for this one fruit note actually we don't need this one so we are not going to use this one but we are going to use a private rigid body for main body a private rigid body for the head body and a private transform tr for our own transform store tr not transform we also need a private float counter and a private bull move now this counter we will use it with the movement frequency to allow the player to move and we can put these two right here so that they are put with the appropriate or right below the appropriate variable that will accompany them later on and the last variable that we need is a private bool create node at tail this will tell us do we need to create a node at our tail that is when we eat a fruit do we need to create a note or not now instead of me explaining all of these variables one by one what they are i will demonstrate that so in the awake so i'm going to change start to awake in the awake the first thing that we are going to do is we are going to say our tr is equal to our transform tr is this one right here so we're going to get it with our or our transform is equal to tr next thing our main body is going to be equal to get component and get the rigid body component from our player and that is the top head or the top main body of the snake so the top parent which is the empty game object so this one right here that we currently have selected in the hierarchy we have that one selected that is the or the one that we are getting its rigid body by using get component the next thing that we need to do is we need to call here init snake nodes now this is a function that we still did not create and right below that function we are also going to call init player and this is also a function that we still did not create now let us go and create that right below the update we're going to create void init snake nodes now in this one we are going to initialize the nodes that means every single separate part of the snake as you can see if i go inside of the scene view you see we need to get all of these notes so we need to get the head of the snake so this one we also need to get this node the middle one and the tail one so we need to get all three of these so here in our init snake nodes we're going to say nodes which is our array of rigid bodies or a list you see here of rigid bodies and we are going to make it a new list of rigid bodies and below here we're going to say nodes.add to add to that list and we're going to say tr which is our transform get child and we're going to get the child that's at the zero index dot get component so it's get component rigid body component just like this close parentheses and we're good to go copy paste copy paste and we're going to say child one and child two and what is going on here now before i explain the last thing that we need to do is our head body is equal to nodes and the element that's at index number zero what is going on here you see here we are using tr which is our transform you see here our tr is the transform get child and we are getting the child what does this mean you see our transform the topmost transform from our snake it has children so we have the node or the head the node in the tail and we know that or the transform knows that we have children assigned to it so we can use or access those children's by using indexes so you can say get child 0 which means it will get the first child or the child that's at element 0 which is in our case head get child one in our case it's the node get child two in our case it is the tail and here notice the head body it is the rigid body of the head snake so the rigid body of the head snake and we know the head is set at index number zero which i explained a moment ago now in order to initialize our player so right here below we are going to create init player simply here we are going to make sure where our player is moving left right or up or down so switch so we're going to use switch and we're going to use direction and we are going to use cases in our switching case so we're going to have case player direction right and here we're going to use break i'm going to copy this and paste it so we are going to have direction left up and down and here i'm going to simply say down so based on the direction we are going to position all of our nodes or shift them to that position so if we need to or if our starting position is the right position we're going to do this so we're going to say nodes and the element that's at index 1 that position is going to be equal to nodes and the element that's at index 0 minus nu vector 3 and here for our x we are going to say metrics dot node and 0f0f and for our for our nodes number two or the element that's a number two and by the way here we need to say node zero that position so the position of our node zero and by the way inside of our nodes we are adding rigid bodies so when we say position we are getting the position of the rigid body you see here when i hover over it says the position of the rigid body so we're getting the position of the rigid body and here we're going to say nodes and the element that's at index 2 now we're going to say that position is equal to and we're going to use nodes an element that's at 0 that position minus nu vector 3 and for our metrics so we are going to say metrics dot node and we're going to multiply that by two and zero f zero f what is going on well when we start our game to the right we need to shift the positions of our game objects to the right side and in order to do that we need to get the node 0 which is the head what we need to do essentially if we are starting to the right side that means when we start our game that means when we start our game we will start moving to this side what we need to do we need to shift the position of this node over here and this node over here because then we are going to move to the right or actually to the left side excuse me i'm moving to the left but assume that i said left so if we are moving to the left side we shift their positions to the right side by using plus now let me demonstrate that so i'm going to move them back here and notice here if we are going to move to the left side i'm simply going to copy these lines of code and paste them here instead of typing here minus we're going to say plus you see here we are doing the same thing except here we are doing that with the plus sign so let me go back here and demonstrate that with the left position if we need to start moving to the left position with our snake that means we are going to this side and we know that the head so this bad boy over here he needs to be at the top so he needs to be the leading node in our snake in order to do that we need to shift this node over here and we need to shift this node over here and this is exactly what we are doing right here so if we need to move to the left side use the node that's at element one and use the element zero node which is the head and add to its position the metrics node which is the displacement that we saw here this is the displacement of our nodes so this is how far away they are from each other and do the same thing for our second node essentially this code right here is going to position these nodes relative to the node 0 meaning and let me just go back here meaning our head is the relative position so our node here this code right here is going to move this node over here and this code right here is going to move this tail node over here this is what we are doing essentially now we are going to do or everything that we explained here for the left side applies to the right side except well the right side is opposite to the left for our up side we are going to do the same thing except for the y axis so for the y side we are going to say minus but our metrics node is going to be on the y so zero for the zero f for x and we are going to move that one on the y and same thing here so we're just going to take this and zero f for the x and for the y matrix node multiplied by 2 y multiplied by 2 because our node at second position is our tail node so we need to multiply that by 2 because our head is here our node is here we need to multiply this by two so one head is one node is two and multiply that by two moving that right over here this is why we are multiplying with two for our down position simply copy this code from the up position paste it here and for the down we're going to say plus like this and voila we are good to go now of course we need to create one more function so right here above our init player we're going to create void set direction random and here we're going to say in direction random or die d i r random is going to be equal to random dot range from zero up to and we need to say here int and we're going to say player direction dot count to convert the count to an integer because if we use it like this without casting it to an integer and we go back in unity we will see here best of overloaded method match for random rage float float we need to put this into a float or an integer so i'm going to use it like this because our count if you remember has a value of 4 but this is an enumeration and we can cast this enumeration to an integer i've talked this already once in one of my tutorials can't remember which one but anyways we can cast it into an integer because as i said the value is four so the direction random will be based on random range and notice here we are casting this value to an integer and simply here we're going to say direction is going to be equal to d i r random now same way as we can cast these enums to an integer we can use enumerations to cast integers to enums so we can see here player direction now based here on the random value let's say random value is equal to one so this d i r int or d i r random value will have a value of one when we convert that into our into our enumeration player direction and we go back here the value one is up it will be the same if the value is two so value two is right if the value is let's say three then the direction will be down now we do need to call this right here so set direction random we need to call it right above our switch in case statement so we need to call it right there and we need to go back here and we can unposit or uncomment almost said on position we can uncomment these functions now now pay attention if we go back here i am going to clear the console and we go here in our game pay attention how the snake is positioned snake has been positioned with right direction in mind so it looks like it's going to start moving this direction notice now when we run the game so i'm going to hit the play button you see now it is positioned like it is going to go downwards you see and if i remove or stop the game and play it again you see now it is positioned again to the right side stop and rerun the game it will be positioned now you see like it is going upwards so this is how we are moving these nodes relative to the head node this is how are we positioning these nodes by using these lines of code right here now we are still still not done here with the awake function we need to create our delta position or which to go or position in which where we are going so our delta position is going to be equal to new list of vector threes like this open close these curly brackets and here i'm going to pass a new vector three and here i'm going to say comma now for the x i'm going to say negative step length comma zero f for the y i'm going to copy this and paste it below and here i'm going to say zero f first so zero f and here i am going to say step length comma here paste this one right here now here we are going to have positive step length and i'm going to copy this and paste it here now another comma here remove this comma and here we're going to have the negative length now right here i am going to add comments and here we need to end this statement with our semicolon so i'm going to add comments here like this so this one is going to be our negative dx or going to the left side here i'm going to put it like this this one is going to be our d y or going to the up direction right here i am going to say this one is going to be dx or going to the right side and this one and let me just move all of these by one and this one is going to be our negative d y or this means going to the down direction so you see here this step length this one right here is actually the value or we are going to move by that value so this is the time interval that value when we move we will move by 0.2 units this is what i'm trying to say so when we have this right here this means negative d y we're going to the left side or negative x so to say here we have the positive y meaning up here we have the positive x meaning right and here we have the negative y going down and you see here negative y positive x positive y negative x so this position right here means we're going to the left up right and this one is going down now in order for us to actually move we need to create a function that is going to move us but before that we also need to create a function here we need to create a function that is avoid check movement frequency and for this function we are going to say here our counter so counter plus equals time dot delta time we know the time that delta time is the difference between every frame so it's the time it takes from one frame to go to another frame and we're going to say here if our counter is greater or equal to movement frequency what we are going to do we are going to say our counter is equal to zero to start counting from zero again and here we are going to say move is equal to true to allow our game object to move now in order to make it move we are going to say here void move or create a function that is going to allow us to move and not on animator move no simply void move and inside of this function we are going to create here a vector3 d position this is the delta position we're going to use here delta position so it's actually delta position and we are going to use that by using here an int and we are going to pass here the direction so the delta position or deposition is our delta position we are casting the integer or direction to an integer to get it as an index so depending on the index if we are going to the left side for example if we're going to the left side index will be zero meaning we will access element that's at index zero in the dental in the delta position and if we go here in the delta position element that's at index zero is left as you can see right here so now that we have our delta position what is the next thing to do first of all we are going to create here a vector 3 parent pos of parent position head body dot position and right below here we're going to create a vector 3 prev position or the previous position and below here we are going to say main body that position is equal to main body position plus d position right below we're going to say head body that position is equal to head body dot position plus the position again now we are also going to move all the snake nodes so we're going to say for int i which is equal to one as long as one or i is less than nodes dot count our i is going to be plus plus and we are simply going to see here previous position is equal to nodes element that's an index i that position storing the previous position nodes and element that's at index i that position is equal to parent position and parent position is now equal to previous position now don't worry if i'm not explaining everything in detail right now because we will test it out soon do not worry after we do all of this we need to check if we need to not trigger its check if we need to create a new node because we ate a fruit we will do that later on and for that we're simply going to say if create node at tail then we are going to write the code to do that for us now practically we are done for now and we can test it out by going here in the update function we are going to call check movement frequency which is this one right here come on go down this is check movement frequency in the update we're going to calculate our counter by adding to it delta time and if the counter is greater or equal to movement frequency then we will allow the movement and in the fixed update right below here so void fixed update and let me just remove this private because i like it to be void simply and in our fixed update we're going to check if move so if we can move then move is equal to false and we're going to call the function move not fog mode move like this thank you like this so in the update function we are checking for the frequency so counter plus equals time that delta time if the counter is greater or equal to the movement frequency then we are going to say counter is zero so that we can count from the beginning from zero and move is equal to true in the fixed update if move is equal to true move will be false and move the snake by one increment and in the move here this is where we are going to move the snake now in order to test that and see it in action i am going to go back here in unity and run the game and we are going to see the movement of the snake and then we will go and break it down line by line so when i hit the play button pay attention to the snake you see snake is moving by one increment it is gone we cannot control the snake notice now if i hit the play button now snake is going downwards just a moment ago first time when we tested out snake was moving upwards i'm going to hit the play button again hopefully it will move left or right and now again it is moving down or up come on try to move left or right just for once okay now it is moving to the left side and you can test it out as long as you don't see it moving left right up and down but this definitely works we see it now let me try one more time hopefully it will go to the right side no anyways let's go break it down line by line so these here are now getting a clear picture or we are understanding for what we are using this direction is going to determine in which direction our snake is going to go step length is the frequency or the units measurement unit by how much units we are going to move every node that is 0.2 units movement frequency is the how many times we can move in a second so every point one of a second we can move counter is used to test that out so we are adding to our counter the delta time we know that is the it's a very small number so the difference or the time it takes from one frame to go to another frame so that's a very small number and when that counter value is greater or equal to the movement frequency which is this value right here then we will allow our snake to move so counter is reset back to zero and move is equal to true and moving forward this is our tail prefab which we'll use later on when we eat a fruit or when the snake eats the fruit we will add to the snake so it's get it gets larger and larger this is the delta position and you see here delta position is the direction where we are going is it left is it up right or down and we're using that by well using the step length and these values right here you see here the negative step length is negative x meaning we're going to the left side positive y that means up and positive step linked that means going to the right side the negative y means we're going down now here are the nodes that we are going to get when we initialize the snake basically these are the rigid bodies of every part of the snake so the head the node in every part of the tail so we can have 20 tails when we eat 20 fruits every single one of those tails is going to be added to this node array you see here we're using the transform to get the childs so we are getting the child at index zero one and two child at zero index or at zero index is our head so we are doing or assigning that right here and moving back here we have the main body head and the transform so the main body is our main body or the top parent or the parent of all game objects so this one right here the snake that's the main body our tr is the transform and here we are initializing the snake notes by getting the rigid bodies from every child next we are initializing the player that means we are setting the direction the initial direction of the movement of the snake we're doing that with this function which is this one right here so you're using a random range from zero and direction dot count so player direction count we are casting that to an integer because the value here of the count is equal to four as you can see here count is equal to four so when we cast it to an integer it will display that value so it will display four which means a random range from zero or between zero and four and when we get that random range let's say that number is three we will cast it back to player direction so if the value is three three is down if the value is for example 2 then 2 is right and you get the picture so we are assigning that to the direction now when we do that in this function based on which direction we have is it right left up or down we will displace these nodes and we saw that we have previewed that so let's say for example if the initial position is moving to the left side if i hit here pause and i'm going to zoom in on our snake i'm going to hit the play button you see here the initial direction was left side which means both of these nodes this one here and this one here shifted to the right side by using these lines of code so using the head position of our snake as orientation and we're adding to that position this value here now metrics node is this one right here this is the increment or the stepped length this is the same as step length and for our second node we need to multiply that by two because we need to also place it after our middle node because we have three nodes same applies for right up and down now moving forward here we have our check movement frequency we have explained this so we are adding to the counter delta time when the counter is greater or equal to the movement frequency reset counter move is equal to true this happens in the update function in the move function we are getting the delta position meaning the direction where we are moving so we are moving by using delta position which is our array that we create right here and we are casting to an integer the direction if the direction is for example or the value of the direction is 2 that means we are moving to the right side next we are getting the parent position which is our head body position and we are storing the previous position now first we need to start moving the main body which is the main body of our snake the top parent holding all nodes and we're going to move it by using or setting its position to be equal to its current position plus the delta position or the direction where we are going so the direction position we're doing the same thing with the head body so head body's position is equal to head body's current position plus the direction where we are going now depending on if we are going to the left we are going to plus and the value for the left let me just see here the value for the left is the negative step length and 0 for the y so it will move it to that direction now we have to move all of our nodes we moved our head already that's why in i is equal to 1 because here if you paid attention the element or the first node is the node at element 0 which is our head node and we already set the head body or the head node we moved it so now what we need to do is move all other nodes that's why i starts at one and not at zero and we're going to move how many nodes we have if we have 100 nodes then we're going to use count which will be 100 so we will move 100 nodes now the previous position and we are getting that by using the node at the current i index in its current position this is the previous position the new position for that node is the parent position so the parent position that we had here for our head and now the parent position is equal to the previous position because the next node will be repositioned by using that same position and the outcome for that is if we go in our unity and if we hit the play button you will see how our snake is moving come on unity please have mercy upon us so if i hit the play button again you will see that the snake will move in the increment or using incremented values or if we go here the step length that is this is how many units it will use to two moves moving forward with our game we have the snake moving and it is moving in a certain direction the problem is that we cannot control that we cannot control the movement of the snake when the game starts so when we press any button we will not change the direction of the snake so in order to fix that inside of our player scripts folder we need to right click and create a new c sharp script which we are going to call player player input and this script we need to attach on our snake right here so drag and drop our player input hit apply so that this change applies to the prefab and double click it and open it in visual studio man i miss saying open it in mono develop but hey people change so now i'm using visual studio i have changed anyways moving forward what do we need for our player input the first thing is our player controller so we need a private player controller that we are going to call player controller of course this is because we need to inform the player controller that we change the direction where the snake needs to move now we are also going to create a private int horizontal which by default is equal to zero and vertical which by default is equal to zero as well we also need to create a public enumerations of public enum that i'm going to call axes and you can assume which axes do we have so we have horizontal and we have vertical because well we have two axes now inside of our start function we can get our player controller so player controller is equal to get component get component player controller component like this and this can be done in the awake function as well so you can choose to put this in the awake if you want to we can leave it at awake because we are only getting here our player controller because i like to initialize my variables in the awake function more than i like to initialize them in the start function now inside of the update the first thing that we need to do is that we need to get our player input but before that we need to say horizontal is equal to zero and vertical is equal to zero to reset their values and now in order to get that input we need to call a function that we did not create and i'm going to call it get keyboard input like this and right below here we're going to create it by typing void in the name of the function which is get keyboard input and now inside of our keyboard input we're simply going to say horizontal is equal to and we need to say input dot get axis raw and here we are going to say horizontal and for our vertical we are going to say vertical is equal to input dot get axis or raw and it is going to be vertical but we have an error what is this error if i hover over it says cannot implicitly convert type float to an integer the problem is that this returns a float you see this right here this input get axis raw returns a float so we need to cast it to an integer by typing in parentheses in in front of it and the same thing we need to do it right here so we are casting or converting this float into an integer so we have here our horizontal and vertical we do need to test if our horizontal is not equal to null then we need to say our vertical so vertical is going to be equal to zero like this and why do we why did we type this here well if we move horizontal we need to set vertical at zero and this is to prevent double movement so just to prevent double movement this is why we are doing it like this now in order to test this out we need to create a function that we well still did not create and this function let me just type this out here i remove this curly bracket now right below our get keyboard input we need to create void set movement and inside of our set movement we are going to move our game object but we are going to do it or call it right here right below our get keyboard input now inside of our set movement here we are going to say if our vertical is not equal to zero then we are going to call our player controller to change the movement but in order to change that movement we need to go here in our player controller right below our check movement frequency we need to create a public void set input direction which takes a player direction dir as a parameter now first of all in this function we need to prevent movement in the opposite direction what does that mean it means that if we are moving up we cannot start moving down we cannot start moving down or if we are moving left we cannot start to move to the right side and vice versa so we need to say here if our dir is equal to player direction up and our direction is equal to player direction down or if our dir is equal to player direction dot down and our direction is equal to player direction up you you see my point because we cannot move in the opposite side because if the let me quickly go here in unity and if i take my snake in the scene let's assume snake is moving in the right side like this we cannot press left and it will start moving left now we cannot do that we need to start moving up and then move left or down and then move left this is my point that's why we are testing this and we need to say here as well if d i r is equal to player direction dot right and direction is equal to player direction dot left or if d i r is equal to player direction dot left and direction is equal to player direction right so if this is true if some of these is true then we're going to hit return not a rect transformer whatever that was if one of these is true and notice we are using or so only one of these needs to be true so if direction is equal to or d i r is equal to up and d i r is the parameter so if d i r is equal to up and direction is equal to down then that is true we cannot move to the opposite side same thing goes for down and up right and left left and right but if this right here is not true then we are simply going to say direction is equal to d i r now direction is our own variable that we are using here let me just find it here it is our direction we talked about it in the previous video so direction is equal to the parameter that we put here now we also need to force move so we need to see here force move our game object or our snake now our force move we're going to create it so force move and simply in our force move we are going to say counter is equal to zero move is equal to false and move call our function to move the snake immediately without waiting for the next movement frequency threshold why well because when we press the button we want to move the snake right away we don't want to wait for the movement frequency threshold to kick in so that we can actually start moving the snake so right away when we press the button and this is what we are doing here so we are resetting the counter move is equal to false and we will call move to right to move the snake right away now going back to our set movement now if our vertical is not equal to zero we are going to say player controller dot set input direction and here we are going to test if our vertical is equal to one question mark then we are going to say player direction dot up colon player direction dot down what are we doing here what is going on well you see here we are testing if vertical is equal to null this essentially this code right here and let me just take this code so this code right here that we did and let me just put it right here so that we can actually see it this is what we are doing pay attention here so if our vertical is equal to one and we are using or questioning that or asking that with a question mark so if it's equal to one and that is true then the value will be up otherwise the value will be down this is essentially if as if we are doing this let me just put like this and this is essentially the same as if we typed if vertical is equal to 1 then our player direction is equal to player direction up so player direction up else if vertical is not equal to one then player direction dot down this is what we are asking with this right here so if the vertical's value is equal to one then we will set direction up which is logical because vertical that means that we will go upwards on the yaxis if and just go back what why is it taking me over there anyways otherwise if our vertical is not equal to one this is for this we are using this column so if it's not equal to one and let me just go back here so if it's not equal to one that means that we will use direction down for the value meaning we will go down now here we are going to say else if so else if our horizontal is not equal to zero we're going to do the same thing so we're going to say player controller playercontroller.set input direction and here we're going to say horizontal is it equal to one question mark and right here we're going to say playerdirection.right colon playerdirection.left it's the same thing except for our horizontal so it's exactly the same thing now we can test this out but we will have one problem and we will see what that problem is so if i go back here i am going to clear the console and i'm going to hit the play button and notice now we can change the direction see we can change the direction but you see the snake is moving like crazy as long as if we are holding our mouse or actually our keyboard i'm pressing w key asd or left arrow right arrow up you see the snake is moving like crazy like some crazy parasite that came from out of earth you know alien parasite and it's trying to get into you now we don't want this we don't want this kind of movement we have this movement because we are using input get axis raw now this is not something that we want so i'm going to comment this out we need to create another function that will get us the movement of the snake now here we're going to create a function that will return an integer and we're going to call it get access raw which takes an axis and i'm going to call it axis as a parameter and it takes this axis that we created this enumeration right here now right at the bottom of this function we are going to return zero if nothing happens because we need to return an integer but what we are going to do here is that we are going to test if our axis is equal to dot horizontal so we need to check for the horizontal axis then we're going to say bull left is equal to input dot get key down did we press a key down and that is going to be key code key code dot left arrow and ball right is going to be input dot get key down and this is going to be key code dot right arrow like this so we are going to get here the boolean for the left and the right now you can do the same thing for our w asd i'm using here arrows so pay attention because we will use arrows left arrow right up and down arrow on your keyboard to move our snake now you can do the same thing for w key asd and to move that that snake with those keys so here i'm going to say if left meaning if we pressed the left arrow key then here we are going to say return return negative one because we are moving to the left side if right then we press the right arrow key we are going to say return one like this otherwise we are going to say return no like this else if so else if our axes is equal to x is that vertical so we need to check for the vertical axis then we're going to say ball up is equal to input dot get key down and we are testing for key code so get key down and it's key code dot up arrow our ball down is equal to input dot get key down and key code.down arrow and same thing so we need to test it like this so we need to say here if up so if up we pressed the up arrow key we are going to return one if down then we are going to return negative one so return minus one otherwise return zero or return null i'm saying null for zero but actually it's return zero so this is what we are doing and let's go inside of our keyboard input and right here our horizontal is going to be equal to get access raw passing here access dot horizontal our vertical is going to be equal to get access raw passing our access dot vertical so it's vertical like this voila so if we go back now in our unity and if i press the play button and notice now if i try to move you see the snake i'm holding the up button so i'm holding these buttons that i'm pressing for the snake to move but the snake is not moving like crazy like you did a moment ago and notice here pay attention now you see the snake is moving and let me just go and demonstrate this so in our player controller if i uncomment or actually comment these lines of code out you will see how this helps us preventing the snake's movement so pay attention now if the snake is moving you see now we cannot move it like this you see it's moving to the left and now we're changing it to move it to the right or now down and now it's moving up you see we cannot move it like this we cannot move the snake like this because the snake then will hit itself and it will die because remember if the snake or in the snake game on old nokia phones or any snake game when the snake hits its own tail it is that gone kaput bam wow however you want to call it anyways it is dead the game is over so that's why we are preventing the movement in the opposite direction because now if i am moving for example to the left side i cannot press right to move so i'm moving to the right and i'm pressing left it's not working i'm moving to the left pressing right we're moving up pressing down it is not working we need to turn left or right and then move to that side where we want to move and also let's go and briefly break down all of these codes now this right here it's pretty clear this is clear what it is this right here as well here we are resetting horizontal and vertical every time after the input and here we're getting that input now pay attention here we are using horizontal and our function get axis raw and here get axis raw here horizontal here vertical this is clear as well so here when it's horizontal we are checking for get key down if we press our key code down for the left arrow or the right arrow we will store that in these booleans if we press the left or if we pressed right we will return negative one or one depending on which one of these we have pressed otherwise we will simply return zero same thing for the vertical axis if we press key code up or down this will trigger or it will set the appropriate boolean out of these two to be true if we press up we'll return one if we press down we will return negative one because down on the yaxis is negative up is positive on the left side for the horizontal left is negative right is positive we did this probably thousands of times in my tutorials on youtube channel in the ultimate game development academy and i talked about this thousands of times and this is basic math if you go to the left side on axis it is the negative side right side is the positive up is positive down is negative so moving back inside of our get keyboard input we are storing that value in the horizontal so it will be either one or negative one or zero and here we are checking if our value is not equal to zero so we need to check if it's not equal to zero because if it's equal to zero we are not moving so we are not moving if it's equal to zero so if it's not equal to zero it's either one or negative one if vertical is equal to one then we will set it up which means positive if it's not equal to one meaning it's negative one then it's down same thing for the horizontal and in our player controller we created set input direction we are preventing here movement to the opposite side and we tested this out a moment ago and when that happens we're setting the direction to our own or dir this parameter to our own movement direction and then force move the snake just so that it moves right away instead of waiting for the threshold of the movement frequency moving forward with our snake we can move it and we can control it so let us now detect collision on the walls and also add our collectibles now first of all we're going to start with our walls and if we go here in the level we have these walls right here so all of these walls and let me select all of them so we have top walls we have bottom walls left and right walls select all of these walls except don't select their parents so bottom walls this one right here left walls and right walls we don't need to select these so select all of the walls except for their parents as you can see i did not select top walls game object bottom walls left walls and right walls because we are using that as a parent to store all of these children so now when we have all of these we are simply going to click on add component and we are going to add a mesh collider so mesh collider component on all of these so that we can detect collision on them and i am going to tag them so click here on add tag and i'm going to create a wall tag i'm also going to create a fruit tag and a bomb tag so select again all of these walls except for their parents so select them except the parents and tag them with the wall tag and voila we're good to go and also for these obstacles here which are these as you can see so these right here if i turn them off so these also set their tag to be wall and i'm going to select the 11 level and hit apply so that this change applies to the prefab and if we go inside of our player controller and right here inside of our void on trigger enter in our ontrigger enter we can test if we collided with the wall except here for other i'm going to say target because i like to name this parameter target and i'm going to say if our target dot tag is equal to tags dot wall we are simply going to print here so print touched wall like this so we touch the wall and that is that this is just for testing purposes we will fix this later on do not worry about that so if i go back here in unity and if i try to collide with some of these wall obstacles pay attention in the console so now when i hit one of these bam we should see inside of our console that we have collided with the wall now of course we collided with the top walls but we are not colliding with the obstacle walls that is because we need to select them as well and attach a mesh collider on them we forgot to do that so if i hit the play button again and if i go through these walls that are obstacle walls bam you see touched wall touched wall touched wall when we go through all of these so this is working we are detecting collision between our walls and now moving back in our project we are going to import the bomb and the fruit now here i'm going to filter for the eyeball in our project and drag and drop the eyeball right here and i'm going to filter for the bomb and i'm going to drag and drop the bomb also in our hierarchy panel and inside of our prefabs i'm going to right click and create a folder and this is going to be our pickups so pickups where we are going to store the eyeball and the bomb and here actually i'm going to name the eyeball to fruit and bomb balls simply to bomb i'm going to tag the fruit with the fruit tag and bomb with the bomb tag i am also going to remove the animation from the bomb and for the fruit remove the animation as well i am going to change the scale of the fruit to 0.1.1 0.1 the zaxis is going to be 5.8 and we are going to attach a sphere collider on it and actually let me just take this fruit so eyeball this fruit right here and i'm going to name this game object here as fruit and this one i'm going to say 0.1.1.1 rotation i'm going to say 0 this rotation negative 90. and on this one i'm going to attach a sphere collider make it a trigger and let me just see where it is here it is this is our eyeball or our fruit that we are going to use as a fruit that is and i'm going to tag it here with the fruit tag come on select it where it is fruit not bomb what is wrong with me so tag it with the fruit tag and for the bomb i'm also going to change that so i'm going to say 0.2.2.2 the z position 5.8 for the bomb and here is our bomb we are also going to attach a sphere collider on the bomb and voila this is it so if we go inside of our prefabs and pickups i'm going to drag and drop the fruit and i'm going to drag and drop the bomb prefab if we go back in unity here if we touch the wall i'm also going to see or if our target tag is equal to tags so tags come on tags dot bomb we are also going to print now touched bomb because we are going to check if we touch the bomb now for our fruit we are going to do the same thing so we are going to say if our target dot tag is equal to tags dot fruit tag and here we are simply going to deactivate it so we are going to say target dot game object set active is false and we need to say create node at the tail is now equal to true because remember here we are going to create a tail because we picked up a fruit so we need to create a tail now first of all we are going to test if this actually works and then we will see how can we create that tail so first of all we are going to pick up the bomb and see if we are printing in the console that we are picking or picked up the bomb so bam we touch the bomb that is good we will end the game when we touch the bomb now we are going to pick up the fruit and when we pick it up bam it is gone but we need to create a node at tail or make the snake larger because we are we picked up a fruit so if i go back here in visual studio this now is true create note a tail is now true so when we go back here this is where we need to create that so first of all when this is true we are going to say create node a tail is now equal to false because we only want to create node at tail once we don't want to create it multiple times and if we continue what is the next thing to do is that we need to create a game object so we need to say game object and we need to say new node is equal to instantiate and we are going to instantiate the node prefab or tail prefab and we can say here new tail or new tail or new node actually new node tail prefab and we are going to instantiate it where where we are going to instantiate it using nodes and we are going to say nodes.count minus 1 dot position so position dot quaternion identity like this and let me just move quaternion identity here what are we doing here we know that in our instant sheet we need to pass a game object that we want to instantiate or create a copy out of that game object we need to pass a position and we need to pass a rotation rotation is not important quaternion identity zero zero zero what's important is the position notice here i'm using nodes and nodes count minus one dot position this is the last node in the nodes array that we are storing here and remember in the beginning we stored three nodes our head our middle node and our tail and i said every new tail node will be stored inside of this nodes array because we need to keep track how many do we have and if i go back here what is the next thing to do we need to say new node dot transform.setparent and we need to set our own transform and here we're going to say true you see here world position if world position stays true the parent relative position scale and rotation are modified such that the object keeps the same world space position rotation and scale as before so when we say here true it will simply make this node keep the same position same skill and everything relative to its parent and here we are simply going to say nodes add and we are going to append to it new node dot get component and we're going to append the rigidbody component like this because i said we are going to add every new node inside of this array now we can see this the best way to see this is if i copy and paste a little bit or multiple of these fruits so we can have one fruit here i'm going to duplicate it one fruit here one fruit here for example one fruit here and one fruit here just so that we can see that our snake is growing larger so now we have three of our snakes so three parts of our snakes now we should have four you see now we have four and five you see the snake is bigger and notice now again picking up these you see the snake gets bigger and bigger again picking one one more one more the snake is bigger and the bigger we picked up all of these you see we picked up all of these notes and you can see that every single one of those notes or actually those fruits are being appended at the end of the snake because we are using nodes and nodes count we are getting the element that's at the count minus one which is the last element inside of that array so the last element inside of that array we are getting that and we are positioning we are positioning that node at that position so if the last node let's say if i highlight or use my highlight tool so this is the head of the snake this is the node this is the tail and this is another tail so let's say we eat a new node or new fruit here so we eat it and now we want to append it to the snake so the snakes position or the snake grows larger so this node needs to go here that's why we are using this right here nodes count so this right here position which is the last position count minus one it's the last element in the array which is this one and its position so we are using its position to set it so append that right here so append it right after that position this is what we are doing and basically that is that what we can also add here is that now we can say if so here we can say or if our target dot tag is equal to tags dot tail tag so if we touch our tail so you're also going to say print snake touched tail and if i go back here we need to make sure that our snakes last part has a tail you see here it needs to have a tail tag so add tag and here we are going to say tail tag so select it and this one will have a tail tag hit apply and if we go back here for our snake if i select it and the tail that we add here this tail also needs to have the tail tag because the snake will die if it hits itself and notice if i pick up some of these fruits and when we pick it up the snake will get larger and larger so then we can touch our own tail notice now we touch our own tail you see here snake touch and i spell touch with touch so snake touched tail you see we touched tail and bam we should die when we touch our tail but we will do that later on don't worry about that the point is that this all is working we can remove all of these fruits so let me select all of these fruits we can remove them we are only left to create our gameplay controller who is going to spawn all of these fruits in our level so on and so forth and also create audio effects but before we end this video i'm also going to create our ui quickly because our ui is not going to be that large so if i go here in our game our canvas is going to be set on screens play screen space overlay i'm going to scale it with screen size 180 by 720 and i'm going to match the width and height equally i'm going to take the image this is going to be our icon so snake icon and i'm going to set the anchor at the top middle i am going to set here for the source image this snake portrait or however we are going to call it the width and height is 8080 for this snake the position x is negative 99 and the position y is negative 5 8 like this and the next thing we are going to add our separators so i'm going to take here i'm going to actually rename this one as well ui canvas i'm going to hit here right click and ui text now this text is not going to be a child of our snake icon it is going to be a regular text i'm going to call it separator separator and i'm going to simply add this line to separate and we will see what we will separate i'm going to set the font at ariel and let me just resize it i'm going to set the anchor at the top middle the width is 29 and the height will be 135 the position x will be negative 32 and the position y is negative 49. the scale or the font size is 103 and i am going to set the color to white and voila this is it and actually we can move it just a little bit down something like this yeah this can do so negative 62 negative 62 can do and voila this is our separator now i named it separate torn it's separator and we're also going to create a score so here instead of separator i'm going to call it score now for the score top anchor the width is going to be 303 the height is going to be 83 the position x is going to be 1 5 1 and the position y is going to be negative 60. and here i'm simply going to say score like this 0 and let me just find it where it is so where is my score where did i put it yeah here it is here is my score and let me just resize the font something like this so the font can be 50 here in this case i'm going to set the font at 50 and maybe just move the score a little bit down negative 72. so negative 72 for our score now the font for our score is going to be our open sun's regular open sun's regular here it is and voila that is practically that this is going to be our score or maybe just move a little bit up so negative 6 9 this works perfectly so this is our ui here is where we are going to keep track of the score this is our snake image this is the separator between the snake image and the score not that fancy because the point is not to create fancy ui the point is to create our snake game also make sure that you attached or dragged and dropped the bomb inside of our pickup so drag and drop the bomb and the fruit to make them prefabs let us wrap things up starting with our gameplay controller so in the scripts folder and helper scripts i am going to right click and create our gameplay controller like this and i am going to right click here in the hierarchy and create an empty game object which i'm going to name gameplay so it's gameplay controller so gameplay controller and i'm going to attach the script on the gameplay controller what do we need well as always we need a couple of variables to start with and let me do my thing so let me tag the class give a little bit of space the first thing we are going to make our gameplay controller an instance so public static gameplay controller instance like this and for our instance right here instead of our update i'm going to click create create make instance and inside of this one i'm simply going to say if instance is equal to null meaning it's not pointing anywhere i'm going to say instance is equal to this and voila we are good to go i'm also going to call this function in the awake function as always so this is nothing new we did this probably thousands of times so far before moving forward i am also going to type here using unityengine.ui because we need to get ourselves a reference to the text displaying the score to our user and we are going to display the score every time our snake eats a fruit so here we also need a public game object for our fruit pick up no this is not a pickup truck it's simply a fruit and we also have a bomb pick up like this now also we are going to have a private float this is going to be our minimum underscore x which is equal to negative 4.25 f we are also going to have maximum x which is equal to 4.25 f now the minimum is negative and the positive or the maximum is positive minimum y which is equal to negative 2.26 f and positive or maximum y which is equal to 2.26 f and also our private float z underscore p o s which is equal to 5.8 f what is all of this here what did i just type am i going crazy or not well first of all we need to make sure that we are going to spawn our fruits and the bomb between our game objects here let me just find the level here it is so between when i said between our game objects i meant between here and here so as you can see this point let me just take it again so this point here is four point oh let me just find it it's negative 4.25 so negative 4.25 which is somewhere around here and this one is positive 4.25 which is somewhere around here how did i find these values well i just did as you just saw i took this fruit or this eye and i positioned it here and saw which position that was then positioned it here and saw which position that was did the same thing for y axis and voila this is how i got them now our fruit and bomb in the scene we can remove them because we are going to drag and drop if i select the gameplay controller we will go in prefabs and pickups and we will drag and drop these from our prefab so fruit pickup will go here and bomb pick up will go right here so moving forward or going back here and z position is same as for all of our game objects you can see snake has z position 5.8 so does every other game object that we want it to be visible so moving forward we also need a private text which is going to be our score text and we need a private int which is our score count now inside of the start function we are going to say so void start and here we are going to say our score text is equal to game object find the game object with the name score get the component text from that game object like this and we are good to go now you need to make sure that the name of that game object is indeed score so in our ui here so ui canvas here it is score so make sure the names match up or otherwise this will not work now we are going to create functions that are going to start spawning our pickups be that a bomb or our fruit so first of all we are going to create an i enumerator a co routine as you might assumed and we're going to call it spawn pick ops like this so start spawning pickups and here we're going to say yield return new wait for seconds and we are going to wait from random dot range between 1f and 1.5 f so between one second and 1.5 of a second we're going to wait and then we will spawn either a fruit or a bomb and we're going to do that using a random value so if random range from 0 to 10 is greater or equal to 2 then we are going to instantiate a fruit so here we're going to say instantiate and we're going to pass here our fruit pickup at the position new vector 3 like this and for our x we're going to say random.range from minimum x to maximum x this is for the x position for the y position random dot range from maximum or minimum y to maximum y and our z position so zpos comma quaternion identity and we are good to go so let me just put quaternion identity right below here and voila we are good to go this is for spawning r and actually i'm also going to put new vector 3 right here and put this right here so it works perfectly like a charm so instantiate the fruit pickup on the random range between minimum x and the maximum x minimum y and the maximum y and i've explained this it will instantiate our game objects so i'm going to take it like this and zoom in on our level just a little bit something like this and i'm going to take the highlight tool just so that i can demonstrate that this is the minimum x and this is the maximum x value minimum or maximum y and this is the minimum y so between random range between minimum and maximum that's this range so between here so between these two values here it will spawn it on the xaxis and on the yaxis it will spawn them between these values as i explained a moment ago how are we in stenching or how did i get those random values so this is if random range is greater or equal to two because there is only twenty percent chance that we will spawn a bomb if that happens then here we are going to copy this line of code and here in the else statement instead of fruit pickup we are simply going to say bomb pickup and voila that is that but we need two more functions because here above we are going to create void start spawning like this so start spawning and here we're simply going to say start co routine and we are going to start our spawn pick up school routine which will start well this co routine but here inside of this co routine we are also going to call invoke and we are going to invoke this function like this so you see here we are invoking this function this one right here that will call our co routine and again over and over and over and over until we create here a public void spawning and in our cancel spawning we are simply going to cancel so cancel invoke passing here the start spawning invoke co routine that well we are going to cancel and when we start our game right here in the start function we are going to spawn it after 0.5 seconds so 0.5 of a second and we will start spawning and spawning and spawning now before we test this out and see if this actually works and it will work we are going to go here and we're going to create a public void increase so increase score and here simply we're going to say score count plus plus and our score text dot text is equal to score column plus score count and this right here will be called inside of our snake so when we go in our player controller when we pick up a fruit you see here we are going to call our gameplay controller so gameplay controller that instance that increase score just like that so simply call it to increase the score and by the way notice here if i go and run our game i'm going to hit the play button so now after 0.5 of a second you see here we have a bomb we have a fruit so here i'm going to pick up a fruit another bomb fruit right here let me try to pick it up so fruit here now one thing that you are probably noticing is that these game objects are staying in the scene they are not being deactivated until we pick them up or until we touch the bomb and eventually we will run out of places where we can walk or move because of the bomb now because of that we need to go in our scripts and here i'm going to create a new folder for our pick up scripts and simply here i'm going to create the activate pickup so csharp script deactivate pick up inside of this script we are simply going to create two functions or actually one function called void the activate which is going to do what game object set active so that set not gameplay controller game object and this is what i hate so visual studio crashed on me for some reason so we need to wait for it to reload again when this happens i simply close visual studio this happens also with mono develop i hate it when this happens it simply freezes it will not take into consideration mono behavior monodevelop whatever but now it works because now you see i can call our game object set active is false and in the start i am going to invoke our deactivate after random range so random dot range between three seconds and six seconds so between three seconds and six seconds we are going to deactivate our game objects now as we did or did we go here in our gameplay controller and we called here increase score actually i did not even tested that out i didn't did not see we were looking at our fruits but pay attention now so pay attention to the score when you start picking out fruity c score is now one and let us try to pick this up and now score is two and again our fruits and our bombs are not being deactivated because silly me select them right here in the prefabs and attach the deactivate pick up script so if i hit the play button now and pay attention to the score again so when we start picking up roots we will start also counting the score so now score is one score is two and you see the fruits are disappearing i almost cut that one on did i cut this one i think i did okay this one i missed four okay this one i missed five and you see it is working so we are counting the score everything is going perfectly well what we need to do now is actually stop the game when we hit one of these so either wall bomb or tail so when we hit one of these we simply what are what we are going to do is we are going to say time not tone but time that time skill is zero we are going to stop our game then you can restart the game by using your code or either press the button and restart it because i'm not gonna go we did this already in mary's of times restarting the game we created menus i do this extensively in the ultimate game development academy so you have all of the resources you need to create your own mechanism for restarting the game so on and so forth because what i'm going to do now is go in unity and i'm going to hit here or double click and create an audio manager script and going back in our scripts folder and helper scripts right click i am going to create a c sharp script which i'm going to call audio manager and attach it on the audio manager game object so simply drag and drop it on the audio manager and what do we have in our audio manager well first of all let me just tag the class give a little bit of space we are also going to make him an instance so we are going to say here public static audio manager instance instance like this and here we are simply going to create void make instance so if instance is equal to null we're simply going to say instance is equal to this in our awake function we are going to call make instance and that is that this is for our instance and we are also going to have our public audio clip for our pick up sound and for our dead sound and for these two we are simply going to have a public void play why are you correcting me so public void play underscore pick up sound like this and we are going to call here audio source play clip it point the clip is pick up sound at point transform that position and i'm going to duplicate it paste it here this is going to be play dead sound and simply here instead of the pickup sound we are going to paste our dead sound and it's simple like that and for our sounds go in the audio manager and for our pickup so pick up sound is going to be our eat fruit sound and for our dead sound we are going to have game over sound too so game over sound number two this is what we have for our sounds moving back in our script for the player controller here when we increase the score we are also going to call our audio manager dot instance to play the pickup sound and here we are going to call our audiomanager.instance to play the dead sound practically we are done with our game if i go back here and i'm going to pump up the volume so that we can hear the sounds so now when we pick up our fruit pay attention let me just try to pick one of these up it's like an eating eating sound you see i had to stop there because i was about to pick up a fruit and again and again and again and we can pick them up and notice when i hit the wall the game is stopped we don't spawn anything anymore you can we did create here a function in our gameplay controller so we created this to cancel our spawning we did not call it because we're using here time scale in our gameplay controller when the time scale is set to zero instantiate will not work but if you want to implement something else you can call cancel invoke you can stop the game with the boolean whatever you choose and that is that basically so in our gameplay controller we did nothing new we just created here our instance we attached our pickup prefabs i've explained how i got these values this is the text for the score and the score count here we simply have a co routine that based on the random value will either spawn a fruit or spawn a bomb invoke spawning which will call this function again to start the same co routine increasing the score here for our audio manager simply playing the pickup sounds and the dead sound by using play clip at point we created also a script to deactivate our pickups after three or six or between three and six seconds here for our player controller simply we called those functions to play the sounds and to display the score and we explained everything else in the previous videos so again i'm going to hit the play button so that we can see this in action one more time so here is one of our pickups i'm going to try to die this time by eating or touching my own tail so i've ate this come on come on come on this and this and this this also oh i missed that one yeah i died now you see here you see how he died we should have passed this here the reason for this is because my collider for my eyeball or this one the dude the first the snake's head is too large you can resize it so the radius is set at one or actually for this snake this dude right here excuse me so the radius is set at 0.11 you can resize it let me just go in the scene and search for the snake you can resize it to something like 0.09 which is smaller so if i hit the play button so now our collider is smaller we can still pick things up so we can eat here the fruit as you just saw so we can eat the fruit but when we try to pass our own tail then it will work because let me just try to make the snake a little bit bigger to demonstrate that so we ate this we ate this and let me just ate this or eat this as well and let me try it okay now it works you see now we are not dead by going right near our tail but we will be dead if i do this and bam we have died again this is our small 3d snake game this is how simple it is if you had this idea when the nokia phone came out probably we will be millionaires but hey we did not came with that idea first so just learned something from this tutorial in this game that we have created fi here here from awesomedudes.com i will see you guys in the next video
