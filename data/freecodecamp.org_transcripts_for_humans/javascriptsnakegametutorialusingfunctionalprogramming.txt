With timestamps:

00:00 - in this video i want to take you through
00:02 - this snake-like game that i've built
00:04 - using javascript and more precisely
00:07 - javascript in functional style or in
00:09 - functional programming styles so with
00:11 - the focus on purity small functions and
00:15 - composability
00:16 - so as you can see here now i'm running
00:18 - this snake game in the browser
00:20 - and ah you can see also there that i
00:23 - actually crashed sorry my camera is in
00:25 - the way so i can't really see what i'm
00:26 - doing in the snake game so
00:28 - but but this is the browser
00:29 - implementation and because i i tried to
00:32 - put the focus on modularity it was kind
00:34 - of trivial to make one sort of gui for
00:37 - the browser and then another gui for the
00:40 - terminal so
00:41 - if we jump over here to this side you
00:42 - can see if i just look at where i'm at
00:45 - now i'm in a folder called snake where i
00:47 - have a few files and what we're looking
00:49 - at here in in the browser is this
00:52 - web.html file but what i can also do is
00:55 - i can run this cli.js file through node
00:59 - and then we can place snake in the
01:00 - terminal so if we if we run cli through
01:02 - node you can see that we now get snake
01:05 - but in in sort of terminal mode let me
01:07 - make this a bit bigger so the x's
01:09 - represent the snakes the dots are the
01:11 - grid or that's traversable and the olds
01:14 - are the apples that you need to to eat
01:16 - in order to become longer and the
01:18 - interesting portion is of course or the
01:20 - interesting part is of course that this
01:21 - runs on the same quotation marks engine
01:23 - like we've separated the game engine
01:25 - from from the visuals of the game which
01:28 - is generally what we should do right we
01:30 - should separate presentation from the
01:32 - business logic so my interpretation of
01:34 - most of these snake tutorials or
01:36 - actually game tutorials that you find on
01:38 - the interwebs is that they are focused
01:40 - on just getting a quick version up and
01:43 - running
01:44 - quickly essentially but what i want to
01:46 - do
01:46 - as i tend to do with all of these videos
01:48 - is instead talk about design so i'm by
01:51 - no means saying that this is a perfectly
01:52 - designed snake game at some point i just
01:54 - said okay never mind let me just drop
01:56 - this make this video and i'll leave it
01:58 - to you guys to hopefully improve upon
02:00 - this game and make it even better or
02:02 - rather i should say improve upon this
02:04 - code and make this codebase even more
02:07 - modular and elegant that would be
02:08 - fantastic so if you do have comments
02:10 - please do shoot those in the comments or
02:12 - or if you do fork off from this code
02:14 - base and make changes please do post
02:16 - your changes in the comments that would
02:17 - be really interesting to read but
02:19 - anyways when we focus on modularity we
02:21 - can again trivially achieve this kind of
02:24 - thing where we have one implementation
02:26 - for the terminal and one implementation
02:28 - for the web which uh of course
02:31 - if we generalize this notion what we're
02:32 - talking about here is that you might
02:33 - have a single core and then multiple
02:36 - different implementers of that core or
02:38 - users of that core so that might mean
02:39 - that you could have let's say a
02:41 - multiplayer portion of your game or you
02:43 - might expose your game through an api or
02:46 - you might make an ios version and an
02:48 - android version and a web version of
02:50 - your game and so forth and now i'm
02:52 - saying game but actually we're talking
02:53 - about applications right so generally
02:55 - what i
02:56 - usually want to talk about is is design
02:58 - of programs is how we keep programs
03:00 - alive over longer periods of time and
03:02 - how to to increase modularity and so in
03:05 - some sense then this game is just an
03:07 - example of that but but anyways you
03:09 - could also just see this as how to build
03:12 - snake using functional programming in
03:14 - javascript let's get going so let me
03:16 - cancel out of the game here and let me
03:18 - make this full screen
03:20 - okay so again let me just show you uh
03:22 - the files that i have in this folder
03:24 - here so
03:26 - the main snake implementation is in this
03:28 - file called snake.js that's sort of the
03:31 - core library or or the the game engine
03:34 - in some sense and then these three files
03:36 - web.css web.html and web.js that's
03:40 - essentially that's essentially the web
03:42 - interface for the snake game so that's
03:44 - what we were looking at when we were
03:45 - playing in the browser those three files
03:47 - and then this cli.js file that's the uh
03:51 - node implementation that's that's what
03:52 - we're looking at up here right that's
03:54 - the terminal gui for through which you
03:57 - can play this snake game and then
03:58 - finally this bass.js is some base
04:02 - function so essentially when doing
04:03 - functional programming as i've talked
04:05 - about in other videos we tend to pass
04:07 - data last and we tend to have functions
04:10 - that are curried so we tend to have
04:12 - functions that are partially appliable
04:14 - but of course javascript doesn't work
04:15 - this way so that's why i implemented a
04:17 - few functions myself such as map and etc
04:20 - and of course like if you would build an
04:22 - extensive game you would probably use a
04:24 - third-party library such as for example
04:26 - ram.js or another library implementing
04:29 - the fantasyland specification but for
04:31 - the sake of this video i really wanted
04:32 - to keep everything self-contained i
04:34 - don't want to use any third-party
04:35 - libraries and this is why we have some
04:36 - code in this base in this base file but
04:39 - then of course we have this readme file
04:41 - just because i've put this up on github
04:42 - and by the way you can find the link to
04:44 - all of the code in the description i
04:46 - might have moved it elsewhere but the
04:48 - link in the description should work
04:49 - let's actually start by looking at the
04:51 - web end so let's start with web.html so
04:54 - let me open vim and then let's open
04:56 - web.html and as you can see i mean this
04:59 - is clearly just any old normal html file
05:03 - where we we are loading in the the style
05:06 - sheet uh here i'm doing some funky stuff
05:08 - i'll explain that in a moment but then
05:10 - in the body we have a canvas setup
05:13 - that's uh of a size 700 and of a height
05:17 - or over width 700 and of a height 500
05:20 - and then i'm loading these script tags
05:22 - and maybe it's maybe people nowadays
05:25 - always load their scripts here and then
05:28 - make sure that the dom is loaded in the
05:30 - scripts files i was just lazy and put
05:32 - them here to ensure that when i load uh
05:35 - this web.js the canvas has definitely
05:38 - loaded but yeah that's a completely
05:39 - different discussion but anyways you can
05:41 - see here that i'm loading in the base
05:42 - library then i'm loading in snake and
05:44 - then i'm loading in web.js so so clearly
05:47 - i mean this is because i don't have a
05:49 - build system set up where i don't have a
05:51 - build process set up so i mean clearly
05:53 - if you were building this and actually
05:54 - shipping this on the web you would you
05:56 - would probably somehow like minify all
05:58 - of your all of your files into a single
06:01 - main.min.js file right and you'd only
06:03 - load that and that would do everything
06:05 - so you would come construct a single
06:07 - javascript file from all of your other
06:09 - javascript files but now this is just a
06:10 - simple example so let's not bother with
06:12 - that right so then we're loading in the
06:13 - base library and the base library will
06:15 - expose a bunch of cons globals or it
06:17 - will essentially define a bunch of
06:19 - functions that are available on the
06:20 - global scope and uh same thing for snake
06:23 - and then web is the actual machinery of
06:26 - this web implementation or i shouldn't
06:27 - say the machinery is the is the actual
06:29 - main entry point of this web application
06:33 - and then let me just quickly explain
06:34 - this i mean this i do let me actually
06:36 - let me open up a split here and open up
06:38 - snake.js in order to show you that so
06:41 - snake.js because i i started with the
06:43 - the cons with a command line
06:46 - implementation actually from the
06:47 - beginning i was thinking that i only
06:48 - should do the command line
06:49 - implementation but then i figured
06:50 - actually it's so easy to make another
06:52 - web implementation so let me just make a
06:53 - web implementation as well i'm a big fan
06:55 - of trying to keep it as absolutely
06:57 - simple as possible from the beginning
06:59 - and this is why i was so actually i
07:00 - started building this snake.js file and
07:03 - and and i started doing it in a sort of
07:05 - step-by-step fashion where i implemented
07:07 - one function at a time where it's like
07:09 - okay this function needs to be able to
07:10 - do this right so like if we have a list
07:12 - of snake points and we want to compute
07:15 - the next snake point given a movement in
07:17 - some direction
07:18 - what would that function look like right
07:20 - and then i did that step by step for for
07:22 - all of the different pieces and then
07:23 - sort of from the ground up build the the
07:25 - snake implementation but anyways i
07:27 - because i did this i want to make use of
07:29 - the module system in node so you can see
07:31 - here in the end that i say module dot
07:33 - exports and then i export a bunch of
07:36 - actually first constants and then three
07:38 - functions and same thing goes for this
07:40 - base libraries if we go to this base
07:42 - library here you can see that this base
07:43 - library exports a bunch of functions so
07:46 - clearly module.exports is not available
07:48 - in uh the browser if you're in a similar
07:51 - scenario with some production code you
07:53 - should of course look into something
07:54 - like browserify or maybe there's
07:55 - something more modern now but but but
07:57 - now i mean we just do it we can just
07:59 - hack it up so so i just simply said that
08:02 - in the global scope i said that require
08:05 - is a function that returns an empty
08:07 - object right and module is
08:10 - an empty object and module dot exports
08:14 - is also sorry so so let me also say i
08:16 - mean i said require here but i said that
08:18 - the problem in in this right hand was
08:20 - the module exports but actually we have
08:22 - so in snake for example snake actually
08:25 - does require right so so snake the snake
08:27 - implementation or the snake game engine
08:29 - depends on the base uh functions the
08:32 - functions in the base library the base
08:34 - library helper functions so here we make
08:36 - use of the word require so so the
08:38 - browser does not have the word require
08:40 - and the browser does not have the word
08:42 - module nor
08:43 - module.exports and when i say word i
08:45 - mean of course i mean keyword sorry um
08:47 - so anyways we just say that require is a
08:49 - function that returns an empty object
08:51 - module on the other hand is an empty
08:53 - object and module.exports is a function
08:55 - that returns an empty object just just
08:56 - to make them not fail right they're not
08:58 - doing anything useful and then i'm
09:00 - relying on the fact that i know that
09:02 - both sn base and snake and web are all
09:05 - defining the fun their functions like
09:07 - this right here's a function here here
09:09 - are a few other functions here a few
09:11 - other functions and so forth so so if i
09:13 - just run these
09:15 - this code in the browser they will be
09:16 - exposed as
09:18 - global functions so just a quick and
09:20 - hacky way of getting this to work but
09:22 - anyways that's the web right so what it
09:24 - does so you can think of this as that
09:26 - web is actually the entry point or
09:28 - web.js is the entry point and then
09:30 - web.js needs to first require base and
09:33 - then require snake and this is why
09:35 - they're in this order or actually i mean
09:37 - to be perfectly frank rather web needs
09:39 - to require snake and snake needs to
09:41 - require base that's actually the more
09:43 - proper way of saying it so that's that's
09:44 - web html let's let's now look at web.js
09:47 - right so so what does this actually do
09:50 - so we don't have a ton of lines here
09:51 - right let me just scroll through this
09:52 - file you can see
09:54 - here at
09:56 - yeah 53 here i'm saying i mean i added a
09:58 - comment here to say that this is the
10:00 - main portion right so let's actually
10:01 - start from this main portion so what
10:03 - web.js does so so the javascript that
10:06 - will be run in the browser
10:08 - when we run the browser version of the
10:10 - snake game right first we do draw so
10:12 - these are actually two lines right sorry
10:13 - i just i thought it was prettier to put
10:15 - them on a single line so first we do
10:17 - draw
10:18 - one initial draw and then we say request
10:22 - animation frame i don't actually really
10:24 - know what that is but it's something
10:25 - like well the next time the browser will
10:28 - redraw redraw using this function please
10:32 - or something along those lines so people
10:34 - who develop games tend to use these so
10:36 - window the request animation frame and
10:38 - then we pass the function step or the
10:41 - function that's returned by invoking
10:42 - step with zero and so importantly
10:45 - usually people do this right they pass a
10:47 - function but i'm actually invoking the
10:50 - function step because step when invoked
10:53 - will return a new function and the
10:55 - reason for that is to avoid one global
10:57 - or another global so so step needs to
11:00 - keep track of how much time has passed
11:02 - since the last step right because so if
11:04 - i'm not mistaken like i mean request
11:06 - animation frame might be called
11:08 - different times depending on the i guess
11:11 - frame rate or something like that of
11:12 - your browser or the frame rate that you
11:14 - can manage to get on your browsers like
11:16 - depending on the performance of your
11:17 - computer your the request animation
11:19 - frame will be or rather the function
11:21 - that uh we pass the request animation
11:23 - frame will be called with different
11:25 - intervals different time intervals
11:27 - depending on the performance of the
11:28 - computer that you're running it on so in
11:30 - every call to step we need to check the
11:32 - delta we need to check the diff between
11:34 - the current time and the last time we
11:36 - rendered and that's why i passed this
11:38 - first variable because here i'm saying
11:39 - then that or this first zero because i'm
11:41 - saying that the time since the last
11:43 - redraw was zero so we're saying let's
11:45 - instantly redraw so so here you can see
11:48 - then that here's the definition of the
11:49 - step method right so the step method or
11:51 - the step function i should say sorry it
11:52 - takes a t1 so time step one
11:55 - or time stamp i should say a timestamp
11:56 - one at a timestamp two and then it says
11:58 - okay what's the difference between
11:59 - timestamp two and time step one and if
12:02 - that's greater than a hundred and i
12:04 - don't really know let's think about this
12:06 - so i can't really remember but i assume
12:08 - this is in milliseconds so that would
12:10 - mean a hundred milliseconds right so a
12:13 - tenth of a second so every tenth of a
12:15 - second we enter this portion and all of
12:18 - the other times we enter this portion
12:19 - and now you can see how this works right
12:21 - because if we do enter this portion if
12:24 - there if
12:25 - if 100 milliseconds has passed since the
12:27 - last time we we updated or the last time
12:30 - we stepped then what we want to do is we
12:32 - want to say this state global this
12:34 - global state variable i'll get i'll get
12:36 - to this in a moment equals the next
12:39 - state given the current state right this
12:41 - is kind of typical functional
12:43 - programming right instead of doing
12:44 - mutation we're just saying that we have
12:46 - this global state variable global i mean
12:48 - you don't you shouldn't have a global
12:50 - state variable but like but i mean in
12:52 - this case it happens to be uh to be
12:54 - global but essentially the point is
12:56 - containing your state into a single
12:58 - variable and then passing that state
13:00 - through a function that produces the
13:02 - next state right from that given state
13:04 - so instead of saying well here's my
13:06 - state here are the actions that i want
13:07 - to do let's change all of the variables
13:09 - so that it matches the new state because
13:11 - then some things are more difficult to
13:12 - reason about because we have mutation
13:14 - all over the place instead we say well
13:16 - here's the old state let me pass you
13:18 - that and then if you compute what the
13:21 - next state would look like given that
13:23 - old state well then i then i know what
13:25 - to do with that right so that's what
13:26 - we're saying state is this this state
13:29 - variable and we say next is a function
13:31 - from snake from the snake engine and
13:35 - when we pat and when we pass state to
13:37 - that it will compute the next state and
13:39 - then we will set this set the state here
13:42 - this mutable state here to this new
13:44 - state and then we will do draw right and
13:46 - draw i haven't even bothered about
13:48 - trying to make immutable in any kind of
13:50 - sense because like like the canvas
13:52 - libraries or they're like the canvas and
13:54 - apis of browsers or
13:56 - like there's tons of there's tons of
13:58 - mutations that would be extremely
13:59 - painful maybe there is a way to do that
14:01 - if you have an idea of how to do that
14:02 - please do shoot something in the comment
14:03 - that would be or in the comment section
14:05 - that would be very interesting to read
14:06 - about anyways
14:07 - so so that's for the if branch or for
14:09 - the true case right for the false case
14:10 - what happens well in the false case or
14:12 - in other words when enough time hasn't
14:14 - passed 100 milliseconds hasn't passed
14:16 - since the last time we updated then we
14:18 - simply do
14:20 - my camera is in the way i can see but
14:22 - but we simply do the same thing or we
14:25 - say or rather i should say we don't
14:28 - compute the new state and we don't
14:29 - redraw importantly but we do request
14:32 - another animation frame and and to that
14:34 - we tack on uh or or we throw in a
14:37 - function that's that says step again
14:39 - from t1 so notice the difference between
14:42 - this line and this line right in in this
14:45 - line we have t2 and in this line we have
14:47 - t1 t2 and t1 and t2 here is because
14:52 - we want to have the new point that the
14:55 - current timestamp as the as the next
14:57 - time step that we want to compare again
14:59 - so it's like as the as the next time
15:01 - step that we want to say has a hundred
15:04 - milliseconds pass from this time stamp
15:05 - right that's what we want to do when we
15:07 - do redraw but when we don't redraw we
15:09 - want to compute from the old timestamp
15:11 - we want to say well you started at
15:13 - timestamp zero and now 50 has passed 50
15:16 - is not enough so keep on keep on waiting
15:19 - but you should compare against zero and
15:21 - not against 50 because if we if we keep
15:23 - updating this if we keep changing this
15:25 - to t2 here if i said uh t2 here we would
15:28 - never redraw right or maybe in the odd
15:31 - case if it's like it's super laggy or
15:33 - something like that right but but
15:34 - assuming we have good frame rate then
15:36 - then we would essentially never call
15:38 - this and that'd be problematic so this
15:39 - is why we're saying t1 and of course i
15:41 - mean maybe this wasn't clear but what
15:43 - request animation frame does is that it
15:45 - passes a timestamp and that is this t2
15:48 - then and i don't actually know i mean
15:50 - it's not it's not like it's a date
15:51 - because we start from zero but maybe
15:53 - it's something like the time since the
15:55 - the this browser session was initiated
15:58 - or something like this i mean this since
16:00 - the page was rendered i should maybe say
16:01 - but anyways i mean i have no idea so
16:03 - don't take my word for that but that's
16:04 - that's the update method but actually
16:05 - let's go up to the top here because i
16:07 - feel like what i what i didn't say is
16:09 - this that the state variable that we
16:10 - talked about is defined here so so
16:12 - notice comment that says mutable state
16:14 - so this is so this is the state variable
16:16 - that contains the state of the game at
16:18 - all times and it's global quotation
16:20 - marks like it's it's shared across all
16:23 - of these functions in this file and and
16:25 - what you can do is is that the functions
16:28 - or actually the functions don't there
16:30 - are two functions that change it i
16:31 - should say right there's the there's the
16:33 - step method that changes it but there's
16:35 - also this key events thing like there's
16:37 - this listener for key events and that
16:40 - thing also changes the state right so
16:42 - actually let's let's look at that uh at
16:44 - once right or wait first let's begin
16:46 - here in the top so so we can say okay so
16:48 - so we say let state is equal to the
16:51 - initial state and where does this
16:52 - initial state function comes from i mean
16:54 - this is the problem of working with
16:55 - globals it's very difficult to see where
16:58 - things are actually coming from
17:00 - since they're not actually scoped i'm
17:02 - realizing now maybe i should have scoped
17:03 - them so that instead of making these
17:06 - functions all functions in this file i
17:09 - could have put them inside an object and
17:10 - that would give us a name space here so
17:12 - that we could say snake dot initial
17:13 - state because that's kind of actually
17:15 - what we're looking at here like if you
17:17 - would use required you would get that
17:18 - for free but but anyways yeah i should
17:20 - have fixed that maybe yeah but anyways
17:22 - that's from the from the snake.js file
17:25 - so snake.js file has a function called
17:28 - next here right and we'll talk about
17:30 - this when we get to the snake.js file
17:31 - but but but suffice to say for now that
17:34 - the next function takes a state and
17:37 - computes the next state given that state
17:39 - oh sorry i was about to talk about
17:41 - initial state and not about next but
17:43 - that's that's next right that's what
17:44 - next does but if we look at initial
17:46 - state that's just a function it's it's a
17:48 - i think it's called a unit function like
17:49 - it's a constant in some sense so it's a
17:52 - function that takes no arguments so it's
17:53 - nullary and it returns uh an object that
17:57 - is essentially a state representation
18:00 - but it's the initial state so the
18:01 - initial state is essentially always the
18:03 - same so when you start a game you need
18:05 - to start from the initial state so yeah
18:07 - that's the way we invoke this this state
18:09 - variable now let's go back down here and
18:13 - let's now talk about these events so we
18:15 - say window dot so now my camera is
18:18 - really in the way add add event listener
18:20 - key down so that's the first argument
18:21 - and then the second argument is this
18:23 - function that takes a single argument
18:25 - which is this variable named e which is
18:26 - the event and then we can extract the
18:28 - key variable or the key property from
18:30 - that event and then we switch case over
18:34 - or over essentially that variable and
18:36 - then we say okay well we want to be able
18:38 - to control the snake using wasd the keys
18:40 - and h h j k l uh so here's the wasd and
18:45 - here is h j k l but then we also want to
18:48 - be able to use the arrow keys right so
18:50 - and depending on which one of these we
18:51 - press we want to compute a new state we
18:54 - want to say that the new state
18:56 - is what the old state was but plus
19:00 - quotation marks plus this new
19:03 - direction so these are constants
19:06 - north west south east these are
19:07 - constants that i've defined in this
19:09 - snake.js file where we have north and
19:11 - south and east and west right and these
19:13 - are essentially just i guess maybe you
19:14 - could think of them as vectors i'm not
19:16 - really sure but like they have an x
19:17 - direction and a and a y direction or a
19:20 - velocity in these directions right so
19:22 - north means moving zero x but negative
19:25 - one y that's the definition of north
19:27 - within the context of this game but but
19:29 - anyway so so we want to cue those in and
19:32 - we need to pass the current state
19:33 - because again remember the snake game
19:35 - has no clue of the current state that we
19:37 - have right it's it's uh actually i
19:39 - should say this it's pure
19:41 - except for that the snake snake.js file
19:45 - has some randomness right so here we
19:47 - have one function that does some random
19:50 - stuff and and i mean remember randomness
19:53 - is is impure because it relies on things
19:56 - such as system date and etc so given the
19:59 - same input you won't get the same output
20:01 - but i mean i was pragmatic here it's
20:03 - just thinking like there's no point
20:04 - trying to do something more complex here
20:07 - in my mind it makes sense for a
20:09 - function that computes a random position
20:11 - within a grid to be within the snake.js
20:14 - file and not elsewhere but anyways there
20:16 - are clearly solutions for that but i'm
20:17 - just being pragmatic but but essentially
20:19 - so so then the snake and q method needs
20:22 - to be passed the current state we need
20:24 - to pass the current state as we do here
20:25 - right and we need to do that because as
20:28 - we do here because again it's it's
20:32 - almost pure so it doesn't know what
20:34 - state we have it doesn't keep track of
20:36 - its own state and and q is also defined
20:39 - here in this snake snake method and
20:42 - again we'll get to this when we start to
20:44 - talk about the the snake stuff but
20:46 - essentially as you can see here it takes
20:47 - the current state and it takes a move it
20:50 - asks whether the move is valid and if
20:52 - the move is valid it does this if it's
20:54 - not it does that right so if it's not
20:57 - valid it just returns the same state it
20:58 - does it does no changes but if it is
21:01 - valid then it says okay we want to merge
21:04 - yeah we want to compute a new state that
21:06 - is the old state plus that this moves
21:09 - property has changed to
21:11 - the old moves concatenated with an array
21:15 - containing only this new move so this is
21:17 - an extremely complicated way of just
21:18 - saying append
21:20 - but immutably append the last move to
21:23 - the list of moves but we haven't even
21:24 - talked about the state tree so we'll get
21:26 - to that in more detail but that's that's
21:28 - in queue and this is sort of the basic
21:30 - game loop right like if you think about
21:31 - this game first from the from the main
21:33 - here we draw one initial time and that's
21:34 - sort of the the first drawing but then
21:36 - we say we'll start stepping from zero
21:39 - and then we keep doing the step method
21:40 - okay step and step and step and step and
21:43 - so forth and whenever we've it's been
21:46 - 100 milliseconds since the last step we
21:48 - compute the next state from the old
21:50 - state and then we redraw and then again
21:52 - we just keep on
21:53 - looping quotation marks keep on
21:55 - requesting animation frames so that's
21:57 - that's sort of update and draw but then
21:59 - there's also this other exogenous force
22:02 - that that can enter right like there are
22:04 - also key events like when the user types
22:06 - uh keys we listen to this and if you
22:09 - happen to type a key that's that's one
22:11 - of the arrow keys then we need to
22:12 - compute a new state so so then we're
22:15 - also saying well you need to set the new
22:17 - state to the old state plus this new key
22:20 - that's being pressed i would say that
22:21 - that's that's fairly clear again like
22:24 - the
22:24 - the benefits of mutation or the benefits
22:27 - of avoiding the mutation is that
22:28 - whenever you want to change things
22:30 - usually it's pretty easy to change
22:33 - things because you don't have to think
22:34 - about state so for example i'm not sure
22:36 - if you noticed but when we played this
22:38 - game well sir of course how could you
22:40 - have noticed it's not actually visible
22:41 - and think about that but
22:43 - the way the game worked from the
22:44 - beginning was that if i'm traveling in
22:47 - the direction west as i'm doing now and
22:50 - i press east right i'm traveling
22:52 - leftwards but if i press the opposite
22:54 - direction if i press east right or
22:56 - conversely if i'm traveling to the right
22:58 - and i press the left key so if i press
23:00 - the inverse direction or the opposite
23:02 - direction of the direction i'm traveling
23:03 - in i would instantly crash because it's
23:05 - like the snake is moving in this
23:07 - direction right and it's like it's it's
23:09 - immediately just going
23:11 - directly into its own tail right and
23:13 - some snake games actually did work this
23:15 - way and was extremely frustrating and
23:16 - that's what i noticed here as well like
23:18 - when i was playing this it just messed
23:20 - me up all the time because i kept on
23:21 - crashing when i wanted to try out the
23:24 - game so i figured okay let's actually
23:25 - remove that functionality from from my
23:27 - snake game and that's when i added this
23:29 - valid move portion to nq so previously
23:32 - nq used to only do this right it used to
23:34 - only just merge in whatever motion you
23:36 - you added into the queue of motions or
23:38 - into the queue of moves but now i said
23:40 - well actually let's let's avoid this
23:43 - sort of inverse situation so if you pass
23:45 - the inverse so that's what value move
23:47 - does it checks whether it's the inverse
23:48 - and if it's not the inverse yes then
23:50 - it's valid but if not if it is an
23:52 - inverse then then we will ignore it and
23:54 - we'll just pass the old state so we'll
23:56 - not cue the move right so it's these
23:57 - kind of scenarios that we often find
23:59 - ourselves in when we use immutability
24:00 - like when we realize okay would be cool
24:02 - if the game could do this or actually
24:04 - this is a this is a tricky thing let's
24:06 - let's not actually make it do this let's
24:07 - make it do that instead right and then
24:09 - we try it out and it actually turns out
24:10 - to be fairly simple most of the time but
24:12 - anyways okay so so so this is the whole
24:14 - this is the the web portion right we
24:16 - have we have the step function we have
24:19 - the event listeners we have let me here
24:21 - in the main let me just put that back on
24:23 - one line we have this main that that
24:25 - initiates it and then we haven't talked
24:27 - about what draw actually does right so
24:28 - as you can see here is the comment says
24:30 - game loop draw right so so this function
24:33 - draw and it's also pretty simple like as
24:36 - you can see from the comments here like
24:37 - i was contemplating separating this into
24:39 - multiple functions but given the mutable
24:41 - nature of the canvas library and like
24:44 - given the fact that we probably won't
24:45 - reuse this code i just figured whatever
24:47 - let's just make this let's actually just
24:48 - make this a long function that does does
24:50 - all of these things like one by one so
24:52 - what it does is that it it clears the
24:54 - canvas right so so ctx here is another
24:57 - global variable because yeah what to do
24:59 - right so so let's actually start from
25:01 - the top right so so the first line says
25:03 - okay let's let's make a constant
25:04 - variable called canvas and let's from
25:07 - the document get the canvas or let's get
25:09 - the thing that has the id canvas so if
25:12 - we look at the html thing you can see
25:14 - that canvas here actually has an id of
25:17 - canvas just to make it simple for myself
25:19 - right so so i i grab that canvas and
25:22 - then we get the context for that so that
25:23 - we can draw so so in ctx is is a context
25:26 - variable then we have these position
25:28 - helpers here we'll talk about these in a
25:29 - moment but what we do then is that we
25:31 - first clear this canvas by saying okay
25:34 - let's set the fill style to this uh like
25:37 - blackish color i guess
25:39 - and then we we draw a rectangle over the
25:41 - hole of the whole width and the height
25:43 - then the next step is that we draw the
25:45 - snake right so then we say let's set the
25:47 - fill style to something which is
25:48 - greenish and then let's map over the
25:51 - snake so so this is where it sort of
25:53 - gets interesting right because it's like
25:54 - the different graphics engines or the
25:56 - different gui's or the different sort of
25:58 - interfaces can have completely different
26:00 - ways of interacting with this stage
26:02 - right but but so the state exposes dot
26:04 - snake it exposes
26:06 - actually lots of things like like moves
26:09 - and
26:10 - apple and and so forth and so forth but
26:12 - but we're just going to make use of
26:14 - snake and of apple so what we do is just
26:17 - that we map a function over uh
26:19 - state.snake and so snake is an array of
26:22 - positions so it's it's or it's a it's a
26:24 - it's an array of points points being
26:27 - objects that have x and y coordinates
26:29 - and of course this is not an actual
26:30 - proper map because i don't care about
26:32 - the return results so this is actually
26:34 - more like a for each that actually
26:35 - mutates the canvas but map was a shorter
26:38 - word so whatever any in each of these
26:40 - iterations of the function what we do is
26:42 - that we say well using this fill style
26:44 - fill a rectangle in the context from
26:47 - this exposition this y position over
26:49 - this width and over this height and now
26:52 - you can see why
26:54 - these x and y methods and these x and y
26:56 - methods are just helpers for me to so
26:58 - that i'm not duplicating the same math
27:00 - all over this place so
27:02 - if you remember what we did was that we
27:04 - drew
27:05 - rectangles right so notice how the snake
27:08 - so every point in the snake or every uh
27:11 - piece of the snake or just think of the
27:13 - apples for example take up sort of one
27:15 - quotation marks pixel and
27:18 - pixel meaning uh like traversable pixel
27:20 - in this grid maybe i should say tile
27:22 - actually like it covers one tile and so
27:25 - what we do then here is that we compute
27:28 - uh the the the position of these tiles
27:30 - so x1 here will return the width of one
27:33 - tile and y one here will return the
27:36 - width of one tile and what happens when
27:38 - we do this y of some position is that if
27:41 - if the y-coordinate is zero then we'll
27:44 - put then it'll turn to zero right
27:46 - because if we look at the implementation
27:47 - of y here we say uh take the canvas
27:50 - height and divide it by the number of
27:54 - rows that we have in the state so like
27:56 - if the
27:57 - sorry i forgot to say that we have the r
27:59 - here as well right so so if r is zero r
28:02 - being the the y coordinate right so
28:04 - let's say that the y coordinate is zero
28:06 - then we multiply that with the height of
28:08 - the canvas and let's say that the height
28:10 - of the canvas is a hundred and then we
28:12 - divide that by let's say uh 20 which is
28:15 - the uh the number of rows let's say so
28:18 - the number of tiles in the y direction
28:20 - now this is not necessarily correct with
28:23 - in regards to this particular scenario
28:24 - but just hypothetically it makes sense
28:26 - then you can see that we get zero right
28:27 - because that's a zeroth position like
28:29 - that's the pixel that we actually want
28:30 - to draw from but if we take one we get
28:33 - five if we take two and we get ten and
28:35 - so forth and if we take 20 we get a
28:37 - hundred because like that's the that's
28:38 - the last pixel and actually 20 doesn't
28:41 - exist if we have 20. it's 19 would be
28:43 - the last one because it's height will
28:45 - also be 5 and then 5 will take it up to
28:47 - 100. but anyway so so those are just two
28:49 - helpers in order to to not have to
28:51 - duplicate that as you can see we use
28:53 - these x and y things here as well so
28:55 - that's the way we draw the snake and
28:56 - then we do that for the apple as well so
28:58 - we say okay here we don't have to
29:00 - actually iterate we just say
29:02 - fill rect
29:03 - at this x position at this y position
29:06 - using this width and this height right
29:08 - and the width and the height is the same
29:09 - because the apple is as large as a tile
29:11 - just ah as all of the pieces of the
29:13 - snake is is is as large as the tile but
29:16 - the position is based on the on the x
29:18 - position of the apple right so so the x
29:21 - position and the y position so we're
29:23 - saying compute the y position from this
29:26 - coordinate which is defined by state dot
29:29 - apple dot y and then finally we draw the
29:32 - crash so let's just think about so let's
29:34 - let's just look at that right like if i
29:37 - if i crash into my own tail notice how
29:39 - the screen flashes quickly red right or
29:42 - quickly flashes in red
29:44 - there you go right it quickly flashes in
29:46 - red and how we know that that has
29:48 - happened is that i decided that well if
29:50 - we don't have a snake in the game field
29:52 - that means that either the game is just
29:54 - started or there was a crash so actually
29:56 - if we just refresh the page you can see
29:58 - that it blinks red and maybe this is an
30:00 - unwanted feature and we should try to
30:01 - solve this but i just figured whatever
30:03 - let's just not think about that now so
30:05 - if there is no snake right so
30:06 - essentially then we're saying that if
30:09 - state.snake.length is equal to zero so
30:11 - if we don't have a snake then we should
30:14 - essentially draw this red rectangle over
30:16 - the whole screen right so that's the way
30:18 - we're indicating a crash and and that's
30:20 - the whole drawing thing and i i mean
30:23 - a moment to pause and reflect right like
30:25 - like the point here is that this is all
30:28 - graphics right like assuming that we can
30:31 - use this uh state structure for all of
30:34 - the graphics engines assuming that state
30:36 - tree
30:37 - gives enough information this can be
30:39 - completely focused on just the visuals
30:41 - right and and it is not sort of
30:43 - intermingled with all of the business
30:44 - logic so if we say ah actually let's
30:47 - change the color of the snake it's
30:48 - trivial to find the place where we can
30:50 - change the color of the snake or let's
30:52 - make the apples round it's trivial to
30:54 - find the place where we make the apples
30:56 - round instead and we don't have to worry
30:57 - about accidentally messing up some of
31:00 - the other core business logic because
31:02 - that's in a completely different place
31:03 - so we have to be really silly in order
31:05 - to mess that up so anyways that that's
31:06 - the draw that's the draw function and i
31:08 - think actually we've covered all of the
31:10 - stuff here here then right like first we
31:12 - just grab out the canvas we set up this
31:13 - mutable state that's based on the
31:15 - initial state we we construct these two
31:17 - position helpers that will make us
31:18 - position things in this uh grid or a
31:21 - visual grid in the browser and then we
31:22 - construct this draw function that will
31:24 - take the mutable state or based on the
31:27 - mutables they draw a bunch of stuff on
31:29 - the canvas and then we have this game
31:31 - loop that whenever it's called checks
31:33 - whether it has passed enough time in
31:35 - order to progress to the next state and
31:37 - and redraw or whether it should just
31:39 - keep on ticking and then we have these
31:41 - these listeners that listen for events
31:43 - or listen for keystrokes and produce new
31:46 - states based on these keystrokes where
31:48 - the new states contain the new
31:50 - keystrokes or contain the directions
31:52 - that we want to move in and then finally
31:53 - we have this this main that sort of just
31:55 - initiates and starts the whole thing up
31:57 - and of course i mean we didn't actually
31:58 - need this first uh this first draw here
32:01 - in the in the end right like the only
32:03 - difference if we have that or if we
32:04 - remove that you can see that there's a
32:06 - quick flash of 100 milliseconds where we
32:08 - don't have a board that's essentially
32:10 - the only difference and that's why i
32:12 - added that because then immediately we
32:14 - should get the board actually now that i
32:15 - think about it it's almost hardly
32:17 - visible like like
32:19 - you can see i mean loading the page
32:21 - probably takes quite some time anyway so
32:24 - so yeah i mean you might want to remove
32:26 - that okay but that's the web portion
32:28 - let's now actually look at the snake
32:30 - core library i think it's probably
32:31 - easier to start with that and then look
32:33 - at the the command line implementation
32:35 - so let's go to snake.js so again this is
32:38 - we we've glanced into this file a tiny
32:41 - bit but but not too much
32:43 - so i think actually there's too much
32:45 - code here right so let's start from the
32:46 - top let's just scroll through quickly
32:48 - first to get an idea like we have
32:50 - about yeah 61 lines of code and if you
32:54 - have ways of making this again more
32:56 - elegant and more concise not not concise
32:58 - as in cold gold pheasant just for the
33:00 - sake of conciseness but as in elegance
33:02 - then please do shoot something in the
33:04 - comments that would be massively
33:05 - interesting but what we start by doing
33:06 - is just requiring this base library that
33:08 - we've defined again as we've talked
33:10 - about with some helper methods i'm not
33:12 - sure if we actually ever looked at that
33:13 - but here's the base library right yeah
33:15 - we did quickly look at that but we just
33:16 - define a few a few functions such as for
33:18 - example map and as constant and identity
33:22 - and all that stuff but let's forget
33:24 - about that for now right but we load the
33:25 - functions from the base library and then
33:27 - we do this and this is kind of just me
33:30 - hacking again so i apologize for that
33:31 - but what i wanted to do is so base for
33:33 - example exposes the function map right
33:35 - so you have base dot map but whenever i
33:38 - use i don't want to have to say based on
33:40 - map i just want to be able to simply say
33:42 - map and refer to base.map because they
33:44 - are helper functions as i mean in some
33:46 - sense you could argue that that some of
33:48 - the functions defined in base here are
33:50 - functions that should be defined in
33:52 - javascript if javascript was actually
33:54 - aiming to be a functional language like
33:56 - so functions such as map or reduce are
33:59 - defined in the prelude of haskell so
34:02 - they're defined in the base library of
34:03 - haskell reduce is actually called fold
34:05 - in in in haskell but and not just that i
34:08 - mean tons of other methods such as
34:10 - identity and constant and lots of other
34:12 - things some of them are not like prop
34:15 - for example like because haskell is
34:17 - aesthetically typed language and and
34:19 - javascript is dynamically typed language
34:20 - so if we look at the base library here
34:22 - for example i define the helper method
34:24 - prop which essentially takes a key and
34:27 - then takes an object and extracts the
34:30 - value under that key from that object
34:32 - and it's trickier to define an
34:33 - aesthetically typed language actually
34:34 - now that i think i'm thinking about it
34:36 - actually it's completely defined upon
34:37 - aesthetically typed language it's just
34:39 - probably not as useful right because
34:41 - you're probably using static typing
34:43 - because it gives you benefits and when
34:44 - you're starting to use this sort of key
34:46 - value pair syntax this dictionary syntax
34:49 - then you are exposing yourself to
34:51 - runtime errors because you might end up
34:52 - in situations where the key doesn't
34:53 - exist but anyways that's tangential what
34:55 - i wanted to say is just that in
34:57 - javascript because of the dynamic nature
34:59 - of javascript some of the functions that
35:00 - we might want to put in the base library
35:02 - quotation marks make sense to put in the
35:04 - base library but might not be functions
35:06 - that we want to put in the base library
35:07 - in other languages but anyways this is
35:10 - total sidetrack that's why i'm doing
35:11 - this right just to expose all of those
35:13 - functions so i can say k and id and map
35:17 - and so forth and not have to say bass
35:19 - dot map and so forth so so that's that
35:22 - okay let's move on then we have these
35:23 - constants right these constants we've
35:25 - already talked about we need some way of
35:27 - talking about the different directions
35:29 - and maybe you could argue that these
35:30 - should be functions that or again like
35:33 - nullary functions that take no arguments
35:35 - and return this but anyways i just
35:37 - define them as constants then we have uh
35:40 - this point operation and actually i was
35:42 - thinking about this a while like this is
35:44 - not excellent because if you could check
35:46 - for deep object equality right like i
35:48 - think in many of the javascript
35:49 - libraries you can do that in many of the
35:51 - testing libraries you can so actually
35:52 - like object deep equals or or deep
35:55 - equality of two objects is actually a
35:57 - very useful thing to have in the
35:58 - language so actually i mean the
35:59 - implementation of point equals should
36:01 - essentially just like if you pass point
36:04 - one and you pass point two then the
36:05 - implementation should essentially be
36:06 - point one equals equals point two if if
36:09 - equality in in javascript was based on
36:12 - the deep structure of an object and not
36:15 - the the reference to that thing in
36:18 - memory or the pointer to that thing in
36:20 - memory but anyways i mean and even if it
36:22 - didn't look like this it should perhaps
36:23 - be the deep uh the deep equality between
36:27 - p1 and p2 and maybe if we do that in the
36:31 - current fashion it would look like this
36:33 - right and actually if we have that then
36:36 - point equals is essentially equal to
36:38 - deep equals if you think about that
36:40 - because if i put both of these at the
36:42 - same time you can see i mean what we do
36:44 - is simply that we take one x here
36:47 - one y here we pass the x here and we
36:51 - pass the y here so
36:53 - we're just applying that function so so
36:56 - then it's really it's the same thing
36:57 - like we don't even have to take any
36:58 - arguments we can make it point free and
37:00 - and that's the reason i'm complaining
37:01 - about this like point point equality is
37:04 - nothing special like i want to say that
37:06 - the x point equals the x point and the y
37:08 - point equals the y point of the two of
37:09 - the two things or not the point i mean
37:11 - the the x property of point one equals
37:14 - the x property of point two and the y
37:16 - property of point one equals the y
37:18 - property of point two like that's the
37:19 - check i want to make but that's just a
37:21 - check of equality so that's why i'm
37:23 - saying like that's a bit silly and that
37:24 - was disappointing but i think it was
37:26 - just overkill to implement deeper
37:28 - quality a function of deeper quality in
37:30 - in the base library but at least now you
37:32 - know anyways let's move on so so then we
37:34 - have a bunch of boolean methods right so
37:36 - so what i mean here is i mean a bunch of
37:38 - functions that take some particular or
37:40 - potential arguments but also also the
37:43 - the current state and then given the
37:44 - current state answers questions so the
37:47 - questions that we want to have answered
37:48 - is whether the snake will eat upon the
37:52 - next update given the current state and
37:55 - whether the snake will crash
37:57 - given the current state in the next
38:00 - update so if we have this current state
38:02 - and we have a list of moves so we have a
38:04 - list of left right up down etc given the
38:06 - next move and the current state will the
38:08 - snake crash that's that's the things
38:10 - that we're asking here and then this
38:12 - thing is of course as we talked about
38:14 - before whether a particular move is
38:16 - valid but that's before we enter the the
38:20 - move into the state so i mean maybe we
38:23 - could have done it in a way we could
38:24 - have just blindly added moves into the
38:26 - state and then have a function that
38:28 - computes a a clean state without any
38:31 - invalid con consecutive move
38:33 - combinations or without any any sort of
38:36 - inverses in the list of moves but but i
38:38 - chose to do it this way maybe the other
38:39 - way would have been more elegant but so
38:41 - you pass a move first and then you pass
38:43 - a state and then it says yes if this
38:46 - move is okay given this state so if it's
38:49 - okay to add this move to this state and
38:52 - the way we do this is just that we say
38:54 - okay well so let's think about this we
38:56 - do logical or between this thing and
38:59 - between this thing right so let's just
39:01 - let's put these uh like this just
39:04 - temporarily so that we can think about
39:05 - it right so we're doing the same thing
39:07 - twice we're saying either either
39:08 - something holds for for the x-axis or
39:11 - something holds for the y-axis or for
39:13 - the y direction and if either of these
39:15 - hold then it's a valid move and what
39:17 - needs to hold is that the uh x velocity
39:21 - of the move
39:23 - of the of the last stacked move of the
39:26 - of the next move that we have when when
39:28 - we add that to the new move that we want
39:31 - to add that needs to be different from
39:33 - zero so so what we're saying is that if
39:35 - we are moving in x minus one then if we
39:39 - add one to that then that would give
39:42 - zero because if we're moving in this
39:43 - direction and then we add one so one
39:46 - would be this direction that would be
39:48 - the polar opposite of that thing or of
39:51 - that direction similarly if we're moving
39:53 - one and we add negative one we get zero
39:56 - because we're if we're moving in this
39:58 - direction and we add this direction then
40:01 - these cancel out and we get zero right
40:03 - and that's the scenario that we don't
40:05 - want
40:06 - where we're crashing into our own head
40:08 - but we're saying that either the x-axis
40:11 - needs to be different or the the y needs
40:12 - to be different i mean since you can't
40:14 - since you can't move diagonally yeah
40:16 - this is in some sense probably overly
40:18 - complicated because clearly if the
40:20 - y-axis has a value then x will be zero
40:23 - and if the x axis has a value or if the
40:26 - x direction has a value then the the y
40:28 - will be zero so there's probably a more
40:31 - simple implementation that you could you
40:33 - could look for so let's go backwards by
40:34 - putting this back on one line and then
40:36 - let's look at the next stuff actually
40:38 - before we go any further let's let's
40:39 - look at the stage right so initial state
40:42 - let's go here i mean we said previously
40:43 - that there's a function called initial
40:45 - state that returns the initial state
40:47 - that all of the other states are sort of
40:48 - built from so in the initial state we
40:50 - have just a few things right we have
40:52 - some number of columns and some number
40:54 - of rows and th these are just in order
40:56 - to i mean maybe it's not the best place
40:58 - to store these because they won't change
41:00 - or they shouldn't change over the over
41:01 - the course of the game but maybe if you
41:03 - would think in terms of levels then
41:04 - maybe this could actually change but who
41:06 - knows but then we have a list of moves
41:09 - and the initial in the initial state we
41:11 - start with east in the list of moves as
41:13 - you can see right like when we refresh
41:15 - the game we always start from the same
41:17 - position here
41:18 - and we always start by moving east
41:21 - and that's because the default move is
41:23 - east and we can't see here because the
41:26 - default snake is empty but what happens
41:29 - after a crash is what causes the snake
41:31 - to start at 2 2 but we'll see that later
41:33 - and then we start with the default apple
41:35 - actually at 16.2 so maybe that should be
41:38 - a random position but for some reason i
41:40 - chose to put it there so again you can
41:42 - see that the apple always starts here so
41:44 - we'll always automatically catch the
41:46 - first apple right by just leaving the
41:48 - snake to do its thing so that's the
41:50 - initial state but let's now jump back
41:53 - now now you know sort of what that
41:54 - contains and of course the snake thing
41:56 - right like we were saying the snake is
41:58 - is an array and it is an array of
42:00 - positions or points right so things that
42:03 - look like this right that have an x
42:05 - coordinate and that have a y coordinate
42:06 - and this is why we're saying point equal
42:08 - or this is why i said point because we
42:10 - call these these things that have dot x
42:12 - and dot y we call these points so yeah
42:14 - actually so let me jump down i think
42:15 - it's actually easier just just to follow
42:17 - along from down here instead instead of
42:19 - going line by line because the order
42:21 - wasn't superb so let's actually just
42:23 - look at the next method here instead so
42:25 - when we looked at the web implementation
42:27 - if we go oh sorry to webjs here you can
42:30 - see we talked about how we call how we
42:34 - call the next function here right when
42:36 - we step the game we say the new state is
42:39 - equal to the old state ran through this
42:43 - the next function and the question is
42:45 - what does the next function do well the
42:46 - next function is i make use of this
42:49 - library method called spec which the
42:51 - library ramda i think they call it apply
42:53 - spec or something like that but i just
42:55 - called it specs so you can see spec is a
42:57 - fairly interesting method it has this it
42:59 - has this slightly tricky implementation
43:01 - where it takes an object and then it
43:04 - takes some value and then it grabs the
43:07 - keys out of this object and maps over
43:09 - the keys constructs a new object from
43:13 - that key and runs the function that
43:16 - hides under that key applies that
43:18 - function to this x that we passed to
43:21 - this value that we passed and then it
43:22 - reduces over
43:24 - merge so it simply merges all of these
43:27 - different different objects that it
43:29 - produced into a single object and that's
43:30 - a pretty complicated way of saying that
43:33 - essentially what we do here let me just
43:35 - i mean if i if i retype this
43:36 - implementation we could retype it as
43:38 - that let's think about it next is a
43:40 - function that takes a state and returns
43:43 - a new object where the new object if i
43:46 - had a spread syntax i could say is the
43:48 - old state right plus or actually let's
43:51 - not use this person let's be explicit so
43:53 - take some state and and and returns a
43:55 - new object where rows is equal to state
43:58 - of rows calls is equal to state dot
44:01 - calls
44:03 - moves is equal to
44:05 - next moves while being past the state
44:09 - and snake is snay a next snake being
44:14 - past the state and apple is next apple
44:19 - being past the state
44:21 - so that's essentially that's essentially
44:23 - what we're doing and actually i mean if
44:25 - we would express this in function syntax
44:27 - as well these first two just to make it
44:29 - clear uh really that why we can use spec
44:32 - in this lower implementation is because
44:35 - this is essentially then just using the
44:37 - prop method that we talked about before
44:39 - so if i say prop here
44:42 - pass row yes sorry like this right i
44:44 - pass these props as a string and then we
44:47 - pass the state as the second argument
44:50 - and sorry i'm using curried or functions
44:52 - that allow partial applications we
44:54 - actually need to invoke the function
44:55 - like this so that would be the same
44:57 - thing and now if you look at that right
44:59 - if you look at that implementation you
45:00 - can say okay well actually
45:03 - next is a function that takes some state
45:05 - produces a new object where the state
45:09 - needs to be passed to all of the
45:11 - functions or rather i should say it
45:12 - produces so next is a function that
45:14 - takes some state and produces a new
45:15 - object where this new object contains a
45:17 - bunch of keys and to determine the
45:20 - values under all of these keys we need
45:23 - to execute a few functions but these
45:26 - functions they are not nullary we need
45:28 - to pass them some arguments and the
45:29 - argument that we need to pass is
45:31 - essentially the state like if you line
45:34 - this up you can see all of them are past
45:37 - the state so essentially what we did is
45:39 - just that we we sort of made it point
45:41 - free we remove this portion notice how
45:44 - we do this we remove this boop and then
45:46 - we say okay all of these need to be past
45:50 - state okay but that's that's why we have
45:52 - the spec method so then we say spec
45:55 - and then we pass state here
45:58 - okay that's that's also the same thing
46:00 - but then we're back into the scenario
46:02 - that we looked at before where it's like
46:03 - well well actually next is now a
46:05 - function that invokes this this function
46:08 - spec by just passing the x that we pass
46:11 - it right like next is a function that
46:13 - takes an x and runs another function
46:16 - through that x or over that x and then
46:18 - we don't even need to specify the x we
46:20 - can just we just remove the state here
46:23 - like we remove the explicit call and
46:25 - then but then we remove this explicit
46:28 - variable here and then we just say next
46:30 - is the running of spec over these
46:32 - functions and then we pass it some
46:34 - states so
46:36 - i mean
46:36 - i would argue that this is more clear
46:38 - but yeah i'm totally empathetic too if
46:41 - you have a different opinion like as
46:43 - soon as you start to learn a few of
46:45 - these really common functional
46:47 - programming i wouldn't say patterns but
46:49 - like functions essentially these these
46:51 - common functions that we tend to use all
46:53 - the time like constant and id and map
46:56 - and reduce and pipe and compose and i
46:59 - would argue for dynamic languages this
47:02 - method is like super common uh or this
47:04 - function spec or or apply spec is super
47:06 - common so when you start to recognize
47:08 - these i actually think this becomes the
47:10 - easier version to read but there's a
47:11 - whole discussion about whether point
47:13 - free is is sensible or not i can shoot
47:15 - some links in the description if you're
47:16 - interested in that but anyways let's
47:18 - move on so that's that's the next method
47:20 - and we've all already talked about
47:22 - enqueue what enqueue does is essentially
47:24 - that you pass it a state and you pass it
47:26 - a move and if the move is valid then you
47:28 - merge the move into the list of of
47:31 - current moves that you have stacked up
47:32 - right so so the reason we're stacking
47:34 - them up by the way is that if you think
47:35 - about it what we can do oh sorry let me
47:37 - collect
47:38 - a few of these just to get a tail
47:41 - but what we can do is that we can stack
47:43 - moves
47:44 - like
47:46 - this if i just mash the buttons sorry
47:48 - now i have a tail now i can do this okay
47:50 - so if i just mash the buttons and then i
47:52 - let go let's see if this works
47:55 - let's not crash
47:57 - i just mash the buttons and i let go you
47:59 - can see that we've stacked a few moves
48:01 - and the reason we do that is because of
48:04 - if you've ever played this the game of
48:06 - snake you see
48:07 - like literally in this scenario right
48:09 - like now i just want to go right down
48:11 - for example like immediately right and
48:13 - then immediately down and then i can
48:15 - just queue down after right so i just
48:17 - press write down and then i've cued it
48:20 - so like if we didn't do something like
48:21 - this maybe we wouldn't be able to get
48:24 - both of them in actually now that i
48:26 - think about it that would probably work
48:27 - still
48:28 - i don't know maybe you have some opinion
48:30 - opinion about that i mean what wouldn't
48:31 - work is this sort of stacking but then
48:33 - again this stacking isn't necessarily
48:35 - super useful i assume but anyways let's
48:37 - get back to the code that was the
48:38 - original intention of why i did it as a
48:40 - list so yeah that that's enqueue so
48:43 - we've talked about in queue we've talked
48:44 - about next we've talked about initial
48:46 - state and what we i guess what we should
48:48 - do now is just talk about well first
48:50 - let's talk about these so the next state
48:52 - is computed from the old state right and
48:54 - rows when we do prop rows and prop calls
48:56 - as we looked at in the other
48:57 - implementation that just equates to the
48:59 - same value like we just say this value
49:02 - is whatever the old value was but
49:03 - however next moves let's actually look
49:05 - at the next moves right so let's search
49:06 - for cons next moves right and what this
49:09 - does is that it says okay it takes some
49:11 - state and and remember so what it the
49:13 - intention is that it takes the whole
49:15 - state but the intention is that it
49:16 - should produce only the list of moves
49:18 - right so it takes the hole and it
49:20 - produces the part so we take the state
49:22 - and then we say okay
49:24 - state.moves.length is greater than one
49:26 - so so we say if we have more moves than
49:29 - one then we should drop the first move
49:33 - right so so drop first is a function
49:35 - that i've defined here in the base drop
49:37 - first which is i mean it's trivial we
49:38 - just call a slice on an array slice and
49:41 - then pass one but i just did this
49:43 - to make it more readable right because
49:44 - now we can actually like very easily see
49:46 - what it does so we say drop the first
49:48 - from state moves or if the if the length
49:51 - of the the moves list is not greater
49:54 - than zero right so so if we have only a
49:56 - single move left then it will simply be
49:59 - a state of moves so what this means is
50:02 - that if we have more than one move we
50:04 - will drop the the first move because
50:06 - we've used it like in the next in the
50:08 - next state we won't have this this uh we
50:11 - won't have the first move left because
50:13 - we've now used it but if we have only a
50:16 - single move then we shouldn't do that
50:18 - because we want to keep repeating that
50:19 - move right that's how we're achieving
50:21 - this effect where it just keeps moving
50:23 - right i mean i'm not touching anything
50:25 - but it just keeps it just keeps moving
50:27 - to the right so that's because we we
50:29 - keep that in and and of course let me
50:31 - just quickly mention again that you can
50:33 - using functional programming you can
50:34 - make a lot of things point three point
50:36 - one and point two i've also kind of
50:39 - mixed this this sort of object-oriented
50:42 - dot syntax with this function syntax
50:46 - where you truly like truly have a
50:47 - function and then pass the data and i
50:50 - i'm a bit disappointed about myself for
50:51 - doing that but anyways i mean i just
50:53 - figured let's stay pragmatic but
50:55 - probably like here you we should do
50:57 - something like this like length of state
51:00 - that moves because this this dot syntax
51:02 - is fine because this is purely data but
51:04 - then length is a function on that but
51:06 - but this is a sort of give and take i
51:08 - mean i don't think we're going to be
51:10 - able to get away from this anytime soon
51:11 - in javascript because like maybe my
51:13 - terminology is a bit shaky here but if
51:15 - you've tried haskell for example like
51:17 - you have ad-hoc polymorphism and you
51:20 - have parametric polymorphism and ad-hoc
51:23 - polymorphism is kind of like
51:24 - polymorphism and object-oriented
51:26 - programming and so so the so the thing
51:29 - in haskell is that you can actually
51:30 - define a length function that takes some
51:32 - data and then does different things
51:34 - depending on the type of that data
51:36 - that's a bit tricky in in a language
51:38 - such as javascript because we don't have
51:41 - ad-hoc polymorphism in that way the way
51:43 - we achieve ad-hoc polymorphism is
51:45 - through object-oriented polymorphism is
51:47 - is by saying that length is a function
51:50 - that exists on an object and in in a
51:53 - dynamically typed language such as
51:55 - javascript we say well everything is a
51:56 - duct type right like if it quacks it's
51:58 - it's it's a duck so everything that
52:00 - responds to length is lengthable but
52:03 - which implementation of length you get
52:05 - depends on which object you call the
52:07 - method length on so i mean it's a give
52:10 - and take like we probably have to mix
52:13 - these two types of syntax before we have
52:17 - facilities for ad hoc polymorphism that
52:19 - looks a bit more like something like
52:21 - haskell in javascript which probably we
52:23 - maybe won't because maybe i'm not
52:26 - realizing how difficult that would be to
52:28 - implement in a dynamic language but
52:29 - anyways now we're way out of the zone so
52:31 - so so let's get back into this game but
52:33 - i just wanted to mention that that i'm
52:35 - completely aware that that's it's not
52:37 - it's not superb anyways how do we
52:39 - compute the next position of the apple
52:41 - well if this is where we get to this
52:43 - we'll eat that we talked about right
52:44 - like if the snake will eat the apple
52:47 - given the current state then we need to
52:50 - spawn a new position and that's when
52:52 - we're using this r d pulse that we
52:54 - talked about that's that's the that is
52:56 - the function in this snake library that
52:58 - is impure or actually i mean then next
53:01 - apple becomes impure because it's making
53:03 - use of an impure function but whatever
53:05 - so if the snake given the current state
53:08 - will eat the apple then we need to spawn
53:10 - a new position for the apple based on
53:12 - the current state if it's not right if
53:15 - it's not if the snake is not going to
53:16 - eat the apple then the apple will
53:18 - maintain in the maintain its position
53:20 - that the new position for the apple will
53:22 - be the same so so let's actually for the
53:24 - fun of it i mean let's actually do the
53:25 - same thing in both of these cases right
53:27 - like we have the cases where it will eat
53:28 - and we have the case where it won't eat
53:30 - so let's change the won't eat case to
53:32 - also uh spawning a new apple at a random
53:35 - position and then if we refresh this and
53:36 - run this again you can see that it's
53:38 - absolute and total madness right because
53:40 - now we have
53:42 - the apple is sort of respawning at new
53:44 - locations regardless of whether we're
53:46 - eating the apple or not so actually i
53:47 - mean i don't know the probabilities here
53:49 - but it's probably i have no idea whether
53:50 - it's higher or lower but like it's a
53:52 - very tricky game to play so this is
53:54 - surely not what we want then and and
53:56 - then also for the fun of it let's try
53:57 - the other thing like let's say instead
53:59 - of when we eat an apple that's spawning
54:01 - it at around a position let's just spawn
54:02 - it at the same position let's say that
54:04 - the the new position of the apple is the
54:06 - same as the old position of the apple
54:08 - regardless of whether we ate it or not
54:09 - then we can see that what happens is
54:10 - that we don't spot a new apple right the
54:12 - game works fine but we can just like
54:16 - hands off and then just leave it like
54:17 - this because we're just going to eat all
54:19 - the apples until we crash
54:20 - actually it's probably still tricky
54:22 - again because the snake will take up all
54:24 - the screen and then it's going to be
54:25 - tricky to eat the apple but anyways i
54:27 - mean clearly what we want is a random
54:28 - position so we want is this like we
54:30 - spawn a new position when we eat the
54:32 - apple and again that was like this is
54:34 - some of these things are very easy to to
54:36 - think about when you have immutability
54:39 - like i would imagine that going back and
54:41 - forth between these two changes would be
54:42 - more difficult if you had it would
54:44 - potentially be more difficult if you had
54:46 - mutable state depending on how you add
54:47 - structure you caught clearly next thing
54:49 - let's let's move the next head right so
54:51 - next head uh well let's think about it
54:53 - this way we have next snake and we have
54:55 - next heads maybe these should be in the
54:56 - other direction right so so and i think
54:59 - next snake was called in the next method
55:02 - here right so yeah so we're saying snake
55:03 - is equal to next snake so if we go back
55:05 - to next snake here and next snake makes
55:08 - use of next head so let's actually talk
55:11 - about next snake first so let's first
55:13 - think about the snake right
55:15 - look at this like let's actually grab
55:17 - one more apple here so now so now we're
55:20 - a snake of three dots right if you look
55:22 - at it now we're four but so so the snake
55:25 - is a list
55:28 - of positions
55:29 - and now it's a list with four elements
55:32 - that each have positions
55:34 - and i think if i'm not mistaken i will
55:37 - have to see either the first element or
55:40 - the last element in the list is the head
55:43 - of the snake so what we do is that we
55:45 - just when we need to move the snake we
55:48 - remove one element in the end and then
55:50 - we add one element in the beginning and
55:52 - when we eat right think about it look at
55:54 - what happens when we eat
55:56 - then we the snake is prolonged so what
56:00 - happens is that we add one in the front
56:03 - but we don't remove one in the end or i
56:05 - shouldn't say we add one in the front
56:07 - what i mean is we do compute the next
56:09 - position of the head but we don't remove
56:12 - one from the tail right so we have the
56:14 - snake here and then we're saying okay if
56:16 - you if you're not eating we should just
56:18 - take the snake and move it here but if
56:19 - you're eating then we should take the
56:22 - head and move it here but this tail
56:23 - should be fixed we should not remove
56:25 - anything from the end because it's this
56:27 - removing that makes that gives the
56:29 - appearance of it moving right because
56:30 - it's actually that we we remove this
56:32 - thing maybe it's easier maybe if we just
56:34 - think about one daughter like if you
56:36 - have one one dot like one one one snake
56:38 - head then what happens when we're not
56:40 - eating is that we're just saying okay
56:42 - remove this boop and make another one
56:44 - here and that gives the appearance of
56:46 - moving right
56:48 - and then
56:49 - and so forth but if we're eating we're
56:52 - saying create the new one right you have
56:54 - one here create the new one but don't
56:56 - remove this one right so so we give the
56:59 - appearance of prolongation and not of of
57:02 - or of extension and not of of moving of
57:05 - course it's moving as well but but
57:06 - anyways so that's the way that we
57:08 - structured that by the way i mean i
57:09 - tried this in multiple different
57:10 - approaches i also try i mean it's an
57:12 - interesting game because you can also
57:14 - approach it by building up a grid and
57:16 - then sort of making operations on that
57:18 - grid so like you have a two by two uh
57:20 - array like a matrix but anyways maybe if
57:23 - you if you try out the solution along
57:24 - those lines maybe again shoot something
57:26 - in the comments that would be
57:27 - interesting to look at so
57:29 - to compute the next snake what do we do
57:31 - well what we do is that we have two ifs
57:33 - we have two nested if so we say okay if
57:35 - the snake will crash right given the
57:37 - current state given the current
57:38 - direction given the current world if in
57:41 - the next state that we are now computing
57:43 - will the snake crash or not like if it
57:45 - will crash then the next snake is going
57:47 - to be an empty raid then we're going
57:49 - back to this sort of initial state thing
57:51 - we're saying let's go back the snake is
57:53 - an empty ray however if the snake won't
57:56 - crash we do any of these things and if
57:57 - it won't crash we're asking this well is
58:00 - it so that the snake is eating because
58:02 - if it's eating then what we want to do
58:04 - is just that we want to add the next
58:08 - head we want to compute the position of
58:10 - the next head like we did here with the
58:11 - hands right like we have one we have
58:13 - this we have a snake here and we want to
58:14 - add the snake here or we want to move it
58:17 - here right and if it's eating we just
58:19 - want to compute this new position and
58:20 - then we want to concat that into uh the
58:23 - current or with the current snake
58:25 - however if it's not eating then we need
58:28 - to move it or we need to give the
58:29 - appearance of moving that means we can't
58:31 - just compute the new position but we
58:33 - also need to drop the last position so
58:36 - we need to remove something from the end
58:38 - and let's just think about whether it's
58:40 - it's in the head or not so what we're
58:42 - doing is that we're saying that the head
58:43 - is an array and then we concat that with
58:46 - the old snake yeah so what we're doing
58:47 - is that we're adding into the beginning
58:49 - right so we're not it's not that we're
58:50 - pushing in positions into the end of the
58:53 - snake but it's more like we're adding at
58:55 - index zero and then we're shifting all
58:57 - of the other ones uh backwards so i
58:59 - haven't at all thought about performance
59:01 - and efficiency but i mean clearly there
59:03 - are probably multiple ways you could
59:04 - improve this code but so that's what
59:06 - happens when we're when the snake is
59:08 - eating we are adding a new head but
59:10 - we're not removing the tail and if it's
59:12 - not eating we're adding a new head and
59:15 - we are removing the tail so actually i
59:17 - mean if we if we remove this drop last
59:20 - just to try this out right then we're
59:22 - saying it's going to get longer all the
59:24 - time so if we run this now you can see
59:26 - just like it's it's never ending like it
59:28 - doesn't matter if we eat or not the
59:30 - snake is just growing and growing and
59:32 - yeah that was tricky for me to handle
59:34 - but as you can see right like the snake
59:36 - just keeps on growing and growing and
59:38 - growing again like a trivial thing to
59:40 - change but we go back to uh to actually
59:43 - dropping the mast and of course if we
59:44 - did drop last here as well just to be
59:47 - exhausted let's try that as well that
59:48 - would mean that even if we are
59:50 - collecting apples nothing happens like
59:52 - the snake isn't actually prolonged
59:56 - so of course what we want is that
59:58 - like this okay that's the next snake but
60:01 - then okay
60:02 - as we were saying next next next snake
60:04 - makes you some next head so the question
60:06 - is how do we compute the next position
60:09 - and that's actually pretty interesting
60:10 - right so let's look at next head so
60:11 - again next head the structure is that it
60:13 - takes a state and it produces a single
60:16 - position right so think about it i mean
60:18 - next snake takes a state and produces a
60:22 - list of snake positions next head takes
60:25 - the full state and produces a single
60:28 - position that represents the head of the
60:30 - snake and what it does is that it it too
60:33 - has to ask an if question and the if
60:35 - question that it asks is that do we
60:37 - currently have a snake or not right like
60:39 - if the length is zero like if you look
60:41 - here right uh
60:43 - as we talked about in in next snake of
60:45 - course when we crash we completely wipe
60:47 - out the snakes so that we don't have a
60:49 - snake so when we compute the next head
60:51 - it might be that we're trying to compute
60:53 - the next head from from no snake at all
60:55 - so this is why we're asking is the
60:56 - length zero because if it is zero then
60:59 - this we want is like the default start
61:03 - position maybe i should have had that as
61:04 - a comment or something like that
61:06 - actually if you look at it if we refresh
61:07 - here you can see that this supposedly is
61:10 - 2 2. ah actually let's think about it
61:12 - that means so x 3 and y 3 if you start
61:15 - from 1 so this is why i mean maybe one
61:17 - would assume that it's here but actually
61:19 - this is 1 1 because this is 0 0. so here
61:22 - it's 0 0 one one and then two two so uh
61:26 - so yeah we start at two two all the time
61:28 - and that's essentially because when the
61:31 - length of the snake is zero then we
61:32 - spawn at two two and again i mean we
61:35 - could do r and d let's say r d pulse
61:38 - uh given the state
61:40 - yeah that should work as well then we
61:42 - are starting at random positions we're
61:44 - always starting going east but now we're
61:47 - spawning it at random positions we're
61:49 - spawning the snake at random positions
61:51 - but i i figured this this makes sense i
61:53 - mean it's kind of nice to start from
61:55 - from two two and also it's obvious that
61:56 - you've crashed so that's what happens if
61:58 - the stink is zero like if it's the
62:00 - initial case but if we do have a snake
62:02 - like if if the length of the snake is
62:04 - currently longer than zero what do we do
62:07 - well this i found pretty cool we create
62:09 - a new position that has an x and then
62:12 - that has a y of course and what we do is
62:14 - that we take the i mean think about how
62:16 - these two look very much the same right
62:18 - like x and y is essentially the same
62:20 - thing but what we do is that we say the
62:22 - x position is the current x position of
62:26 - the snake of the of the current head of
62:28 - the snake right what's in the zeroth
62:30 - position
62:31 - plus
62:32 - the x of this move that we've stacked
62:35 - the next move that we want to grab so so
62:37 - the the move that is pending the move
62:40 - that it that we're supposed to execute
62:41 - now and remember like the moves that we
62:43 - can have are are any of these north
62:45 - south east west east west west so if we
62:49 - have east stacked right as in the
62:50 - default case then then x will be one so
62:53 - what we're saying here is that we're
62:54 - saying
62:55 - uh state dot is snake so we're taking
62:58 - taking the state position snake position
63:00 - and supposedly if we start at two
63:02 - uh at as we've defined as the sort of
63:04 - default start position here so if we
63:07 - start at at two and then we say plus and
63:10 - we add one because east is one so the
63:13 - default direction is one then we get
63:15 - three right because the current head is
63:19 - at two two or if we only think about the
63:21 - x position the current head is at at x
63:23 - two and then if we add one we end up in
63:26 - x3 right and that's actually the next
63:28 - head now the question that and of course
63:31 - maybe what we should mention is that
63:32 - this of course works for negative as
63:34 - well so if you have if the position is
63:36 - two and you add negative one then you
63:38 - get one because you're moving in the
63:40 - other direction
63:41 - and the reason then that we have this
63:43 - mod thing is that we're making use of
63:45 - the modulus operators so actually i mean
63:47 - in the best of worlds i wouldn't have
63:49 - had to write that i i
63:52 - should have been able to write something
63:53 - like let's think about this so so this
63:56 - so the same calculation mod
63:58 - uh state dot calls that that's the way i
64:01 - i wanted to use like we want to use the
64:04 - the mod operator but apparently the
64:06 - modulus operator in javascript behaves
64:08 - differently than i had expected in
64:11 - regards to negative numbers but think
64:13 - about it the reason we use modulus here
64:15 - is that because we want to have this
64:17 - wrapping effect right like notice how
64:19 - when we go out of the right end of the
64:21 - screen like it's a torus right we go out
64:24 - on the right end of the screen and we
64:25 - show up on the left end and similarly if
64:28 - we go out on the left hand we show up on
64:29 - the right and and and that modulus
64:32 - operator is actually everything that's
64:33 - needed to implement that because what
64:36 - we're saying is that if the grid let's
64:37 - say that the grid is 12 like right let's
64:39 - think of a clock so if i'm not sure if i
64:42 - can do mod here actually so
64:44 - if i do 10 yeah i can't okay so let's do
64:47 - it in google so so if we do 10 modulo 12
64:51 - for example we get 10 because so so let
64:55 - me be more clear so so if 12 is the
64:58 - width of the grid and we're talking
65:00 - about the exposition let's say so the
65:01 - number of columns that we have to work
65:03 - with is 12 and that means that 0 is an
65:06 - okay position 11 is an okay position 12
65:09 - is not an okay position so if we do
65:13 - 0 12 modulo 12 that means that it's the
65:17 - zeroth position so what i mean is that
65:20 - 12 is the size of the grid
65:22 - and 0 is the position that we want to
65:26 - position the next head in if we don't
65:29 - think about this wrapping around right
65:31 - like then you could say
65:32 - position
65:34 - 316 right like even if you have a grid
65:37 - of 12 actually i mean we could do that
65:38 - that's that's the point of modulo so if
65:41 - we do
65:42 - 316 modulo 12 that means that if you try
65:45 - to move to position 316 you should
65:48 - actually be at position four because
65:51 - you've wrapped around you've looped
65:52 - around multiple multiple times but if we
65:54 - just think about the edge cases right
65:56 - like zero yields zero so that means the
65:59 - zeroth positions that means we're not
66:01 - changing zero and if you do 12
66:04 - you also get 0 because 12 modulo 12 like
66:08 - 12 divided by 12 gives a remainder of
66:11 - zero so that also puts you back in in
66:13 - position zero which makes sense because
66:15 - we're saying it's zero indexed right so
66:17 - so because we have the zero index the
66:19 - max index is 11. so when we try to go to
66:22 - 12 we should wrap around back to back to
66:25 - zero so maybe i'm not making a superb
66:28 - job of explaining this but but every
66:30 - number then between 0 and 11
66:33 - inclusive will be the number that we
66:36 - pass so if we pass 2 we get 2 if we pass
66:39 - 3 we get 3 if we pass 4 we get a 4 and
66:43 - so forth but if we pass higher numbers
66:46 - which happens when we are at position 11
66:50 - and we pass one right so or we add one
66:52 - right so this is more like the scenario
66:54 - that we have we are at position 11 we
66:57 - pass one and then we do modulo 12 of
66:59 - that so that gives us 12 that we do
67:01 - modulo 12 on and that gives us zero that
67:04 - makes us wrap around back and
67:07 - let's let's jump into note quickly and
67:08 - look at this so actually i should have
67:10 - done this in notes from the beginning
67:12 - so so 10 modulo 12 gives us 10 uh 10
67:16 - right and but 12 modulo 12 gives us zero
67:19 - which wraps us around backs similarly 13
67:22 - then gives us one but this is a case
67:23 - where that we're never seeing however
67:25 - what i would want is that negative 1
67:29 - should also wrap so negative 1 should
67:31 - put us in the other end of the 12 and
67:33 - that's the way i was expecting that that
67:35 - modulo was behaving so let's see can we
67:37 - actually can we require
67:40 - the base library from here so let's try
67:43 - to require base oops sorry
67:46 - base equals required oh sorry because i
67:48 - now i declared it twice but messed up so
67:50 - let's restart jump back into nodes so
67:52 - let's require the the base library
67:55 - sorry i'm such a confused person so
67:58 - let's jump into node and let's say const
68:00 - base is equal to require from the
68:03 - current directory the file called base
68:06 - let's just be specific and say dot js
68:08 - right and that works then we have the
68:10 - base library and base i mean the base
68:12 - area that we've defined in this project
68:13 - and base has the function mode right so
68:16 - this
68:17 - mod however works differently i mean it
68:20 - works the same if you pass 10 and 12
68:22 - again then you get no sorry it's the
68:25 - okay sorry for for other reasons i did
68:26 - it in the other order so here i pass uh
68:29 - so this if i pass it this way i mean 10
68:32 - modulo 12 then we get 10. if i pass 12
68:36 - we wrapped around to zero similarly for
68:39 - 13 but again we never end up in that
68:41 - scenario but now if i pass negative one
68:43 - we wrap around in the other direction
68:45 - and end up at 11 and modulo 2 and so
68:48 - forth so so yeah and that's a different
68:51 - implementation of of modulo uh and i
68:53 - think i left a comment here yeah i left
68:55 - a comment here to link that you can
68:56 - check out if you're interested in the
68:58 - source i think that came from a stack
68:59 - overflow post or something like that so
69:01 - anyways that was those
69:03 - one of these moments where you go like
69:04 - ah excellent
69:07 - like it's awesome when when math can
69:09 - make problems that seem a bit tricky to
69:12 - solve in programming and
69:13 - but math makes them trivial those are
69:15 - the good days right but anyways so
69:17 - that's why we do modulo here so what
69:20 - we're saying is that this is the raw
69:22 - quotation marks the raw new position and
69:25 - then we say take that position and do
69:28 - modulo of of the the size of of the rows
69:32 - or the colds depending on which one
69:33 - we're working with so that we wrap
69:35 - around but yeah that's that's next head
69:37 - and so next snake is is based on on that
69:39 - next head essentially and yeah the
69:41 - randomness here we've talked about the
69:43 - initial state we've talked about next
69:45 - we've talked about enqueue we've talked
69:47 - about oh my god we actually talked about
69:48 - everything now so yeah i think we've
69:50 - talked about everything and that sort of
69:52 - covers it in in getting to the point
69:54 - where where the snake game is operating
69:56 - uh something like this because we also
69:59 - looked at the the web html and js file
70:02 - and of course i mean i also have this
70:04 - web.css file with just some basic
70:07 - styling in order to make this look a bit
70:09 - prettier i mean if we remove i'm not
70:11 - even sure like if i remove this stuff it
70:14 - looks like this right i've actually
70:15 - zoomed in so this is the this is what we
70:17 - actually draw on the canvas but this is
70:19 - just some basic styling that i added in
70:21 - order to make it look like this
70:23 - but yeah that's it before we wrap this
70:25 - up let's actually also look at the cli
70:28 - so the command line interface so i'm
70:30 - opening up cli.js right and let me just
70:33 - map a keystroke here in vim to run node
70:36 - on
70:37 - cli.js or to run cli.js through node so
70:41 - if i just hit that we're running this
70:43 - and again you can see this works fine
70:46 - and actually i mean this is a pretty
70:47 - short implementation as well so the game
70:50 - loop is a bit different here we still do
70:52 - this sort of showing and stepping but
70:54 - what i do is i set an interval yeah so
70:57 - what we do is we make use of set
70:59 - interval right which is this function in
71:01 - javascript that calls a function with a
71:04 - regular interval it's also expressed in
71:06 - in milliseconds but here actually i run
71:08 - it every 80 milliseconds so yeah for
71:11 - some odd reason i chose a different
71:13 - interval for the terminal application
71:15 - maybe we should change this to 100 in
71:17 - order to sort of make it have the same
71:19 - speed but
71:20 - never mind i mean that we can trigger
71:21 - the change but essentially what this set
71:23 - interval does is that it it does these
71:25 - two things right if we pass a function
71:28 - to set interval that first calls step
71:31 - and then calls show and actually i mean
71:33 - now that i think about it what we could
71:35 - have done is we could have said pipe
71:37 - step
71:39 - step and then show like so over 80
71:43 - and that should be the same that should
71:45 - be the same thing right and actually
71:47 - that didn't work and i think it has
71:48 - something to do with like the console
71:50 - log here or something like that so like
71:52 - the context disappears but never mind
71:53 - let's not think about that now and
71:55 - either way i mean piping here is not
71:56 - necessarily a sensible thing to do
71:58 - because a step and show are are mutating
72:01 - functions or there are functions that
72:03 - like i mean compose and pipe we usually
72:05 - use when we actually want to pipe
72:07 - compose functions like because we're
72:08 - actually passing data through now we're
72:10 - just do saying do this thing and then do
72:12 - that thing so like never mind but
72:13 - anyways so set interval what it does is
72:15 - that it calls step and then it calls
72:17 - show and it does that every 18
72:20 - milliseconds and what show does let's
72:23 - start with the show right so so both of
72:24 - these both show and step or functions
72:26 - that don't take any arguments and show
72:28 - what it does is that it console logs
72:29 - this strange character which works as a
72:32 - clearing right like if you think about
72:33 - it actually if i if i remove this i
72:35 - think that would be the most simple way
72:37 - of describing this like if we remove
72:39 - this and then redraw you can see that
72:41 - the game works right but if i if i
72:44 - scroll out
72:46 - you can see we have multiple versions of
72:48 - the game where the the lower one this
72:50 - one here in the bottom uh this one is is
72:53 - the active one because that's the
72:55 - freshest one the the other ones are
72:57 - histories and actually we are we are
72:59 - printing and printing and printing so
73:01 - it's not like it looks static but it's
73:02 - not actually static i mean it's like a
73:04 - moving like these old animated movies
73:06 - like where you draw where wherever where
73:08 - you pull past the strip of multiple
73:10 - images and that's actually exactly what
73:12 - happens now like this is a strip of
73:13 - multiple images anyway sorry let's stop
73:15 - thinking about that now it's pretty
73:17 - interesting but um if we if we add that
73:19 - character we keep clearing the screen
73:21 - all the time so that we're just it's
73:22 - it's like clearing the canvas so that's
73:24 - that's the first part part of show like
73:26 - we clear and then what we do is that is
73:28 - that we have these uh
73:30 - these functions on the object matrix
73:32 - right so so here you can see we have a
73:34 - comment that says matrix operations and
73:36 - then following that there's a constant
73:38 - called matrix which is sort of a module
73:40 - with a bunch of functions that operates
73:42 - on matrices and actually i mean i use
73:44 - the word matrix here indicatively like
73:46 - it's not actually truly a matrix but
73:48 - what we have is that we have an array of
73:50 - an array like we have a two-dimensional
73:52 - array where the first i think first i do
73:55 - rows and then i do columns or maybe the
73:57 - other way around uh so anyway the the
73:59 - things under matrix under the matrix
74:02 - module are then things that operate on
74:04 - on this type of structure uh so what we
74:07 - do is essentially then that we say okay
74:08 - matrix dot to string of
74:11 - mate matrix dot from state
74:14 - given the current state so here we
74:15 - probably could actually use pipe in a
74:17 - sensible manner so what we're doing is
74:19 - that we're saying yeah pipe
74:22 - matrix
74:24 - matrix from state and then matrix two
74:28 - string and we're piping that through the
74:31 - state
74:32 - ah so this is probably the reason why i
74:34 - didn't do this because the line turned
74:36 - out to be longer like if you compare the
74:38 - two lines this is actually longer but
74:41 - that should work fine as well and like
74:44 - if we run that
74:45 - that doesn't work fine oh sorry my bad
74:48 - this is probably why the other thing
74:49 - didn't work as well we're not using a
74:51 - raid syntax i should pipe like that yeah
74:53 - sorry so that's probably why the other
74:55 - thing didn't work as well no
74:57 - maybe didn't have anything to do with
74:58 - the console log but anyways uh so yeah
75:00 - we could use a pipe there instead but as
75:03 - just said i mean even
75:05 - even if i remove that sort of array here
75:08 - you can see that this line is longer and
75:09 - i just figured never mind let's just do
75:11 - this but anyways both of these things
75:13 - are equivalent but yeah maybe maybe this
75:14 - one is more clear so maybe let's keep
75:16 - that one i guess i didn't because of the
75:19 - length of the lines like you can see
75:20 - we're at 88 we're at column 88 but
75:23 - anyways let's keep it like that for now
75:25 - so so that's show so what it does is
75:27 - essentially it clears the screen it says
75:30 - construct a matrix from the current
75:33 - state remember the state is the same
75:35 - kind of state that we used in the web
75:37 - gui right like that's what we're saying
75:39 - like we use the same state tree but we
75:42 - do different things based on the state
75:44 - tree and thus we can show a command line
75:46 - interface and we can show a web
75:48 - interface so from this current state we
75:51 - we produce a matrix and then we take
75:53 - that matrix and we pass it to two
75:55 - strings so what we do is that we produce
75:57 - the matrix and then immediately we turn
75:59 - that matrix into a string so actually i
76:02 - mean maybe you could argue that i've
76:04 - made it unnecessarily complicated in
76:06 - some way and maybe we should find a way
76:07 - which is more similar to the web
76:09 - approach where we sort of just
76:10 - immediately do what we or display what
76:12 - we want to display but to me this seemed
76:14 - like the easiest approach like having
76:16 - this intermediate data structure that's
76:17 - this matrix like thing because i mean if
76:19 - you think about it we print this pretty
76:22 - much as as a matrix right like this is
76:24 - this has a number of rows and it has a
76:26 - number of columns and actually if we
76:28 - look at two string here in the matrix
76:30 - module you can see that this is where it
76:32 - becomes obvious that it's fairly trivial
76:34 - because two string takes i wrote x's x's
76:37 - here because like usually in functional
76:38 - programming you can you will see people
76:40 - say like x's or s's or something like
76:43 - that to indicate that you have an array
76:45 - of something so you have an array of x's
76:48 - here but i i tend to write x's x's i'm
76:51 - not sure if that's conventional i hope
76:52 - that's conventional because it seems
76:54 - sensible to indicate that it's an array
76:55 - of an array of x of x's so and that's
76:59 - why i say x is x is here on the outside
77:01 - and then x is here on the inside so the
77:03 - way this works is that we map over the
77:06 - the outer array and then for every inner
77:09 - array we join up all of the values with
77:12 - a space if you think about it you can
77:14 - see here that there's a space in between
77:16 - there's a space in between all of the
77:18 - different dots like if we didn't have
77:20 - that space uh probably this one yeah
77:22 - this actually does work right this
77:24 - doesn't look very nice also because
77:27 - columns are a lot narrower than than the
77:31 - rows so so we need that extra space in
77:33 - order to sort of make it look a bit more
77:35 - nice so we join it up with space and
77:37 - then we join up each of these rows with
77:39 - a backslash r backslash n which is
77:41 - essentially a line break so that we can
77:42 - print it as a single string that that
77:45 - sort of looks like a grid
77:47 - and actually i just realized i used to
77:49 - have a 0.3 or not a 0.3 version of this
77:52 - but rather a version that's more similar
77:54 - to the make function here where instead
77:56 - of actually calling map on the axis of
78:00 - x's we say map and past the axis of x's
78:03 - because i guess that could be more
78:05 - elegant than this but anyways there are
78:07 - multiple ways you can rewrite this
78:08 - function and some of them are probably a
78:10 - lot more elegant than the way i've
78:12 - written it now but anyways that's the
78:14 - two string function and of course if we
78:17 - think about this method again like what
78:18 - we're saying is that we first do from
78:20 - state and then we do two string so we
78:23 - start with this from state and then we
78:25 - do two strings so from state what that
78:28 - does is that it creates one of these
78:30 - excess of x's it creates one of these
78:32 - grids or one of these matrices uh
78:35 - containing the appropriate values and
78:37 - how we do that is essentially by piping
78:39 - right we say well we need to pass this
78:41 - state so we take the state as an
78:43 - argument and then we pipe it through a
78:45 - few functions but the first function
78:46 - makes the matrix the second function
78:48 - adds the snake to the matrix the third
78:50 - function has the apple and the fourth
78:52 - function adds a crash if there is
78:54 - supposed to be any crash so again these
78:56 - are sort of immutable methods in order
78:58 - just to keep my head straight in this so
79:00 - matrix.make we can see up here right the
79:02 - matrix that make here i called it table
79:05 - and not state because a table is
79:08 - anything that has calls and rows but i
79:10 - mean actually what we will pass is we
79:12 - will actually pass this date but
79:14 - since we only care about the calls and
79:15 - the rows i figured i'd call it table
79:17 - here and what we what make does is
79:19 - essentially that we use this helper
79:21 - function rep right so if we look at the
79:22 - base library uh cons rep here we have
79:25 - the implementation of rep and what rep
79:27 - does is that it takes a constant and
79:28 - then it takes an n and then it maps this
79:32 - constant using the function k which is
79:34 - the const function over the range from 0
79:37 - to n so this sounds a bit bonkers but
79:40 - what this actually means is that if if
79:42 - you have actually let's let's jump into
79:44 - node and let's look at this so a const
79:47 - base is required
79:51 - right and then we have the base library
79:52 - and then we can say
79:54 - base dot
79:56 - rep and if i say a
79:59 - and then i'll pass 10
80:01 - you can see that we get 10 a's if i get
80:03 - past three we'll get three a's right
80:05 - then if i instead of a if i have one
80:07 - here i'll i'll essentially get an array
80:09 - with this thing repeated the number of
80:11 - times
80:12 - as the second argument that we're
80:14 - passing and rep was implemented in terms
80:17 - of range and what range does is just
80:19 - that let's see if i can remember the
80:21 - syntax if we do this right then we get a
80:24 - range from 10 to 20 we get an array of
80:26 - all the elements of 10 to 20. so what we
80:28 - were doing is that we were mapping over
80:29 - that range in order to have an array of
80:32 - multiple elements and what we were
80:34 - mapping is that we were mapping the
80:36 - function k
80:37 - of
80:38 - the the constant that we were passing so
80:41 - when we did base dot rep a 10 here up in
80:44 - the beginning for example then our
80:46 - constant is a so if i say k
80:49 - of a then i have oh sorry bass dot k
80:53 - then i have a function that accepts an
80:55 - argument but it doesn't care about which
80:57 - argument it it's passed regardless of
80:59 - what argument is passed it's going to
81:01 - respond with a and that's how we can
81:03 - when we map so so actually let's let's
81:05 - do that manually like if i have that
81:07 - range from 10 to 20 and then i map over
81:11 - that and if i map k of a we will replace
81:16 - oh sorry base k in base.k
81:18 - we will replace all of the values in the
81:20 - rearray with a
81:22 - and that is essentially the way that a
81:24 - rep works and yeah i guess range and k
81:28 - as well and and map but
81:30 - anyways so that's why we do rep rep here
81:34 - so so i think it's it's pretty
81:36 - interesting i mean what we do is we
81:37 - repeat the repetition of period or this
81:41 - the string period over the number of
81:44 - columns that we have in this table we do
81:46 - that for every row that we have in this
81:49 - table so that's a pretty concise
81:50 - implementation of making a a
81:52 - two-dimensional array filled with dots
81:55 - right so that's the first thing we do we
81:56 - make the matrix based on the state
81:59 - we make the matrix from the state but
82:02 - then here we have these three functions
82:05 - that we want to use to add additional
82:07 - things to this to this matrix we want to
82:09 - change particular we want to adjust
82:11 - particular cells in this matrix and note
82:14 - how we're passing states to these
82:16 - because essentially
82:17 - this one
82:18 - only requires the state to be passed
82:20 - once but these actually require the
82:22 - state to be passed twice so we'll invoke
82:24 - them like this so add snake is a method
82:27 - that can be defined only when we know
82:30 - what the state is and this i mean i was
82:33 - struggling a bit with this i think this
82:35 - didn't turn out super nice so if you
82:37 - have any suggestions of how to rewrite
82:39 - this properly super interesting if you
82:41 - want to post anything about that i was
82:42 - toying with the idea of probably using
82:44 - the s combinator or converge or
82:47 - something along these lines but probably
82:48 - we could find out more sensible ways of
82:50 - expressing this but anyways what we do
82:52 - essentially is so add snake what it does
82:54 - is that when given some state it will it
82:57 - will produce a function that's
82:59 - essentially a pipeline where we spread
83:02 - the mapping of setting x or rather i
83:06 - should say spread the result of mapping
83:09 - the value x over the snake so
83:12 - essentially this is the thing about it i
83:13 - mean this looks a bit hairy but like but
83:14 - actually it's not that strange i mean so
83:16 - the thing about it like the snake in the
83:18 - state is an array it's an array of
83:20 - positions so what we do is that we map
83:23 - the function of setting x and setting x
83:28 - in the matrix takes a particular
83:29 - position and so by mapping that we get a
83:32 - a list of functions
83:34 - that we then spread over this piping so
83:37 - we spread it into arguments so we make a
83:39 - function that went past a state we'll
83:42 - run that state or sorry not when past
83:45 - the state when past a matrix we'll pass
83:47 - we'll run that matrix through a bunch of
83:50 - matrix dot set transformations that set
83:53 - sets x at that particular position and
83:56 - if you look at set i mean set is also
83:59 - fairly straightforward what it does is
84:01 - that it takes a value and then it takes
84:03 - a position and what it does then so the
84:05 - position is then a point right maybe i
84:06 - should have said points or something
84:08 - that has an x and y and it calls adjust
84:11 - on the y
84:12 - or adjust at the y position but then
84:15 - passes the adjustment of the x position
84:19 - of the constant of the values so so what
84:22 - we do i mean actually i mean if we if we
84:24 - express this in a less strange manner
84:27 - actually
84:28 - what this is is that we're saying well i
84:31 - mean if we would do this in a mutating
84:32 - fashion uh what it does is that it takes
84:35 - another argument because it's point free
84:36 - right so so it takes it also takes the
84:38 - matrix and what we do is that we say the
84:40 - matrix
84:42 - uh of the position y
84:45 - and then position
84:46 - x is equal to the value and then we
84:49 - return the matrix like
84:52 - and then we return the matrix so that's
84:54 - essentially what what the set method
84:56 - what the set function does but but now
84:58 - we're mutating and so now we're trying
85:00 - to do that without mutating and when
85:02 - doing that we also got rid of the matrix
85:04 - variable here and and of course adjust
85:06 - is a function that we defined here uh in
85:09 - in our base base helper library but of
85:11 - course it's also available in a lot of
85:13 - different libraries and what adjust does
85:15 - is simply that it takes an n which is an
85:17 - index it takes a function and then it
85:20 - takes some kind of collection some x's
85:22 - and what it does is that it changes it
85:24 - runs the function at the index n of the
85:28 - x's right so so it's a way of if we go
85:31 - back here right like if we say uh list
85:35 - index
85:36 - equals value or more specifically if we
85:39 - say function over if we run a function
85:42 - over the value at that index right
85:45 - that's what what this version of adjust
85:47 - does and then and then we pass k here
85:49 - because we're not actually interested in
85:51 - running a function over the value we
85:52 - don't care about the old value we just
85:53 - want to replace it with a new value so
85:55 - that's kind of a
85:56 - general version of of adjust and yes so
85:59 - so this we do in order to to so
86:01 - essentially what set does is that when
86:03 - given a value when given a position and
86:06 - we're given a matrix it produces a new
86:08 - matrix that looks like the old matrix
86:10 - but where the value at the position has
86:13 - been updated to the new value and that's
86:16 - essentially what we do with set right
86:18 - and so that's why we use it in in add
86:20 - snake and we also use it in add apple
86:22 - and actually not add crash because here
86:24 - we did a more simple implementation i
86:26 - guess but yeah that's how we use it in
86:28 - add snake the way we use it in add apple
86:30 - is much more simple much more simple
86:32 - then we just simply say matrix.set and
86:35 - we set uh to an o at the position of the
86:38 - apple right so state that apple contains
86:40 - a position and we're just saying matrix
86:41 - that's set at that particular position
86:43 - right so i mean this we could change to
86:45 - an a and then if we run you can see that
86:47 - we now have a's instead of o's that
86:49 - represent the apple uh so that's the
86:51 - apple and then the crash is very simple
86:53 - here we just say that okay if the snake
86:56 - length is zero in other words if we
86:58 - don't have a snake if we've crashed or
86:59 - if we just started the game then we map
87:02 - the mapping of the constant dash
87:06 - so over this grid
87:08 - think about it the grid is a list of
87:09 - lists so over every column or row
87:13 - depending on which order we structured
87:14 - anything maybe it's row so over every
87:16 - row we map but we map the function that
87:19 - is the mapping of every column and over
87:23 - that we map the function k which is
87:26 - constant that returns regardless of what
87:29 - it gets it returns whatever we passed it
87:31 - and what we passed it in this case
87:32 - happens to be this dash symbol or this
87:35 - this pound sign this uh hashtag and
87:38 - that's only what we do if we if we don't
87:41 - have a snake so if we've crashed but if
87:43 - we hadn't crashed then we passed id and
87:46 - why do we pass id because id is the
87:47 - identity function so that means that
87:49 - well if we haven't crashed then the grid
87:51 - needs to stay the same if we didn't do
87:53 - that let's just say let's say we did
87:55 - this in both of the cases so instead of
87:58 - doing id we do this mapping again
88:01 - then it'd be a constant crash like we're
88:03 - just it looks like constant we're
88:05 - actually just redrawing this constant
88:07 - and recomputing this constant all the
88:08 - time but yeah so so that's why we need
88:10 - to to pass the id and if we didn't do
88:12 - this this mapping of pound that wouldn't
88:14 - be the end of the world it would just
88:15 - not be obvious when we've crashed so
88:17 - what we want to do is visualize like
88:19 - like we did in the web right like here
88:21 - when we crash we have the screen sort of
88:24 - turns red like that right and here in
88:27 - the terminal we want we want every
88:28 - position to be replaced by a dash and
88:30 - that's that right that's so these are
88:32 - the matrix operations that we have we
88:34 - we can make a matrix we can set
88:36 - something in the matrix we can given
88:38 - some state produce a function that when
88:40 - given a matrix adds that snake to the
88:42 - matrix similarly for the apple and
88:44 - similar for a crash similarly for a
88:46 - crash and then we can take a matrix and
88:48 - turn it into a representable string and
88:50 - then here we have the from from state
88:53 - function that essentially first makes a
88:54 - matrix adds a snake adds an apple and
88:57 - adds a crash all in order so that we can
89:00 - simply just call that from from over
89:02 - here uh in our game loop when we want to
89:05 - show
89:06 - okay that's that's show then we also
89:08 - have step but step is super trivial
89:11 - similarly if we go up here into the top
89:13 - like similarly to the web right like if
89:15 - we go back to web.html you can oh sorry
89:18 - not so web.js you can see here in the
89:21 - top that we have this mutable state
89:22 - where we say that the state is equal to
89:24 - initial stage for some reason i chose
89:25 - lowercase as since uppercase as here
89:28 - that makes no sense but in the cli here
89:31 - we have a variable called state which is
89:33 - which starts as the initial state from
89:35 - the snake and that is the mutable state
89:38 - and the reason that that's mutable is of
89:40 - course that we need to listen to these
89:42 - key events so i'm not gonna bother you
89:44 - about how this listening to keys work
89:47 - but this seems to be i like the way we
89:49 - do it in node when we want to listen to
89:51 - key presses so we capture what's in
89:53 - standard in and if we happen to press
89:55 - control c we need to exit the process
89:56 - because people need to be able to exit
89:58 - the program but if not then i'll just do
90:01 - two upper on it so so we don't have to
90:03 - worry about lowercase w or uppercase w
90:06 - and then we just look for wasd as as in
90:08 - the webcase right and hjkl and we look
90:12 - for up left down right arrows and what
90:15 - we do is actually the same thing let's
90:17 - let's look at this
90:18 - so yeah so the state is equal to
90:22 - the enqueuing of the old state and the
90:26 - new move and then we break and this is
90:28 - the same thing as we had here in the web
90:30 - where we said okay nq
90:33 - based on the new state this new move and
90:36 - compute a new state from that and and
90:38 - replace the mutable state with this new
90:41 - state that's computed and that's the way
90:43 - we do that and yeah i guess i guess
90:45 - that's pretty much it so to do that read
90:48 - line we needed to read in the base note
90:50 - library read line it seems that there
90:52 - are other ways of doing it but this
90:53 - seems to be the easiest way so yeah it
90:55 - kind of seems like that's it it seems
90:58 - like a lot of cold in some sense right
91:01 - but if you think about it what i would
91:03 - argue and what i would argue is that
91:06 - what we've done is that the snake
91:08 - implementation is actually only this
91:10 - file it's actually only snake.js
91:13 - like this is this is the implementation
91:15 - of of snake the other stuff regards how
91:18 - to display the snake game like what
91:21 - graphics version or engine
91:23 - you want to use your snake with what gui
91:25 - you want to use your snake game with so
91:27 - which way you want to display snake to
91:29 - the user and which way you want the user
91:31 - to interact with your snake game so
91:33 - again like if we think broader than game
91:35 - programming functional programming is
91:37 - really susceptible to modularity and
91:41 - so what i mean is when you produce small
91:44 - functions you can really quickly feel
91:47 - how they become very composable and very
91:50 - reusable but yeah i mean but if you
91:53 - actually know exactly what you're
91:54 - building and you know that you're not
91:56 - expecting any change and you have a
91:57 - strict specification then yeah maybe you
92:00 - don't need to be worried about change
92:02 - but if you are worried about change like
92:03 - if you're building an application that
92:04 - might change over time or if you're
92:06 - building something that might be shipped
92:08 - to multiple platforms then approaching
92:09 - something even like game programming
92:11 - kind of like we've been approaching it
92:13 - today i think actually makes a ton of
92:14 - sense what do you think let me know in
92:16 - the comments and let's discuss beyond
92:18 - that if you thought this was interesting
92:20 - and if you want me to decompose any
92:21 - other games let me know like tetris or
92:24 - pong or whatever i mean shoot something
92:26 - in the comments either way clearly this
92:27 - code can be improved a lot but hopefully
92:29 - you find something useful as we dove
92:31 - through this piece of code yeah i'm
92:34 - christopher i'm the guy that you just
92:35 - saw in this video i hope that you liked
92:38 - the video and i really hope that you
92:39 - felt that you learned something if you
92:41 - did like the video i would suggest that
92:43 - you check out my youtube channel
92:45 - the link to my youtube channel is in the
92:47 - description so
92:48 - thank you again very much for watching
92:50 - and i hope to see you in another video
92:52 - either here on this channel or over on
92:54 - my channel i'll see you in the next one

Cleaned transcript:

in this video i want to take you through this snakelike game that i've built using javascript and more precisely javascript in functional style or in functional programming styles so with the focus on purity small functions and composability so as you can see here now i'm running this snake game in the browser and ah you can see also there that i actually crashed sorry my camera is in the way so i can't really see what i'm doing in the snake game so but but this is the browser implementation and because i i tried to put the focus on modularity it was kind of trivial to make one sort of gui for the browser and then another gui for the terminal so if we jump over here to this side you can see if i just look at where i'm at now i'm in a folder called snake where i have a few files and what we're looking at here in in the browser is this web.html file but what i can also do is i can run this cli.js file through node and then we can place snake in the terminal so if we if we run cli through node you can see that we now get snake but in in sort of terminal mode let me make this a bit bigger so the x's represent the snakes the dots are the grid or that's traversable and the olds are the apples that you need to to eat in order to become longer and the interesting portion is of course or the interesting part is of course that this runs on the same quotation marks engine like we've separated the game engine from from the visuals of the game which is generally what we should do right we should separate presentation from the business logic so my interpretation of most of these snake tutorials or actually game tutorials that you find on the interwebs is that they are focused on just getting a quick version up and running quickly essentially but what i want to do as i tend to do with all of these videos is instead talk about design so i'm by no means saying that this is a perfectly designed snake game at some point i just said okay never mind let me just drop this make this video and i'll leave it to you guys to hopefully improve upon this game and make it even better or rather i should say improve upon this code and make this codebase even more modular and elegant that would be fantastic so if you do have comments please do shoot those in the comments or or if you do fork off from this code base and make changes please do post your changes in the comments that would be really interesting to read but anyways when we focus on modularity we can again trivially achieve this kind of thing where we have one implementation for the terminal and one implementation for the web which uh of course if we generalize this notion what we're talking about here is that you might have a single core and then multiple different implementers of that core or users of that core so that might mean that you could have let's say a multiplayer portion of your game or you might expose your game through an api or you might make an ios version and an android version and a web version of your game and so forth and now i'm saying game but actually we're talking about applications right so generally what i usually want to talk about is is design of programs is how we keep programs alive over longer periods of time and how to to increase modularity and so in some sense then this game is just an example of that but but anyways you could also just see this as how to build snake using functional programming in javascript let's get going so let me cancel out of the game here and let me make this full screen okay so again let me just show you uh the files that i have in this folder here so the main snake implementation is in this file called snake.js that's sort of the core library or or the the game engine in some sense and then these three files web.css web.html and web.js that's essentially that's essentially the web interface for the snake game so that's what we were looking at when we were playing in the browser those three files and then this cli.js file that's the uh node implementation that's that's what we're looking at up here right that's the terminal gui for through which you can play this snake game and then finally this bass.js is some base function so essentially when doing functional programming as i've talked about in other videos we tend to pass data last and we tend to have functions that are curried so we tend to have functions that are partially appliable but of course javascript doesn't work this way so that's why i implemented a few functions myself such as map and etc and of course like if you would build an extensive game you would probably use a thirdparty library such as for example ram.js or another library implementing the fantasyland specification but for the sake of this video i really wanted to keep everything selfcontained i don't want to use any thirdparty libraries and this is why we have some code in this base in this base file but then of course we have this readme file just because i've put this up on github and by the way you can find the link to all of the code in the description i might have moved it elsewhere but the link in the description should work let's actually start by looking at the web end so let's start with web.html so let me open vim and then let's open web.html and as you can see i mean this is clearly just any old normal html file where we we are loading in the the style sheet uh here i'm doing some funky stuff i'll explain that in a moment but then in the body we have a canvas setup that's uh of a size 700 and of a height or over width 700 and of a height 500 and then i'm loading these script tags and maybe it's maybe people nowadays always load their scripts here and then make sure that the dom is loaded in the scripts files i was just lazy and put them here to ensure that when i load uh this web.js the canvas has definitely loaded but yeah that's a completely different discussion but anyways you can see here that i'm loading in the base library then i'm loading in snake and then i'm loading in web.js so so clearly i mean this is because i don't have a build system set up where i don't have a build process set up so i mean clearly if you were building this and actually shipping this on the web you would you would probably somehow like minify all of your all of your files into a single main.min.js file right and you'd only load that and that would do everything so you would come construct a single javascript file from all of your other javascript files but now this is just a simple example so let's not bother with that right so then we're loading in the base library and the base library will expose a bunch of cons globals or it will essentially define a bunch of functions that are available on the global scope and uh same thing for snake and then web is the actual machinery of this web implementation or i shouldn't say the machinery is the is the actual main entry point of this web application and then let me just quickly explain this i mean this i do let me actually let me open up a split here and open up snake.js in order to show you that so snake.js because i i started with the the cons with a command line implementation actually from the beginning i was thinking that i only should do the command line implementation but then i figured actually it's so easy to make another web implementation so let me just make a web implementation as well i'm a big fan of trying to keep it as absolutely simple as possible from the beginning and this is why i was so actually i started building this snake.js file and and and i started doing it in a sort of stepbystep fashion where i implemented one function at a time where it's like okay this function needs to be able to do this right so like if we have a list of snake points and we want to compute the next snake point given a movement in some direction what would that function look like right and then i did that step by step for for all of the different pieces and then sort of from the ground up build the the snake implementation but anyways i because i did this i want to make use of the module system in node so you can see here in the end that i say module dot exports and then i export a bunch of actually first constants and then three functions and same thing goes for this base libraries if we go to this base library here you can see that this base library exports a bunch of functions so clearly module.exports is not available in uh the browser if you're in a similar scenario with some production code you should of course look into something like browserify or maybe there's something more modern now but but but now i mean we just do it we can just hack it up so so i just simply said that in the global scope i said that require is a function that returns an empty object right and module is an empty object and module dot exports is also sorry so so let me also say i mean i said require here but i said that the problem in in this right hand was the module exports but actually we have so in snake for example snake actually does require right so so snake the snake implementation or the snake game engine depends on the base uh functions the functions in the base library the base library helper functions so here we make use of the word require so so the browser does not have the word require and the browser does not have the word module nor module.exports and when i say word i mean of course i mean keyword sorry um so anyways we just say that require is a function that returns an empty object module on the other hand is an empty object and module.exports is a function that returns an empty object just just to make them not fail right they're not doing anything useful and then i'm relying on the fact that i know that both sn base and snake and web are all defining the fun their functions like this right here's a function here here are a few other functions here a few other functions and so forth so so if i just run these this code in the browser they will be exposed as global functions so just a quick and hacky way of getting this to work but anyways that's the web right so what it does so you can think of this as that web is actually the entry point or web.js is the entry point and then web.js needs to first require base and then require snake and this is why they're in this order or actually i mean to be perfectly frank rather web needs to require snake and snake needs to require base that's actually the more proper way of saying it so that's that's web html let's let's now look at web.js right so so what does this actually do so we don't have a ton of lines here right let me just scroll through this file you can see here at yeah 53 here i'm saying i mean i added a comment here to say that this is the main portion right so let's actually start from this main portion so what web.js does so so the javascript that will be run in the browser when we run the browser version of the snake game right first we do draw so these are actually two lines right sorry i just i thought it was prettier to put them on a single line so first we do draw one initial draw and then we say request animation frame i don't actually really know what that is but it's something like well the next time the browser will redraw redraw using this function please or something along those lines so people who develop games tend to use these so window the request animation frame and then we pass the function step or the function that's returned by invoking step with zero and so importantly usually people do this right they pass a function but i'm actually invoking the function step because step when invoked will return a new function and the reason for that is to avoid one global or another global so so step needs to keep track of how much time has passed since the last step right because so if i'm not mistaken like i mean request animation frame might be called different times depending on the i guess frame rate or something like that of your browser or the frame rate that you can manage to get on your browsers like depending on the performance of your computer your the request animation frame will be or rather the function that uh we pass the request animation frame will be called with different intervals different time intervals depending on the performance of the computer that you're running it on so in every call to step we need to check the delta we need to check the diff between the current time and the last time we rendered and that's why i passed this first variable because here i'm saying then that or this first zero because i'm saying that the time since the last redraw was zero so we're saying let's instantly redraw so so here you can see then that here's the definition of the step method right so the step method or the step function i should say sorry it takes a t1 so time step one or time stamp i should say a timestamp one at a timestamp two and then it says okay what's the difference between timestamp two and time step one and if that's greater than a hundred and i don't really know let's think about this so i can't really remember but i assume this is in milliseconds so that would mean a hundred milliseconds right so a tenth of a second so every tenth of a second we enter this portion and all of the other times we enter this portion and now you can see how this works right because if we do enter this portion if there if if 100 milliseconds has passed since the last time we we updated or the last time we stepped then what we want to do is we want to say this state global this global state variable i'll get i'll get to this in a moment equals the next state given the current state right this is kind of typical functional programming right instead of doing mutation we're just saying that we have this global state variable global i mean you don't you shouldn't have a global state variable but like but i mean in this case it happens to be uh to be global but essentially the point is containing your state into a single variable and then passing that state through a function that produces the next state right from that given state so instead of saying well here's my state here are the actions that i want to do let's change all of the variables so that it matches the new state because then some things are more difficult to reason about because we have mutation all over the place instead we say well here's the old state let me pass you that and then if you compute what the next state would look like given that old state well then i then i know what to do with that right so that's what we're saying state is this this state variable and we say next is a function from snake from the snake engine and when we pat and when we pass state to that it will compute the next state and then we will set this set the state here this mutable state here to this new state and then we will do draw right and draw i haven't even bothered about trying to make immutable in any kind of sense because like like the canvas libraries or they're like the canvas and apis of browsers or like there's tons of there's tons of mutations that would be extremely painful maybe there is a way to do that if you have an idea of how to do that please do shoot something in the comment that would be or in the comment section that would be very interesting to read about anyways so so that's for the if branch or for the true case right for the false case what happens well in the false case or in other words when enough time hasn't passed 100 milliseconds hasn't passed since the last time we updated then we simply do my camera is in the way i can see but but we simply do the same thing or we say or rather i should say we don't compute the new state and we don't redraw importantly but we do request another animation frame and and to that we tack on uh or or we throw in a function that's that says step again from t1 so notice the difference between this line and this line right in in this line we have t2 and in this line we have t1 t2 and t1 and t2 here is because we want to have the new point that the current timestamp as the as the next time step that we want to compare again so it's like as the as the next time step that we want to say has a hundred milliseconds pass from this time stamp right that's what we want to do when we do redraw but when we don't redraw we want to compute from the old timestamp we want to say well you started at timestamp zero and now 50 has passed 50 is not enough so keep on keep on waiting but you should compare against zero and not against 50 because if we if we keep updating this if we keep changing this to t2 here if i said uh t2 here we would never redraw right or maybe in the odd case if it's like it's super laggy or something like that right but but assuming we have good frame rate then then we would essentially never call this and that'd be problematic so this is why we're saying t1 and of course i mean maybe this wasn't clear but what request animation frame does is that it passes a timestamp and that is this t2 then and i don't actually know i mean it's not it's not like it's a date because we start from zero but maybe it's something like the time since the the this browser session was initiated or something like this i mean this since the page was rendered i should maybe say but anyways i mean i have no idea so don't take my word for that but that's that's the update method but actually let's go up to the top here because i feel like what i what i didn't say is this that the state variable that we talked about is defined here so so notice comment that says mutable state so this is so this is the state variable that contains the state of the game at all times and it's global quotation marks like it's it's shared across all of these functions in this file and and what you can do is is that the functions or actually the functions don't there are two functions that change it i should say right there's the there's the step method that changes it but there's also this key events thing like there's this listener for key events and that thing also changes the state right so actually let's let's look at that uh at once right or wait first let's begin here in the top so so we can say okay so so we say let state is equal to the initial state and where does this initial state function comes from i mean this is the problem of working with globals it's very difficult to see where things are actually coming from since they're not actually scoped i'm realizing now maybe i should have scoped them so that instead of making these functions all functions in this file i could have put them inside an object and that would give us a name space here so that we could say snake dot initial state because that's kind of actually what we're looking at here like if you would use required you would get that for free but but anyways yeah i should have fixed that maybe yeah but anyways that's from the from the snake.js file so snake.js file has a function called next here right and we'll talk about this when we get to the snake.js file but but but suffice to say for now that the next function takes a state and computes the next state given that state oh sorry i was about to talk about initial state and not about next but that's that's next right that's what next does but if we look at initial state that's just a function it's it's a i think it's called a unit function like it's a constant in some sense so it's a function that takes no arguments so it's nullary and it returns uh an object that is essentially a state representation but it's the initial state so the initial state is essentially always the same so when you start a game you need to start from the initial state so yeah that's the way we invoke this this state variable now let's go back down here and let's now talk about these events so we say window dot so now my camera is really in the way add add event listener key down so that's the first argument and then the second argument is this function that takes a single argument which is this variable named e which is the event and then we can extract the key variable or the key property from that event and then we switch case over or over essentially that variable and then we say okay well we want to be able to control the snake using wasd the keys and h h j k l uh so here's the wasd and here is h j k l but then we also want to be able to use the arrow keys right so and depending on which one of these we press we want to compute a new state we want to say that the new state is what the old state was but plus quotation marks plus this new direction so these are constants north west south east these are constants that i've defined in this snake.js file where we have north and south and east and west right and these are essentially just i guess maybe you could think of them as vectors i'm not really sure but like they have an x direction and a and a y direction or a velocity in these directions right so north means moving zero x but negative one y that's the definition of north within the context of this game but but anyway so so we want to cue those in and we need to pass the current state because again remember the snake game has no clue of the current state that we have right it's it's uh actually i should say this it's pure except for that the snake snake.js file has some randomness right so here we have one function that does some random stuff and and i mean remember randomness is is impure because it relies on things such as system date and etc so given the same input you won't get the same output but i mean i was pragmatic here it's just thinking like there's no point trying to do something more complex here in my mind it makes sense for a function that computes a random position within a grid to be within the snake.js file and not elsewhere but anyways there are clearly solutions for that but i'm just being pragmatic but but essentially so so then the snake and q method needs to be passed the current state we need to pass the current state as we do here right and we need to do that because as we do here because again it's it's almost pure so it doesn't know what state we have it doesn't keep track of its own state and and q is also defined here in this snake snake method and again we'll get to this when we start to talk about the the snake stuff but essentially as you can see here it takes the current state and it takes a move it asks whether the move is valid and if the move is valid it does this if it's not it does that right so if it's not valid it just returns the same state it does it does no changes but if it is valid then it says okay we want to merge yeah we want to compute a new state that is the old state plus that this moves property has changed to the old moves concatenated with an array containing only this new move so this is an extremely complicated way of just saying append but immutably append the last move to the list of moves but we haven't even talked about the state tree so we'll get to that in more detail but that's that's in queue and this is sort of the basic game loop right like if you think about this game first from the from the main here we draw one initial time and that's sort of the the first drawing but then we say we'll start stepping from zero and then we keep doing the step method okay step and step and step and step and so forth and whenever we've it's been 100 milliseconds since the last step we compute the next state from the old state and then we redraw and then again we just keep on looping quotation marks keep on requesting animation frames so that's that's sort of update and draw but then there's also this other exogenous force that that can enter right like there are also key events like when the user types uh keys we listen to this and if you happen to type a key that's that's one of the arrow keys then we need to compute a new state so so then we're also saying well you need to set the new state to the old state plus this new key that's being pressed i would say that that's that's fairly clear again like the the benefits of mutation or the benefits of avoiding the mutation is that whenever you want to change things usually it's pretty easy to change things because you don't have to think about state so for example i'm not sure if you noticed but when we played this game well sir of course how could you have noticed it's not actually visible and think about that but the way the game worked from the beginning was that if i'm traveling in the direction west as i'm doing now and i press east right i'm traveling leftwards but if i press the opposite direction if i press east right or conversely if i'm traveling to the right and i press the left key so if i press the inverse direction or the opposite direction of the direction i'm traveling in i would instantly crash because it's like the snake is moving in this direction right and it's like it's it's immediately just going directly into its own tail right and some snake games actually did work this way and was extremely frustrating and that's what i noticed here as well like when i was playing this it just messed me up all the time because i kept on crashing when i wanted to try out the game so i figured okay let's actually remove that functionality from from my snake game and that's when i added this valid move portion to nq so previously nq used to only do this right it used to only just merge in whatever motion you you added into the queue of motions or into the queue of moves but now i said well actually let's let's avoid this sort of inverse situation so if you pass the inverse so that's what value move does it checks whether it's the inverse and if it's not the inverse yes then it's valid but if not if it is an inverse then then we will ignore it and we'll just pass the old state so we'll not cue the move right so it's these kind of scenarios that we often find ourselves in when we use immutability like when we realize okay would be cool if the game could do this or actually this is a this is a tricky thing let's let's not actually make it do this let's make it do that instead right and then we try it out and it actually turns out to be fairly simple most of the time but anyways okay so so so this is the whole this is the the web portion right we have we have the step function we have the event listeners we have let me here in the main let me just put that back on one line we have this main that that initiates it and then we haven't talked about what draw actually does right so as you can see here is the comment says game loop draw right so so this function draw and it's also pretty simple like as you can see from the comments here like i was contemplating separating this into multiple functions but given the mutable nature of the canvas library and like given the fact that we probably won't reuse this code i just figured whatever let's just make this let's actually just make this a long function that does does all of these things like one by one so what it does is that it it clears the canvas right so so ctx here is another global variable because yeah what to do right so so let's actually start from the top right so so the first line says okay let's let's make a constant variable called canvas and let's from the document get the canvas or let's get the thing that has the id canvas so if we look at the html thing you can see that canvas here actually has an id of canvas just to make it simple for myself right so so i i grab that canvas and then we get the context for that so that we can draw so so in ctx is is a context variable then we have these position helpers here we'll talk about these in a moment but what we do then is that we first clear this canvas by saying okay let's set the fill style to this uh like blackish color i guess and then we we draw a rectangle over the hole of the whole width and the height then the next step is that we draw the snake right so then we say let's set the fill style to something which is greenish and then let's map over the snake so so this is where it sort of gets interesting right because it's like the different graphics engines or the different gui's or the different sort of interfaces can have completely different ways of interacting with this stage right but but so the state exposes dot snake it exposes actually lots of things like like moves and apple and and so forth and so forth but but we're just going to make use of snake and of apple so what we do is just that we map a function over uh state.snake and so snake is an array of positions so it's it's or it's a it's a it's an array of points points being objects that have x and y coordinates and of course this is not an actual proper map because i don't care about the return results so this is actually more like a for each that actually mutates the canvas but map was a shorter word so whatever any in each of these iterations of the function what we do is that we say well using this fill style fill a rectangle in the context from this exposition this y position over this width and over this height and now you can see why these x and y methods and these x and y methods are just helpers for me to so that i'm not duplicating the same math all over this place so if you remember what we did was that we drew rectangles right so notice how the snake so every point in the snake or every uh piece of the snake or just think of the apples for example take up sort of one quotation marks pixel and pixel meaning uh like traversable pixel in this grid maybe i should say tile actually like it covers one tile and so what we do then here is that we compute uh the the the position of these tiles so x1 here will return the width of one tile and y one here will return the width of one tile and what happens when we do this y of some position is that if if the ycoordinate is zero then we'll put then it'll turn to zero right because if we look at the implementation of y here we say uh take the canvas height and divide it by the number of rows that we have in the state so like if the sorry i forgot to say that we have the r here as well right so so if r is zero r being the the y coordinate right so let's say that the y coordinate is zero then we multiply that with the height of the canvas and let's say that the height of the canvas is a hundred and then we divide that by let's say uh 20 which is the uh the number of rows let's say so the number of tiles in the y direction now this is not necessarily correct with in regards to this particular scenario but just hypothetically it makes sense then you can see that we get zero right because that's a zeroth position like that's the pixel that we actually want to draw from but if we take one we get five if we take two and we get ten and so forth and if we take 20 we get a hundred because like that's the that's the last pixel and actually 20 doesn't exist if we have 20. it's 19 would be the last one because it's height will also be 5 and then 5 will take it up to 100. but anyway so so those are just two helpers in order to to not have to duplicate that as you can see we use these x and y things here as well so that's the way we draw the snake and then we do that for the apple as well so we say okay here we don't have to actually iterate we just say fill rect at this x position at this y position using this width and this height right and the width and the height is the same because the apple is as large as a tile just ah as all of the pieces of the snake is is is as large as the tile but the position is based on the on the x position of the apple right so so the x position and the y position so we're saying compute the y position from this coordinate which is defined by state dot apple dot y and then finally we draw the crash so let's just think about so let's let's just look at that right like if i if i crash into my own tail notice how the screen flashes quickly red right or quickly flashes in red there you go right it quickly flashes in red and how we know that that has happened is that i decided that well if we don't have a snake in the game field that means that either the game is just started or there was a crash so actually if we just refresh the page you can see that it blinks red and maybe this is an unwanted feature and we should try to solve this but i just figured whatever let's just not think about that now so if there is no snake right so essentially then we're saying that if state.snake.length is equal to zero so if we don't have a snake then we should essentially draw this red rectangle over the whole screen right so that's the way we're indicating a crash and and that's the whole drawing thing and i i mean a moment to pause and reflect right like like the point here is that this is all graphics right like assuming that we can use this uh state structure for all of the graphics engines assuming that state tree gives enough information this can be completely focused on just the visuals right and and it is not sort of intermingled with all of the business logic so if we say ah actually let's change the color of the snake it's trivial to find the place where we can change the color of the snake or let's make the apples round it's trivial to find the place where we make the apples round instead and we don't have to worry about accidentally messing up some of the other core business logic because that's in a completely different place so we have to be really silly in order to mess that up so anyways that that's the draw that's the draw function and i think actually we've covered all of the stuff here here then right like first we just grab out the canvas we set up this mutable state that's based on the initial state we we construct these two position helpers that will make us position things in this uh grid or a visual grid in the browser and then we construct this draw function that will take the mutable state or based on the mutables they draw a bunch of stuff on the canvas and then we have this game loop that whenever it's called checks whether it has passed enough time in order to progress to the next state and and redraw or whether it should just keep on ticking and then we have these these listeners that listen for events or listen for keystrokes and produce new states based on these keystrokes where the new states contain the new keystrokes or contain the directions that we want to move in and then finally we have this this main that sort of just initiates and starts the whole thing up and of course i mean we didn't actually need this first uh this first draw here in the in the end right like the only difference if we have that or if we remove that you can see that there's a quick flash of 100 milliseconds where we don't have a board that's essentially the only difference and that's why i added that because then immediately we should get the board actually now that i think about it it's almost hardly visible like like you can see i mean loading the page probably takes quite some time anyway so so yeah i mean you might want to remove that okay but that's the web portion let's now actually look at the snake core library i think it's probably easier to start with that and then look at the the command line implementation so let's go to snake.js so again this is we we've glanced into this file a tiny bit but but not too much so i think actually there's too much code here right so let's start from the top let's just scroll through quickly first to get an idea like we have about yeah 61 lines of code and if you have ways of making this again more elegant and more concise not not concise as in cold gold pheasant just for the sake of conciseness but as in elegance then please do shoot something in the comments that would be massively interesting but what we start by doing is just requiring this base library that we've defined again as we've talked about with some helper methods i'm not sure if we actually ever looked at that but here's the base library right yeah we did quickly look at that but we just define a few a few functions such as for example map and as constant and identity and all that stuff but let's forget about that for now right but we load the functions from the base library and then we do this and this is kind of just me hacking again so i apologize for that but what i wanted to do is so base for example exposes the function map right so you have base dot map but whenever i use i don't want to have to say based on map i just want to be able to simply say map and refer to base.map because they are helper functions as i mean in some sense you could argue that that some of the functions defined in base here are functions that should be defined in javascript if javascript was actually aiming to be a functional language like so functions such as map or reduce are defined in the prelude of haskell so they're defined in the base library of haskell reduce is actually called fold in in in haskell but and not just that i mean tons of other methods such as identity and constant and lots of other things some of them are not like prop for example like because haskell is aesthetically typed language and and javascript is dynamically typed language so if we look at the base library here for example i define the helper method prop which essentially takes a key and then takes an object and extracts the value under that key from that object and it's trickier to define an aesthetically typed language actually now that i think i'm thinking about it actually it's completely defined upon aesthetically typed language it's just probably not as useful right because you're probably using static typing because it gives you benefits and when you're starting to use this sort of key value pair syntax this dictionary syntax then you are exposing yourself to runtime errors because you might end up in situations where the key doesn't exist but anyways that's tangential what i wanted to say is just that in javascript because of the dynamic nature of javascript some of the functions that we might want to put in the base library quotation marks make sense to put in the base library but might not be functions that we want to put in the base library in other languages but anyways this is total sidetrack that's why i'm doing this right just to expose all of those functions so i can say k and id and map and so forth and not have to say bass dot map and so forth so so that's that okay let's move on then we have these constants right these constants we've already talked about we need some way of talking about the different directions and maybe you could argue that these should be functions that or again like nullary functions that take no arguments and return this but anyways i just define them as constants then we have uh this point operation and actually i was thinking about this a while like this is not excellent because if you could check for deep object equality right like i think in many of the javascript libraries you can do that in many of the testing libraries you can so actually like object deep equals or or deep equality of two objects is actually a very useful thing to have in the language so actually i mean the implementation of point equals should essentially just like if you pass point one and you pass point two then the implementation should essentially be point one equals equals point two if if equality in in javascript was based on the deep structure of an object and not the the reference to that thing in memory or the pointer to that thing in memory but anyways i mean and even if it didn't look like this it should perhaps be the deep uh the deep equality between p1 and p2 and maybe if we do that in the current fashion it would look like this right and actually if we have that then point equals is essentially equal to deep equals if you think about that because if i put both of these at the same time you can see i mean what we do is simply that we take one x here one y here we pass the x here and we pass the y here so we're just applying that function so so then it's really it's the same thing like we don't even have to take any arguments we can make it point free and and that's the reason i'm complaining about this like point point equality is nothing special like i want to say that the x point equals the x point and the y point equals the y point of the two of the two things or not the point i mean the the x property of point one equals the x property of point two and the y property of point one equals the y property of point two like that's the check i want to make but that's just a check of equality so that's why i'm saying like that's a bit silly and that was disappointing but i think it was just overkill to implement deeper quality a function of deeper quality in in the base library but at least now you know anyways let's move on so so then we have a bunch of boolean methods right so so what i mean here is i mean a bunch of functions that take some particular or potential arguments but also also the the current state and then given the current state answers questions so the questions that we want to have answered is whether the snake will eat upon the next update given the current state and whether the snake will crash given the current state in the next update so if we have this current state and we have a list of moves so we have a list of left right up down etc given the next move and the current state will the snake crash that's that's the things that we're asking here and then this thing is of course as we talked about before whether a particular move is valid but that's before we enter the the move into the state so i mean maybe we could have done it in a way we could have just blindly added moves into the state and then have a function that computes a a clean state without any invalid con consecutive move combinations or without any any sort of inverses in the list of moves but but i chose to do it this way maybe the other way would have been more elegant but so you pass a move first and then you pass a state and then it says yes if this move is okay given this state so if it's okay to add this move to this state and the way we do this is just that we say okay well so let's think about this we do logical or between this thing and between this thing right so let's just let's put these uh like this just temporarily so that we can think about it right so we're doing the same thing twice we're saying either either something holds for for the xaxis or something holds for the yaxis or for the y direction and if either of these hold then it's a valid move and what needs to hold is that the uh x velocity of the move of the of the last stacked move of the of the next move that we have when when we add that to the new move that we want to add that needs to be different from zero so so what we're saying is that if we are moving in x minus one then if we add one to that then that would give zero because if we're moving in this direction and then we add one so one would be this direction that would be the polar opposite of that thing or of that direction similarly if we're moving one and we add negative one we get zero because we're if we're moving in this direction and we add this direction then these cancel out and we get zero right and that's the scenario that we don't want where we're crashing into our own head but we're saying that either the xaxis needs to be different or the the y needs to be different i mean since you can't since you can't move diagonally yeah this is in some sense probably overly complicated because clearly if the yaxis has a value then x will be zero and if the x axis has a value or if the x direction has a value then the the y will be zero so there's probably a more simple implementation that you could you could look for so let's go backwards by putting this back on one line and then let's look at the next stuff actually before we go any further let's let's look at the stage right so initial state let's go here i mean we said previously that there's a function called initial state that returns the initial state that all of the other states are sort of built from so in the initial state we have just a few things right we have some number of columns and some number of rows and th these are just in order to i mean maybe it's not the best place to store these because they won't change or they shouldn't change over the over the course of the game but maybe if you would think in terms of levels then maybe this could actually change but who knows but then we have a list of moves and the initial in the initial state we start with east in the list of moves as you can see right like when we refresh the game we always start from the same position here and we always start by moving east and that's because the default move is east and we can't see here because the default snake is empty but what happens after a crash is what causes the snake to start at 2 2 but we'll see that later and then we start with the default apple actually at 16.2 so maybe that should be a random position but for some reason i chose to put it there so again you can see that the apple always starts here so we'll always automatically catch the first apple right by just leaving the snake to do its thing so that's the initial state but let's now jump back now now you know sort of what that contains and of course the snake thing right like we were saying the snake is is an array and it is an array of positions or points right so things that look like this right that have an x coordinate and that have a y coordinate and this is why we're saying point equal or this is why i said point because we call these these things that have dot x and dot y we call these points so yeah actually so let me jump down i think it's actually easier just just to follow along from down here instead instead of going line by line because the order wasn't superb so let's actually just look at the next method here instead so when we looked at the web implementation if we go oh sorry to webjs here you can see we talked about how we call how we call the next function here right when we step the game we say the new state is equal to the old state ran through this the next function and the question is what does the next function do well the next function is i make use of this library method called spec which the library ramda i think they call it apply spec or something like that but i just called it specs so you can see spec is a fairly interesting method it has this it has this slightly tricky implementation where it takes an object and then it takes some value and then it grabs the keys out of this object and maps over the keys constructs a new object from that key and runs the function that hides under that key applies that function to this x that we passed to this value that we passed and then it reduces over merge so it simply merges all of these different different objects that it produced into a single object and that's a pretty complicated way of saying that essentially what we do here let me just i mean if i if i retype this implementation we could retype it as that let's think about it next is a function that takes a state and returns a new object where the new object if i had a spread syntax i could say is the old state right plus or actually let's not use this person let's be explicit so take some state and and and returns a new object where rows is equal to state of rows calls is equal to state dot calls moves is equal to next moves while being past the state and snake is snay a next snake being past the state and apple is next apple being past the state so that's essentially that's essentially what we're doing and actually i mean if we would express this in function syntax as well these first two just to make it clear uh really that why we can use spec in this lower implementation is because this is essentially then just using the prop method that we talked about before so if i say prop here pass row yes sorry like this right i pass these props as a string and then we pass the state as the second argument and sorry i'm using curried or functions that allow partial applications we actually need to invoke the function like this so that would be the same thing and now if you look at that right if you look at that implementation you can say okay well actually next is a function that takes some state produces a new object where the state needs to be passed to all of the functions or rather i should say it produces so next is a function that takes some state and produces a new object where this new object contains a bunch of keys and to determine the values under all of these keys we need to execute a few functions but these functions they are not nullary we need to pass them some arguments and the argument that we need to pass is essentially the state like if you line this up you can see all of them are past the state so essentially what we did is just that we we sort of made it point free we remove this portion notice how we do this we remove this boop and then we say okay all of these need to be past state okay but that's that's why we have the spec method so then we say spec and then we pass state here okay that's that's also the same thing but then we're back into the scenario that we looked at before where it's like well well actually next is now a function that invokes this this function spec by just passing the x that we pass it right like next is a function that takes an x and runs another function through that x or over that x and then we don't even need to specify the x we can just we just remove the state here like we remove the explicit call and then but then we remove this explicit variable here and then we just say next is the running of spec over these functions and then we pass it some states so i mean i would argue that this is more clear but yeah i'm totally empathetic too if you have a different opinion like as soon as you start to learn a few of these really common functional programming i wouldn't say patterns but like functions essentially these these common functions that we tend to use all the time like constant and id and map and reduce and pipe and compose and i would argue for dynamic languages this method is like super common uh or this function spec or or apply spec is super common so when you start to recognize these i actually think this becomes the easier version to read but there's a whole discussion about whether point free is is sensible or not i can shoot some links in the description if you're interested in that but anyways let's move on so that's that's the next method and we've all already talked about enqueue what enqueue does is essentially that you pass it a state and you pass it a move and if the move is valid then you merge the move into the list of of current moves that you have stacked up right so so the reason we're stacking them up by the way is that if you think about it what we can do oh sorry let me collect a few of these just to get a tail but what we can do is that we can stack moves like this if i just mash the buttons sorry now i have a tail now i can do this okay so if i just mash the buttons and then i let go let's see if this works let's not crash i just mash the buttons and i let go you can see that we've stacked a few moves and the reason we do that is because of if you've ever played this the game of snake you see like literally in this scenario right like now i just want to go right down for example like immediately right and then immediately down and then i can just queue down after right so i just press write down and then i've cued it so like if we didn't do something like this maybe we wouldn't be able to get both of them in actually now that i think about it that would probably work still i don't know maybe you have some opinion opinion about that i mean what wouldn't work is this sort of stacking but then again this stacking isn't necessarily super useful i assume but anyways let's get back to the code that was the original intention of why i did it as a list so yeah that that's enqueue so we've talked about in queue we've talked about next we've talked about initial state and what we i guess what we should do now is just talk about well first let's talk about these so the next state is computed from the old state right and rows when we do prop rows and prop calls as we looked at in the other implementation that just equates to the same value like we just say this value is whatever the old value was but however next moves let's actually look at the next moves right so let's search for cons next moves right and what this does is that it says okay it takes some state and and remember so what it the intention is that it takes the whole state but the intention is that it should produce only the list of moves right so it takes the hole and it produces the part so we take the state and then we say okay state.moves.length is greater than one so so we say if we have more moves than one then we should drop the first move right so so drop first is a function that i've defined here in the base drop first which is i mean it's trivial we just call a slice on an array slice and then pass one but i just did this to make it more readable right because now we can actually like very easily see what it does so we say drop the first from state moves or if the if the length of the the moves list is not greater than zero right so so if we have only a single move left then it will simply be a state of moves so what this means is that if we have more than one move we will drop the the first move because we've used it like in the next in the next state we won't have this this uh we won't have the first move left because we've now used it but if we have only a single move then we shouldn't do that because we want to keep repeating that move right that's how we're achieving this effect where it just keeps moving right i mean i'm not touching anything but it just keeps it just keeps moving to the right so that's because we we keep that in and and of course let me just quickly mention again that you can using functional programming you can make a lot of things point three point one and point two i've also kind of mixed this this sort of objectoriented dot syntax with this function syntax where you truly like truly have a function and then pass the data and i i'm a bit disappointed about myself for doing that but anyways i mean i just figured let's stay pragmatic but probably like here you we should do something like this like length of state that moves because this this dot syntax is fine because this is purely data but then length is a function on that but but this is a sort of give and take i mean i don't think we're going to be able to get away from this anytime soon in javascript because like maybe my terminology is a bit shaky here but if you've tried haskell for example like you have adhoc polymorphism and you have parametric polymorphism and adhoc polymorphism is kind of like polymorphism and objectoriented programming and so so the so the thing in haskell is that you can actually define a length function that takes some data and then does different things depending on the type of that data that's a bit tricky in in a language such as javascript because we don't have adhoc polymorphism in that way the way we achieve adhoc polymorphism is through objectoriented polymorphism is is by saying that length is a function that exists on an object and in in a dynamically typed language such as javascript we say well everything is a duct type right like if it quacks it's it's it's a duck so everything that responds to length is lengthable but which implementation of length you get depends on which object you call the method length on so i mean it's a give and take like we probably have to mix these two types of syntax before we have facilities for ad hoc polymorphism that looks a bit more like something like haskell in javascript which probably we maybe won't because maybe i'm not realizing how difficult that would be to implement in a dynamic language but anyways now we're way out of the zone so so so let's get back into this game but i just wanted to mention that that i'm completely aware that that's it's not it's not superb anyways how do we compute the next position of the apple well if this is where we get to this we'll eat that we talked about right like if the snake will eat the apple given the current state then we need to spawn a new position and that's when we're using this r d pulse that we talked about that's that's the that is the function in this snake library that is impure or actually i mean then next apple becomes impure because it's making use of an impure function but whatever so if the snake given the current state will eat the apple then we need to spawn a new position for the apple based on the current state if it's not right if it's not if the snake is not going to eat the apple then the apple will maintain in the maintain its position that the new position for the apple will be the same so so let's actually for the fun of it i mean let's actually do the same thing in both of these cases right like we have the cases where it will eat and we have the case where it won't eat so let's change the won't eat case to also uh spawning a new apple at a random position and then if we refresh this and run this again you can see that it's absolute and total madness right because now we have the apple is sort of respawning at new locations regardless of whether we're eating the apple or not so actually i mean i don't know the probabilities here but it's probably i have no idea whether it's higher or lower but like it's a very tricky game to play so this is surely not what we want then and and then also for the fun of it let's try the other thing like let's say instead of when we eat an apple that's spawning it at around a position let's just spawn it at the same position let's say that the the new position of the apple is the same as the old position of the apple regardless of whether we ate it or not then we can see that what happens is that we don't spot a new apple right the game works fine but we can just like hands off and then just leave it like this because we're just going to eat all the apples until we crash actually it's probably still tricky again because the snake will take up all the screen and then it's going to be tricky to eat the apple but anyways i mean clearly what we want is a random position so we want is this like we spawn a new position when we eat the apple and again that was like this is some of these things are very easy to to think about when you have immutability like i would imagine that going back and forth between these two changes would be more difficult if you had it would potentially be more difficult if you had mutable state depending on how you add structure you caught clearly next thing let's let's move the next head right so next head uh well let's think about it this way we have next snake and we have next heads maybe these should be in the other direction right so so and i think next snake was called in the next method here right so yeah so we're saying snake is equal to next snake so if we go back to next snake here and next snake makes use of next head so let's actually talk about next snake first so let's first think about the snake right look at this like let's actually grab one more apple here so now so now we're a snake of three dots right if you look at it now we're four but so so the snake is a list of positions and now it's a list with four elements that each have positions and i think if i'm not mistaken i will have to see either the first element or the last element in the list is the head of the snake so what we do is that we just when we need to move the snake we remove one element in the end and then we add one element in the beginning and when we eat right think about it look at what happens when we eat then we the snake is prolonged so what happens is that we add one in the front but we don't remove one in the end or i shouldn't say we add one in the front what i mean is we do compute the next position of the head but we don't remove one from the tail right so we have the snake here and then we're saying okay if you if you're not eating we should just take the snake and move it here but if you're eating then we should take the head and move it here but this tail should be fixed we should not remove anything from the end because it's this removing that makes that gives the appearance of it moving right because it's actually that we we remove this thing maybe it's easier maybe if we just think about one daughter like if you have one one dot like one one one snake head then what happens when we're not eating is that we're just saying okay remove this boop and make another one here and that gives the appearance of moving right and then and so forth but if we're eating we're saying create the new one right you have one here create the new one but don't remove this one right so so we give the appearance of prolongation and not of of or of extension and not of of moving of course it's moving as well but but anyways so that's the way that we structured that by the way i mean i tried this in multiple different approaches i also try i mean it's an interesting game because you can also approach it by building up a grid and then sort of making operations on that grid so like you have a two by two uh array like a matrix but anyways maybe if you if you try out the solution along those lines maybe again shoot something in the comments that would be interesting to look at so to compute the next snake what do we do well what we do is that we have two ifs we have two nested if so we say okay if the snake will crash right given the current state given the current direction given the current world if in the next state that we are now computing will the snake crash or not like if it will crash then the next snake is going to be an empty raid then we're going back to this sort of initial state thing we're saying let's go back the snake is an empty ray however if the snake won't crash we do any of these things and if it won't crash we're asking this well is it so that the snake is eating because if it's eating then what we want to do is just that we want to add the next head we want to compute the position of the next head like we did here with the hands right like we have one we have this we have a snake here and we want to add the snake here or we want to move it here right and if it's eating we just want to compute this new position and then we want to concat that into uh the current or with the current snake however if it's not eating then we need to move it or we need to give the appearance of moving that means we can't just compute the new position but we also need to drop the last position so we need to remove something from the end and let's just think about whether it's it's in the head or not so what we're doing is that we're saying that the head is an array and then we concat that with the old snake yeah so what we're doing is that we're adding into the beginning right so we're not it's not that we're pushing in positions into the end of the snake but it's more like we're adding at index zero and then we're shifting all of the other ones uh backwards so i haven't at all thought about performance and efficiency but i mean clearly there are probably multiple ways you could improve this code but so that's what happens when we're when the snake is eating we are adding a new head but we're not removing the tail and if it's not eating we're adding a new head and we are removing the tail so actually i mean if we if we remove this drop last just to try this out right then we're saying it's going to get longer all the time so if we run this now you can see just like it's it's never ending like it doesn't matter if we eat or not the snake is just growing and growing and yeah that was tricky for me to handle but as you can see right like the snake just keeps on growing and growing and growing again like a trivial thing to change but we go back to uh to actually dropping the mast and of course if we did drop last here as well just to be exhausted let's try that as well that would mean that even if we are collecting apples nothing happens like the snake isn't actually prolonged so of course what we want is that like this okay that's the next snake but then okay as we were saying next next next snake makes you some next head so the question is how do we compute the next position and that's actually pretty interesting right so let's look at next head so again next head the structure is that it takes a state and it produces a single position right so think about it i mean next snake takes a state and produces a list of snake positions next head takes the full state and produces a single position that represents the head of the snake and what it does is that it it too has to ask an if question and the if question that it asks is that do we currently have a snake or not right like if the length is zero like if you look here right uh as we talked about in in next snake of course when we crash we completely wipe out the snakes so that we don't have a snake so when we compute the next head it might be that we're trying to compute the next head from from no snake at all so this is why we're asking is the length zero because if it is zero then this we want is like the default start position maybe i should have had that as a comment or something like that actually if you look at it if we refresh here you can see that this supposedly is 2 2. ah actually let's think about it that means so x 3 and y 3 if you start from 1 so this is why i mean maybe one would assume that it's here but actually this is 1 1 because this is 0 0. so here it's 0 0 one one and then two two so uh so yeah we start at two two all the time and that's essentially because when the length of the snake is zero then we spawn at two two and again i mean we could do r and d let's say r d pulse uh given the state yeah that should work as well then we are starting at random positions we're always starting going east but now we're spawning it at random positions we're spawning the snake at random positions but i i figured this this makes sense i mean it's kind of nice to start from from two two and also it's obvious that you've crashed so that's what happens if the stink is zero like if it's the initial case but if we do have a snake like if if the length of the snake is currently longer than zero what do we do well this i found pretty cool we create a new position that has an x and then that has a y of course and what we do is that we take the i mean think about how these two look very much the same right like x and y is essentially the same thing but what we do is that we say the x position is the current x position of the snake of the of the current head of the snake right what's in the zeroth position plus the x of this move that we've stacked the next move that we want to grab so so the the move that is pending the move that it that we're supposed to execute now and remember like the moves that we can have are are any of these north south east west east west west so if we have east stacked right as in the default case then then x will be one so what we're saying here is that we're saying uh state dot is snake so we're taking taking the state position snake position and supposedly if we start at two uh at as we've defined as the sort of default start position here so if we start at at two and then we say plus and we add one because east is one so the default direction is one then we get three right because the current head is at two two or if we only think about the x position the current head is at at x two and then if we add one we end up in x3 right and that's actually the next head now the question that and of course maybe what we should mention is that this of course works for negative as well so if you have if the position is two and you add negative one then you get one because you're moving in the other direction and the reason then that we have this mod thing is that we're making use of the modulus operators so actually i mean in the best of worlds i wouldn't have had to write that i i should have been able to write something like let's think about this so so this so the same calculation mod uh state dot calls that that's the way i i wanted to use like we want to use the the mod operator but apparently the modulus operator in javascript behaves differently than i had expected in regards to negative numbers but think about it the reason we use modulus here is that because we want to have this wrapping effect right like notice how when we go out of the right end of the screen like it's a torus right we go out on the right end of the screen and we show up on the left end and similarly if we go out on the left hand we show up on the right and and and that modulus operator is actually everything that's needed to implement that because what we're saying is that if the grid let's say that the grid is 12 like right let's think of a clock so if i'm not sure if i can do mod here actually so if i do 10 yeah i can't okay so let's do it in google so so if we do 10 modulo 12 for example we get 10 because so so let me be more clear so so if 12 is the width of the grid and we're talking about the exposition let's say so the number of columns that we have to work with is 12 and that means that 0 is an okay position 11 is an okay position 12 is not an okay position so if we do 0 12 modulo 12 that means that it's the zeroth position so what i mean is that 12 is the size of the grid and 0 is the position that we want to position the next head in if we don't think about this wrapping around right like then you could say position 316 right like even if you have a grid of 12 actually i mean we could do that that's that's the point of modulo so if we do 316 modulo 12 that means that if you try to move to position 316 you should actually be at position four because you've wrapped around you've looped around multiple multiple times but if we just think about the edge cases right like zero yields zero so that means the zeroth positions that means we're not changing zero and if you do 12 you also get 0 because 12 modulo 12 like 12 divided by 12 gives a remainder of zero so that also puts you back in in position zero which makes sense because we're saying it's zero indexed right so so because we have the zero index the max index is 11. so when we try to go to 12 we should wrap around back to back to zero so maybe i'm not making a superb job of explaining this but but every number then between 0 and 11 inclusive will be the number that we pass so if we pass 2 we get 2 if we pass 3 we get 3 if we pass 4 we get a 4 and so forth but if we pass higher numbers which happens when we are at position 11 and we pass one right so or we add one right so this is more like the scenario that we have we are at position 11 we pass one and then we do modulo 12 of that so that gives us 12 that we do modulo 12 on and that gives us zero that makes us wrap around back and let's let's jump into note quickly and look at this so actually i should have done this in notes from the beginning so so 10 modulo 12 gives us 10 uh 10 right and but 12 modulo 12 gives us zero which wraps us around backs similarly 13 then gives us one but this is a case where that we're never seeing however what i would want is that negative 1 should also wrap so negative 1 should put us in the other end of the 12 and that's the way i was expecting that that modulo was behaving so let's see can we actually can we require the base library from here so let's try to require base oops sorry base equals required oh sorry because i now i declared it twice but messed up so let's restart jump back into nodes so let's require the the base library sorry i'm such a confused person so let's jump into node and let's say const base is equal to require from the current directory the file called base let's just be specific and say dot js right and that works then we have the base library and base i mean the base area that we've defined in this project and base has the function mode right so this mod however works differently i mean it works the same if you pass 10 and 12 again then you get no sorry it's the okay sorry for for other reasons i did it in the other order so here i pass uh so this if i pass it this way i mean 10 modulo 12 then we get 10. if i pass 12 we wrapped around to zero similarly for 13 but again we never end up in that scenario but now if i pass negative one we wrap around in the other direction and end up at 11 and modulo 2 and so forth so so yeah and that's a different implementation of of modulo uh and i think i left a comment here yeah i left a comment here to link that you can check out if you're interested in the source i think that came from a stack overflow post or something like that so anyways that was those one of these moments where you go like ah excellent like it's awesome when when math can make problems that seem a bit tricky to solve in programming and but math makes them trivial those are the good days right but anyways so that's why we do modulo here so what we're saying is that this is the raw quotation marks the raw new position and then we say take that position and do modulo of of the the size of of the rows or the colds depending on which one we're working with so that we wrap around but yeah that's that's next head and so next snake is is based on on that next head essentially and yeah the randomness here we've talked about the initial state we've talked about next we've talked about enqueue we've talked about oh my god we actually talked about everything now so yeah i think we've talked about everything and that sort of covers it in in getting to the point where where the snake game is operating uh something like this because we also looked at the the web html and js file and of course i mean i also have this web.css file with just some basic styling in order to make this look a bit prettier i mean if we remove i'm not even sure like if i remove this stuff it looks like this right i've actually zoomed in so this is the this is what we actually draw on the canvas but this is just some basic styling that i added in order to make it look like this but yeah that's it before we wrap this up let's actually also look at the cli so the command line interface so i'm opening up cli.js right and let me just map a keystroke here in vim to run node on cli.js or to run cli.js through node so if i just hit that we're running this and again you can see this works fine and actually i mean this is a pretty short implementation as well so the game loop is a bit different here we still do this sort of showing and stepping but what i do is i set an interval yeah so what we do is we make use of set interval right which is this function in javascript that calls a function with a regular interval it's also expressed in in milliseconds but here actually i run it every 80 milliseconds so yeah for some odd reason i chose a different interval for the terminal application maybe we should change this to 100 in order to sort of make it have the same speed but never mind i mean that we can trigger the change but essentially what this set interval does is that it it does these two things right if we pass a function to set interval that first calls step and then calls show and actually i mean now that i think about it what we could have done is we could have said pipe step step and then show like so over 80 and that should be the same that should be the same thing right and actually that didn't work and i think it has something to do with like the console log here or something like that so like the context disappears but never mind let's not think about that now and either way i mean piping here is not necessarily a sensible thing to do because a step and show are are mutating functions or there are functions that like i mean compose and pipe we usually use when we actually want to pipe compose functions like because we're actually passing data through now we're just do saying do this thing and then do that thing so like never mind but anyways so set interval what it does is that it calls step and then it calls show and it does that every 18 milliseconds and what show does let's start with the show right so so both of these both show and step or functions that don't take any arguments and show what it does is that it console logs this strange character which works as a clearing right like if you think about it actually if i if i remove this i think that would be the most simple way of describing this like if we remove this and then redraw you can see that the game works right but if i if i scroll out you can see we have multiple versions of the game where the the lower one this one here in the bottom uh this one is is the active one because that's the freshest one the the other ones are histories and actually we are we are printing and printing and printing so it's not like it looks static but it's not actually static i mean it's like a moving like these old animated movies like where you draw where wherever where you pull past the strip of multiple images and that's actually exactly what happens now like this is a strip of multiple images anyway sorry let's stop thinking about that now it's pretty interesting but um if we if we add that character we keep clearing the screen all the time so that we're just it's it's like clearing the canvas so that's that's the first part part of show like we clear and then what we do is that is that we have these uh these functions on the object matrix right so so here you can see we have a comment that says matrix operations and then following that there's a constant called matrix which is sort of a module with a bunch of functions that operates on matrices and actually i mean i use the word matrix here indicatively like it's not actually truly a matrix but what we have is that we have an array of an array like we have a twodimensional array where the first i think first i do rows and then i do columns or maybe the other way around uh so anyway the the things under matrix under the matrix module are then things that operate on on this type of structure uh so what we do is essentially then that we say okay matrix dot to string of mate matrix dot from state given the current state so here we probably could actually use pipe in a sensible manner so what we're doing is that we're saying yeah pipe matrix matrix from state and then matrix two string and we're piping that through the state ah so this is probably the reason why i didn't do this because the line turned out to be longer like if you compare the two lines this is actually longer but that should work fine as well and like if we run that that doesn't work fine oh sorry my bad this is probably why the other thing didn't work as well we're not using a raid syntax i should pipe like that yeah sorry so that's probably why the other thing didn't work as well no maybe didn't have anything to do with the console log but anyways uh so yeah we could use a pipe there instead but as just said i mean even even if i remove that sort of array here you can see that this line is longer and i just figured never mind let's just do this but anyways both of these things are equivalent but yeah maybe maybe this one is more clear so maybe let's keep that one i guess i didn't because of the length of the lines like you can see we're at 88 we're at column 88 but anyways let's keep it like that for now so so that's show so what it does is essentially it clears the screen it says construct a matrix from the current state remember the state is the same kind of state that we used in the web gui right like that's what we're saying like we use the same state tree but we do different things based on the state tree and thus we can show a command line interface and we can show a web interface so from this current state we we produce a matrix and then we take that matrix and we pass it to two strings so what we do is that we produce the matrix and then immediately we turn that matrix into a string so actually i mean maybe you could argue that i've made it unnecessarily complicated in some way and maybe we should find a way which is more similar to the web approach where we sort of just immediately do what we or display what we want to display but to me this seemed like the easiest approach like having this intermediate data structure that's this matrix like thing because i mean if you think about it we print this pretty much as as a matrix right like this is this has a number of rows and it has a number of columns and actually if we look at two string here in the matrix module you can see that this is where it becomes obvious that it's fairly trivial because two string takes i wrote x's x's here because like usually in functional programming you can you will see people say like x's or s's or something like that to indicate that you have an array of something so you have an array of x's here but i i tend to write x's x's i'm not sure if that's conventional i hope that's conventional because it seems sensible to indicate that it's an array of an array of x of x's so and that's why i say x is x is here on the outside and then x is here on the inside so the way this works is that we map over the the outer array and then for every inner array we join up all of the values with a space if you think about it you can see here that there's a space in between there's a space in between all of the different dots like if we didn't have that space uh probably this one yeah this actually does work right this doesn't look very nice also because columns are a lot narrower than than the rows so so we need that extra space in order to sort of make it look a bit more nice so we join it up with space and then we join up each of these rows with a backslash r backslash n which is essentially a line break so that we can print it as a single string that that sort of looks like a grid and actually i just realized i used to have a 0.3 or not a 0.3 version of this but rather a version that's more similar to the make function here where instead of actually calling map on the axis of x's we say map and past the axis of x's because i guess that could be more elegant than this but anyways there are multiple ways you can rewrite this function and some of them are probably a lot more elegant than the way i've written it now but anyways that's the two string function and of course if we think about this method again like what we're saying is that we first do from state and then we do two string so we start with this from state and then we do two strings so from state what that does is that it creates one of these excess of x's it creates one of these grids or one of these matrices uh containing the appropriate values and how we do that is essentially by piping right we say well we need to pass this state so we take the state as an argument and then we pipe it through a few functions but the first function makes the matrix the second function adds the snake to the matrix the third function has the apple and the fourth function adds a crash if there is supposed to be any crash so again these are sort of immutable methods in order just to keep my head straight in this so matrix.make we can see up here right the matrix that make here i called it table and not state because a table is anything that has calls and rows but i mean actually what we will pass is we will actually pass this date but since we only care about the calls and the rows i figured i'd call it table here and what we what make does is essentially that we use this helper function rep right so if we look at the base library uh cons rep here we have the implementation of rep and what rep does is that it takes a constant and then it takes an n and then it maps this constant using the function k which is the const function over the range from 0 to n so this sounds a bit bonkers but what this actually means is that if if you have actually let's let's jump into node and let's look at this so a const base is required right and then we have the base library and then we can say base dot rep and if i say a and then i'll pass 10 you can see that we get 10 a's if i get past three we'll get three a's right then if i instead of a if i have one here i'll i'll essentially get an array with this thing repeated the number of times as the second argument that we're passing and rep was implemented in terms of range and what range does is just that let's see if i can remember the syntax if we do this right then we get a range from 10 to 20 we get an array of all the elements of 10 to 20. so what we were doing is that we were mapping over that range in order to have an array of multiple elements and what we were mapping is that we were mapping the function k of the the constant that we were passing so when we did base dot rep a 10 here up in the beginning for example then our constant is a so if i say k of a then i have oh sorry bass dot k then i have a function that accepts an argument but it doesn't care about which argument it it's passed regardless of what argument is passed it's going to respond with a and that's how we can when we map so so actually let's let's do that manually like if i have that range from 10 to 20 and then i map over that and if i map k of a we will replace oh sorry base k in base.k we will replace all of the values in the rearray with a and that is essentially the way that a rep works and yeah i guess range and k as well and and map but anyways so that's why we do rep rep here so so i think it's it's pretty interesting i mean what we do is we repeat the repetition of period or this the string period over the number of columns that we have in this table we do that for every row that we have in this table so that's a pretty concise implementation of making a a twodimensional array filled with dots right so that's the first thing we do we make the matrix based on the state we make the matrix from the state but then here we have these three functions that we want to use to add additional things to this to this matrix we want to change particular we want to adjust particular cells in this matrix and note how we're passing states to these because essentially this one only requires the state to be passed once but these actually require the state to be passed twice so we'll invoke them like this so add snake is a method that can be defined only when we know what the state is and this i mean i was struggling a bit with this i think this didn't turn out super nice so if you have any suggestions of how to rewrite this properly super interesting if you want to post anything about that i was toying with the idea of probably using the s combinator or converge or something along these lines but probably we could find out more sensible ways of expressing this but anyways what we do essentially is so add snake what it does is that when given some state it will it will produce a function that's essentially a pipeline where we spread the mapping of setting x or rather i should say spread the result of mapping the value x over the snake so essentially this is the thing about it i mean this looks a bit hairy but like but actually it's not that strange i mean so the thing about it like the snake in the state is an array it's an array of positions so what we do is that we map the function of setting x and setting x in the matrix takes a particular position and so by mapping that we get a a list of functions that we then spread over this piping so we spread it into arguments so we make a function that went past a state we'll run that state or sorry not when past the state when past a matrix we'll pass we'll run that matrix through a bunch of matrix dot set transformations that set sets x at that particular position and if you look at set i mean set is also fairly straightforward what it does is that it takes a value and then it takes a position and what it does then so the position is then a point right maybe i should have said points or something that has an x and y and it calls adjust on the y or adjust at the y position but then passes the adjustment of the x position of the constant of the values so so what we do i mean actually i mean if we if we express this in a less strange manner actually what this is is that we're saying well i mean if we would do this in a mutating fashion uh what it does is that it takes another argument because it's point free right so so it takes it also takes the matrix and what we do is that we say the matrix uh of the position y and then position x is equal to the value and then we return the matrix like and then we return the matrix so that's essentially what what the set method what the set function does but but now we're mutating and so now we're trying to do that without mutating and when doing that we also got rid of the matrix variable here and and of course adjust is a function that we defined here uh in in our base base helper library but of course it's also available in a lot of different libraries and what adjust does is simply that it takes an n which is an index it takes a function and then it takes some kind of collection some x's and what it does is that it changes it runs the function at the index n of the x's right so so it's a way of if we go back here right like if we say uh list index equals value or more specifically if we say function over if we run a function over the value at that index right that's what what this version of adjust does and then and then we pass k here because we're not actually interested in running a function over the value we don't care about the old value we just want to replace it with a new value so that's kind of a general version of of adjust and yes so so this we do in order to to so essentially what set does is that when given a value when given a position and we're given a matrix it produces a new matrix that looks like the old matrix but where the value at the position has been updated to the new value and that's essentially what we do with set right and so that's why we use it in in add snake and we also use it in add apple and actually not add crash because here we did a more simple implementation i guess but yeah that's how we use it in add snake the way we use it in add apple is much more simple much more simple then we just simply say matrix.set and we set uh to an o at the position of the apple right so state that apple contains a position and we're just saying matrix that's set at that particular position right so i mean this we could change to an a and then if we run you can see that we now have a's instead of o's that represent the apple uh so that's the apple and then the crash is very simple here we just say that okay if the snake length is zero in other words if we don't have a snake if we've crashed or if we just started the game then we map the mapping of the constant dash so over this grid think about it the grid is a list of lists so over every column or row depending on which order we structured anything maybe it's row so over every row we map but we map the function that is the mapping of every column and over that we map the function k which is constant that returns regardless of what it gets it returns whatever we passed it and what we passed it in this case happens to be this dash symbol or this this pound sign this uh hashtag and that's only what we do if we if we don't have a snake so if we've crashed but if we hadn't crashed then we passed id and why do we pass id because id is the identity function so that means that well if we haven't crashed then the grid needs to stay the same if we didn't do that let's just say let's say we did this in both of the cases so instead of doing id we do this mapping again then it'd be a constant crash like we're just it looks like constant we're actually just redrawing this constant and recomputing this constant all the time but yeah so so that's why we need to to pass the id and if we didn't do this this mapping of pound that wouldn't be the end of the world it would just not be obvious when we've crashed so what we want to do is visualize like like we did in the web right like here when we crash we have the screen sort of turns red like that right and here in the terminal we want we want every position to be replaced by a dash and that's that right that's so these are the matrix operations that we have we we can make a matrix we can set something in the matrix we can given some state produce a function that when given a matrix adds that snake to the matrix similarly for the apple and similar for a crash similarly for a crash and then we can take a matrix and turn it into a representable string and then here we have the from from state function that essentially first makes a matrix adds a snake adds an apple and adds a crash all in order so that we can simply just call that from from over here uh in our game loop when we want to show okay that's that's show then we also have step but step is super trivial similarly if we go up here into the top like similarly to the web right like if we go back to web.html you can oh sorry not so web.js you can see here in the top that we have this mutable state where we say that the state is equal to initial stage for some reason i chose lowercase as since uppercase as here that makes no sense but in the cli here we have a variable called state which is which starts as the initial state from the snake and that is the mutable state and the reason that that's mutable is of course that we need to listen to these key events so i'm not gonna bother you about how this listening to keys work but this seems to be i like the way we do it in node when we want to listen to key presses so we capture what's in standard in and if we happen to press control c we need to exit the process because people need to be able to exit the program but if not then i'll just do two upper on it so so we don't have to worry about lowercase w or uppercase w and then we just look for wasd as as in the webcase right and hjkl and we look for up left down right arrows and what we do is actually the same thing let's let's look at this so yeah so the state is equal to the enqueuing of the old state and the new move and then we break and this is the same thing as we had here in the web where we said okay nq based on the new state this new move and compute a new state from that and and replace the mutable state with this new state that's computed and that's the way we do that and yeah i guess i guess that's pretty much it so to do that read line we needed to read in the base note library read line it seems that there are other ways of doing it but this seems to be the easiest way so yeah it kind of seems like that's it it seems like a lot of cold in some sense right but if you think about it what i would argue and what i would argue is that what we've done is that the snake implementation is actually only this file it's actually only snake.js like this is this is the implementation of of snake the other stuff regards how to display the snake game like what graphics version or engine you want to use your snake with what gui you want to use your snake game with so which way you want to display snake to the user and which way you want the user to interact with your snake game so again like if we think broader than game programming functional programming is really susceptible to modularity and so what i mean is when you produce small functions you can really quickly feel how they become very composable and very reusable but yeah i mean but if you actually know exactly what you're building and you know that you're not expecting any change and you have a strict specification then yeah maybe you don't need to be worried about change but if you are worried about change like if you're building an application that might change over time or if you're building something that might be shipped to multiple platforms then approaching something even like game programming kind of like we've been approaching it today i think actually makes a ton of sense what do you think let me know in the comments and let's discuss beyond that if you thought this was interesting and if you want me to decompose any other games let me know like tetris or pong or whatever i mean shoot something in the comments either way clearly this code can be improved a lot but hopefully you find something useful as we dove through this piece of code yeah i'm christopher i'm the guy that you just saw in this video i hope that you liked the video and i really hope that you felt that you learned something if you did like the video i would suggest that you check out my youtube channel the link to my youtube channel is in the description so thank you again very much for watching and i hope to see you in another video either here on this channel or over on my channel i'll see you in the next one
