With timestamps:

00:00 - hi in these videos we are going to be
00:02 - talking about time complexity and Big O
00:04 - notation specifically in this video
00:07 - we're going to be talking about why you
00:08 - should care and what it is Big O
00:11 - notation and time complexity are ways of
00:13 - discussing how long an algorithm is
00:15 - going to take so that you can streamline
00:17 - your software or your web app why do you
00:20 - should care about this is pretty
00:21 - straightforward do you see yourself
00:23 - sitting on a web page that's loading and
00:25 - loading and loading how long will you
00:28 - stay there before you go to another site
00:30 - some people might wait longer than
00:31 - others but at the end of the day if
00:33 - you're waiting on something to load or
00:35 - waiting for it to do what you expect it
00:36 - to do it's not going to be a good
00:38 - product for the user for now let's talk
00:41 - specifically about time complexity as it
00:43 - relates to an algorithm you've worked
00:46 - with algorithms and the bonfires an
00:47 - algorithm could be one function or a set
00:50 - of functions that solves a problem
00:52 - instead of saying well that algorithm
00:55 - will take exactly 4.5 seconds it's a
00:58 - little bit more complicated than that it
01:00 - kind of depends on what that algorithm
01:01 - is doing and Big O notation is a way of
01:04 - discussing that without going into too
01:06 - much detail about what the algorithm is
01:08 - specifically doing another thing you
01:11 - should know about Big O notation is it's
01:13 - the worst case scenario everything in
01:16 - Big O notation is calculated for the
01:18 - most possible data or the most possible
01:20 - users so that you can kind of see ok
01:22 - this might not be a problem if they have
01:25 - one or two users on my site but if I
01:27 - start to have thousands of users at a
01:29 - time this is not going to scale well
01:31 - meaning it's not gonna work well for a
01:33 - larger amounts of data you might be
01:37 - thinking well what about Moore's law
01:39 - can't we just build a faster computer
01:41 - that'll solve these algorithms faster in
01:43 - a couple years and we won't really have
01:45 - to worry about it short answer is no
01:47 - we're talking exponentially here and no
01:50 - matter how much faster the computer is
01:52 - the problem is going to get a lot more
01:53 - complicated faster than the computer is
01:55 - going to get faster
01:56 - Big O notation it comes in handy if
01:59 - you're building a tool of our site and
02:00 - you want it to be scalable for large
02:03 - amounts of traffic Big O notation will
02:05 - start to point out some places in your
02:07 - code where that is going to
02:09 - young users once we get more users in
02:12 - the system another reason that you want
02:14 - to know about big o-notation is it is a
02:16 - common interview topic even if your code
02:18 - runs great being able to explain why
02:20 - your code runs great and why it is
02:23 - efficient can be really really useful at
02:26 - the end of the day what I want you to
02:27 - take away from this is speed of your
02:29 - algorithms matters in a way that we can
02:32 - measure that is Big O notation

Cleaned transcript:

hi in these videos we are going to be talking about time complexity and Big O notation specifically in this video we're going to be talking about why you should care and what it is Big O notation and time complexity are ways of discussing how long an algorithm is going to take so that you can streamline your software or your web app why do you should care about this is pretty straightforward do you see yourself sitting on a web page that's loading and loading and loading how long will you stay there before you go to another site some people might wait longer than others but at the end of the day if you're waiting on something to load or waiting for it to do what you expect it to do it's not going to be a good product for the user for now let's talk specifically about time complexity as it relates to an algorithm you've worked with algorithms and the bonfires an algorithm could be one function or a set of functions that solves a problem instead of saying well that algorithm will take exactly 4.5 seconds it's a little bit more complicated than that it kind of depends on what that algorithm is doing and Big O notation is a way of discussing that without going into too much detail about what the algorithm is specifically doing another thing you should know about Big O notation is it's the worst case scenario everything in Big O notation is calculated for the most possible data or the most possible users so that you can kind of see ok this might not be a problem if they have one or two users on my site but if I start to have thousands of users at a time this is not going to scale well meaning it's not gonna work well for a larger amounts of data you might be thinking well what about Moore's law can't we just build a faster computer that'll solve these algorithms faster in a couple years and we won't really have to worry about it short answer is no we're talking exponentially here and no matter how much faster the computer is the problem is going to get a lot more complicated faster than the computer is going to get faster Big O notation it comes in handy if you're building a tool of our site and you want it to be scalable for large amounts of traffic Big O notation will start to point out some places in your code where that is going to young users once we get more users in the system another reason that you want to know about big onotation is it is a common interview topic even if your code runs great being able to explain why your code runs great and why it is efficient can be really really useful at the end of the day what I want you to take away from this is speed of your algorithms matters in a way that we can measure that is Big O notation
