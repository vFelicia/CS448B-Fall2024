With timestamps:

00:00 - hey everybody this is gregory from dapp
00:02 - university so today i'm going to show
00:04 - you how to write your first blockchain
00:05 - application i'll show you how to create
00:07 - a to-do list that's powered by ethereum
00:10 - smart contracts i'll show you how to
00:11 - create your first ethereum smart
00:13 - contract with a solidity programming
00:15 - language or write tests against the
00:17 - smart contract deploy it to a blockchain
00:20 - and we'll also create a client side
00:21 - application for the to-do list so if
00:23 - you're new around here be sure to
00:25 - subscribe to this channel and click the
00:26 - like button down below and also you can
00:29 - download my courses for free on my
00:31 - website over at dap university dot com
00:33 - forward slash free download i've got a
00:35 - link to that down in the description
00:36 - below and also on my website you can
00:38 - find a full-length article to accompany
00:41 - this video you can actually follow that
00:42 - step by step as you're following this
00:44 - tutorial and i've also got a link to
00:46 - that in the video description so before
00:48 - we start actually building the
00:49 - application let's get a high level
00:51 - overview of how a blockchain application
00:53 - powered by smart contracts actually
00:55 - works so how does a blockchain work and
00:58 - how does a blockchain application work
01:00 - well i've chosen a to-do list for this
01:02 - tutorial because that's a really common
01:04 - way to learn any new technology and i
01:07 - want to use that to show you how a
01:08 - blockchain application works so first
01:10 - let's look at how a to-do list would
01:12 - work as a web application and then i'll
01:14 - show you how it would work as a
01:15 - blockchain application so i'll put my
01:17 - whiteboard up here to demonstrate
01:19 - so normally whenever you access a web
01:21 - application like a to-do list for
01:23 - example
01:24 - you use a web browser and you connect to
01:26 - a web server over the internet
01:29 - and you access you know all the code and
01:31 - all the data from this web server
01:34 - so like this you basically
01:36 - connect from your web browser to the
01:38 - server and on the server it contains all
01:40 - the you know client-side files like html
01:43 - css and javascript
01:45 - it you know contains all of the back-end
01:48 - code for the server right any business
01:50 - logic you might write and any data
01:53 - that's stored in your application is
01:54 - stored in a database right
01:56 - and pretty much any other to-do list
01:58 - tutorial that's out there is going to
02:00 - show you how to write you know a
02:01 - client-side application and html and css
02:03 - and javascript and then it's going to
02:05 - show you how to basically
02:07 - do some business logic on a web backend
02:10 - that you know creates reads writes
02:12 - updates to do's and it puts them inside
02:14 - of a database like this right
02:17 - and all that's you know on a central
02:19 - server and that's how you build a to-do
02:21 - list on a web application
02:23 - so how would you build a to-do list on a
02:25 - blockchain well it would work a little
02:26 - bit differently so instead of connecting
02:29 - directly to a server you know we're
02:31 - gonna access our to-do list via a
02:33 - browser
02:34 - and we're gonna you know connect to
02:36 - a client-side application that we will
02:38 - build and this will just be a simple
02:41 - client-side application on a web server
02:43 - but this client-side application isn't
02:45 - gonna talk to a web backend in a
02:48 - database instead it's going to actually
02:51 - talk directly to the blockchain and on
02:54 - the blockchain we're going to have code
02:56 - that's going to be written with ethereum
02:58 - smart contracts
03:00 - that will contain all of the business
03:01 - logic for our to-do list
03:03 - and all the to-do items are going to be
03:05 - stored on the blockchain itself
03:09 - and that's fundamentally how a
03:11 - blockchain application would work and
03:13 - how it's different from a traditional
03:14 - web application
03:17 - so that might bring up a lot of
03:19 - questions like well how do we connect to
03:20 - a blockchain and how does the blockchain
03:22 - work like what even is a blockchain
03:25 - well i'll pause here and tell you a
03:27 - little bit more about that so what even
03:29 - is a blockchain right or client-side
03:31 - application is actually talking to a
03:32 - blockchain right here
03:34 - so it's actually a separate network okay
03:37 - and a blockchain is a peer-to-peer
03:39 - network of nodes that all talk to one
03:42 - another it's a distributed network so
03:44 - there's actually different computers
03:46 - different machines that talk to one
03:48 - another and we can connect to an
03:50 - individual node on the blockchain in
03:52 - order to use it that's what our web
03:54 - application is doing here
03:56 - so
03:58 - all the nodes on the network participate
04:01 - in running the network they all contain
04:03 - a copy of the code on the blockchain and
04:06 - all of the data on the blockchain
04:09 - and all of the data on the blockchain is
04:12 - contained in bundles of records called
04:14 - blocks which are chained together to
04:17 - make up the blockchain and all the nodes
04:20 - on the network also participate in
04:22 - ensuring that the data on the blockchain
04:25 - the public ledger is secure and
04:27 - unchangeable and that's what makes the
04:29 - blockchain so powerful and so what about
04:31 - the code on the blockchain
04:33 - well all the code on the blockchain is
04:35 - contained in smart contracts
04:37 - so smart contracts are basically just
04:39 - programs that run on the blockchain and
04:42 - they're going to be the building blocks
04:43 - of blockchain applications and that's
04:46 - what we're going to build our to-do list
04:47 - out of we're going to write a smart
04:48 - contract that will contain all the tasks
04:51 - in the to-do list and allow us to add
04:53 - new ones and complete them and things
04:55 - like that so smart contracts are written
04:57 - in a programming language called
04:58 - solidity
04:59 - and all the code in the smart contract
05:02 - is immutable which that means it's
05:04 - unchangeable whenever we deploy to the
05:06 - blockchain we won't be able to update
05:08 - that code and that's important to
05:09 - understand because that's what makes the
05:10 - blockchain so secure whenever we put
05:13 - code on the blockchain we know we can
05:14 - trust it at that point it's called
05:17 - trustless for a reason
05:19 - whenever it's on the blockchain we know
05:21 - that no one will change it and therefore
05:22 - we know the to-do list will behave the
05:24 - same way every time and sometimes i
05:26 - actually think about smart contracts
05:28 - kind of like microservices on the web
05:30 - they're on the blockchain and they read
05:32 - and write data from the blockchain and
05:34 - they do stuff with it you know they
05:35 - execute business logic all right now go
05:37 - back to the drawing board and kind of
05:39 - give you a refresher about how our
05:40 - application is going to work
05:42 - again we're going to connect the
05:43 - application with a web browser and we're
05:46 - going to build a client-side application
05:48 - in html css and javascript
05:51 - and that client-side application is
05:52 - going to talk directly to the blockchain
05:56 - and that's where we're going to put our
05:57 - smart contract we'll create the to-do
05:58 - list with an ethereum smart contract
06:01 - written in solidity and we'll compile it
06:03 - and deploy it to the blockchain it will
06:05 - also connect to the blockchain network
06:08 - with our personal account with an
06:10 - ethereum wallet in our browser and i'll
06:12 - show you how to get that set up in this
06:13 - tutorial as well so now we've seen how
06:15 - blockchain works and how we can build
06:17 - our to-do list application on the
06:18 - blockchain so let's jump in and start
06:20 - programming here's a preview of the
06:22 - application that will develop in this
06:24 - tutorial this will be a to-do list
06:26 - powered by an ethereum smart contract
06:29 - where we'll be able to add new to-do
06:30 - items and we'll be able to check items
06:33 - off of the to-do list and before you get
06:35 - started you need to make sure you have
06:36 - node.js already installed on your
06:38 - computer you can see if you have node
06:40 - installed by going to your terminal and
06:41 - typing node v you can install node with
06:44 - a package manager like homebrew or you
06:45 - can download it directly from the
06:47 - node.js website the first item in the
06:49 - blockchain developer toolkit is a
06:50 - personal blockchain we're going to use
06:52 - ganache as our personal blockchain for
06:54 - this tutorial you can head over to
06:56 - truffleframework.com forward slash
06:57 - ganache to download it you can click
06:59 - this download link and whenever you've
07:01 - downloaded it make sure you install it
07:03 - and when you open it you've got a local
07:05 - blockchain running
07:06 - so what is ganache you know what is a
07:08 - personal blockchain well a personal
07:10 - blockchain is like a real blockchain
07:12 - network you know that's connected to the
07:14 - public or anyone can connect to it but
07:16 - it runs on a computer it's you know a
07:18 - closed network and ganache basically you
07:20 - know is a process that runs on a
07:22 - computer that spins up this blockchain
07:23 - and runs on a server
07:25 - so we can use this to develop smart
07:27 - contracts we can run tests against it we
07:29 - can run scripts against the network
07:31 - develop applications that actually talk
07:32 - to this blockchain and it's really
07:34 - helpful and it's an invaluable tool in
07:36 - the blockchain developer toolkit
07:38 - so
07:39 - um if you open ganache you'll see you
07:41 - know 10 accounts listed here these are
07:43 - the addresses to each account on the
07:45 - side and you'll see you know these
07:46 - balances you'll see 100 ether and this
07:49 - is the ethereum cryptocurrency that each
07:51 - account has and it's you know required
07:53 - to you know pay gas fees in the network
07:54 - and stuff like that all right so that's
07:56 - an overview of the ganache personal
07:59 - blockchain network and we're going to
08:00 - leave ganache here set up in our project
08:02 - because we're going to need it uh
08:04 - running in order to develop our project
08:06 - the next dependency is the truffle
08:08 - framework we're going to use the truffle
08:10 - framework to develop ethereum smart
08:12 - contracts with the solidity programming
08:14 - language you can install truffle by
08:16 - going to your terminal and typing npm
08:18 - install
08:19 - g truffle at
08:22 - 5.0.2 and it's important that you use
08:25 - this exact version in order to follow
08:27 - along with this tutorial so truffle is a
08:30 - suite of tools that allows us to you
08:32 - know develop smart contracts write tests
08:34 - against smart contracts deploy smart
08:37 - contracts to the blockchain it gives us
08:39 - development console and that also allows
08:41 - us to develop client-side applications
08:43 - inside of our project so it does a lot
08:45 - and i'm going to show off all those
08:46 - features in this tutorial the next
08:48 - dependency is the meta mask extension
08:50 - for google chrome
08:51 - remember that the ethereum blockchain is
08:53 - a network
08:54 - and we need a special browser extension
08:56 - in order to connect to that network and
08:58 - that's where metamask comes into play
09:00 - metamask will allow us to connect to the
09:02 - blockchain with our personal account and
09:05 - actually interact with the smart
09:06 - contract that will develop in this
09:08 - tutorial
09:09 - you can install metamask by going to the
09:11 - google chrome web store and searching
09:13 - for metamask and clicking install
09:15 - and once you've installed it just make
09:17 - sure that you enable it inside of your
09:19 - chrome extensions like this you can also
09:21 - see the little fox icon in your
09:23 - extensions tab
09:28 - now let's create the project i'll start
09:30 - by creating a directory for our project
09:32 - like this
09:35 - eth just stands for ethereum so i'll
09:38 - enter into that newly created directory
09:42 - and now once we're inside of here we'll
09:44 - actually create a new truffle project
09:46 - but before we do that i just want to
09:47 - make sure that you're using the correct
09:48 - truffle version you can check your
09:50 - truffle version like this
09:52 - truffle version
09:54 - and you want to ensure that your version
09:56 - is the same as mine which is
09:58 - 5.0.2 so it's not go ahead and check out
10:01 - the dependencies section of this video
10:03 - to see how to install the specific
10:05 - version of truffle
10:07 - so now we'll initialize a new truffle
10:08 - project like this we'll just say truffle
10:11 - init
10:12 - all right and now we've successfully
10:14 - unboxed a new travel project and now i'm
10:16 - going to actually create a package.json
10:19 - file in order to you know pull in some
10:21 - development dependencies for the project
10:23 - so i'll say touch
10:24 - package dot json
10:27 - all right and now i'm going to open this
10:29 - project inside of sublime text that's
10:30 - the text editor i'm using
10:32 - so let's go to the package.json file we
10:34 - can actually see the project directory
10:36 - over here and we can see the newly
10:37 - created package.json file and it's empty
10:40 - i'm going to paste in the contents of
10:42 - this file that we'll use for this
10:44 - tutorial and you can actually
10:46 - get this package.json file by cloning
10:48 - this repository on the github link in
10:51 - the description down below all right so
10:53 - here's the dependencies for the project
10:55 - i'm just going to go ahead and save this
10:56 - like i said i just pasted these in here
10:58 - and you can see we have a few
11:00 - dependencies like the bootstrap
11:01 - framework we'll use this for building
11:02 - out um the client-side application we've
11:05 - got some dependencies for testing the
11:07 - smart contracts a server for running the
11:10 - client-side application
11:11 - and you know some other truffle specific
11:14 - development dependencies and i've locked
11:15 - these versions um so that you can keep
11:17 - following this tutorial in the future so
11:19 - make sure that all these versions match
11:21 - what i have here
11:22 - so now i'm actually going to install the
11:24 - dependencies for the project like this
11:25 - so i'll just say npm install all right
11:28 - so now they're installed
11:29 - now let's go back into our project and
11:31 - actually create the smart contract file
11:34 - that we'll use to build the to-do list
11:37 - we'll do that by going to the contracts
11:38 - directory and you can see there's a
11:40 - smart contract that exists inside of
11:42 - here this is actually a smart contract
11:44 - that comes bundled with truffle that
11:46 - manages migrations to the network and
11:48 - i'll explain that here in a little bit
11:50 - and now i'll create a new file inside
11:51 - this directory called to do list
11:54 - dot sol
11:55 - so we can see that to-do list is
11:58 - capitalized to do list
12:00 - and it's in the same project directory
12:01 - here
12:02 - so now let's actually create the smart
12:04 - contract that will manage the to-do list
12:06 - for the application the first thing we
12:08 - want to do inside this file is actually
12:09 - declare the version of the solidity
12:11 - programming language that we want to use
12:13 - we'll do that like this we'll say pragma
12:16 - solidity
12:18 - we'll use a carrot
12:19 - i'm going to say
12:20 - version 0.5.0
12:22 - and we'll end this line with a semicolon
12:25 - all right
12:26 - now the next thing we do is actually
12:28 - declare the smart contract we do that
12:30 - with the contract keyword say contract
12:33 - and we want to call this contract a
12:35 - to-do list which is the same name as the
12:36 - file say to-do list
12:39 - and we follow that with some opening and
12:40 - closing curly braces
12:42 - and inside of here is where we actually
12:44 - write all of the code for the smart
12:45 - contract now i'll go ahead and bump the
12:47 - font up so you all can see this a little
12:49 - better
12:50 - so the first thing that we'll do inside
12:52 - of here is just keep track of the number
12:54 - of tasks that are in the to-do list
12:57 - and we'll store this value inside the
12:59 - smart contract as a way to kind of get
13:01 - started and just make sure that
13:02 - everything is set up properly in our
13:04 - project we'll deploy this simple smart
13:06 - contract to the blockchain and actually
13:08 - see if we can connect to it before we
13:10 - you know do anything any more
13:11 - complicated than that
13:13 - so first we'll keep track of the number
13:16 - of to-do lists inside of the smart
13:18 - contract with a variable and it'll be a
13:20 - special kind of variable and solidity
13:22 - called a state variable
13:24 - and we can declare a state variable like
13:26 - this we'll say unt
13:28 - task count
13:29 - so state variables inside of solidity
13:32 - are actually written to the blockchain
13:34 - and that's what they're called state
13:36 - variables they actually represent the
13:37 - state of this smart contract on the
13:40 - blockchain
13:41 - and the state of the smart contract is
13:42 - going to change anytime this task count
13:45 - changes and these are a lot like you
13:47 - know class variables in an
13:48 - object-oriented context where you know
13:52 - the scope of the variable belongs to the
13:53 - entire smart contract not necessarily
13:55 - like a function or something like that
13:57 - we'll see that more as we continue on
13:59 - through this tutorial
14:01 - but initially we can set this value to
14:03 - zero like this
14:04 - all right we just say equal zero
14:06 - and we can also
14:08 - create a way to read this value from the
14:11 - smart contract with a keyword called
14:13 - public
14:14 - all right and what that does is actually
14:17 - provides some a function for us
14:20 - that allows us to read the value task
14:22 - count from the to-do list and solidity
14:24 - kind of just magically gives us a
14:27 - function whenever we use this public
14:29 - keyword
14:30 - all right that's all we'll do for our
14:31 - basic smart contract in order to
14:34 - set this project up and actually deploy
14:36 - this to the blockchain and make sure
14:37 - that everything's set up correctly we'll
14:39 - come back and you know build this out
14:41 - throughout this tutorial but for now we
14:42 - just want to do a simple check to make
14:44 - sure everything works properly now let's
14:46 - actually compile this smart contract
14:48 - before it goes to the blockchain and
14:50 - make sure that we wrote all our code
14:51 - correctly we'll go to the terminal and
14:52 - type truffle
14:54 - compile
14:56 - and we can see that it actually created
14:58 - some new files here i'll show you that
15:00 - in the project if you go to the build
15:02 - directory and then contracts we'll see
15:05 - migrations and to-do lists.json
15:09 - so this is actually a json
15:10 - representation of the smart contract
15:11 - that's created by truffle
15:13 - and it contains some information that's
15:16 - useful to us this is the smart contract
15:18 - abi which is the abstract binary
15:20 - interface we'll actually use this
15:22 - later in the tutorial when we talk to
15:24 - our
15:25 - smart contract in javascript we can see
15:27 - the byte code that was created by the
15:28 - smart contract
15:30 - this is actually the byte code that gets
15:31 - run on the ethereum virtual machine
15:34 - and yeah there's a lot more useful
15:36 - information inside of here but i just
15:37 - wanted to show you that initially now in
15:39 - order to actually put this smart
15:41 - contract on the blockchain we want to
15:43 - create a few more files and i'll kind of
15:45 - give you a tour of the rest of the
15:47 - project structure here as we do that
15:50 - in order to connect to the blockchain
15:51 - we'll actually need to update this
15:53 - truffle dash config
15:55 - file all right and i'm actually going to
15:57 - just paste some code inside of here
15:59 - again you can get this code from the
16:01 - repository uh for this project the
16:03 - github repo that i've got down in the
16:05 - description below you just check out
16:06 - that link
16:07 - all right i'm just going to save this
16:09 - and i'll explain what's going on here
16:11 - basically inside of this configuration
16:14 - file we have the network's key inside of
16:16 - this object right so what that does is
16:19 - allows to specify several different
16:21 - networks but here we have a development
16:23 - network um that's actually connecting to
16:25 - ganache so this is localhost and this is
16:27 - the port that ganache is running on so
16:29 - while we're here let's go ahead and
16:30 - actually make sure that ganache is
16:31 - running
16:33 - so you can open ganache find wherever
16:34 - you installed it make sure it's open
16:37 - and we can see that the port is 7545
16:41 - right and we can see it's localhost
16:42 - 127.0.0.1.7545.
16:46 - so now that we have this filled out um
16:48 - this is actually talking to the local
16:50 - blockchain now let's create a migration
16:52 - file in order to get the smart contract
16:54 - onto the blockchain
16:56 - so if you go to your migrations
16:57 - directory you'll see a file inside of
16:59 - here it's called initial migrations
17:02 - so i'm actually going to copy the
17:03 - contents of this and actually create a
17:04 - new file in the same directory
17:07 - and i'll call it uh
17:09 - two
17:10 - we'll say deploy
17:12 - contracts
17:14 - dot js okay
17:16 - what's inside of this directory well
17:18 - these are migrations i'm just going to
17:19 - paste this code in here so what is a
17:21 - migration well if you've come from
17:22 - another development background where
17:24 - you've used a database you might have
17:26 - had to change the state of that database
17:28 - by adding new tables or adding columns
17:31 - to the tables
17:32 - and that's because you're changing the
17:33 - state of the database
17:35 - the structure right the schema and
17:37 - that's essentially what you're doing
17:39 - in this project right here with a
17:41 - migration whenever you're deploying a
17:43 - smart contract to the blockchain you're
17:45 - actually changing the blockchain state
17:48 - remember the blockchain basically is
17:49 - just a big database in one sense and
17:52 - whenever you put the smart contract on
17:53 - the blockchain you're updating the state
17:56 - and thereby you need a migration in
17:58 - order to do that okay
18:01 - and you'll see these migration files
18:02 - over here are numbered and that tells
18:04 - truffle what order they need to be run
18:06 - in so make sure your starts number two
18:09 - and inside of here what we'll do is
18:11 - actually change this we'll change
18:12 - migrations to be a to-do list
18:16 - so to-do lists from artifact require
18:19 - truffle creates a an artifact
18:22 - out of this to-do list.json that we saw
18:24 - a second ago
18:25 - and that's going to be just a an
18:27 - abstraction of the smart contract that
18:29 - it understands in order to put in the
18:31 - blockchain now let's actually run the
18:32 - migration and deploy the smart contract
18:35 - to the blockchain
18:36 - so first again make sure that ganache is
18:38 - running make sure that you've you know
18:40 - configured this correctly and we'll run
18:42 - the migration like this we'll just say
18:44 - truffle
18:45 - migrate
18:46 - all right it looks like it was
18:47 - successful so what we've done is
18:48 - actually deployed the smart contract to
18:50 - the blockchain and if you open ganache
18:53 - you'll see
18:54 - that something has changed you know with
18:56 - this first account we'll see that the
18:58 - balance of ether you know the ethereum
19:00 - cryptocurrency balance has actually gone
19:02 - down by a little bit that's because
19:04 - deploying smart contracts to the
19:06 - blockchain actually costs ether it costs
19:08 - gas and we can see that this account has
19:11 - done that it's actually paid the gas fee
19:13 - in order to deploy the smart contract to
19:15 - the blockchain and truffle by default
19:17 - uses the first account inside this
19:19 - wallet in order to pay those fees
19:22 - now let's open the truffle console in
19:24 - order to check the smart contract that
19:26 - we deployed to the blockchain we'll do
19:27 - that like this we'll say truffle
19:29 - console
19:30 - now we'll retrieve the smart contract
19:32 - from the blockchain like this we'll say
19:34 - to-do list
19:35 - equals await
19:37 - to-do list
19:38 - dot deployed
19:40 - so to-do list is the name of the uh
19:44 - smart contract that we created in the
19:45 - migration we go back to project and see
19:48 - you know this to-do list right
19:50 - we've actually retrieved
19:52 - the smart contract a deployed copy of it
19:54 - from the blockchain and assigned it to
19:56 - this variable to-do list and you'll see
19:59 - this await keyword here so let me
20:02 - explain that we must interact with the
20:04 - blockchain in an asynchronous fashion
20:06 - and if you've ever developed other
20:07 - javascript applications you would know
20:10 - that there's a lot of different
20:11 - strategies for handling asynchronous
20:13 - actions right you can use promises
20:16 - there's a lot of different ways to do it
20:17 - but with truffle version five we've
20:19 - actually
20:20 - been able to use the async await pattern
20:23 - inside the console which is really nice
20:25 - you can just do things in a simple one
20:26 - line like this basically this is just
20:29 - saying you know wait for this finished
20:31 - result
20:32 - and whatever the result is assigned to
20:34 - this variable
20:35 - so we can actually look at that we say
20:36 - to-do lists
20:38 - all right you can actually see the
20:40 - result as the smart contract here
20:43 - and i'll just pull this up so you can
20:44 - see
20:47 - let's actually get the address the
20:48 - contract we'll say to-do list
20:50 - address
20:52 - all right
20:53 - and we can see this is the address of
20:55 - the smart contract that's deployed to
20:56 - the blockchain this is just where it's
20:58 - located
20:59 - and now we can actually see the count of
21:03 - tasks that we created in the smart
21:05 - contract so we'll say to do list
21:07 - dot count
21:10 - like this or sorry task account that's
21:12 - what we called it
21:15 - all right we can see that is zero and
21:17 - now truffle actually stores that as a
21:19 - big number whenever we retrieve it we
21:21 - could convert it to a number like this
21:22 - we could just say uh
21:25 - task account
21:26 - assign it to a variable and say a weight
21:30 - all right we could say task count two
21:32 - number
21:34 - and i see that it's zero all right so
21:36 - that's a good check to see that
21:38 - everything is set up properly if you've
21:40 - been able to complete all this so far
21:42 - you know you've been able to create a
21:43 - smart contract create a new truffle
21:45 - project you know connect it to a
21:47 - blockchain and actually to put the smart
21:49 - contract on the blockchain and talk to
21:51 - it if you have any trouble just you know
21:53 - rewind the video and try to see where
21:55 - you might have gone wrong what we want
21:57 - to do now is actually pause and commit
22:00 - some of these changes i'm going to
22:02 - create a new git repository i'll say git
22:04 - init
22:06 - and inside of here i'm actually going to
22:08 - create a
22:10 - git ignore file you don't necessarily
22:12 - have to follow along with all these
22:13 - steps but i'm just going to do them so
22:15 - that you all can see
22:17 - what i'm going to do inside of here is
22:19 - create this git ignore file that ignores
22:20 - the node modules directory so that we
22:22 - don't commit all the node modules to
22:24 - source
22:25 - all right i'm going to say git add
22:28 - i'm not sure what all these errors are
22:30 - sorry i'm going to get commit
22:33 - i'll say project
22:35 - setup
22:37 - all right so that's it for the first
22:39 - part of this tutorial where we've
22:40 - actually set the project up in the next
22:42 - section we're actually going to list out
22:44 - the tasks in the to-do list
22:49 - now let's list out the tasks inside of
22:51 - this to-do list
22:53 - i'll show you the steps that we'll
22:54 - follow
22:55 - first we'll list the tasks in the smart
22:57 - contract
22:58 - and then we'll do that in the console
23:01 - and next we'll actually wire up the
23:03 - client side application and list the
23:04 - tasks there
23:06 - and finally we'll write some tests that
23:08 - make sure that the smart contract is
23:10 - listing the tasks correctly
23:12 - so first
23:13 - we'll go to our smart contract that
23:15 - we've been working on to-do lists
23:17 - and we'll actually write the code to
23:18 - list out the tasks in the to-do list
23:20 - here
23:21 - so first we'll need a way to
23:23 - actually model the task
23:25 - we'll do that with something called a
23:27 - struct solidity allows us to define our
23:29 - own data types of structs
23:31 - and we can create a new struct like this
23:34 - we can say struct task follows with
23:37 - curly braces
23:39 - and we'll actually give this some more
23:40 - attributes in a second
23:41 - let me pause and explain uh some more
23:43 - features of solidity right solidity is a
23:46 - statically typed language in fact you
23:48 - can see the data types listed here you
23:50 - know uint this is an unsigned integer
23:53 - which basically just means that it's an
23:55 - integer uh that can't be negative right
23:58 - so integers can be positive or negative
24:00 - with a minus sign you know a sign in
24:02 - front of it or a positive sign and so
24:03 - solidity allows us to define this uh
24:05 - struct task here
24:08 - and we can give it some attributes like
24:09 - this we can say uint
24:12 - id this will be the id of the task this
24:14 - is going to be an unsigned integer which
24:16 - basically just means an integer that
24:18 - can't be negative right if it was a
24:20 - negative integer would have a sign in
24:21 - front of it that'd be a sign integer but
24:23 - this is unsigned
24:24 - and the next thing will be a string and
24:27 - we'll say the content this will just be
24:30 - you know the text and next will be a
24:32 - boolean and that will be completed
24:35 - and that will represent the checkbox
24:36 - state of the to-do list you know whether
24:38 - the item has been checked off or not
24:41 - all right so that's how we'll actually
24:43 - model a task on the to-do list with this
24:45 - data structure
24:46 - and now we need a place to put these
24:48 - tasks so where will they go
24:50 - well we effectively want to put these in
24:53 - storage on the blockchain so how do we
24:55 - do that how do we access the storage
24:58 - we need to create a new state variable
25:00 - like we did here with task account
25:02 - remember task account is getting written
25:03 - to storage it's a state variable it's
25:05 - representing the state of the smart
25:07 - contract which is written to the
25:08 - blockchain the actual data storage
25:10 - and we'll actually want to create a
25:12 - state variable called tasks here
25:15 - but we don't want it to be you know an
25:18 - unsigned integer we want a different
25:20 - data type
25:21 - we want something called a mapping
25:24 - and this is going to take a key value
25:25 - pair like this it'll say uint
25:29 - say task
25:32 - okay now mapping and solidity is a lot
25:34 - like an associative array or a hash in
25:37 - other programming languages where you
25:38 - store a key value pair right
25:41 - and when we declare this mapping here
25:43 - we declare the data type for the key
25:45 - which is an unsigned integer and the
25:48 - task
25:50 - which is you know this struct that we
25:52 - defined here
25:53 - and essentially this is going to be kind
25:55 - of like a database for us it'll have a
25:58 - uint an unsigned integer that will be
26:00 - the id essentially of the task that
26:03 - we'll store here
26:05 - so we can look for task you know one two
26:08 - three and it'll return the tasks okay
26:11 - and we also want to make this public
26:13 - just like we did with a task account
26:16 - and that will give us a reader function
26:18 - for free provided by solidity that will
26:20 - allow us to access the items out of this
26:23 - mapping
26:24 - all right now we have a way
26:26 - to create new tasks and actually put
26:28 - them in the you know database or the
26:30 - blockchain in this case we'll be able to
26:32 - use this task id reference here and
26:34 - store the task like this
26:36 - so now we need a way to actually put
26:38 - this task struct
26:40 - inside of this mapping
26:42 - to do that we'll create a function
26:45 - called create task say
26:47 - function
26:48 - create task
26:51 - and inside of here we'll provide a
26:53 - single argument which will just be the
26:55 - content of the task itself so we'll say
26:57 - string
26:58 - memory
27:00 - say content
27:02 - let's be public
27:05 - all right now inside of this we're going
27:07 - to write some code that puts this task
27:11 - inside of this mapping
27:13 - so the first thing we'll do is determine
27:15 - the id of the task we're going to create
27:18 - right
27:19 - so that's why we're using task count
27:21 - and you see that each task struct has an
27:24 - id and we want to increment this task
27:27 - count value anytime we're creating a new
27:29 - task to put inside of this mapping
27:32 - so do that like this we'll just say task
27:35 - count
27:36 - and we'll just use the increment
27:37 - operator you might find this uh to be
27:40 - similar to other programming languages
27:42 - where you're basically just changing
27:43 - this value by one
27:45 - all
27:46 - right so once we've done that we'll have
27:49 - a new task count which if this is zero
27:52 - and the first time we call this uh it'll
27:54 - change to one and that means the first
27:56 - task that we put inside of this mapping
27:59 - whenever we call this create task
28:00 - function will be one and the next time
28:02 - it'll be two the next time it'd be three
28:05 - so now let's actually put it inside the
28:06 - mapping we do that like this we'll say
28:08 - tasks
28:11 - that will reference the mapping
28:14 - and we'll say task account we can
28:16 - actually reference it by
28:18 - uh
28:19 - you know the key which will be the
28:20 - unsigned integer here
28:22 - and we'll just say equals
28:24 - and we'll create a new task we'll do
28:26 - that like this we just say you know task
28:28 - just copy this
28:30 - and
28:32 - we say task
28:33 - count
28:34 - we just provide the arguments for the
28:36 - structs so the id the content and
28:38 - completed so the task count is the new
28:41 - id
28:42 - the content is the content being passed
28:44 - in
28:45 - oops
28:46 - from the function
28:48 - and
28:50 - it's a new task so it's not completed
28:51 - yet so we'll just say false
28:54 - all right
28:55 - now we have a way to actually put tasks
28:57 - inside the to-do list which we'll need
28:59 - as a prerequisite in order to list tasks
29:02 - you know we'll need some tasks inside of
29:04 - the to-do list in order to show them and
29:06 - the next thing we want to actually do is
29:08 - you know go ahead and populate our to-do
29:11 - list so that when we you know call it up
29:13 - on the client side it's already got some
29:15 - to-do items inside of it for us okay and
29:19 - what we can do is basically just add
29:21 - some tasks to this list whenever this
29:24 - smart contract is deployed
29:26 - so how do we do that
29:28 - well we do that with something called
29:30 - the constructor function for the smart
29:32 - contract
29:33 - so if you've ever used another
29:35 - programming language that has like an
29:36 - initialize function inside of a class or
29:39 - some sort of object you know maybe init
29:42 - or new something like that
29:44 - you've seen a constructor before
29:47 - so basically this is just going to be
29:49 - a function that's called
29:51 - whenever the smart contract is
29:54 - run for the first time which in this
29:56 - case is upon deployment all right
29:58 - so inside of this constructor function
30:00 - we can actually add a default task to
30:04 - the to-do list all right
30:06 - so we do that like this we'll just say
30:08 - create task
30:10 - task
30:12 - and we'll just pass in uh check
30:16 - out
30:17 - app university
30:19 - dot com
30:22 - all right i'll put a semicolon here
30:26 - so now whenever we access the smart
30:28 - contract for the first time
30:29 - it will have a default task inside of it
30:34 - so whenever we list the tasks out there
30:35 - will be something they're forced to see
30:37 - and that way we'll know that this worked
30:39 - properly whenever we look at this in the
30:40 - console and connect our client-side
30:42 - application and write tests and things
30:44 - like that
30:45 - all right now let's actually compile a
30:47 - smart contract to make sure it worked we
30:48 - could just say truffle pile
30:51 - i may have some syntax errors or
30:52 - something like that we'll see
30:55 - all right it worked so now let's
30:56 - actually open the console to see if it
30:58 - worked we'll say truffle console
31:01 - well actually first before we do that
31:02 - let's make sure we have ganache running
31:05 - i don't
31:07 - so let's pull it up
31:13 - all right so ganache is running and now
31:15 - we actually need to migrate our smart
31:16 - contracts we'll say truffle
31:18 - migrate i'm just going to pass in the
31:20 - reset flag
31:21 - to be safe here in case you had ganache
31:23 - already running so what does the reset
31:25 - flag do well that would deploy a new
31:28 - copy of the smart contract to the
31:29 - blockchain if an existing one um is
31:32 - already there
31:33 - so like if you go you know we change our
31:35 - smart contract code here so if you added
31:37 - new functions or something like that you
31:39 - could migrate with the reset flag uh to
31:42 - deploy a new copy so i'm gonna do that
31:44 - just in case you had ganache running
31:45 - already
31:48 - all right now let's open the truffle
31:49 - console
31:51 - so i'll do it like this truffle console
31:55 - and what we'll do is actually list out
31:57 - the to-do items so
31:59 - first i will just get a copy of the
32:02 - to-do list we'll say to-do list
32:06 - equals await to do list.deployed
32:12 - all right let's make sure the address is
32:14 - there say to do
32:16 - this to address
32:20 - oops
32:20 - misspelled that
32:24 - okay
32:25 - now let's actually list out the items
32:29 - now let me explain something about this
32:30 - mapping
32:31 - we want to call this tasks function
32:34 - that's provided by solidity
32:36 - to list out the task in the to-do list
32:39 - and remember we declare this public so
32:41 - solidity gave us a tasks function for
32:43 - free to reference this mapping
32:46 - but whenever we call this function it
32:47 - won't just return all the tasks in the
32:50 - list
32:51 - and that's because solidity doesn't do
32:54 - that for us this mapping is a dynamic
32:57 - size there's no way
32:59 - you know and natively to know how big it
33:02 - is inside the smart contract
33:04 - um and so you can't iterate over it and
33:07 - you can't just return the entire thing
33:09 - you actually have to reference
33:10 - the items out one by one
33:13 - and that's why we're using the task
33:15 - account counter cache here
33:18 - so if we know that this task count is
33:19 - one that means there's only one task in
33:21 - the to-do list and we would just have to
33:23 - call this function one time to get that
33:25 - task and we would pass in the id which
33:28 - would be one in this case and it would
33:29 - return the task if it were 10 we would
33:32 - have to do this 10 times we'd call this
33:34 - function once with one and that would
33:37 - return task number one we'd call it the
33:39 - second time with two and that would
33:41 - return task number two et cetera et
33:43 - cetera until we get 10
33:45 - which case it will return task number
33:47 - 10. so that's how we would do that and
33:49 - if you're doing that on the client side
33:51 - we would use a for loop or something
33:52 - like that which we'll
33:54 - get to whenever we reach that section
33:57 - so for now inside the console we can
33:59 - just reference you know the only to-do
34:01 - item inside of here the only task is
34:03 - this one
34:04 - so we can say
34:07 - task equals await
34:10 - to do lists
34:12 - dot tasks
34:15 - and we'll say one
34:18 - all right let's see the task
34:20 - she bumped this up
34:25 - all right there you go
34:27 - so there's the task we can see the
34:29 - content check out dapaniversity.com
34:31 - we can see that it's completed as false
34:34 - we can see the id is one it's a big
34:36 - number but we can actually do that
34:37 - inside here we can say task
34:40 - id
34:41 - two number
34:44 - right it's one
34:46 - task content
34:49 - sorry it's not a function
34:50 - it's just an attribute
34:52 - all right so now we've actually migrated
34:54 - this smart contract to the blockchain
34:56 - and we've been able to list tasks
34:58 - inside the console now let's create the
35:00 - client side application and actually
35:01 - list out the tasks there so in order to
35:04 - do that
35:05 - we'll need to create some new files
35:07 - first we'll create a directory to store
35:09 - the client-side files we'll just say
35:12 - this
35:14 - say source so we see a new directory
35:17 - came up here
35:18 - and we'll create a new file inside of
35:20 - here called index.html
35:25 - sorry say touch
35:27 - source index.html
35:31 - and we'll create an app.js file to store
35:34 - all the javascript code say touch source
35:39 - app.js
35:40 - okay
35:42 - stepping over the project and see
35:44 - we have an empty app.js file and an
35:46 - empty index.html file
35:49 - and another file we actually want to
35:50 - create is um
35:52 - a bs config file
35:56 - so bs config stands for browser sync
35:58 - configuration i mean browser sync is
36:01 - something that we use
36:03 - uh
36:04 - as a part of light server so if you go
36:06 - to your package
36:07 - uh json file you'll see this light
36:09 - server dependency so this is the web
36:12 - server that we're going to use in order
36:13 - to run the client side application we
36:15 - need to configure the server to know
36:17 - about a few different directories inside
36:19 - of our project we want to tell it where
36:21 - the source directory is for the you know
36:24 - client side files we want to tell it
36:26 - where
36:28 - these contract the smart contract json
36:31 - files are we also want to tell it where
36:33 - our node modules are to pull out some
36:36 - dependencies for building out the front
36:38 - end so we'll do that like this
36:40 - we'll actually create a new file say
36:43 - touch bs config
36:46 - dot uh
36:47 - json
36:50 - okay
36:52 - so inside of this file i'm actually
36:53 - going to paste in some code
36:55 - um and you can actually get this
36:57 - configuration
36:59 - from
37:00 - the
37:01 - project
37:02 - from github down in the description
37:03 - below
37:04 - let's paste this inside of here
37:06 - and don't worry too much about this this
37:08 - is all just proprietary
37:10 - uh browser sync configuration so
37:13 - basically we're just saying the server
37:14 - configuration is uh this
37:17 - and we're pulling the files in from the
37:19 - source directory and also the build
37:21 - contracts directory
37:23 - so basically it's saying expose all of
37:25 - these directories
37:27 - to
37:28 - our our web server root and then also
37:31 - we're going to mask a vendor with node
37:34 - modules so any uh node modules that
37:38 - exist inside our project we can
37:39 - reference those at the vendor route
37:42 - all right so there's a server
37:43 - configuration
37:44 - and now we actually want to fill in the
37:47 - index.html file
37:50 - now likewise inside of here i don't want
37:52 - to spend a bunch of time writing html
37:54 - and css so i'm going to just paste in
37:58 - uh the code
37:59 - from the application and again you can
38:02 - just pull this source code from the
38:03 - github link down below
38:05 - i'm just going to paste this in like
38:07 - this what we'll do is actually build out
38:08 - the javascript part
38:10 - but i don't want to spend too much time
38:11 - writing the html
38:13 - all right
38:14 - so i'm going to paste this in here
38:16 - i'll explain you know what's going on um
38:19 - basically you know we're pulling in the
38:21 - twitter bootstrap framework to write the
38:24 - front end so we don't have to write a
38:25 - bunch of css and ui elements ourself
38:28 - um you know we can see this uh
38:31 - bootstrap that was what i showed you a
38:33 - second ago in bs config that's how i got
38:35 - this vendor here
38:38 - and we can see some basic css that's
38:40 - just written inside the head tag
38:43 - and yeah we got some markup essentially
38:45 - we have a simple loader to
38:48 - show whatever the application is loading
38:50 - a form that allows us to create a new
38:52 - to-do item and we will actually um
38:57 - have a way to list out the tasks here
39:00 - so for now i'm going to just uh
39:04 - comment out this form i think i think
39:06 - it'll run otherwise
39:09 - all right
39:11 - and let's actually just see if we can
39:13 - start the server
39:16 - so i'll start the server in a new tab
39:19 - i'll say
39:21 - uh
39:22 - npm
39:24 - run
39:25 - dev i believe is the command
39:27 - all right yep that worked
39:29 - so you can see uh that we basically got
39:32 - something right we see it's loading
39:33 - that's fine um if you open your console
39:35 - i'm sure you'll see some errors or
39:37 - something like that yeah failed the
39:38 - resource that's okay
39:40 - don't worry about that just yet we will
39:42 - wire this up to actually work but for
39:43 - now i just wanted to make sure that the
39:44 - server is working properly that we can
39:46 - see bootstrap right we see this nav bar
39:48 - up here we can see the dav diversity
39:50 - to-do list you actually click through
39:51 - this link it'll take you to my website
39:53 - which is pretty cool
39:56 - um but yeah so let's fill in the project
39:58 - and actually list out the to-do's in
40:00 - this client-side application so to list
40:01 - the to-do items we essentially
40:04 - want to fill in
40:06 - uh this unordered list we've got two
40:09 - here we have a list for
40:11 - the tasks and then the completed tasks
40:14 - so if we have an uncompleted task it'll
40:16 - go in this list and whenever we complete
40:18 - them it'll go here but for now they're
40:19 - all uncompleted so they'll stay in this
40:20 - task list
40:22 - all right so in order to do that we need
40:23 - to do several things inside this app.js
40:25 - file this is where we'll actually create
40:28 - um you know our javascript app that
40:29 - talks to the blockchain so the first
40:31 - thing we'll do is actually create an app
40:33 - like this let's say app
40:35 - this is object
40:36 - okay and we'll create a load function
40:42 - and actually call this async
40:46 - we're going to use a lot of async
40:48 - functions inside of this tutorial
40:51 - i've been using a lot of async await
40:52 - pattern when loading data from the
40:53 - blockchain it seems to be pretty helpful
40:56 - so we'll fill this in
41:01 - and then in order to load the app let's
41:03 - actually do this console log
41:06 - uploading
41:09 - and in order to load the app whenever
41:11 - the project loads we'll just say
41:16 - say window
41:20 - when it loads
41:22 - we'll just uh pass in a function
41:25 - say app.load actually didn't mean to put
41:27 - that inside this object
41:29 - do it like this
41:32 - all right so let's reload
41:35 - all right so we see the app's actually
41:36 - loading
41:37 - all right now i'm actually put these
41:38 - windows side by side and you can see
41:40 - that this to-do list is actually
41:42 - responsive which is cool we'll be able
41:43 - to see the tasks right here and be able
41:45 - to focus on the code while we're doing
41:46 - this the first thing we want to do
41:48 - inside this load function is actually
41:52 - say await
41:54 - app.load
41:56 - web3
41:58 - we want to load the web3 library in
42:00 - order to connect the blockchain now when
42:02 - we load web 3 i'm actually just going to
42:04 - use the configuration that's specified
42:07 - by metamask themselves right what we're
42:09 - doing is creating a way to talk to the
42:11 - blockchain we want metamask which is
42:13 - going to be the browser extension that
42:15 - we use to connect to our dap our
42:17 - blockchain application
42:19 - to talk to the blockchain with web3js
42:22 - and metamask actually suggests a way to
42:25 - do that so i'm not going to reinvent the
42:28 - wheel here i'm just going to do what
42:28 - metamask tells us to do
42:30 - so i'm going to actually just paste in
42:32 - the configuration that they suggest and
42:34 - don't worry if you don't understand
42:36 - what's going on here
42:39 - just know that this works and it's
42:41 - inside of the github repository then you
42:44 - can find the code and link it with the
42:46 - link in the description below
42:48 - so let me pause because i don't feel
42:49 - like i've fully explained web3 js very
42:53 - well and what's going on here okay
42:56 - so remember this to-do list application
42:58 - is backed by the blockchain
43:00 - and we want to actually connect to the
43:02 - blockchain to use it so a few things
43:04 - have to happen
43:05 - we have to connect our browser to the
43:08 - blockchain and that's what we'll use
43:10 - metamask for
43:11 - right
43:12 - and then our client-side application
43:14 - needs to actually connect to the
43:16 - blockchain and that's what web3js is for
43:19 - so inside of our project we'll use the
43:21 - web3.js library to talk to the ethereum
43:23 - blockchain it'll actually allow us to
43:25 - connect to it and you know read and
43:28 - write data from the blockchain inside of
43:30 - the app
43:31 - and then metamask will allow us to
43:35 - you know communicate with that client
43:36 - that application with web3js and allow
43:39 - us to you know interact with it via our
43:41 - browser
43:43 - so what we did here was just loaded up
43:45 - web3.js
43:47 - you know loaded our blockchain
43:49 - connection essentially we even call this
43:50 - like connect to blockchain if we wanted
43:52 - to um
43:54 - and
43:56 - now we'll actually use our browser to
43:58 - connect to it with metamask
44:01 - so let's actually do that i will
44:04 - open up ganache
44:06 - let's actually find the private key here
44:09 - we'll show the key
44:11 - copy it
44:13 - all right
44:14 - we'll go to metamask
44:16 - and make sure you've opened this if you
44:17 - haven't already
44:19 - and what you want to do is connect to
44:20 - the private network which is localhost
44:22 - 7545
44:24 - right so you might see the main ethereum
44:26 - network
44:27 - first but you want to change networks to
44:29 - localhost 7545 here
44:32 - and what you want to do is click this
44:34 - accounts menu you want to import account
44:38 - and you want to paste in the private key
44:40 - select type private key and click paste
44:43 - and then import all right i've already
44:44 - done this step so i'm not going to do it
44:46 - so i'll click cancel
44:48 - whenever you've imported the account you
44:50 - know from ganache you want to use this
44:52 - make sure you use the first one because
44:53 - that's the account that we deployed the
44:54 - smart contract with okay
44:56 - you'll actually be connected with that
44:58 - account to the blockchain right so
45:00 - here's your blockchain account and then
45:02 - you can add it to your wallet in
45:04 - metamask to connect to the blockchain
45:07 - with your web browser and you'll specify
45:09 - the blockchain by
45:11 - you know picking
45:12 - this local blockchain that we have
45:14 - running with ganache okay
45:18 - so refresh that all right and you've got
45:21 - um your account connected to the network
45:26 - now let's
45:27 - take that account
45:29 - um from ganache this one right here and
45:31 - let's show it in our application to
45:33 - prove that we're actually connected to
45:36 - the blockchain with it
45:37 - all right
45:39 - so
45:40 - i'll just say
45:42 - load account
45:44 - like this
45:45 - create a load account function say load
45:47 - account
45:49 - this would be async
45:53 - and i'll say app.account
45:57 - equals
45:59 - each
46:01 - counts
46:02 - zero
46:04 - okay
46:05 - so web3 here
46:08 - was set by
46:10 - uh
46:12 - load web3
46:13 - and it has this eth object that's going
46:15 - to contain all the accounts which will
46:16 - be an array once you get the first one
46:18 - which will be the account that we're
46:19 - connected with inside of metamask
46:21 - and inside the load function i'll say
46:23 - await
46:25 - load
46:29 - account
46:31 - app.load account okay save that
46:34 - and now
46:35 - inside of the index.html file
46:38 - um you'll see that we have a place for
46:42 - the account here
46:44 - this will be the
46:46 - place where we can actually add the
46:47 - account we'll do that in a second
46:49 - but for now it's actually just
46:51 - console.log
46:56 - and see if it worked properly
46:58 - all right yep there we go we can see it
47:00 - here
47:01 - we can verify that's the same account in
47:03 - metamask so e925a
47:07 - and that's e925a all right so we've
47:10 - successfully retrieved the account from
47:12 - metamask and we'll actually stick it
47:13 - inside the project in a little bit okay
47:15 - so we'll just clean that up
47:20 - now let's actually load the smart
47:21 - contract from the blockchain this will
47:23 - be the to-do list
47:25 - that we created so that we can list out
47:27 - the tasks from the to-do lists
47:31 - uh in order to do that we'll say load
47:33 - contract
47:36 - say async
47:39 - pass it a function
47:42 - um and inside of here
47:44 - the first thing we'll do is actually
47:46 - pull out
47:47 - um the smart contract json file say
47:51 - const
47:53 - to-do list
47:55 - equals
47:56 - a weight
47:58 - let's say
48:00 - jquery get json
48:03 - let's be to-do-list
48:07 - okay
48:09 - so if you remember inside the bsconfig
48:11 - file
48:13 - we exposed the build contracts directory
48:15 - to the root of our project so we can
48:17 - call this to-do list.json file we're
48:19 - actually pulling out this file right
48:21 - here
48:23 - and we can log it
48:28 - we can log it but in order to do that we
48:29 - need to call this function say oh wait
48:33 - contract
48:35 - okay
48:36 - all right we can see it here here's the
48:38 - to-do list uh file
48:42 - okay so next what we want to do is
48:43 - actually create a truffle contract so
48:45 - truffle contract is just a javascript
48:47 - representation the smart contract that
48:48 - will allow us to you know call the
48:50 - functions on it and things like that
48:52 - so what we'll do is i'm just going to
48:54 - paste in some code that shows you how to
48:55 - do that do like this
48:57 - okay
48:59 - so this will be
49:00 - uh we'll call truffle contract we'll
49:02 - pass in this to-do list json file that's
49:05 - basically gonna create a wrapper around
49:06 - the json file that we created by truffle
49:09 - and it's gonna allow us to you know
49:10 - interact with it and we'll set the
49:11 - provider which is the web3 provider
49:13 - which we um
49:15 - created here
49:17 - and this is basically just going to give
49:18 - us a copy of the smart contract in
49:20 - javascript and it's going to tell us
49:22 - where it is on the blockchain and we're
49:24 - going to be able to do stuff like you
49:25 - know call all the functions that we
49:27 - coded inside of here like the tasks
49:28 - function the task account and things
49:30 - like that so let's clear this out
49:32 - and just save and refresh and see if
49:35 - everything worked
49:36 - all right so to do list of undefined
49:38 - let's change that so we actually need a
49:40 - place to store this contract so i'll say
49:42 - this
49:43 - let's say contracts like this
49:47 - we'll actually create an empty object
49:52 - okay
49:54 - we'll refresh
49:55 - if you guys get stuck on any of these
49:57 - steps feel free to clone the repository
49:59 - and see the code um
50:01 - below
50:02 - now we want to actually you know
50:04 - get a deployed copy of the smart
50:06 - contract like we did in the console
50:08 - remember we did you know to-do list
50:10 - equals like a wait to do list.deployed
50:12 - we're going to do the same thing here
50:14 - so we'll say app.to-do list
50:17 - equals await
50:19 - app.contracts
50:21 - to-do list
50:23 - deployed
50:25 - okay
50:26 - and you know this is really just uh
50:30 - and this is really just you know getting
50:31 - the values from the blockchain so this
50:33 - is a live contract now
50:35 - this is just like we did in the console
50:38 - all right now we should have loaded our
50:40 - app up with a lot of data we've
50:42 - connected to the blockchain we've
50:44 - retrieved the account and we've
50:45 - retrieved the smart contract that we
50:47 - created you know in the previous section
50:50 - so we want to do now is actually render
50:51 - some information on the page the first
50:53 - thing we'll do is actually
50:56 - render out the account that we're
50:58 - connected with so first we'll just say
50:59 - render
51:01 - equals an async function
51:04 - and inside of here what i'm going to do
51:07 - is show
51:09 - the account
51:11 - right inside of our html
51:15 - okay
51:16 - and remember we got this place to show
51:18 - the account right here
51:20 - so that's exactly what i'm going to do
51:21 - i'm going to put the account inside of
51:23 - this
51:25 - and i'm going to call the render
51:26 - function
51:27 - so after the contracts have loaded i'll
51:29 - say a weight app dot render
51:34 - all right in order to see this change
51:37 - we'll actually expand the window here
51:39 - all right
51:40 - you can see that the account was put in
51:42 - here
51:44 - so like i said earlier i created this as
51:46 - a responsive application um and we can
51:48 - see the account you know here
51:50 - but whenever we resize the window we
51:52 - don't want to see that anymore just to
51:54 - save some space so we'll keep that down
51:56 - but that works and if you want to code
51:57 - this you know with your window all the
51:59 - way open feel free to do that i'm just
52:01 - going to use a smaller view um to save
52:03 - some screen real estate so you guys can
52:05 - see
52:06 - both things happening as i'm doing the
52:07 - tutorial
52:09 - all right
52:10 - so let's do some more things inside this
52:11 - render function what we actually want to
52:13 - do is render the tasks
52:15 - um
52:16 - but i'm going to basically create some
52:19 - other logic inside of here uh to prevent
52:23 - double rendering
52:24 - all right
52:26 - so what we'll do
52:28 - is do a couple things
52:32 - we will
52:33 - say that the app is loading
52:36 - we'll keep track of that like this
52:40 - let's change this to false whenever it's
52:42 - rendering we'll save is loading stop
52:44 - calling this function this will
52:45 - basically prevent a double rendering
52:47 - problem
52:49 - and while this is loading we'll actually
52:50 - set it to true and when it's finished
52:53 - we'll put it back to false
52:54 - so let's actually create a set loading
52:57 - function like this i'm just going to
52:59 - paste some code in you can find this
53:01 - code in the uh github repository
53:05 - so it's set loading basically it's just
53:06 - going to update it and we'll show the
53:08 - loader in the index.html file this will
53:11 - be our simple loader that you see here
53:13 - loading
53:14 - this is loading
53:16 - and i'm going to show it when it's
53:17 - loading right and i'm going to hide the
53:20 - content which is this this is actually
53:22 - the to-do list itself
53:24 - all right i'm going to show the loader
53:26 - hide the content
53:29 - all right so let's save that and see if
53:30 - there's any errors
53:34 - all right
53:35 - so that looks like the loader went away
53:37 - which is what we want
53:39 - all right now next we want to do is
53:41 - actually fill in
53:42 - um
53:43 - the
53:44 - tasks who actually want to render them
53:46 - so we'll list out the tasks inside of
53:48 - its own function like this we'll say
53:49 - render
53:50 - tasks
53:52 - say async
53:54 - so inside this function
53:56 - we need to do a lot of things
53:58 - the first thing we want to do is
54:00 - actually load the tasks from the
54:02 - blockchain
54:04 - and then the second thing we want to do
54:06 - is actually render out you know each
54:09 - task
54:11 - with the task template
54:14 - and we're gonna have to
54:16 - basically render out each task one by
54:19 - one
54:20 - and then we're gonna have to actually
54:22 - show the task on the page
54:25 - okay
54:26 - this is kind of a three-step process
54:28 - it's gonna be a little complicated but
54:29 - just bear with me i'll show you how it
54:31 - works
54:32 - so what we're gonna do is fetch them
54:33 - from the blockchain and we're gonna
54:35 - actually use this template that's
54:36 - created down here this task template
54:39 - it's going to have a check box and the
54:40 - content
54:42 - we're going to you know fetch this off
54:43 - the page and create a new task with this
54:46 - okay
54:48 - so first what we think we need to do is
54:50 - fetch the number of tasks from the
54:52 - blockchain remember i said that we can't
54:54 - you know just fetch all the tasks with
54:56 - this mapping essentially we need to find
54:58 - out how many there are and we need to
55:00 - loop through
55:02 - the items in this mapping and fetch them
55:05 - out one by one so if there's ten tasks
55:07 - inside of here we'll need to do one two
55:09 - three four five six seven eight nine ten
55:11 - if there's one we just do this once so
55:12 - in this case there's just one
55:15 - but that's what we need to do first we
55:16 - say const task count
55:18 - equals a weight this is app.to-do list
55:23 - task count
55:24 - okay
55:26 - and now we know how many there are
55:29 - and the next thing we want to do is
55:30 - actually fetch this template that we'll
55:32 - use to list the task on the page
55:34 - say const
55:36 - task template
55:39 - equals
55:41 - task
55:42 - template
55:44 - okay
55:46 - and now we actually want to use this
55:48 - task account to
55:50 - um
55:51 - render out each
55:53 - task on the page in order to do that
55:56 - we'll create a for loop in javascript
55:57 - like this
55:59 - if you've written some javascript before
56:00 - it should look pretty familiar we're
56:02 - basically just saying
56:04 - for every number
56:06 - from
56:07 - one
56:09 - all the way up to the task count
56:13 - do this operation
56:15 - so that's what we want to do we start
56:17 - with one because that's the first valid
56:19 - id
56:20 - inside of the mapping so from task
56:23 - number one all the way up to the maximum
56:26 - number of tasks which you know if it's
56:28 - 10 we're going to do this 10 times you
56:30 - know fetch each task so we'll actually
56:32 - read the value from this
56:34 - mapping with the id
56:37 - so i in this case is going to be the id
56:39 - inside the loop
56:40 - the first thing we'll do is actually
56:42 - fetch all the values for the task we'll
56:44 - call the task function
56:46 - and break out the attributes
56:49 - to the id the name and completed
56:52 - do that like this
56:54 - so say task equals await
56:57 - do list task i which is the id in this
57:00 - case
57:02 - and so because of how truffle contract
57:03 - works this is actually going to return
57:05 - an array
57:07 - and we have to reference these values by
57:08 - each item in the array so the first item
57:10 - will be the task id the second id second
57:13 - item
57:14 - which will be the task content the third
57:16 - item which will be completed
57:18 - and remember this array is zero index
57:20 - that's why the first item is zero second
57:22 - item is one third item is two
57:25 - okay so now we'll have the task
57:28 - um id content completed
57:31 - the next thing that we'll do is actually
57:33 - create the html for the task like this
57:35 - i'm just going to paste in this
57:38 - all right
57:39 - so we'll do is actually get a new task
57:42 - template we'll take this task template
57:43 - that was you know fetched from the dom
57:46 - and we'll actually clone it right we'll
57:47 - get a new copy
57:49 - we're going to find the content for this
57:51 - template we're going to fill in the
57:53 - content from the task
57:56 - and we'll find the
57:58 - input which will be the check box and
58:00 - we're going to populate that with some
58:02 - values which will be the task id so
58:05 - basically whenever we check this we'll
58:07 - like you know turn it on and off
58:09 - and
58:10 - whether it's completed or not
58:13 - we'll just use that from the task
58:15 - and we want to wire up a uh
58:18 - on click function which will be
58:20 - toggle completed it will implement this
58:21 - later we won't use it for now so we can
58:23 - comment it out okay so the next thing we
58:25 - want to do is actually put the task in
58:26 - the crest list so i'm going to paste in
58:28 - some code here too
58:31 - so what this does is check if it's
58:33 - completed
58:34 - and remember there's two lists here
58:35 - there's a list for the completed tasks
58:37 - and a list for the um sorry here's the
58:39 - completed tasks and then the list for
58:41 - the non-completed tasks
58:43 - and if the task's completed we'll put it
58:44 - in the right list
58:46 - and the last thing we want to do is
58:47 - actually show the task we'll do that
58:49 - like this we'll just take the
58:52 - hidden task template that we've been
58:54 - modifying let's show it like this
58:56 - okay
58:59 - all right so let's actually try to call
59:01 - this render tasks function inside of the
59:05 - render function
59:08 - so render task is here and then after we
59:11 - render the account we want to run the
59:12 - tasks like this
59:14 - so let's save this and see what happens
59:15 - we might have some errors but we can
59:16 - just address those as they come up
59:19 - oh no there it is boom it worked
59:22 - so we've actually successfully listed
59:24 - the tasks from the smart contract in the
59:26 - blockchain
59:27 - i can pull this out and we can see the
59:29 - first task inside of here which is check
59:31 - out dap university so i'm actually going
59:33 - to do that i'm going to right click and
59:34 - go to dapuniversity.com
59:36 - awesome so it worked
59:38 - see my social links here and get my
59:40 - twitter
59:42 - it's pretty cool
59:43 - all right so i know we've covered a lot
59:46 - of ground but we have successfully
59:48 - listed the tasks inside the client side
59:50 - application okay
59:52 - um i've commented a couple things out
59:54 - here because we haven't implemented them
59:56 - just yet but if you get confused just go
59:58 - rewind the video and uh you know find
60:00 - what you might have gotten lost
60:02 - the next step we want to do is actually
60:04 - write some tests to ensure that the
60:07 - tasks were listed out properly okay
60:09 - and we're actually going to use the moca
60:11 - testing framework
60:13 - from javascript and the chai assertion
60:15 - library in order to write our tests so
60:17 - you can read more about these if you
60:19 - want to we'll create a new file in the
60:20 - test directory let's say test
60:23 - to-do list
60:24 - dot test.js
60:26 - if you go into the test directory you
60:28 - can see the to-do list.test.js file here
60:31 - all right so let's actually write a
60:32 - basic test to ensure that you know the
60:35 - contract was initialized properly and
60:37 - that actually lists out tasks
60:39 - the first thing we want to do inside of
60:41 - here is actually require the smart
60:42 - contract like this
60:44 - that's very similar to our migration
60:46 - file pattern
60:48 - say contract
60:49 - and we'll say to-do list
60:52 - we'll pass in a function here
60:58 - all right and we'll write all of our
60:59 - tests inside of this callback function
61:01 - this callback function is actually going
61:03 - to expose all the accounts uh in the
61:05 - blockchain right so all the accounts
61:08 - that are connected to ganache all these
61:10 - are going to be injected inside of this
61:12 - variable here this will be an array you
61:14 - can read them out one by one
61:17 - so the first thing we'll do is actually
61:20 - get a deployed copy of the smart
61:22 - contract with a before hook
61:25 - okay
61:26 - and we'll do that like this we'll
61:28 - basically just say
61:29 - before
61:31 - each test runs that's essentially what
61:32 - this means
61:34 - we're going to pass an asynchronous
61:35 - function that should allow us to use the
61:36 - await keyword let's say this dot to-do
61:39 - list equals to-do list dot deployed
61:42 - okay
61:43 - and before each test runs we'll have a
61:45 - copy of the to-do list is deployed to
61:47 - the blockchain
61:49 - now let's create our first test example
61:51 - we'll just say it deploys successfully
61:56 - all right we'll use the async function
61:59 - because we want to use a weight inside
62:01 - of here
62:03 - and the first thing we'll do is actually
62:04 - just get the address like we did in the
62:06 - console earlier say const
62:08 - address
62:11 - i'll wait this
62:13 - to do list address
62:16 - we'll say
62:17 - we basically just want to make sure that
62:18 - the address exists
62:20 - so we want to check that it's not
62:22 - um you know empty so we'll do that like
62:25 - this
62:26 - say assert
62:27 - not equal
62:29 - this address we don't want to be 0x0 we
62:32 - don't want it to be an empty string we
62:34 - don't want it to be null and we don't
62:35 - want it to be undefined
62:37 - so we can check that and that'll just
62:39 - make sure that the smart contract was
62:41 - actually put on the blockchain and that
62:42 - it has an address
62:44 - okay
62:46 - now we can run this test inside of
62:48 - shuffle like this we just say truffle
62:50 - test
62:51 - hit enter
62:53 - all right and it passes
62:54 - now the next thing we want to do is
62:56 - actually list out the tasks and the test
62:58 - and make sure that it works
63:00 - so we'll say it
63:01 - lists
63:03 - tasks
63:05 - pass this asic function
63:09 - so inside of here we'll just do a very
63:11 - simple check we'll just basically make
63:14 - sure the count is correct and that we
63:16 - can fetch you know a task by the count
63:19 - so first we'll just get the task count
63:22 - and we'll just do that and then next we
63:24 - want to actually try to fetch the
63:27 - task out of the mapping
63:29 - so we'll just make sure that a task
63:30 - exists where the task count is okay this
63:33 - will be a simple test
63:35 - so do that
63:36 - and now we want to do is actually assert
63:38 - that the id is equal to the task count
63:41 - right that it was set correctly so let's
63:44 - do a basic test and just try to run it
63:46 - and see if it works
63:48 - all right it works
63:49 - so let's look at that we can see that
63:51 - we're just getting the task we're
63:53 - calling the id and making sure that it's
63:54 - equal to the same task count
63:56 - next let's test some more values and
63:58 - make sure that the content is correct
64:00 - that completed is correct and that um
64:04 - the task number is the same as we expect
64:08 - so let's just do that like this paste in
64:10 - some examples we'll say assert equal the
64:12 - task content is this that's the first
64:14 - task we set whenever we initialize the
64:16 - contract
64:17 - we want to say that the completed is
64:19 - false right we want to say that the task
64:21 - count is actually 1 we want to specify
64:23 - that it's 1 in this case
64:25 - so let's say that run the tests
64:28 - all right passes all right so that
64:29 - concludes this section where we've
64:31 - actually listed out the tasks in the
64:33 - to-do list i know that we covered a lot
64:35 - of ground
64:36 - we actually created the tasks inside of
64:39 - the smart contract we listed them out in
64:41 - the console we had to wire up the client
64:43 - side application to list the tasks out
64:45 - there and we wrote some tests so that's
64:47 - a lot if you got confused about anything
64:50 - feel free to rewind the video paste in
64:52 - the code from the github repository down
64:54 - below
64:56 - and while we're here i'm going to go
64:57 - ahead and commit these changes let's say
64:58 - git add
65:00 - i'm going to say git commit
65:03 - all right so we've listed the tasks
65:09 - the next item is to add tasks to the
65:12 - to-do list
65:13 - we'll do this with a client-side
65:14 - application and we'll write tests for it
65:17 - but first we want to change this create
65:19 - task function to
65:21 - add some additional functionality
65:23 - so right now we're calling this create
65:24 - task functions at the constructor to add
65:26 - a default task to the to-do list like
65:28 - this
65:29 - but we want to you know call this
65:31 - function externally
65:33 - from the client side in order to create
65:35 - tasks that way we also do it in the
65:37 - console and things like that
65:39 - so what i'm going to do is actually add
65:42 - a new line here
65:44 - and what i want to happen is to
65:47 - broadcast an event
65:49 - that this task was created
65:51 - let me explain that
65:53 - solidity allows us to create events that
65:55 - are triggered anytime you know something
65:57 - happens inside of a smart contract and
66:00 - external consumers can subscribe to
66:01 - these events to know uh whenever the
66:04 - event happened and events are really
66:06 - useful because
66:07 - you know whatever we call this create
66:08 - task function we don't always know when
66:11 - you know the transaction actually
66:13 - completed we don't always know when it
66:14 - was mined and things like that and it
66:16 - can be really useful to listen to those
66:18 - events uh in order to you know know that
66:20 - it was finished
66:22 - so we can create an event in solidity
66:24 - before we call it here we need to
66:26 - actually declare it inside of our smart
66:27 - contract
66:29 - we'll just do it like this
66:31 - we'll go below this mapping we'll say
66:33 - event we'll say task created
66:37 - and notice that's capitalized
66:40 - all right here's a semicolon here and
66:42 - we'll just add some arguments to this
66:44 - event we'll say uint id this will be the
66:47 - id the task that was created a string
66:51 - this is the content
66:53 - and the
66:55 - completed
66:56 - property so boolean
66:58 - completed all right
67:02 - so that's how we create an event inside
67:03 - of solidity right this just means that
67:05 - you know the task created event is
67:07 - available to us inside of the smart
67:09 - contract
67:10 - and i'll show you how we can actually
67:11 - call it
67:13 - we do like this we use the emit keyword
67:16 - emit
67:18 - task
67:19 - created
67:20 - and we pass in the arguments so the id
67:22 - here is
67:25 - the task
67:26 - count and the content
67:29 - which is passed in from the function
67:32 - and false
67:34 - because it's a new task and we haven't
67:36 - completed it yet and that's pretty easy
67:38 - that's how you trigger events inside of
67:40 - solidity and we can subscribe to these
67:41 - events you know inside the client-side
67:43 - application or you know anywhere that
67:46 - can listen to events on a smart contract
67:48 - all right while we're here i'm going to
67:49 - go ahead and actually write the tests
67:51 - for creating the to-do item
67:53 - so i'll open the test file over here do
67:55 - the side by side and i'll just create a
67:57 - new example down here so below list
68:00 - tasks we'll say it creates tasks
68:03 - i'm just going to add some space so you
68:04 - can see better
68:07 - so say it
68:09 - creates tasks
68:12 - all right let's say async
68:14 - pass in a function
68:17 - and first we'll say
68:19 - construct
68:21 - equals await this dot to-do list
68:25 - create task
68:29 - and i'll say a new task
68:31 - okay
68:33 - and we'll check the task count
68:37 - oh wait this dot to-do list
68:41 - task account
68:42 - all right we'll fetch that
68:44 - and first we'll check that the
68:50 - task count is the same as we expect say
68:54 - two so that's the first thing we'll
68:56 - check on
68:56 - we'll ensure that you know we created a
68:58 - new task and the new count is actually
69:01 - two
69:02 - and now what we'll do is check that this
69:04 - event this task created event was
69:06 - actually triggered
69:08 - and you know we'll dig into the logs
69:11 - uh and say that the id was the same the
69:14 - contents the same and completed was the
69:16 - same so that would be the actually you
69:17 - know this new task that we created was
69:19 - you know logged out so we can get the
69:20 - event like this we're going to use this
69:22 - result which was you know the result of
69:24 - this
69:25 - finished
69:27 - create task function right we use the
69:28 - async weight pattern to get the result
69:30 - here and the event is actually contained
69:32 - inside of that
69:34 - so we'll say const event equals
69:37 - result
69:39 - logs okay it's in their logs and it's
69:42 - the first item
69:43 - okay
69:44 - and
69:45 - the args
69:47 - key basically is going to contain all
69:49 - the values for the event
69:51 - and you could log this out like in
69:53 - ganache
69:54 - you could actually console log this
69:55 - event in fact let's just do that right
69:56 - now let's just say
69:59 - console.log
70:01 - result
70:04 - go to the terminal truffle
70:09 - we'll show you the result and what it
70:10 - looks like so you can see what we're
70:12 - digging into
70:14 - all right this is loading okay so this
70:16 - is what the result looks like we see
70:18 - there's a transaction hash here and it's
70:20 - got a receipt
70:22 - and inside of here we have logs right
70:26 - and here is where the event
70:29 - information is contained
70:31 - right
70:32 - we can see
70:36 - this args key right here it's going to
70:38 - have an object and granted we can't see
70:40 - exactly what's inside of here because
70:42 - it's not locking all the information
70:44 - but this args key is going to contain
70:47 - all the values of this event that was
70:49 - triggered whenever
70:51 - this was created okay
70:54 - so i'll take out that result
70:58 - now
70:58 - i will
71:00 - check to see that all the information is
71:02 - there so let's say a search
71:04 - equal
71:05 - event id
71:08 - we'll say two number
71:10 - it's equal to
71:12 - we'll say a search
71:14 - equal
71:15 - event content
71:18 - is equal to a new task
71:21 - search equal
71:24 - event completed
71:27 - i'll say false
71:29 - all right let's run the test
71:33 - and this time we won't see all this log
71:35 - output it'll actually just run the test
71:38 - and hopefully it'll pass yep it passed
71:41 - all right so we can see that our event
71:43 - was triggered whenever we
71:45 - called this create task function
71:47 - all right so i'm going to remove the
71:48 - space
71:49 - and that's how you write tests uh for
71:51 - this create task function and check on
71:53 - events now let's go to the front end
71:56 - application
71:57 - and create tasks that way now before you
72:00 - jump back into this make sure a few
72:01 - things are correct make sure that
72:03 - ganache is running
72:05 - your blockchain is running and make sure
72:07 - that
72:08 - your contracts are migrated that you're
72:10 - connected with meta mask right here
72:12 - things like that
72:14 - okay
72:15 - so what i'm going to do is actually
72:17 - enable this form
72:19 - that i commented out from the previous
72:20 - steps on the page
72:22 - so this form is going to have an on
72:23 - submit function create task which we'll
72:25 - build here in a second i haven't done
72:26 - that just yet but i'll just refresh the
72:28 - page and show what it looks like all
72:30 - right
72:31 - so we'll see this add task
72:33 - field and we'll actually type in a task
72:35 - here and we'll hit enter
72:37 - there's no button here just for
72:38 - simplicity's sake we'll just use the
72:40 - enter key in order to create the task
72:44 - all right so
72:45 - i'll go back to the app.js file let's
72:47 - actually add the create task function
72:50 - we'll do that like this
72:52 - let's do it down here below the render
72:54 - function
72:56 - all right we can say oops
72:59 - create task
73:02 - this will be an async function
73:10 - so what we'll do is say app dot set
73:12 - loading
73:14 - to true
73:15 - okay
73:16 - so whenever we call this we want to show
73:18 - the loader
73:22 - and we'll do that const content equals
73:26 - new task
73:29 - val
73:31 - okay and that's just the name of the
73:32 - form
73:33 - so if you go back to the index.html file
73:36 - you'll see this uh you know sorry it's
73:38 - the name of the the input it's on the
73:40 - form see on submit create task we're
73:42 - gonna fetch the value of
73:44 - this input right here this input which
73:47 - is the id new task okay and we're gonna
73:49 - get the value which is gonna be what's
73:51 - ever filled out inside there
73:53 - so new task value
73:56 - and now we're actually gonna call the
73:58 - smart contract function we're going to
74:00 - call this create task function uh with
74:03 - we know web3js with the truffle contract
74:05 - library and talk to the blockchain in
74:07 - order to actually update it so we'll say
74:08 - a white
74:11 - app.to-do list
74:15 - actually sorry this will be
74:17 - create task
74:21 - and we'll pass in the content from the
74:23 - value
74:26 - okay and whenever we do that
74:31 - whenever this is finished
74:33 - i'm just going to do a shortcut and
74:34 - reload the page so that whenever this is
74:37 - actually done i'll just refresh the page
74:39 - and it'll go ahead and fetch
74:41 - all the tasks from the blockchain again
74:43 - and list them out on the page so instead
74:45 - of having to like you know listen maybe
74:47 - for the event and then reload the page
74:49 - like sometimes i can get into a double
74:50 - rendering problem so i'm just going to
74:53 - um
74:54 - actually just reload so i'll say like
74:56 - window dot location no reload that's
74:59 - just a javascript thing to say refresh
75:00 - the page
75:01 - okay
75:03 - so let's test it out and see if it works
75:05 - i'm going to open the console and see if
75:06 - there's any errors
75:08 - nope we're good all right so we'll say a
75:11 - new task
75:12 - or we'll say task number one
75:14 - task
75:16 - number one
75:18 - and like i said there's no button here i
75:20 - just want to hit enter in order to make
75:22 - this work so i'll hit enter
75:25 - and i didn't put a button on here just
75:27 - for simplicity's sake
75:28 - i'll say confirm
75:32 - all right there we go
75:34 - so we successfully added a task we can
75:36 - see task number one was added to the
75:38 - list
75:39 - and and if you go and check ganache
75:41 - you can see
75:42 - uh the same thing if you go back to your
75:45 - transactions
75:47 - you can see that a transaction was
75:49 - created right here
75:51 - i think it's the same one
75:54 - yeah looks like that's the same one
75:57 - and also you can go to your logs see the
75:59 - same thing
76:02 - and scroll like crazy i think there's
76:04 - at the bottom right
76:06 - anyways that gives you an idea of you
76:08 - know where you can look to find out more
76:10 - information about the blockchain
76:11 - whenever you're doing this kind of stuff
76:13 - all right so we've successfully created
76:15 - a new task on our to-do list and we've
76:17 - you know done it inside the smart
76:18 - contract we have done it on the client
76:21 - side and we've written tests to make
76:23 - sure that this works
76:24 - so that's it for this section i'm going
76:26 - to go ahead and commit these changes
76:28 - i'll say get ad dot
76:31 - git commit
76:34 - let's say three
76:36 - creates tasks
76:43 - now the last thing we're going to do in
76:44 - this tutorial is actually check off the
76:46 - tasks from the to-do list whenever we do
76:48 - that they'll appear in a completed list
76:51 - down here and they'll be striked out
76:54 - so we'll do that like this
76:56 - first we're going to go to our to-do
76:57 - list we'll create a new function
76:59 - we'll call this toggle completed okay
77:03 - so i'm going to give you some space down
77:05 - here
77:08 - say function
77:10 - toggle completed
77:13 - okay so what do you want this function
77:15 - to do
77:16 - so we want to take this uh you know
77:19 - struct these task structs that are
77:21 - inside this mapping
77:22 - and we want to find a specific task
77:26 - and we want to change this value
77:28 - so if this value is already true when i
77:30 - change it to false and it's already
77:31 - false when i change it to true so
77:33 - basically if someone checked this item
77:35 - uh it would you know
77:37 - say that it's completed and if it's on
77:38 - the completed list we could check it and
77:40 - it would take it off the complete list
77:42 - and put it back in the you know not
77:44 - completed list
77:45 - okay
77:47 - so
77:48 - this function will need a parameter
77:50 - it'll need an id of the task that we
77:52 - want to actually toggle
77:54 - so we'll do that like this we'll say
77:55 - uint id
77:57 - all right we'll say public
78:02 - so first we will
78:06 - get the task out of the mapping all
78:08 - right
78:10 - so we need to read the task out of the
78:12 - mapping like this you can see task you
78:13 - know tasks count we can do the same
78:15 - thing we say task and we can read the id
78:17 - like this say id
78:20 - so that will actually fetch it out let's
78:21 - assign it to a variable
78:24 - whenever we do this we want to
78:27 - actually
78:29 - declare this variable with the type task
78:32 - and we're actually going to do this just
78:34 - in memory
78:35 - so it looks kind of funny but this is
78:37 - how we do that in solidity we say task
78:39 - this is the data type that we declared
78:41 - right here task
78:45 - memory
78:46 - and we say
78:48 - task like this
78:50 - okay
78:51 - now notice this underscore basically
78:54 - just means this is a local variable and
78:55 - not a state variable um it's not
78:58 - necessarily specific to solidity it's
78:59 - just a convention right you see this
79:01 - here in fact i'm going to do this like
79:03 - this as well id
79:05 - see you know content is underscored here
79:07 - because that was a local variable that
79:08 - was passed in the function
79:10 - id is the same way and i'm going to do
79:12 - just task like this because i don't want
79:14 - to assign it to the state
79:16 - um there's nothing special about doing
79:18 - that it just convention
79:21 - so now i'm going to say task
79:24 - dot completed
79:26 - and we basically want to do the opposite
79:28 - of whatever it was before
79:30 - so we can read the value of whatever it
79:32 - was before like this we just say tasks
79:34 - completed but we want to say the
79:36 - opposite so we'll say bang oops bang
79:39 - right
79:41 - so if it was false this will turn into
79:43 - true and if it was true it'll turn into
79:44 - false
79:45 - we're assigning that new value here
79:48 - all right next um we're going to put it
79:51 - back into the mapping
79:53 - so just like we did tasks task count
79:56 - equals this
79:57 - we're going to put it back into the task
79:59 - mapping say tasks
80:03 - uh id
80:05 - equals
80:07 - task
80:09 - all right
80:11 - so that's how we would create a function
80:13 - to toggle task completion
80:16 - now i want to do a few more things
80:17 - inside of here before we move on
80:20 - um i want to emit an event just like in
80:23 - the create task function
80:25 - so first we'll declare an event
80:28 - we'll just say
80:30 - event
80:31 - let's say task completed
80:35 - all right
80:37 - and we'll give this two arguments we'll
80:40 - say unit id
80:43 - say you
80:44 - went or sorry bool
80:47 - completed
80:50 - all right
80:52 - and now i will trigger that event inside
80:54 - here say emit
80:57 - task completed
81:00 - id
81:02 - task completed
81:05 - all right and that should work a lot
81:07 - like our create task function where that
81:08 - will emit an event anytime this
81:10 - function's called
81:14 - okay so let's actually write a test to
81:16 - make sure this works before we you know
81:18 - wire up the client side application
81:21 - we'll go to the uh test file right here
81:23 - and i'm actually going to split this
81:24 - pane uh vertically all right so i've
81:27 - just split this pane
81:29 - um we've got a test file down here and
81:31 - the smart contract cut up here so i'm
81:33 - just going to focus on this we want to
81:35 - just test this function unit test this
81:36 - toggle completed
81:38 - so i'm going to create a new function
81:40 - down here and give ourselves some space
81:42 - or sorry new example
81:44 - that will say that it toggles task is
81:46 - completed so i'll scroll down a little
81:48 - bit actually just uh
81:50 - copy this and paste it again to give
81:52 - ourselves some space and
81:54 - have some boilerplate so we'll say it
81:57 - toggles
81:58 - task completion
82:01 - and i'll clear out all this
82:05 - actually let's do this let's say result
82:07 - equals this dot to-do list dot toggle
82:11 - completed
82:14 - and i'll pass in
82:16 - uh
82:17 - one should be the first task
82:20 - and we'll get the task itself
82:23 - we'll actually retrieve the task
82:26 - now pass in id1
82:29 - all right
82:30 - and we want to assert that that's going
82:32 - to be equal to
82:34 - task
82:36 - completed we want it to be true
82:41 - and we want to fetch the event just like
82:42 - we did in the previous example
82:45 - and we want to ensure that the event id
82:48 - is equal to
82:50 - one
82:51 - and that the event completed is equal to
82:54 - true
82:55 - all right does that make sense so
82:56 - basically i know i modified a lot of
82:58 - that code so that might be a little
83:00 - tricky
83:01 - i didn't just you know write it out as i
83:02 - was thinking it i just changed what was
83:04 - there from the previous example so let's
83:06 - just review
83:07 - so we're toggling completed we're
83:09 - calling this function
83:11 - passing in the id of the first task we
83:13 - know there's a task already in the to-do
83:14 - list because we created one inside the
83:16 - constructor right
83:18 - and
83:19 - we waited for that to finish
83:20 - got the result which we'll use to read
83:22 - out the logs here in a second
83:24 - um
83:25 - but the next thing we did was we got the
83:26 - task right and we checked that it was
83:29 - actually completed right so that's true
83:32 - and now we want to make sure that this
83:34 - event was triggered
83:35 - and we you know get the event by digging
83:37 - into this result which we witnessed in
83:39 - the previous section if you didn't check
83:41 - that out go ahead and rewatch that part
83:43 - um so we took the event and got the id
83:46 - made sure it was 1 and then looked at
83:48 - completed and ensured that it was true
83:51 - all right so let's try to run the test
83:57 - all right it looks like i've had an
83:59 - error
84:00 - let's go back to this code we can see i
84:02 - forgot the underscore here
84:04 - let's run it again
84:06 - all right it passes awesome
84:09 - okay so i'm going to remove this space
84:11 - save this
84:14 - now let's go to the client side
84:15 - application and wire up the check boxes
84:18 - to toggle the tasks
84:20 - so go back to the app.js file and i'll
84:22 - create a new function down here
84:24 - i will call it
84:26 - toggle completed i believe this is the
84:28 - same name as the smart contract function
84:31 - so below create task we'll say toggle
84:33 - completed
84:35 - i'll say async
84:37 - pass it a function
84:40 - and we'll do is similarly to create task
84:43 - we will say the app is loading
84:46 - say const
84:48 - task id
84:50 - and actually inside of here this is
84:52 - going to be on a on click event because
84:54 - whenever we click this check box uh
84:57 - we're gonna you know have an event
84:58 - listener that calls this function
85:01 - so i'm gonna pass in the actual event
85:03 - itself
85:04 - we'll just use e for short
85:06 - and that event is gonna contain
85:09 - the name of this check box
85:11 - which the name value is going to be set
85:13 - to
85:14 - the actual task id
85:16 - so we'll say e target
85:18 - name
85:19 - and now i'll say
85:21 - await we're actually going to call the
85:22 - smart contract function to toggle this
85:24 - task is completed say app
85:26 - dot to-do list
85:30 - toggle completed
85:33 - i'm going to pass in the task id
85:36 - all right
85:37 - and then just like the create task
85:39 - function whenever that's finished i'm
85:40 - just going to reload uh the webpage
85:45 - semicolon or sorry a comma there
85:48 - okay no errors
85:50 - but if you remember in the previous
85:52 - sections
85:53 - i commented this out so i'm going to put
85:55 - i'm going to re-enable this this is
85:57 - where we actually wire up the on click
85:59 - handler to do this so now
86:02 - whenever we're rendering the tasks out
86:04 - we found you know the check box and we
86:07 - want to actually add the event handler
86:09 - whenever it's clicked
86:11 - to call this function
86:13 - so everything looks good
86:15 - all right
86:16 - let's try it out
86:20 - i'll try to check this off the list
86:22 - see if it works
86:24 - all right looks like we got
86:26 - a problem here
86:27 - all right we do have a problem and i'm
86:29 - gonna see if you can guess what it is
86:32 - it's something i forgot to do in the
86:34 - previous step and i'm actually going to
86:35 - leave this in the recording because it
86:37 - kind of shows you the nature of
86:39 - blockchain development and all the
86:40 - things you need to do
86:42 - do you know what it is yet
86:44 - well i'll tell you we forgot to run the
86:46 - migrations
86:48 - so we added a new function to the smart
86:50 - contract and it worked on the tests um
86:53 - but we didn't actually deploy a new copy
86:54 - of the smart contract to the blockchain
86:56 - with this new function
86:58 - so in order to do that we'll run truffle
87:01 - migrate dash dash reset to deploy a new
87:04 - copy of the smart contract to the
87:06 - blockchain
87:07 - and whenever we do that we're going to
87:08 - want to refresh our web page to pick up
87:10 - that change
87:12 - all right so let's try that again sorry
87:14 - guys i forgot that step like i said i
87:16 - wanted to leave that in the video just
87:18 - to show you you know something you might
87:19 - forget to do um and hopefully that'll
87:22 - help you remember
87:23 - all right so we'll refresh the page
87:25 - now we see that our other task is gone
87:28 - now why did that happen well that's
87:29 - because you know whenever we deploy a
87:31 - new copy the smart contract all the
87:34 - state of the smart contract is gone
87:36 - right it's a new smart contract whenever
87:38 - we redeploy so all the old tasks we had
87:41 - in the smart contract have disappeared
87:43 - so we'll add a new one we'll say task
87:44 - number one
87:46 - about a few
87:48 - we'll just sign these really fast
87:51 - task number two
87:56 - task number three
88:01 - all right so now it's actually toggle
88:02 - one is completed and we see the metamask
88:04 - confirmation pop up we'll sign it
88:06 - confirm
88:08 - and there we go
88:09 - we've actually successfully uh checked
88:12 - off task number one from the list and we
88:14 - can see that it was added to
88:17 - um
88:18 - you know the list down here below so we
88:20 - can you know actually to do the to-do
88:22 - item on task number two we can go to
88:24 - dappyuniversity.com
88:27 - all right we see it awesome we went
88:29 - there
88:30 - and now we can go here and check that
88:32 - out the list because we actually did it
88:34 - confirm
88:36 - and there we go
88:37 - all right so that's it guys that's
88:39 - actually the end of this tutorial you've
88:41 - successfully created your own to-do list
88:44 - on ethereum powered by smart contracts
88:47 - and you've created this client set
88:48 - application to interact with it so
88:50 - congratulations
88:51 - i hope you all like this tutorial
88:54 - again be sure to subscribe to the
88:55 - channel if you haven't already and also
88:58 - don't forget you can download
89:05 - you can just sign up for my email list
89:06 - to you know get my courses downloaded
89:08 - for free and also you can you know keep
89:11 - up with me on twitter and stuff like
89:12 - that for more daily updates
89:15 - so also guys
89:16 - i'm releasing a premium course like a
89:19 - full decentralized blockchain
89:21 - development course
89:23 - sometime soon so you'll want to sign up
89:25 - for that email list to find out more
89:27 - updates about that it's going to be
89:28 - really extensive it's going to be really
89:30 - awesome
89:30 - you're going to want to learn about it
89:33 - so just stay in touch and also by the
89:35 - time this video is out you'll be able to
89:37 - find an article
89:38 - to accompany this video which you can
89:40 - follow along step by step it'll be
89:42 - somewhere on my website it'll probably
89:44 - be in the video description below as
89:45 - well you can see other articles on my
89:47 - website here
89:49 - um
89:50 - like you know this is the uh ultimate
89:52 - ethereum dap tutorial which i released
89:54 - last year uh which is a pretty popular
89:56 - tutorial that shows you how to build
89:57 - your first decentralized application i
89:59 - mean you can code your own
90:00 - cryptocurrency on ethereum
90:02 - you know build an erc20 token and stuff
90:04 - like that got some other deep dives on
90:06 - topics like you know web3js which we
90:08 - talked about some in this tutorial
90:11 - um you know a lot more lessons on
90:13 - solidity how to develop smart contracts
90:15 - i kind of go into more features of the
90:17 - language and things like that so this is
90:18 - a huge resource with a lot of free stuff
90:21 - a lot of good information i also have
90:23 - some tutorials on like how to build a
90:25 - real world ico and things like that this
90:27 - is like a you know production ready ico
90:30 - that you could use in the real world
90:32 - this is pretty advanced you know and
90:33 - also if you're looking for somebody to
90:35 - work on your blockchain projects um you
90:37 - know i am available my email address is
90:39 - down below i do a lot of you know
90:41 - blockchain development a lot of
90:43 - consultation and advising for people who
90:44 - are launching blockchain startups icos
90:47 - things like that i've got a complete
90:48 - solution for launching an ico like i
90:50 - said you can reach out to me via email
90:52 - my email is on my website and also in
90:54 - the description below some buttons here
90:56 - you can contact me on the website like i
90:58 - said my twitter's here things like that
91:00 - so again i hope you all liked this
91:01 - tutorial until next time thanks for
91:03 - watching dap university

Cleaned transcript:

hey everybody this is gregory from dapp university so today i'm going to show you how to write your first blockchain application i'll show you how to create a todo list that's powered by ethereum smart contracts i'll show you how to create your first ethereum smart contract with a solidity programming language or write tests against the smart contract deploy it to a blockchain and we'll also create a client side application for the todo list so if you're new around here be sure to subscribe to this channel and click the like button down below and also you can download my courses for free on my website over at dap university dot com forward slash free download i've got a link to that down in the description below and also on my website you can find a fulllength article to accompany this video you can actually follow that step by step as you're following this tutorial and i've also got a link to that in the video description so before we start actually building the application let's get a high level overview of how a blockchain application powered by smart contracts actually works so how does a blockchain work and how does a blockchain application work well i've chosen a todo list for this tutorial because that's a really common way to learn any new technology and i want to use that to show you how a blockchain application works so first let's look at how a todo list would work as a web application and then i'll show you how it would work as a blockchain application so i'll put my whiteboard up here to demonstrate so normally whenever you access a web application like a todo list for example you use a web browser and you connect to a web server over the internet and you access you know all the code and all the data from this web server so like this you basically connect from your web browser to the server and on the server it contains all the you know clientside files like html css and javascript it you know contains all of the backend code for the server right any business logic you might write and any data that's stored in your application is stored in a database right and pretty much any other todo list tutorial that's out there is going to show you how to write you know a clientside application and html and css and javascript and then it's going to show you how to basically do some business logic on a web backend that you know creates reads writes updates to do's and it puts them inside of a database like this right and all that's you know on a central server and that's how you build a todo list on a web application so how would you build a todo list on a blockchain well it would work a little bit differently so instead of connecting directly to a server you know we're gonna access our todo list via a browser and we're gonna you know connect to a clientside application that we will build and this will just be a simple clientside application on a web server but this clientside application isn't gonna talk to a web backend in a database instead it's going to actually talk directly to the blockchain and on the blockchain we're going to have code that's going to be written with ethereum smart contracts that will contain all of the business logic for our todo list and all the todo items are going to be stored on the blockchain itself and that's fundamentally how a blockchain application would work and how it's different from a traditional web application so that might bring up a lot of questions like well how do we connect to a blockchain and how does the blockchain work like what even is a blockchain well i'll pause here and tell you a little bit more about that so what even is a blockchain right or clientside application is actually talking to a blockchain right here so it's actually a separate network okay and a blockchain is a peertopeer network of nodes that all talk to one another it's a distributed network so there's actually different computers different machines that talk to one another and we can connect to an individual node on the blockchain in order to use it that's what our web application is doing here so all the nodes on the network participate in running the network they all contain a copy of the code on the blockchain and all of the data on the blockchain and all of the data on the blockchain is contained in bundles of records called blocks which are chained together to make up the blockchain and all the nodes on the network also participate in ensuring that the data on the blockchain the public ledger is secure and unchangeable and that's what makes the blockchain so powerful and so what about the code on the blockchain well all the code on the blockchain is contained in smart contracts so smart contracts are basically just programs that run on the blockchain and they're going to be the building blocks of blockchain applications and that's what we're going to build our todo list out of we're going to write a smart contract that will contain all the tasks in the todo list and allow us to add new ones and complete them and things like that so smart contracts are written in a programming language called solidity and all the code in the smart contract is immutable which that means it's unchangeable whenever we deploy to the blockchain we won't be able to update that code and that's important to understand because that's what makes the blockchain so secure whenever we put code on the blockchain we know we can trust it at that point it's called trustless for a reason whenever it's on the blockchain we know that no one will change it and therefore we know the todo list will behave the same way every time and sometimes i actually think about smart contracts kind of like microservices on the web they're on the blockchain and they read and write data from the blockchain and they do stuff with it you know they execute business logic all right now go back to the drawing board and kind of give you a refresher about how our application is going to work again we're going to connect the application with a web browser and we're going to build a clientside application in html css and javascript and that clientside application is going to talk directly to the blockchain and that's where we're going to put our smart contract we'll create the todo list with an ethereum smart contract written in solidity and we'll compile it and deploy it to the blockchain it will also connect to the blockchain network with our personal account with an ethereum wallet in our browser and i'll show you how to get that set up in this tutorial as well so now we've seen how blockchain works and how we can build our todo list application on the blockchain so let's jump in and start programming here's a preview of the application that will develop in this tutorial this will be a todo list powered by an ethereum smart contract where we'll be able to add new todo items and we'll be able to check items off of the todo list and before you get started you need to make sure you have node.js already installed on your computer you can see if you have node installed by going to your terminal and typing node v you can install node with a package manager like homebrew or you can download it directly from the node.js website the first item in the blockchain developer toolkit is a personal blockchain we're going to use ganache as our personal blockchain for this tutorial you can head over to truffleframework.com forward slash ganache to download it you can click this download link and whenever you've downloaded it make sure you install it and when you open it you've got a local blockchain running so what is ganache you know what is a personal blockchain well a personal blockchain is like a real blockchain network you know that's connected to the public or anyone can connect to it but it runs on a computer it's you know a closed network and ganache basically you know is a process that runs on a computer that spins up this blockchain and runs on a server so we can use this to develop smart contracts we can run tests against it we can run scripts against the network develop applications that actually talk to this blockchain and it's really helpful and it's an invaluable tool in the blockchain developer toolkit so um if you open ganache you'll see you know 10 accounts listed here these are the addresses to each account on the side and you'll see you know these balances you'll see 100 ether and this is the ethereum cryptocurrency that each account has and it's you know required to you know pay gas fees in the network and stuff like that all right so that's an overview of the ganache personal blockchain network and we're going to leave ganache here set up in our project because we're going to need it uh running in order to develop our project the next dependency is the truffle framework we're going to use the truffle framework to develop ethereum smart contracts with the solidity programming language you can install truffle by going to your terminal and typing npm install g truffle at 5.0.2 and it's important that you use this exact version in order to follow along with this tutorial so truffle is a suite of tools that allows us to you know develop smart contracts write tests against smart contracts deploy smart contracts to the blockchain it gives us development console and that also allows us to develop clientside applications inside of our project so it does a lot and i'm going to show off all those features in this tutorial the next dependency is the meta mask extension for google chrome remember that the ethereum blockchain is a network and we need a special browser extension in order to connect to that network and that's where metamask comes into play metamask will allow us to connect to the blockchain with our personal account and actually interact with the smart contract that will develop in this tutorial you can install metamask by going to the google chrome web store and searching for metamask and clicking install and once you've installed it just make sure that you enable it inside of your chrome extensions like this you can also see the little fox icon in your extensions tab now let's create the project i'll start by creating a directory for our project like this eth just stands for ethereum so i'll enter into that newly created directory and now once we're inside of here we'll actually create a new truffle project but before we do that i just want to make sure that you're using the correct truffle version you can check your truffle version like this truffle version and you want to ensure that your version is the same as mine which is 5.0.2 so it's not go ahead and check out the dependencies section of this video to see how to install the specific version of truffle so now we'll initialize a new truffle project like this we'll just say truffle init all right and now we've successfully unboxed a new travel project and now i'm going to actually create a package.json file in order to you know pull in some development dependencies for the project so i'll say touch package dot json all right and now i'm going to open this project inside of sublime text that's the text editor i'm using so let's go to the package.json file we can actually see the project directory over here and we can see the newly created package.json file and it's empty i'm going to paste in the contents of this file that we'll use for this tutorial and you can actually get this package.json file by cloning this repository on the github link in the description down below all right so here's the dependencies for the project i'm just going to go ahead and save this like i said i just pasted these in here and you can see we have a few dependencies like the bootstrap framework we'll use this for building out um the clientside application we've got some dependencies for testing the smart contracts a server for running the clientside application and you know some other truffle specific development dependencies and i've locked these versions um so that you can keep following this tutorial in the future so make sure that all these versions match what i have here so now i'm actually going to install the dependencies for the project like this so i'll just say npm install all right so now they're installed now let's go back into our project and actually create the smart contract file that we'll use to build the todo list we'll do that by going to the contracts directory and you can see there's a smart contract that exists inside of here this is actually a smart contract that comes bundled with truffle that manages migrations to the network and i'll explain that here in a little bit and now i'll create a new file inside this directory called to do list dot sol so we can see that todo list is capitalized to do list and it's in the same project directory here so now let's actually create the smart contract that will manage the todo list for the application the first thing we want to do inside this file is actually declare the version of the solidity programming language that we want to use we'll do that like this we'll say pragma solidity we'll use a carrot i'm going to say version 0.5.0 and we'll end this line with a semicolon all right now the next thing we do is actually declare the smart contract we do that with the contract keyword say contract and we want to call this contract a todo list which is the same name as the file say todo list and we follow that with some opening and closing curly braces and inside of here is where we actually write all of the code for the smart contract now i'll go ahead and bump the font up so you all can see this a little better so the first thing that we'll do inside of here is just keep track of the number of tasks that are in the todo list and we'll store this value inside the smart contract as a way to kind of get started and just make sure that everything is set up properly in our project we'll deploy this simple smart contract to the blockchain and actually see if we can connect to it before we you know do anything any more complicated than that so first we'll keep track of the number of todo lists inside of the smart contract with a variable and it'll be a special kind of variable and solidity called a state variable and we can declare a state variable like this we'll say unt task count so state variables inside of solidity are actually written to the blockchain and that's what they're called state variables they actually represent the state of this smart contract on the blockchain and the state of the smart contract is going to change anytime this task count changes and these are a lot like you know class variables in an objectoriented context where you know the scope of the variable belongs to the entire smart contract not necessarily like a function or something like that we'll see that more as we continue on through this tutorial but initially we can set this value to zero like this all right we just say equal zero and we can also create a way to read this value from the smart contract with a keyword called public all right and what that does is actually provides some a function for us that allows us to read the value task count from the todo list and solidity kind of just magically gives us a function whenever we use this public keyword all right that's all we'll do for our basic smart contract in order to set this project up and actually deploy this to the blockchain and make sure that everything's set up correctly we'll come back and you know build this out throughout this tutorial but for now we just want to do a simple check to make sure everything works properly now let's actually compile this smart contract before it goes to the blockchain and make sure that we wrote all our code correctly we'll go to the terminal and type truffle compile and we can see that it actually created some new files here i'll show you that in the project if you go to the build directory and then contracts we'll see migrations and todo lists.json so this is actually a json representation of the smart contract that's created by truffle and it contains some information that's useful to us this is the smart contract abi which is the abstract binary interface we'll actually use this later in the tutorial when we talk to our smart contract in javascript we can see the byte code that was created by the smart contract this is actually the byte code that gets run on the ethereum virtual machine and yeah there's a lot more useful information inside of here but i just wanted to show you that initially now in order to actually put this smart contract on the blockchain we want to create a few more files and i'll kind of give you a tour of the rest of the project structure here as we do that in order to connect to the blockchain we'll actually need to update this truffle dash config file all right and i'm actually going to just paste some code inside of here again you can get this code from the repository uh for this project the github repo that i've got down in the description below you just check out that link all right i'm just going to save this and i'll explain what's going on here basically inside of this configuration file we have the network's key inside of this object right so what that does is allows to specify several different networks but here we have a development network um that's actually connecting to ganache so this is localhost and this is the port that ganache is running on so while we're here let's go ahead and actually make sure that ganache is running so you can open ganache find wherever you installed it make sure it's open and we can see that the port is 7545 right and we can see it's localhost 127.0.0.1.7545. so now that we have this filled out um this is actually talking to the local blockchain now let's create a migration file in order to get the smart contract onto the blockchain so if you go to your migrations directory you'll see a file inside of here it's called initial migrations so i'm actually going to copy the contents of this and actually create a new file in the same directory and i'll call it uh two we'll say deploy contracts dot js okay what's inside of this directory well these are migrations i'm just going to paste this code in here so what is a migration well if you've come from another development background where you've used a database you might have had to change the state of that database by adding new tables or adding columns to the tables and that's because you're changing the state of the database the structure right the schema and that's essentially what you're doing in this project right here with a migration whenever you're deploying a smart contract to the blockchain you're actually changing the blockchain state remember the blockchain basically is just a big database in one sense and whenever you put the smart contract on the blockchain you're updating the state and thereby you need a migration in order to do that okay and you'll see these migration files over here are numbered and that tells truffle what order they need to be run in so make sure your starts number two and inside of here what we'll do is actually change this we'll change migrations to be a todo list so todo lists from artifact require truffle creates a an artifact out of this todo list.json that we saw a second ago and that's going to be just a an abstraction of the smart contract that it understands in order to put in the blockchain now let's actually run the migration and deploy the smart contract to the blockchain so first again make sure that ganache is running make sure that you've you know configured this correctly and we'll run the migration like this we'll just say truffle migrate all right it looks like it was successful so what we've done is actually deployed the smart contract to the blockchain and if you open ganache you'll see that something has changed you know with this first account we'll see that the balance of ether you know the ethereum cryptocurrency balance has actually gone down by a little bit that's because deploying smart contracts to the blockchain actually costs ether it costs gas and we can see that this account has done that it's actually paid the gas fee in order to deploy the smart contract to the blockchain and truffle by default uses the first account inside this wallet in order to pay those fees now let's open the truffle console in order to check the smart contract that we deployed to the blockchain we'll do that like this we'll say truffle console now we'll retrieve the smart contract from the blockchain like this we'll say todo list equals await todo list dot deployed so todo list is the name of the uh smart contract that we created in the migration we go back to project and see you know this todo list right we've actually retrieved the smart contract a deployed copy of it from the blockchain and assigned it to this variable todo list and you'll see this await keyword here so let me explain that we must interact with the blockchain in an asynchronous fashion and if you've ever developed other javascript applications you would know that there's a lot of different strategies for handling asynchronous actions right you can use promises there's a lot of different ways to do it but with truffle version five we've actually been able to use the async await pattern inside the console which is really nice you can just do things in a simple one line like this basically this is just saying you know wait for this finished result and whatever the result is assigned to this variable so we can actually look at that we say todo lists all right you can actually see the result as the smart contract here and i'll just pull this up so you can see let's actually get the address the contract we'll say todo list address all right and we can see this is the address of the smart contract that's deployed to the blockchain this is just where it's located and now we can actually see the count of tasks that we created in the smart contract so we'll say to do list dot count like this or sorry task account that's what we called it all right we can see that is zero and now truffle actually stores that as a big number whenever we retrieve it we could convert it to a number like this we could just say uh task account assign it to a variable and say a weight all right we could say task count two number and i see that it's zero all right so that's a good check to see that everything is set up properly if you've been able to complete all this so far you know you've been able to create a smart contract create a new truffle project you know connect it to a blockchain and actually to put the smart contract on the blockchain and talk to it if you have any trouble just you know rewind the video and try to see where you might have gone wrong what we want to do now is actually pause and commit some of these changes i'm going to create a new git repository i'll say git init and inside of here i'm actually going to create a git ignore file you don't necessarily have to follow along with all these steps but i'm just going to do them so that you all can see what i'm going to do inside of here is create this git ignore file that ignores the node modules directory so that we don't commit all the node modules to source all right i'm going to say git add i'm not sure what all these errors are sorry i'm going to get commit i'll say project setup all right so that's it for the first part of this tutorial where we've actually set the project up in the next section we're actually going to list out the tasks in the todo list now let's list out the tasks inside of this todo list i'll show you the steps that we'll follow first we'll list the tasks in the smart contract and then we'll do that in the console and next we'll actually wire up the client side application and list the tasks there and finally we'll write some tests that make sure that the smart contract is listing the tasks correctly so first we'll go to our smart contract that we've been working on todo lists and we'll actually write the code to list out the tasks in the todo list here so first we'll need a way to actually model the task we'll do that with something called a struct solidity allows us to define our own data types of structs and we can create a new struct like this we can say struct task follows with curly braces and we'll actually give this some more attributes in a second let me pause and explain uh some more features of solidity right solidity is a statically typed language in fact you can see the data types listed here you know uint this is an unsigned integer which basically just means that it's an integer uh that can't be negative right so integers can be positive or negative with a minus sign you know a sign in front of it or a positive sign and so solidity allows us to define this uh struct task here and we can give it some attributes like this we can say uint id this will be the id of the task this is going to be an unsigned integer which basically just means an integer that can't be negative right if it was a negative integer would have a sign in front of it that'd be a sign integer but this is unsigned and the next thing will be a string and we'll say the content this will just be you know the text and next will be a boolean and that will be completed and that will represent the checkbox state of the todo list you know whether the item has been checked off or not all right so that's how we'll actually model a task on the todo list with this data structure and now we need a place to put these tasks so where will they go well we effectively want to put these in storage on the blockchain so how do we do that how do we access the storage we need to create a new state variable like we did here with task account remember task account is getting written to storage it's a state variable it's representing the state of the smart contract which is written to the blockchain the actual data storage and we'll actually want to create a state variable called tasks here but we don't want it to be you know an unsigned integer we want a different data type we want something called a mapping and this is going to take a key value pair like this it'll say uint say task okay now mapping and solidity is a lot like an associative array or a hash in other programming languages where you store a key value pair right and when we declare this mapping here we declare the data type for the key which is an unsigned integer and the task which is you know this struct that we defined here and essentially this is going to be kind of like a database for us it'll have a uint an unsigned integer that will be the id essentially of the task that we'll store here so we can look for task you know one two three and it'll return the tasks okay and we also want to make this public just like we did with a task account and that will give us a reader function for free provided by solidity that will allow us to access the items out of this mapping all right now we have a way to create new tasks and actually put them in the you know database or the blockchain in this case we'll be able to use this task id reference here and store the task like this so now we need a way to actually put this task struct inside of this mapping to do that we'll create a function called create task say function create task and inside of here we'll provide a single argument which will just be the content of the task itself so we'll say string memory say content let's be public all right now inside of this we're going to write some code that puts this task inside of this mapping so the first thing we'll do is determine the id of the task we're going to create right so that's why we're using task count and you see that each task struct has an id and we want to increment this task count value anytime we're creating a new task to put inside of this mapping so do that like this we'll just say task count and we'll just use the increment operator you might find this uh to be similar to other programming languages where you're basically just changing this value by one all right so once we've done that we'll have a new task count which if this is zero and the first time we call this uh it'll change to one and that means the first task that we put inside of this mapping whenever we call this create task function will be one and the next time it'll be two the next time it'd be three so now let's actually put it inside the mapping we do that like this we'll say tasks that will reference the mapping and we'll say task account we can actually reference it by uh you know the key which will be the unsigned integer here and we'll just say equals and we'll create a new task we'll do that like this we just say you know task just copy this and we say task count we just provide the arguments for the structs so the id the content and completed so the task count is the new id the content is the content being passed in oops from the function and it's a new task so it's not completed yet so we'll just say false all right now we have a way to actually put tasks inside the todo list which we'll need as a prerequisite in order to list tasks you know we'll need some tasks inside of the todo list in order to show them and the next thing we want to actually do is you know go ahead and populate our todo list so that when we you know call it up on the client side it's already got some todo items inside of it for us okay and what we can do is basically just add some tasks to this list whenever this smart contract is deployed so how do we do that well we do that with something called the constructor function for the smart contract so if you've ever used another programming language that has like an initialize function inside of a class or some sort of object you know maybe init or new something like that you've seen a constructor before so basically this is just going to be a function that's called whenever the smart contract is run for the first time which in this case is upon deployment all right so inside of this constructor function we can actually add a default task to the todo list all right so we do that like this we'll just say create task task and we'll just pass in uh check out app university dot com all right i'll put a semicolon here so now whenever we access the smart contract for the first time it will have a default task inside of it so whenever we list the tasks out there will be something they're forced to see and that way we'll know that this worked properly whenever we look at this in the console and connect our clientside application and write tests and things like that all right now let's actually compile a smart contract to make sure it worked we could just say truffle pile i may have some syntax errors or something like that we'll see all right it worked so now let's actually open the console to see if it worked we'll say truffle console well actually first before we do that let's make sure we have ganache running i don't so let's pull it up all right so ganache is running and now we actually need to migrate our smart contracts we'll say truffle migrate i'm just going to pass in the reset flag to be safe here in case you had ganache already running so what does the reset flag do well that would deploy a new copy of the smart contract to the blockchain if an existing one um is already there so like if you go you know we change our smart contract code here so if you added new functions or something like that you could migrate with the reset flag uh to deploy a new copy so i'm gonna do that just in case you had ganache running already all right now let's open the truffle console so i'll do it like this truffle console and what we'll do is actually list out the todo items so first i will just get a copy of the todo list we'll say todo list equals await to do list.deployed all right let's make sure the address is there say to do this to address oops misspelled that okay now let's actually list out the items now let me explain something about this mapping we want to call this tasks function that's provided by solidity to list out the task in the todo list and remember we declare this public so solidity gave us a tasks function for free to reference this mapping but whenever we call this function it won't just return all the tasks in the list and that's because solidity doesn't do that for us this mapping is a dynamic size there's no way you know and natively to know how big it is inside the smart contract um and so you can't iterate over it and you can't just return the entire thing you actually have to reference the items out one by one and that's why we're using the task account counter cache here so if we know that this task count is one that means there's only one task in the todo list and we would just have to call this function one time to get that task and we would pass in the id which would be one in this case and it would return the task if it were 10 we would have to do this 10 times we'd call this function once with one and that would return task number one we'd call it the second time with two and that would return task number two et cetera et cetera until we get 10 which case it will return task number 10. so that's how we would do that and if you're doing that on the client side we would use a for loop or something like that which we'll get to whenever we reach that section so for now inside the console we can just reference you know the only todo item inside of here the only task is this one so we can say task equals await to do lists dot tasks and we'll say one all right let's see the task she bumped this up all right there you go so there's the task we can see the content check out dapaniversity.com we can see that it's completed as false we can see the id is one it's a big number but we can actually do that inside here we can say task id two number right it's one task content sorry it's not a function it's just an attribute all right so now we've actually migrated this smart contract to the blockchain and we've been able to list tasks inside the console now let's create the client side application and actually list out the tasks there so in order to do that we'll need to create some new files first we'll create a directory to store the clientside files we'll just say this say source so we see a new directory came up here and we'll create a new file inside of here called index.html sorry say touch source index.html and we'll create an app.js file to store all the javascript code say touch source app.js okay stepping over the project and see we have an empty app.js file and an empty index.html file and another file we actually want to create is um a bs config file so bs config stands for browser sync configuration i mean browser sync is something that we use uh as a part of light server so if you go to your package uh json file you'll see this light server dependency so this is the web server that we're going to use in order to run the client side application we need to configure the server to know about a few different directories inside of our project we want to tell it where the source directory is for the you know client side files we want to tell it where these contract the smart contract json files are we also want to tell it where our node modules are to pull out some dependencies for building out the front end so we'll do that like this we'll actually create a new file say touch bs config dot uh json okay so inside of this file i'm actually going to paste in some code um and you can actually get this configuration from the project from github down in the description below let's paste this inside of here and don't worry too much about this this is all just proprietary uh browser sync configuration so basically we're just saying the server configuration is uh this and we're pulling the files in from the source directory and also the build contracts directory so basically it's saying expose all of these directories to our our web server root and then also we're going to mask a vendor with node modules so any uh node modules that exist inside our project we can reference those at the vendor route all right so there's a server configuration and now we actually want to fill in the index.html file now likewise inside of here i don't want to spend a bunch of time writing html and css so i'm going to just paste in uh the code from the application and again you can just pull this source code from the github link down below i'm just going to paste this in like this what we'll do is actually build out the javascript part but i don't want to spend too much time writing the html all right so i'm going to paste this in here i'll explain you know what's going on um basically you know we're pulling in the twitter bootstrap framework to write the front end so we don't have to write a bunch of css and ui elements ourself um you know we can see this uh bootstrap that was what i showed you a second ago in bs config that's how i got this vendor here and we can see some basic css that's just written inside the head tag and yeah we got some markup essentially we have a simple loader to show whatever the application is loading a form that allows us to create a new todo item and we will actually um have a way to list out the tasks here so for now i'm going to just uh comment out this form i think i think it'll run otherwise all right and let's actually just see if we can start the server so i'll start the server in a new tab i'll say uh npm run dev i believe is the command all right yep that worked so you can see uh that we basically got something right we see it's loading that's fine um if you open your console i'm sure you'll see some errors or something like that yeah failed the resource that's okay don't worry about that just yet we will wire this up to actually work but for now i just wanted to make sure that the server is working properly that we can see bootstrap right we see this nav bar up here we can see the dav diversity todo list you actually click through this link it'll take you to my website which is pretty cool um but yeah so let's fill in the project and actually list out the todo's in this clientside application so to list the todo items we essentially want to fill in uh this unordered list we've got two here we have a list for the tasks and then the completed tasks so if we have an uncompleted task it'll go in this list and whenever we complete them it'll go here but for now they're all uncompleted so they'll stay in this task list all right so in order to do that we need to do several things inside this app.js file this is where we'll actually create um you know our javascript app that talks to the blockchain so the first thing we'll do is actually create an app like this let's say app this is object okay and we'll create a load function and actually call this async we're going to use a lot of async functions inside of this tutorial i've been using a lot of async await pattern when loading data from the blockchain it seems to be pretty helpful so we'll fill this in and then in order to load the app let's actually do this console log uploading and in order to load the app whenever the project loads we'll just say say window when it loads we'll just uh pass in a function say app.load actually didn't mean to put that inside this object do it like this all right so let's reload all right so we see the app's actually loading all right now i'm actually put these windows side by side and you can see that this todo list is actually responsive which is cool we'll be able to see the tasks right here and be able to focus on the code while we're doing this the first thing we want to do inside this load function is actually say await app.load web3 we want to load the web3 library in order to connect the blockchain now when we load web 3 i'm actually just going to use the configuration that's specified by metamask themselves right what we're doing is creating a way to talk to the blockchain we want metamask which is going to be the browser extension that we use to connect to our dap our blockchain application to talk to the blockchain with web3js and metamask actually suggests a way to do that so i'm not going to reinvent the wheel here i'm just going to do what metamask tells us to do so i'm going to actually just paste in the configuration that they suggest and don't worry if you don't understand what's going on here just know that this works and it's inside of the github repository then you can find the code and link it with the link in the description below so let me pause because i don't feel like i've fully explained web3 js very well and what's going on here okay so remember this todo list application is backed by the blockchain and we want to actually connect to the blockchain to use it so a few things have to happen we have to connect our browser to the blockchain and that's what we'll use metamask for right and then our clientside application needs to actually connect to the blockchain and that's what web3js is for so inside of our project we'll use the web3.js library to talk to the ethereum blockchain it'll actually allow us to connect to it and you know read and write data from the blockchain inside of the app and then metamask will allow us to you know communicate with that client that application with web3js and allow us to you know interact with it via our browser so what we did here was just loaded up web3.js you know loaded our blockchain connection essentially we even call this like connect to blockchain if we wanted to um and now we'll actually use our browser to connect to it with metamask so let's actually do that i will open up ganache let's actually find the private key here we'll show the key copy it all right we'll go to metamask and make sure you've opened this if you haven't already and what you want to do is connect to the private network which is localhost 7545 right so you might see the main ethereum network first but you want to change networks to localhost 7545 here and what you want to do is click this accounts menu you want to import account and you want to paste in the private key select type private key and click paste and then import all right i've already done this step so i'm not going to do it so i'll click cancel whenever you've imported the account you know from ganache you want to use this make sure you use the first one because that's the account that we deployed the smart contract with okay you'll actually be connected with that account to the blockchain right so here's your blockchain account and then you can add it to your wallet in metamask to connect to the blockchain with your web browser and you'll specify the blockchain by you know picking this local blockchain that we have running with ganache okay so refresh that all right and you've got um your account connected to the network now let's take that account um from ganache this one right here and let's show it in our application to prove that we're actually connected to the blockchain with it all right so i'll just say load account like this create a load account function say load account this would be async and i'll say app.account equals each counts zero okay so web3 here was set by uh load web3 and it has this eth object that's going to contain all the accounts which will be an array once you get the first one which will be the account that we're connected with inside of metamask and inside the load function i'll say await load account app.load account okay save that and now inside of the index.html file um you'll see that we have a place for the account here this will be the place where we can actually add the account we'll do that in a second but for now it's actually just console.log and see if it worked properly all right yep there we go we can see it here we can verify that's the same account in metamask so e925a and that's e925a all right so we've successfully retrieved the account from metamask and we'll actually stick it inside the project in a little bit okay so we'll just clean that up now let's actually load the smart contract from the blockchain this will be the todo list that we created so that we can list out the tasks from the todo lists uh in order to do that we'll say load contract say async pass it a function um and inside of here the first thing we'll do is actually pull out um the smart contract json file say const todo list equals a weight let's say jquery get json let's be todolist okay so if you remember inside the bsconfig file we exposed the build contracts directory to the root of our project so we can call this todo list.json file we're actually pulling out this file right here and we can log it we can log it but in order to do that we need to call this function say oh wait contract okay all right we can see it here here's the todo list uh file okay so next what we want to do is actually create a truffle contract so truffle contract is just a javascript representation the smart contract that will allow us to you know call the functions on it and things like that so what we'll do is i'm just going to paste in some code that shows you how to do that do like this okay so this will be uh we'll call truffle contract we'll pass in this todo list json file that's basically gonna create a wrapper around the json file that we created by truffle and it's gonna allow us to you know interact with it and we'll set the provider which is the web3 provider which we um created here and this is basically just going to give us a copy of the smart contract in javascript and it's going to tell us where it is on the blockchain and we're going to be able to do stuff like you know call all the functions that we coded inside of here like the tasks function the task account and things like that so let's clear this out and just save and refresh and see if everything worked all right so to do list of undefined let's change that so we actually need a place to store this contract so i'll say this let's say contracts like this we'll actually create an empty object okay we'll refresh if you guys get stuck on any of these steps feel free to clone the repository and see the code um below now we want to actually you know get a deployed copy of the smart contract like we did in the console remember we did you know todo list equals like a wait to do list.deployed we're going to do the same thing here so we'll say app.todo list equals await app.contracts todo list deployed okay and you know this is really just uh and this is really just you know getting the values from the blockchain so this is a live contract now this is just like we did in the console all right now we should have loaded our app up with a lot of data we've connected to the blockchain we've retrieved the account and we've retrieved the smart contract that we created you know in the previous section so we want to do now is actually render some information on the page the first thing we'll do is actually render out the account that we're connected with so first we'll just say render equals an async function and inside of here what i'm going to do is show the account right inside of our html okay and remember we got this place to show the account right here so that's exactly what i'm going to do i'm going to put the account inside of this and i'm going to call the render function so after the contracts have loaded i'll say a weight app dot render all right in order to see this change we'll actually expand the window here all right you can see that the account was put in here so like i said earlier i created this as a responsive application um and we can see the account you know here but whenever we resize the window we don't want to see that anymore just to save some space so we'll keep that down but that works and if you want to code this you know with your window all the way open feel free to do that i'm just going to use a smaller view um to save some screen real estate so you guys can see both things happening as i'm doing the tutorial all right so let's do some more things inside this render function what we actually want to do is render the tasks um but i'm going to basically create some other logic inside of here uh to prevent double rendering all right so what we'll do is do a couple things we will say that the app is loading we'll keep track of that like this let's change this to false whenever it's rendering we'll save is loading stop calling this function this will basically prevent a double rendering problem and while this is loading we'll actually set it to true and when it's finished we'll put it back to false so let's actually create a set loading function like this i'm just going to paste some code in you can find this code in the uh github repository so it's set loading basically it's just going to update it and we'll show the loader in the index.html file this will be our simple loader that you see here loading this is loading and i'm going to show it when it's loading right and i'm going to hide the content which is this this is actually the todo list itself all right i'm going to show the loader hide the content all right so let's save that and see if there's any errors all right so that looks like the loader went away which is what we want all right now next we want to do is actually fill in um the tasks who actually want to render them so we'll list out the tasks inside of its own function like this we'll say render tasks say async so inside this function we need to do a lot of things the first thing we want to do is actually load the tasks from the blockchain and then the second thing we want to do is actually render out you know each task with the task template and we're gonna have to basically render out each task one by one and then we're gonna have to actually show the task on the page okay this is kind of a threestep process it's gonna be a little complicated but just bear with me i'll show you how it works so what we're gonna do is fetch them from the blockchain and we're gonna actually use this template that's created down here this task template it's going to have a check box and the content we're going to you know fetch this off the page and create a new task with this okay so first what we think we need to do is fetch the number of tasks from the blockchain remember i said that we can't you know just fetch all the tasks with this mapping essentially we need to find out how many there are and we need to loop through the items in this mapping and fetch them out one by one so if there's ten tasks inside of here we'll need to do one two three four five six seven eight nine ten if there's one we just do this once so in this case there's just one but that's what we need to do first we say const task count equals a weight this is app.todo list task count okay and now we know how many there are and the next thing we want to do is actually fetch this template that we'll use to list the task on the page say const task template equals task template okay and now we actually want to use this task account to um render out each task on the page in order to do that we'll create a for loop in javascript like this if you've written some javascript before it should look pretty familiar we're basically just saying for every number from one all the way up to the task count do this operation so that's what we want to do we start with one because that's the first valid id inside of the mapping so from task number one all the way up to the maximum number of tasks which you know if it's 10 we're going to do this 10 times you know fetch each task so we'll actually read the value from this mapping with the id so i in this case is going to be the id inside the loop the first thing we'll do is actually fetch all the values for the task we'll call the task function and break out the attributes to the id the name and completed do that like this so say task equals await do list task i which is the id in this case and so because of how truffle contract works this is actually going to return an array and we have to reference these values by each item in the array so the first item will be the task id the second id second item which will be the task content the third item which will be completed and remember this array is zero index that's why the first item is zero second item is one third item is two okay so now we'll have the task um id content completed the next thing that we'll do is actually create the html for the task like this i'm just going to paste in this all right so we'll do is actually get a new task template we'll take this task template that was you know fetched from the dom and we'll actually clone it right we'll get a new copy we're going to find the content for this template we're going to fill in the content from the task and we'll find the input which will be the check box and we're going to populate that with some values which will be the task id so basically whenever we check this we'll like you know turn it on and off and whether it's completed or not we'll just use that from the task and we want to wire up a uh on click function which will be toggle completed it will implement this later we won't use it for now so we can comment it out okay so the next thing we want to do is actually put the task in the crest list so i'm going to paste in some code here too so what this does is check if it's completed and remember there's two lists here there's a list for the completed tasks and a list for the um sorry here's the completed tasks and then the list for the noncompleted tasks and if the task's completed we'll put it in the right list and the last thing we want to do is actually show the task we'll do that like this we'll just take the hidden task template that we've been modifying let's show it like this okay all right so let's actually try to call this render tasks function inside of the render function so render task is here and then after we render the account we want to run the tasks like this so let's save this and see what happens we might have some errors but we can just address those as they come up oh no there it is boom it worked so we've actually successfully listed the tasks from the smart contract in the blockchain i can pull this out and we can see the first task inside of here which is check out dap university so i'm actually going to do that i'm going to right click and go to dapuniversity.com awesome so it worked see my social links here and get my twitter it's pretty cool all right so i know we've covered a lot of ground but we have successfully listed the tasks inside the client side application okay um i've commented a couple things out here because we haven't implemented them just yet but if you get confused just go rewind the video and uh you know find what you might have gotten lost the next step we want to do is actually write some tests to ensure that the tasks were listed out properly okay and we're actually going to use the moca testing framework from javascript and the chai assertion library in order to write our tests so you can read more about these if you want to we'll create a new file in the test directory let's say test todo list dot test.js if you go into the test directory you can see the todo list.test.js file here all right so let's actually write a basic test to ensure that you know the contract was initialized properly and that actually lists out tasks the first thing we want to do inside of here is actually require the smart contract like this that's very similar to our migration file pattern say contract and we'll say todo list we'll pass in a function here all right and we'll write all of our tests inside of this callback function this callback function is actually going to expose all the accounts uh in the blockchain right so all the accounts that are connected to ganache all these are going to be injected inside of this variable here this will be an array you can read them out one by one so the first thing we'll do is actually get a deployed copy of the smart contract with a before hook okay and we'll do that like this we'll basically just say before each test runs that's essentially what this means we're going to pass an asynchronous function that should allow us to use the await keyword let's say this dot todo list equals todo list dot deployed okay and before each test runs we'll have a copy of the todo list is deployed to the blockchain now let's create our first test example we'll just say it deploys successfully all right we'll use the async function because we want to use a weight inside of here and the first thing we'll do is actually just get the address like we did in the console earlier say const address i'll wait this to do list address we'll say we basically just want to make sure that the address exists so we want to check that it's not um you know empty so we'll do that like this say assert not equal this address we don't want to be 0x0 we don't want it to be an empty string we don't want it to be null and we don't want it to be undefined so we can check that and that'll just make sure that the smart contract was actually put on the blockchain and that it has an address okay now we can run this test inside of shuffle like this we just say truffle test hit enter all right and it passes now the next thing we want to do is actually list out the tasks and the test and make sure that it works so we'll say it lists tasks pass this asic function so inside of here we'll just do a very simple check we'll just basically make sure the count is correct and that we can fetch you know a task by the count so first we'll just get the task count and we'll just do that and then next we want to actually try to fetch the task out of the mapping so we'll just make sure that a task exists where the task count is okay this will be a simple test so do that and now we want to do is actually assert that the id is equal to the task count right that it was set correctly so let's do a basic test and just try to run it and see if it works all right it works so let's look at that we can see that we're just getting the task we're calling the id and making sure that it's equal to the same task count next let's test some more values and make sure that the content is correct that completed is correct and that um the task number is the same as we expect so let's just do that like this paste in some examples we'll say assert equal the task content is this that's the first task we set whenever we initialize the contract we want to say that the completed is false right we want to say that the task count is actually 1 we want to specify that it's 1 in this case so let's say that run the tests all right passes all right so that concludes this section where we've actually listed out the tasks in the todo list i know that we covered a lot of ground we actually created the tasks inside of the smart contract we listed them out in the console we had to wire up the client side application to list the tasks out there and we wrote some tests so that's a lot if you got confused about anything feel free to rewind the video paste in the code from the github repository down below and while we're here i'm going to go ahead and commit these changes let's say git add i'm going to say git commit all right so we've listed the tasks the next item is to add tasks to the todo list we'll do this with a clientside application and we'll write tests for it but first we want to change this create task function to add some additional functionality so right now we're calling this create task functions at the constructor to add a default task to the todo list like this but we want to you know call this function externally from the client side in order to create tasks that way we also do it in the console and things like that so what i'm going to do is actually add a new line here and what i want to happen is to broadcast an event that this task was created let me explain that solidity allows us to create events that are triggered anytime you know something happens inside of a smart contract and external consumers can subscribe to these events to know uh whenever the event happened and events are really useful because you know whatever we call this create task function we don't always know when you know the transaction actually completed we don't always know when it was mined and things like that and it can be really useful to listen to those events uh in order to you know know that it was finished so we can create an event in solidity before we call it here we need to actually declare it inside of our smart contract we'll just do it like this we'll go below this mapping we'll say event we'll say task created and notice that's capitalized all right here's a semicolon here and we'll just add some arguments to this event we'll say uint id this will be the id the task that was created a string this is the content and the completed property so boolean completed all right so that's how we create an event inside of solidity right this just means that you know the task created event is available to us inside of the smart contract and i'll show you how we can actually call it we do like this we use the emit keyword emit task created and we pass in the arguments so the id here is the task count and the content which is passed in from the function and false because it's a new task and we haven't completed it yet and that's pretty easy that's how you trigger events inside of solidity and we can subscribe to these events you know inside the clientside application or you know anywhere that can listen to events on a smart contract all right while we're here i'm going to go ahead and actually write the tests for creating the todo item so i'll open the test file over here do the side by side and i'll just create a new example down here so below list tasks we'll say it creates tasks i'm just going to add some space so you can see better so say it creates tasks all right let's say async pass in a function and first we'll say construct equals await this dot todo list create task and i'll say a new task okay and we'll check the task count oh wait this dot todo list task account all right we'll fetch that and first we'll check that the task count is the same as we expect say two so that's the first thing we'll check on we'll ensure that you know we created a new task and the new count is actually two and now what we'll do is check that this event this task created event was actually triggered and you know we'll dig into the logs uh and say that the id was the same the contents the same and completed was the same so that would be the actually you know this new task that we created was you know logged out so we can get the event like this we're going to use this result which was you know the result of this finished create task function right we use the async weight pattern to get the result here and the event is actually contained inside of that so we'll say const event equals result logs okay it's in their logs and it's the first item okay and the args key basically is going to contain all the values for the event and you could log this out like in ganache you could actually console log this event in fact let's just do that right now let's just say console.log result go to the terminal truffle we'll show you the result and what it looks like so you can see what we're digging into all right this is loading okay so this is what the result looks like we see there's a transaction hash here and it's got a receipt and inside of here we have logs right and here is where the event information is contained right we can see this args key right here it's going to have an object and granted we can't see exactly what's inside of here because it's not locking all the information but this args key is going to contain all the values of this event that was triggered whenever this was created okay so i'll take out that result now i will check to see that all the information is there so let's say a search equal event id we'll say two number it's equal to we'll say a search equal event content is equal to a new task search equal event completed i'll say false all right let's run the test and this time we won't see all this log output it'll actually just run the test and hopefully it'll pass yep it passed all right so we can see that our event was triggered whenever we called this create task function all right so i'm going to remove the space and that's how you write tests uh for this create task function and check on events now let's go to the front end application and create tasks that way now before you jump back into this make sure a few things are correct make sure that ganache is running your blockchain is running and make sure that your contracts are migrated that you're connected with meta mask right here things like that okay so what i'm going to do is actually enable this form that i commented out from the previous steps on the page so this form is going to have an on submit function create task which we'll build here in a second i haven't done that just yet but i'll just refresh the page and show what it looks like all right so we'll see this add task field and we'll actually type in a task here and we'll hit enter there's no button here just for simplicity's sake we'll just use the enter key in order to create the task all right so i'll go back to the app.js file let's actually add the create task function we'll do that like this let's do it down here below the render function all right we can say oops create task this will be an async function so what we'll do is say app dot set loading to true okay so whenever we call this we want to show the loader and we'll do that const content equals new task val okay and that's just the name of the form so if you go back to the index.html file you'll see this uh you know sorry it's the name of the the input it's on the form see on submit create task we're gonna fetch the value of this input right here this input which is the id new task okay and we're gonna get the value which is gonna be what's ever filled out inside there so new task value and now we're actually gonna call the smart contract function we're going to call this create task function uh with we know web3js with the truffle contract library and talk to the blockchain in order to actually update it so we'll say a white app.todo list actually sorry this will be create task and we'll pass in the content from the value okay and whenever we do that whenever this is finished i'm just going to do a shortcut and reload the page so that whenever this is actually done i'll just refresh the page and it'll go ahead and fetch all the tasks from the blockchain again and list them out on the page so instead of having to like you know listen maybe for the event and then reload the page like sometimes i can get into a double rendering problem so i'm just going to um actually just reload so i'll say like window dot location no reload that's just a javascript thing to say refresh the page okay so let's test it out and see if it works i'm going to open the console and see if there's any errors nope we're good all right so we'll say a new task or we'll say task number one task number one and like i said there's no button here i just want to hit enter in order to make this work so i'll hit enter and i didn't put a button on here just for simplicity's sake i'll say confirm all right there we go so we successfully added a task we can see task number one was added to the list and and if you go and check ganache you can see uh the same thing if you go back to your transactions you can see that a transaction was created right here i think it's the same one yeah looks like that's the same one and also you can go to your logs see the same thing and scroll like crazy i think there's at the bottom right anyways that gives you an idea of you know where you can look to find out more information about the blockchain whenever you're doing this kind of stuff all right so we've successfully created a new task on our todo list and we've you know done it inside the smart contract we have done it on the client side and we've written tests to make sure that this works so that's it for this section i'm going to go ahead and commit these changes i'll say get ad dot git commit let's say three creates tasks now the last thing we're going to do in this tutorial is actually check off the tasks from the todo list whenever we do that they'll appear in a completed list down here and they'll be striked out so we'll do that like this first we're going to go to our todo list we'll create a new function we'll call this toggle completed okay so i'm going to give you some space down here say function toggle completed okay so what do you want this function to do so we want to take this uh you know struct these task structs that are inside this mapping and we want to find a specific task and we want to change this value so if this value is already true when i change it to false and it's already false when i change it to true so basically if someone checked this item uh it would you know say that it's completed and if it's on the completed list we could check it and it would take it off the complete list and put it back in the you know not completed list okay so this function will need a parameter it'll need an id of the task that we want to actually toggle so we'll do that like this we'll say uint id all right we'll say public so first we will get the task out of the mapping all right so we need to read the task out of the mapping like this you can see task you know tasks count we can do the same thing we say task and we can read the id like this say id so that will actually fetch it out let's assign it to a variable whenever we do this we want to actually declare this variable with the type task and we're actually going to do this just in memory so it looks kind of funny but this is how we do that in solidity we say task this is the data type that we declared right here task memory and we say task like this okay now notice this underscore basically just means this is a local variable and not a state variable um it's not necessarily specific to solidity it's just a convention right you see this here in fact i'm going to do this like this as well id see you know content is underscored here because that was a local variable that was passed in the function id is the same way and i'm going to do just task like this because i don't want to assign it to the state um there's nothing special about doing that it just convention so now i'm going to say task dot completed and we basically want to do the opposite of whatever it was before so we can read the value of whatever it was before like this we just say tasks completed but we want to say the opposite so we'll say bang oops bang right so if it was false this will turn into true and if it was true it'll turn into false we're assigning that new value here all right next um we're going to put it back into the mapping so just like we did tasks task count equals this we're going to put it back into the task mapping say tasks uh id equals task all right so that's how we would create a function to toggle task completion now i want to do a few more things inside of here before we move on um i want to emit an event just like in the create task function so first we'll declare an event we'll just say event let's say task completed all right and we'll give this two arguments we'll say unit id say you went or sorry bool completed all right and now i will trigger that event inside here say emit task completed id task completed all right and that should work a lot like our create task function where that will emit an event anytime this function's called okay so let's actually write a test to make sure this works before we you know wire up the client side application we'll go to the uh test file right here and i'm actually going to split this pane uh vertically all right so i've just split this pane um we've got a test file down here and the smart contract cut up here so i'm just going to focus on this we want to just test this function unit test this toggle completed so i'm going to create a new function down here and give ourselves some space or sorry new example that will say that it toggles task is completed so i'll scroll down a little bit actually just uh copy this and paste it again to give ourselves some space and have some boilerplate so we'll say it toggles task completion and i'll clear out all this actually let's do this let's say result equals this dot todo list dot toggle completed and i'll pass in uh one should be the first task and we'll get the task itself we'll actually retrieve the task now pass in id1 all right and we want to assert that that's going to be equal to task completed we want it to be true and we want to fetch the event just like we did in the previous example and we want to ensure that the event id is equal to one and that the event completed is equal to true all right does that make sense so basically i know i modified a lot of that code so that might be a little tricky i didn't just you know write it out as i was thinking it i just changed what was there from the previous example so let's just review so we're toggling completed we're calling this function passing in the id of the first task we know there's a task already in the todo list because we created one inside the constructor right and we waited for that to finish got the result which we'll use to read out the logs here in a second um but the next thing we did was we got the task right and we checked that it was actually completed right so that's true and now we want to make sure that this event was triggered and we you know get the event by digging into this result which we witnessed in the previous section if you didn't check that out go ahead and rewatch that part um so we took the event and got the id made sure it was 1 and then looked at completed and ensured that it was true all right so let's try to run the test all right it looks like i've had an error let's go back to this code we can see i forgot the underscore here let's run it again all right it passes awesome okay so i'm going to remove this space save this now let's go to the client side application and wire up the check boxes to toggle the tasks so go back to the app.js file and i'll create a new function down here i will call it toggle completed i believe this is the same name as the smart contract function so below create task we'll say toggle completed i'll say async pass it a function and we'll do is similarly to create task we will say the app is loading say const task id and actually inside of here this is going to be on a on click event because whenever we click this check box uh we're gonna you know have an event listener that calls this function so i'm gonna pass in the actual event itself we'll just use e for short and that event is gonna contain the name of this check box which the name value is going to be set to the actual task id so we'll say e target name and now i'll say await we're actually going to call the smart contract function to toggle this task is completed say app dot todo list toggle completed i'm going to pass in the task id all right and then just like the create task function whenever that's finished i'm just going to reload uh the webpage semicolon or sorry a comma there okay no errors but if you remember in the previous sections i commented this out so i'm going to put i'm going to reenable this this is where we actually wire up the on click handler to do this so now whenever we're rendering the tasks out we found you know the check box and we want to actually add the event handler whenever it's clicked to call this function so everything looks good all right let's try it out i'll try to check this off the list see if it works all right looks like we got a problem here all right we do have a problem and i'm gonna see if you can guess what it is it's something i forgot to do in the previous step and i'm actually going to leave this in the recording because it kind of shows you the nature of blockchain development and all the things you need to do do you know what it is yet well i'll tell you we forgot to run the migrations so we added a new function to the smart contract and it worked on the tests um but we didn't actually deploy a new copy of the smart contract to the blockchain with this new function so in order to do that we'll run truffle migrate dash dash reset to deploy a new copy of the smart contract to the blockchain and whenever we do that we're going to want to refresh our web page to pick up that change all right so let's try that again sorry guys i forgot that step like i said i wanted to leave that in the video just to show you you know something you might forget to do um and hopefully that'll help you remember all right so we'll refresh the page now we see that our other task is gone now why did that happen well that's because you know whenever we deploy a new copy the smart contract all the state of the smart contract is gone right it's a new smart contract whenever we redeploy so all the old tasks we had in the smart contract have disappeared so we'll add a new one we'll say task number one about a few we'll just sign these really fast task number two task number three all right so now it's actually toggle one is completed and we see the metamask confirmation pop up we'll sign it confirm and there we go we've actually successfully uh checked off task number one from the list and we can see that it was added to um you know the list down here below so we can you know actually to do the todo item on task number two we can go to dappyuniversity.com all right we see it awesome we went there and now we can go here and check that out the list because we actually did it confirm and there we go all right so that's it guys that's actually the end of this tutorial you've successfully created your own todo list on ethereum powered by smart contracts and you've created this client set application to interact with it so congratulations i hope you all like this tutorial again be sure to subscribe to the channel if you haven't already and also don't forget you can download you can just sign up for my email list to you know get my courses downloaded for free and also you can you know keep up with me on twitter and stuff like that for more daily updates so also guys i'm releasing a premium course like a full decentralized blockchain development course sometime soon so you'll want to sign up for that email list to find out more updates about that it's going to be really extensive it's going to be really awesome you're going to want to learn about it so just stay in touch and also by the time this video is out you'll be able to find an article to accompany this video which you can follow along step by step it'll be somewhere on my website it'll probably be in the video description below as well you can see other articles on my website here um like you know this is the uh ultimate ethereum dap tutorial which i released last year uh which is a pretty popular tutorial that shows you how to build your first decentralized application i mean you can code your own cryptocurrency on ethereum you know build an erc20 token and stuff like that got some other deep dives on topics like you know web3js which we talked about some in this tutorial um you know a lot more lessons on solidity how to develop smart contracts i kind of go into more features of the language and things like that so this is a huge resource with a lot of free stuff a lot of good information i also have some tutorials on like how to build a real world ico and things like that this is like a you know production ready ico that you could use in the real world this is pretty advanced you know and also if you're looking for somebody to work on your blockchain projects um you know i am available my email address is down below i do a lot of you know blockchain development a lot of consultation and advising for people who are launching blockchain startups icos things like that i've got a complete solution for launching an ico like i said you can reach out to me via email my email is on my website and also in the description below some buttons here you can contact me on the website like i said my twitter's here things like that so again i hope you all liked this tutorial until next time thanks for watching dap university
