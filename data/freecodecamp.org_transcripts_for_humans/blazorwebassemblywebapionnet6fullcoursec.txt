With timestamps:

00:00 - blazer web assembly is a single page app
00:02 - framework for building interactive
00:04 - client-side web apps with net it uses
00:08 - open web standards without plug-ins or
00:10 - recompiling code into other languages
00:12 - this course will teach you how to use
00:14 - blazer web assembly and web api on.net
00:17 - 6. you will learn step by step how to
00:20 - build a shopping cart application this
00:22 - course also provides a guide on how to
00:24 - integrate a payment gateway into your
00:27 - blazer webassembly component so that a
00:30 - user is able to pay for products through
00:32 - your application using a debit or credit
00:34 - card or even a paypal account
00:37 - gavin lawn teaches this course
00:39 - gavin is a senior software engineer with
00:42 - over 20 years of experience i encourage
00:44 - you to leave a comment with the most
00:46 - interesting thing you learn for the
00:48 - benefit of other campers who are
00:49 - watching this course
00:52 - please join me as we build a very basic
00:54 - shopping cart application using blazer
00:56 - webassembly
00:57 - a few of the significant technologies
00:59 - we'll use for building our application
01:01 - are as follows
01:03 - the latest version of visual studio
01:05 - which is visual studio 2022
01:08 - and we'll use the community edition for
01:09 - windows
01:11 - dot net 6 which is at the time of
01:13 - creating this video the latest version
01:15 - of dot net it was released in november
01:18 - of 2021
01:20 - sql server 2019
01:24 - laser web assembly we'll use bootstrap
01:26 - version 5 for layout and styling
01:28 - purposes we'll build a restful mvc web
01:31 - api project for handling database
01:33 - related functionality and returning
01:35 - relevant data from the server to our
01:38 - client side blazer application
01:41 - all technologies used for the
01:42 - development of this application can be
01:45 - downloaded free of charge please see
01:47 - below in the description the locations
01:49 - of where you are able to download the
01:50 - relevant technologies for free we are
01:53 - going to integrate a payment gateway
01:54 - powered by paypal into our application
01:57 - so that a user can use their paypal
01:59 - account or a valid debit or credit card
02:02 - to pay for the items that are purchased
02:04 - through our online shopping cart
02:06 - application
02:08 - blazer is a relatively new feature of
02:10 - asp.net
02:11 - it offers two hosting models a
02:13 - server-side hosting model and a
02:15 - client-side hosting model
02:17 - we are going to use the client-side
02:19 - hosting model for the development of our
02:21 - shopping cart application the
02:23 - significance of this hosting model is
02:25 - that the c-sharp code runs directly
02:27 - within our browsers
02:28 - what makes this possible is a technology
02:31 - named webassembly
02:33 - in recent years the creation of spa
02:35 - applications or single page applications
02:38 - have become very popular as web
02:40 - solutions
02:42 - up until fairly recently javascript
02:44 - frameworks like angular or react have
02:46 - been the available choices for the
02:48 - creation of spa applications
02:51 - with blazer we are now able to create
02:53 - our single page applications using
02:55 - c-sharp
02:56 - we don't necessarily need to depend on
02:59 - javascript for the creation of our
03:01 - interactive ui code
03:03 - we can create this code using c-sharp
03:06 - in this application however the payment
03:08 - gateway provided by paypal is coded in
03:11 - javascript
03:12 - so we will use blaze's interoperability
03:15 - functionality with javascript to
03:17 - interact with the relevant javascript
03:19 - paypal code
03:21 - so let's get started
03:23 - let's create our blazer solution
03:25 - let's fire up visual studio 2022
03:29 - select create new project
03:32 - let's choose the appropriate project
03:34 - template
03:37 - blazer webassembly app
03:43 - let's name our solution shop online
03:45 - solution
03:48 - let's name the blazer project
03:50 - shoponline.web
04:15 - great
04:16 - let's add a new project to our solution
04:19 - where we'll create our restful web api
04:21 - functionality
04:23 - so let's ensure that we choose the
04:25 - correct project template
04:41 - let's name our project shoponline.api
04:45 - notice that for the authentication type
04:47 - we are choosing none
04:50 - we are not going to implement membership
04:52 - functionality which of course includes
04:54 - login and registration functionality
04:56 - we'll focus purely on the shopping cart
04:59 - functionality
05:01 - we want to run our application on the
05:03 - latest version
05:04 - of.net.net 6.
05:06 - note that we have enabled open api
05:08 - support by doing this the swashbuckle
05:11 - nuget package will be automatically
05:13 - installed and the appropriate swagger
05:15 - middleware will be automatically
05:17 - configured appropriately within our
05:19 - project
05:22 - one of the advantages of this is when we
05:24 - run our web api project interactively
05:27 - we'll be able to test our web api code
05:29 - through our browsers even before we have
05:32 - developed any front-end code
05:34 - so a basic ui will automatically be
05:37 - created for this purpose for us
05:40 - when we run our application
05:41 - interactively we'll be able to test each
05:43 - of our action methods through the
05:45 - relevant automatically created web-based
05:48 - ui
05:51 - note that you can also use a tool like
05:53 - postman to test your web api
05:55 - functionality
05:57 - i won't be using postman during the
05:59 - development of this application
06:10 - we are going to build our database using
06:12 - codefirst migrations and entity
06:14 - framework core
06:16 - migrations allow us to evolve our
06:18 - database without losing data or database
06:20 - objects
06:22 - so by using plain old c-sharp classes we
06:24 - can build the database entities that we
06:27 - wish to include within our shopping cart
06:29 - application
06:31 - once we have created relevant related
06:33 - c-sharp classes we'll look at an entity
06:35 - relationship diagram that represents our
06:38 - shopping cart applications database
06:40 - design
06:41 - let's add a folder named entities to our
06:43 - project this is where the classes that
06:46 - will represent our database entities
06:48 - will reside
06:56 - so let's create a class named cart to
06:59 - represent the cart entity
07:06 - so let's add two public properties to
07:08 - this class
07:10 - id as integer and user id as integer
07:27 - let's add a new class named cart item
07:30 - this entity represents an item that has
07:32 - been added to the user's shopping cart
07:40 - so let's add an integer property named
07:43 - id
07:44 - let's add an integer property named cart
07:46 - id
07:47 - this property represents a foreign key
07:49 - field
07:50 - and is used to join the cart entity to
07:53 - the cart item entity
07:55 - so the cart entity has a one-to-many
07:57 - relationship with the cart item entity
08:00 - this denotes that many card items can be
08:03 - included within one particular shopping
08:06 - cart
08:07 - let's include an integer property named
08:10 - product id
08:19 - lastly let's include an integer property
08:21 - named qty
08:23 - representing the quantity or number of a
08:25 - particular product that may be included
08:28 - within a particular shopping cart
08:31 - let's create a new class representing
08:33 - the product entity
08:35 - the product entity will have a
08:37 - one-to-many relationship with the cart
08:39 - item entity this denotes that a product
08:42 - can be included many times across many
08:44 - different shopping carts
08:47 - let's add an integer property named id
08:50 - let's add a string property named name
08:57 - let's add a string property named
08:59 - description
09:04 - let's add a string property named image
09:06 - url
09:27 - let's create a property of type decimal
09:29 - named price
09:35 - let's create a property of type integer
09:37 - named qty
09:39 - lastly let's add a property of type
09:41 - integer named category id
09:44 - the categoryid property represents a
09:47 - foreign key from the product category
09:49 - entity the code for which we are about
09:51 - to implement
09:58 - so let's create a class named product
10:00 - category
10:02 - this entity has a one-to-many
10:04 - relationship with the product entity
10:09 - let's add a public property named id
10:12 - note that when a property is named id
10:15 - by convention entity framework core will
10:18 - designate the id property as
10:20 - representative of the relevant entity's
10:23 - primary key
10:24 - let's add a property of type string and
10:27 - name this property name
10:30 - and lastly let's create a class to
10:32 - represent our user entity which of
10:35 - course represents a user of our
10:37 - application
10:40 - note that i've included this entity as a
10:42 - temporary substitute for a membership
10:44 - facility like for example microsoft
10:47 - identity so that we can focus on the
10:49 - shopping cart workflows and not be
10:51 - distracted by the membership
10:53 - functionality so let's add an integer
10:56 - property named id
10:58 - let's add a string property named
11:00 - username
11:05 - so if we look at this entity
11:07 - relationship diagram we can see the
11:09 - relationships between our entities
11:12 - the cart entity has a one-to-many
11:14 - relationship with the cart item entity
11:17 - the product entity has a one-to-many
11:19 - relationship with the card item entity
11:22 - the product category entity has a
11:24 - one-to-many relationship with the
11:26 - product entity
11:28 - the user entity has a one-to-one
11:30 - relationship with the cart entity
11:33 - so this basically means each user can
11:36 - only have one shopping cart within our
11:38 - application
11:40 - if you look at the sql server management
11:42 - studio that is installed on my local
11:44 - machine you can see that i've already
11:46 - generated a database through ef core
11:50 - this was done when i was developing the
11:52 - prototype for this application
11:54 - so we are now going to use efcor to
11:57 - generate a database for our shopping
11:59 - cart application
12:01 - the classes that we have just created
12:03 - representing our entities
12:05 - will be used by ef core to generate the
12:07 - corresponding database tables within a
12:09 - database that ef core will create for us
12:14 - in order to generate our database with
12:16 - the relevant tables through visual
12:17 - studio
12:19 - let's install two nuget packages
12:22 - to do this right click the dependencies
12:25 - node within our shoponline.api project
12:28 - click the manage new get packages menu
12:31 - item
12:33 - click the browse tab on the new get
12:35 - package manager dialog
12:38 - let's search for entity framework core
12:40 - dot sql server
12:45 - and this is the package we want to
12:46 - install
12:53 - let's click the install button
12:55 - then the i accept button
13:02 - great
13:03 - let's search for the second package that
13:05 - we need to install the reason we are
13:07 - installing this package is because we
13:09 - want to run our migrations from within
13:11 - visual studio as opposed to using
13:14 - the.net cli for this purpose
13:17 - note that you would use different
13:18 - commands when running migration commands
13:21 - using the.net cli as opposed to the
13:24 - commands you would run when using visual
13:26 - studio
13:28 - so let's search for entity framework
13:30 - call dot tools
13:33 - and this is the package we want
13:35 - let's install the microsoft dot entity
13:37 - framework core dot tools nuget package
14:06 - the next step is we must configure a
14:09 - connection string in order to connect
14:11 - our application with the database that
14:13 - we wish to create using entity framework
14:16 - core code first migrations
14:19 - so let's open the appsettings.json file
14:22 - within our shoponline.web project
14:48 - within the connection string that i'm
14:49 - configuring here
14:51 - i'm including my server name which is
14:53 - gavin lon's pc
14:55 - the database which i wish to name shop
14:57 - online
14:58 - and we are going to use a trusted
15:00 - connection to connect our shopping cart
15:02 - applications web api to our database so
15:05 - let's include trusted underscore
15:07 - connection equals true within our
15:09 - connection string
15:12 - note that i have named my connection
15:14 - string shop online connection
15:19 - let's create our database context class
15:22 - let's first create a folder named data
15:25 - within our shoponline.api
15:27 - project
15:36 - let's add a class named shoponlinedb
15:39 - context to our new data folder
15:54 - so in order to make this class represent
15:56 - our ef core database context we need to
15:59 - implement code so that our shop online
16:01 - db context class
16:03 - inherits from ef course db context class
16:08 - you can see there's a red squiggly line
16:10 - under db context this is because we
16:13 - haven't yet brought in the microsoft dot
16:15 - entity framework call namespace
16:18 - an easy way to include the appropriate
16:19 - using directive through visual studio
16:22 - is to press control period and then
16:25 - select the appropriate menu item from
16:27 - the menu that is presented to us through
16:29 - visual studio
16:31 - let's create the constructor for our
16:33 - shop online dbcontext class
16:42 - we must add a parameter to the
16:44 - constructor that we have just generated
16:47 - the parameter is named options
16:50 - and is of the generic type db context
16:53 - options which has the data type shop
16:55 - online db context passed as an argument
16:58 - to it
17:06 - we can then write code to pass the
17:08 - argument that will be passed to our shop
17:11 - online db context class constructor to
17:14 - the base class from which it inherits
17:16 - i.e the db context class
17:19 - now because i want to focus on the
17:20 - shopping cart workflows at this stage
17:23 - and don't want us to be distracted by
17:25 - the implementation of administrative
17:27 - crowd operation functionality
17:30 - we are going to seed our database with
17:32 - certain data
17:34 - this is data that i've already prepared
17:37 - so we are not going to include create
17:39 - read update and delete functionality
17:42 - regarding the creation and maintenance
17:44 - of product data at this stage we are
17:47 - going to seed our database with product
17:49 - related data
17:51 - we are going to seed our database with
17:53 - the relevant data so that we can move
17:55 - directly to the creation of our shopping
17:57 - cart functionality
17:59 - so in order to seed the database
18:02 - appropriately we can override a method
18:04 - that exists within the db context base
18:07 - class
18:08 - this method is named on model creating
18:12 - an easy way to generate the relevant
18:13 - override code for this method through
18:16 - visual studio is to type in the word
18:18 - override and then press the spacebar we
18:21 - can then select the on model creating
18:24 - item from the drop-down list presented
18:26 - to us within visual studio
18:29 - i have already prepared the code for
18:31 - seeding our database and this code can
18:33 - be found at this location on github
18:37 - so let's go to the appropriate github
18:39 - location
18:44 - and copy this code to our clipboards
18:51 - let's then paste the code from our
18:53 - clipboards into the on model creating
18:55 - method
19:45 - the next step
19:46 - is to let entity framework core know as
19:49 - it were about our entities
19:52 - so we can do this by using the entity
19:54 - framework call dbset generic type
19:59 - so for each of our entities we need to
20:01 - appropriately include a public property
20:03 - of type db set
20:05 - within our shop online dbcontext class
20:50 - to register our shop online db context
20:52 - class for dependency injection let's
20:54 - open the
20:55 - relevantprogram.cs file
20:58 - then we can simply add this code here to
21:01 - register our shop online dbcontext class
21:04 - for dependency injection
21:09 - note that our code is reading the
21:11 - connection string that we configured in
21:13 - the app settings.json file
21:21 - we are now ready to generate a migration
21:24 - using ef core
21:27 - so let's launch the new get package
21:29 - console manager window from within
21:31 - visual studio like this
21:38 - we can then type the appropriate command
21:40 - to generate a migration
21:43 - so let's type in add dash migration
21:45 - followed by the name of the migration we
21:47 - wish to create
21:55 - so when i run the add dash migration
21:58 - command i get an exception
22:01 - i've found out that this exception
22:03 - occurred because at present the
22:05 - shoponline.web project
22:07 - is set to my startup project within the
22:09 - relevant solution
22:11 - so if you get this exception all you
22:13 - need to do to fix this is make the
22:17 - shoponline.api project your startup
22:19 - project like this
22:31 - so let's try again
22:50 - and now we don't get the exception and
22:52 - it works as expected
22:54 - and you can see code within the up
22:56 - method of the migration class that we
22:58 - have just generated
23:00 - this code creates our database and the
23:02 - relevant tables
23:04 - this method also contains code that
23:07 - seeds the relevant database tables with
23:10 - the data that i prepared prior to
23:12 - creating this video
23:27 - the down method contains code to undo
23:29 - the changes made by code contained
23:31 - within the up method
23:42 - to run our migration all we need to do
23:45 - is type the update database command
23:48 - within the new get package manager
23:50 - console window like this
23:54 - and then of course press enter
24:02 - and now if we look at sql server
24:04 - management studio we can see that the
24:06 - shop online database has been created
24:10 - the database tables have been
24:11 - appropriately created based on the
24:13 - entities we created using c-sharp
24:15 - classes
24:18 - the relevant database tables have been
24:20 - seeded with the data created from the
24:22 - code we included within the on model
24:25 - creating method
24:26 - which resides within the shop online db
24:29 - context class
24:31 - the data with which we have seeded our
24:33 - database contains product and user
24:35 - information
24:37 - this has been done so that we can focus
24:39 - on the shopping cart functionality and
24:41 - not worry at this stage about
24:43 - implementing code or create read update
24:46 - and delete functionality regarding
24:48 - products sold by our fictional online
24:51 - store
24:52 - here are just a few notes about running
24:54 - migrations
24:56 - please note that if you have run a
24:57 - migration or more than one migration and
25:00 - are not happy with the changes made to
25:02 - the database
25:03 - you can undo the changes made by running
25:06 - this command update dash database
25:09 - followed by a zero
25:11 - the number zero is a special case that
25:13 - means before the first migration and
25:16 - causes the effects of all migrations to
25:18 - be rolled back
25:20 - you may wish to remove the migrations
25:23 - after this you can remove a migration
25:25 - that has not yet been used to update the
25:28 - database
25:29 - by running the command remove dash
25:31 - migration
25:32 - the remove dash migration command will
25:35 - remove the last migration that has not
25:37 - yet run
25:39 - note that if for example you have
25:41 - updated the database with multiple
25:43 - migrations
25:44 - and you wish to roll back the changes to
25:47 - before a particular migration was run
25:50 - you can roll back your changes
25:52 - to that particular state
25:54 - by running the migration that was run
25:56 - directly before the migrations that were
25:59 - run that contain the changes you wish to
26:01 - roll back
26:08 - this is the second part in a series of
26:10 - videos dedicated to building a shopping
26:12 - cart application
26:13 - using blazer and a restful web api
26:19 - in this video we are going to start with
26:21 - the workflow that involves retrieving
26:23 - product data from our database
26:26 - and returning the data to the client
26:28 - blazer component
26:30 - the code for this functionality will be
26:32 - implemented within a web api component
26:36 - so in this tutorial we'll start to
26:38 - develop our web api component
26:41 - before we do this
26:43 - let's create the classes that represent
26:45 - the data that will be passed between the
26:47 - web api component and the blazer
26:50 - component
26:54 - you might be thinking but we have
26:56 - already created the classes to represent
26:58 - the data for our application for example
27:00 - product product category cart cart item
27:03 - etc yes we did create these classes that
27:07 - represent our entities in the previous
27:09 - part of this video series
27:11 - these entity classes directly map to the
27:13 - database tables that were generated when
27:16 - we ran the relevant migration
27:19 - the function of these classes can be
27:21 - seen as blueprints for their
27:23 - corresponding database tables
27:25 - when we pass data between the web api
27:28 - component and the blazer component we
27:31 - don't necessarily want to pass the exact
27:34 - data defined by the properties in the
27:36 - classes that represent the database
27:38 - entities
27:40 - for example in this tutorial we are
27:42 - going to create code that returns the
27:45 - product data from the web api component
27:47 - to the blazer component
27:51 - the product class contains certain
27:53 - product related properties one of which
27:55 - is the category id
27:57 - a particular category id value
28:00 - could for example denote
28:02 - that a particular product falls under
28:04 - the electronics category and could for
28:06 - example be a laptop
28:08 - or for example the product could fall
28:10 - under the furniture category
28:13 - and could be for example a couch
28:16 - the category id property within the
28:19 - product entity is a foreign key
28:21 - from the product category entity
28:24 - from a human perspective the category id
28:26 - property does not have much meaning
28:29 - because it contains a numeric value so
28:31 - it wouldn't for example make much sense
28:33 - to display the category id to the user
28:37 - we may want to pass the relevant
28:38 - category name in addition to the product
28:41 - information defined in the product class
28:44 - so to facilitate this we can create a
28:47 - new model
28:48 - that contains all the relevant products
28:50 - data as well as the relevant category
28:53 - name which is included in the product
28:56 - category entity and not the product
28:58 - entity
29:00 - so it makes sense to create a new model
29:02 - to represent the data
29:05 - that in this case we wish to pass from
29:07 - server to client
29:09 - we need a model that includes all the
29:11 - product information as well as the
29:13 - category name
29:14 - the type of model i am referring to is
29:17 - known as a dto or data transfer object
29:21 - this type of model includes the data
29:23 - that needs to be passed between server
29:26 - and client
29:30 - so a dto is an object that defines how
29:33 - the data will be sent over the network
29:37 - the classes that represent our entities
29:40 - that we created in the first tutorial
29:42 - directly map to their corresponding
29:45 - database tables
29:47 - these classes represent the structure of
29:50 - certain tables in our database
29:53 - we can create dtos data transfer objects
29:57 - that are based on the underlying entity
29:59 - classes but may be differently shaped
30:02 - based on the data that needs to be
30:04 - passed between client and server
30:10 - we are going to create a standard
30:11 - library project to house our dtos
30:16 - so let's create a new project within our
30:18 - solution
30:22 - let's select the appropriate class
30:24 - library project template
30:36 - let's name our new project
30:38 - shoponline.models
30:59 - let's delete the default class generated
31:02 - for us by visual studio
31:11 - let's create a folder named dtos
31:22 - so let's create the dtos that we are
31:24 - going to use in our application
31:26 - now the only dto that we are interested
31:29 - in at the moment will be named product
31:31 - dto
31:32 - but let's create the other dto classes
31:35 - that will be used later on in the
31:37 - development of our application as well
31:40 - as the products dto class
31:43 - the dto classes will be explained in
31:45 - more detail at appropriate points during
31:48 - the development of our application
31:51 - let's create a class named cart item dto
32:09 - let's make sure our new class contains
32:11 - the public access modifier
32:14 - let's create the properties for the cart
32:15 - item dto class
32:17 - id as integer
32:19 - product id as integer
32:23 - cart id as integer
32:26 - product name as string
32:29 - product description as string
32:33 - product image url as string
32:42 - price as decimal
32:46 - total price as decimal
32:48 - and qty as integer
32:55 - let's create a new class named cart item
32:57 - to add dto
33:12 - let's ensure that our new class contains
33:15 - the public access modifier
33:17 - so cart id as integer product id as
33:20 - integer and qty as integer
33:28 - let's create a new class named cart item
33:31 - qty update dto
33:42 - let's ensure that our new class contains
33:44 - the public access modifier
33:47 - cart item id as integer
33:51 - qty as integer
33:54 - let's create a class named product dto
33:58 - this is the dto that we are going to use
34:00 - in this tutorial
34:06 - let's ensure that our new class contains
34:08 - the public access modifier
34:12 - id as integer name as string description
34:15 - as string
34:18 - image url as string
34:22 - price as decimal
34:26 - qty as integer
34:28 - category id as integer and category name
34:32 - as string
34:36 - great so we have created the classes
34:38 - that represent our dtos data transfer
34:41 - objects
34:43 - let's go to our shop online.api project
34:47 - so we are now going to start coding the
34:49 - logic for our first workflow starting
34:52 - with the web api component
34:54 - this workflow simply involves retrieving
34:57 - product data from our database and
34:59 - returning the data to the client blazer
35:01 - application the blazer application will
35:04 - contain code that displays the relevant
35:06 - product data to the user
35:12 - so now our shop online db context class
35:15 - has been registered for dependency
35:17 - injection
35:18 - we'll see in a bit how we are able to
35:20 - implement code to ensure that an object
35:23 - of type shop online db context is
35:26 - injected into relevant classes
35:29 - we are going to use the repository
35:30 - design pattern to abstract our data
35:33 - handling layer
35:35 - repositories are classes or components
35:38 - that encapsulate the logic required to
35:40 - access data sources
35:43 - we can use repositories to centralize
35:46 - common data access functionality
35:49 - which has the benefit of facilitating
35:52 - better maintainability easier unit
35:54 - testing
35:55 - extensibility and cleaner code
35:59 - the best way to understand the
36:01 - repository pattern is to implement the
36:02 - relevant code
36:04 - so let's write the code for our product
36:06 - repository functionality
36:09 - so let's create a folder named
36:11 - repositories
36:22 - within the repositories folder let's
36:24 - create a folder named contracts
36:29 - within the contracts folder let's create
36:31 - an interface named i product repository
36:47 - let's create four method definitions
36:50 - within our new interface
36:53 - we want all these methods to run
36:54 - asynchronously so all the method
36:56 - definitions within this interface will
36:58 - return generic task objects
37:02 - our first method is named getitems and
37:05 - returns an i enumerable collection of
37:07 - type product
37:09 - so the i enumerable collection is passed
37:12 - as a type argument
37:14 - to the task object
37:16 - as discussed
37:17 - this is so the method that implements
37:19 - this method definition
37:21 - can run asynchronously
37:24 - the other methods follow a similar
37:25 - pattern
37:27 - let's define the method definition for a
37:29 - method named get categories
37:32 - let's define a method definition for a
37:34 - method named get item which contains a
37:36 - parameter of type integer named id
37:40 - let's define a method definition for a
37:42 - method named get category which contains
37:45 - a parameter of type integer named id
37:48 - so we have defined the interface
37:50 - that we want a class named product
37:52 - repository to implement
37:55 - so let's create a class directly within
37:58 - the repositories directory named product
38:00 - repository
38:12 - and the first thing we need to do is
38:14 - write the code to implement the i
38:16 - product repository interface so let's do
38:19 - that
38:20 - we can see a red squiggly line under i
38:22 - product repository
38:24 - this is because we need to bring in the
38:26 - shoponline.api.repositories.contracts
38:30 - namespace
38:31 - a quick way to do this is press ctrl
38:34 - period and then select the appropriate
38:36 - item from a list provided by visual
38:38 - studio like this
38:42 - the red squiggly line is still there
38:45 - this is because visual studio is telling
38:47 - us as it were
38:49 - that we need to implement code for all
38:51 - the method definitions that we have
38:53 - defined within the i product repository
38:56 - interface
38:58 - so let's press ctrl period once again
39:01 - and select the appropriate item from the
39:02 - list presented to us
39:07 - and visual studio generates the relevant
39:09 - code stubs for us
39:11 - so visual studio generates default
39:13 - implementations for
39:16 - the relevant method definitions
39:18 - so at this stage we only want to
39:20 - implement the code logic relevant to the
39:22 - workflow that is the focus of this video
39:25 - i.e returning a collection of product
39:27 - data to the client side calling code in
39:30 - this case our blazer component
39:33 - we are going to need to use the shop
39:34 - online db context object to interact
39:37 - with our shop online database
39:40 - as you will recall earlier
39:43 - we registered the shop online db context
39:45 - object for dependency injection
39:48 - this means that we are able to gain
39:50 - access to an object of type shop online
39:53 - db context by defining an appropriate
39:56 - parameterized constructor in our product
39:58 - repository class
40:02 - so let's create the code for this
40:04 - an easy way to automatically generate a
40:06 - constructor within visual studio
40:09 - is type ctor
40:11 - and then press the tab key twice like
40:14 - this
40:24 - then in order to indicate to.net that we
40:27 - want an object of type shop online db
40:30 - context to be injected into this
40:32 - constructor all we need to do is define
40:35 - a parameter within our constructor of
40:37 - type shop online db context like this
40:41 - let's bring in the appropriate namespace
40:44 - and we can get visual studio to create
40:46 - an appropriate private read-only member
40:49 - variable to reference our shop online db
40:52 - context object
40:53 - by pressing control period
40:56 - and selecting the appropriate item from
40:58 - the list presented to us by visual
41:00 - studio
41:02 - great
41:03 - so for the workflow that is the focus of
41:05 - this tutorial
41:07 - we only need to implement code for two
41:09 - of the method definitions within the i
41:12 - product
41:13 - repository interface
41:15 - so at this point we are only going to
41:17 - implement code for the get items method
41:20 - and the get categories method
41:22 - so let's implement code for the get
41:24 - items method
41:26 - all we want this method to do is return
41:28 - all the products from the products table
41:31 - so let's write the code for this
41:34 - note we want our code to run
41:36 - asynchronously so we must include the
41:38 - await keyword here
41:40 - notice how once we have typed in the
41:42 - await keyword that the async keyword
41:45 - automatically appears in the method
41:47 - definition for the get items method
41:50 - if you include the await keyword within
41:52 - a method
41:53 - the method in which you include the
41:55 - await keyword must appropriately contain
41:58 - the async keyword
42:00 - note that to include the to list async
42:03 - extension method here in our code we
42:06 - must bring in the microsoft.entity
42:08 - framework core namespace
42:19 - and that's it
42:20 - we have written the code to return an i
42:22 - enumerable collection of products data
42:25 - from our database
42:27 - so let's implement the code to return
42:29 - the product categories from our database
42:32 - we can do this by implementing the
42:33 - appropriate code within our get
42:35 - categories method like this
42:47 - great
42:49 - so we have now implemented the code for
42:51 - retrieving product data from our
42:53 - database
42:54 - the next step is to write code to return
42:58 - the appropriate data to the calling
43:00 - client
43:01 - so to do this we need to create an
43:03 - appropriate controller class
43:06 - before we create our controller class
43:08 - let's delete these classes that were
43:10 - generated by default when we first
43:13 - created our web api project
43:15 - these classes are obviously not going to
43:17 - be used in our application
43:25 - so now let's create a class within our
43:27 - controllers directory
43:38 - let's ensure that we select the
43:39 - appropriate controller class template
43:49 - let's name this class product controller
43:53 - so the first thing to do is to write the
43:55 - code so that an object of type product
43:58 - repository is automatically injected
44:00 - into our controller classes constructor
44:03 - via dependency injection
44:25 - let's also ensure that we have a
44:27 - read-only private field that references
44:30 - the object passed in via dependency
44:32 - injection
44:34 - but we haven't yet registered our
44:35 - product repository class for dependency
44:38 - injection
44:39 - so let's write the code for this let's
44:41 - open the program.cs file
44:45 - let's implement the code to register the
44:47 - product repository class with the
44:49 - dependency injection system
44:51 - notice how we use the add scoped method
44:54 - to register our product repository class
44:56 - for dependency injection
44:58 - we could have used the add transient
45:00 - method or the add singleton method to
45:03 - register our product repository class
45:05 - with the dependency injection system but
45:08 - in our case add scoped is the
45:10 - appropriate method for this purpose
45:13 - very basically
45:14 - using add transient would mean that a
45:17 - new instance of the relevant object is
45:19 - provided to every class that requires
45:22 - the relevant object to be injected
45:25 - using add singleton would mean that the
45:28 - same instance of the object is injected
45:30 - into the relevant classes for every http
45:33 - request
45:35 - using add scoped means that the same
45:38 - instance of the object is injected into
45:40 - relevant classes within a particular
45:43 - http request
45:45 - note that in this case a new instance of
45:47 - the relevant object will be created for
45:50 - each http request
45:52 - let's create a method definition for an
45:55 - action method named get items
45:58 - we want our action method to run
46:00 - asynchronously
46:03 - the type that is passed to the generic
46:05 - task object
46:07 - is of the generic action result type
46:11 - one of the core benefits of returning an
46:13 - action result
46:14 - is that as well as returning the
46:16 - requested data from an action method to
46:18 - the client an appropriate response
46:21 - status code can also be returned for
46:23 - example a http status code of 200 means
46:27 - the request
46:28 - has succeeded a status code of 404
46:31 - represents that a resource could not be
46:33 - found and a http status code of 500
46:37 - represents that an internal server error
46:39 - occurred
46:41 - so we need to pass the type of data that
46:44 - we wish to return to the client as a
46:46 - type argument to the action result
46:49 - generic type
46:50 - so we want to return an i enumerable
46:52 - collection of type product dto to the
46:55 - client
46:57 - so the first thing we need to do is
46:58 - create a project reference to the shop
47:01 - online dot models project
47:03 - because this is where our product dto
47:06 - class resides
47:19 - then let's bring in the
47:22 - shoponline.models.dtos namespace great
47:25 - let's name our action method get items
47:29 - each action method in our controller
47:31 - must map to a particular http verb
47:34 - for example get post push delete etc
47:39 - our get items action method will be used
47:42 - for getting product data and returning
47:44 - that product data to the client
47:47 - so the appropriate http verb for this
47:50 - action method is get
47:52 - so to indicate this to dot net we need
47:55 - to decorate our get items action method
47:58 - with the http get attribute
48:02 - so let's implement the code logic for
48:04 - our get items action method
48:06 - let's first create a try catch block
48:09 - an easy way to do this in visual studio
48:11 - is to type in try followed by pressing
48:14 - the tab key twice
48:16 - so let's write code that calls the
48:18 - product repository classes get items
48:20 - method asynchronously to return an i
48:23 - enumerable collection of type product to
48:26 - our action method
48:36 - we want to include the category name
48:38 - associated with each product in our
48:40 - collection so let's write code to return
48:43 - a collection
48:44 - of product category objects to our
48:47 - action method
48:48 - we'll write the code that joins our
48:50 - collection of products with our
48:52 - collection of product categories in a
48:54 - bit
48:58 - so you may have spotted that the code in
49:00 - this action method is not ideal at the
49:03 - moment
49:04 - it is not ideal because we are
49:07 - retrieving a collection of products and
49:09 - a collection of categories in two
49:10 - separate queries to the database
49:13 - a more performant way for retrieving the
49:16 - product collection and related category
49:18 - data
49:19 - would be to appropriately use the
49:21 - include extension method
49:24 - within the relevant link query in the
49:26 - get items method within the product
49:28 - repository class
49:31 - the use of the include method would join
49:34 - the data retrieved from the products
49:36 - database table with related data
49:39 - retrieved from the product categories
49:41 - database table and allow for the
49:43 - products data and related category data
49:46 - to be returned through one query
49:49 - i'm going to leave the code as it is for
49:51 - now we'll optimize this code for
49:53 - performance by using the include
49:55 - extension method as i've just described
49:58 - toward the end of the course
50:02 - so if either the products variable is
50:04 - null
50:05 - or the product categories variable is
50:08 - null
50:09 - let's return a status code of not found
50:11 - to the calling client code
50:14 - so in this case our web api will return
50:16 - a http status code of 404
50:19 - meaning that relevant data was not found
50:22 - or a relevant resource was not found
50:25 - so in this case it means that the client
50:27 - request failed
50:29 - and the reason for the failure is that
50:31 - an essential resource could not be found
50:39 - else
50:40 - we want to join the collection of
50:42 - product categories with the collection
50:44 - of products so that we can return a
50:47 - collection of product dtos to the
50:49 - calling client code
50:51 - which will include the category name
50:54 - remember the product dto definition
50:56 - contains a category name property
50:59 - in order to get the category name for
51:01 - each product in the collection we need
51:03 - to join the collection of type product
51:06 - to the collection of type product
51:08 - category
51:09 - we are going to use link for this
51:11 - purpose
51:13 - in order to avoid creating too many
51:15 - lines of code within our action method
51:18 - we are going to create an extension
51:19 - method to return a collection type of
51:22 - product dto to our action method
51:25 - so let's create a folder named
51:27 - extensions
51:35 - let's create a class within our
51:37 - extensions folder named dto conversions
51:45 - note that in order to create an
51:46 - extension method we need the class that
51:49 - houses our extension methods to be
51:51 - static
51:52 - let's create our extension method
51:56 - so the extension method must be a static
51:58 - method and we want to return an
52:00 - ienumerable collection of objects of
52:03 - type product dto to the calling code
52:06 - let's name our method convert to dto
52:10 - the first parameter in an extension
52:12 - method must be the type of an object on
52:15 - which we want
52:17 - to be able to call the convert dto
52:19 - extension method so by convention this
52:22 - parameter definition must also be
52:24 - preceded by this keyword
52:28 - so on an ienumerable collection of type
52:30 - product we want to be able to call the
52:32 - convert to dto method in order to
52:34 - convert an ienumerable collection of
52:37 - type product to an ienumerable
52:39 - collection of type product dto
52:43 - the logic for this method will using a
52:45 - link query join a collection of type
52:48 - product to a collection of type product
52:51 - category and return a collection of type
52:53 - product dto to the calling code so the
52:56 - second parameter of the convert to dto
52:58 - method is of a type that is an
53:01 - ienumerable collection of type product
53:03 - category
53:05 - let's write the logic for our extension
53:07 - method
53:10 - so let's write a link query that joins
53:12 - the collection of type product to the
53:14 - collection of type product category and
53:17 - return a collection of type product dto
53:44 - great
53:46 - so let's go back to the product
53:47 - controller class and finish the code for
53:49 - the get items action method
54:06 - so in order for the convert to dto
54:08 - method to be accessible on the products
54:10 - variable
54:11 - we must of course bring in the
54:14 - shoponline.api.extension's namespace
54:25 - then let's pass in the product
54:27 - categories variable as an argument to
54:30 - the convert to dto extension method
54:42 - then we can return
54:44 - a http status code of 200 to the calling
54:47 - code
54:48 - we can do this by returning the results
54:51 - of an ok method
54:53 - which accepts an argument of a
54:56 - collection of type
54:57 - product dto
55:00 - so this code returns a http status code
55:03 - of 200
55:04 - as well as a collection of type product
55:06 - dto to the calling client code
55:10 - so if for some reason an exception
55:12 - occurs during the running of the
55:14 - relevant server side code
55:16 - in this case we want our code
55:19 - to return a http status code of 500
55:22 - to the calling client code coupled with
55:25 - an appropriate error message
55:27 - let's keep the error message simple
55:33 - great
55:34 - so if we open our program.cs file
55:38 - you can see the configuration code here
55:40 - related to swagger and swagger ui
55:45 - swagger is an interface description
55:47 - language
55:48 - for describing restful apis expressed
55:51 - using json
55:56 - the configuration relevant to swagger ui
55:58 - here means that our web api project is
56:01 - equipped with a basic web-based user
56:04 - interface
56:05 - where we can see relevant information
56:07 - regarding our controllers and action
56:09 - methods
56:10 - we are also able to use the swagger user
56:12 - interface to test and debug our action
56:15 - methods
56:16 - when we run our web api code
56:18 - interactively through visual studio
56:22 - so let's run our code to see this in
56:24 - action
56:43 - and here we are presented with the
56:45 - swagger ui
56:55 - let's test our get items action method
56:59 - we can do this through our swagger user
57:01 - interface like this
57:13 - excellent
57:14 - in the next part of this video series
57:17 - we'll write the calling client code that
57:19 - calls the action method that we have
57:21 - written in this tutorial from our blazer
57:23 - component
57:24 - we'll also write the code to
57:26 - appropriately display the products
57:28 - returned from our web api component to
57:30 - the user
57:32 - so in the next tutorial we'll start to
57:35 - develop our blazer webassembly component
57:49 - so this is the third part of a video
57:52 - series where we are building a shopping
57:54 - cart application using blazer web
57:56 - assembly and web api
57:59 - we are building our application on.net 6
58:02 - which at the time of writing this video
58:04 - is the latest version of net
58:07 - we are now at a stage
58:09 - where we have built our database using
58:10 - entity framework core code first
58:12 - migrations
58:14 - and have started implementing code for
58:16 - the first workflow which simply involves
58:19 - retrieving products data from our
58:20 - database and displaying this product's
58:23 - data to the user
58:26 - in part 2 the previous part of this
58:28 - video series
58:29 - we implemented the code that retrieves
58:32 - the relevant product data from our
58:33 - database and returns the data to the
58:35 - calling client
58:37 - this code was implemented in an action
58:39 - method within a controller class named
58:41 - product controller
58:43 - this class was created within our
58:45 - shoponline.api project which contains
58:48 - the code for our web api component
58:52 - in this video we want to start
58:53 - developing the code for our client-side
58:55 - blazer component
58:57 - so in this video we'll implement code
58:59 - within our blazer component to call the
59:02 - action method that we developed in the
59:04 - previous part of this video series and
59:06 - display the returned data to the user
59:11 - so let's get started
59:13 - the first thing we need to do is copy
59:15 - the url to our clipboards which is the
59:17 - url of our web api component
59:21 - when we run the shoponline.api project
59:23 - through visual studio
59:26 - we are doing this so that we can
59:28 - appropriately configure our blazer
59:30 - component to point to the appropriate
59:32 - local web api url
59:35 - so that we can easily test our
59:37 - application through visual studio during
59:39 - the development phase of our shopping
59:41 - cart application
59:43 - one way we can access the relevant url
59:45 - is to simply run our web api project
59:49 - so let's copy this part of the url
59:52 - which we can refer to as the base url or
59:54 - base address to our clipboards
59:57 - then let's open the program.cs class
59:59 - within our shoponline.web component
60:12 - so here is a block of code that was
60:14 - automatically included within our
60:16 - shoponline.web component
60:18 - whereby the http client object is
60:21 - configured for dependency injection
60:24 - this means that we will automatically
60:25 - have access to a http client object from
60:29 - appropriately written classes within our
60:31 - blazer component
60:33 - we will be using the http client object
60:36 - to call relevant action methods within
60:38 - our web api component
60:41 - so in order for our http client
60:44 - component to point to the web api
60:46 - component on our local machines we need
60:49 - to replace the argument
60:51 - that is currently being passed to the
60:53 - uri constructor here with the base url
60:57 - that we have just copied to our
60:58 - clipboards
61:00 - so let's appropriately paste the base
61:02 - url copied to our clipboards here
61:06 - great
61:08 - so we are going to wrap the
61:10 - functionality that handles calls to our
61:12 - web api component within services
61:16 - these services are simply c-sharp
61:18 - classes that wrap the functionality for
61:21 - handling
61:22 - interactions with our web api component
61:26 - so the first thing to do is create a
61:28 - folder named services
61:38 - then within the services folder let's
61:40 - create a folder named contracts
61:50 - let's create an interface named i
61:52 - product service within the contracts
61:55 - folder
62:08 - so we'll build up the methods for the
62:10 - product service class over time when
62:13 - appropriate during the development of
62:15 - our application
62:17 - we are just going to implement code for
62:18 - one method in this video
62:21 - so let's create a method definition for
62:23 - our method in the i product service file
62:27 - we want our method to run asynchronously
62:30 - so our method will return a task object
62:32 - in this case we are going to write code
62:34 - to return a generic task object
62:37 - because this method must return a value
62:39 - to the calling code
62:43 - the type of value that we want to return
62:46 - to calling code is an ienumerable
62:48 - collection of objects of type product
62:51 - dto
62:52 - let's name this method get items
62:55 - in a bit we'll implement code for this
62:57 - method to retrieve relevant product data
63:00 - from the appropriate action method that
63:02 - resides within our web api component
63:06 - we have a red squiggly line under
63:08 - product dto
63:09 - the product dto type is defined within
63:12 - the shop online.models project so let's
63:15 - create a project reference to the shop
63:17 - online dot models project
63:24 - let's then bring in the name space for
63:26 - the product dto type
63:34 - great
63:35 - okay so let's create the code to
63:37 - implement our i product service
63:39 - interface
63:41 - so let's create a class named product
63:43 - service
63:44 - directly within the services folder
63:53 - let's create a constructor
63:59 - so we want to tell dot net as it were
64:02 - that we want a http client object to be
64:06 - injected into our product service class
64:10 - so to do this we simply define a
64:12 - parameter of type http client within our
64:15 - constructor definition
64:17 - then let's generate a read-only member
64:19 - variable
64:20 - to reference the object of type http
64:22 - client that will be injected into this
64:25 - class at runtime
64:28 - the next thing to do
64:30 - is to implement the i product service
64:32 - interface so let's write the code for
64:34 - this
64:42 - let's generate the code stub for the
64:44 - method that we have defined within the i
64:47 - product service interface
64:55 - let's write the code logic for the get
64:57 - items method
64:59 - let's first generate a try catch block
65:06 - within the try block let's write code to
65:09 - call the get items action method
65:11 - that resides within the product
65:13 - controller of our web api component
65:41 - you can see we are using the generic get
65:44 - from json async method to call the
65:46 - appropriate action method within our web
65:48 - api component
65:50 - we are passing in a type argument which
65:52 - is an ienumerable collection of type
65:55 - product dto to the get json async
65:58 - generic method
66:00 - we are doing this because we want our
66:01 - get from json async method to return an
66:05 - ienumerable collection of type product
66:07 - dto
66:09 - so this method will translate the data
66:11 - which will be in json format
66:14 - returned from the web api component into
66:17 - an object of type i innumerable
66:20 - which is strongly typed with the type
66:22 - product dto
66:25 - notice that we are passing in texture
66:28 - which denotes where the collection of
66:30 - resources that we want to retrieve from
66:32 - our web api component can be found
66:36 - the web api component will know as it
66:38 - were to invoke the get items action
66:41 - method within the product controller
66:42 - class of our web api component based on
66:45 - this information passed as an argument
66:49 - to the get from json async method
66:52 - we have a red squiggly line under get
66:54 - from json async so to get rid of the
66:57 - error flagged by the c-sharp compiler
67:00 - we must bring in the system.net
67:03 - dot http dot json namespace
67:06 - this is where the get from json async
67:09 - extension method resides
67:12 - the get items action method that we are
67:14 - calling in our web api component will
67:17 - return a collection of objects of type
67:19 - product dto in json format
67:22 - the json data will automatically be
67:25 - translated into an i enumerable
67:27 - collection of objects of type product
67:29 - dto for us
67:31 - so our products variable here will
67:34 - reference the returned result which will
67:36 - be an ienumerable collection of objects
67:39 - of type product dto
67:42 - so we could add additional codes to
67:44 - handle the http response returned from
67:47 - the web api component
67:49 - we'll look at writing code for this
67:51 - when we look at exception handling in
67:53 - more detail in a later tutorial
67:56 - for now i just want to go through the
67:58 - basics of returning data from the web
68:00 - api component and displaying the data to
68:03 - the user from code created within the
68:05 - blazer web assembly component
68:09 - so now we are going to create our razor
68:10 - component where we will create the code
68:13 - to display the data to the user i.e the
68:15 - data returned from the service
68:17 - functionality we have just created
68:20 - razer components are fundamental to
68:22 - blazer simply put
68:25 - blazer apps are built using razer
68:27 - components
68:29 - so within the pages folder let's create
68:32 - a razor component named products.razer
68:47 - note that we are able to create our code
68:49 - to call our service functionality
68:51 - directly within our razer file within
68:54 - the code section here
69:00 - in the interests of creating cleaner
69:02 - code we are going to abstract the code
69:04 - for consuming our service functionality
69:06 - within a base class
69:08 - our raiser component will then inherit
69:11 - from the appropriate base class
69:13 - so let's create a c-sharp class named
69:15 - products base
69:24 - so in order for our base class to be
69:26 - inherited from our razor component our
69:29 - base class must inherit from a class
69:31 - named component base which resides
69:34 - within the
69:35 - microsoft.asp.net core dot components
69:38 - namespace
69:40 - so let's go to our razer file
69:42 - we want our products.razer component to
69:45 - be invoked when our application is first
69:48 - loaded
69:49 - so we can ensure that this happens by
69:51 - declaring information about our razor
69:52 - components root at the top of this page
69:55 - like this
69:57 - note that when a razor component with an
69:59 - at page directive is compiled
70:02 - the generated component class is
70:04 - provided a root attribute specifying the
70:07 - component's root template
70:09 - here we are just providing a forward
70:11 - slash this means that when the url
70:14 - contains only the base url for our
70:16 - blazer component
70:18 - that our products dot razor component
70:20 - will be invoked
70:22 - and now we can write code within our
70:24 - razor file that declares that our
70:26 - products.razer component inherits from
70:30 - the product base class like this
70:35 - so let's go back to our product space
70:37 - class
70:39 - let's create a property to facilitate
70:40 - dependency injection
70:42 - of an object of type i product service
70:45 - into our products razor component
70:49 - so let's define a public property of
70:51 - type i product service named product
70:54 - service
70:55 - so to indicate to.net that we want an
70:57 - object of type i product service
71:00 - injected into this property we need to
71:02 - decorate the appropriate property with
71:04 - the inject attribute like this
71:10 - and of course we mustn't forget to
71:12 - register our product service class for
71:14 - dependency injection
71:16 - so to do this let's open the program.cs
71:19 - class
71:20 - and implement the relevant dependency
71:22 - injection configuration code like this
71:42 - great
71:44 - let's create a public property to expose
71:47 - an ienumerable collection of objects of
71:49 - type product dto
71:52 - this collection will be accessible to
71:54 - the relevant razor code that we'll
71:56 - implement in a bit
71:58 - to output the product data
72:01 - so now we want our code that retrieves
72:04 - our product data from the server our web
72:06 - api component to run when the product's
72:09 - razor component is first invoked
72:12 - we can do this by overriding a function
72:16 - named uninitialized async
72:19 - so to override a method we can type
72:22 - override press the spacebar and then
72:25 - select the method that we wish to
72:26 - override
72:29 - we want to override a method named on
72:31 - initialized async so let's select the
72:34 - appropriate item here
72:36 - the on initialized async method is
72:39 - associated with a blazer lifecycle event
72:43 - let's read a little bit about lifecycle
72:45 - events on this microsoft docs webpage
72:49 - the razer component processes razer
72:51 - component life cycle events in a set of
72:54 - synchronous and asynchronous life cycle
72:57 - methods
72:58 - the life cycle methods can be overridden
73:01 - to perform additional operations in
73:03 - components during component
73:05 - initialization and rendering
73:09 - if the component is rendering for the
73:11 - first time on a request
73:13 - create the components instance
73:15 - perform property injection run set
73:18 - parameters async call
73:21 - on initialized async
73:24 - if an incomplete task is returned the
73:26 - task is awaited and then the component
73:29 - is rendered
73:37 - so within the uninitialized async method
73:40 - let's implement the code for retrieving
73:42 - our products data from our web api
73:44 - component like this
74:03 - we are using the object of type i
74:04 - product service that will be injected
74:07 - into this class at runtime to return the
74:09 - relevant products data to our product
74:12 - component
74:16 - let's implement code for outputting the
74:18 - product data
74:31 - so if the product property is null ie
74:35 - has not yet been retrieved from the
74:37 - server
74:38 - we can output a loading indicator to the
74:40 - user so while the data is being
74:42 - retrieved
74:43 - this loading indicator will remain on
74:45 - the user's screen
74:47 - else when the relevant product data has
74:50 - populated the products property
74:53 - we want code to execute that outputs the
74:56 - product's data to the user in an
74:58 - aesthetically pleasing style
75:29 - let's bring in the namespace of our
75:31 - product dto
75:36 - class we can include this using
75:39 - directive in the underscore
75:41 - imports.raiser file here
75:44 - and this means that this using directive
75:46 - will apply to the other razer files as
75:48 - well
76:09 - let's write a link query here that
76:11 - sequentially takes four items at a time
76:13 - from the collection of product dto
76:15 - objects
76:23 - images relevant to each of the products
76:25 - has been uploaded to github please feel
76:27 - free to download these images each image
76:30 - maps to a row of data in the products
76:32 - table in our database we seeded our
76:34 - database with the relevant data in the
76:36 - first part of this video series
76:55 - let's then implement code to
76:57 - appropriately output the product data
77:30 - bootstrap 5 is being used to output each
77:32 - item of products data as a bootstrap
77:35 - card
77:37 - later we are going to abstract this code
77:39 - further to clean up the code a bit
77:42 - the final code for this functionality is
77:44 - available on github
77:46 - the appropriate link can be found below
77:47 - in the description
77:49 - for now i just want to write code to
77:51 - display our product data appropriately
77:53 - to the user
78:12 - it was pointed out in the comments
78:13 - section that my spelling of the word
78:15 - furniture is incorrect both in the shop
78:18 - online db context class and the sidebar
78:21 - in the prototype shopping cart
78:22 - application that i created in
78:24 - preparation for this video series
78:28 - i don't know why i spelled furniture
78:30 - with an a like this
78:32 - for nature
78:34 - but clearly that's what i did
78:37 - the consequence is that after you ran
78:39 - the migration to create and seed your
78:41 - database the word furniture may be
78:43 - incorrectly spelt in your product
78:45 - database table and your products
78:47 - category database table
78:49 - of course you may have spotted this and
78:51 - fixed this before creating and running
78:54 - the relevant migration if not the good
78:56 - news is that this is easy to fix
78:59 - i thought that fixing this issue gives
79:01 - us a great opportunity to see how easy
79:03 - it is to fix issues like this during the
79:06 - development phase of our application
79:08 - using ef core migrations
79:11 - we can fix the relevant data simply by
79:13 - correcting the spelling issue within the
79:15 - on model creating method in the shop
79:17 - online dbcontext class
79:20 - we can then generate a migration that
79:23 - will contain the code that can be used
79:25 - to update the database
79:27 - with the relevant fix
79:30 - so if you ran your migration where the
79:32 - word furniture was spelt incorrectly
79:34 - within the on model creating method of
79:37 - your shop online db context class
79:40 - please follow along with these steps to
79:41 - fix the issue within your database
79:44 - please note that the appropriate
79:46 - spelling fixes regarding all instances
79:48 - of the word furniture have been uploaded
79:51 - to the relevant github repository of
79:53 - course the link to the relevant
79:54 - repository is included below in the
79:56 - description
79:58 - so let's open the shop online db context
80:01 - class
80:02 - that can be found in the data folder
80:04 - within the shoponline.api
80:06 - project
80:08 - let's go to the on model creating method
80:12 - so let's press ctrl f so that we can
80:14 - perform a find and replace on the
80:16 - incorrectly spelt word furniture
80:20 - okay clearly i can't even make the
80:21 - excuse that this was a typo
80:25 - look at how consistent i've been in
80:27 - spelling the word furniture wrong
80:29 - right let's replace the incorrect
80:31 - spelling of the word furniture with the
80:33 - correct spelling of the word furniture
80:42 - so eight occurrences
80:44 - and here are some instances where our
80:46 - find and replace did not fix the
80:47 - spelling because our search was matching
80:50 - the whole word
80:52 - so let's amend the relevant image file
80:54 - name references for these particular
80:56 - instances
80:58 - of course make sure that furniture is
81:00 - spelled correctly for the relevant
81:01 - furniture folder and the relevant image
81:04 - files on your local machines
81:08 - i did correct the spelling issue before
81:10 - i uploaded the image files to github so
81:12 - your file system should contain the
81:14 - correct spelling from when you
81:15 - downloaded the relevant files from
81:17 - github
81:29 - we can now invoke the package manager
81:31 - console window from within visual studio
81:34 - and create a migration to fix our issue
81:37 - so let's create a new migration by
81:39 - typing in the add dash migration command
82:00 - and you can see that the appropriate
82:01 - code to fix the relevant data in our
82:03 - database is generated for us in a new
82:06 - migration class
82:08 - if we are happy with the relevant
82:10 - migration code we can run the update
82:13 - database command to fix the relevant
82:15 - data in our databases
82:18 - so let's do that
82:38 - great
82:40 - so we are now ready to run our code
82:43 - in order to run both the web api
82:45 - component and the blazer component
82:47 - simultaneously through visual studio we
82:50 - can configure the shoponline.api project
82:53 - and the shoponline web project to start
82:55 - up at the same time like this
83:01 - but we want the shoponline.api project
83:04 - to start a little bit earlier
83:21 - before we run our code let's delete the
83:23 - index.razer file from within our pages
83:25 - directory this razer component is also
83:28 - configured with the same route as we
83:30 - have configured for our products razer
83:32 - component and we are not going to use
83:35 - the index raiser component
83:37 - that was generated by default in our
83:39 - application
83:40 - so now when we first run this code we
83:42 - are actually going to get an exception
83:44 - i'll explain why in a bit and then we'll
83:46 - take steps to resolve the issue
83:50 - let's press the play button to run the
83:51 - code
84:06 - you can see here that we have an
84:07 - exception coming from our blazer
84:09 - component
84:11 - if we press f12 while our chrome
84:13 - browsers are active
84:14 - we can examine the relevant error
84:16 - message here
84:18 - the exception is caused as a result of
84:20 - cause
84:22 - or cross-origin resource sharing
84:25 - cross-origin resource sharing cause
84:29 - is a http header-based mechanism that
84:32 - allows a server to indicate any origins
84:35 - domain scheme or port
84:37 - other than its own from which a browser
84:40 - should permit loading resources
84:43 - basically this error occurs because our
84:46 - blazer component has a different base
84:47 - url to our web api component
84:51 - as a result of this a security barrier
84:53 - prevents us from being able to access
84:55 - the relevant resources returned from our
84:57 - web api component
85:06 - let's copy the base url for our blazer
85:08 - component to our clipboards you'll see
85:10 - why we are doing this in a bit
85:14 - we are able to configure a policy within
85:16 - our web api project
85:18 - to explicitly allow
85:20 - for our blazer components to access
85:22 - relevant resources
85:24 - so to do this let's open the program.cs
85:26 - file within our shoponline.api project
85:30 - and include the relevant course policy
85:32 - code like this
85:36 - so where you see the urls in this block
85:38 - of code
85:39 - please paste the base url for your
85:42 - blazer component for the relevant url
85:44 - arguments
85:45 - note that we can configure both the http
85:48 - version of our url and the https version
85:52 - of our url in this course policy code
85:58 - and please ensure that you don't include
86:00 - a forward slash character at the end of
86:02 - these url arguments
86:38 - great
86:40 - let's run the code again
87:01 - excellent we now have our product data
87:03 - appropriately displayed to us
87:05 - when we first load our application
87:31 - so all is working fine
87:33 - but if we look at our product dot raiser
87:35 - file
87:36 - we can see that we have written quite a
87:38 - lot of code here
87:40 - we can make this code that outputs a row
87:42 - of products reusable by abstracting this
87:44 - code into its own component
87:48 - its own razor component
87:51 - by abstracting this code into its own
87:54 - razor component we are not only allowing
87:56 - for the relevant code to be reusable by
87:59 - other razer parent components
88:01 - we are also creating cleaner code
88:04 - so to do this we can create a child
88:06 - razor component to house the code that
88:09 - outputs the relevant product data
88:12 - so let's create a razor component named
88:14 - displayproducts.razer
88:37 - let's create a c-sharp class named
88:40 - display product base which will of
88:42 - course be the base class for our
88:44 - displayproducts.razer
88:46 - component
89:01 - let's make our display products base
89:03 - class inherit from the component base
89:06 - class
89:14 - we want a parent razor component to be
89:16 - able to pass an i innumerable collection
89:19 - of objects of type product dto to our
89:22 - display products razer child component
89:26 - we can achieve this by creating a
89:28 - parameter property within our display
89:30 - products base class like this
89:33 - it is important to note that a parameter
89:36 - property
89:37 - is decorated with the parameter
89:39 - attribute
89:50 - let's go to the display products.razer
89:52 - file
89:53 - and implement code to inherit from our
89:56 - display products base class
89:59 - then we can go to our products.razer
90:01 - file
90:02 - and cut the relevant code and paste it
90:05 - into our display products.razer file
90:08 - like this
90:20 - then we can modify the code
90:22 - appropriately
90:23 - so that the code within the display
90:25 - products.razer file is traversing the i
90:28 - enumerable collection passed
90:30 - to the display products child razor
90:32 - components products parameter
90:41 - a child component cannot be accessed
90:44 - directly through a browser and therefore
90:46 - does not contain a root declaration
90:50 - a child razor component must be invoked
90:52 - from within a parent razor component
90:56 - so let's go to the product's parent
90:58 - razor component
90:59 - and call the child
91:01 - display products child component through
91:03 - this declarative code
91:05 - notice how we are able to pass the
91:07 - relevant collection of objects of type
91:09 - product dto to the products parameter
91:13 - that we defined within the display
91:15 - products child component
91:18 - and the code for calling the child razor
91:20 - component from the parent razor
91:22 - component is very much like typical html
91:25 - code
91:26 - by abstracting the code for displaying a
91:29 - list of products to the user into a
91:31 - child razor component we have created
91:34 - cleaner code facilitated easier code
91:37 - maintenance and the display products
91:39 - child razor component can be reused from
91:42 - within other parent components
91:45 - this will be demonstrated in a later
91:47 - tutorial
91:48 - let's run the code
92:05 - great
92:06 - so let's say that a requirement arises
92:10 - where we need to display each product
92:12 - item under its appropriate product
92:14 - category
92:17 - so to answer this requirement
92:19 - we can create an appropriate link query
92:21 - to group our objects of type product dto
92:24 - by product category
92:26 - like this
93:18 - we can also include a category heading
93:20 - for each group of products
93:31 - and of course each row containing the
93:34 - grouped products must reside within the
93:36 - loop like this
93:45 - let's also include a dividing line
93:47 - between each product group
94:15 - let's run the code
94:37 - great
94:38 - we can clean up this code even further
94:40 - by abstracting the relevant link code
94:43 - within the appropriate base class like
94:45 - this
96:53 - great
96:55 - and let's say that we only wish to
96:56 - display four items for each product
96:59 - category we can achieve this by using
97:01 - links take extension method like this
97:26 - excellent
97:28 - the last thing i'd like to do is add
97:30 - basic animation effects to each of the
97:32 - bootstrap cards we are using to
97:35 - represent our products
97:37 - so to add a css class that only applies
97:40 - to a particular razor component we can
97:42 - add a style sheet with a name that
97:44 - adheres to a specific naming convention
97:48 - so let's add a css style sheet to the
97:50 - pages directory
98:22 - and let's name the stylesheet
98:25 - displayproduct.razer.css
98:29 - this naming convention ensures that the
98:32 - styles contained
98:34 - within this file will only apply to the
98:37 - displayproducts.razer component
98:41 - which is the component that outputs the
98:43 - bootstrap cards that represent our
98:45 - products
98:46 - this tutorial is not about css so i've
98:49 - pre-prepared the relevant css code
98:53 - so i'm just going to paste the relevant
98:55 - code into the display products
98:57 - dot
98:58 - file here
99:00 - this code is of course accessible from
99:02 - within the relevant github repository
99:21 - let's run the code
99:39 - and you can see that when we hover our
99:40 - mouse pointers over a card the relevant
99:43 - image scales and a box shadow appears
99:45 - these basic animation effects have been
99:47 - included to enhance the user's ux
99:51 - excellent
100:04 - so this is the fourth part in a series
100:06 - of videos dedicated to building a
100:07 - shopping cart application on.net 6 using
100:10 - blazer web assembly and web api
100:14 - we have now created our first workflow
100:16 - which involves retrieving product data
100:18 - from the database and displaying the
100:20 - data to the user in an aesthetically
100:23 - pleasing style
100:25 - we have built our database using entity
100:27 - framework core
100:29 - we have implemented code using the
100:31 - repository design pattern
100:33 - within a web api component in order to
100:35 - return products data from our database
100:38 - to a calling client
100:40 - in the last part of this series part
100:42 - three
100:43 - we implemented code for our blazer
100:46 - webassembly component to call an
100:48 - appropriate action method within our web
100:50 - api component
100:52 - using a http get request in order to
100:55 - retrieve product data from the server
100:57 - and display the data to the user in an
100:59 - aesthetically pleasing style
101:02 - we want to create functionality to
101:04 - retrieve data
101:05 - for a specific product from the server
101:08 - and display the details of that product
101:10 - to the user
101:11 - so when the user clicks on a particular
101:13 - product only the details for that
101:15 - specific product are displayed to the
101:17 - user
101:18 - the user can then decide whether or not
101:21 - to add the product to the user's
101:23 - shopping cart
101:24 - a button will be provided within the
101:26 - razer component responsible for
101:28 - displaying the relevant products details
101:30 - whereby a user can click this button and
101:33 - add the relevant product to the user's
101:35 - shopping cart we'll implement the code
101:37 - for the add to cart button in the next
101:40 - tutorial
101:42 - so let's go to the web api component
101:46 - let's open the product repository class
101:48 - and go to the get item method
101:51 - you can see that currently we have a
101:52 - default implementation for this method
101:55 - which was created when we generated the
101:58 - code stubs
101:59 - through visual studio of the i product
102:01 - repository interface that we are
102:03 - implementing in the product repository
102:06 - class
102:07 - so as the name implies the get item
102:09 - method returns data regarding a single
102:12 - item
102:22 - so we can use the find async method to
102:25 - retrieve the data pertaining to the
102:26 - product that matches the id value passed
102:29 - into the get item method through code
102:32 - like this
102:34 - the next step is to expose the
102:36 - functionality to a calling client by
102:38 - implementing code that gets executed in
102:41 - reaction to an appropriate http get
102:44 - request
102:45 - so we want the get item functionality to
102:47 - execute when a calling client makes an
102:50 - appropriate http get request for product
102:53 - data that can be identified in the
102:56 - system with the id value passed to our
102:59 - web api component from the calling
103:01 - client
103:03 - we can implement code that creates an
103:05 - appropriate http response
103:08 - through creating an action method within
103:10 - our product controller controller class
103:13 - so let's create a method within the
103:15 - product controller class to return data
103:17 - for a particular product
103:20 - to speed things up let's duplicate the
103:22 - get items action method that we created
103:25 - in the second part of this series
103:27 - and change the code appropriately so as
103:30 - to implement the functionality for the
103:32 - get item action method
103:35 - we only want to return data for one
103:37 - object of type product dto rather than
103:40 - an i enumerable collection of objects of
103:43 - type product dto to the calling client
103:46 - so let's change the return type
103:48 - appropriately
103:49 - let's include a parameter named id which
103:52 - is of type integer
103:54 - this id parameter denotes the id value
103:57 - of the product data for which the client
103:59 - wishes to have returned from our web api
104:02 - component within the http get attribute
104:06 - let's include the appropriate root
104:08 - template information
104:10 - our get item action method contains a
104:12 - parameter of type integer named id
104:15 - so for the get item action method it is
104:18 - appropriate to pass in an argument of
104:20 - type string
104:22 - to its corresponding
104:24 - http get attribute that denotes the
104:27 - appropriate root template for this
104:29 - action method
104:32 - so let's use the product repository
104:34 - object passed into our controller class
104:36 - via dependency injection to call the
104:38 - getitem method
104:39 - that we have just implemented within the
104:41 - product repository class
104:44 - so if the returned value is null this
104:46 - means that the resource does not exist
104:48 - so let's pass a response to the calling
104:50 - client
104:51 - that includes a bad request status code
104:55 - we can do this in code by returning the
104:57 - result returned from the bad request
104:59 - method like this so let's say we also
105:03 - want to include the name of the category
105:06 - under which the relevant product
105:08 - falls
105:09 - in the returned object
105:14 - as we know we only have the id of the
105:17 - category under which the returned
105:19 - product falls within the product entity
105:22 - we don't have the facility to store any
105:25 - other information pertaining to the
105:26 - products category within the product
105:29 - entity
105:30 - so we need to write code to get the
105:32 - category information from the product
105:34 - category entity
105:36 - we can then include the product
105:37 - information and the category information
105:40 - in an object of type product dto and
105:42 - return the relevant object of type
105:44 - product dto to the calling client
105:47 - so let's implement code for the get
105:48 - category method within the product
105:50 - repository class to retrieve data
105:53 - for our specific category based on the
105:55 - category id passed into this method
106:26 - let's then write code within our get
106:28 - item action method to appropriately call
106:30 - the get category method on the object of
106:33 - type
106:34 - i product repository like this
106:37 - the next step is to write the code that
106:39 - merges the data pertaining to a specific
106:42 - product
106:43 - with the data pertaining to the relevant
106:45 - products category
106:47 - into one object of type product dto in
106:50 - order to write the code for this in a
106:51 - clean way
106:53 - we can create a convert to dto extension
106:56 - method overload within our dto
106:59 - conversions class so the convert to dto
107:02 - extension method currently within our
107:04 - dto conversions class converts a
107:06 - collection of products and a collection
107:08 - of product categories
107:11 - appropriately into a collection of
107:13 - objects of type product eto and returns
107:16 - the collection of objects of type
107:17 - product dto to the calling code
107:20 - we want our new convert to dto extension
107:23 - method overload to convert one object of
107:25 - type product and related object of type
107:28 - product category into one object of type
107:31 - product dto and return the subject of
107:34 - type product dto to the calling code
107:37 - this is basically so that we can include
107:39 - the relevant product data and the
107:41 - category name within one object
107:44 - our product dto type facilitates this
107:48 - so we can write code to perform the
107:50 - relevant conversion like this
108:30 - we can now go to our get item action
108:32 - method and call the convert to dto
108:35 - extension method
108:36 - which is now available on this object of
108:39 - type product to return the appropriate
108:41 - object of type product dto to our action
108:44 - method
108:46 - we can then write code to return a http
108:49 - status code of 200 okay
108:52 - along with the relevant object of type
108:54 - product dto to the calling client by
108:57 - appropriately returning the result of
108:59 - the ok method and passing in the
109:01 - appropriate object of type product dto
109:04 - to the ok method
109:06 - if an exception occurs for some reason
109:09 - during the execution of the get item
109:11 - action method
109:12 - we have code here that will return a
109:14 - http status code of 500 denoting an
109:18 - internal server error
109:20 - to the calling client along with an
109:22 - appropriate error message
109:24 - great
109:26 - so let's write code within the blazer
109:28 - component
109:29 - to make an appropriate http call to the
109:32 - server side code that we have just
109:34 - implemented
109:36 - so let's open our i product service
109:38 - interface
109:39 - let's include a method definition for a
109:41 - method
109:42 - where we will implement the code to call
109:44 - the get item action method on the server
109:48 - we want this getitem method to run
109:51 - asynchronously so we are returning a
109:53 - task object
109:55 - the getitem method is returning a value
109:58 - so we must pass the return type as a
110:01 - type argument
110:03 - to the generic task type here
110:07 - this method contains a parameter of type
110:09 - integer and is named id
110:12 - this id parameter denotes the id value
110:15 - that is used to identify a specific
110:18 - product
110:20 - so let's implement the get item method
110:23 - in the product service class
110:25 - let's generate a try catch block
110:28 - in the previous part of this series part
110:30 - 3 we implemented code for the get items
110:33 - method that uses the http client objects
110:36 - get from json async method to call the
110:39 - relevant server side action method
110:41 - this method calls the relevant action
110:43 - method but also handles translating the
110:45 - returned json data into the appropriate
110:49 - objects type
110:53 - i'm going to use the get async method to
110:55 - call the relevant action method in our
110:57 - get item method this method doesn't
111:00 - convert the returned json data to the
111:03 - appropriate object type we need to write
111:06 - code for this separately we'll do that
111:08 - in a bit the get async method returns a
111:11 - http response object
111:13 - so we can use the returned object to
111:15 - first ascertain
111:17 - as to whether our http request to the
111:20 - server was successful
111:22 - so this code checks that the relevant
111:24 - status code falls within the success
111:26 - range
111:28 - so if the call is successful we want
111:30 - code
111:31 - to execute that checks if our http
111:34 - request has returned a response with
111:37 - content
111:38 - if there is no content returned from the
111:40 - server we want code executed that
111:42 - returns
111:44 - the default value associated with the
111:46 - product dto type like this
111:49 - so the c sharp default value for a user
111:52 - defines type which is a reference type
111:54 - will be null
111:56 - so this is just the way i'm choosing to
111:58 - handle the scenario where the call to
112:00 - the server is successful but for some
112:02 - reason no data is returned from the
112:04 - server
112:06 - so when the call is successful and
112:08 - content is returned from the server we
112:10 - want code to execute that translates the
112:13 - json data returned from the server into
112:15 - an object of the appropriate type
112:34 - else if the call to the server is not
112:36 - successful we want code to execute that
112:38 - handles the exception
112:40 - so here we are just going to throw the
112:42 - exception at this point
112:44 - and we can pass the message sent back
112:46 - from the server as an argument to the
112:48 - exception object like this
113:05 - within the catch block
113:07 - we could implement codes to log the
113:08 - exception or handle the exception
113:11 - in an appropriate manner that we choose
113:15 - let's implement appropriate code within
113:17 - the get items method to also include
113:19 - exception handling functionality
114:46 - so let's create a razor component within
114:48 - the pages folder
115:04 - let's name this component
115:05 - productdetails.razer
115:08 - so this is the component where we'll
115:10 - implement the code to display details
115:12 - regarding a specific product
115:16 - let's create the base class for our
115:17 - product details component and let's name
115:20 - this component product details base
115:30 - let's implement the code for our product
115:32 - details base class
115:35 - we want the id parameter that denotes
115:38 - the identifier for a specific product to
115:41 - be passed into the component so let's
115:43 - create a parameter named id that is of
115:46 - type integer
115:48 - we need to decorate this property with
115:50 - the parameter attribute
115:52 - we also need to ensure
115:54 - that our base class inherits from the
115:56 - component base class
115:59 - so we want an object of type i product
116:02 - service to be injected into our product
116:05 - details component
116:07 - so we can do this by including a
116:09 - property within our base class of type i
116:11 - product service
116:13 - and decorate the relevant property with
116:15 - the inject attribute
116:23 - let's include a property of type product
116:26 - dto within our base class
116:28 - and let's name this property product
116:35 - let's include a string property to store
116:37 - an exception message
116:40 - so we want code to execute when our
116:41 - blazer component is first invoked
116:44 - so we can ensure that this happens by
116:46 - writing the relevant code within a
116:48 - method that overrides the uninitialized
116:50 - async method
116:52 - to generate the appropriate
116:54 - uninitialized async method let's type in
116:57 - override followed by pressing the space
116:59 - bar and then let's select the
117:01 - appropriate method from the list
117:03 - presented to us
117:08 - let's generate a try catch block
117:11 - within the try catch block let's
117:13 - appropriately call the get item method
117:15 - on the injected object of type i product
117:18 - service the returned value is assigned
117:21 - to our product property
117:23 - which we can then access from our
117:25 - product details.razer file
117:38 - if an exception occurs we want the
117:40 - exception message to be assigned to the
117:43 - error message property
118:09 - let's implement code to output details
118:11 - regarding the relevant product
118:15 - so let's ensure that we include the
118:17 - appropriate root template at the top of
118:19 - the file
118:21 - we can use the page directive for this
118:23 - purpose and notice how we are including
118:26 - the id parameter here
118:28 - this is because an appropriate id
118:30 - parameter must be passed to this razor
118:32 - component when this razor component is
118:34 - invoked
118:46 - let's write the code logic
118:49 - so while the product property is null
118:51 - and the error message property is null
118:53 - we want a loading indicator to be
118:55 - displayed to the user
119:03 - else if an error occurs in which case
119:06 - the error message property will not be
119:08 - null we want the error message to be
119:10 - displayed
119:12 - please note that for the sake of this
119:14 - example we are writing functionality to
119:16 - display the error message returned from
119:18 - the server to the screen
119:21 - in a complete application it would be
119:23 - more appropriate to output a
119:25 - user-friendly non-technical error
119:27 - message to the user and log the actual
119:30 - error message returned from the server
119:34 - else we want to output the details of
119:35 - the relevant product in an aesthetically
119:38 - pleasing style to the user
120:09 - and of course bootstrap 5 classes are
120:11 - being used here to output the data in an
120:14 - aesthetically pleasing style
120:55 - great
120:57 - then let's go to the display
120:59 - products.razer file and include the
121:01 - appropriate value for the href attribute
121:04 - within the anchor tag that wraps the
121:06 - cards that represent the products sold
121:09 - in our online store
121:11 - so we want this link to invoke the
121:13 - product details razer component
121:17 - we need to include the appropriate id
121:19 - value denoting the identifier for a
121:22 - specific product within our href
121:24 - attribute value here
121:27 - let's run the code
121:48 - great
121:51 - let's abstract the code that outputs an
121:53 - exception to the user in its own razor
121:56 - component
121:57 - so that we can reuse this component from
121:59 - within multiple parent razor components
122:02 - this is also a cleaner way of
122:04 - implementing the code that displays an
122:06 - error message to the user
122:28 - let's write code to force an exception
122:30 - to occur
122:31 - so we know that a product with an id of
122:33 - 1000 does not exist in the system
122:36 - so in this case the server will send
122:38 - back a response code indicating that a
122:41 - bad request has been made
122:43 - let's run the code
123:00 - great
123:12 - lastly it would be better in terms of a
123:14 - user's ux
123:16 - if an appropriate animated loading
123:18 - indicator was displayed to the user
123:20 - while the user is waiting for data to be
123:22 - displayed
123:24 - so if we navigate to this site here
123:31 - we can copy the relevant html and css
123:33 - code for an animated loading indicator
123:37 - of our choice
123:39 - these loading indicators here can be
123:41 - used within our application free of
123:43 - charge
123:45 - so let's select this one
123:47 - let's copy the html and the css code for
123:50 - the loading indicator of our choice and
123:52 - integrate the code within our
123:54 - application
123:55 - the cleanest way to integrate this code
123:57 - into our applications
123:59 - in my opinion is to abstract the loading
124:01 - indicator code within a razor component
124:04 - as discussed in the previous part of
124:06 - this series part 3 we are able to create
124:09 - a css file
124:11 - that only applies
124:12 - to its corresponding razer component
124:15 - by naming the relevant css file in a way
124:18 - that adheres to a specific naming
124:19 - convention
124:21 - so if the name of the razer component is
124:24 - display spinner we can create a css file
124:27 - that will only apply to this razor
124:29 - component by naming the relevant css
124:32 - file display
124:36 - spinner.razer.css so we can now reuse
124:39 - the spinner functionality
124:41 - for multiple parent components
125:48 - i look forward to presenting the next
125:50 - video in this series where we'll create
125:52 - the functionality for adding products to
125:54 - a shopping cart
126:12 - this is the fifth part in a video series
126:15 - dedicated to building a shopping cart
126:17 - application using
126:19 - blazerwebassemblyon.net 6.
126:22 - so we have completed the implementation
126:24 - of two workflows
126:26 - the first workflow involves retrieving
126:29 - the data pertaining to the products sold
126:32 - by our online store
126:34 - and displaying the data in an
126:36 - aesthetically pleasing style to the user
126:39 - the second workflow involves displaying
126:42 - details for a particular product to the
126:45 - screen
126:45 - in response to the user clicking on a
126:47 - card representing the relevant product
126:52 - in this video we'll create the
126:54 - functionality whereby the user clicks
126:56 - the add to cart button
126:58 - which is available on the screen where
127:01 - details for a particular product are
127:02 - displayed
127:04 - this button click action will result in
127:06 - the relevant product being added to the
127:09 - user's shopping cart
127:12 - after the user has clicked the add to
127:14 - cart button
127:16 - the user will subsequently be navigated
127:18 - to a screen that displays data
127:21 - pertaining to the products currently
127:23 - contained within the user's shopping
127:26 - cart
127:27 - so let's get started
127:29 - so let's first implement the
127:31 - functionality for the server side code
127:34 - so let's go to our project
127:36 - that contains the functionality for our
127:38 - web api component
127:40 - in the second part of this video series
127:43 - we implemented the repository design
127:45 - pattern for functionality to handle
127:48 - database interactions regarding the
127:50 - products sold by our online store
127:54 - so we now want to create the code for
127:57 - handling the database functionality
127:59 - pertaining to the shopping cart
128:02 - so let's create an interface that
128:04 - contains the method definitions for the
128:07 - shopping cart repository class that
128:09 - we'll create once we have created its
128:12 - interface
128:13 - so let's create an interface named i
128:16 - shopping cart repository
128:30 - let's create a method definition for a
128:32 - method named add item
128:34 - as the name suggests
128:36 - the code that we'll implement for this
128:38 - method will add a particular product to
128:40 - the relevant user's shopping cart
128:57 - let's add a method definition for a
128:59 - method named update qty
129:02 - when a user first adds a product to the
129:05 - user's shopping cart
129:07 - the quantity of the relevant product
129:09 - added to the user's shopping cart will
129:12 - be won by default
129:15 - the implementation for this method will
129:17 - involve updating the quantity of a
129:19 - particular product
129:21 - that is currently contained within a
129:23 - user's shopping cart
129:25 - let's add a method definition for a
129:27 - method named delete item
129:30 - as the name suggests the functionality
129:32 - for this method will involve removing a
129:34 - particular product from the user's
129:36 - shopping cart
129:38 - the get item method will contain
129:40 - functionality for retrieving data
129:43 - regarding a particular product that is
129:45 - currently in the user's shopping cart
129:48 - the get items method will contain
129:51 - functionality for retrieving data for
129:53 - all the products that are currently in a
129:55 - particular user's shopping cart
130:02 - so let's create a class named shopping
130:04 - cart repository
130:23 - let's write codes to implement the i
130:25 - shopping cart repository interface that
130:28 - we have just created
130:30 - let's position our mouse pointers
130:31 - appropriately and press control period
130:34 - in order to bring in the appropriate
130:36 - namespace ie where the i shopping cart
130:39 - repository interface resides
130:43 - let's press control period and generate
130:45 - the code stubs for the method
130:47 - definitions that we included within the
130:49 - i shopping cart repository interface
130:52 - so in this video
130:54 - we are going to implement functionality
130:56 - for three of the methods that we have
130:58 - defined within the i shopping cart
131:00 - repository interface namely add item get
131:04 - items and get item
131:06 - before we do this let's create a
131:08 - constructor
131:18 - let's add a parameter to our constructor
131:21 - that is of type shop online db context
131:25 - by including this parameter we are
131:27 - indicatingto.net that we want an object
131:30 - of this type injected into our shopping
131:33 - cart repository class at runtime
131:36 - we have already registered the shop
131:39 - online db context type for dependency
131:41 - injection
131:43 - the shop online db context type is the
131:46 - ef core database context object that is
131:49 - used for handling data manipulation and
131:51 - data retrieval functionality in relation
131:54 - to our applications database
132:04 - so let's implement the functionality for
132:06 - the add item method
132:08 - let's first write a link query that
132:10 - ensures that the product that the user
132:13 - is attempting to add
132:15 - to the user's shopping cart exists in
132:17 - the products table
132:36 - so if the item returned
132:38 - from our link query is not null
132:41 - we want code to execute that adds the
132:43 - relevant product to the cart items
132:45 - database table
132:47 - this denotes that the product has been
132:50 - added to the user's shopping cart
132:52 - so let's implement the code to add the
132:55 - item to the cart items database table
132:58 - once we have called the add async method
133:00 - we must also remember to call the save
133:03 - changes async method
133:06 - then we can write code
133:08 - to return the entity
133:10 - that has been successfully added to the
133:12 - cart items database table like this
133:17 - if an item is not successfully added to
133:19 - the database we want code to execute
133:22 - that will return null to the calling
133:24 - code
133:25 - so in order to avoid a product being
133:28 - added twice to our user's shopping cart
133:31 - let's implement code that checks to see
133:33 - if the relevant product already exists
133:36 - within the user's shopping cart
133:39 - let's implement the code for this in a
133:41 - private method
133:43 - that returns a boolean value
134:09 - then we can use the private method we
134:11 - have just created like this to perform
134:14 - the relevant check
134:37 - so we have ensured that only one
134:39 - instance of a particular product can be
134:41 - added to the user's shopping cart
134:44 - please note that the user will be able
134:46 - to purchase more than one instance of a
134:48 - particular product by appropriately
134:50 - modifying the qty or quantity field
134:55 - we'll implement this at a later stage
135:01 - let's implement the code for the get
135:02 - items method
135:04 - let's write code that returns the
135:06 - results of a link query pertaining to
135:08 - the products currently stored within the
135:11 - user's shopping cart
135:49 - then let's write code for the get item
135:51 - method
135:53 - let's write code that returns the
135:55 - results of a link query which is data
135:58 - pertaining to a particular product
136:00 - currently stored
136:02 - within the relevant user's shopping cart
137:03 - let's add a controller class to the
137:05 - controllers folder
137:26 - let's name this controller class
137:28 - shopping cart controller
137:35 - firstly let's create a constructor that
137:37 - contains two parameters one of type i
137:41 - shopping cart repository and the other
137:43 - of type i product
137:54 - repository let's create two read-only
137:57 - fields
137:58 - to reference the objects that will be
138:00 - injected into our controller class at
138:03 - runtime
138:13 - let's of course not forget to register
138:15 - the i shopping cart repository type for
138:17 - dependency injection
138:44 - so let's implement the code for the get
138:46 - items action method
139:07 - let's use our shopping cart repository
139:09 - object to return the items currently
139:11 - stored within the relevant user's
139:13 - shopping cart
139:16 - if no items are contained within the
139:18 - shopping cart we want code to execute
139:20 - that returns a http response of no
139:24 - content to the calling client
139:26 - this is denoted by a http code status of
139:30 - 204
139:34 - so this means the client http request
139:37 - was successful but no items related to
139:40 - the client's request are present in the
139:42 - system therefore no content can be
139:44 - returned to the calling client
139:47 - so we are returning a collection of type
139:49 - can't item dto to the client from the
139:52 - action method
139:54 - we have just written code that retrieves
139:56 - a collection of objects of type cart
139:58 - item
139:59 - we want to return a collection of
140:01 - objects of type can't item dto to the
140:04 - calling client the cart item dto type
140:07 - contains additional data regarding the
140:10 - relevant product
140:11 - we don't have the additional data at
140:13 - this point so let's use the product
140:16 - repository object
140:17 - to retrieve a collection of objects of
140:20 - type product
140:22 - we can then write code to join our
140:24 - collection of card item objects with the
140:26 - collection of objects of type product
140:28 - using a link query and return an
140:30 - appropriate collection of objects of
140:32 - type can't item dto
140:35 - to the calling client
140:39 - so let's keep this code clean and
140:41 - implement a linq query
140:43 - in an extension method to return the
140:45 - relevant collection of objects of type
140:47 - cart item dto to the get items action
140:50 - method
140:52 - before we do this let's write code to
140:54 - throw an exception if no products exist
140:57 - within the system because if there are
140:58 - no products in the system and the user
141:00 - is attempting to add a product to the
141:02 - user's shopping cart well this won't
141:05 - make any sense
141:07 - so this means an exception has occurred
141:11 - let's write code in a catch block that
141:13 - returns a http status code of 500 to the
141:16 - calling code
141:18 - so if for some reason an exception
141:20 - occurs during the execution of the get
141:22 - items action method we want an internal
141:24 - server error 500 http response to be
141:28 - returned to the client
141:30 - so let's go to the dto conversions class
141:33 - and implement another extension method
141:35 - overload named convert to dto
141:39 - we'll be able to call this extension
141:41 - method overload on an i enumerable
141:43 - collection of type cart item to perform
141:46 - the relevant conversion functionality
142:55 - let's go to our get items action method
142:58 - and call the extension method we have
142:59 - just created
143:01 - to return the appropriate collection of
143:03 - objects of type cat item dto
143:14 - we can then write code to return this
143:16 - collection to the calling client with a
143:18 - http response status code of 200 okay
144:07 - let's implement the code for the get
144:08 - item action method
144:47 - you can see here
144:48 - that the code is very similar to the get
144:50 - items action method but we of course
144:54 - are only returning one item of type cart
144:56 - item dto to the calling client instead
144:59 - of a collection of objects of type cart
145:01 - item dto
145:04 - so let's write code
145:06 - for converting an object of type card
145:08 - item to an object of type cart item dto
145:12 - to do this let's go to the dto
145:14 - conversion class and implement the code
145:17 - for the appropriate extension method
145:19 - overload
145:59 - we can then call the relevant convert to
146:02 - dto extension method on the relevant
146:04 - object of type cart item to perform the
146:07 - appropriate conversion functionality
146:14 - let's write the functionality for
146:15 - handling a post request
146:18 - from the client whereby a user is
146:20 - attempting to add
146:21 - a product to the user's shopping cart
146:25 - so let's write code to call the add item
146:27 - method on the shopping cart repository
146:30 - object that will be injected into our
146:32 - controller class at runtime
147:17 - we want to return the newly added item
147:20 - of type cart item dto to the calling
147:23 - client
147:24 - so we can call the same conversion code
147:27 - that we implemented for the get item
147:28 - method for this purpose
147:31 - it is important to note
147:33 - that it is standard practice for a post
147:35 - action method to return the location of
147:38 - the resource where the newly added item
147:40 - can be found
147:42 - this location will be returned in the
147:44 - header of the http response returned
147:47 - from this method
147:48 - we can use the create at action method
147:50 - to ensure that we are adhering to this
147:53 - standard practice
147:55 - so the relevant resource can be found at
147:57 - the uri universal resource identifier
148:01 - pertaining to the get item action method
148:05 - and we are including the id
148:07 - of the newly added resource here
148:14 - and for the final argument we are
148:17 - including the newly added object which
148:20 - we have now converted to type cart item
148:22 - dto
148:37 - if you'd like to read more about the
148:39 - create at action method i've included an
148:41 - appropriate link below in the
148:42 - description
148:45 - and we of course need to decorate this
148:47 - action method with the http post
148:49 - attribute
149:28 - let's run the shoponline.api project
149:30 - through visual studio
149:43 - and you can see
149:45 - the new action methods
149:47 - and relevant dtos are present on the
149:50 - swagger ui web page
149:52 - great
149:53 - let's implement the relevant code for
149:55 - our blazer component so let's go to the
149:58 - shoponline.web project
150:00 - let's create a new service class where
150:02 - we'll implement code that interacts
150:05 - with the action methods
150:07 - that we have created within our shopping
150:10 - cart controller class in our web api
150:12 - project
150:13 - firstly let's create the appropriate
150:15 - interface in the contracts folder for
150:18 - the relevant service class
150:20 - let's name this interface i shopping
150:22 - cart service
150:39 - let's create a method definition for the
150:40 - get items method
150:42 - and the add items method
151:06 - let's create a class named shopping cart
151:09 - service
151:25 - let's generate the code stubs for the
151:26 - methods defined within the i shopping
151:29 - cart service interface
151:40 - let's create a constructor for the
151:42 - shopping cart service class
151:48 - let's include a parameter of type http
151:51 - client as a parameter within our
151:52 - constructor
151:54 - this parameter indicates to.net that we
151:57 - want an object of type http client
152:00 - injected into this class at runtime
152:03 - let's implement the code for the add
152:05 - item method
152:24 - so basically this code calls the post
152:27 - action method that we implemented in the
152:29 - shopping cart controller class
152:32 - if the response http status code
152:36 - is within the success range let's check
152:38 - to see if any content was returned if no
152:42 - content was returned let's return the
152:44 - default c-sharp value for the cart item
152:46 - dto type to the calling code
152:50 - which will be null
152:53 - if content was returned
152:56 - from the server
152:58 - let's return the object representing the
153:00 - newly created shopping cart item to the
153:03 - calling code this will of course be an
153:05 - object of type can't item dto
153:27 - let's include the relevant exception
153:28 - handling code
153:51 - let's implement code for the get items
153:53 - method
154:09 - so i'm deliberately including an
154:11 - incorrect uri universal resource
154:13 - identifier
154:15 - reference here
154:16 - so that this will force an exception
154:18 - when we run the code we'll fix this
154:21 - a little bit later after we have run the
154:23 - code that tests how an application
154:26 - handles the relevant exception
154:29 - this code simply places a http get
154:32 - request to the get items action method
154:34 - and if content is returned returns the
154:37 - relevant content to the relevant razer
154:39 - component i.e the calling code
155:41 - let's go to the product details base
155:43 - class and implement a button click event
155:45 - handler method for the add to cart
155:48 - button
155:49 - let's name this click event handler
155:51 - method add to cart underscore click
156:15 - let's make sure that we have registered
156:17 - the i shopping cart service type for
156:20 - dependency injection
156:46 - let's implement code that ensures that
156:48 - an object of type i shopping cart
156:50 - service is injected into the product
156:52 - details base class at runtime
157:33 - then our code within the add to cart
157:35 - underscore click event handler method
157:38 - calls the add item method
157:40 - on the injected shopping cart service
157:43 - object to add a product chosen by the
157:45 - user to the user's shopping cart
157:55 - let's go to the product details.razer
157:57 - file and implement the code that calls
157:59 - the add to cart underscore click event
158:02 - handler method
158:25 - so we have started with the
158:26 - implementation of the shopping cart
158:28 - functionality we have not implemented
158:30 - user registration or login functionality
158:33 - ie membership functionality in this
158:36 - application
158:38 - we could implement codes to bring down
158:39 - user related information from the server
158:42 - when the user first logs onto the system
158:45 - the information could include the user's
158:47 - user id
158:48 - and the user's cart id
158:51 - so because we haven't implemented login
158:53 - functionality let's temporarily hard
158:56 - code the user's cart id and user id in a
159:00 - class within the project that contains
159:02 - our blazer functionality so that we can
159:04 - progress with the implementation of the
159:07 - shopping cart functionality
159:09 - so in the first video in this series we
159:11 - seeded the data with data for two users
159:15 - so let's say that we are going to run
159:17 - the code from the perspective of the
159:19 - user that has a user id of one and a
159:22 - cart id of one
159:34 - so we can now pass in the hard-coded
159:36 - cart id value here
159:38 - along with the relevant product id
159:44 - and a quantity of one when a user adds a
159:46 - product to the user's shopping cart by
159:49 - default one instance of that product is
159:52 - added to the user's shopping cart
159:55 - let's strategically add some breakpoints
159:57 - in the blazer project and the web api
160:00 - project
160:17 - and run the code
160:29 - and let's invoke the functionality for
160:30 - the workflow that we have just
160:32 - implemented incurred by clicking a
160:35 - product that we wish to add to the
160:37 - shopping cart
160:39 - and then let's click the add to cart
160:42 - button
161:38 - great
161:39 - if we look at the cart items database
161:41 - table
161:50 - we can see an item has been
161:52 - appropriately inserted into the relevant
161:55 - table
161:56 - let's test this again
163:10 - great
163:18 - let's create a razor component that will
163:20 - be responsible for rendering a
163:21 - collection of products data pertaining
163:23 - to products that have been added to the
163:26 - user's shopping cart to the screen
163:29 - so let's add a razor component named
163:31 - shoppingcart.razer
163:46 - let's add a base class for the shopping
163:47 - cart razor component let's name this
163:49 - class shopping cart base
164:01 - let's implement code for the shopping
164:03 - cart base class
164:05 - so our shopping cart base class must
164:08 - inherit from the component base class
164:10 - because we want this class to be the
164:12 - base class for the shopping cart raiser
164:14 - component
164:16 - let's write code for injecting an object
164:18 - of type i shopping cart service into our
164:22 - class at runtime
164:44 - let's include a property for referencing
164:46 - a collection of objects of type cart
164:49 - item dto
164:50 - this property will be used within the
164:52 - shoppingcart.razer file
164:54 - for code that displays the relevant data
164:56 - to the screen
164:58 - let's create the code to override the
165:00 - uninitialized async method where we'll
165:03 - implement code for assigning the
165:05 - relevant collection of items returned
165:07 - from the server to the shopping cart
165:09 - items property when the razer component
165:12 - is first rendered
166:00 - great
166:02 - let's implement the code for the
166:03 - shoppingcart.razer file
166:09 - let's include the page directive at the
166:11 - top to declare the root template for our
166:14 - shopping cart razor component
166:25 - let's use the inherits directive to
166:27 - ensure that we are using the shopping
166:29 - cart base class as the razer components
166:32 - base class
166:34 - so while the shopping cart items
166:36 - property is null
166:37 - and the error message property is null
166:40 - we want a spinner loading indicator to
166:42 - be displayed to the user
166:46 - if the error message property is not
166:47 - null we want the relevant error message
166:50 - to be displayed to the user
167:01 - else
167:03 - we want code to run that displays in an
167:05 - aesthetically pleasing style the data
167:08 - representing a collection of products
167:10 - that have been added to the user's
167:12 - shopping cart
167:14 - we are using bootstrap 5 classes for
167:17 - styling the html elements
167:19 - in our razer file
169:12 - now that we have written the code for
169:13 - displaying a collection of products data
169:16 - for products added to the user's
169:18 - shopping cart let's write code that
169:20 - navigates the user
169:22 - to this screen
169:24 - after the user clicks the add to cart
169:27 - button
169:28 - so let's go to the add to cart
169:30 - underscore click event handler method
169:32 - within the product details base class
169:34 - and implement the relevant code
169:37 - so we can use an object of type
169:39 - navigation manager to navigate the user
169:42 - to the relevant screen
169:44 - so let's write code to ensure
169:46 - that an object of type navigation
169:48 - manager is injected into our razer
169:50 - component at runtime
169:52 - let's then invoke the navigate to method
169:55 - on the navigation manager object to
169:58 - navigate the user to the shopping cart
170:00 - screen
170:20 - let's run the code
170:54 - and an error message is displayed to us
170:57 - this is because we are forcing a 404 not
171:00 - found error to occur
171:01 - at the moment
171:03 - we have included an incorrect path to
171:06 - the end point that returns the
171:08 - collection of card item dto objects
171:11 - within the get items method of the
171:12 - shopping cart service class
171:15 - we need to appropriately include a
171:17 - reference to the shopping cart
171:19 - controller name within this uri
171:21 - reference so let's correct this uri
171:25 - universal resource identifier
171:27 - by appropriately including the relevant
171:29 - controller name here
172:07 - great
172:43 - this is the sixth part in a video series
172:46 - dedicated to building a shopping cart
172:47 - application
172:48 - using
172:50 - blazerwebassemblyon.net 6.
172:52 - so we have created three workflows let's
172:55 - recap the first workflow involves
172:58 - retrieving products data from the
173:00 - database and displaying the products
173:02 - data to the user in an aesthetically
173:04 - pleasing style
173:06 - the second workflow involves retrieving
173:08 - details for an individual product and
173:11 - displaying the relevant details in an
173:14 - aesthetically pleasing style to the user
173:17 - the third workflow involves the user
173:19 - adding a product to the user's shopping
173:21 - cart and the user being navigated to a
173:23 - screen that displays a list of products
173:26 - contained within the user's shopping
173:28 - cart
173:39 - in this video we'll create the workflow
173:42 - that involves a user removing a product
173:44 - from the user's shopping cart
173:55 - let's get started
173:58 - let's start by implementing the server
174:00 - side code
174:01 - let's go to our shoponline.api project
174:04 - and open the shopping cart repository.cs
174:08 - file
174:09 - let's implement the code logic for the
174:11 - delete item method
174:23 - so we can use the id value that will be
174:26 - passed into this method to find the
174:28 - entity that we wish to delete from the
174:31 - cart items database table
174:34 - we are using the find async method to
174:36 - find the relevant entity using the
174:39 - primary key field
174:40 - which is the id field if we find the
174:43 - relevant entity if the item returned
174:46 - from the find async method is not null
174:49 - we can use the remove method to remove
174:52 - the relevant entity from the cart items
174:54 - database table
174:57 - then we mustn't forget to call the save
175:00 - changes async method to commit the
175:02 - relevant change to our database
175:19 - in order to make this delete
175:21 - functionality available to calling
175:22 - client code
175:24 - let's create an appropriate endpoint
175:26 - within our web api component
175:29 - so let's go to the shopping cart
175:31 - controller class
175:32 - and create an appropriate action method
175:35 - that will call the relevant delete item
175:37 - method that we have just implemented
175:40 - in the shopping cart repository class
176:04 - let's decorate our delete item action
176:06 - method with an attribute that declares
176:09 - that this action method corresponds to
176:11 - the http delete verb
176:15 - so far in the development of our
176:17 - application we have created endpoints
176:20 - that correspond to both the get and post
176:23 - http verbs
176:26 - we are about to implement the logic for
176:29 - an endpoint that corresponds to the
176:31 - delete http verb
176:34 - let's declare the relevant root template
176:36 - information for our action method by
176:39 - passing an appropriate string argument
176:41 - to the http delete attribute
176:46 - this information includes a definition
176:48 - for the id that needs to be part of the
176:50 - uri universal resource identifier
176:53 - pertaining to the entity that a client
176:56 - wishes to delete
176:58 - so we are essentially enabling a calling
177:01 - client to delete a specific resource
177:03 - from the system
177:05 - let's create a try catch block a simple
177:08 - way to create the relevant code for this
177:10 - is to type try followed by pressing the
177:13 - tab key twice
177:15 - let's call the delete item method on the
177:18 - shopping cart repository object
177:20 - that will be injected into the
177:21 - constructor of this controller class at
177:24 - runtime
177:25 - if the entity that the client wishes to
177:27 - delete
177:28 - cannot be found
177:30 - we want code to execute that returns a
177:32 - http response code of not found 404
177:36 - to the client
177:39 - the information that we want transferred
177:41 - across the network for the relevant
177:43 - entity that the client wishes to delete
177:46 - is of type can't item dto
177:49 - and not the type cart item that is
177:51 - returned from the delete item method
177:54 - called on the shopping cart repository
177:56 - object
177:57 - in the previous part of this video
177:59 - series part 5 we implemented an
178:02 - extension method overload named convert
178:05 - to dto within the dto conversions class
178:08 - this extension method can be called on
178:11 - any object of type cart item
178:14 - before we appropriately call the convert
178:16 - to dto extension method
178:18 - we must retrieve the relevant product
178:20 - entity from the database so let's write
178:22 - the code to achieve this
178:25 - then let's call the convert to dto
178:27 - method on the object of type cart item
178:30 - returned from the shopping cart
178:32 - repository classes delete item method to
178:35 - convert the relevant object of type cart
178:37 - item to an object of type cart item dto
178:41 - then let's write code to return a http
178:44 - response code of ok200
178:47 - to the client along with the relevant
178:49 - object of type cart item dto
178:54 - let's complete this method by writing
178:57 - code that executes
178:59 - if for some reason an exception is
179:01 - thrown during the execution of the code
179:04 - logic within the delete item action
179:06 - method
179:21 - let's go to our blazer component so
179:24 - let's go to
179:25 - the shoponline.web project
179:28 - let's add an appropriate new method
179:30 - definition to the i shopping cart
179:32 - service interface named delete item
179:45 - let's open the shopping cart service
179:47 - class and implement the code logic for
179:49 - the delete item method
180:38 - if the http response code returned from
180:42 - the server
180:43 - falls within the success range
180:46 - we want code to execute that returns an
180:49 - object of type can't item dto to the
180:51 - calling code
180:58 - if the call to the server is not
181:00 - successful we want null to be returned
181:03 - to the calling code
181:20 - let's open the shopping cart base class
181:23 - within the pages folder
181:26 - let's implement code for a method that
181:28 - handles a button click event
181:30 - so this method will be called when a
181:32 - user clicks a delete button
181:34 - that we'll create in a bit in the
181:36 - shoppingcart.razer file
181:51 - let's appropriately call the delete item
181:53 - method on the shopping cart service
181:55 - object
181:56 - that will be injected into our razor
181:58 - component at runtime
182:01 - so this code will call the appropriate
182:03 - action method on the server side
182:05 - that will delete the relevant entity
182:08 - cart item from our database
182:11 - so we want the results of this deletion
182:13 - operation to be reflected on the user
182:15 - interface
182:17 - which means we need the shopping cart
182:19 - razor component to re-render once the
182:22 - deletion operation has completed
182:24 - successfully
182:27 - we could call the appropriate get items
182:30 - method and retrieve all the relevant
182:32 - shopping cart items that are currently
182:34 - saved to our database for the relevant
182:37 - user
182:38 - and assign the results to the shopping
182:40 - cart items property
182:43 - and the result of the deletion operation
182:45 - would then appropriately be reflected on
182:48 - the ui
182:49 - however
182:50 - we can implement code for a solution
182:53 - that will be more performant for this
182:55 - purpose
182:56 - than the solution that i've just
182:58 - expressed i.e that involves an
183:00 - additional call to the server-side code
183:04 - we can reflect the results of a deletion
183:06 - operation on the ui
183:08 - by simply deleting the relevant cart
183:10 - item object from the client side
183:13 - collection of card items
183:15 - referenced by our shopping cart items
183:17 - property
183:21 - by deleting the relevant item from the
183:23 - client side collection we are avoiding a
183:25 - trip as it were to the server side
183:28 - this could result in a significant
183:31 - performance benefit
183:33 - so let's create a private method
183:35 - responsible for removing the relevant
183:37 - item from the client side shopping cart
183:40 - items collection
183:41 - we first need a variable that references
183:44 - the object within the shopping cart
183:46 - items collection that we wish to delete
183:49 - so let's create another private method
183:52 - that contains code for returning a
183:54 - specific object within the shopping cart
183:56 - items collection
184:16 - let's then call our new private method
184:20 - to return the object that we wish to
184:22 - delete from the shopping cart items
184:24 - collection to our remove card item
184:27 - method
184:29 - we can then implement code to delete the
184:31 - relevant item from the relevant
184:33 - client-side shopping cart items
184:35 - collection
184:36 - but there is a problem with this at the
184:38 - moment
184:39 - our client site collection stored within
184:42 - the shopping cart items property is
184:44 - currently of type i enumerable
184:47 - the i enumerable type is fine for when
184:50 - we need to traverse through the items in
184:52 - the relevant collection
184:54 - but we don't currently have an easy way
184:56 - available to us to remove an item from
184:58 - the relevant client-side collection
185:02 - one solution to this problem is that we
185:05 - can change the type of our client side
185:07 - collection to type list
185:14 - we must also appropriately change the
185:16 - return type of the delete item method
185:19 - definition in the i shopping cart
185:21 - service interface and of course we must
185:23 - also appropriately change the return
185:26 - type
185:27 - for the implementation of this method
185:29 - in the shopping cart service class
186:38 - let's go back to the shopping cart base
186:40 - class
186:41 - and use the remove method
186:43 - on the shopping cart items collection
186:45 - which is now of type list to remove the
186:48 - relevant item from the relevant client
186:50 - side collection
187:15 - let's appropriately call our remove cart
187:17 - item method
187:19 - from within the delete cart item
187:20 - underscore click event handler method
187:29 - let's create the delete button within
187:31 - the shoppingcart.razer file
187:52 - let's use blazers at on click syntax to
187:55 - ensure that our delete can't item
187:57 - underscore click
187:59 - functionality is triggered when the user
188:01 - clicks our new button
188:23 - let's run the code and test our method
189:42 - great
189:48 - okay so i don't like this empty screen
189:50 - displayed to the user here
189:52 - when the user no longer has any cart
189:54 - items saved to the user's shopping cart
189:59 - so let's ensure that status information
190:01 - is outputted to the user
190:04 - for the case where the user's shopping
190:05 - cart is empty
190:07 - so we can do this by using the count
190:09 - method
190:10 - so if the count method returns a value
190:12 - greater than zero we can output the data
190:15 - contained within the shopping cart items
190:18 - property as well as the relevant
190:19 - shopping cart summary information
190:44 - else let's output a basic message to the
190:46 - user informing the user that the user's
190:49 - shopping cart is empty
191:04 - let's run the code
191:27 - great
191:50 - so i think rather than display the text
191:52 - remove on the relevant button
191:55 - i think the standard trash icon would
191:57 - look better
191:59 - let's use font awesome for this purpose
192:01 - i'm going to use an appropriate cdn
192:04 - cloud delivery network link to reference
192:07 - the relevant font awesome css file
192:18 - so if we go to this website we can copy
192:21 - the relevant link here
192:23 - and we can then paste it into our
192:25 - index.html file in order to include font
192:29 - awesome icons within our application
192:55 - we are now able to reference the font
192:57 - awesome trash icon like this to display
192:59 - the trash icon on our delete button
193:41 - excellent
193:43 - i hope you've enjoyed this video i look
193:45 - forward to presenting the next video in
193:46 - this series
193:48 - where we'll continue to develop our
193:49 - shopping cart application we are going
193:52 - to implement the update quantity
193:54 - functionality in the next video
194:05 - this is the seventh part of a video
194:07 - series dedicated to building a shopping
194:09 - cart application
194:11 - using
194:12 - blazerwebassemblyon.net 6.
194:18 - so in the previous part of this series
194:21 - we created functionality whereby a user
194:23 - can delete an item from the user's
194:26 - shopping cart
194:35 - in this video we are going to create the
194:37 - functionality whereby a user is able to
194:40 - update the quantity
194:42 - of a particular product that has been
194:44 - placed within the user's shopping cart
194:48 - a notable feature that we'll add
194:51 - is the showing and hiding of the update
194:54 - qty button so we only want the update
194:57 - qty button to appear when the user
195:00 - changes the appropriate value in the
195:03 - field denoting the quantity of a
195:05 - particular item in the user's shopping
195:07 - cart
195:10 - when the relevant field is changed the
195:12 - relevant update qty button appears once
195:15 - the user has clicked the update qty
195:17 - button to update the quantity of a
195:19 - particular item in the user's shopping
195:22 - cart we want the update qty button to
195:24 - disappear
195:26 - to achieve the appropriate showing and
195:27 - hiding of the update qty button we are
195:30 - going to invoke a javascript method
195:34 - this brings us to an important question
195:36 - how do we integrate javascript into our
195:39 - blazer webassembly component
195:42 - in this video we are going to look at
195:44 - how we can use blaze's javascript
195:46 - interoperability feature to interact
195:48 - with javascript code from within our
195:51 - blazer webassembly component
195:53 - we'll implement this functionality
195:55 - toward the end of the video so please
195:57 - stick around to the end to learn about
195:58 - javascript interoperability with blazer
196:02 - to start with let's create the
196:03 - server-side code for the update qty
196:06 - functionality so let's get started let's
196:09 - go to the shoponline.api project
196:12 - let's open the shopping cart repository
196:14 - class
196:37 - let's implement the code logic for the
196:39 - update qty method
196:42 - first thing to do is reference the item
196:44 - that we wish to update
196:50 - so if we are able to find the relevant
196:52 - item within our database and therefore
196:54 - the item variable will not be null
196:57 - we can then update the qty field with
197:00 - the value passed in from the client
197:07 - and to commit the change to the database
197:10 - we must of course call the save changes
197:12 - async method
197:14 - let's write code to return null to the
197:16 - calling client for when the item is not
197:19 - found within the database
197:21 - let's expose the update quantity
197:24 - functionality to our calling client
197:26 - through an action method
197:28 - let's open the shopping cart controller
197:30 - class
197:52 - let's create an action method named
197:54 - update qty
198:19 - let's appropriately call the update qty
198:22 - method on the shopping cart repository
198:24 - object to update the relevant resource
198:26 - with the qty value passed into our
198:29 - action method by the client
198:53 - let's use our convert to dto method to
198:56 - appropriately convert the cart item
198:58 - object into an object of type cart item
199:02 - dto we can then write code to return the
199:05 - relevant object of type cart item dto to
199:08 - the calling client
199:10 - along with the http code status of 200
199:13 - ok
199:15 - let's include the appropriate exception
199:17 - handling code
199:18 - so we have so far created action methods
199:21 - that correspond to the http get verb the
199:24 - http post verb and the http delete verb
199:28 - the other two most common http verbs
199:32 - are the http put verb and the http patch
199:36 - verb the http put verb and the http
199:40 - patch verb
199:42 - are both associated with the performance
199:45 - of resource updates
199:47 - the difference between these two http
199:50 - verbs is that the http put verb is
199:54 - associated with action methods that
199:55 - modify a resource where the client sends
199:58 - data that updates the entire resource
200:01 - the http patch verb however is
200:04 - associated with action methods that
200:07 - partially update the respective resource
200:11 - so we want our update qty method
200:14 - to update only the qty field for a cart
200:18 - item resource
200:19 - so this means it is appropriate to
200:21 - associate our update qty action method
200:24 - with the http patch verb
200:28 - we can write declarative code to
200:30 - indicate that this action method is
200:32 - associated with a http patch verb to do
200:36 - this we can appropriately decorate the
200:38 - update qty action method with the http
200:42 - patch attribute like this
200:45 - note that we are passing in data to the
200:47 - http patch attribute that provides
200:50 - necessary route template information
200:52 - this indicates that the uri for the
200:55 - relevant endpoint must appropriately
200:57 - contain the id of the resource that the
201:00 - client wishes to modify
201:02 - right let's write the appropriate code
201:05 - for the blazer component
201:07 - so let's go to the shoponline.web
201:09 - project
201:10 - let's open the i shopping cart service
201:12 - class
201:44 - let's open the shopping cart service
201:46 - class to implement the code logic for
201:48 - the update qty method
202:45 - let's first serialize the dto that we
202:48 - wish to pass to the server into json
202:51 - format
202:58 - let's create an object of type string
203:00 - content so that we can appropriately
203:03 - pass the relevant data in the
203:05 - appropriate format to the server
203:39 - let's call the patch async method on our
203:41 - http client object and pass in the
203:44 - appropriate uri
203:54 - as well as the relevant data
203:57 - to the patch async method
204:05 - if the http response status code falls
204:08 - within the success range let's include
204:11 - code that returns the appropriate data
204:13 - returned from the server to the calling
204:15 - code
204:36 - let's go to the shopping cart base class
204:51 - let's create a method that will handle
204:53 - the update qty button click event so the
204:56 - calling code will pass in the id of the
204:58 - shopping cart item that the user wishes
205:00 - to update as well as the relevant
205:02 - quantity value
205:04 - if the quantity value is greater than
205:06 - zero meaning that the quantity or qty
205:09 - field value is valid
205:12 - we can appropriately call the update qty
205:14 - method on the shopping cart service
205:16 - object
205:18 - to call the relevant server side code in
205:20 - order to update the database
205:22 - appropriately
205:35 - else if the calling code passes in an
205:37 - invalid quantity let's set the quantity
205:39 - field
205:40 - for the relevant cart item to one
206:01 - let's go to the shopping cart dot raise
206:03 - a file
206:22 - let's add an input field that will allow
206:25 - a user to modify the quantity of a
206:27 - particular item in the user's shopping
206:29 - cart
206:30 - note that we are using blazers at bind
206:33 - syntax to bind each quantity input field
206:36 - to the corresponding property of the
206:37 - appropriate object of type cart item dto
206:41 - stored within the shopping cart items
206:43 - collection
206:44 - this means for example that if the qty
206:46 - property for a cart item dto object
206:49 - stored within the shopping cart items
206:51 - collection is modified that this
206:53 - modification will immediately be
206:54 - reflected on the ui in the appropriate
206:57 - quantity input field
207:28 - let's create the update qty button
207:31 - that a user can click in order to update
207:33 - the quantity of a particular item
207:40 - let's use blazes at onclick syntax to
207:43 - call the appropriate event handler
207:45 - method that we have created within the
207:47 - shopping cart base class
207:57 - let's stand by our convention to use the
208:00 - underscore click suffix
208:02 - for these type of event handler methods
208:06 - so let's change the name of the relevant
208:08 - method
208:09 - from update qty cart item to update qty
208:12 - cart item underscore click
208:32 - then we can write code to pass in the
208:34 - appropriate values to our update qty
208:36 - cart item underscore click method
209:22 - let's test the code
210:31 - great
210:33 - so we haven't yet written code so that
210:36 - the total quantity and total price is
210:39 - reflected within the cart item summary
210:41 - information displayed to the user on the
210:43 - right-hand side of the user's screen
210:47 - let's implement the code for this
210:49 - so firstly let's include two properties
210:52 - within our shopping cart base class
210:55 - let's include a property to store the
210:57 - total price of the items within the
210:59 - user's shopping cart
211:07 - and the total quantity of the items
211:09 - stored within the user's shopping cart
211:21 - let's create a private method named set
211:24 - total price
211:26 - which is responsible for calculating the
211:28 - total price of all the items stored
211:31 - within the user's shopping cart and
211:32 - assigning the result of this calculation
211:35 - to the relevant property
211:40 - let's create a private method named set
211:42 - total quantity which is responsible for
211:45 - calculating the total quantity of items
211:47 - stored within the user's shopping cart
211:49 - and assigning the result of this
211:51 - calculation to the relevant property
211:57 - let's create a private method named
211:58 - calculate cart item summary totals let's
212:01 - call the set total price method as well
212:04 - as the set total quantity method from
212:06 - within the calculate cart summary totals
212:08 - method
212:10 - we want the total price of all the items
212:13 - stored within the user's shopping cart
212:15 - as well as the total quantity of items
212:17 - stored within the user's shopping cart
212:19 - to be reflected on the ui whenever a
212:21 - user action results in the state of the
212:23 - shopping cart changing
212:25 - so let's appropriately call our
212:27 - calculate card summary totals method
212:30 - from within the update qty cart item
212:33 - underscore click event handler method
212:40 - the delete cart item underscore click
212:42 - event handler method
212:51 - and the on initialized async method that
212:54 - is called when the razer component is
212:56 - rendered
212:59 - let's go to the shoppingcart.racer file
213:01 - and implement the code that will result
213:04 - in the appropriate summary totals being
213:06 - reflected appropriately on the ui
213:21 - before we run the code we must also
213:23 - include a method in the shopping cart
213:25 - base class
213:26 - that updates the total price property on
213:29 - the relevant object of type cart item
213:32 - dto when the relevant quantity property
213:34 - is updated for a particular cart item by
213:37 - the user
213:40 - so basically if for example a cart item
213:43 - has a price of 50 dollars and the user
213:45 - updates its quantity property
213:48 - from one to two
213:50 - we need to change the cart items total
213:52 - price
213:52 - from fifty dollars to a hundred dollars
213:56 - to calculate the total price
213:58 - is simply a mathematical operation
214:01 - of price multiplied by quantity
214:04 - so let's create a method named update
214:07 - item total price
214:09 - let's call our get card item private
214:11 - method
214:12 - to reference the relevant cart item
214:15 - then we can update its total price
214:17 - property with the result of the
214:19 - calculation that we have just discussed
214:27 - we want our update item total price
214:29 - method invoked
214:31 - every time the quantity for an item
214:34 - within the user's shopping cart changes
214:37 - so let's implement the code for this
214:38 - appropriately
214:50 - great
214:58 - let's run the code
216:05 - excellent
216:06 - so let's look at javascript
216:08 - interoperability in a blazer webassembly
216:11 - component
216:16 - let's implement the code so that our
216:18 - update qty button is only shown
216:22 - to the user when the state of the
216:23 - relevant input field changes
216:26 - so let's first create a css file for our
216:29 - shopping cart razor component
216:31 - so let's create a css file named
216:34 - shoppingcart.razer.css
216:37 - as discussed when we create a css file
216:40 - that only applies to a specific razor
216:42 - component we must adhere to a specific
216:45 - naming convention
216:47 - let's create a css class named update
216:50 - dash
216:51 - qty that contains the code display colon
216:55 - none
216:57 - so we can apply this class to the update
217:00 - qty button like this to ensure
217:03 - that when the relevant razer component
217:05 - first loads that the update qty button
217:08 - is not displayed to the user
217:11 - so the next step is to create a
217:14 - javascript method that is invoked when
217:17 - the quantity input field is changed by
217:19 - the user
217:21 - this javascript method will be
217:23 - responsible for appropriately showing
217:25 - and hiding the relevant update qty
217:28 - button
217:29 - let's create a folder within the www
217:31 - root folder of our project named js
217:37 - let's add a javascript file named
217:40 - shoppingcartfunctions.js to the js
217:42 - folder
218:02 - let's create a javascript function named
218:05 - make update qty button visible
218:08 - this function accepts two arguments
218:11 - one denotes the id of the relevant cart
218:14 - item and the other denotes a boolean
218:16 - value
218:21 - so in order to be able to identify the
218:24 - relevant button within our javascript
218:26 - code we can apply a data attribute to
218:29 - the relevant html element
218:32 - so let's go to our shoppingcart.razer
218:35 - file and include a data attribute named
218:38 - data dash item id and set its value to
218:42 - the id of the relevant cart item
218:45 - the code for the javascript function is
218:47 - fairly basic
218:49 - let's use our data attribute to
218:51 - reference the appropriate button element
218:54 - we are using the data dash item id
218:57 - data attribute to identify a specific
219:00 - update qty button
219:10 - if the boolean value is true
219:12 - we want code to execute within our
219:14 - javascript function to make the relevant
219:16 - button visible
219:18 - if the boolean value is false we want
219:21 - our function to make the relevant button
219:23 - invisible
219:49 - let's appropriately reference our new
219:51 - javascript file from within the
219:54 - index.html file
220:17 - then we need to write code to detect
220:20 - when a quantity input field or qty input
220:23 - field is changed by the user
220:26 - we can use blaze's at on input syntax
220:29 - for this purpose
220:31 - one might think that the at on change
220:34 - syntax
220:35 - should be used for this purpose but a
220:37 - method executed in response to the at
220:40 - once syntax
220:42 - will only be invoked when the relevant
220:44 - input field loses focus
220:47 - we want our method to be invoked
220:49 - immediately when the relevant input
220:51 - field's value changes
220:54 - so let's implement a method within the
220:56 - shoppingcartbase.cs class that will be
220:59 - invoked when a quantity input field is
221:02 - changed
221:03 - so we want our make update qty button
221:06 - visible javascript function to be
221:08 - invoked when a quantity input field is
221:10 - changed
221:12 - so how can we call a javascript function
221:15 - from within a razer component
221:17 - the answer to this is that we can use
221:19 - the built-in js runtime type for this
221:21 - purpose so let's create a property of
221:24 - type i js runtime
221:38 - let's decorate this property with the
221:40 - inject attribute so that an appropriate
221:43 - object of type ijs runtime will be
221:46 - injected into our razor component at
221:48 - runtime
221:51 - we can then use the object to
221:52 - appropriately call our make update qty
221:55 - button visible javascript function like
221:58 - this
222:27 - let's go to our shopping cart dot race
222:29 - of file and appropriately call our
222:32 - update qty underscore input method
222:57 - lastly let's write code that calls the
222:59 - relevant javascript function to make the
223:01 - relevant update qty button disappear
223:04 - once the relevant button has been
223:06 - clicked
223:15 - let's run the code
223:45 - excellent
224:05 - this is the eighth part of a video
224:07 - series dedicated to building a shopping
224:09 - cart application using
224:12 - blazerwebassemblyon.net 6.
224:17 - so at this point we have achieved quite
224:19 - a lot
224:20 - we have created the functionality for
224:22 - displaying grouped products to the user
224:25 - we have also created most of the
224:27 - functionality for the shopping cart
224:29 - a user can now add a product to the
224:31 - shopping cart remove a product from the
224:34 - shopping cart and can update the
224:37 - quantity of a product that is contained
224:39 - within the shopping cart
224:42 - so we now need a way for a user to be
224:44 - able to navigate to the shopping cart
224:47 - from anywhere within the application
224:50 - we also want the user to be able to see
224:51 - at a glance
224:53 - how many items are currently contained
224:55 - within the user's shopping cart
224:58 - currently the user is only able to
225:00 - navigate to the shopping cart through
225:02 - our application by adding a product to
225:05 - the shopping cart
225:07 - we want the user to be able to see how
225:08 - many items have been added to the user's
225:11 - shopping cart at a glance no matter
225:13 - where the user is within the application
225:16 - for example the user may be viewing the
225:18 - grouped products displayed to the user
225:21 - when the application is first launched
225:24 - and wishes to know how many items are
225:26 - currently contained within the user's
225:29 - shopping cart
225:31 - we also want the user to be able to
225:34 - navigate to the user's shopping cart
225:37 - through our application from anywhere
225:39 - within the application simply by
225:41 - clicking a button
225:43 - so we want to make this button
225:45 - accessible to the user from anywhere in
225:48 - the application
225:49 - so in this video we'll provide an
225:51 - appropriate solution for this we'll
225:53 - provide a button in the header part of
225:55 - the ui that when clicked will navigate
225:58 - the user to the user's shopping cart
226:01 - the quantity of items stored within the
226:04 - user's shopping cart will be displayed
226:06 - on the text of the relevant button
226:09 - so the quantity value displayed on the
226:11 - relevant button must be kept up to date
226:15 - so we must facilitate the change of the
226:17 - relevant quantity value whenever the
226:20 - number of items within the shopping cart
226:22 - changes
226:23 - the code for the button containing the
226:25 - text representing the number of items in
226:28 - the user's shopping cart will be
226:30 - contained within its own razor component
226:33 - a razor component we'll name cart menu
226:37 - so this means we need to find a way to
226:39 - send data to the cart menu razor
226:42 - component from other relevant razer
226:44 - components like for example the shopping
226:47 - cart razor component whereby code must
226:50 - execute that updates the relevant
226:52 - quantity value
226:53 - when a change to the number of items
226:56 - stored within the user's shopping cart
226:58 - is made
226:59 - in this video we'll see how c-sharp
227:02 - events can be used to facilitate
227:05 - communication of data between the
227:07 - loosely coupled razor components within
227:09 - our application
227:12 - right let's get started
227:15 - let's go to our blazer client component
227:18 - so let's go to the project named
227:19 - shoponline.web
227:21 - let's open the i shopping cart service
227:24 - file
227:27 - let's create a definition for a c-sharp
227:29 - event
227:31 - note that the action type is a delegate
227:34 - that doesn't return a value
227:36 - so any method that the relevant delegate
227:39 - points to will be able to accept the
227:41 - arguments defined
227:43 - within the relevant delegate but the
227:45 - method will not return a value
227:48 - in our case any method pointed to by
227:51 - this delegate will accept one argument
227:53 - of type integer
227:56 - let's create a definition for a method
227:57 - that is responsible for raising the
227:59 - relevant event to subscribed components
228:03 - if what we are doing here is unclear to
228:05 - you don't worry
228:07 - it will become clearer to you as we
228:09 - develop the code in this video
228:11 - okay so let's open the shopping cart
228:13 - service file
228:26 - let's implement the code for the
228:28 - interface items that we have just
228:30 - created
228:56 - let's implement the code for the raise
228:58 - event on shopping cart changed method
229:01 - first we need to check if our event has
229:04 - any subscribers
229:07 - we can do this by evaluating the on
229:09 - shopping cart changed event object
229:12 - so if the on shopping cart changed
229:14 - object is not null this means that the
229:17 - event has subscribers
229:20 - so if the event has subscribers
229:22 - we need to write code that raises the
229:25 - event to those subscribers
229:28 - we can do this by implementing the
229:30 - invoke method on the on shopping cart
229:32 - changed event object
229:34 - then we can send the appropriate integer
229:36 - value to each of our subscribers by
229:39 - passing in the appropriate integer value
229:42 - to the invoke method
229:45 - so in the context of our application an
229:47 - example of a subscriber will be a method
229:50 - within the cart menu razor component
229:53 - that we'll create later in this tutorial
229:56 - when the quantity of the item stored
229:58 - within the user's shopping cart changes
230:00 - the event is raised and a custom method
230:03 - that will be created within the cart
230:05 - menu razor component will be invoked in
230:08 - response to the quantity of items stored
230:10 - within the shopping cart changing
230:13 - basically when the quantity of the
230:15 - shopping cart changes the event is
230:17 - raised and any subscribed methods are
230:19 - called
230:20 - this will be clarified with code that
230:22 - we'll create in a bit
230:25 - so this event being raised will result
230:28 - in the new quantity of items stored
230:30 - within the user's shopping cart
230:33 - being displayed
230:34 - from within the cart menu razor
230:36 - component
230:44 - let's open the products base dot cs file
230:49 - let's write code so that an object of
230:51 - type shopping cart service will be
230:53 - injected into this razor component at
230:56 - runtime
230:57 - so the product razor component is loaded
231:00 - when a user first launches our
231:02 - application we want the user to be able
231:04 - to see how many items are currently
231:07 - stored within the user's shopping cart
231:08 - when the application is first loaded
231:12 - so let's first appropriately call code
231:14 - on the server to retrieve the shopping
231:16 - cart items currently stored within the
231:18 - user's shopping cart
231:20 - i can feel the comments flowing my way
231:22 - already
231:24 - so i think i'll be preemptive and just
231:26 - say that i'm aware that this may not be
231:28 - the most performant way of doing this
231:31 - but i want to focus on events in
231:32 - relation to razer components in this
231:34 - tutorial we will be optimizing the code
231:37 - in later videos
231:39 - for example by including local storage
231:42 - functionality
231:43 - i don't want to make my videos too
231:45 - convoluted
231:46 - so this is why i sometimes first create
231:50 - simplistic code in certain scenarios so
231:53 - that momentum is gained in the
231:54 - development of our application
231:57 - and then as i said we can always
231:59 - optimize the code in later tutorials
232:02 - right
232:03 - let's write code to calculate the number
232:05 - of items currently stored within the
232:07 - user's shopping cart
232:13 - we can then use the shopping cart
232:14 - service object to raise the appropriate
232:17 - event
232:18 - which will in effect send the quantity
232:20 - of items stored within the user's
232:22 - shopping cart to any subscribers
232:25 - so this will result
232:27 - in the appropriate quantity value being
232:29 - displayed to the user in the header
232:31 - section of the layout of our application
232:34 - let's open the
232:36 - shoppingcartbase.cs file
232:40 - so we want our event to be raised each
232:42 - time the quantity of items stored within
232:45 - the user's shopping cart changes
232:54 - let's create a private method named cart
232:56 - changed
232:58 - let's rationalize our code a bit
233:00 - so that the card summary totals private
233:02 - method is called whenever this card
233:04 - changed method is called
233:07 - and we want our events to be raised
233:09 - whenever the cart changed method is
233:11 - called
233:12 - we want our cart changed method to be
233:14 - called whenever the state of the user's
233:16 - shopping cart is changed
233:26 - so let's appropriately call our method
233:28 - from within the uninitialized async
233:30 - method
233:36 - the delete card item underscore click
233:38 - event handler method and the update qty
233:42 - cart item underscore click event handler
233:44 - method
233:46 - notice that each time we write code to
233:48 - invoke the cart changed method we are
233:50 - replacing the call to the cart summary
233:53 - totals method with the call to our new
233:56 - cart changed method
233:57 - because the calculate summary totals
233:59 - method is now being called from within
234:02 - the cart changed method
234:05 - so let's create the code for the cart
234:07 - menu razer component
234:09 - this component will be displayed
234:12 - in the header section of our layout for
234:14 - our application
234:16 - so let's create a race component called
234:18 - cartmenu.razer
234:19 - within the shared folder
234:36 - let's write code
234:38 - so that an object of type i shopping
234:40 - card service is injected into our cart
234:42 - menu razor component at runtime
234:52 - let's open the underscore imports.razer
234:55 - file and include a using directive that
234:58 - references the shop online dot web dot
235:01 - services dot contracts name
235:12 - space so we are not using inheritance
235:15 - for this component
235:17 - so we can instead include code logic for
235:19 - this razor component within the add code
235:22 - section of our razer file
235:24 - this is because our cart menu razor
235:26 - component is not likely to contain a lot
235:29 - of code logic so we don't necessarily
235:32 - need to abstract the code logic into a
235:35 - separate base class
235:39 - let's define a variable of type integer
235:42 - named
235:43 - shoppingcartitemcount
235:44 - let's create an override for the razer
235:46 - component's uninitialized method this
235:49 - method will be called when our razor
235:51 - component is first rendered
235:54 - so we want our razor component to
235:55 - subscribe
235:57 - to the event that we created in the
236:00 - shopping cart service class
236:02 - to achieve this we can implement this
236:04 - code
236:06 - this means that every time the relevant
236:08 - event is raised the shopping cart
236:10 - changed method will be run
236:13 - so we haven't yet implemented code for
236:15 - the shopping cart changed method so
236:17 - let's do that
236:24 - so all we are doing is updating our
236:26 - shopping cart item count variable with
236:28 - the quantity value passed into this
236:30 - method from code that executes to raise
236:33 - the relevant event
236:39 - note that we are calling blazers built
236:41 - in state has changed method here
236:45 - this is an explicit way of telling
236:47 - blazer as it were to re-render the
236:49 - relevant razer component
236:55 - so we are explicitly telling blazer to
236:57 - re-render the component after the
236:59 - shopping cart item count variable
237:02 - has been assigned a new value from code
237:05 - that is raising the relevant event
237:10 - the shopping cart item count
237:12 - will be used in the ui user interface
237:15 - code
237:16 - that we are about to create for
237:18 - displaying the new quantity of items
237:21 - stored within the user's shopping cart
237:24 - so let's write the ui code and this must
237:27 - exist outside the at code section so we
237:31 - want a button displayed to the user that
237:33 - displays a value representing an
237:36 - up-to-date count of items currently
237:38 - stored within the user's shopping cart
237:48 - we also want a user to be able to
237:50 - navigate to the user's shopping cart
237:52 - when this button is clicked
238:02 - in order to prevent possible memory
238:04 - leaks
238:05 - we can write code to unsubscribe from
238:08 - the on shopping cart changed event
238:11 - so to do this let's implement the i
238:13 - disposable interface
238:16 - then we can implement code for the
238:18 - dispose method to unsubscribe from the
238:21 - on shopping cart changed event like this
238:26 - so you can see that the plus equals
238:28 - operator is used to subscribe to an
238:31 - event
238:32 - and the minus equals operator is used to
238:35 - unsubscribe from an event
238:39 - let's open the main layout razor
238:41 - component from within the shared folder
238:44 - this component is responsible for
238:46 - displaying the main ui layout of our
238:48 - application
238:51 - we can ensure that our cart menu razor
238:53 - component displays within the header
238:55 - section
238:56 - by including the appropriate tag
238:59 - for our cart menu razer component here
239:08 - so let's run the code
240:01 - excellent
240:02 - so notice that when we are using a
240:04 - mobile view when running the application
240:07 - we are not able to see our header menu
240:09 - item
240:11 - so let's write code to allow for users
240:14 - that are using our application in a
240:16 - mobile view
240:17 - to be able to see the count of items
240:19 - currently stored within the user's
240:21 - shopping cart
240:22 - and also to be able to navigate to the
240:24 - user's shopping cart from anywhere
240:26 - within the application
240:28 - we can do this by adding an appropriate
240:30 - menu item to the application's main menu
240:33 - for when the application is being used
240:36 - using a mobile view
240:38 - so let's open the nav menu.razer file
240:41 - from within the shared directory this
240:44 - file contains the code responsible for
240:46 - creating our application's main menu
240:50 - let's add a new menu item to the main
240:52 - menu like this
241:30 - let's write code so that an object of
241:31 - type i shopping cart service is injected
241:34 - into this razor component at runtime
241:38 - in the add code section let's create a
241:41 - private variable of type integer named
241:44 - shoppingcartitemscount
242:02 - let's implement the code to subscribe to
242:04 - the on shopping cart changed event
242:08 - let's implement the method
242:10 - that we want to executed when the on
242:12 - shopping cart changed event is raised
242:37 - let's go to the appropriate menu item
242:39 - code and include the shopping cart item
242:42 - count variable so that the user is able
242:44 - to see
242:45 - from this menu item
242:48 - how many items are currently stored
242:50 - within the user's shopping cart
242:53 - now we only want this menu item to be
242:55 - shown to users that are using our
242:58 - application using a mobile view
243:01 - so we can ensure this by including the d
243:05 - sm
243:06 - none bootstrap class within the
243:08 - appropriate html element that represents
243:12 - the relevant menu item
243:14 - lastly let's write code so that before
243:17 - this razer component is garbage
243:19 - collected ie before.net frees the memory
243:22 - taken up by this razor component that
243:24 - the relevant method within this razor
243:26 - component is unsubscribed from the on
243:29 - shopping cart changed event
243:45 - let's run the code
244:35 - excellent
244:54 - so we have now completed all the
244:55 - functionality that enables a user to add
244:58 - items to the user's shopping cart as
245:00 - well as remove items from the user's
245:02 - shopping cart a user is also able to
245:05 - update the quantity of products within
245:07 - the user's shopping cart
245:09 - so of course no point leaving the
245:11 - products hanging around in the user's
245:13 - shopping cart the next logical step is
245:16 - for a user to purchase the products in
245:18 - the user's shopping cart
245:21 - so we are going to create a razor
245:23 - component in this part of the course
245:25 - that denotes a checkout facility whereby
245:28 - the user can purchase the products
245:31 - within the user's shopping cart
245:34 - so how do we create a payment facility
245:36 - so that users can purchase the items in
245:39 - the user's shopping cart
245:41 - the answer is we must integrate a
245:43 - payment gateway into our application
245:56 - so if we navigate to this website
245:59 - we can see here some useful information
246:01 - regarding payment gateways
246:04 - what is a payment gateway
246:08 - a payment gateway is a service
246:10 - that authorizes
246:12 - and processes debit slash credit card or
246:16 - paypal payments
246:18 - for online merchants
246:20 - and traditional brick and mortar
246:22 - businesses
246:23 - a payment gateway facilitates these
246:25 - transactions
246:26 - by encrypting sensitive data and
246:30 - transferring it between a payment portal
246:33 - a website or a mobile device
246:36 - and the bank slash front end processor
246:41 - if we scroll further down this page
246:43 - we can see a list of the most popular
246:45 - payment gateway providers
246:48 - you've probably heard of a few of them
246:50 - like for example paypal and stripe
246:53 - paypal stripe square secure pay
246:57 - worldpay
246:58 - authorized.net
247:00 - to checkout.com braintree
247:03 - i have a business account with paypal so
247:06 - i'm most familiar with paypal in this
247:08 - video i'll give you a very basic guide
247:11 - on how you can integrate the paypal
247:13 - payment gateway into your application
247:16 - even though i'm specifically using
247:18 - paypal the same fundamental principles
247:20 - will apply for other payment gateways
247:23 - please see the relevant instructions
247:25 - provided by your preferred payment
247:27 - gateway service provider on how you can
247:30 - integrate your preferred payment gateway
247:32 - into your applications
247:34 - the payment gateway service provider
247:37 - will provide developers with information
247:39 - on how to integrate the relevant payment
247:42 - gateway into your application
247:45 - it's not as difficult as you might think
247:48 - all of the heavy lifting as it were is
247:50 - done through the third party payment
247:52 - gateway
247:55 - so this tutorial is not a definitive or
247:58 - comprehensive guide on how to integrate
248:01 - a payment gateway into your application
248:03 - but it will hopefully give you a very
248:05 - good idea of how to integrate a payment
248:07 - gateway into your applications
248:10 - it all depends on your application's
248:12 - requirement on how you go about
248:14 - implementing relevant payment gateway
248:16 - integration functionality in your
248:18 - applications
248:22 - let me first present a brief disclaimer
248:24 - before we start this tutorial
248:28 - this is not a definitive guide
248:31 - on integrating a payment gateway into
248:32 - your application
248:34 - this is certainly not a final e-commerce
248:37 - solution
248:38 - the purpose of this tutorial
248:41 - serves to give you a basic idea
248:43 - of how you are able to integrate a
248:46 - payment gateway into a blazer
248:48 - webassembly application
248:50 - if you wish to create an application
248:53 - that uses a payment gateway in a live
248:56 - environment you'll need to research
248:58 - relevant information provided by your
249:00 - preferred payment gateway provider in
249:02 - order to gain a thorough understanding
249:05 - of how to create an e-commerce solution
249:08 - using the relevant payment gateway
249:18 - right let's get started
249:20 - let's create a razor component named
249:23 - checkout.razer within the pages folder
249:36 - let's create a c-sharp class named
249:38 - checkoutbase.cs within the pages folder
249:49 - let's write code to ensure that the
249:50 - checkout razer component inherits from
249:53 - the checkout base class
249:57 - as the name of our razer component
249:58 - suggests a user will navigate to this
250:01 - razor component in order to purchase the
250:03 - items within the user's shopping cart
250:06 - paypal makes it easy for us to integrate
250:09 - the payment gateway functionality within
250:11 - our applications by providing us with
250:14 - sample html and javascript code
250:18 - in order to copy the relevant html and
250:20 - javascript code let's navigate to this
250:22 - paypal web page
250:25 - if we scroll further down the page
250:27 - paypal presents us with a few options
250:30 - i'm going to use the first option here
250:33 - let's click the start setup button
250:36 - let's select the variable price list
250:38 - item here
250:45 - let's select the desktop option here
250:51 - then to copy the relevant javascript and
250:53 - html code we can click the copy code
250:56 - button here
250:58 - let's navigate to our index.html page
251:01 - and paste the html and javascript code
251:05 - currently stored within our clipboards
251:07 - here
251:20 - you can see here we have a javascript
251:22 - function named init paypal button
251:26 - this method contains callback methods
251:28 - like for example create order and on
251:31 - approved
251:32 - the create order method is called by
251:34 - paypal when an order is created
251:37 - and the on approved method is called
251:40 - after the relevant order has been
251:42 - approved by paypal
251:44 - note that within the on approved method
251:47 - there is code that logs information
251:50 - about the order which is sent back from
251:52 - paypal after an order has been approved
251:55 - to the browser console window the
251:58 - relevant information is sent back from
251:59 - paypal regarding the relevant order
252:02 - after the order has been approved by
252:03 - paypal
252:05 - so this gives us an idea of how our code
252:07 - integrates with paypal
252:10 - we also have a script tag here that
252:12 - references a script file at a specific
252:15 - paypal location
252:17 - the way in which we are able to link a
252:19 - paypal account to our application is
252:22 - through this client dash id parameter
252:24 - here
252:25 - at the moment we only have a placeholder
252:27 - value for the client dash id parameter
252:31 - i'll demonstrate a bit later
252:33 - how we are able to generate a valid
252:35 - client id value that we can paste over
252:38 - this placeholder value here
252:40 - i'll demonstrate this a bit later
252:43 - we have this html code here that
252:46 - contains various fields and a
252:48 - placeholder for the relevant payment
252:50 - gateway related buttons that the user
252:52 - can use to start the payment process
252:55 - the user will be able to pay using a
252:57 - valid debit or credit card by clicking
253:00 - this button or if the user has a valid
253:03 - paypal account the user can use the
253:05 - user's paypal account by clicking this
253:07 - button
253:10 - for a particular integration requirement
253:13 - we can tailor the sample code to our
253:15 - needs
253:16 - so we are going to simplify the code
253:18 - here and remove code that is superfluous
253:21 - in relation to our particular
253:23 - requirement
253:25 - so let's say
253:27 - that for a particular integration
253:29 - requirement
253:31 - we only need the description field and
253:34 - the amount field
253:36 - so we can delete the javascript code
253:39 - from the init paypal button method here
253:42 - that references the html elements
253:45 - denoting the fields that we don't need
253:50 - we don't need this code here so let's
253:52 - delete it
253:58 - we don't need this code because it is
254:01 - code used for validating user input
254:04 - code within our application will control
254:07 - what is entered into the appropriate
254:09 - fields namely the amount field and the
254:12 - description field
254:13 - therefore we don't need any user
254:15 - validation related code
254:18 - in the on init method
254:20 - there is a lot of code relevant to user
254:22 - validation that we don't need
254:26 - let's delete the honornet method
254:29 - within the onclick method we only need
254:31 - this code here that references the
254:33 - values that will be inserted into the
254:35 - amount and description fields at an
254:37 - appropriate time by certain code within
254:40 - our application so let's copy the
254:42 - relevant code from the onclick method
254:44 - here
254:46 - let's paste it into the create order
254:48 - method here
254:50 - then we can simply delete the onclick
254:52 - method
254:55 - you can see here in the on approved
254:57 - method we have code here that logs order
255:00 - information to the user's browser
255:02 - console window this information is sent
255:05 - back from paypal once a user's order has
255:09 - been approved by paypal and contains
255:11 - details about the user's order we'll
255:14 - examine the order information later when
255:16 - we test our code
255:19 - you can see here that the sample code
255:22 - that we copied from paypal includes a
255:24 - call
255:25 - to the init paypal button javascript
255:27 - method
255:28 - we want to control when the init paypal
255:31 - button method is invoked
255:33 - we'll implement the code to call the
255:35 - init paypal button method
255:38 - using c-sharp code and blaze's
255:40 - javascript interoperability feature from
255:43 - within the checkout razer component in a
255:46 - bit
255:48 - so let's remove the call to the init
255:50 - paypal button from the index.html file
255:57 - let's cut this html code here
256:02 - and paste it into our checkout.razer
256:05 - file
256:11 - this will allow the paypal buttons to be
256:13 - available to the user when the user
256:15 - invokes the checkout raiser component
256:18 - for our particular requirement let's say
256:20 - that all we are interested in is the
256:22 - description field and the amount field
256:26 - so let's remove the html elements that
256:29 - we don't need
256:30 - for the implementation of our
256:32 - integration code with paypal
256:38 - we don't need the html elements
256:40 - that label the relevant fields
256:43 - because we are going to make the amount
256:45 - field and description field hidden text
256:47 - fields
256:49 - we don't want the user to enter any
256:51 - payment information we are going to
256:53 - control the values that are inserted
256:56 - into these fields through c-sharp code
256:59 - that we'll implement in a bit
257:02 - we need this div element here because
257:04 - this tells paypal as it were
257:06 - where we want the relevant paypal
257:08 - gateway related buttons placed within
257:11 - our ui
257:13 - so
257:14 - for our requirement
257:16 - we don't want these fields to be visible
257:18 - to the user
257:19 - so let's make these fields hidden text
257:22 - fields
257:30 - so let's create the code for the
257:32 - checkout base.cs class
257:44 - we are going to want to call
257:46 - the init paypal button javascript method
257:49 - that resides within our index.html file
257:53 - from within the checkoutbase.cs class so
257:56 - we need to write code that ensures that
257:59 - an object of type rjsruntime
258:01 - is injected into our checkoutrazor
258:03 - component at runtime
258:05 - this is so that we can utilize blaze's
258:07 - javascript interoperability feature to
258:10 - call the init paypal button javascript
258:12 - method
258:13 - that we copied from the relevant paypal
258:15 - web page earlier
258:18 - we'll write the code to call this
258:19 - javascript method in a bit
258:22 - we need to reference the collection of
258:24 - shopping cart items
258:25 - so let's create a property of type i
258:28 - enumerable that is strongly typed with
258:30 - the cart item dto type
258:40 - let's create a property named total qty
258:48 - let's create a property named payment
258:50 - description
258:54 - let's create a property named payment
258:57 - amount
258:58 - let's create code to bind the paypal
259:01 - related hidden text fields we have
259:03 - implemented within the checkout.razer
259:05 - file
259:06 - to their counterpart properties by using
259:09 - blazers at bind syntax
259:12 - so this means that every time relevant
259:14 - property values change
259:16 - laser will automatically update their
259:18 - counterpart input fields
259:20 - i.e the input fields that contain the
259:23 - relevant at bind syntax in the
259:26 - checkout.racer file
259:28 - the payment description and payment
259:30 - amount properties will be bound to the
259:32 - input fields implemented within the
259:35 - checkout.racer file
259:37 - so this is one of the aspects involved
259:39 - in integrating our application with
259:41 - paypal
259:43 - we can communicate the total payment
259:45 - amount to paypal through the payment
259:48 - amount property and we can communicate
259:51 - whatever payment description we want by
259:54 - updating the payment description
259:56 - property
259:57 - the javascript within the init paypal
260:00 - button method references the fields that
260:02 - we have implemented using hidden text
260:04 - fields in the checkout.razer file i.e
260:08 - the amount field and the description
260:10 - field
260:11 - the fields are bound to their
260:13 - counterpart properties within the
260:16 - checkout base class
260:18 - we can use this description field to
260:20 - uniquely identify a particular payment
260:24 - there are of course many different ways
260:25 - to implement this type of functionality
260:27 - i've chosen this way for the sake of the
260:30 - example in the interests of keeping the
260:32 - example simple i.e for teaching purposes
260:36 - when we run the code and create a test
260:38 - order once our order is approved by
260:40 - paypal we'll be able to inspect the data
260:43 - within our browser's console window
260:45 - which is the data sent back from paypal
260:48 - after our order has been approved
260:50 - we'll see that one of the fields
260:52 - contains our unique description value
260:57 - we want an object of type i shopping
260:59 - cart service to be injected into our
261:01 - checkout raiser component at run time so
261:03 - let's create a property of type i
261:05 - shopping cart service and ensure that it
261:08 - is decorated with the inject attribute
261:15 - let's override the uninitialized async
261:18 - method
261:37 - let's implement code to retrieve the
261:39 - user's shopping cart items
261:42 - we'll look at code in a later tutorial
261:45 - whereby we can use local storage
261:47 - functionality so that we don't have to
261:49 - make so many calls to the server
261:51 - we can use local storage to improve
261:53 - performance but we'll write this code in
261:56 - a later tutorial
261:59 - so i'm writing code to create a new good
262:01 - here
262:02 - so that we can use this good value to
262:04 - uniquely identify a particular order
262:16 - let's assign the total payment amount to
262:18 - the payment amount property
262:24 - let's assign the total quantity
262:27 - to the total qty property
262:30 - let's create an identifier field so that
262:33 - we can uniquely identify a particular
262:35 - order as i said earlier
262:37 - i'm just doing this for the sake of this
262:39 - example
262:41 - it is up to the developer to modify the
262:43 - appropriate code so that it is adapted
262:46 - appropriately in relation to the
262:47 - developer's particular requirement
262:50 - so let's include an o for order followed
262:53 - by the user's id
262:55 - and then followed by the unique guide
262:58 - value within the payment description
263:00 - field
263:11 - let's override the on after render async
263:14 - method this method is called in response
263:17 - to the occurrence of a blazer lifecycle
263:20 - event that occurs after the relevant
263:23 - razer component is rendered
263:25 - we can use the first render argument
263:28 - passed to this method to ensure that our
263:30 - code within this method is only fired
263:33 - once after our razor component is first
263:35 - rendered
263:38 - so if first render is true
263:40 - we want code to execute that uses our js
263:44 - object to call the init paypal button
263:46 - javascript method
263:48 - so you can see how we are integrating
263:50 - our checkout razer component
263:52 - with the sample javascript code that we
263:55 - included within the index.html file this
263:58 - is of course the sample code we copied
264:00 - from paypal
264:02 - so as to perform our integration with
264:04 - their payment gateway
264:27 - so the next step is to generate the
264:29 - client id
264:31 - whereby we can link our paypal account
264:33 - to our application
264:35 - so we need to do this through paypal
264:38 - note that you are able to follow along
264:40 - with the next part of this tutorial even
264:43 - if you just have a personal account with
264:44 - paypal
264:46 - you will however need a business account
264:48 - with paypal if you wish to go live
264:51 - with the paypal payment gateway
264:53 - functionality
264:55 - paypal provides a sandbox feature that
264:58 - we can use for development and testing
265:00 - purposes but as i said if you wish to go
265:02 - live you'll need a paypal business
265:05 - account for instructions on how to
265:07 - create a paypal business account please
265:09 - navigate to this url
265:24 - so assuming you have a paypal account as
265:27 - stated you are still able to follow
265:29 - along even if you just have a personal
265:31 - account and you don't have a business
265:33 - account
265:34 - let's log in to paypal
265:38 - then let's click the developer menu
265:39 - option here
265:41 - so that we can use the sandbox feature
265:43 - to implement the server side part of the
265:46 - integration functionality so that we can
265:48 - integrate the paypal payment gateway
265:51 - into our application
265:53 - you can then navigate to the dashboard
265:55 - like this
265:57 - you can see here you have two options
266:00 - one for sandbox and the other for live
266:03 - we are going to use the sandbox facility
266:07 - if you want to go live with your paypal
266:09 - payment gateway you would use the live
266:11 - facility
266:13 - as discussed you will need a paypal
266:15 - business account before you are able to
266:17 - go live with the paypal payment gateway
266:21 - so to create the server side
266:22 - functionality that we need in order to
266:25 - integrate the paypal payment gateway
266:26 - into our application click the create
266:29 - app button
266:38 - let's give the app a sensible name
266:44 - and then create the app like this
266:55 - we now have this client id generated for
266:57 - us
266:58 - and this is the key to how we can
267:00 - associate our client-side integration
267:03 - with our paypal account
267:05 - so let's copy this client id value to
267:08 - our clipboards
267:10 - let's remain logged into paypal
267:12 - and let's appropriately paste the
267:14 - relevant client id value to our
267:17 - index.html file here for the client-id
267:20 - parameter
267:29 - great
267:31 - while we are here let's remove the
267:33 - enable dash funding parameter here
267:44 - let's go back to paypal
267:46 - so for testing purposes paypal allows us
267:49 - to generate mock credit card details
267:52 - when we test our code we are going to
267:54 - use the generated mock credit card
267:56 - details to make a test payment
267:59 - we can generate mock credit card details
268:02 - by clicking the credit card generator
268:04 - menu option here
268:14 - and then i'm going to select the united
268:16 - kingdom as my country first
268:19 - and then to generate the mock credit
268:21 - card details we can press the generate
268:24 - credit card button here
268:26 - so let's copy the relevant mock credit
268:28 - card details and save them somewhere so
268:31 - that we can access them a little bit
268:32 - later when we test our application
268:35 - before we test the code let's make sure
268:38 - that we can navigate from our shopping
268:40 - cart razor component
268:42 - to our checkout component so to do this
268:44 - let's appropriately update the code
268:46 - within our
268:48 - shoppingcart.razer file
268:56 - then we must also ensure
268:58 - that we have an appropriate at page
269:00 - directive at the top of our
269:02 - checkout.racer file
269:04 - a user needs to be able to navigate
269:06 - directly to the checkout raiser
269:08 - component
269:09 - so we must include appropriate root
269:11 - template information following the add
269:14 - page directive
269:22 - and now we should be able to make a test
269:24 - payment through our application
269:27 - let's run the code
269:30 - let's add some items to our shopping
269:32 - cart
269:56 - let's proceed to check out
270:11 - let's appropriately enter our mock
270:13 - credit card details along with some
270:15 - appropriate made up data regarding
270:17 - personal information like address and
270:19 - phone number
270:45 - excellent
270:48 - now if we press f12
270:50 - within our chrome browsers
270:52 - we can see the data sent back from
270:54 - paypal
270:55 - in the on approved callback method
270:57 - defined within the init paypal button
271:00 - method we have code to log data sent
271:03 - back from paypal after an approved order
271:06 - has been made
271:09 - we could implement code that extracts
271:11 - the relevant data from the returned data
271:13 - from paypal and update our application's
271:16 - database in an appropriate way depending
271:18 - on our requirement
271:20 - that functionality is beyond the scope
271:22 - of this course but hopefully this gives
271:24 - you a good enough insight
271:26 - of how to integrate the paypal
271:28 - functionality into your application but
271:31 - please read the relevant developer
271:33 - related information provided by your
271:35 - preferred payment gateway service
271:37 - provider for information on how to
271:40 - create relevant integration
271:42 - functionality that best suits your
271:44 - requirement
271:46 - and you can see here our custom
271:48 - description value
271:50 - that we created earlier in code
271:53 - has been sent back from paypal along
271:56 - with the other order information
271:58 - which contains the user id value
272:02 - and a guide value that our code
272:04 - generates for each order that is sent to
272:07 - paypal
272:11 - so let's finish the code for our
272:12 - checkout raiser component
273:08 - let's say that we want to display a
273:10 - summary of items that the user is
273:12 - purchasing on the checkout ui
273:15 - next to the paypal buttons
273:18 - so let's write the code for this
274:15 - please note this code can be copied from
274:17 - the relevant github repository i have
274:19 - included the location of the relevant
274:21 - github repository below in the
274:23 - description
274:59 - let's test the code
275:59 - excellent
276:07 - this is the 10th part and the
276:09 - penultimate video in a video series
276:11 - dedicated to building a shopping cart
276:13 - application on net 6.
276:16 - so we are nearly finished building our
276:18 - shopping cart application
276:20 - in this video we are going to create
276:22 - functionality so that a user can filter
276:24 - the products in our stores product
276:27 - catalog
276:28 - by product category
276:30 - we will write codes to query our
276:32 - database for all the product categories
276:34 - within our database and display them as
276:37 - menu items in the main menu contained
276:40 - within the sidebar section of our ui
276:44 - when the user clicks one of the menu
276:46 - items denoting a product category
276:48 - data representing the products related
276:50 - to that category will be appropriately
276:53 - displayed to the user
276:55 - right let's get started
276:57 - so in the first part of this course we
276:59 - created our database through ef core
277:02 - code first migrations a requirement to
277:04 - update the databases seed data or
277:07 - structure may arise for example due to a
277:10 - decision to include new functionality
277:13 - within the application or perhaps just
277:15 - to correct a minor mistake made when the
277:18 - database was first created and seeded
277:20 - with data
277:21 - through ef core code first migrations we
277:24 - have the agility that we need to make
277:27 - appropriate adjustments to our database
277:29 - during the development and testing
277:31 - phases of our application
277:35 - so before we start writing code we need
277:38 - to address a database related
277:40 - requirement
277:41 - we need to add a new column to the
277:43 - product categories database table
277:46 - where we can store relevant css code
277:48 - that denotes an icon used to represent a
277:51 - product category
277:53 - we are of course going to use ef core
277:55 - code first migrations to address this
277:57 - requirement
277:59 - so let's first update the product
278:01 - category entity class to include a new
278:03 - string property
278:14 - and let's appropriately name our new
278:16 - property icon css
278:25 - we are going to need an appropriate dto
278:28 - data transfer object to house the data
278:30 - that we send back to the client for when
278:33 - a client makes a request to the server
278:36 - for a collection of product category
278:38 - data
278:39 - so let's go to the shoponline.models
278:42 - project and create an appropriate class
278:45 - to represent the relevant dto
279:22 - let's go back to the shoponline.api
279:25 - project
279:26 - before we generate the relevant
279:28 - migration code let's open the shop
279:30 - online dbcontext class and update the
279:33 - relevant code for seeding our database
279:35 - within the onmodelcreating method
279:57 - so here we are including relevant font
280:00 - awesome css classes within the new field
280:03 - named icon css
280:07 - these classes will be appropriately
280:08 - referenced within our code to render
280:11 - appropriate icon images for each of the
280:13 - relevant product categories
280:16 - so let's create our migration
280:33 - and give it a sensible name
280:43 - great
280:45 - let's look at the migration code that we
280:47 - have just generated
281:04 - great
281:05 - let's run our migration through the
281:07 - update dash database command
281:36 - excellent
281:38 - so let's go to our shoponline.api
281:40 - project
281:41 - so if we look at the product repository
281:44 - class
281:44 - we can see that we have already written
281:46 - the code for returning a collection of
281:48 - product category objects
281:52 - we need to expose this functionality to
281:55 - the relevant clients
281:56 - so to do this let's create an
281:58 - appropriate action method within the
282:00 - product controller class
282:43 - let's create an extension method to
282:45 - convert the collection of product
282:47 - category objects to a collection of
282:49 - product category dto objects
282:52 - this may seem like a pointless exercise
282:55 - because the shape of the product
282:56 - category class is exactly the same as
282:58 - the shape of the product category dto
283:01 - class
283:02 - it is important to understand that even
283:04 - though this step may seem unnecessary
283:08 - that we are doing this due to design
283:10 - best practices
283:12 - why is this the design best practice
283:15 - in the future a new requirement may
283:16 - arise for example where a client may
283:19 - require additional data to be returned
283:22 - from the relevant action method
283:24 - we want to maintain a clear separation
283:26 - of concerns between the dto classes and
283:30 - the corresponding entity classes
283:32 - the reason for this is that the relevant
283:35 - dto classes can evolve independently
283:38 - from the relevant entity classes if
283:40 - required without affecting their
283:43 - counterpart entity classes
283:46 - so a dto class can for example be
283:49 - extended without affecting its
283:51 - counterpart entity class
283:53 - let's finish off the code for our action
283:56 - method
284:13 - great
284:15 - so let's go to the shoponline.web
284:17 - project and write the calling client
284:20 - code for retrieving a collection of
284:22 - product category data
284:25 - let's create the relevant service code
284:27 - let's add an appropriate method
284:29 - definition to the i product service
284:31 - interface
284:42 - let's implement the code for the
284:44 - interface that we have just created
286:15 - so our code in this method is
286:17 - appropriately requesting a collection of
286:19 - objects of type product category dto
286:22 - from the server great
286:37 - let's create a razor component that will
286:40 - be responsible for outputting the
286:42 - product categories as menu items inside
286:45 - our blazer applications main menu that
286:47 - resides within the sidebar section of
286:50 - our applications ui
286:53 - so within the shared directory let's
286:56 - create a razor component named product
286:58 - categories nav menu
287:07 - let's create a class named product
287:09 - categories nav menu base
287:38 - let's write code so that an object of
287:40 - type i product service
287:42 - is injected into our razor component at
287:45 - run time
287:49 - let's create a property of type i
287:51 - enumerable that is strongly typed with
287:54 - the product category dto type
288:02 - let's create a string property named
288:04 - error message
288:09 - let's override the uninitialized async
288:12 - method
288:21 - let's create code within the
288:22 - uninitialized async method that
288:24 - retrieves a collection of objects of
288:26 - type product category dto from the
288:28 - server and assigns the returned
288:31 - collection to the product category dtos
288:34 - property
288:35 - great
288:36 - let's implement the code for the product
288:38 - categories nav menu razer file
288:41 - so we need to create a using directive
288:44 - that references the shoponline.web.pages
288:47 - namespace so let's add the appropriate
288:49 - using directive to the underscore
288:52 - imports.razer file
288:55 - we are adding this using directive
288:57 - because we are going to add appropriate
288:59 - tags
289:00 - to the product categories nav menu razer
289:02 - file that reference relevant child razor
289:05 - components that have been added to the
289:08 - pages directory
289:18 - for example
289:20 - the display spinner child razor
289:22 - component
290:01 - so notice that we are creating a link
290:03 - that contains a category id parameter
290:06 - we'll later write code that uses this
290:08 - parameter value to query the server for
290:11 - a collection of product data that is
290:14 - related to a particular category denoted
290:17 - by the relevant category id value
290:20 - so we haven't yet written the code for
290:23 - the products by category raiser
290:25 - component
290:27 - we'll write the code for this razor
290:28 - component a bit later
290:31 - this razor component will contain code
290:33 - for displaying a collection of objects
290:36 - of type product dto
290:38 - that are related to the category id
290:41 - value
290:42 - that will be passed as a parameter to
290:44 - the products by category razor component
291:25 - so the next step is to reference our new
291:28 - razor component from within the razer
291:30 - component that contains the main menu
291:33 - that appears to the user in the sidebar
291:36 - of the ui
291:38 - so let's add the appropriate tag to
291:40 - reference our product categories nav
291:42 - menu razor component
292:06 - let's run the code
292:12 - and we can see that our product
292:13 - categories are now appearing as menu
292:16 - items within the sidebar
292:18 - however
292:19 - as you can see the style of the product
292:22 - category menu items are different from
292:24 - the home menu item
292:26 - because the codes that produces the
292:28 - category menu item is contained within a
292:30 - different razor component
292:38 - so to solve this i'm simply going to
292:40 - copy the css code from the
292:42 - navmenu.razer.css file and paste it into
292:46 - a new css file that we must name product
292:50 - categories nav menu dot razer dot css
292:54 - so this will result in the product
292:57 - category menu items being styled like
293:00 - the home menu item
293:03 - so we are flagrantly violating the
293:05 - principle of dry don't repeat yourself
293:08 - here
293:09 - i'm doing this deliberately to keep up
293:11 - the momentum and creating the code for
293:13 - this application so that i can
293:15 - effectively keep the focus on the
293:17 - aspects that are the subject of this
293:20 - part of the course
293:22 - you can of course centralize the css
293:24 - code for the menu items in adherence
293:26 - with the principle of dry however for
293:28 - the reasons i've just explained i won't
293:30 - address this issue in this part of the
293:32 - course
293:43 - great
293:45 - so let's move on to create the code for
293:48 - filtering the products by category
293:51 - let's go back to the shoponline.api
293:53 - project
293:54 - let's go to the i product repository
293:56 - interface
293:58 - let's create a new method definition
294:00 - within the i product repository
294:01 - interface
294:03 - the code that we'll implement for this
294:04 - method will be responsible for
294:06 - retrieving a collection of product data
294:09 - that is related to a particular product
294:11 - category
294:13 - so let's implement the code for the
294:15 - method that we have just defined within
294:17 - the product repository class
294:59 - let's create an appropriate action
295:00 - method to expose this functionality to
295:03 - calling client code
296:16 - great
296:18 - right let's go back to the
296:19 - shoponline.web project and implement the
296:22 - service related code regarding the
296:24 - functionality for retrieving product
296:26 - data related to a particular category id
296:30 - let's open the i product service
296:32 - interface
296:33 - and create an appropriate method
296:35 - definition
296:51 - let's implement the code logic for the
296:52 - method definition that we have just
296:54 - created
297:57 - so here we are appropriately requesting
297:59 - a collection of objects of type products
298:02 - dto
298:03 - that are related to a particular product
298:05 - category
298:16 - right let's create a razor component
298:18 - responsible for displaying the product
298:20 - data filtered by category on the ui
298:32 - let's name this razor component products
298:34 - by category.razer
298:43 - let's create a class named products by
298:46 - category base
298:58 - let's implement the code for the
299:00 - products by category base class
299:08 - firstly let's create a property that
299:10 - represents a parameter that will be
299:12 - passed into this razor component
299:14 - the value passed into this category id
299:17 - parameter will be an appropriate
299:20 - category id value
299:22 - note that we are able to declare that a
299:24 - property represents a parameter
299:26 - by decorating the relevant property with
299:29 - the parameter attribute
299:32 - let's create the other necessary
299:33 - properties for our razor component
300:07 - so we want our collection of products to
300:10 - be retrieved for a particular category
300:12 - only when the category id parameter is
300:14 - set
300:16 - so we can do this by implementing our
300:18 - code within a method that is called by
300:20 - blazer in response to a life cycle event
300:23 - occurring
300:24 - when our parameter value is set
300:28 - so to achieve this we are overriding a
300:30 - built-in blazer method named on
300:32 - parameters set async
300:42 - so let's write the code within the on
300:44 - parameters set async method
300:46 - our code simply retrieves the
300:48 - appropriate products data from the
300:49 - server based on the value passed into
300:52 - our category id parameter
301:51 - let's write the appropriate ui code
301:53 - within the products by category.razer
301:55 - file
302:04 - so let's first use the add page
302:06 - directive to appropriately declare the
302:09 - relevant root template information for
302:11 - our products by category razer component
302:23 - let's write code to inherit from the
302:26 - products by category base class
302:34 - let's implement the code logic
303:12 - so as you can see
303:14 - we can reuse our display products razor
303:17 - component
303:18 - that we created in a previous part of
303:20 - this course to display the relevant
303:22 - products data to the user
303:36 - let's run the code
303:49 - excellent
303:55 - so you can see that our product category
303:57 - menu items appear differently when
303:59 - compared to the home menu item
304:01 - so let's fix this in code so that our
304:04 - menu items are displayed in a consistent
304:06 - way to the user
304:28 - great
304:29 - let's finish off by adding an
304:31 - appropriate logo for our application
305:27 - excellent
305:29 - i hope you have enjoyed this video i
305:31 - look forward to presenting the final
305:32 - video in this series
305:34 - where we'll optimize our code to
305:36 - potentially create better performance
305:38 - for our application
305:47 - hi and welcome i'm gavin lon
305:50 - this is the 11th and final part in a
305:52 - series of videos dedicated to building a
305:55 - shopping cart application using blazer
305:57 - web assembly and web api on net six
306:02 - so we have now built our basic shopping
306:04 - cart application
306:06 - but is software ever really 100 complete
306:10 - at points there may be bug fixes to make
306:13 - we may need to upgrade our application
306:15 - with the latest technologies
306:18 - a requirement may arise to improve the
306:20 - overall performance of the application
306:24 - there may be parts of the application
306:26 - where ux user experience can be enhanced
306:30 - in this video we are going to look
306:31 - specifically at how we can improve the
306:34 - performance of our application
306:36 - by optimizing our code
306:38 - there are two areas where we can
306:40 - potentially enhance the performance of
306:42 - our application
306:43 - item number one
306:45 - in the web api component we are
306:47 - currently making two separate queries to
306:49 - the database when retrieving product
306:52 - data
306:53 - our code is returning both product data
306:56 - and product category data to the calling
306:58 - client
306:59 - to do this we are currently calling two
307:01 - separate methods in the product
307:03 - repository class
307:05 - one for retrieving details about the
307:07 - products from the product database table
307:10 - and the other for retrieving details
307:13 - about the product categories from the
307:15 - product categories database table
307:18 - so in this video to potentially enhance
307:20 - performance we are going to retrieve the
307:22 - product and category details through one
307:25 - query to the database instead of two
307:28 - the other area where we can improve
307:30 - performance is by using local storage
307:32 - within the blazer component to store
307:35 - both the product data and shopping cart
307:38 - data so that when our application needs
307:40 - to retrieve relevant product data or
307:42 - shopping cart data
307:44 - our code can retrieve the relevant
307:46 - information from local storage i.e data
307:49 - stored on the client within the user's
307:51 - browser as opposed to making a trip as
307:54 - it were to the server every time the
307:56 - relevant data needs to be retrieved
307:59 - so basically the travel time and
308:01 - retrieving the relevant data can be
308:03 - shortened in certain scenarios the data
308:06 - can be retrieved on the client instead
308:08 - of the server
308:11 - for content like this and much more
308:13 - please consider subscribing and please
308:15 - ring the bell so as to be notified of
308:16 - future content
308:18 - if you like this video please hit the
308:20 - like button and please feel free to
308:22 - share this video with anyone you feel
308:24 - may benefit from its content
308:27 - so let's attack the first item let's go
308:30 - to the shoponline.api project
308:33 - let's optimize the code on the server
308:35 - where we can make one query to the
308:37 - database to retrieve both product
308:39 - information and related product category
308:41 - information rather than use two separate
308:44 - queries for this purpose
308:47 - so the first step is that we need to
308:49 - modify the class representing the
308:51 - product entity
308:53 - so we must first add a public property
308:56 - to the product class that is of type
308:58 - product category
309:06 - let's add the foreign key attribute to
309:09 - our new product category property we can
309:12 - then pass an appropriate string value to
309:15 - the foreign key attribute
309:17 - that is used for declaring which
309:18 - property in the product class must be
309:21 - used for joining the product entity to
309:23 - the product category entity so this code
309:27 - will indicate to ef core as it were how
309:29 - we want to join the product entity to
309:32 - the product category entity
309:38 - let's go to the product repository class
309:40 - and first modify the get item method to
309:43 - appropriately join the product entity to
309:46 - the product category entity in the
309:48 - relevant link query
309:50 - so to do this we can use the include
309:52 - method like this
309:54 - we are establishing the join between the
309:56 - two entities through this lambda
309:58 - expression
310:00 - notice the product category property
310:02 - that we recently created within the
310:05 - product
310:06 - class for this query we only want to
310:10 - retrieve one item
310:12 - so we can use the single or default
310:13 - async method to filter the product data
310:16 - based on the relevant product id passed
310:18 - to this method
310:25 - then for the get items method the code
310:28 - is similar to the get item method
310:31 - but for the get items method we wish to
310:34 - return all the products that are
310:36 - currently stored in the products
310:37 - database table with the related product
310:40 - category information
310:42 - to the calling code
310:43 - so we of course don't need to filter the
310:46 - data
310:47 - so that means we don't need to use a
310:49 - method like the single or default async
310:51 - method in this query
310:59 - then the last method that we need to
311:01 - appropriately modify is the get items by
311:04 - category method
311:39 - if we open the product controller class
311:42 - we can see that we can now simplify the
311:44 - code here but first we need to
311:46 - appropriately update the relevant
311:48 - extension methods responsible for
311:50 - converting objects of type product to
311:53 - objects of type product dto
311:56 - so let's first update the extension
311:58 - method that converts an individual
312:00 - product to type product dto
312:21 - great
312:23 - then let's update the conversion
312:24 - extension method that converts a
312:26 - collection of objects of type product to
312:29 - a collection of objects of type product
312:32 - dto
312:53 - great
312:55 - we can now update the relevant action
312:57 - methods accordingly
312:59 - we no longer need to query for the
313:01 - category items in a separate query that
313:04 - we are using here to get a collection of
313:06 - category items
313:35 - so we've potentially improved
313:36 - performance of the server-side code
313:39 - through an appropriate code optimization
313:41 - exercise
313:43 - we are only dealing with a small amount
313:45 - of data so the performance improvement
313:48 - would probably be negligible
313:50 - but if we were dealing with large
313:51 - amounts of data the performance
313:53 - improvement would be more significant
313:56 - so let's look at the second way that we
313:58 - can improve the performance of our
314:00 - application
314:01 - the second way that we can improve the
314:03 - performance of our application involves
314:06 - an update to our blazer component
314:09 - so let's go to the shoponline.web
314:11 - project
314:13 - let's see how we can reduce the number
314:14 - of trips to the server we are currently
314:17 - making for retrieving relevant product
314:19 - and shopping cart data
314:21 - through the use of local storage
314:24 - so we could use javascript and blazer's
314:27 - javascript interoperability feature and
314:30 - write our own local storage
314:31 - functionality
314:33 - it turns out though we don't need to go
314:35 - to this kind of trouble because someone
314:37 - has already made available a new get
314:39 - package that contains the local storage
314:41 - functionality we need
314:43 - so let's invoke the nuget package
314:45 - manager window
314:47 - let's search for local storage
315:03 - and this is the package we want to
315:06 - install
315:07 - so let's install the
315:09 - blazered.localstorage nuget package
315:19 - for more details regarding local storage
315:21 - please navigate to this url
315:23 - basically the javascript local storage
315:26 - object allows you to save key value
315:29 - pairs in the browser
315:32 - note the local storage object stores
315:35 - data with no expiration date the data is
315:38 - not deleted when the browser is closed
315:41 - and are available for future sessions
315:45 - so the local storage functionality
315:47 - provided to us within the
315:49 - blazid.localstorage nuget package
315:52 - abstracts the javascript code for
315:54 - managing local storage
315:56 - so we don't need to write the relevant
315:58 - javascript code ourselves
316:01 - we are now going to create two services
316:04 - to encapsulate our local storage
316:06 - functionality so let's first create an
316:08 - interface named i manage products local
316:11 - storage service
316:27 - let's create two method definitions like
316:30 - this
316:30 - let's create an appropriate method
316:32 - definition for a method named get
316:34 - collection
316:44 - let's create an appropriate method
316:45 - definition for a method named remove
316:48 - collection
316:54 - let's create an appropriate service
316:56 - class to implement the methods defined
316:59 - within the interface we have just
317:01 - created
317:45 - let's create a constructor whereby we
317:47 - indicate that we want an object of type
317:50 - i local storage service and an object of
317:53 - type i product service injected into our
317:56 - constructor at run time
317:58 - note that the i local storage service
318:00 - type is a type provided by the
318:04 - blazer.localstorage nuget package that
318:06 - we have now installed
318:08 - so this type will be used to implement
318:11 - the necessary local storage
318:13 - functionality
318:18 - let's create a private method named ad
318:20 - collection
318:37 - this method simply retrieves the product
318:39 - data from the server
318:41 - and saves the relevant product data in
318:44 - the user's browser using local storage
319:01 - okay let's create a string constant to
319:03 - store the key that will be used to
319:05 - identify the relevant value
319:08 - in this case the relevant value is a
319:10 - serialized collection of objects of type
319:12 - product dto
319:24 - let's implement the code for the get
319:26 - collection method
319:28 - so this method first tries to retrieve
319:31 - the relevance data from local storage
319:34 - if the relevant data does not exist in
319:36 - local storage we can call the add
319:39 - collection private method to retrieve
319:41 - the relevant data from the server and
319:43 - save the relevant data to the user's
319:45 - browser using local storage
319:48 - the remove collection method simply
319:50 - removes the relevant data stored within
319:52 - the user's browser using local storage
320:01 - right let's create an interface within
320:03 - the contracts folder named i manage cart
320:06 - items local storage service
320:29 - let's create an appropriate method
320:31 - definition for a method named get
320:33 - collection
320:36 - let's create an appropriate method
320:37 - definition for a method named save
320:39 - collection
320:45 - let's create an appropriate method
320:46 - definition for a method named remove
320:48 - collection
320:50 - right let's implement the relevant code
320:52 - for the interface that we have just
320:53 - created
320:56 - so let's first create a class named
320:58 - manage cart items local storage service
321:42 - let's create a constructor whereby we
321:45 - indicate that we want an object of type
321:48 - i local storage service and an object of
321:50 - type i shopping cart service injected
321:53 - into our constructor at runtime
322:04 - let's create a constant to store the key
322:07 - that will be used to identify the
322:09 - relevant items stored using local
322:11 - storage the local storage item in this
322:14 - case will be a serialized collection of
322:17 - card item dto objects
322:21 - let's create a private method named add
322:24 - collection
322:39 - this method simply retrieves relevant
322:41 - data from the server and appropriately
322:43 - saves the data to local storage
322:53 - this method attempts to retrieve the
322:56 - relevant data from local storage if the
322:58 - relevant data does not exist in local
323:00 - storage the code retrieves the relevant
323:02 - data from the server and appropriately
323:05 - saves the relevant data to local storage
323:12 - let's implement the code for the remove
323:13 - collection method which involves
323:15 - appropriately deleting a collection of
323:17 - objects of type cart item dto from local
323:20 - storage
323:22 - notice that the key constant is used to
323:25 - identify the relevant local storage item
323:28 - let's implement the code for the save
323:30 - collection method which involves
323:32 - appropriately saving a collection of
323:34 - objects of type cart item dto to local
323:37 - storage
323:43 - so we haven't yet registered the ilocal
323:45 - storage service type provided in the
323:48 - blazer.localstorage package with the
323:51 - dependency injection system
323:53 - so let's open our program.cs file
323:56 - and apply the code to register the
323:59 - ilocalstorage service type for
324:01 - dependency injection
324:03 - so we can use the add blazer local
324:05 - storage extension method for this
324:07 - purpose
324:18 - we must then also register our two new
324:20 - service classes that we have created to
324:23 - abstract the relevant local storage
324:25 - functionality with the dependency
324:27 - injection system
324:44 - so let's now implement the relevant
324:46 - local storage functionality within the
324:48 - relevant razor components in order to
324:51 - hopefully increase the performance of
324:53 - our blazer component
324:55 - let's open the products base class
324:59 - this is the base class for the razor
325:02 - component that first loads when our
325:04 - application is first launched
325:06 - let's create the code to ensure
325:09 - that our two local storage services are
325:11 - injected into this razor component
325:31 - let's say that when the product's razor
325:33 - component is loaded we want to clear the
325:35 - relevant local storage items from local
325:38 - storage
325:40 - this will force our code to retrieve the
325:44 - relevant data from the server at this
325:46 - stage
325:48 - then subsequently we want the relevant
325:50 - data retrieved from local storage to
325:53 - enhance performance
325:56 - so let's create a private method named
325:58 - clear local storage and use the relevant
326:00 - functionality we have created within the
326:02 - relevant services to remove the relevant
326:05 - data from local storage
326:12 - let's call this method from within the
326:14 - uninitialized async method
326:18 - then instead of going straight to the
326:19 - server for our data let's use the
326:22 - appropriate local storage service object
326:24 - to first check to see if the relevant
326:27 - data resides within local storage
326:30 - of course in this case we are clearing
326:32 - the data before this method is called
326:35 - which will force our code to retrieve
326:36 - the data from the server
326:38 - however our code will subsequently save
326:41 - the data retrieved from the server to
326:43 - local storage which means that when
326:45 - other razer components retrieve the
326:47 - relevant data
326:49 - the data will be retrieved from local
326:50 - storage on the client side which means
326:53 - an unnecessary trip to the server will
326:55 - be avoided
326:57 - so this gives us an idea of how we are
326:59 - able to increase performance of our
327:01 - application using local storage
327:04 - we can also use our manage cart items
327:06 - local storage service object
327:09 - to retrieve any cart item data that may
327:11 - be saved to the user's shopping cart
327:14 - like this
327:17 - so in this case this code will retrieve
327:19 - the relevant data from the server and
327:21 - save the data to local storage
327:25 - any data retrieval of items within the
327:27 - user's shopping cart can then be done
327:30 - from local storage and therefore trips
327:32 - to the server are saved and the
327:34 - performance of our application is
327:36 - potentially enhanced
327:39 - let's appropriately update the shopping
327:41 - cart razor component
327:43 - let's write the code so that an object
327:46 - of type i manage card items local
327:48 - storage service is injected into this
327:50 - razor component at runtime
328:06 - in the uninitialized async method let's
328:08 - replace the code that retrieves the
328:10 - relevant cart item data from the server
328:13 - to get the relevant data from local
328:15 - storage
328:20 - when a user updates the quantity of a
328:22 - particular item saved within the user's
328:25 - shopping cart we must update the
328:28 - relevant local storage item
328:30 - this is because of course the relevant
328:32 - shopping cart has now changed
328:44 - we can appropriately implement the safe
328:46 - collection method for this purpose
329:13 - we must also use the appropriate local
329:15 - storage service to implement the code to
329:18 - update the relevant local storage item
329:21 - when a user removes an item from the
329:23 - user's shopping cart
329:40 - let's implement the relevant local
329:41 - storage related code for the product
329:43 - details razer component
329:46 - so this component is responsible for
329:48 - displaying details for a particular
329:51 - product
329:52 - this razer component also contains
329:54 - functionality for adding a product to
329:57 - the user's shopping cart
330:17 - let's first create a private property to
330:19 - reference the shopping cart items
330:21 - collection here because when the user
330:24 - adds a product to the user's shopping
330:26 - cart we want our code to update the
330:29 - relevant local storage item
330:32 - we no longer only want the code to
330:34 - update the relevant shopping cart on the
330:36 - server we need to keep the client side
330:39 - local storage data up to date as well
330:42 - so let's first write code to update our
330:45 - shopping cart item's private property
330:48 - with data retrieved from local storage
330:51 - within the uninitialized async method so
330:54 - within the method responsible for adding
330:56 - a new item to the user's shopping cart
330:59 - we need to write code that not only
331:01 - updates the data on the server but also
331:04 - updates the relevant local storage item
331:08 - so we can implement the desired
331:09 - functionality in code like this
331:31 - we can also now implement code that gets
331:33 - data for an individual product from
331:36 - local storage
332:29 - great
332:30 - let's appropriately update the products
332:32 - by category razor component to include
332:34 - local storage functionality
332:48 - let's write code so that an object of
332:50 - type image products local storage
332:52 - service will be injected into this razor
332:55 - component at runtime
333:23 - let's write a private method
333:25 - so that the products filtered by
333:27 - category id are retrieved from local
333:30 - storage
334:08 - let's appropriately call our new private
334:11 - method from within the on parameters set
334:14 - async method
334:26 - lastly let's appropriately update the
334:28 - checkout razer component with our local
334:31 - storage functionality
335:04 - great let's run the code
335:31 - excellent
335:33 - that definitely seems to have made a
335:35 - positive difference to the performance
335:37 - of our shopping cart application
335:41 - if you've made it to the end of this
335:42 - course well done
335:44 - you have learned quite a lot about laser
335:47 - web assembly and web api
335:49 - we have also learned how to create a
335:52 - basic spy application where the vast
335:54 - majority of the code is implemented
335:57 - using c-sharp
335:59 - i hope you have enjoyed going through
336:00 - this course as much as i enjoyed
336:03 - creating it
336:04 - for content like this and much more
336:07 - please consider subscribing and please
336:09 - ring the bell so as to be notified of
336:11 - future content
336:12 - if you liked this video please hit the
336:14 - like button and please feel free to
336:16 - share this video with anyone you feel
336:19 - may benefit from its content
336:21 - i really enjoy engaging with you in the
336:23 - comments section so please feel free to
336:25 - leave a comment
336:26 - the latest code can be found on github a
336:29 - link to the relevant repository has been
336:31 - included below in the description
336:39 - thank you and take care

Cleaned transcript:

blazer web assembly is a single page app framework for building interactive clientside web apps with net it uses open web standards without plugins or recompiling code into other languages this course will teach you how to use blazer web assembly and web api on.net 6. you will learn step by step how to build a shopping cart application this course also provides a guide on how to integrate a payment gateway into your blazer webassembly component so that a user is able to pay for products through your application using a debit or credit card or even a paypal account gavin lawn teaches this course gavin is a senior software engineer with over 20 years of experience i encourage you to leave a comment with the most interesting thing you learn for the benefit of other campers who are watching this course please join me as we build a very basic shopping cart application using blazer webassembly a few of the significant technologies we'll use for building our application are as follows the latest version of visual studio which is visual studio 2022 and we'll use the community edition for windows dot net 6 which is at the time of creating this video the latest version of dot net it was released in november of 2021 sql server 2019 laser web assembly we'll use bootstrap version 5 for layout and styling purposes we'll build a restful mvc web api project for handling database related functionality and returning relevant data from the server to our client side blazer application all technologies used for the development of this application can be downloaded free of charge please see below in the description the locations of where you are able to download the relevant technologies for free we are going to integrate a payment gateway powered by paypal into our application so that a user can use their paypal account or a valid debit or credit card to pay for the items that are purchased through our online shopping cart application blazer is a relatively new feature of asp.net it offers two hosting models a serverside hosting model and a clientside hosting model we are going to use the clientside hosting model for the development of our shopping cart application the significance of this hosting model is that the csharp code runs directly within our browsers what makes this possible is a technology named webassembly in recent years the creation of spa applications or single page applications have become very popular as web solutions up until fairly recently javascript frameworks like angular or react have been the available choices for the creation of spa applications with blazer we are now able to create our single page applications using csharp we don't necessarily need to depend on javascript for the creation of our interactive ui code we can create this code using csharp in this application however the payment gateway provided by paypal is coded in javascript so we will use blaze's interoperability functionality with javascript to interact with the relevant javascript paypal code so let's get started let's create our blazer solution let's fire up visual studio 2022 select create new project let's choose the appropriate project template blazer webassembly app let's name our solution shop online solution let's name the blazer project shoponline.web great let's add a new project to our solution where we'll create our restful web api functionality so let's ensure that we choose the correct project template let's name our project shoponline.api notice that for the authentication type we are choosing none we are not going to implement membership functionality which of course includes login and registration functionality we'll focus purely on the shopping cart functionality we want to run our application on the latest version of.net.net 6. note that we have enabled open api support by doing this the swashbuckle nuget package will be automatically installed and the appropriate swagger middleware will be automatically configured appropriately within our project one of the advantages of this is when we run our web api project interactively we'll be able to test our web api code through our browsers even before we have developed any frontend code so a basic ui will automatically be created for this purpose for us when we run our application interactively we'll be able to test each of our action methods through the relevant automatically created webbased ui note that you can also use a tool like postman to test your web api functionality i won't be using postman during the development of this application we are going to build our database using codefirst migrations and entity framework core migrations allow us to evolve our database without losing data or database objects so by using plain old csharp classes we can build the database entities that we wish to include within our shopping cart application once we have created relevant related csharp classes we'll look at an entity relationship diagram that represents our shopping cart applications database design let's add a folder named entities to our project this is where the classes that will represent our database entities will reside so let's create a class named cart to represent the cart entity so let's add two public properties to this class id as integer and user id as integer let's add a new class named cart item this entity represents an item that has been added to the user's shopping cart so let's add an integer property named id let's add an integer property named cart id this property represents a foreign key field and is used to join the cart entity to the cart item entity so the cart entity has a onetomany relationship with the cart item entity this denotes that many card items can be included within one particular shopping cart let's include an integer property named product id lastly let's include an integer property named qty representing the quantity or number of a particular product that may be included within a particular shopping cart let's create a new class representing the product entity the product entity will have a onetomany relationship with the cart item entity this denotes that a product can be included many times across many different shopping carts let's add an integer property named id let's add a string property named name let's add a string property named description let's add a string property named image url let's create a property of type decimal named price let's create a property of type integer named qty lastly let's add a property of type integer named category id the categoryid property represents a foreign key from the product category entity the code for which we are about to implement so let's create a class named product category this entity has a onetomany relationship with the product entity let's add a public property named id note that when a property is named id by convention entity framework core will designate the id property as representative of the relevant entity's primary key let's add a property of type string and name this property name and lastly let's create a class to represent our user entity which of course represents a user of our application note that i've included this entity as a temporary substitute for a membership facility like for example microsoft identity so that we can focus on the shopping cart workflows and not be distracted by the membership functionality so let's add an integer property named id let's add a string property named username so if we look at this entity relationship diagram we can see the relationships between our entities the cart entity has a onetomany relationship with the cart item entity the product entity has a onetomany relationship with the card item entity the product category entity has a onetomany relationship with the product entity the user entity has a onetoone relationship with the cart entity so this basically means each user can only have one shopping cart within our application if you look at the sql server management studio that is installed on my local machine you can see that i've already generated a database through ef core this was done when i was developing the prototype for this application so we are now going to use efcor to generate a database for our shopping cart application the classes that we have just created representing our entities will be used by ef core to generate the corresponding database tables within a database that ef core will create for us in order to generate our database with the relevant tables through visual studio let's install two nuget packages to do this right click the dependencies node within our shoponline.api project click the manage new get packages menu item click the browse tab on the new get package manager dialog let's search for entity framework core dot sql server and this is the package we want to install let's click the install button then the i accept button great let's search for the second package that we need to install the reason we are installing this package is because we want to run our migrations from within visual studio as opposed to using the.net cli for this purpose note that you would use different commands when running migration commands using the.net cli as opposed to the commands you would run when using visual studio so let's search for entity framework call dot tools and this is the package we want let's install the microsoft dot entity framework core dot tools nuget package the next step is we must configure a connection string in order to connect our application with the database that we wish to create using entity framework core code first migrations so let's open the appsettings.json file within our shoponline.web project within the connection string that i'm configuring here i'm including my server name which is gavin lon's pc the database which i wish to name shop online and we are going to use a trusted connection to connect our shopping cart applications web api to our database so let's include trusted underscore connection equals true within our connection string note that i have named my connection string shop online connection let's create our database context class let's first create a folder named data within our shoponline.api project let's add a class named shoponlinedb context to our new data folder so in order to make this class represent our ef core database context we need to implement code so that our shop online db context class inherits from ef course db context class you can see there's a red squiggly line under db context this is because we haven't yet brought in the microsoft dot entity framework call namespace an easy way to include the appropriate using directive through visual studio is to press control period and then select the appropriate menu item from the menu that is presented to us through visual studio let's create the constructor for our shop online dbcontext class we must add a parameter to the constructor that we have just generated the parameter is named options and is of the generic type db context options which has the data type shop online db context passed as an argument to it we can then write code to pass the argument that will be passed to our shop online db context class constructor to the base class from which it inherits i.e the db context class now because i want to focus on the shopping cart workflows at this stage and don't want us to be distracted by the implementation of administrative crowd operation functionality we are going to seed our database with certain data this is data that i've already prepared so we are not going to include create read update and delete functionality regarding the creation and maintenance of product data at this stage we are going to seed our database with product related data we are going to seed our database with the relevant data so that we can move directly to the creation of our shopping cart functionality so in order to seed the database appropriately we can override a method that exists within the db context base class this method is named on model creating an easy way to generate the relevant override code for this method through visual studio is to type in the word override and then press the spacebar we can then select the on model creating item from the dropdown list presented to us within visual studio i have already prepared the code for seeding our database and this code can be found at this location on github so let's go to the appropriate github location and copy this code to our clipboards let's then paste the code from our clipboards into the on model creating method the next step is to let entity framework core know as it were about our entities so we can do this by using the entity framework call dbset generic type so for each of our entities we need to appropriately include a public property of type db set within our shop online dbcontext class to register our shop online db context class for dependency injection let's open the relevantprogram.cs file then we can simply add this code here to register our shop online dbcontext class for dependency injection note that our code is reading the connection string that we configured in the app settings.json file we are now ready to generate a migration using ef core so let's launch the new get package console manager window from within visual studio like this we can then type the appropriate command to generate a migration so let's type in add dash migration followed by the name of the migration we wish to create so when i run the add dash migration command i get an exception i've found out that this exception occurred because at present the shoponline.web project is set to my startup project within the relevant solution so if you get this exception all you need to do to fix this is make the shoponline.api project your startup project like this so let's try again and now we don't get the exception and it works as expected and you can see code within the up method of the migration class that we have just generated this code creates our database and the relevant tables this method also contains code that seeds the relevant database tables with the data that i prepared prior to creating this video the down method contains code to undo the changes made by code contained within the up method to run our migration all we need to do is type the update database command within the new get package manager console window like this and then of course press enter and now if we look at sql server management studio we can see that the shop online database has been created the database tables have been appropriately created based on the entities we created using csharp classes the relevant database tables have been seeded with the data created from the code we included within the on model creating method which resides within the shop online db context class the data with which we have seeded our database contains product and user information this has been done so that we can focus on the shopping cart functionality and not worry at this stage about implementing code or create read update and delete functionality regarding products sold by our fictional online store here are just a few notes about running migrations please note that if you have run a migration or more than one migration and are not happy with the changes made to the database you can undo the changes made by running this command update dash database followed by a zero the number zero is a special case that means before the first migration and causes the effects of all migrations to be rolled back you may wish to remove the migrations after this you can remove a migration that has not yet been used to update the database by running the command remove dash migration the remove dash migration command will remove the last migration that has not yet run note that if for example you have updated the database with multiple migrations and you wish to roll back the changes to before a particular migration was run you can roll back your changes to that particular state by running the migration that was run directly before the migrations that were run that contain the changes you wish to roll back this is the second part in a series of videos dedicated to building a shopping cart application using blazer and a restful web api in this video we are going to start with the workflow that involves retrieving product data from our database and returning the data to the client blazer component the code for this functionality will be implemented within a web api component so in this tutorial we'll start to develop our web api component before we do this let's create the classes that represent the data that will be passed between the web api component and the blazer component you might be thinking but we have already created the classes to represent the data for our application for example product product category cart cart item etc yes we did create these classes that represent our entities in the previous part of this video series these entity classes directly map to the database tables that were generated when we ran the relevant migration the function of these classes can be seen as blueprints for their corresponding database tables when we pass data between the web api component and the blazer component we don't necessarily want to pass the exact data defined by the properties in the classes that represent the database entities for example in this tutorial we are going to create code that returns the product data from the web api component to the blazer component the product class contains certain product related properties one of which is the category id a particular category id value could for example denote that a particular product falls under the electronics category and could for example be a laptop or for example the product could fall under the furniture category and could be for example a couch the category id property within the product entity is a foreign key from the product category entity from a human perspective the category id property does not have much meaning because it contains a numeric value so it wouldn't for example make much sense to display the category id to the user we may want to pass the relevant category name in addition to the product information defined in the product class so to facilitate this we can create a new model that contains all the relevant products data as well as the relevant category name which is included in the product category entity and not the product entity so it makes sense to create a new model to represent the data that in this case we wish to pass from server to client we need a model that includes all the product information as well as the category name the type of model i am referring to is known as a dto or data transfer object this type of model includes the data that needs to be passed between server and client so a dto is an object that defines how the data will be sent over the network the classes that represent our entities that we created in the first tutorial directly map to their corresponding database tables these classes represent the structure of certain tables in our database we can create dtos data transfer objects that are based on the underlying entity classes but may be differently shaped based on the data that needs to be passed between client and server we are going to create a standard library project to house our dtos so let's create a new project within our solution let's select the appropriate class library project template let's name our new project shoponline.models let's delete the default class generated for us by visual studio let's create a folder named dtos so let's create the dtos that we are going to use in our application now the only dto that we are interested in at the moment will be named product dto but let's create the other dto classes that will be used later on in the development of our application as well as the products dto class the dto classes will be explained in more detail at appropriate points during the development of our application let's create a class named cart item dto let's make sure our new class contains the public access modifier let's create the properties for the cart item dto class id as integer product id as integer cart id as integer product name as string product description as string product image url as string price as decimal total price as decimal and qty as integer let's create a new class named cart item to add dto let's ensure that our new class contains the public access modifier so cart id as integer product id as integer and qty as integer let's create a new class named cart item qty update dto let's ensure that our new class contains the public access modifier cart item id as integer qty as integer let's create a class named product dto this is the dto that we are going to use in this tutorial let's ensure that our new class contains the public access modifier id as integer name as string description as string image url as string price as decimal qty as integer category id as integer and category name as string great so we have created the classes that represent our dtos data transfer objects let's go to our shop online.api project so we are now going to start coding the logic for our first workflow starting with the web api component this workflow simply involves retrieving product data from our database and returning the data to the client blazer application the blazer application will contain code that displays the relevant product data to the user so now our shop online db context class has been registered for dependency injection we'll see in a bit how we are able to implement code to ensure that an object of type shop online db context is injected into relevant classes we are going to use the repository design pattern to abstract our data handling layer repositories are classes or components that encapsulate the logic required to access data sources we can use repositories to centralize common data access functionality which has the benefit of facilitating better maintainability easier unit testing extensibility and cleaner code the best way to understand the repository pattern is to implement the relevant code so let's write the code for our product repository functionality so let's create a folder named repositories within the repositories folder let's create a folder named contracts within the contracts folder let's create an interface named i product repository let's create four method definitions within our new interface we want all these methods to run asynchronously so all the method definitions within this interface will return generic task objects our first method is named getitems and returns an i enumerable collection of type product so the i enumerable collection is passed as a type argument to the task object as discussed this is so the method that implements this method definition can run asynchronously the other methods follow a similar pattern let's define the method definition for a method named get categories let's define a method definition for a method named get item which contains a parameter of type integer named id let's define a method definition for a method named get category which contains a parameter of type integer named id so we have defined the interface that we want a class named product repository to implement so let's create a class directly within the repositories directory named product repository and the first thing we need to do is write the code to implement the i product repository interface so let's do that we can see a red squiggly line under i product repository this is because we need to bring in the shoponline.api.repositories.contracts namespace a quick way to do this is press ctrl period and then select the appropriate item from a list provided by visual studio like this the red squiggly line is still there this is because visual studio is telling us as it were that we need to implement code for all the method definitions that we have defined within the i product repository interface so let's press ctrl period once again and select the appropriate item from the list presented to us and visual studio generates the relevant code stubs for us so visual studio generates default implementations for the relevant method definitions so at this stage we only want to implement the code logic relevant to the workflow that is the focus of this video i.e returning a collection of product data to the client side calling code in this case our blazer component we are going to need to use the shop online db context object to interact with our shop online database as you will recall earlier we registered the shop online db context object for dependency injection this means that we are able to gain access to an object of type shop online db context by defining an appropriate parameterized constructor in our product repository class so let's create the code for this an easy way to automatically generate a constructor within visual studio is type ctor and then press the tab key twice like this then in order to indicate to.net that we want an object of type shop online db context to be injected into this constructor all we need to do is define a parameter within our constructor of type shop online db context like this let's bring in the appropriate namespace and we can get visual studio to create an appropriate private readonly member variable to reference our shop online db context object by pressing control period and selecting the appropriate item from the list presented to us by visual studio great so for the workflow that is the focus of this tutorial we only need to implement code for two of the method definitions within the i product repository interface so at this point we are only going to implement code for the get items method and the get categories method so let's implement code for the get items method all we want this method to do is return all the products from the products table so let's write the code for this note we want our code to run asynchronously so we must include the await keyword here notice how once we have typed in the await keyword that the async keyword automatically appears in the method definition for the get items method if you include the await keyword within a method the method in which you include the await keyword must appropriately contain the async keyword note that to include the to list async extension method here in our code we must bring in the microsoft.entity framework core namespace and that's it we have written the code to return an i enumerable collection of products data from our database so let's implement the code to return the product categories from our database we can do this by implementing the appropriate code within our get categories method like this great so we have now implemented the code for retrieving product data from our database the next step is to write code to return the appropriate data to the calling client so to do this we need to create an appropriate controller class before we create our controller class let's delete these classes that were generated by default when we first created our web api project these classes are obviously not going to be used in our application so now let's create a class within our controllers directory let's ensure that we select the appropriate controller class template let's name this class product controller so the first thing to do is to write the code so that an object of type product repository is automatically injected into our controller classes constructor via dependency injection let's also ensure that we have a readonly private field that references the object passed in via dependency injection but we haven't yet registered our product repository class for dependency injection so let's write the code for this let's open the program.cs file let's implement the code to register the product repository class with the dependency injection system notice how we use the add scoped method to register our product repository class for dependency injection we could have used the add transient method or the add singleton method to register our product repository class with the dependency injection system but in our case add scoped is the appropriate method for this purpose very basically using add transient would mean that a new instance of the relevant object is provided to every class that requires the relevant object to be injected using add singleton would mean that the same instance of the object is injected into the relevant classes for every http request using add scoped means that the same instance of the object is injected into relevant classes within a particular http request note that in this case a new instance of the relevant object will be created for each http request let's create a method definition for an action method named get items we want our action method to run asynchronously the type that is passed to the generic task object is of the generic action result type one of the core benefits of returning an action result is that as well as returning the requested data from an action method to the client an appropriate response status code can also be returned for example a http status code of 200 means the request has succeeded a status code of 404 represents that a resource could not be found and a http status code of 500 represents that an internal server error occurred so we need to pass the type of data that we wish to return to the client as a type argument to the action result generic type so we want to return an i enumerable collection of type product dto to the client so the first thing we need to do is create a project reference to the shop online dot models project because this is where our product dto class resides then let's bring in the shoponline.models.dtos namespace great let's name our action method get items each action method in our controller must map to a particular http verb for example get post push delete etc our get items action method will be used for getting product data and returning that product data to the client so the appropriate http verb for this action method is get so to indicate this to dot net we need to decorate our get items action method with the http get attribute so let's implement the code logic for our get items action method let's first create a try catch block an easy way to do this in visual studio is to type in try followed by pressing the tab key twice so let's write code that calls the product repository classes get items method asynchronously to return an i enumerable collection of type product to our action method we want to include the category name associated with each product in our collection so let's write code to return a collection of product category objects to our action method we'll write the code that joins our collection of products with our collection of product categories in a bit so you may have spotted that the code in this action method is not ideal at the moment it is not ideal because we are retrieving a collection of products and a collection of categories in two separate queries to the database a more performant way for retrieving the product collection and related category data would be to appropriately use the include extension method within the relevant link query in the get items method within the product repository class the use of the include method would join the data retrieved from the products database table with related data retrieved from the product categories database table and allow for the products data and related category data to be returned through one query i'm going to leave the code as it is for now we'll optimize this code for performance by using the include extension method as i've just described toward the end of the course so if either the products variable is null or the product categories variable is null let's return a status code of not found to the calling client code so in this case our web api will return a http status code of 404 meaning that relevant data was not found or a relevant resource was not found so in this case it means that the client request failed and the reason for the failure is that an essential resource could not be found else we want to join the collection of product categories with the collection of products so that we can return a collection of product dtos to the calling client code which will include the category name remember the product dto definition contains a category name property in order to get the category name for each product in the collection we need to join the collection of type product to the collection of type product category we are going to use link for this purpose in order to avoid creating too many lines of code within our action method we are going to create an extension method to return a collection type of product dto to our action method so let's create a folder named extensions let's create a class within our extensions folder named dto conversions note that in order to create an extension method we need the class that houses our extension methods to be static let's create our extension method so the extension method must be a static method and we want to return an ienumerable collection of objects of type product dto to the calling code let's name our method convert to dto the first parameter in an extension method must be the type of an object on which we want to be able to call the convert dto extension method so by convention this parameter definition must also be preceded by this keyword so on an ienumerable collection of type product we want to be able to call the convert to dto method in order to convert an ienumerable collection of type product to an ienumerable collection of type product dto the logic for this method will using a link query join a collection of type product to a collection of type product category and return a collection of type product dto to the calling code so the second parameter of the convert to dto method is of a type that is an ienumerable collection of type product category let's write the logic for our extension method so let's write a link query that joins the collection of type product to the collection of type product category and return a collection of type product dto great so let's go back to the product controller class and finish the code for the get items action method so in order for the convert to dto method to be accessible on the products variable we must of course bring in the shoponline.api.extension's namespace then let's pass in the product categories variable as an argument to the convert to dto extension method then we can return a http status code of 200 to the calling code we can do this by returning the results of an ok method which accepts an argument of a collection of type product dto so this code returns a http status code of 200 as well as a collection of type product dto to the calling client code so if for some reason an exception occurs during the running of the relevant server side code in this case we want our code to return a http status code of 500 to the calling client code coupled with an appropriate error message let's keep the error message simple great so if we open our program.cs file you can see the configuration code here related to swagger and swagger ui swagger is an interface description language for describing restful apis expressed using json the configuration relevant to swagger ui here means that our web api project is equipped with a basic webbased user interface where we can see relevant information regarding our controllers and action methods we are also able to use the swagger user interface to test and debug our action methods when we run our web api code interactively through visual studio so let's run our code to see this in action and here we are presented with the swagger ui let's test our get items action method we can do this through our swagger user interface like this excellent in the next part of this video series we'll write the calling client code that calls the action method that we have written in this tutorial from our blazer component we'll also write the code to appropriately display the products returned from our web api component to the user so in the next tutorial we'll start to develop our blazer webassembly component so this is the third part of a video series where we are building a shopping cart application using blazer web assembly and web api we are building our application on.net 6 which at the time of writing this video is the latest version of net we are now at a stage where we have built our database using entity framework core code first migrations and have started implementing code for the first workflow which simply involves retrieving products data from our database and displaying this product's data to the user in part 2 the previous part of this video series we implemented the code that retrieves the relevant product data from our database and returns the data to the calling client this code was implemented in an action method within a controller class named product controller this class was created within our shoponline.api project which contains the code for our web api component in this video we want to start developing the code for our clientside blazer component so in this video we'll implement code within our blazer component to call the action method that we developed in the previous part of this video series and display the returned data to the user so let's get started the first thing we need to do is copy the url to our clipboards which is the url of our web api component when we run the shoponline.api project through visual studio we are doing this so that we can appropriately configure our blazer component to point to the appropriate local web api url so that we can easily test our application through visual studio during the development phase of our shopping cart application one way we can access the relevant url is to simply run our web api project so let's copy this part of the url which we can refer to as the base url or base address to our clipboards then let's open the program.cs class within our shoponline.web component so here is a block of code that was automatically included within our shoponline.web component whereby the http client object is configured for dependency injection this means that we will automatically have access to a http client object from appropriately written classes within our blazer component we will be using the http client object to call relevant action methods within our web api component so in order for our http client component to point to the web api component on our local machines we need to replace the argument that is currently being passed to the uri constructor here with the base url that we have just copied to our clipboards so let's appropriately paste the base url copied to our clipboards here great so we are going to wrap the functionality that handles calls to our web api component within services these services are simply csharp classes that wrap the functionality for handling interactions with our web api component so the first thing to do is create a folder named services then within the services folder let's create a folder named contracts let's create an interface named i product service within the contracts folder so we'll build up the methods for the product service class over time when appropriate during the development of our application we are just going to implement code for one method in this video so let's create a method definition for our method in the i product service file we want our method to run asynchronously so our method will return a task object in this case we are going to write code to return a generic task object because this method must return a value to the calling code the type of value that we want to return to calling code is an ienumerable collection of objects of type product dto let's name this method get items in a bit we'll implement code for this method to retrieve relevant product data from the appropriate action method that resides within our web api component we have a red squiggly line under product dto the product dto type is defined within the shop online.models project so let's create a project reference to the shop online dot models project let's then bring in the name space for the product dto type great okay so let's create the code to implement our i product service interface so let's create a class named product service directly within the services folder let's create a constructor so we want to tell dot net as it were that we want a http client object to be injected into our product service class so to do this we simply define a parameter of type http client within our constructor definition then let's generate a readonly member variable to reference the object of type http client that will be injected into this class at runtime the next thing to do is to implement the i product service interface so let's write the code for this let's generate the code stub for the method that we have defined within the i product service interface let's write the code logic for the get items method let's first generate a try catch block within the try block let's write code to call the get items action method that resides within the product controller of our web api component you can see we are using the generic get from json async method to call the appropriate action method within our web api component we are passing in a type argument which is an ienumerable collection of type product dto to the get json async generic method we are doing this because we want our get from json async method to return an ienumerable collection of type product dto so this method will translate the data which will be in json format returned from the web api component into an object of type i innumerable which is strongly typed with the type product dto notice that we are passing in texture which denotes where the collection of resources that we want to retrieve from our web api component can be found the web api component will know as it were to invoke the get items action method within the product controller class of our web api component based on this information passed as an argument to the get from json async method we have a red squiggly line under get from json async so to get rid of the error flagged by the csharp compiler we must bring in the system.net dot http dot json namespace this is where the get from json async extension method resides the get items action method that we are calling in our web api component will return a collection of objects of type product dto in json format the json data will automatically be translated into an i enumerable collection of objects of type product dto for us so our products variable here will reference the returned result which will be an ienumerable collection of objects of type product dto so we could add additional codes to handle the http response returned from the web api component we'll look at writing code for this when we look at exception handling in more detail in a later tutorial for now i just want to go through the basics of returning data from the web api component and displaying the data to the user from code created within the blazer web assembly component so now we are going to create our razor component where we will create the code to display the data to the user i.e the data returned from the service functionality we have just created razer components are fundamental to blazer simply put blazer apps are built using razer components so within the pages folder let's create a razor component named products.razer note that we are able to create our code to call our service functionality directly within our razer file within the code section here in the interests of creating cleaner code we are going to abstract the code for consuming our service functionality within a base class our raiser component will then inherit from the appropriate base class so let's create a csharp class named products base so in order for our base class to be inherited from our razor component our base class must inherit from a class named component base which resides within the microsoft.asp.net core dot components namespace so let's go to our razer file we want our products.razer component to be invoked when our application is first loaded so we can ensure that this happens by declaring information about our razor components root at the top of this page like this note that when a razor component with an at page directive is compiled the generated component class is provided a root attribute specifying the component's root template here we are just providing a forward slash this means that when the url contains only the base url for our blazer component that our products dot razor component will be invoked and now we can write code within our razor file that declares that our products.razer component inherits from the product base class like this so let's go back to our product space class let's create a property to facilitate dependency injection of an object of type i product service into our products razor component so let's define a public property of type i product service named product service so to indicate to.net that we want an object of type i product service injected into this property we need to decorate the appropriate property with the inject attribute like this and of course we mustn't forget to register our product service class for dependency injection so to do this let's open the program.cs class and implement the relevant dependency injection configuration code like this great let's create a public property to expose an ienumerable collection of objects of type product dto this collection will be accessible to the relevant razor code that we'll implement in a bit to output the product data so now we want our code that retrieves our product data from the server our web api component to run when the product's razor component is first invoked we can do this by overriding a function named uninitialized async so to override a method we can type override press the spacebar and then select the method that we wish to override we want to override a method named on initialized async so let's select the appropriate item here the on initialized async method is associated with a blazer lifecycle event let's read a little bit about lifecycle events on this microsoft docs webpage the razer component processes razer component life cycle events in a set of synchronous and asynchronous life cycle methods the life cycle methods can be overridden to perform additional operations in components during component initialization and rendering if the component is rendering for the first time on a request create the components instance perform property injection run set parameters async call on initialized async if an incomplete task is returned the task is awaited and then the component is rendered so within the uninitialized async method let's implement the code for retrieving our products data from our web api component like this we are using the object of type i product service that will be injected into this class at runtime to return the relevant products data to our product component let's implement code for outputting the product data so if the product property is null ie has not yet been retrieved from the server we can output a loading indicator to the user so while the data is being retrieved this loading indicator will remain on the user's screen else when the relevant product data has populated the products property we want code to execute that outputs the product's data to the user in an aesthetically pleasing style let's bring in the namespace of our product dto class we can include this using directive in the underscore imports.raiser file here and this means that this using directive will apply to the other razer files as well let's write a link query here that sequentially takes four items at a time from the collection of product dto objects images relevant to each of the products has been uploaded to github please feel free to download these images each image maps to a row of data in the products table in our database we seeded our database with the relevant data in the first part of this video series let's then implement code to appropriately output the product data bootstrap 5 is being used to output each item of products data as a bootstrap card later we are going to abstract this code further to clean up the code a bit the final code for this functionality is available on github the appropriate link can be found below in the description for now i just want to write code to display our product data appropriately to the user it was pointed out in the comments section that my spelling of the word furniture is incorrect both in the shop online db context class and the sidebar in the prototype shopping cart application that i created in preparation for this video series i don't know why i spelled furniture with an a like this for nature but clearly that's what i did the consequence is that after you ran the migration to create and seed your database the word furniture may be incorrectly spelt in your product database table and your products category database table of course you may have spotted this and fixed this before creating and running the relevant migration if not the good news is that this is easy to fix i thought that fixing this issue gives us a great opportunity to see how easy it is to fix issues like this during the development phase of our application using ef core migrations we can fix the relevant data simply by correcting the spelling issue within the on model creating method in the shop online dbcontext class we can then generate a migration that will contain the code that can be used to update the database with the relevant fix so if you ran your migration where the word furniture was spelt incorrectly within the on model creating method of your shop online db context class please follow along with these steps to fix the issue within your database please note that the appropriate spelling fixes regarding all instances of the word furniture have been uploaded to the relevant github repository of course the link to the relevant repository is included below in the description so let's open the shop online db context class that can be found in the data folder within the shoponline.api project let's go to the on model creating method so let's press ctrl f so that we can perform a find and replace on the incorrectly spelt word furniture okay clearly i can't even make the excuse that this was a typo look at how consistent i've been in spelling the word furniture wrong right let's replace the incorrect spelling of the word furniture with the correct spelling of the word furniture so eight occurrences and here are some instances where our find and replace did not fix the spelling because our search was matching the whole word so let's amend the relevant image file name references for these particular instances of course make sure that furniture is spelled correctly for the relevant furniture folder and the relevant image files on your local machines i did correct the spelling issue before i uploaded the image files to github so your file system should contain the correct spelling from when you downloaded the relevant files from github we can now invoke the package manager console window from within visual studio and create a migration to fix our issue so let's create a new migration by typing in the add dash migration command and you can see that the appropriate code to fix the relevant data in our database is generated for us in a new migration class if we are happy with the relevant migration code we can run the update database command to fix the relevant data in our databases so let's do that great so we are now ready to run our code in order to run both the web api component and the blazer component simultaneously through visual studio we can configure the shoponline.api project and the shoponline web project to start up at the same time like this but we want the shoponline.api project to start a little bit earlier before we run our code let's delete the index.razer file from within our pages directory this razer component is also configured with the same route as we have configured for our products razer component and we are not going to use the index raiser component that was generated by default in our application so now when we first run this code we are actually going to get an exception i'll explain why in a bit and then we'll take steps to resolve the issue let's press the play button to run the code you can see here that we have an exception coming from our blazer component if we press f12 while our chrome browsers are active we can examine the relevant error message here the exception is caused as a result of cause or crossorigin resource sharing crossorigin resource sharing cause is a http headerbased mechanism that allows a server to indicate any origins domain scheme or port other than its own from which a browser should permit loading resources basically this error occurs because our blazer component has a different base url to our web api component as a result of this a security barrier prevents us from being able to access the relevant resources returned from our web api component let's copy the base url for our blazer component to our clipboards you'll see why we are doing this in a bit we are able to configure a policy within our web api project to explicitly allow for our blazer components to access relevant resources so to do this let's open the program.cs file within our shoponline.api project and include the relevant course policy code like this so where you see the urls in this block of code please paste the base url for your blazer component for the relevant url arguments note that we can configure both the http version of our url and the https version of our url in this course policy code and please ensure that you don't include a forward slash character at the end of these url arguments great let's run the code again excellent we now have our product data appropriately displayed to us when we first load our application so all is working fine but if we look at our product dot raiser file we can see that we have written quite a lot of code here we can make this code that outputs a row of products reusable by abstracting this code into its own component its own razor component by abstracting this code into its own razor component we are not only allowing for the relevant code to be reusable by other razer parent components we are also creating cleaner code so to do this we can create a child razor component to house the code that outputs the relevant product data so let's create a razor component named displayproducts.razer let's create a csharp class named display product base which will of course be the base class for our displayproducts.razer component let's make our display products base class inherit from the component base class we want a parent razor component to be able to pass an i innumerable collection of objects of type product dto to our display products razer child component we can achieve this by creating a parameter property within our display products base class like this it is important to note that a parameter property is decorated with the parameter attribute let's go to the display products.razer file and implement code to inherit from our display products base class then we can go to our products.razer file and cut the relevant code and paste it into our display products.razer file like this then we can modify the code appropriately so that the code within the display products.razer file is traversing the i enumerable collection passed to the display products child razor components products parameter a child component cannot be accessed directly through a browser and therefore does not contain a root declaration a child razor component must be invoked from within a parent razor component so let's go to the product's parent razor component and call the child display products child component through this declarative code notice how we are able to pass the relevant collection of objects of type product dto to the products parameter that we defined within the display products child component and the code for calling the child razor component from the parent razor component is very much like typical html code by abstracting the code for displaying a list of products to the user into a child razor component we have created cleaner code facilitated easier code maintenance and the display products child razor component can be reused from within other parent components this will be demonstrated in a later tutorial let's run the code great so let's say that a requirement arises where we need to display each product item under its appropriate product category so to answer this requirement we can create an appropriate link query to group our objects of type product dto by product category like this we can also include a category heading for each group of products and of course each row containing the grouped products must reside within the loop like this let's also include a dividing line between each product group let's run the code great we can clean up this code even further by abstracting the relevant link code within the appropriate base class like this great and let's say that we only wish to display four items for each product category we can achieve this by using links take extension method like this excellent the last thing i'd like to do is add basic animation effects to each of the bootstrap cards we are using to represent our products so to add a css class that only applies to a particular razor component we can add a style sheet with a name that adheres to a specific naming convention so let's add a css style sheet to the pages directory and let's name the stylesheet displayproduct.razer.css this naming convention ensures that the styles contained within this file will only apply to the displayproducts.razer component which is the component that outputs the bootstrap cards that represent our products this tutorial is not about css so i've preprepared the relevant css code so i'm just going to paste the relevant code into the display products dot file here this code is of course accessible from within the relevant github repository let's run the code and you can see that when we hover our mouse pointers over a card the relevant image scales and a box shadow appears these basic animation effects have been included to enhance the user's ux excellent so this is the fourth part in a series of videos dedicated to building a shopping cart application on.net 6 using blazer web assembly and web api we have now created our first workflow which involves retrieving product data from the database and displaying the data to the user in an aesthetically pleasing style we have built our database using entity framework core we have implemented code using the repository design pattern within a web api component in order to return products data from our database to a calling client in the last part of this series part three we implemented code for our blazer webassembly component to call an appropriate action method within our web api component using a http get request in order to retrieve product data from the server and display the data to the user in an aesthetically pleasing style we want to create functionality to retrieve data for a specific product from the server and display the details of that product to the user so when the user clicks on a particular product only the details for that specific product are displayed to the user the user can then decide whether or not to add the product to the user's shopping cart a button will be provided within the razer component responsible for displaying the relevant products details whereby a user can click this button and add the relevant product to the user's shopping cart we'll implement the code for the add to cart button in the next tutorial so let's go to the web api component let's open the product repository class and go to the get item method you can see that currently we have a default implementation for this method which was created when we generated the code stubs through visual studio of the i product repository interface that we are implementing in the product repository class so as the name implies the get item method returns data regarding a single item so we can use the find async method to retrieve the data pertaining to the product that matches the id value passed into the get item method through code like this the next step is to expose the functionality to a calling client by implementing code that gets executed in reaction to an appropriate http get request so we want the get item functionality to execute when a calling client makes an appropriate http get request for product data that can be identified in the system with the id value passed to our web api component from the calling client we can implement code that creates an appropriate http response through creating an action method within our product controller controller class so let's create a method within the product controller class to return data for a particular product to speed things up let's duplicate the get items action method that we created in the second part of this series and change the code appropriately so as to implement the functionality for the get item action method we only want to return data for one object of type product dto rather than an i enumerable collection of objects of type product dto to the calling client so let's change the return type appropriately let's include a parameter named id which is of type integer this id parameter denotes the id value of the product data for which the client wishes to have returned from our web api component within the http get attribute let's include the appropriate root template information our get item action method contains a parameter of type integer named id so for the get item action method it is appropriate to pass in an argument of type string to its corresponding http get attribute that denotes the appropriate root template for this action method so let's use the product repository object passed into our controller class via dependency injection to call the getitem method that we have just implemented within the product repository class so if the returned value is null this means that the resource does not exist so let's pass a response to the calling client that includes a bad request status code we can do this in code by returning the result returned from the bad request method like this so let's say we also want to include the name of the category under which the relevant product falls in the returned object as we know we only have the id of the category under which the returned product falls within the product entity we don't have the facility to store any other information pertaining to the products category within the product entity so we need to write code to get the category information from the product category entity we can then include the product information and the category information in an object of type product dto and return the relevant object of type product dto to the calling client so let's implement code for the get category method within the product repository class to retrieve data for our specific category based on the category id passed into this method let's then write code within our get item action method to appropriately call the get category method on the object of type i product repository like this the next step is to write the code that merges the data pertaining to a specific product with the data pertaining to the relevant products category into one object of type product dto in order to write the code for this in a clean way we can create a convert to dto extension method overload within our dto conversions class so the convert to dto extension method currently within our dto conversions class converts a collection of products and a collection of product categories appropriately into a collection of objects of type product eto and returns the collection of objects of type product dto to the calling code we want our new convert to dto extension method overload to convert one object of type product and related object of type product category into one object of type product dto and return the subject of type product dto to the calling code this is basically so that we can include the relevant product data and the category name within one object our product dto type facilitates this so we can write code to perform the relevant conversion like this we can now go to our get item action method and call the convert to dto extension method which is now available on this object of type product to return the appropriate object of type product dto to our action method we can then write code to return a http status code of 200 okay along with the relevant object of type product dto to the calling client by appropriately returning the result of the ok method and passing in the appropriate object of type product dto to the ok method if an exception occurs for some reason during the execution of the get item action method we have code here that will return a http status code of 500 denoting an internal server error to the calling client along with an appropriate error message great so let's write code within the blazer component to make an appropriate http call to the server side code that we have just implemented so let's open our i product service interface let's include a method definition for a method where we will implement the code to call the get item action method on the server we want this getitem method to run asynchronously so we are returning a task object the getitem method is returning a value so we must pass the return type as a type argument to the generic task type here this method contains a parameter of type integer and is named id this id parameter denotes the id value that is used to identify a specific product so let's implement the get item method in the product service class let's generate a try catch block in the previous part of this series part 3 we implemented code for the get items method that uses the http client objects get from json async method to call the relevant server side action method this method calls the relevant action method but also handles translating the returned json data into the appropriate objects type i'm going to use the get async method to call the relevant action method in our get item method this method doesn't convert the returned json data to the appropriate object type we need to write code for this separately we'll do that in a bit the get async method returns a http response object so we can use the returned object to first ascertain as to whether our http request to the server was successful so this code checks that the relevant status code falls within the success range so if the call is successful we want code to execute that checks if our http request has returned a response with content if there is no content returned from the server we want code executed that returns the default value associated with the product dto type like this so the c sharp default value for a user defines type which is a reference type will be null so this is just the way i'm choosing to handle the scenario where the call to the server is successful but for some reason no data is returned from the server so when the call is successful and content is returned from the server we want code to execute that translates the json data returned from the server into an object of the appropriate type else if the call to the server is not successful we want code to execute that handles the exception so here we are just going to throw the exception at this point and we can pass the message sent back from the server as an argument to the exception object like this within the catch block we could implement codes to log the exception or handle the exception in an appropriate manner that we choose let's implement appropriate code within the get items method to also include exception handling functionality so let's create a razor component within the pages folder let's name this component productdetails.razer so this is the component where we'll implement the code to display details regarding a specific product let's create the base class for our product details component and let's name this component product details base let's implement the code for our product details base class we want the id parameter that denotes the identifier for a specific product to be passed into the component so let's create a parameter named id that is of type integer we need to decorate this property with the parameter attribute we also need to ensure that our base class inherits from the component base class so we want an object of type i product service to be injected into our product details component so we can do this by including a property within our base class of type i product service and decorate the relevant property with the inject attribute let's include a property of type product dto within our base class and let's name this property product let's include a string property to store an exception message so we want code to execute when our blazer component is first invoked so we can ensure that this happens by writing the relevant code within a method that overrides the uninitialized async method to generate the appropriate uninitialized async method let's type in override followed by pressing the space bar and then let's select the appropriate method from the list presented to us let's generate a try catch block within the try catch block let's appropriately call the get item method on the injected object of type i product service the returned value is assigned to our product property which we can then access from our product details.razer file if an exception occurs we want the exception message to be assigned to the error message property let's implement code to output details regarding the relevant product so let's ensure that we include the appropriate root template at the top of the file we can use the page directive for this purpose and notice how we are including the id parameter here this is because an appropriate id parameter must be passed to this razor component when this razor component is invoked let's write the code logic so while the product property is null and the error message property is null we want a loading indicator to be displayed to the user else if an error occurs in which case the error message property will not be null we want the error message to be displayed please note that for the sake of this example we are writing functionality to display the error message returned from the server to the screen in a complete application it would be more appropriate to output a userfriendly nontechnical error message to the user and log the actual error message returned from the server else we want to output the details of the relevant product in an aesthetically pleasing style to the user and of course bootstrap 5 classes are being used here to output the data in an aesthetically pleasing style great then let's go to the display products.razer file and include the appropriate value for the href attribute within the anchor tag that wraps the cards that represent the products sold in our online store so we want this link to invoke the product details razer component we need to include the appropriate id value denoting the identifier for a specific product within our href attribute value here let's run the code great let's abstract the code that outputs an exception to the user in its own razor component so that we can reuse this component from within multiple parent razor components this is also a cleaner way of implementing the code that displays an error message to the user let's write code to force an exception to occur so we know that a product with an id of 1000 does not exist in the system so in this case the server will send back a response code indicating that a bad request has been made let's run the code great lastly it would be better in terms of a user's ux if an appropriate animated loading indicator was displayed to the user while the user is waiting for data to be displayed so if we navigate to this site here we can copy the relevant html and css code for an animated loading indicator of our choice these loading indicators here can be used within our application free of charge so let's select this one let's copy the html and the css code for the loading indicator of our choice and integrate the code within our application the cleanest way to integrate this code into our applications in my opinion is to abstract the loading indicator code within a razor component as discussed in the previous part of this series part 3 we are able to create a css file that only applies to its corresponding razer component by naming the relevant css file in a way that adheres to a specific naming convention so if the name of the razer component is display spinner we can create a css file that will only apply to this razor component by naming the relevant css file display spinner.razer.css so we can now reuse the spinner functionality for multiple parent components i look forward to presenting the next video in this series where we'll create the functionality for adding products to a shopping cart this is the fifth part in a video series dedicated to building a shopping cart application using blazerwebassemblyon.net 6. so we have completed the implementation of two workflows the first workflow involves retrieving the data pertaining to the products sold by our online store and displaying the data in an aesthetically pleasing style to the user the second workflow involves displaying details for a particular product to the screen in response to the user clicking on a card representing the relevant product in this video we'll create the functionality whereby the user clicks the add to cart button which is available on the screen where details for a particular product are displayed this button click action will result in the relevant product being added to the user's shopping cart after the user has clicked the add to cart button the user will subsequently be navigated to a screen that displays data pertaining to the products currently contained within the user's shopping cart so let's get started so let's first implement the functionality for the server side code so let's go to our project that contains the functionality for our web api component in the second part of this video series we implemented the repository design pattern for functionality to handle database interactions regarding the products sold by our online store so we now want to create the code for handling the database functionality pertaining to the shopping cart so let's create an interface that contains the method definitions for the shopping cart repository class that we'll create once we have created its interface so let's create an interface named i shopping cart repository let's create a method definition for a method named add item as the name suggests the code that we'll implement for this method will add a particular product to the relevant user's shopping cart let's add a method definition for a method named update qty when a user first adds a product to the user's shopping cart the quantity of the relevant product added to the user's shopping cart will be won by default the implementation for this method will involve updating the quantity of a particular product that is currently contained within a user's shopping cart let's add a method definition for a method named delete item as the name suggests the functionality for this method will involve removing a particular product from the user's shopping cart the get item method will contain functionality for retrieving data regarding a particular product that is currently in the user's shopping cart the get items method will contain functionality for retrieving data for all the products that are currently in a particular user's shopping cart so let's create a class named shopping cart repository let's write codes to implement the i shopping cart repository interface that we have just created let's position our mouse pointers appropriately and press control period in order to bring in the appropriate namespace ie where the i shopping cart repository interface resides let's press control period and generate the code stubs for the method definitions that we included within the i shopping cart repository interface so in this video we are going to implement functionality for three of the methods that we have defined within the i shopping cart repository interface namely add item get items and get item before we do this let's create a constructor let's add a parameter to our constructor that is of type shop online db context by including this parameter we are indicatingto.net that we want an object of this type injected into our shopping cart repository class at runtime we have already registered the shop online db context type for dependency injection the shop online db context type is the ef core database context object that is used for handling data manipulation and data retrieval functionality in relation to our applications database so let's implement the functionality for the add item method let's first write a link query that ensures that the product that the user is attempting to add to the user's shopping cart exists in the products table so if the item returned from our link query is not null we want code to execute that adds the relevant product to the cart items database table this denotes that the product has been added to the user's shopping cart so let's implement the code to add the item to the cart items database table once we have called the add async method we must also remember to call the save changes async method then we can write code to return the entity that has been successfully added to the cart items database table like this if an item is not successfully added to the database we want code to execute that will return null to the calling code so in order to avoid a product being added twice to our user's shopping cart let's implement code that checks to see if the relevant product already exists within the user's shopping cart let's implement the code for this in a private method that returns a boolean value then we can use the private method we have just created like this to perform the relevant check so we have ensured that only one instance of a particular product can be added to the user's shopping cart please note that the user will be able to purchase more than one instance of a particular product by appropriately modifying the qty or quantity field we'll implement this at a later stage let's implement the code for the get items method let's write code that returns the results of a link query pertaining to the products currently stored within the user's shopping cart then let's write code for the get item method let's write code that returns the results of a link query which is data pertaining to a particular product currently stored within the relevant user's shopping cart let's add a controller class to the controllers folder let's name this controller class shopping cart controller firstly let's create a constructor that contains two parameters one of type i shopping cart repository and the other of type i product repository let's create two readonly fields to reference the objects that will be injected into our controller class at runtime let's of course not forget to register the i shopping cart repository type for dependency injection so let's implement the code for the get items action method let's use our shopping cart repository object to return the items currently stored within the relevant user's shopping cart if no items are contained within the shopping cart we want code to execute that returns a http response of no content to the calling client this is denoted by a http code status of 204 so this means the client http request was successful but no items related to the client's request are present in the system therefore no content can be returned to the calling client so we are returning a collection of type can't item dto to the client from the action method we have just written code that retrieves a collection of objects of type cart item we want to return a collection of objects of type can't item dto to the calling client the cart item dto type contains additional data regarding the relevant product we don't have the additional data at this point so let's use the product repository object to retrieve a collection of objects of type product we can then write code to join our collection of card item objects with the collection of objects of type product using a link query and return an appropriate collection of objects of type can't item dto to the calling client so let's keep this code clean and implement a linq query in an extension method to return the relevant collection of objects of type cart item dto to the get items action method before we do this let's write code to throw an exception if no products exist within the system because if there are no products in the system and the user is attempting to add a product to the user's shopping cart well this won't make any sense so this means an exception has occurred let's write code in a catch block that returns a http status code of 500 to the calling code so if for some reason an exception occurs during the execution of the get items action method we want an internal server error 500 http response to be returned to the client so let's go to the dto conversions class and implement another extension method overload named convert to dto we'll be able to call this extension method overload on an i enumerable collection of type cart item to perform the relevant conversion functionality let's go to our get items action method and call the extension method we have just created to return the appropriate collection of objects of type cat item dto we can then write code to return this collection to the calling client with a http response status code of 200 okay let's implement the code for the get item action method you can see here that the code is very similar to the get items action method but we of course are only returning one item of type cart item dto to the calling client instead of a collection of objects of type cart item dto so let's write code for converting an object of type card item to an object of type cart item dto to do this let's go to the dto conversion class and implement the code for the appropriate extension method overload we can then call the relevant convert to dto extension method on the relevant object of type cart item to perform the appropriate conversion functionality let's write the functionality for handling a post request from the client whereby a user is attempting to add a product to the user's shopping cart so let's write code to call the add item method on the shopping cart repository object that will be injected into our controller class at runtime we want to return the newly added item of type cart item dto to the calling client so we can call the same conversion code that we implemented for the get item method for this purpose it is important to note that it is standard practice for a post action method to return the location of the resource where the newly added item can be found this location will be returned in the header of the http response returned from this method we can use the create at action method to ensure that we are adhering to this standard practice so the relevant resource can be found at the uri universal resource identifier pertaining to the get item action method and we are including the id of the newly added resource here and for the final argument we are including the newly added object which we have now converted to type cart item dto if you'd like to read more about the create at action method i've included an appropriate link below in the description and we of course need to decorate this action method with the http post attribute let's run the shoponline.api project through visual studio and you can see the new action methods and relevant dtos are present on the swagger ui web page great let's implement the relevant code for our blazer component so let's go to the shoponline.web project let's create a new service class where we'll implement code that interacts with the action methods that we have created within our shopping cart controller class in our web api project firstly let's create the appropriate interface in the contracts folder for the relevant service class let's name this interface i shopping cart service let's create a method definition for the get items method and the add items method let's create a class named shopping cart service let's generate the code stubs for the methods defined within the i shopping cart service interface let's create a constructor for the shopping cart service class let's include a parameter of type http client as a parameter within our constructor this parameter indicates to.net that we want an object of type http client injected into this class at runtime let's implement the code for the add item method so basically this code calls the post action method that we implemented in the shopping cart controller class if the response http status code is within the success range let's check to see if any content was returned if no content was returned let's return the default csharp value for the cart item dto type to the calling code which will be null if content was returned from the server let's return the object representing the newly created shopping cart item to the calling code this will of course be an object of type can't item dto let's include the relevant exception handling code let's implement code for the get items method so i'm deliberately including an incorrect uri universal resource identifier reference here so that this will force an exception when we run the code we'll fix this a little bit later after we have run the code that tests how an application handles the relevant exception this code simply places a http get request to the get items action method and if content is returned returns the relevant content to the relevant razer component i.e the calling code let's go to the product details base class and implement a button click event handler method for the add to cart button let's name this click event handler method add to cart underscore click let's make sure that we have registered the i shopping cart service type for dependency injection let's implement code that ensures that an object of type i shopping cart service is injected into the product details base class at runtime then our code within the add to cart underscore click event handler method calls the add item method on the injected shopping cart service object to add a product chosen by the user to the user's shopping cart let's go to the product details.razer file and implement the code that calls the add to cart underscore click event handler method so we have started with the implementation of the shopping cart functionality we have not implemented user registration or login functionality ie membership functionality in this application we could implement codes to bring down user related information from the server when the user first logs onto the system the information could include the user's user id and the user's cart id so because we haven't implemented login functionality let's temporarily hard code the user's cart id and user id in a class within the project that contains our blazer functionality so that we can progress with the implementation of the shopping cart functionality so in the first video in this series we seeded the data with data for two users so let's say that we are going to run the code from the perspective of the user that has a user id of one and a cart id of one so we can now pass in the hardcoded cart id value here along with the relevant product id and a quantity of one when a user adds a product to the user's shopping cart by default one instance of that product is added to the user's shopping cart let's strategically add some breakpoints in the blazer project and the web api project and run the code and let's invoke the functionality for the workflow that we have just implemented incurred by clicking a product that we wish to add to the shopping cart and then let's click the add to cart button great if we look at the cart items database table we can see an item has been appropriately inserted into the relevant table let's test this again great let's create a razor component that will be responsible for rendering a collection of products data pertaining to products that have been added to the user's shopping cart to the screen so let's add a razor component named shoppingcart.razer let's add a base class for the shopping cart razor component let's name this class shopping cart base let's implement code for the shopping cart base class so our shopping cart base class must inherit from the component base class because we want this class to be the base class for the shopping cart raiser component let's write code for injecting an object of type i shopping cart service into our class at runtime let's include a property for referencing a collection of objects of type cart item dto this property will be used within the shoppingcart.razer file for code that displays the relevant data to the screen let's create the code to override the uninitialized async method where we'll implement code for assigning the relevant collection of items returned from the server to the shopping cart items property when the razer component is first rendered great let's implement the code for the shoppingcart.razer file let's include the page directive at the top to declare the root template for our shopping cart razor component let's use the inherits directive to ensure that we are using the shopping cart base class as the razer components base class so while the shopping cart items property is null and the error message property is null we want a spinner loading indicator to be displayed to the user if the error message property is not null we want the relevant error message to be displayed to the user else we want code to run that displays in an aesthetically pleasing style the data representing a collection of products that have been added to the user's shopping cart we are using bootstrap 5 classes for styling the html elements in our razer file now that we have written the code for displaying a collection of products data for products added to the user's shopping cart let's write code that navigates the user to this screen after the user clicks the add to cart button so let's go to the add to cart underscore click event handler method within the product details base class and implement the relevant code so we can use an object of type navigation manager to navigate the user to the relevant screen so let's write code to ensure that an object of type navigation manager is injected into our razer component at runtime let's then invoke the navigate to method on the navigation manager object to navigate the user to the shopping cart screen let's run the code and an error message is displayed to us this is because we are forcing a 404 not found error to occur at the moment we have included an incorrect path to the end point that returns the collection of card item dto objects within the get items method of the shopping cart service class we need to appropriately include a reference to the shopping cart controller name within this uri reference so let's correct this uri universal resource identifier by appropriately including the relevant controller name here great this is the sixth part in a video series dedicated to building a shopping cart application using blazerwebassemblyon.net 6. so we have created three workflows let's recap the first workflow involves retrieving products data from the database and displaying the products data to the user in an aesthetically pleasing style the second workflow involves retrieving details for an individual product and displaying the relevant details in an aesthetically pleasing style to the user the third workflow involves the user adding a product to the user's shopping cart and the user being navigated to a screen that displays a list of products contained within the user's shopping cart in this video we'll create the workflow that involves a user removing a product from the user's shopping cart let's get started let's start by implementing the server side code let's go to our shoponline.api project and open the shopping cart repository.cs file let's implement the code logic for the delete item method so we can use the id value that will be passed into this method to find the entity that we wish to delete from the cart items database table we are using the find async method to find the relevant entity using the primary key field which is the id field if we find the relevant entity if the item returned from the find async method is not null we can use the remove method to remove the relevant entity from the cart items database table then we mustn't forget to call the save changes async method to commit the relevant change to our database in order to make this delete functionality available to calling client code let's create an appropriate endpoint within our web api component so let's go to the shopping cart controller class and create an appropriate action method that will call the relevant delete item method that we have just implemented in the shopping cart repository class let's decorate our delete item action method with an attribute that declares that this action method corresponds to the http delete verb so far in the development of our application we have created endpoints that correspond to both the get and post http verbs we are about to implement the logic for an endpoint that corresponds to the delete http verb let's declare the relevant root template information for our action method by passing an appropriate string argument to the http delete attribute this information includes a definition for the id that needs to be part of the uri universal resource identifier pertaining to the entity that a client wishes to delete so we are essentially enabling a calling client to delete a specific resource from the system let's create a try catch block a simple way to create the relevant code for this is to type try followed by pressing the tab key twice let's call the delete item method on the shopping cart repository object that will be injected into the constructor of this controller class at runtime if the entity that the client wishes to delete cannot be found we want code to execute that returns a http response code of not found 404 to the client the information that we want transferred across the network for the relevant entity that the client wishes to delete is of type can't item dto and not the type cart item that is returned from the delete item method called on the shopping cart repository object in the previous part of this video series part 5 we implemented an extension method overload named convert to dto within the dto conversions class this extension method can be called on any object of type cart item before we appropriately call the convert to dto extension method we must retrieve the relevant product entity from the database so let's write the code to achieve this then let's call the convert to dto method on the object of type cart item returned from the shopping cart repository classes delete item method to convert the relevant object of type cart item to an object of type cart item dto then let's write code to return a http response code of ok200 to the client along with the relevant object of type cart item dto let's complete this method by writing code that executes if for some reason an exception is thrown during the execution of the code logic within the delete item action method let's go to our blazer component so let's go to the shoponline.web project let's add an appropriate new method definition to the i shopping cart service interface named delete item let's open the shopping cart service class and implement the code logic for the delete item method if the http response code returned from the server falls within the success range we want code to execute that returns an object of type can't item dto to the calling code if the call to the server is not successful we want null to be returned to the calling code let's open the shopping cart base class within the pages folder let's implement code for a method that handles a button click event so this method will be called when a user clicks a delete button that we'll create in a bit in the shoppingcart.razer file let's appropriately call the delete item method on the shopping cart service object that will be injected into our razor component at runtime so this code will call the appropriate action method on the server side that will delete the relevant entity cart item from our database so we want the results of this deletion operation to be reflected on the user interface which means we need the shopping cart razor component to rerender once the deletion operation has completed successfully we could call the appropriate get items method and retrieve all the relevant shopping cart items that are currently saved to our database for the relevant user and assign the results to the shopping cart items property and the result of the deletion operation would then appropriately be reflected on the ui however we can implement code for a solution that will be more performant for this purpose than the solution that i've just expressed i.e that involves an additional call to the serverside code we can reflect the results of a deletion operation on the ui by simply deleting the relevant cart item object from the client side collection of card items referenced by our shopping cart items property by deleting the relevant item from the client side collection we are avoiding a trip as it were to the server side this could result in a significant performance benefit so let's create a private method responsible for removing the relevant item from the client side shopping cart items collection we first need a variable that references the object within the shopping cart items collection that we wish to delete so let's create another private method that contains code for returning a specific object within the shopping cart items collection let's then call our new private method to return the object that we wish to delete from the shopping cart items collection to our remove card item method we can then implement code to delete the relevant item from the relevant clientside shopping cart items collection but there is a problem with this at the moment our client site collection stored within the shopping cart items property is currently of type i enumerable the i enumerable type is fine for when we need to traverse through the items in the relevant collection but we don't currently have an easy way available to us to remove an item from the relevant clientside collection one solution to this problem is that we can change the type of our client side collection to type list we must also appropriately change the return type of the delete item method definition in the i shopping cart service interface and of course we must also appropriately change the return type for the implementation of this method in the shopping cart service class let's go back to the shopping cart base class and use the remove method on the shopping cart items collection which is now of type list to remove the relevant item from the relevant client side collection let's appropriately call our remove cart item method from within the delete cart item underscore click event handler method let's create the delete button within the shoppingcart.razer file let's use blazers at on click syntax to ensure that our delete can't item underscore click functionality is triggered when the user clicks our new button let's run the code and test our method great okay so i don't like this empty screen displayed to the user here when the user no longer has any cart items saved to the user's shopping cart so let's ensure that status information is outputted to the user for the case where the user's shopping cart is empty so we can do this by using the count method so if the count method returns a value greater than zero we can output the data contained within the shopping cart items property as well as the relevant shopping cart summary information else let's output a basic message to the user informing the user that the user's shopping cart is empty let's run the code great so i think rather than display the text remove on the relevant button i think the standard trash icon would look better let's use font awesome for this purpose i'm going to use an appropriate cdn cloud delivery network link to reference the relevant font awesome css file so if we go to this website we can copy the relevant link here and we can then paste it into our index.html file in order to include font awesome icons within our application we are now able to reference the font awesome trash icon like this to display the trash icon on our delete button excellent i hope you've enjoyed this video i look forward to presenting the next video in this series where we'll continue to develop our shopping cart application we are going to implement the update quantity functionality in the next video this is the seventh part of a video series dedicated to building a shopping cart application using blazerwebassemblyon.net 6. so in the previous part of this series we created functionality whereby a user can delete an item from the user's shopping cart in this video we are going to create the functionality whereby a user is able to update the quantity of a particular product that has been placed within the user's shopping cart a notable feature that we'll add is the showing and hiding of the update qty button so we only want the update qty button to appear when the user changes the appropriate value in the field denoting the quantity of a particular item in the user's shopping cart when the relevant field is changed the relevant update qty button appears once the user has clicked the update qty button to update the quantity of a particular item in the user's shopping cart we want the update qty button to disappear to achieve the appropriate showing and hiding of the update qty button we are going to invoke a javascript method this brings us to an important question how do we integrate javascript into our blazer webassembly component in this video we are going to look at how we can use blaze's javascript interoperability feature to interact with javascript code from within our blazer webassembly component we'll implement this functionality toward the end of the video so please stick around to the end to learn about javascript interoperability with blazer to start with let's create the serverside code for the update qty functionality so let's get started let's go to the shoponline.api project let's open the shopping cart repository class let's implement the code logic for the update qty method first thing to do is reference the item that we wish to update so if we are able to find the relevant item within our database and therefore the item variable will not be null we can then update the qty field with the value passed in from the client and to commit the change to the database we must of course call the save changes async method let's write code to return null to the calling client for when the item is not found within the database let's expose the update quantity functionality to our calling client through an action method let's open the shopping cart controller class let's create an action method named update qty let's appropriately call the update qty method on the shopping cart repository object to update the relevant resource with the qty value passed into our action method by the client let's use our convert to dto method to appropriately convert the cart item object into an object of type cart item dto we can then write code to return the relevant object of type cart item dto to the calling client along with the http code status of 200 ok let's include the appropriate exception handling code so we have so far created action methods that correspond to the http get verb the http post verb and the http delete verb the other two most common http verbs are the http put verb and the http patch verb the http put verb and the http patch verb are both associated with the performance of resource updates the difference between these two http verbs is that the http put verb is associated with action methods that modify a resource where the client sends data that updates the entire resource the http patch verb however is associated with action methods that partially update the respective resource so we want our update qty method to update only the qty field for a cart item resource so this means it is appropriate to associate our update qty action method with the http patch verb we can write declarative code to indicate that this action method is associated with a http patch verb to do this we can appropriately decorate the update qty action method with the http patch attribute like this note that we are passing in data to the http patch attribute that provides necessary route template information this indicates that the uri for the relevant endpoint must appropriately contain the id of the resource that the client wishes to modify right let's write the appropriate code for the blazer component so let's go to the shoponline.web project let's open the i shopping cart service class let's open the shopping cart service class to implement the code logic for the update qty method let's first serialize the dto that we wish to pass to the server into json format let's create an object of type string content so that we can appropriately pass the relevant data in the appropriate format to the server let's call the patch async method on our http client object and pass in the appropriate uri as well as the relevant data to the patch async method if the http response status code falls within the success range let's include code that returns the appropriate data returned from the server to the calling code let's go to the shopping cart base class let's create a method that will handle the update qty button click event so the calling code will pass in the id of the shopping cart item that the user wishes to update as well as the relevant quantity value if the quantity value is greater than zero meaning that the quantity or qty field value is valid we can appropriately call the update qty method on the shopping cart service object to call the relevant server side code in order to update the database appropriately else if the calling code passes in an invalid quantity let's set the quantity field for the relevant cart item to one let's go to the shopping cart dot raise a file let's add an input field that will allow a user to modify the quantity of a particular item in the user's shopping cart note that we are using blazers at bind syntax to bind each quantity input field to the corresponding property of the appropriate object of type cart item dto stored within the shopping cart items collection this means for example that if the qty property for a cart item dto object stored within the shopping cart items collection is modified that this modification will immediately be reflected on the ui in the appropriate quantity input field let's create the update qty button that a user can click in order to update the quantity of a particular item let's use blazes at onclick syntax to call the appropriate event handler method that we have created within the shopping cart base class let's stand by our convention to use the underscore click suffix for these type of event handler methods so let's change the name of the relevant method from update qty cart item to update qty cart item underscore click then we can write code to pass in the appropriate values to our update qty cart item underscore click method let's test the code great so we haven't yet written code so that the total quantity and total price is reflected within the cart item summary information displayed to the user on the righthand side of the user's screen let's implement the code for this so firstly let's include two properties within our shopping cart base class let's include a property to store the total price of the items within the user's shopping cart and the total quantity of the items stored within the user's shopping cart let's create a private method named set total price which is responsible for calculating the total price of all the items stored within the user's shopping cart and assigning the result of this calculation to the relevant property let's create a private method named set total quantity which is responsible for calculating the total quantity of items stored within the user's shopping cart and assigning the result of this calculation to the relevant property let's create a private method named calculate cart item summary totals let's call the set total price method as well as the set total quantity method from within the calculate cart summary totals method we want the total price of all the items stored within the user's shopping cart as well as the total quantity of items stored within the user's shopping cart to be reflected on the ui whenever a user action results in the state of the shopping cart changing so let's appropriately call our calculate card summary totals method from within the update qty cart item underscore click event handler method the delete cart item underscore click event handler method and the on initialized async method that is called when the razer component is rendered let's go to the shoppingcart.racer file and implement the code that will result in the appropriate summary totals being reflected appropriately on the ui before we run the code we must also include a method in the shopping cart base class that updates the total price property on the relevant object of type cart item dto when the relevant quantity property is updated for a particular cart item by the user so basically if for example a cart item has a price of 50 dollars and the user updates its quantity property from one to two we need to change the cart items total price from fifty dollars to a hundred dollars to calculate the total price is simply a mathematical operation of price multiplied by quantity so let's create a method named update item total price let's call our get card item private method to reference the relevant cart item then we can update its total price property with the result of the calculation that we have just discussed we want our update item total price method invoked every time the quantity for an item within the user's shopping cart changes so let's implement the code for this appropriately great let's run the code excellent so let's look at javascript interoperability in a blazer webassembly component let's implement the code so that our update qty button is only shown to the user when the state of the relevant input field changes so let's first create a css file for our shopping cart razor component so let's create a css file named shoppingcart.razer.css as discussed when we create a css file that only applies to a specific razor component we must adhere to a specific naming convention let's create a css class named update dash qty that contains the code display colon none so we can apply this class to the update qty button like this to ensure that when the relevant razer component first loads that the update qty button is not displayed to the user so the next step is to create a javascript method that is invoked when the quantity input field is changed by the user this javascript method will be responsible for appropriately showing and hiding the relevant update qty button let's create a folder within the www root folder of our project named js let's add a javascript file named shoppingcartfunctions.js to the js folder let's create a javascript function named make update qty button visible this function accepts two arguments one denotes the id of the relevant cart item and the other denotes a boolean value so in order to be able to identify the relevant button within our javascript code we can apply a data attribute to the relevant html element so let's go to our shoppingcart.razer file and include a data attribute named data dash item id and set its value to the id of the relevant cart item the code for the javascript function is fairly basic let's use our data attribute to reference the appropriate button element we are using the data dash item id data attribute to identify a specific update qty button if the boolean value is true we want code to execute within our javascript function to make the relevant button visible if the boolean value is false we want our function to make the relevant button invisible let's appropriately reference our new javascript file from within the index.html file then we need to write code to detect when a quantity input field or qty input field is changed by the user we can use blaze's at on input syntax for this purpose one might think that the at on change syntax should be used for this purpose but a method executed in response to the at once syntax will only be invoked when the relevant input field loses focus we want our method to be invoked immediately when the relevant input field's value changes so let's implement a method within the shoppingcartbase.cs class that will be invoked when a quantity input field is changed so we want our make update qty button visible javascript function to be invoked when a quantity input field is changed so how can we call a javascript function from within a razer component the answer to this is that we can use the builtin js runtime type for this purpose so let's create a property of type i js runtime let's decorate this property with the inject attribute so that an appropriate object of type ijs runtime will be injected into our razor component at runtime we can then use the object to appropriately call our make update qty button visible javascript function like this let's go to our shopping cart dot race of file and appropriately call our update qty underscore input method lastly let's write code that calls the relevant javascript function to make the relevant update qty button disappear once the relevant button has been clicked let's run the code excellent this is the eighth part of a video series dedicated to building a shopping cart application using blazerwebassemblyon.net 6. so at this point we have achieved quite a lot we have created the functionality for displaying grouped products to the user we have also created most of the functionality for the shopping cart a user can now add a product to the shopping cart remove a product from the shopping cart and can update the quantity of a product that is contained within the shopping cart so we now need a way for a user to be able to navigate to the shopping cart from anywhere within the application we also want the user to be able to see at a glance how many items are currently contained within the user's shopping cart currently the user is only able to navigate to the shopping cart through our application by adding a product to the shopping cart we want the user to be able to see how many items have been added to the user's shopping cart at a glance no matter where the user is within the application for example the user may be viewing the grouped products displayed to the user when the application is first launched and wishes to know how many items are currently contained within the user's shopping cart we also want the user to be able to navigate to the user's shopping cart through our application from anywhere within the application simply by clicking a button so we want to make this button accessible to the user from anywhere in the application so in this video we'll provide an appropriate solution for this we'll provide a button in the header part of the ui that when clicked will navigate the user to the user's shopping cart the quantity of items stored within the user's shopping cart will be displayed on the text of the relevant button so the quantity value displayed on the relevant button must be kept up to date so we must facilitate the change of the relevant quantity value whenever the number of items within the shopping cart changes the code for the button containing the text representing the number of items in the user's shopping cart will be contained within its own razor component a razor component we'll name cart menu so this means we need to find a way to send data to the cart menu razor component from other relevant razer components like for example the shopping cart razor component whereby code must execute that updates the relevant quantity value when a change to the number of items stored within the user's shopping cart is made in this video we'll see how csharp events can be used to facilitate communication of data between the loosely coupled razor components within our application right let's get started let's go to our blazer client component so let's go to the project named shoponline.web let's open the i shopping cart service file let's create a definition for a csharp event note that the action type is a delegate that doesn't return a value so any method that the relevant delegate points to will be able to accept the arguments defined within the relevant delegate but the method will not return a value in our case any method pointed to by this delegate will accept one argument of type integer let's create a definition for a method that is responsible for raising the relevant event to subscribed components if what we are doing here is unclear to you don't worry it will become clearer to you as we develop the code in this video okay so let's open the shopping cart service file let's implement the code for the interface items that we have just created let's implement the code for the raise event on shopping cart changed method first we need to check if our event has any subscribers we can do this by evaluating the on shopping cart changed event object so if the on shopping cart changed object is not null this means that the event has subscribers so if the event has subscribers we need to write code that raises the event to those subscribers we can do this by implementing the invoke method on the on shopping cart changed event object then we can send the appropriate integer value to each of our subscribers by passing in the appropriate integer value to the invoke method so in the context of our application an example of a subscriber will be a method within the cart menu razor component that we'll create later in this tutorial when the quantity of the item stored within the user's shopping cart changes the event is raised and a custom method that will be created within the cart menu razor component will be invoked in response to the quantity of items stored within the shopping cart changing basically when the quantity of the shopping cart changes the event is raised and any subscribed methods are called this will be clarified with code that we'll create in a bit so this event being raised will result in the new quantity of items stored within the user's shopping cart being displayed from within the cart menu razor component let's open the products base dot cs file let's write code so that an object of type shopping cart service will be injected into this razor component at runtime so the product razor component is loaded when a user first launches our application we want the user to be able to see how many items are currently stored within the user's shopping cart when the application is first loaded so let's first appropriately call code on the server to retrieve the shopping cart items currently stored within the user's shopping cart i can feel the comments flowing my way already so i think i'll be preemptive and just say that i'm aware that this may not be the most performant way of doing this but i want to focus on events in relation to razer components in this tutorial we will be optimizing the code in later videos for example by including local storage functionality i don't want to make my videos too convoluted so this is why i sometimes first create simplistic code in certain scenarios so that momentum is gained in the development of our application and then as i said we can always optimize the code in later tutorials right let's write code to calculate the number of items currently stored within the user's shopping cart we can then use the shopping cart service object to raise the appropriate event which will in effect send the quantity of items stored within the user's shopping cart to any subscribers so this will result in the appropriate quantity value being displayed to the user in the header section of the layout of our application let's open the shoppingcartbase.cs file so we want our event to be raised each time the quantity of items stored within the user's shopping cart changes let's create a private method named cart changed let's rationalize our code a bit so that the card summary totals private method is called whenever this card changed method is called and we want our events to be raised whenever the cart changed method is called we want our cart changed method to be called whenever the state of the user's shopping cart is changed so let's appropriately call our method from within the uninitialized async method the delete card item underscore click event handler method and the update qty cart item underscore click event handler method notice that each time we write code to invoke the cart changed method we are replacing the call to the cart summary totals method with the call to our new cart changed method because the calculate summary totals method is now being called from within the cart changed method so let's create the code for the cart menu razer component this component will be displayed in the header section of our layout for our application so let's create a race component called cartmenu.razer within the shared folder let's write code so that an object of type i shopping card service is injected into our cart menu razor component at runtime let's open the underscore imports.razer file and include a using directive that references the shop online dot web dot services dot contracts name space so we are not using inheritance for this component so we can instead include code logic for this razor component within the add code section of our razer file this is because our cart menu razor component is not likely to contain a lot of code logic so we don't necessarily need to abstract the code logic into a separate base class let's define a variable of type integer named shoppingcartitemcount let's create an override for the razer component's uninitialized method this method will be called when our razor component is first rendered so we want our razor component to subscribe to the event that we created in the shopping cart service class to achieve this we can implement this code this means that every time the relevant event is raised the shopping cart changed method will be run so we haven't yet implemented code for the shopping cart changed method so let's do that so all we are doing is updating our shopping cart item count variable with the quantity value passed into this method from code that executes to raise the relevant event note that we are calling blazers built in state has changed method here this is an explicit way of telling blazer as it were to rerender the relevant razer component so we are explicitly telling blazer to rerender the component after the shopping cart item count variable has been assigned a new value from code that is raising the relevant event the shopping cart item count will be used in the ui user interface code that we are about to create for displaying the new quantity of items stored within the user's shopping cart so let's write the ui code and this must exist outside the at code section so we want a button displayed to the user that displays a value representing an uptodate count of items currently stored within the user's shopping cart we also want a user to be able to navigate to the user's shopping cart when this button is clicked in order to prevent possible memory leaks we can write code to unsubscribe from the on shopping cart changed event so to do this let's implement the i disposable interface then we can implement code for the dispose method to unsubscribe from the on shopping cart changed event like this so you can see that the plus equals operator is used to subscribe to an event and the minus equals operator is used to unsubscribe from an event let's open the main layout razor component from within the shared folder this component is responsible for displaying the main ui layout of our application we can ensure that our cart menu razor component displays within the header section by including the appropriate tag for our cart menu razer component here so let's run the code excellent so notice that when we are using a mobile view when running the application we are not able to see our header menu item so let's write code to allow for users that are using our application in a mobile view to be able to see the count of items currently stored within the user's shopping cart and also to be able to navigate to the user's shopping cart from anywhere within the application we can do this by adding an appropriate menu item to the application's main menu for when the application is being used using a mobile view so let's open the nav menu.razer file from within the shared directory this file contains the code responsible for creating our application's main menu let's add a new menu item to the main menu like this let's write code so that an object of type i shopping cart service is injected into this razor component at runtime in the add code section let's create a private variable of type integer named shoppingcartitemscount let's implement the code to subscribe to the on shopping cart changed event let's implement the method that we want to executed when the on shopping cart changed event is raised let's go to the appropriate menu item code and include the shopping cart item count variable so that the user is able to see from this menu item how many items are currently stored within the user's shopping cart now we only want this menu item to be shown to users that are using our application using a mobile view so we can ensure this by including the d sm none bootstrap class within the appropriate html element that represents the relevant menu item lastly let's write code so that before this razer component is garbage collected ie before.net frees the memory taken up by this razor component that the relevant method within this razor component is unsubscribed from the on shopping cart changed event let's run the code excellent so we have now completed all the functionality that enables a user to add items to the user's shopping cart as well as remove items from the user's shopping cart a user is also able to update the quantity of products within the user's shopping cart so of course no point leaving the products hanging around in the user's shopping cart the next logical step is for a user to purchase the products in the user's shopping cart so we are going to create a razor component in this part of the course that denotes a checkout facility whereby the user can purchase the products within the user's shopping cart so how do we create a payment facility so that users can purchase the items in the user's shopping cart the answer is we must integrate a payment gateway into our application so if we navigate to this website we can see here some useful information regarding payment gateways what is a payment gateway a payment gateway is a service that authorizes and processes debit slash credit card or paypal payments for online merchants and traditional brick and mortar businesses a payment gateway facilitates these transactions by encrypting sensitive data and transferring it between a payment portal a website or a mobile device and the bank slash front end processor if we scroll further down this page we can see a list of the most popular payment gateway providers you've probably heard of a few of them like for example paypal and stripe paypal stripe square secure pay worldpay authorized.net to checkout.com braintree i have a business account with paypal so i'm most familiar with paypal in this video i'll give you a very basic guide on how you can integrate the paypal payment gateway into your application even though i'm specifically using paypal the same fundamental principles will apply for other payment gateways please see the relevant instructions provided by your preferred payment gateway service provider on how you can integrate your preferred payment gateway into your applications the payment gateway service provider will provide developers with information on how to integrate the relevant payment gateway into your application it's not as difficult as you might think all of the heavy lifting as it were is done through the third party payment gateway so this tutorial is not a definitive or comprehensive guide on how to integrate a payment gateway into your application but it will hopefully give you a very good idea of how to integrate a payment gateway into your applications it all depends on your application's requirement on how you go about implementing relevant payment gateway integration functionality in your applications let me first present a brief disclaimer before we start this tutorial this is not a definitive guide on integrating a payment gateway into your application this is certainly not a final ecommerce solution the purpose of this tutorial serves to give you a basic idea of how you are able to integrate a payment gateway into a blazer webassembly application if you wish to create an application that uses a payment gateway in a live environment you'll need to research relevant information provided by your preferred payment gateway provider in order to gain a thorough understanding of how to create an ecommerce solution using the relevant payment gateway right let's get started let's create a razor component named checkout.razer within the pages folder let's create a csharp class named checkoutbase.cs within the pages folder let's write code to ensure that the checkout razer component inherits from the checkout base class as the name of our razer component suggests a user will navigate to this razor component in order to purchase the items within the user's shopping cart paypal makes it easy for us to integrate the payment gateway functionality within our applications by providing us with sample html and javascript code in order to copy the relevant html and javascript code let's navigate to this paypal web page if we scroll further down the page paypal presents us with a few options i'm going to use the first option here let's click the start setup button let's select the variable price list item here let's select the desktop option here then to copy the relevant javascript and html code we can click the copy code button here let's navigate to our index.html page and paste the html and javascript code currently stored within our clipboards here you can see here we have a javascript function named init paypal button this method contains callback methods like for example create order and on approved the create order method is called by paypal when an order is created and the on approved method is called after the relevant order has been approved by paypal note that within the on approved method there is code that logs information about the order which is sent back from paypal after an order has been approved to the browser console window the relevant information is sent back from paypal regarding the relevant order after the order has been approved by paypal so this gives us an idea of how our code integrates with paypal we also have a script tag here that references a script file at a specific paypal location the way in which we are able to link a paypal account to our application is through this client dash id parameter here at the moment we only have a placeholder value for the client dash id parameter i'll demonstrate a bit later how we are able to generate a valid client id value that we can paste over this placeholder value here i'll demonstrate this a bit later we have this html code here that contains various fields and a placeholder for the relevant payment gateway related buttons that the user can use to start the payment process the user will be able to pay using a valid debit or credit card by clicking this button or if the user has a valid paypal account the user can use the user's paypal account by clicking this button for a particular integration requirement we can tailor the sample code to our needs so we are going to simplify the code here and remove code that is superfluous in relation to our particular requirement so let's say that for a particular integration requirement we only need the description field and the amount field so we can delete the javascript code from the init paypal button method here that references the html elements denoting the fields that we don't need we don't need this code here so let's delete it we don't need this code because it is code used for validating user input code within our application will control what is entered into the appropriate fields namely the amount field and the description field therefore we don't need any user validation related code in the on init method there is a lot of code relevant to user validation that we don't need let's delete the honornet method within the onclick method we only need this code here that references the values that will be inserted into the amount and description fields at an appropriate time by certain code within our application so let's copy the relevant code from the onclick method here let's paste it into the create order method here then we can simply delete the onclick method you can see here in the on approved method we have code here that logs order information to the user's browser console window this information is sent back from paypal once a user's order has been approved by paypal and contains details about the user's order we'll examine the order information later when we test our code you can see here that the sample code that we copied from paypal includes a call to the init paypal button javascript method we want to control when the init paypal button method is invoked we'll implement the code to call the init paypal button method using csharp code and blaze's javascript interoperability feature from within the checkout razer component in a bit so let's remove the call to the init paypal button from the index.html file let's cut this html code here and paste it into our checkout.razer file this will allow the paypal buttons to be available to the user when the user invokes the checkout raiser component for our particular requirement let's say that all we are interested in is the description field and the amount field so let's remove the html elements that we don't need for the implementation of our integration code with paypal we don't need the html elements that label the relevant fields because we are going to make the amount field and description field hidden text fields we don't want the user to enter any payment information we are going to control the values that are inserted into these fields through csharp code that we'll implement in a bit we need this div element here because this tells paypal as it were where we want the relevant paypal gateway related buttons placed within our ui so for our requirement we don't want these fields to be visible to the user so let's make these fields hidden text fields so let's create the code for the checkout base.cs class we are going to want to call the init paypal button javascript method that resides within our index.html file from within the checkoutbase.cs class so we need to write code that ensures that an object of type rjsruntime is injected into our checkoutrazor component at runtime this is so that we can utilize blaze's javascript interoperability feature to call the init paypal button javascript method that we copied from the relevant paypal web page earlier we'll write the code to call this javascript method in a bit we need to reference the collection of shopping cart items so let's create a property of type i enumerable that is strongly typed with the cart item dto type let's create a property named total qty let's create a property named payment description let's create a property named payment amount let's create code to bind the paypal related hidden text fields we have implemented within the checkout.razer file to their counterpart properties by using blazers at bind syntax so this means that every time relevant property values change laser will automatically update their counterpart input fields i.e the input fields that contain the relevant at bind syntax in the checkout.racer file the payment description and payment amount properties will be bound to the input fields implemented within the checkout.racer file so this is one of the aspects involved in integrating our application with paypal we can communicate the total payment amount to paypal through the payment amount property and we can communicate whatever payment description we want by updating the payment description property the javascript within the init paypal button method references the fields that we have implemented using hidden text fields in the checkout.razer file i.e the amount field and the description field the fields are bound to their counterpart properties within the checkout base class we can use this description field to uniquely identify a particular payment there are of course many different ways to implement this type of functionality i've chosen this way for the sake of the example in the interests of keeping the example simple i.e for teaching purposes when we run the code and create a test order once our order is approved by paypal we'll be able to inspect the data within our browser's console window which is the data sent back from paypal after our order has been approved we'll see that one of the fields contains our unique description value we want an object of type i shopping cart service to be injected into our checkout raiser component at run time so let's create a property of type i shopping cart service and ensure that it is decorated with the inject attribute let's override the uninitialized async method let's implement code to retrieve the user's shopping cart items we'll look at code in a later tutorial whereby we can use local storage functionality so that we don't have to make so many calls to the server we can use local storage to improve performance but we'll write this code in a later tutorial so i'm writing code to create a new good here so that we can use this good value to uniquely identify a particular order let's assign the total payment amount to the payment amount property let's assign the total quantity to the total qty property let's create an identifier field so that we can uniquely identify a particular order as i said earlier i'm just doing this for the sake of this example it is up to the developer to modify the appropriate code so that it is adapted appropriately in relation to the developer's particular requirement so let's include an o for order followed by the user's id and then followed by the unique guide value within the payment description field let's override the on after render async method this method is called in response to the occurrence of a blazer lifecycle event that occurs after the relevant razer component is rendered we can use the first render argument passed to this method to ensure that our code within this method is only fired once after our razor component is first rendered so if first render is true we want code to execute that uses our js object to call the init paypal button javascript method so you can see how we are integrating our checkout razer component with the sample javascript code that we included within the index.html file this is of course the sample code we copied from paypal so as to perform our integration with their payment gateway so the next step is to generate the client id whereby we can link our paypal account to our application so we need to do this through paypal note that you are able to follow along with the next part of this tutorial even if you just have a personal account with paypal you will however need a business account with paypal if you wish to go live with the paypal payment gateway functionality paypal provides a sandbox feature that we can use for development and testing purposes but as i said if you wish to go live you'll need a paypal business account for instructions on how to create a paypal business account please navigate to this url so assuming you have a paypal account as stated you are still able to follow along even if you just have a personal account and you don't have a business account let's log in to paypal then let's click the developer menu option here so that we can use the sandbox feature to implement the server side part of the integration functionality so that we can integrate the paypal payment gateway into our application you can then navigate to the dashboard like this you can see here you have two options one for sandbox and the other for live we are going to use the sandbox facility if you want to go live with your paypal payment gateway you would use the live facility as discussed you will need a paypal business account before you are able to go live with the paypal payment gateway so to create the server side functionality that we need in order to integrate the paypal payment gateway into our application click the create app button let's give the app a sensible name and then create the app like this we now have this client id generated for us and this is the key to how we can associate our clientside integration with our paypal account so let's copy this client id value to our clipboards let's remain logged into paypal and let's appropriately paste the relevant client id value to our index.html file here for the clientid parameter great while we are here let's remove the enable dash funding parameter here let's go back to paypal so for testing purposes paypal allows us to generate mock credit card details when we test our code we are going to use the generated mock credit card details to make a test payment we can generate mock credit card details by clicking the credit card generator menu option here and then i'm going to select the united kingdom as my country first and then to generate the mock credit card details we can press the generate credit card button here so let's copy the relevant mock credit card details and save them somewhere so that we can access them a little bit later when we test our application before we test the code let's make sure that we can navigate from our shopping cart razor component to our checkout component so to do this let's appropriately update the code within our shoppingcart.razer file then we must also ensure that we have an appropriate at page directive at the top of our checkout.racer file a user needs to be able to navigate directly to the checkout raiser component so we must include appropriate root template information following the add page directive and now we should be able to make a test payment through our application let's run the code let's add some items to our shopping cart let's proceed to check out let's appropriately enter our mock credit card details along with some appropriate made up data regarding personal information like address and phone number excellent now if we press f12 within our chrome browsers we can see the data sent back from paypal in the on approved callback method defined within the init paypal button method we have code to log data sent back from paypal after an approved order has been made we could implement code that extracts the relevant data from the returned data from paypal and update our application's database in an appropriate way depending on our requirement that functionality is beyond the scope of this course but hopefully this gives you a good enough insight of how to integrate the paypal functionality into your application but please read the relevant developer related information provided by your preferred payment gateway service provider for information on how to create relevant integration functionality that best suits your requirement and you can see here our custom description value that we created earlier in code has been sent back from paypal along with the other order information which contains the user id value and a guide value that our code generates for each order that is sent to paypal so let's finish the code for our checkout raiser component let's say that we want to display a summary of items that the user is purchasing on the checkout ui next to the paypal buttons so let's write the code for this please note this code can be copied from the relevant github repository i have included the location of the relevant github repository below in the description let's test the code excellent this is the 10th part and the penultimate video in a video series dedicated to building a shopping cart application on net 6. so we are nearly finished building our shopping cart application in this video we are going to create functionality so that a user can filter the products in our stores product catalog by product category we will write codes to query our database for all the product categories within our database and display them as menu items in the main menu contained within the sidebar section of our ui when the user clicks one of the menu items denoting a product category data representing the products related to that category will be appropriately displayed to the user right let's get started so in the first part of this course we created our database through ef core code first migrations a requirement to update the databases seed data or structure may arise for example due to a decision to include new functionality within the application or perhaps just to correct a minor mistake made when the database was first created and seeded with data through ef core code first migrations we have the agility that we need to make appropriate adjustments to our database during the development and testing phases of our application so before we start writing code we need to address a database related requirement we need to add a new column to the product categories database table where we can store relevant css code that denotes an icon used to represent a product category we are of course going to use ef core code first migrations to address this requirement so let's first update the product category entity class to include a new string property and let's appropriately name our new property icon css we are going to need an appropriate dto data transfer object to house the data that we send back to the client for when a client makes a request to the server for a collection of product category data so let's go to the shoponline.models project and create an appropriate class to represent the relevant dto let's go back to the shoponline.api project before we generate the relevant migration code let's open the shop online dbcontext class and update the relevant code for seeding our database within the onmodelcreating method so here we are including relevant font awesome css classes within the new field named icon css these classes will be appropriately referenced within our code to render appropriate icon images for each of the relevant product categories so let's create our migration and give it a sensible name great let's look at the migration code that we have just generated great let's run our migration through the update dash database command excellent so let's go to our shoponline.api project so if we look at the product repository class we can see that we have already written the code for returning a collection of product category objects we need to expose this functionality to the relevant clients so to do this let's create an appropriate action method within the product controller class let's create an extension method to convert the collection of product category objects to a collection of product category dto objects this may seem like a pointless exercise because the shape of the product category class is exactly the same as the shape of the product category dto class it is important to understand that even though this step may seem unnecessary that we are doing this due to design best practices why is this the design best practice in the future a new requirement may arise for example where a client may require additional data to be returned from the relevant action method we want to maintain a clear separation of concerns between the dto classes and the corresponding entity classes the reason for this is that the relevant dto classes can evolve independently from the relevant entity classes if required without affecting their counterpart entity classes so a dto class can for example be extended without affecting its counterpart entity class let's finish off the code for our action method great so let's go to the shoponline.web project and write the calling client code for retrieving a collection of product category data let's create the relevant service code let's add an appropriate method definition to the i product service interface let's implement the code for the interface that we have just created so our code in this method is appropriately requesting a collection of objects of type product category dto from the server great let's create a razor component that will be responsible for outputting the product categories as menu items inside our blazer applications main menu that resides within the sidebar section of our applications ui so within the shared directory let's create a razor component named product categories nav menu let's create a class named product categories nav menu base let's write code so that an object of type i product service is injected into our razor component at run time let's create a property of type i enumerable that is strongly typed with the product category dto type let's create a string property named error message let's override the uninitialized async method let's create code within the uninitialized async method that retrieves a collection of objects of type product category dto from the server and assigns the returned collection to the product category dtos property great let's implement the code for the product categories nav menu razer file so we need to create a using directive that references the shoponline.web.pages namespace so let's add the appropriate using directive to the underscore imports.razer file we are adding this using directive because we are going to add appropriate tags to the product categories nav menu razer file that reference relevant child razor components that have been added to the pages directory for example the display spinner child razor component so notice that we are creating a link that contains a category id parameter we'll later write code that uses this parameter value to query the server for a collection of product data that is related to a particular category denoted by the relevant category id value so we haven't yet written the code for the products by category raiser component we'll write the code for this razor component a bit later this razor component will contain code for displaying a collection of objects of type product dto that are related to the category id value that will be passed as a parameter to the products by category razor component so the next step is to reference our new razor component from within the razer component that contains the main menu that appears to the user in the sidebar of the ui so let's add the appropriate tag to reference our product categories nav menu razor component let's run the code and we can see that our product categories are now appearing as menu items within the sidebar however as you can see the style of the product category menu items are different from the home menu item because the codes that produces the category menu item is contained within a different razor component so to solve this i'm simply going to copy the css code from the navmenu.razer.css file and paste it into a new css file that we must name product categories nav menu dot razer dot css so this will result in the product category menu items being styled like the home menu item so we are flagrantly violating the principle of dry don't repeat yourself here i'm doing this deliberately to keep up the momentum and creating the code for this application so that i can effectively keep the focus on the aspects that are the subject of this part of the course you can of course centralize the css code for the menu items in adherence with the principle of dry however for the reasons i've just explained i won't address this issue in this part of the course great so let's move on to create the code for filtering the products by category let's go back to the shoponline.api project let's go to the i product repository interface let's create a new method definition within the i product repository interface the code that we'll implement for this method will be responsible for retrieving a collection of product data that is related to a particular product category so let's implement the code for the method that we have just defined within the product repository class let's create an appropriate action method to expose this functionality to calling client code great right let's go back to the shoponline.web project and implement the service related code regarding the functionality for retrieving product data related to a particular category id let's open the i product service interface and create an appropriate method definition let's implement the code logic for the method definition that we have just created so here we are appropriately requesting a collection of objects of type products dto that are related to a particular product category right let's create a razor component responsible for displaying the product data filtered by category on the ui let's name this razor component products by category.razer let's create a class named products by category base let's implement the code for the products by category base class firstly let's create a property that represents a parameter that will be passed into this razor component the value passed into this category id parameter will be an appropriate category id value note that we are able to declare that a property represents a parameter by decorating the relevant property with the parameter attribute let's create the other necessary properties for our razor component so we want our collection of products to be retrieved for a particular category only when the category id parameter is set so we can do this by implementing our code within a method that is called by blazer in response to a life cycle event occurring when our parameter value is set so to achieve this we are overriding a builtin blazer method named on parameters set async so let's write the code within the on parameters set async method our code simply retrieves the appropriate products data from the server based on the value passed into our category id parameter let's write the appropriate ui code within the products by category.razer file so let's first use the add page directive to appropriately declare the relevant root template information for our products by category razer component let's write code to inherit from the products by category base class let's implement the code logic so as you can see we can reuse our display products razor component that we created in a previous part of this course to display the relevant products data to the user let's run the code excellent so you can see that our product category menu items appear differently when compared to the home menu item so let's fix this in code so that our menu items are displayed in a consistent way to the user great let's finish off by adding an appropriate logo for our application excellent i hope you have enjoyed this video i look forward to presenting the final video in this series where we'll optimize our code to potentially create better performance for our application hi and welcome i'm gavin lon this is the 11th and final part in a series of videos dedicated to building a shopping cart application using blazer web assembly and web api on net six so we have now built our basic shopping cart application but is software ever really 100 complete at points there may be bug fixes to make we may need to upgrade our application with the latest technologies a requirement may arise to improve the overall performance of the application there may be parts of the application where ux user experience can be enhanced in this video we are going to look specifically at how we can improve the performance of our application by optimizing our code there are two areas where we can potentially enhance the performance of our application item number one in the web api component we are currently making two separate queries to the database when retrieving product data our code is returning both product data and product category data to the calling client to do this we are currently calling two separate methods in the product repository class one for retrieving details about the products from the product database table and the other for retrieving details about the product categories from the product categories database table so in this video to potentially enhance performance we are going to retrieve the product and category details through one query to the database instead of two the other area where we can improve performance is by using local storage within the blazer component to store both the product data and shopping cart data so that when our application needs to retrieve relevant product data or shopping cart data our code can retrieve the relevant information from local storage i.e data stored on the client within the user's browser as opposed to making a trip as it were to the server every time the relevant data needs to be retrieved so basically the travel time and retrieving the relevant data can be shortened in certain scenarios the data can be retrieved on the client instead of the server for content like this and much more please consider subscribing and please ring the bell so as to be notified of future content if you like this video please hit the like button and please feel free to share this video with anyone you feel may benefit from its content so let's attack the first item let's go to the shoponline.api project let's optimize the code on the server where we can make one query to the database to retrieve both product information and related product category information rather than use two separate queries for this purpose so the first step is that we need to modify the class representing the product entity so we must first add a public property to the product class that is of type product category let's add the foreign key attribute to our new product category property we can then pass an appropriate string value to the foreign key attribute that is used for declaring which property in the product class must be used for joining the product entity to the product category entity so this code will indicate to ef core as it were how we want to join the product entity to the product category entity let's go to the product repository class and first modify the get item method to appropriately join the product entity to the product category entity in the relevant link query so to do this we can use the include method like this we are establishing the join between the two entities through this lambda expression notice the product category property that we recently created within the product class for this query we only want to retrieve one item so we can use the single or default async method to filter the product data based on the relevant product id passed to this method then for the get items method the code is similar to the get item method but for the get items method we wish to return all the products that are currently stored in the products database table with the related product category information to the calling code so we of course don't need to filter the data so that means we don't need to use a method like the single or default async method in this query then the last method that we need to appropriately modify is the get items by category method if we open the product controller class we can see that we can now simplify the code here but first we need to appropriately update the relevant extension methods responsible for converting objects of type product to objects of type product dto so let's first update the extension method that converts an individual product to type product dto great then let's update the conversion extension method that converts a collection of objects of type product to a collection of objects of type product dto great we can now update the relevant action methods accordingly we no longer need to query for the category items in a separate query that we are using here to get a collection of category items so we've potentially improved performance of the serverside code through an appropriate code optimization exercise we are only dealing with a small amount of data so the performance improvement would probably be negligible but if we were dealing with large amounts of data the performance improvement would be more significant so let's look at the second way that we can improve the performance of our application the second way that we can improve the performance of our application involves an update to our blazer component so let's go to the shoponline.web project let's see how we can reduce the number of trips to the server we are currently making for retrieving relevant product and shopping cart data through the use of local storage so we could use javascript and blazer's javascript interoperability feature and write our own local storage functionality it turns out though we don't need to go to this kind of trouble because someone has already made available a new get package that contains the local storage functionality we need so let's invoke the nuget package manager window let's search for local storage and this is the package we want to install so let's install the blazered.localstorage nuget package for more details regarding local storage please navigate to this url basically the javascript local storage object allows you to save key value pairs in the browser note the local storage object stores data with no expiration date the data is not deleted when the browser is closed and are available for future sessions so the local storage functionality provided to us within the blazid.localstorage nuget package abstracts the javascript code for managing local storage so we don't need to write the relevant javascript code ourselves we are now going to create two services to encapsulate our local storage functionality so let's first create an interface named i manage products local storage service let's create two method definitions like this let's create an appropriate method definition for a method named get collection let's create an appropriate method definition for a method named remove collection let's create an appropriate service class to implement the methods defined within the interface we have just created let's create a constructor whereby we indicate that we want an object of type i local storage service and an object of type i product service injected into our constructor at run time note that the i local storage service type is a type provided by the blazer.localstorage nuget package that we have now installed so this type will be used to implement the necessary local storage functionality let's create a private method named ad collection this method simply retrieves the product data from the server and saves the relevant product data in the user's browser using local storage okay let's create a string constant to store the key that will be used to identify the relevant value in this case the relevant value is a serialized collection of objects of type product dto let's implement the code for the get collection method so this method first tries to retrieve the relevance data from local storage if the relevant data does not exist in local storage we can call the add collection private method to retrieve the relevant data from the server and save the relevant data to the user's browser using local storage the remove collection method simply removes the relevant data stored within the user's browser using local storage right let's create an interface within the contracts folder named i manage cart items local storage service let's create an appropriate method definition for a method named get collection let's create an appropriate method definition for a method named save collection let's create an appropriate method definition for a method named remove collection right let's implement the relevant code for the interface that we have just created so let's first create a class named manage cart items local storage service let's create a constructor whereby we indicate that we want an object of type i local storage service and an object of type i shopping cart service injected into our constructor at runtime let's create a constant to store the key that will be used to identify the relevant items stored using local storage the local storage item in this case will be a serialized collection of card item dto objects let's create a private method named add collection this method simply retrieves relevant data from the server and appropriately saves the data to local storage this method attempts to retrieve the relevant data from local storage if the relevant data does not exist in local storage the code retrieves the relevant data from the server and appropriately saves the relevant data to local storage let's implement the code for the remove collection method which involves appropriately deleting a collection of objects of type cart item dto from local storage notice that the key constant is used to identify the relevant local storage item let's implement the code for the save collection method which involves appropriately saving a collection of objects of type cart item dto to local storage so we haven't yet registered the ilocal storage service type provided in the blazer.localstorage package with the dependency injection system so let's open our program.cs file and apply the code to register the ilocalstorage service type for dependency injection so we can use the add blazer local storage extension method for this purpose we must then also register our two new service classes that we have created to abstract the relevant local storage functionality with the dependency injection system so let's now implement the relevant local storage functionality within the relevant razor components in order to hopefully increase the performance of our blazer component let's open the products base class this is the base class for the razor component that first loads when our application is first launched let's create the code to ensure that our two local storage services are injected into this razor component let's say that when the product's razor component is loaded we want to clear the relevant local storage items from local storage this will force our code to retrieve the relevant data from the server at this stage then subsequently we want the relevant data retrieved from local storage to enhance performance so let's create a private method named clear local storage and use the relevant functionality we have created within the relevant services to remove the relevant data from local storage let's call this method from within the uninitialized async method then instead of going straight to the server for our data let's use the appropriate local storage service object to first check to see if the relevant data resides within local storage of course in this case we are clearing the data before this method is called which will force our code to retrieve the data from the server however our code will subsequently save the data retrieved from the server to local storage which means that when other razer components retrieve the relevant data the data will be retrieved from local storage on the client side which means an unnecessary trip to the server will be avoided so this gives us an idea of how we are able to increase performance of our application using local storage we can also use our manage cart items local storage service object to retrieve any cart item data that may be saved to the user's shopping cart like this so in this case this code will retrieve the relevant data from the server and save the data to local storage any data retrieval of items within the user's shopping cart can then be done from local storage and therefore trips to the server are saved and the performance of our application is potentially enhanced let's appropriately update the shopping cart razor component let's write the code so that an object of type i manage card items local storage service is injected into this razor component at runtime in the uninitialized async method let's replace the code that retrieves the relevant cart item data from the server to get the relevant data from local storage when a user updates the quantity of a particular item saved within the user's shopping cart we must update the relevant local storage item this is because of course the relevant shopping cart has now changed we can appropriately implement the safe collection method for this purpose we must also use the appropriate local storage service to implement the code to update the relevant local storage item when a user removes an item from the user's shopping cart let's implement the relevant local storage related code for the product details razer component so this component is responsible for displaying details for a particular product this razer component also contains functionality for adding a product to the user's shopping cart let's first create a private property to reference the shopping cart items collection here because when the user adds a product to the user's shopping cart we want our code to update the relevant local storage item we no longer only want the code to update the relevant shopping cart on the server we need to keep the client side local storage data up to date as well so let's first write code to update our shopping cart item's private property with data retrieved from local storage within the uninitialized async method so within the method responsible for adding a new item to the user's shopping cart we need to write code that not only updates the data on the server but also updates the relevant local storage item so we can implement the desired functionality in code like this we can also now implement code that gets data for an individual product from local storage great let's appropriately update the products by category razor component to include local storage functionality let's write code so that an object of type image products local storage service will be injected into this razor component at runtime let's write a private method so that the products filtered by category id are retrieved from local storage let's appropriately call our new private method from within the on parameters set async method lastly let's appropriately update the checkout razer component with our local storage functionality great let's run the code excellent that definitely seems to have made a positive difference to the performance of our shopping cart application if you've made it to the end of this course well done you have learned quite a lot about laser web assembly and web api we have also learned how to create a basic spy application where the vast majority of the code is implemented using csharp i hope you have enjoyed going through this course as much as i enjoyed creating it for content like this and much more please consider subscribing and please ring the bell so as to be notified of future content if you liked this video please hit the like button and please feel free to share this video with anyone you feel may benefit from its content i really enjoy engaging with you in the comments section so please feel free to leave a comment the latest code can be found on github a link to the relevant repository has been included below in the description thank you and take care
