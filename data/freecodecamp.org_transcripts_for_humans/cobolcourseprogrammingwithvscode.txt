With timestamps:

00:00 - [Music]
00:03 - hello there and welcome to your
00:05 - introduction to cobol no matter what
00:07 - brought you here we're glad to see you
00:09 - and hope that you enjoy all that went
00:11 - into creating these videos
00:13 - first things first what is cobalt well
00:16 - whenever there's an acronym i like to
00:18 - start there and cobalt is an acronym for
00:21 - common business oriented language
00:24 - that's a big tell right there right in
00:26 - the name this is a business language
00:29 - compared with other more general purpose
00:31 - languages cobol was designed around data
00:33 - processing specifically data processing
00:36 - with incredibly high accuracy extreme
00:39 - efficiency and ease of reading and
00:41 - writing
00:42 - cobol has indeed been around for over 60
00:45 - years as of this recording and surprise
00:48 - surprise the fundamentals of business
00:50 - being able to process very large amounts
00:52 - of data accurately and efficiently
00:54 - continue to be important so all of the
00:58 - transactions that happen when you're
00:59 - using a credit card visiting a store or
01:02 - doing pretty much anything with a bank
01:04 - there's a good chance some cobalt code
01:06 - got executed somewhere in there
01:08 - in fact every day about three trillion
01:12 - dollars in finance gets handled by
01:14 - cobalt so let's just make sure we're
01:17 - clear here cobalt pretty much runs the
01:19 - world it has been kept up to date to
01:21 - support new requirements throughout the
01:23 - years and 1.5 billion lines of new code
01:26 - are written every year
01:28 - suffice to say learning this language
01:31 - will give you a very valuable set of
01:33 - skills
01:35 - in this course you're going to be
01:36 - working with enterprise cobol which is
01:38 - an implementation written specifically
01:39 - to run on ibm z mainframes
01:42 - the banks insurance agencies energy
01:45 - companies retail chains that depend on
01:47 - cobalt to run their extremely important
01:48 - transactions
01:50 - guess what a whole lot of them also
01:52 - depend on ibm z mainframes to ensure
01:55 - their applications can keep up with the
01:57 - demand 24x7
01:59 - learning enterprise cobol says i want to
02:02 - work on the most important code running
02:04 - on the most important systems running
02:06 - the types of things that no exaggeration
02:09 - at all the world depends on
02:11 - that's a pretty bold statement and i
02:13 - have no problem at all saying it because
02:16 - it's the truth
02:18 - [Music]
02:26 - you might be thinking cobalt on the
02:28 - mainframe am i going to need punch cards
02:31 - and a tie to get through this well first
02:33 - of all
02:34 - no you'll be happy to know that we're
02:35 - going to be teaching all this with
02:37 - visual studio code which as of right now
02:40 - is the most popular editor used
02:42 - worldwide
02:43 - visual studio code or vs code for short
02:46 - supports something called language
02:48 - server protocol which simply put makes
02:50 - it able to support a very large number
02:53 - of languages and environments so the
02:55 - things you'd expect to be there like
02:57 - code completion workspace symbols hover
02:59 - text references and diagnostics can all
03:02 - be supported without it having to be
03:04 - specifically written into vs code itself
03:06 - it gains functionality through
03:08 - extensions which use the language server
03:11 - protocol or lsp
03:13 - we're going to use extensions for vs
03:15 - code that give us all the goodness for
03:17 - cobalt as well as allowing us to connect
03:19 - to a real live mainframe system so after
03:22 - you download and install vs code hop
03:25 - into the extensions marketplace and
03:27 - search for ibm z open editor and hit the
03:30 - install button while that's installing
03:33 - do the same for zoe explorer z-o-w-e
03:36 - that's the simple version of things for
03:38 - more detailed instructions on installing
03:40 - the extensions visit the book version
03:42 - for the full details and screenshots
03:44 - couple of basics once you're in you'll
03:47 - also notice these vertical lines very
03:49 - important for cobalt these are the
03:51 - margins those margins segment each line
03:54 - of cobalt code into its various parts
03:56 - which we'll get into later on just know
03:59 - that it's easier to see whether your
04:01 - text is starting right next to a line
04:03 - than it is to count empty spaces so
04:06 - lines good also if you hover your mouse
04:09 - over some fields a little pop-up box
04:11 - will appear showing you additional
04:13 - information just know that this will
04:15 - come in really handy when you really
04:16 - start hacking away at cobalt code later
04:18 - on and you may also notice that some
04:21 - words get displayed differently than
04:22 - others that's all part of syntax
04:25 - highlighting it just makes things a
04:27 - little bit easier to understand at a
04:28 - glance
04:29 - and this bar across the top that's the
04:32 - breadcrumb view it shows information
04:34 - about what line you're currently at
04:36 - click on any element in that breadcrumb
04:38 - trail and it will highlight the block of
04:40 - text for that element it'll also show
04:43 - you a little outline view of the code
04:45 - over here
04:46 - lastly down at the bottom of your screen
04:49 - there should be a panel with a problem
04:51 - section and if it's not there go up to
04:53 - view and select problems from the editor
04:56 - menu you can click on the problems it is
04:58 - found and it will jump right to those in
05:00 - the code it will find basic logical
05:02 - errors without you having to run or test
05:04 - your code it just knows about those
05:06 - problems ahead of time so you'll
05:08 - definitely want to fix those as they
05:09 - come up
05:11 - got all that i'd say you're ready to
05:12 - dive into some actual cobalt so let's go
05:16 - [Music]
05:24 - cobalt is an english-like computer
05:26 - language it's that way by design meaning
05:29 - it's fairly easy to read understand and
05:32 - maintain compared with other programming
05:34 - languages you'll find that each line of
05:36 - code is pretty transparent about what
05:38 - it's trying to do that's often the first
05:40 - thing people notice about cobol that
05:42 - what it's trying to do is very easy to
05:45 - figure out and you don't have to spend a
05:47 - whole lot of time tracing through code
05:49 - to make sense of it all
05:50 - that's thanks in part to cobalt being
05:52 - standardized so the way that a cobalt
05:55 - implementation should be approached is
05:57 - all described in great detail in that
06:00 - standardization
06:01 - now cobol has gone through several
06:03 - revisions over the years so you do need
06:06 - to keep in mind which particular
06:07 - standard you're working with
06:09 - particularly when you're working with
06:11 - code outside of this course but it
06:13 - mostly comes down to the addition of a
06:15 - few new features better support and
06:18 - small tweaks to fix problems cobalt
06:20 - written specifically for the ibm z
06:22 - mainframe operating system zos is said
06:25 - to be enterprise cobol the code you'll
06:28 - see here in this course is all
06:30 - enterprise cobol and it all gets
06:32 - compiled and executed differently than
06:34 - cobalt you might be writing for other
06:36 - platforms but it is also able to take
06:38 - advantage of hardware and operating
06:41 - system features unavailable anywhere
06:43 - else so it still follows the current
06:46 - cobalt standardization but it's written
06:48 - with enterprise systems in mind
06:51 - let's take a look at some of the basic
06:53 - cobol syntax at a high level so you can
06:55 - get a better feel for the cobol standard
06:58 - right up front one of the key aspects of
07:00 - cobalt some languages use spaces some
07:03 - use tabs cobalt is column dependent
07:06 - meaning it looks at a line of code and
07:08 - expects certain things to be at certain
07:10 - positions in that line
07:12 - specifically it's looking in five key
07:15 - areas of a 72 character line and those
07:19 - look like this
07:20 - the first section columns one through
07:23 - six are the sequence number area
07:25 - sometimes these are blank other times we
07:28 - use them to provide context to a series
07:30 - of statements
07:31 - the next section is the indicator area
07:34 - and it's a multi-purpose area if we're
07:36 - going to leave a comment an asterisk a
07:39 - star goes in here or if we're continuing
07:41 - a previous line it'll be a dash or a
07:44 - hyphen it can also be a d for a
07:47 - debugging line or a slash for source
07:50 - code listing formatting don't worry
07:52 - about all that just yet we'll show you
07:55 - how and why you'll use those later on
07:57 - just remember it's column seven and it's
07:59 - one character
08:01 - next we've got the a area which goes
08:03 - from columns eight to eleven in here
08:06 - you'll find divisions sections
08:08 - paragraphs level indicators and other
08:10 - elements that give cobalt programs their
08:12 - structure
08:14 - right next to it in columns 12 through
08:15 - 72 is the b area this is where you put
08:19 - the actual statements sentences and
08:22 - clauses the things that make a cobol
08:24 - program perform calculations and do
08:27 - stuff
08:28 - then last but not least the
08:29 - identification area running from column
08:31 - 73 to 80. well the compiler might
08:35 - consider at least because it actually
08:36 - ignores it so it doesn't consider it at
08:39 - all it's actually an area the programmer
08:41 - can use for any purpose so it's often
08:44 - just left blank
08:45 - now when you're writing in a programming
08:47 - language there are certain words we have
08:49 - to be careful of
08:51 - words like data end file if ready set
08:55 - until
08:57 - those are cobalt reserve words and when
08:59 - the cobalt compiler sees those words it
09:02 - thinks we're telling it to do something
09:04 - very specific so we shouldn't say ready
09:07 - unless we mean what the compiler thinks
09:10 - it means
09:11 - a full list of reserve words is
09:13 - available at the link in your guide
09:15 - in the next video we're going to talk
09:17 - about how all this fits together in the
09:19 - program structure
09:21 - [Music]
09:29 - let's talk structure koval has a
09:31 - hierarchy structure meaning that it's
09:33 - got things within other things that's
09:36 - part of what gives it its structure the
09:38 - biggest things in a cobalt program are
09:40 - divisions and within those divisions
09:43 - there are sections and within those
09:45 - sections you'll find paragraphs those
09:48 - paragraphs contain sentences and
09:50 - sentences have statements
09:53 - let's start at the statement and work
09:55 - our way back out a statement is a single
09:58 - directive usually starting with one of
10:00 - those reserved words we just talked
10:01 - about so something like add divide move
10:05 - compute
10:06 - those statements go into sentences
10:09 - just like a spoken sentence can reveal
10:11 - many pieces of information a cobalt
10:13 - sentence can contain one or more
10:15 - statements it's just a nice way of
10:17 - placing a bunch of statements together
10:19 - into a logical container
10:21 - so here is a sentence made up of
10:24 - statements and you can see that the end
10:26 - there is a period that period is an
10:28 - implicit scope terminator it says all
10:31 - the previous statements that have not
10:33 - yet ended are declared as finished you
10:37 - can also terminate a scope of a
10:38 - statement using what's known as an
10:40 - explicit scope terminator like if you
10:42 - started with an if statement and you end
10:45 - with an end if
10:47 - then you don't need to specify that
10:49 - you're done with a period
10:50 - either way works and you'll see both
10:52 - used throughout this course
10:54 - so that's sentences and what do
10:56 - sentences go into well generally
10:59 - paragraphs paragraphs are user defined
11:02 - written by you to give your program
11:04 - structure
11:05 - generally a paragraph represents a
11:08 - specific action made up of smaller steps
11:11 - so if it's something that might get
11:13 - called several times throughout your
11:15 - program like applying interest or
11:17 - prompting the user for a series of input
11:19 - that would go into a paragraph
11:22 - that way you can call that paragraph by
11:24 - its name from elsewhere in the program
11:27 - paragraphs go into sections and there
11:29 - are all sorts of sections they can have
11:32 - user defined or predefined names so they
11:34 - can be used to give your program
11:36 - structure or to make sure certain
11:37 - information is where it needs to be for
11:39 - things to run correctly
11:41 - and then there's divisions and there are
11:43 - four cobalt divisions and we can cover
11:46 - all those right now first is the
11:48 - identification division which is where
11:50 - you'd put the name of your program who
11:52 - wrote it when it was written how it
11:54 - should be used all that helpful
11:56 - information then there's the environment
11:58 - division there are two major sections
12:01 - here one lets you set the type of
12:03 - computer environment required to run
12:05 - your program and the other sets of the
12:07 - mapping between the files in your
12:08 - program and the files on the actual data
12:11 - sets so it's the link between your
12:13 - program and the system it's running on
12:16 - the data division sets up all the data
12:18 - that will be used within your program
12:20 - that includes files data from other
12:22 - programs what type of storage or memory
12:25 - you'll use while the program is running
12:27 - and what it will give up when the
12:28 - program ends then there's the procedure
12:31 - division this is where all those
12:33 - sections and paragraphs go so the
12:35 - instructions for how to take data in how
12:38 - to set up the variables performing math
12:40 - on them interacting with the user and
12:42 - all that kind of fun stuff that happens
12:44 - in the procedure division
12:46 - are you ready to see all those
12:47 - statements divisions sentences and
12:49 - paragraphs and actions i sure hope so
12:52 - because it's time for a lab basic cobol
12:54 - syntax in this lab you'll connect to an
12:57 - ibm z system check out a simple cobol
13:00 - hello world program and then submit the
13:02 - jcl to compile the program and view the
13:05 - output good luck and have fun
13:08 - [Music]
13:15 - in this section we're going to talk all
13:17 - about cobol variables i'm pretty sure
13:20 - every programming language in existence
13:23 - has variables of some sort and even
13:25 - basic algebra has the concept of having
13:28 - a letter represent a value like x equals
13:30 - 5.
13:31 - cobalt is really no different though it
13:33 - does put its own spin on some of the
13:35 - details which we'll cover here
13:38 - simply put a variable is a name chosen
13:41 - by the programmer to represent a value
13:44 - that name is referred to as a data name
13:47 - that data name can be anything as long
13:49 - as it's 30 characters or less doesn't
13:52 - contain any spaces is made up of only
13:54 - letters digits and or hashes and isn't a
13:57 - reserved word
13:59 - so some examples of good data names
14:01 - might be balance
14:04 - inventory one two three four five and
14:06 - north american sales in 2020-final
14:10 - that's exactly 30 characters
14:12 - there will be no problem with any of
14:14 - those however if we wanted a data name
14:16 - of top five percent with a percent sign
14:19 - or phone numbers with a space in the
14:22 - middle those would not be good
14:25 - we also have to think about what type of
14:27 - variable we want because when we declare
14:29 - or create a variable we have to tell
14:32 - cobalt what it's going to be numeric
14:35 - just numbers alphabetic just letters or
14:38 - both
14:39 - alphanumeric we also have to tell just
14:42 - how many of those letters and or numbers
14:45 - we think we're going to be using and we
14:47 - do all this because cobalt is an
14:49 - extremely efficient programming language
14:52 - and part of what lets it be so efficient
14:54 - is knowing exactly what's going on with
14:56 - all of its data right from the beginning
14:59 - we set this up in the picture clause
15:02 - picture or pick for short sets the
15:05 - length and the data type of a programmer
15:08 - selected variable name
15:09 - so pic9 is a single numeric value where
15:13 - the length is 1. the 9 means numeric it
15:17 - doesn't mean it's a value of 9 or a
15:18 - length of 9 it just means here's a
15:21 - variable of numeric type and since we
15:23 - didn't specify a length we only get one
15:26 - it defaults to one so i don't know maybe
15:29 - we're programming an elevator in a
15:31 - building with nine floors we could use
15:33 - that to store what floor we're currently
15:35 - on could be handy for that
15:37 - and if we need more than one digit we
15:39 - can specify that within the parentheses
15:41 - like here pick nine parentheses four
15:44 - that says it's a numeric variable and
15:47 - there's four of them that might be a
15:49 - good place to store perhaps the year
15:52 - because obviously you would need four
15:54 - digits to represent a year like 2020 or
15:58 - 2021 or 55 45 or 1999
16:03 - four digits for the year always
16:07 - pick a means we have a single alphabetic
16:09 - character and because we didn't specify
16:12 - length we only get one so i could use
16:13 - that to store my favorite letter
16:16 - z
16:18 - pick x eight gives us eight alphanumeric
16:21 - characters
16:22 - x means alphanumeric and with that many
16:25 - i could store a us license plate made up
16:27 - of up to eight letters and numbers now
16:30 - not all pick clauses are created equal
16:33 - so you need to know that the maximum
16:35 - length of a numeric picture clause is 18
16:38 - while an alphabetic pick clause can be
16:40 - up to 255
16:42 - and know that there are lots of other
16:44 - types of pick clauses we will dive into
16:46 - those as we need them for now just focus
16:49 - on those three numeric alphabetic and
16:52 - alphanumeric
16:54 - you can use picture clauses to represent
16:56 - symbols that appear in the value so for
16:58 - example
16:59 - pick nine parentheses four v nine
17:03 - what the heck does that mean well nine
17:06 - parentheses four means there's four
17:08 - digits then we've got a v which
17:11 - represents the decimal position the dot
17:14 - then two more nines so two more digits
17:17 - we can use this pick clause to represent
17:20 - 1425.82
17:23 - that could be a radio frequency or a
17:25 - measurement of some sort we can also do
17:28 - something like this pick dollar sign 9
17:31 - comma nine nine nine v nine nine
17:35 - that can be used to represent one
17:37 - thousand two hundred and thirty four
17:38 - dollars and fifty six cents the dollar
17:41 - sign and comma carry through and the v
17:43 - indicates the decimal area when we think
17:46 - of a variable we often think about
17:48 - something variable meaning it can change
17:52 - cobalt also has things called literals
17:54 - which contain data that will not change
17:56 - during the course of the program so i
17:59 - might use a literal to store something
18:01 - that i'm going to use several times in a
18:03 - program but only want to have to set it
18:05 - once for all those other places
18:07 - so maybe the name of a company a string
18:10 - of characters that i use to separate
18:12 - lines and output or copyright
18:14 - information
18:15 - anything that's going to get used more
18:17 - than once and isn't going to change
18:18 - while a program is running cobol has a
18:21 - few figurative literals built in to make
18:24 - things easier you can use them without
18:26 - setting them up yourself and a few
18:28 - you'll find most handy are zero and
18:30 - zeros space and spaces low value high
18:34 - value null nulls and you'll notice that
18:36 - for some of these there's a singular as
18:39 - well as a plural version very handy so
18:41 - if you're starting a new variable and
18:43 - you want it to be all spaces the
18:45 - efficient way to set that up is using
18:47 - the spaces literal rather than sitting
18:50 - there and going space basically
18:53 - using literals is what efficient
18:55 - programmers do and i want you to be an
18:57 - efficient programmer up next our good
19:00 - friend the data division
19:02 - [Music]
19:10 - all of the data you're going to use in
19:12 - your program gets set up in the data
19:14 - division to add structure to this we use
19:17 - what's called a data relationship we can
19:20 - see that by looking at this segment of
19:21 - code right here in this data division
19:24 - we've got level indicators each with
19:26 - their own descriptive entry
19:28 - print rec has a level indicator of 01
19:31 - meaning it's the highest and then the
19:33 - data definitions are below it at 0 5
19:37 - and the file account rec has its own set
19:40 - of variables with their own level
19:42 - indicators down here don't you just love
19:44 - that structure it's basically saying the
19:46 - data this file needs are the account
19:49 - fields and then below it it spells out
19:51 - exactly what those account fields are
19:54 - so we've declared the data let's do
19:56 - something with it
19:57 - move and compute are reserved words that
19:59 - we use to alter the value of variables
20:02 - move does well you probably figured it
20:05 - out it moves the data from one place
20:08 - into a variable and compute is used to
20:10 - perform math so in this example we've
20:13 - got a bunch of 77 level variables up top
20:16 - which are who where why rate hours and
20:19 - gross pay you'll notice the first three
20:22 - are alphanumeric and the last three are
20:24 - numeric then down in the procedure
20:26 - division we're using move to set up some
20:29 - of those variables the who where and why
20:32 - are captain cobalt san jose california
20:35 - and learn to be a cobol expert
20:38 - and that's spelled out pretty clearly on
20:40 - those lines we're also setting the hours
20:42 - and rate to 19 and 23.
20:45 - we are not going to set the gross pay
20:48 - with a move instead we're going to use
20:50 - compute and set that to the answer of
20:53 - our times rate
20:55 - and then lastly we'll output the values
20:58 - of our variables with some text before
21:00 - them so the person using the program
21:02 - knows what value they're looking at
21:04 - pretty simple right good because it's um
21:08 - oh yeah it's time for a lab
21:11 - take a look at the payroll zero zero
21:13 - cobalt source code in the id.cbl dataset
21:17 - and when you're ready to give it a try
21:19 - make sure you're submitting the jcl for
21:21 - it and not the cobol itself you submit
21:23 - the jcl to run the cobol got that i know
21:27 - you do have fun
21:29 - [Music]
21:36 - up until now we've mostly been moving
21:38 - data between variables taking them from
21:41 - user input or outputting them to a
21:42 - display now we're going to take things
21:44 - to the next level and start working with
21:46 - files
21:48 - to do this we're going to use select and
21:50 - assign clauses in the environment
21:52 - division
21:53 - fd statements in the data division and
21:56 - from the procedure division open close
21:59 - read into and write from statements
22:02 - the environment and data division is
22:04 - where we describe our inputs and outputs
22:06 - which will get used in the procedure
22:08 - division because as we all know
22:11 - that's where the action happens
22:13 - let's take a look at that action in
22:15 - action here you can see the file control
22:18 - paragraph in the input output section of
22:21 - the environment division
22:23 - what we're doing here is associating
22:25 - each cobalt internal file name with an
22:28 - external data set name in this case
22:30 - print line is the name of the internal
22:33 - file name and
22:35 - p-r-t-l-i-n-e
22:36 - is the external data set or file so
22:40 - that's the select and assign clauses in
22:42 - the environment division
22:44 - further down in the data division this
22:46 - is where we define the level numbers
22:48 - variable names data types and lengths
22:51 - the fd reserve word is used to give the
22:54 - cobalt compiler more information about
22:56 - those internal file names
22:58 - so print line which is linked with the
23:01 - data set file prt lina has these fields
23:06 - types and lengths and account rec which
23:09 - is linked to a cct rec has these fields
23:13 - types and lengths
23:15 - when your cobalt code is running on an
23:16 - ibm z mainframe it'll have access to
23:19 - both traditional z os data sets as well
23:21 - as unix files for right now we're going
23:23 - to focus on the z os sequential data
23:26 - storage method because it's extremely
23:28 - common and a good place to start when
23:30 - working with files in cobol
23:32 - a data set in z os is made up of records
23:36 - and you can think of each record as a
23:38 - line within a data set with a defined
23:41 - length so like anything written out row
23:43 - by row you'll find the exact value
23:46 - you're looking for by scanning down to
23:48 - the right record and then across for the
23:50 - field you want
23:52 - if you take all these fields and add up
23:54 - their length that makes up the entirety
23:56 - of the length of that record you got it
23:58 - it's kind of simple the way data input
24:01 - output or io is handled is a program
24:03 - says hey i'd like to read this piece of
24:06 - data out here and then the operating
24:08 - system or data io subsystem goes and
24:11 - gets it and places it into memory where
24:13 - the program can go and read it if a
24:15 - program is requesting lots and lots of
24:17 - reads one right after the other that's a
24:19 - lot of i o operations which is somewhat
24:22 - inefficient and can lead to slow
24:23 - performance it would be like going into
24:25 - a restaurant and ordering a soda and
24:27 - then waiting until that's brought out
24:28 - and saying you know what i'd also like a
24:30 - hamburger then they bring that out you
24:32 - say fries too
24:34 - and they bring that out and you say
24:36 - ketchup and then they throw you out of
24:38 - the restaurant because that's extremely
24:39 - inefficient and annoying and we don't
24:41 - want to be inefficient or annoying in
24:43 - cobalt programming we have this concept
24:45 - of something called blocks because we
24:47 - know so much about the records we can
24:50 - load data as a block where a block is a
24:53 - group of records as long as the program
24:55 - is going to read one record followed by
24:57 - the next followed by the next and so on
25:00 - we can get the records we want in order
25:02 - into what's called a buffer take a look
25:05 - at this we can see a block of records
25:08 - loaded into a buffer where the overall
25:10 - record length is the size of each field
25:12 - combined we set that overall block size
25:16 - in the buffer with the block contains
25:19 - clause
25:20 - earlier we used the assign clause to
25:22 - describe a data set source file we said
25:25 - select account rack with a dash in it
25:28 - assigned to account rec if we're running
25:30 - this in z os using jcl we need to have a
25:33 - jcl dd statement to link account rec to
25:36 - that actual data set
25:38 - the jcl required for the cobalt compiler
25:41 - to make the connection back to the
25:42 - actual data set looks something like
25:44 - this slash slash account rec
25:47 - d d d s n equals my.data comma disp
25:51 - equals shr
25:54 - if you're unfamiliar with jcl this is a
25:56 - data declaration statement that's what
25:58 - the dd stands for it says that for
26:01 - account rec look here at my.data the
26:05 - disk equals shr just means it expects
26:08 - that the data set exists before we try
26:10 - to use it and that other people can use
26:12 - it at the same time we don't require
26:14 - exclusive access
26:15 - now i don't know about you but i kind of
26:17 - want to see this all spelled out from
26:19 - end to end so we'll start out with
26:21 - account rec that's what we reference
26:24 - within our procedure division in the
26:25 - actual code
26:27 - account rec is what's defined in the
26:29 - environment division's input output
26:31 - section
26:32 - slash slash account rec a cct rec seven
26:36 - characters then gets connected via a dd
26:39 - statement to my.data the actual data set
26:42 - on the disk now don't sweat the jcl
26:45 - stuff too much right now i know you came
26:46 - here to learn cobol not jcl and chances
26:49 - are if you're given some code to write
26:51 - or modify somebody will prepare that jcl
26:54 - for you or at least tell you what data
26:56 - sets and names to use so you won't have
26:57 - to guess
26:59 - there's a link to an online resource for
27:01 - basic jcl concepts in the course notes
27:03 - if you're curious though
27:05 - one other important note the cobalt
27:07 - compiler assumes that what you tell it
27:09 - for the file names is true and correct
27:12 - and it will work when it goes to run
27:14 - because it doesn't have any way of
27:16 - checking what's actually in your jcl or
27:18 - actually on the file system
27:20 - and if any part of that chain is broken
27:22 - or not correctly linked you're going to
27:24 - get an error at run time
27:26 - that's why it's important to have a good
27:28 - naming scheme because chasing those
27:30 - types of errors is no fun at all
27:32 - up next we'll talk about putting all
27:34 - that to use in the procedure division
27:37 - [Music]
27:45 - now we're in the procedure division
27:47 - where we actually open those files that
27:49 - happens in the open file section and we
27:51 - can open files for input and output like
27:54 - this
27:54 - here we've got account rec open for
27:56 - input and print line open for output and
28:00 - just as we open the file we should
28:02 - really make sure to close them when
28:03 - we're done this can be done at the
28:05 - program completion or if it's going to
28:07 - be a long running program when we're
28:08 - done using that file resource we do that
28:11 - with the close dash stop
28:14 - so we just say close
28:16 - account dash rec and then close print
28:19 - dash line and then stop run stops the
28:22 - processing
28:23 - because cobalt is often used to handle
28:26 - lots and lots of data it's a safe
28:28 - assumption that we'll need a way to
28:29 - process records one after the other
28:32 - until we're done you may have seen in
28:34 - other programming languages the concept
28:36 - of a for or a do statement cobalt uses
28:39 - perform and in practice it looks like
28:41 - this
28:42 - i encourage you to hit the pause button
28:44 - on this screen and study it for a little
28:46 - bit because while it's extremely
28:47 - straightforward there are a few bits in
28:49 - here that might raise an eyebrow and
28:51 - we'll go through all of that so i'm
28:54 - stalling here to give you time to find
28:56 - the pause button
28:58 - and we're back so starting at the top
29:01 - we've got the read next record paragraph
29:05 - the first thing we're going to do here
29:06 - is perform a read record that's the
29:09 - first line there are no conditions about
29:11 - it we're going to do a read record at
29:13 - least once
29:15 - that read dash record is defined down
29:17 - here that is going to read the next
29:20 - record from the file and if we're at the
29:23 - end put a y presumably for yes into
29:27 - lastrack
29:28 - then when we're done reading we have
29:30 - this end read and even though that
29:33 - terminates logically and explicitly with
29:35 - the end read it also terminates
29:38 - implicitly with that period there so
29:40 - we're just being complete covering all
29:41 - of our bases
29:42 - now going back up into the read next
29:45 - record we're indenting and our first
29:48 - line here is a perform until
29:51 - it says perform until last rec equals y
29:54 - and why would last rec equals y
29:57 - it would be y if read record detected it
30:00 - hit the bottom and it processed its last
30:02 - record
30:03 - and if that file was empty it would hit
30:06 - this first perform put a y into last rec
30:10 - and then the logic of this until
30:12 - statement would say we're done
30:13 - performing we're bumped out of the logic
30:16 - because there's nothing left to do here
30:18 - and we've also hit this implicit
30:20 - terminator so we're done with this
30:22 - paragraph if the file is empty
30:25 - if the file has a couple of records in
30:27 - it like we would expect then we continue
30:29 - and we're going to do a write record
30:31 - with the data we just got that's defined
30:34 - down at the bottom of the example code
30:36 - then we'll do another read record before
30:38 - going back up to the top of this perform
30:40 - loop where we'll check to see if we got
30:42 - a y
30:43 - if it does we'll end if it's values then
30:46 - we're going to use write record to write
30:48 - them out continuing that process until
30:50 - we've hit the bottom of the file setting
30:52 - last rec to y and finishing
30:55 - reading a file from top to bottom is
30:57 - like the c major scale of cobalt
30:59 - programming you're going to have to do a
31:01 - lot of it so you should know how to do
31:02 - it forwards and backwards and this code
31:04 - right here is a great example of this
31:07 - type of logic done right
31:09 - keep all that good stuff in mind as we
31:11 - go into lab number three you'll use
31:14 - everything we touched on in this lesson
31:16 - to fix some code remember that the all
31:18 - important chain of links between the
31:20 - procedure variables environment
31:22 - variables and the jcl data sets needs to
31:26 - be correct and if it helps write them
31:28 - out so you can double check things as
31:30 - you write it go get to it lab number
31:32 - three
31:37 - [Music]
31:41 - you'll often hear cobalt referred to as
31:43 - a structured programming language in
31:46 - this definition structured means that it
31:48 - relies on the concept of passing control
31:50 - and adhering to a flow structure as a
31:53 - program executes in other words the way
31:56 - that you write your code is used to
31:58 - spell out how it should be executed
32:00 - people writing code in c pli python and
32:04 - of course cobalt use the structure of
32:07 - their languages to ensure code flows
32:09 - exactly the way it ought to
32:11 - another style of programming known as
32:13 - object oriented programming divides code
32:15 - up into smaller segments called classes
32:18 - each having its own specific purpose
32:20 - and each class has its own set of
32:22 - variables and methods then once the
32:24 - classes are defined you write the code
32:26 - that describes the interaction between
32:28 - them all and if you're writing a program
32:30 - where you're going to benefit from this
32:32 - type of class object relationship it
32:34 - allows for you to write very capable
32:36 - code without needing to define each and
32:39 - every instance of each and every class
32:41 - from scratch every single time
32:44 - however i can tell you from a little bit
32:45 - of experience that it's also very easy
32:48 - to write something that looks very
32:49 - simple but behaves completely different
32:52 - from what you intended you're
32:54 - essentially building the structure of
32:55 - code on the fly and that has its
32:57 - advantages but a lot of the code people
33:00 - write on cobalt needs to be transparent
33:03 - and readable and easily diagnosed which
33:05 - is a lot easier to do in a structured
33:08 - language
33:09 - you get the ability to jump around a
33:11 - little bit in cobalt but you should be
33:13 - sure to use those sparingly and not rely
33:15 - on them to provide the backbone of your
33:18 - program
33:19 - as we saw before cobalt passes control
33:21 - primarily using the perform keyword and
33:24 - using paragraphs so how can we best make
33:27 - use of this structure i'm so glad you
33:29 - asked let's take a look at basic program
33:32 - control and flow through a snippet of
33:34 - code
33:35 - we're setting up the output of print
33:37 - line we're setting the message headers
33:39 - of print rec to the number is
33:43 - and then we're adding one to the counter
33:45 - variable moving that value to message to
33:48 - right and then writing print rec which
33:51 - will print something like the number is
33:53 - one
33:54 - then we do the same thing again with the
33:56 - exact same code adding one moving it to
34:00 - message to right and printing it for as
34:02 - many times as we feel like repeating in
34:04 - this section here the only indication i
34:07 - have that i might be done is that the
34:09 - name of the program is 2 10 1 so i can
34:13 - assume we'll do this 10 times
34:15 - a simple looking program but dreadfully
34:18 - repetitive and not a very good use of
34:20 - anybody's time remember we want to be
34:22 - efficient and that doesn't look
34:24 - efficient
34:25 - those three lines of code keep getting
34:27 - written again and again and again so
34:30 - rather than typing them out let's
34:32 - address that issue right here we'll move
34:34 - those three lines of code into a new
34:36 - paragraph called write new record and
34:39 - then we'll just call that paragraph 10
34:41 - times using the perform keyword so the
34:44 - program will get here then run this
34:46 - then go here then run this and i'll do
34:49 - that 10 times this is called an out of
34:52 - line perform statement because it
34:53 - requires jumping down here and then back
34:56 - up and it's definitely less code but it
34:59 - still seems kind of repetitive right
35:01 - that's where we need to look into using
35:03 - a loop using an inline perform statement
35:06 - and once i pop that up on the screen
35:08 - you'll see exactly what i mean
35:10 - in the previous versions the part of the
35:12 - code we were repeating was add one to
35:14 - the counter move that counter value to
35:17 - message to right and then writing it out
35:20 - here we see the move counter statement
35:22 - that looks the same and here's that
35:24 - print wreck we wrap those two lines in
35:27 - this perform and end perform which forms
35:30 - our loop
35:31 - so what about incrementing the content
35:33 - of counter
35:34 - that happens as a condition of the loop
35:37 - itself perform that sets up the loop
35:40 - varying counter from 0 1 by 1 until
35:44 - counter equals 11. that
35:47 - i mean we really don't have to spell out
35:48 - what it does right it basically looks
35:50 - like english perform a loop where each
35:52 - iteration of the loop increases the
35:54 - counter by one starting from one until
35:57 - we get to 11. why did we say 11 we had
36:00 - to say 11 because if we said 10 we would
36:03 - hit 10 after incrementing it match this
36:06 - until clause and bump out before
36:09 - executing the move and print part you'll
36:11 - see a logic like this in other languages
36:13 - like this java example obviously the
36:16 - cobalt version involves a lot more
36:17 - typing but it's easier to read and
36:19 - you'll also get autocomplete so your
36:21 - editor will write a lot of that for you
36:23 - another way you can get around this is
36:25 - by using a go to now
36:28 - here's the thing about go to
36:30 - don't use go to unless you absolutely
36:33 - have to do it and you absolutely know
36:35 - exactly what it's going to do
36:38 - go to does exactly what it sounds like
36:41 - it jumps the program to where you're
36:42 - directing it and it just kind of picks
36:45 - up and runs from there the difference
36:46 - between go to and perform is that
36:49 - instead of it being a special assignment
36:51 - that will do and then return from it's
36:53 - just gonna go there and start executing
36:55 - from there it's like when you're reading
36:57 - something online you see a word or a
36:59 - phrase you don't understand so you
37:01 - search for it and you find a video about
37:03 - it and you watch that video ideally you
37:05 - go okay cool now i understand that and
37:08 - you jump back to where you were or if
37:10 - you're like me you go hey that was kind
37:12 - of cool what was i looking at again and
37:15 - there goes the whole afternoon
37:17 - if you were to go back to that program
37:18 - we showed earlier and replaced the
37:20 - second perform right new record call
37:22 - with a go to right new record like this
37:26 - the program would jump ahead to the
37:27 - right new record paragraph execute it
37:29 - and then just keep on going because it
37:31 - didn't know that was on a special
37:33 - assignment it just thought okay well
37:35 - this is where i am now just understand
37:37 - the difference and be careful when using
37:39 - go-to statements because you might be
37:41 - losing some of that structure that your
37:43 - program needs to be successful
37:46 - if that didn't make sense you might want
37:48 - to re-watch this video and check your
37:50 - notes because right now we're going to
37:52 - go to the next video
37:55 - [Music]
38:03 - when you start planning a program start
38:04 - thinking in paragraphs if you were to
38:07 - start whiteboarding the overall flow of
38:09 - a program drawing words and boxes and
38:11 - connecting those boxes with arrows a lot
38:14 - of those boxes will get implemented as
38:16 - paragraphs and that's good that's kind
38:18 - of the point a paragraph gets defined in
38:21 - the procedure division starts at column
38:24 - eight and can have any name you like
38:26 - apart from a reserved cobalt keyword the
38:28 - declaration of a paragraph is terminated
38:31 - with a period the paragraph itself can
38:33 - contain one to many cobalt sentences and
38:37 - is terminated by either the start of
38:38 - another paragraph or the end of the
38:41 - entire program
38:42 - from an application architecture
38:44 - perspective you really want to spend
38:46 - some time up front charting out the flow
38:49 - of your program and deciding what part
38:51 - will get handled in what paragraph if
38:54 - you start this way instead of kind of
38:56 - figuring it out as you go along not only
38:58 - will your code be less error prone
39:00 - you'll have a nice reference to use
39:02 - later on
39:03 - now there are two big situations where a
39:06 - light should go on over your head and
39:07 - you'll say to yourself ah
39:09 - that's a good use for a paragraph
39:11 - the first is if you find yourself typing
39:13 - the same couple of lines over and over
39:15 - and over again like adding a bunch of
39:17 - numbers together and finding the average
39:20 - if you find yourself doing that think
39:21 - about packaging those up into a
39:24 - paragraph and giving it a name and by
39:26 - the way put at least a few seconds of
39:28 - thought into your paragraph names nobody
39:31 - wants to open up a bunch of source code
39:33 - to find paragraphs called do file stuff
39:36 - or test123
39:39 - aim for something like open input files
39:41 - or check for duplicates that way you
39:44 - know exactly what's going on in there
39:46 - also if you've got a couple of lines
39:48 - that need to happen a bunch of times
39:50 - extracting those lines into a paragraph
39:53 - and using a perform keyword to execute
39:55 - them a certain number of times or until
39:58 - a certain condition is met is good
40:00 - practice for writing comprehensive code
40:03 - a paragraph can come before or after the
40:06 - code calling it but you should try to
40:08 - order your paragraphs close to the order
40:10 - that they'll be executed in at run time
40:13 - just to make it easier to find them what
40:15 - i'm saying is don't just throw new
40:17 - paragraphs at the bottom of the program
40:19 - you may see people start their
40:21 - paragraphs with numbers and each
40:22 - paragraph will look like one thousand
40:24 - dash open files two thousand dash read
40:27 - next record and so on then as you extend
40:30 - your program you can add them into the
40:32 - appropriate significant digit that way
40:34 - you can say you know what that paragraph
40:36 - should be in the three thousands and so
40:38 - on we kind of don't have to rely on this
40:40 - anymore with modern editors that can
40:42 - quickly jump between the paragraphs of a
40:44 - program but this explains why you might
40:47 - see this done in code that you're
40:48 - looking at and you may or may not choose
40:50 - to do the same when you write yours
40:53 - you may also see empty paragraphs at the
40:55 - end of other paragraphs like this
40:57 - the open files end paragraph has no code
41:01 - and does nothing but for someone reading
41:03 - through code it makes a nice visual
41:05 - indicator that the code for this
41:07 - paragraph ends here it also comes into
41:10 - play if you're using the perform through
41:12 - keyword which we'll learn about in just
41:14 - a little bit
41:15 - one of the simplest ways of setting up a
41:17 - loop is with times for example here we
41:20 - say perform 10 times and then some code
41:23 - finishing with end perform
41:26 - and we can set that up with a number
41:28 - just like that or with a numeric
41:30 - variable like this perform my new
41:32 - paragraph counter times whatever counter
41:36 - is it'll perform that paragraph that
41:38 - many times we can also perform through
41:41 - and this can be spelled out through or
41:44 - just th r u
41:45 - check out this example
41:47 - we have our first paragraph 1000
41:49 - paragraph a that says perform
41:52 - 2000 paragraph b through 3000 paragraph
41:56 - c
41:56 - this is another reason to consider the
41:58 - order that you state your paragraphs now
42:01 - we'll hit this perform through jump down
42:03 - and execute paragraph b and c and then
42:06 - finish this paragraph we'll never hit d
42:09 - because we were only performing through
42:11 - paragraph c
42:13 - we can also perform until which will
42:15 - evaluate the check and if that condition
42:18 - is not met it'll take some action this
42:20 - is usually done until a number hits a
42:23 - certain level or two variables are the
42:25 - same like increment this value until
42:28 - it's equal to that value
42:30 - in this example the order is that we do
42:32 - the check and then do the code and if
42:34 - the condition is met we're done we've
42:37 - done it until
42:38 - if that doesn't match your logic we can
42:40 - also do perform until with test after
42:44 - like here this will run the loop and
42:46 - then do the test
42:48 - there's also perform varying where we
42:51 - say something like
42:52 - perform varying counter from 0 1 by 1
42:57 - until counter equals 11. we just looked
42:59 - at that earlier
43:00 - and if you really want to get fancy you
43:02 - can nest those performs like this where
43:04 - we've got two counters going on counter
43:07 - and counter two and every time we
43:09 - increment counter by one we're going to
43:11 - step counter two from one to five in
43:15 - increments of one so we would get one
43:18 - one two three four five two one two
43:20 - three four five three one two three four
43:22 - five and so on
43:24 - now i don't know about you but i'm
43:26 - starting to get a little loopy myself in
43:28 - the next video we'll cover linking in
43:31 - other cobol programs
43:33 - [Music]
43:41 - a cobalt program can call other cobalt
43:44 - programs and you do that with the call
43:46 - keyword followed by the name of the
43:48 - program
43:49 - that can be call prog a1 with the
43:52 - literal program name being in single
43:54 - quotes or like this where we move the
43:57 - program name to a variable and then call
43:59 - that variable
44:01 - the way a calling program calls a called
44:03 - program is through something called
44:05 - linkage and i'm going to show you a very
44:07 - basic example of it the program being
44:09 - called has this section called the
44:11 - linkage section and in here it defines
44:14 - three variables month day and year
44:17 - they're all numeric two digits for month
44:20 - and day and four for year of course
44:22 - there's four for year and they've all
44:24 - got an ls at the end so you know they're
44:26 - in the linkage section as opposed to the
44:28 - variables up here in the working storage
44:31 - section which have a ws at the end
44:34 - so this program over here that we're
44:36 - calling it knows that it's going to be
44:38 - called and it prepares itself by setting
44:41 - up the linkage section it also sets up
44:43 - the procedure division using the using
44:46 - keyword so it's going to use those three
44:48 - variables from the linkage section in
44:50 - addition to the three variables from the
44:53 - data division working storage section
44:56 - now the calling program sets up those
44:58 - three variables in preparation for this
45:00 - which in this case matched the variables
45:03 - in the linkage section we want to set
45:05 - those up just like any other variable
45:08 - then we do this call date sub using
45:12 - month out day out year out there's those
45:15 - three variables we're calling that other
45:17 - program and giving it those three
45:19 - variables to store the output that it
45:21 - generates
45:23 - linking programs can get quite
45:25 - complicated but for now we're just going
45:27 - to leave it at that just know that there
45:29 - are ways of passing actual data as
45:32 - opposed to references to data mechanisms
45:34 - for getting a return value from a called
45:37 - program and all other sorts of goodies
45:39 - once a program reaches a certain size
45:41 - you're almost guaranteed to see
45:43 - everything we've talked about in these
45:45 - last few videos put to use so if this
45:47 - all makes sense you're in good shape
45:49 - let's keep this party going
45:51 - [Music]
45:59 - a big part of cobalt is generating
46:02 - reports you've got tons and tons and
46:05 - tons of data and you need a way to
46:07 - produce a report of that data so someone
46:09 - else can look at it and go
46:12 - hmm yes yes
46:15 - that's very good yes
46:18 - for that reason we've spelled out an
46:19 - example of generating report data here
46:22 - which can be very easily scaled out to
46:24 - handle multiple records and called any
46:26 - number of different ways at the end
46:28 - you'll be asked to complete a lab that
46:30 - puts all of this to use
46:32 - previously we looked at the select and
46:35 - respective assign programmer chosen
46:37 - names we had something like this in the
46:39 - environment division we used print line
46:42 - as the internal cobalt file name for the
46:44 - output
46:45 - now in the file descriptor marked by fd
46:49 - within the file control paragraph we
46:51 - start to connect it all together the fd
46:54 - entry defines the layout of the record
46:57 - within that print line internal file
47:01 - and you can see you were saying fd is a
47:04 - file the highest level descriptor is
47:07 - print wreck and then within that print
47:09 - wreck we have the individual fields
47:12 - defined
47:13 - first account number o presumably for
47:16 - output that's a value of eight
47:18 - alphanumeric characters then look at
47:20 - this filler that's an odd name for a
47:23 - field and it's actually not a field but
47:25 - a cobalt reserved word remember those we
47:28 - use filler to allocate memory space
47:31 - typically between words or variables and
47:34 - filler can be empty it can be dashes or
47:37 - any literal in this example it's eight
47:40 - characters of account number then two
47:43 - spaces and you can see that we spelled
47:46 - out spaces there with s-p-a-c-e-s that's
47:49 - a handy shortcut so you don't actually
47:51 - have to type out the spaces
47:53 - each one of those filler lines in here
47:56 - is just inserting two empty spaces and
47:58 - in this case it might seem somewhat
48:00 - basic but without filler your reports
48:03 - would just be a bunch of values slammed
48:05 - up against one another consider this
48:07 - partial program
48:09 - this is the working storage section
48:11 - we've got four headers defined there's
48:14 - no logic in here this is just something
48:16 - that defines what our data looks like
48:18 - notice we've got some areas up here that
48:20 - are just filler and we're filling them
48:22 - up with this text financial report for
48:26 - then in header two it's a mixture of
48:28 - literal labels and printed out variables
48:31 - so we'll have the word year notice it's
48:33 - year with a space at the end of it and
48:35 - that's why it's five characters
48:37 - then the value of hdr year header year
48:42 - same with month and day
48:44 - header three is all filler it's just
48:46 - account two spaces last name two spaces
48:50 - limit two spaces and balance and then
48:52 - forty spaces
48:54 - if you need forty spaces for your
48:56 - account balance i wanna be your friend
48:58 - send me an email once you're done
49:00 - learning cobalt
49:02 - then in header four this is more filler
49:04 - it's eight dashes two spaces ten dashes
49:08 - two spaces and so on so what i see up
49:11 - here so far is a header that goes up top
49:13 - and that says what the report is and
49:16 - then there's some sort of header info
49:18 - that spells out the time period the
49:19 - report is for which is kind of important
49:22 - and then we've got two headers for the
49:23 - values which i'm assuming will be listed
49:26 - out below
49:27 - makes sense so far
49:28 - so that header too that's date info the
49:31 - data name layout for the date info is
49:34 - defined here and it's kind of neat how
49:36 - this works the high level variable name
49:40 - is ws current date data that's ws for
49:45 - working storage and then within that
49:47 - we've got two sections ws current date
49:50 - and ws current time
49:53 - the date is divided up into the year
49:56 - month and day and the time is divided up
49:59 - into hours minutes seconds and
50:01 - milliseconds now we know exactly what
50:04 - that current date data looks like
50:08 - which is good because that's one of the
50:09 - first things we're going to do in the
50:11 - procedure division aka the division
50:14 - where all the action happens
50:20 - check out this procedure division we
50:22 - start out with a paragraph called write
50:24 - headers and then we've got these four
50:26 - move sentences the first one takes the
50:29 - current date from what's known as an
50:31 - intrinsic function
50:33 - more on that later but what it does is
50:35 - it takes the current date of when that
50:38 - code is actually executed and it copies
50:40 - it into ws current date data
50:44 - then because we defined how the fields
50:46 - of year month and day line up within
50:49 - that data name layout we can just tell
50:52 - it to move the year month and day
50:54 - portions of that data into those three
50:57 - variables then in lines five and six we
51:00 - write out our report header that's the
51:02 - financial report four part and the date
51:04 - info that follows it from header two
51:07 - we're writing those out to print rec and
51:09 - we're writing them out there from header
51:12 - one and header two
51:14 - then we move spaces to print rec and
51:17 - line seven if we didn't do this we might
51:19 - leave straight characters behind we want
51:22 - to start out with the next series of
51:23 - moves and writes assuming that we have a
51:25 - blank record and then we write it out so
51:28 - if you're following along at home which
51:30 - i hope you are we've got the financial
51:33 - report for then the date header and info
51:36 - then a blank space because in line eight
51:39 - we wrote out that line of spaces and put
51:41 - it into the print rec in line seven
51:44 - lines nine and ten write out the column
51:46 - headers of account last name limit
51:49 - balance and those nifty dashes that went
51:51 - under them now all we have to do is
51:53 - print out the data that goes underneath
51:55 - those headers and
51:57 - you know what that's where the lab comes
51:59 - in
52:00 - that will show you how you can take data
52:02 - from a file and use it to generate a
52:04 - report with all the nice formatting and
52:06 - spacing that makes it nice and easy to
52:08 - read after that why don't you report
52:10 - back here for the next lesson
52:13 - [Music]
52:21 - the path that a program takes is
52:22 - sometimes referred to as its logic does
52:25 - the user want to enter more data if yes
52:28 - then we'll jump to the part of our code
52:30 - where we'll let them put in more data if
52:33 - they're done then we'll jump to the part
52:34 - of our code where we're going to process
52:36 - that data it's kind of like hitting a
52:38 - fork in the road and we use what we know
52:41 - to inform that decision
52:43 - maybe you want to look at a bunch of
52:45 - accounts and find the ones that haven't
52:46 - been updated in the last 60 days in that
52:50 - case we're taking the difference between
52:51 - the most recent update and today's date
52:54 - and comparing that difference to 60.
52:57 - presumably if the difference is greater
52:59 - than 60 then we're gonna do something
53:01 - special with that account
53:03 - that's all logic and unless we insert
53:06 - our own logic a program is going to run
53:09 - from the top to the bottom until it's
53:11 - done so we need to learn how to express
53:14 - what we want to happen in a program's
53:16 - logic
53:17 - three of the most common types of cobol
53:19 - conditional expressions are
53:21 - general relation conditions class
53:23 - conditions and sign conditions and a lot
53:26 - of these are fairly simple it's taking
53:28 - two operands comparing them to one
53:30 - another and saying is this greater than
53:32 - that or is this equal to that or saying
53:35 - is this numeric is this lowercase
53:38 - sometimes because of the way our logic
53:40 - is structured we'll want to say is this
53:42 - not numeric because maybe we asked the
53:45 - user for a number and we got that
53:47 - something like xx and we need a way of
53:49 - saying if this is not numeric go and
53:52 - prompt that user again and remind them
53:54 - we're looking for a numeric answer so
53:57 - whenever you're writing a conditional
53:59 - expression they typically start out with
54:01 - is
54:02 - and then there's a test or a comparison
54:04 - afterwards and you can between the test
54:07 - and the comparison throw in a knot to
54:09 - flip that logic around
54:11 - there's another important and powerful
54:13 - tool you have in writing program logic
54:15 - known as conditional names these are
54:18 - used primarily to say the input we're
54:21 - taking needs to pass this test
54:23 - a conditional name is declared in the
54:25 - working storage section with an 88 level
54:28 - number in this case it has to be an 88
54:32 - level number we use a conditional name
54:34 - to say the variable that i'm under needs
54:37 - to match this and it can be a literal a
54:40 - series of literals or a pattern or
54:42 - anything like that and it's a good way
54:44 - of verifying user input and again it
54:46 - always has to be an 88
54:49 - take a look at this example
54:51 - we move az into usa-state
54:55 - then we enter this if statement if state
54:59 - the only way this will pass as true is
55:02 - if state evaluates as true which in this
55:06 - case will only pass if it's equal to tx
55:09 - so we're going to say the state is not
55:12 - texas
55:14 - then here we're moving tx to usa-state
55:18 - that will pass because it matches that
55:20 - 88 conditional statement it equals tx
55:24 - why would we do something like this well
55:26 - imagine instead of just putting in one
55:28 - state we put in all 50. that makes sure
55:30 - somebody didn't put in something like z
55:33 - z or one two as their state or something
55:35 - like that that didn't make any sense so
55:37 - we can use conditional names as a way of
55:40 - validating or limiting data before we
55:42 - try and do something with it
55:44 - there are other ways of implementing
55:46 - this type of logic but being able to
55:48 - have one place to define the scope of
55:50 - the data for a test is quite handy
55:53 - if we're comparing values like if this
55:56 - is greater than that we use conditional
55:59 - operators and those include is greater
56:02 - than which can be written out as is
56:04 - greater than sign remember those
56:06 - alligator mounts
56:07 - or is equal to which can be written out
56:10 - with the equal sign we can also say is
56:13 - greater than or equal to with is greater
56:15 - than equal to
56:18 - we can take that concept and put it to
56:20 - use in conditional expressions that's
56:22 - where we put those if then else
56:24 - statements to use and you're probably
56:26 - already familiar with those concepts
56:28 - either from another programming language
56:29 - or just from everyday talking logic if
56:32 - it's nice out then i'm gonna go for a
56:34 - hike else i'm just gonna stay inside and
56:36 - play video games again we've defined two
56:39 - possible outcomes and what will inform
56:41 - that decision the weather
56:43 - in code we might write something like
56:45 - this
56:46 - if facial expression is happy then say
56:49 - hey i'm glad you're happy otherwise say
56:52 - what can i do to make you happy
56:54 - obviously we would want this program to
56:55 - actually do stuff if you're happy or not
56:58 - happy maybe clap your hands
57:01 - but this shows a basic if then else
57:04 - statement
57:05 - we have another way of doing this that's
57:07 - more useful if there's more than two
57:09 - paths and that's an evaluate statement
57:11 - we set that up like this
57:13 - first we evaluate facial expression when
57:16 - it's happy we do this when it's sad we
57:18 - do this when it's perplexed we do this
57:20 - and we can keep on going until we run
57:22 - out of possibilities and then we hit the
57:24 - end where we just say end evaluate this
57:27 - comes in handy for menu type items like
57:29 - press one to show account balance press
57:31 - two to make withdrawal press three to
57:33 - transfer money etc each one of those
57:35 - could be a when in this big evaluate
57:38 - statement another thing that happens
57:40 - quite often in programming is performing
57:42 - some sort of function or set of steps
57:44 - until something happens maybe it's
57:46 - processing files until we've reached the
57:48 - end or adding stops to this truck
57:50 - driver's route until the truck is full
57:53 - if we're iterating over data
57:54 - specifically tables trying to find a
57:57 - specific entry we can use search
57:59 - statement that syntax looks like this
58:03 - search the facial expression table until
58:05 - you've found the index marked happy then
58:07 - presumably we do something with that
58:09 - record although in this example we issue
58:12 - a stop run so i guess they found
58:14 - happiness and there's nothing left to do
58:16 - let's get back to those conditions you
58:19 - know we can say if this number is equal
58:21 - to that number that's a test of the
58:23 - relationship between two operands which
58:26 - can be numeric or text
58:28 - we can also use conditions to test the
58:30 - content of a data item like is numeric
58:33 - or is not alphabetic lower or even is
58:36 - kanji and for numbers we can say is
58:39 - positive is negative and is zero and
58:43 - just so you know we're really only
58:44 - skimming the surface here to read more
58:46 - about all these conditions visit the ibm
58:49 - knowledge center for enterprise cobol
58:51 - there's links for that in your material
58:53 - we're coming up on that time time to put
58:56 - what you've learned to use in a lab and
58:58 - we're still working on those reports
59:00 - this time we're going to add in a
59:02 - special case if we happen to be in the
59:03 - state of virginia which will result in a
59:06 - special entry in the last line of your
59:08 - report good luck and i'll see you back
59:10 - here when you're done
59:15 - [Music]
59:19 - cobalt is often used to process lots and
59:22 - lots and lots and lots of data and a lot
59:24 - of data is made up of lots and lots and
59:27 - lots and lots of numbers
59:29 - so in order to deal with all those
59:31 - numbers we need to take a look at cobalt
59:34 - arithmetic expressions
59:36 - that's that's it that's that's the intro
59:40 - nope
59:41 - more
59:42 - all right let's put this graphics budget
59:44 - to use it's math time
59:51 - nice
59:52 - good job guys
59:53 - so what is arithmetic expression well an
59:57 - arithmetic expression can be built up
59:59 - with numbers variables that represent
60:01 - numbers the figurative constant of zero
60:04 - and any combination of those enclosed
60:07 - within parentheses including any
60:09 - combination of all that that i just
60:11 - mentioned having mathematical operations
60:14 - performed on them
60:16 - i think that about covers it
60:18 - for example number of people minus
60:21 - number of staff times three divided by
60:24 - eight would be how many pizzas you need
60:26 - in order to feed a crowd of this many
60:29 - people assuming we're not feeding the
60:30 - staff each person will want three slices
60:33 - and there are eight slices per pizza
60:35 - that's a pretty good mix of variables
60:37 - and literals and parentheses and we can
60:40 - spell expressions out with plus minus
60:43 - times divided by and you can also use
60:45 - two asterisks or stars to show
60:48 - exponentiation so 2 star star 8 is 2 to
60:52 - the 8th power meaning we keep doubling
60:55 - two eight times that's 2 4 8 16 32 64
60:59 - 128 256 2 to the eighth equals 256.
61:04 - sometimes it makes sense to spell out
61:06 - our arithmetic expressions using the
61:08 - compute command this can help make your
61:10 - code more readable or just focus a
61:12 - series of arithmetic operations in one
61:15 - place so we can say compute z
61:18 - equals a plus b divided by c exponent d
61:22 - minus e we can also say compute x y z
61:26 - equals all of that and it will assign
61:28 - the answer of whatever that might be to
61:31 - all three variables x y and z
61:34 - now you've probably heard of the order
61:36 - of operations before and if a part of
61:38 - your brain lit up that you haven't heard
61:40 - from in a while the word pemdas probably
61:43 - does the same that is the order in which
61:45 - we tackle an expression starting with
61:48 - parentheses then exponents
61:50 - multiplication division addition and
61:52 - subtraction pemdas
61:55 - by default cobalt will evaluate
61:57 - expressions this way if you want to
61:59 - either circumvent that order or you want
62:02 - to make it more clear for yourself or
62:04 - others who are reading your code you can
62:06 - also enclose sections of your
62:07 - expressions in parentheses cobalt will
62:10 - start with the most nested part of the
62:12 - expression the part enclosed in the most
62:14 - parentheses and then keep working its
62:16 - way out after that it'll look at the
62:18 - unary operators positive negative then
62:21 - exponents then multiplication and
62:24 - division from left to right and then
62:26 - addition and subtraction from left to
62:28 - right
62:29 - that means that an arithmetic expression
62:31 - must begin with either a left
62:33 - parenthesis
62:34 - a unary operator or an operand in the
62:37 - form of a literal number or a variable
62:39 - representing a number there are
62:41 - limitations to how far you can push
62:44 - arithmetic expressions in cobol the
62:46 - first is that exponents in fixed point
62:48 - expressions cannot be more than nine
62:50 - digits if the compiler sees this it'll
62:53 - truncate it and you will get a
62:54 - diagnostic message
62:56 - also while the data descriptions of
62:58 - operands in expressions don't need to be
63:00 - the same meaning you can multiply a
63:02 - two-digit number by a four-digit number
63:05 - the maximum size of each operand is
63:07 - either 18 or 19 decimal digits depending
63:11 - on the compiler option used if you're
63:13 - working with data that requires either
63:15 - very big numbers or a very high degree
63:18 - of precision make sure you know if
63:20 - you're using compatibility or extended
63:23 - mode for arithmetic there are also
63:25 - considerations to
63:27 - consider when dealing with the rounding
63:29 - of data and there's more to get into
63:31 - that we can't cover in its entirety here
63:33 - but that's all spelled out in the
63:35 - procedure division statements cobalt
63:38 - language reference
63:40 - as you've probably guessed we're going
63:41 - to get to use some of these new skills
63:43 - in the upcoming lab check out this
63:45 - change to the working storage section
63:48 - here we've got t limit and t balance
63:51 - there's some big numbers in there and
63:53 - we'll learn more about data types in the
63:54 - upcoming data type section but i can
63:57 - tell you right now those are big numbers
63:59 - or at least able to represent big
64:01 - numbers they're a comp three data type
64:04 - and they start out with a value of zero
64:07 - and look at this we've got what looks
64:09 - like more header type content except
64:11 - we're calling it trailer and i'm not a
64:13 - betting man but i think that's going to
64:14 - come at the end it looks like it's
64:17 - showing us some sort of totals so that
64:19 - makes sense too
64:20 - and then in the read next record
64:23 - paragraph we now have a perform limit
64:26 - balance total line which is calling this
64:29 - which is two compute statements which
64:31 - look like they're keeping a running
64:32 - total of the balance in total from every
64:35 - line it's processing
64:37 - hmm
64:39 - of course we're gonna write it out so
64:41 - we've got this right t limit t balance
64:44 - paragraph which moves the running totals
64:46 - into the dash o variable so that when we
64:49 - write the trailer lines out the actual
64:51 - values are gonna show up in there those
64:54 - are the parts you'll need to finish this
64:56 - sections lab and
64:58 - by my calculations it's time to get to
65:00 - work
65:05 - [Music]
65:10 - computers don't have fingers
65:13 - i mean do they
65:15 - i mean i guess
65:17 - no no they no they don't except what
65:20 - about
65:21 - no no no computers computers do not have
65:23 - fingers let's let's just stick with that
65:26 - so so when a computer is thinking of a
65:29 - number like the number eight it's not
65:31 - going like this it's lighting up little
65:34 - bits of memory that represent that
65:36 - number eight it's got its own methods of
65:38 - taking numbers letters and other
65:40 - concepts and representing them
65:42 - electronically one of the ways you can
65:44 - make sure your programs are running as
65:46 - quickly and efficiently as possible is
65:48 - by choosing the best way for cobalt to
65:50 - represent that data in its memory
65:54 - let's start out with numerical
65:55 - representation there are five different
65:58 - computational value representations
66:00 - let's start with comp one
66:03 - comp 1 is also known as a single
66:05 - precision floating point number
66:07 - representation this is useful for
66:10 - numbers that are very small and close to
66:12 - 0 or very large up to 10 to the power of
66:15 - 38 however comp one has somewhat limited
66:18 - precision it only has about seven
66:21 - significant decimal digits anything
66:23 - beyond that gets rounded so a value like
66:26 - 1 234
66:29 - 567.89
66:32 - that rate there is nine digits and it's
66:34 - going to get rounded which if you're
66:36 - dealing with dollars and cents you might
66:38 - not want to happen but for simple
66:40 - numbers a comp one might work
66:43 - then there's comp 2. this is a double
66:47 - precision floating point numeric
66:48 - representation and this can handle
66:51 - bigger numbers about 10 to the power of
66:53 - 307
66:55 - it has more significant digits up to
66:57 - about 15 so it goes further than comp 1
67:00 - in all regards but it is still somewhat
67:03 - limited and then there's
67:05 - can you guess we did comp 1 comp 2
67:09 - yes you in the back
67:11 - no it's actually comp 3 comp 3 and this
67:15 - is where it gets interesting this is
67:17 - what's known as a bcd or binary coded
67:20 - decimal this is by far the most utilized
67:23 - numeric value representation in cobol it
67:27 - is also somewhat unique and native to
67:29 - the mainframe computer and z
67:31 - architecture and with good reason it has
67:34 - to do with decimal fractions when you do
67:36 - lots and lots of operations with decimal
67:38 - fractions and the data is stored in
67:40 - binary that's when you start to get
67:42 - rounding issues representing that data
67:45 - in binary coded decimal avoids these
67:47 - issues it exactly represents values with
67:50 - decimal places and can go up to 31
67:53 - decimal digits ask someone in a banking
67:56 - credit card or payment processing
67:58 - industry why they depend on cobalt and
68:00 - they're probably going to mention bcd
68:02 - binary code of decimal and decimal
68:04 - fractions
68:06 - and then there's comp 4. comp 4 is only
68:09 - capable of representing integers so if
68:12 - you're dealing with something like a
68:13 - counter or you're only working in
68:15 - integers using comp 4 has you covered
68:17 - there
68:18 - and then there's comp 5 which is the
68:21 - same as com4 but with it you can specify
68:24 - the position of a decimal point it's got
68:26 - space efficiency of comp 4 with the
68:28 - exactness of com3 the drawback there is
68:31 - that cannot exceed 18 decimal digits
68:35 - so there's your numerical value
68:37 - representations
68:38 - numbers are good but sometimes you want
68:41 - to use letters and you'll be happy to
68:42 - know that cobalt's got you covered there
68:44 - as well there's ebcdec which stands for
68:47 - extended binary coded decimal
68:50 - interchange code and ascii which stands
68:53 - for american standard code for
68:55 - information interchange
68:57 - and it's not like one supports bigger
68:59 - words than the other it really just
69:00 - comes down to how the characters are
69:02 - represented in the computer's memory
69:04 - ebcdec has eight bits per character
69:06 - ascii uses seven and the characters are
69:09 - distributed across the possible
69:11 - combinations of those bits differently
69:13 - today the only place you're likely to
69:15 - see ebsydeck code is if you're on an ibm
69:17 - mainframe most everywhere else uses
69:20 - ascii or unicode however just keep this
69:22 - in mind if you're working on programs
69:24 - written a long time ago because every
69:26 - once in a while you'll go to load some
69:28 - data and it'll show up looking all weird
69:31 - your first instinct should be to say is
69:33 - it possible that this data is ebsedec
69:36 - and i'm trying to load it in ascii or
69:38 - vice versa because that happens quite
69:40 - often and now you'll know and you'll be
69:41 - prepared
69:42 - in this slab you'll deal with an issue
69:44 - just like that where spoiler alert
69:47 - there's a mismatch between external data
69:50 - and the cobalt representation of that
69:52 - data there's a hint and an explanation
69:54 - in there to help you along because this
69:56 - is a tricky one
70:01 - [Music]
70:05 - if you're like me one of the things you
70:07 - like about cobalt is how straightforward
70:10 - each line of code within a program is it
70:12 - does what it says it's going to do and
70:15 - there's really no mystery about what do
70:18 - this until this happens means
70:21 - however sometimes you need to do
70:23 - something beyond just add two numbers
70:25 - together or print out a line of text and
70:27 - it would be a shame if every time you
70:29 - needed to for example turn a string of
70:32 - characters from lowercase to uppercase
70:34 - you had to go and build that paragraph
70:36 - of logic all by yourself first off
70:39 - you're just repeating work and more
70:41 - importantly that's important code logic
70:43 - that needs to work right every single
70:45 - time being added onto whatever the
70:48 - primary role of the program that you're
70:50 - writing is
70:51 - there's got to be a better way
70:59 - well fortunately cobalt has a number of
71:02 - what are called intrinsic functions
71:04 - built in that you can use and if you're
71:07 - working with business data chances are
71:09 - there's something in there for you don't
71:12 - worry it's not like there's 500 new
71:14 - functions you have to keep track of the
71:16 - most recent release of enterprise cobalt
71:18 - for z os includes 70 intrinsic functions
71:22 - and they fall into the categories of
71:24 - math statistics
71:27 - date time
71:29 - financial
71:30 - character handling and
71:32 - general
71:34 - let's take a look at some of those
71:35 - intrinsic functions they all follow the
71:38 - format of function then the name of the
71:42 - function and then any arguments passed
71:44 - to that function in parentheses for
71:46 - example look at this we've got two
71:49 - variables item one and item two item one
71:52 - has hello world in it with a capital h
71:55 - and a capital w the rest lower case and
71:58 - then there's item two which is empty and
72:01 - we're going to display item one which
72:03 - should look exactly like it does up here
72:05 - with that capital h and capital w then
72:08 - we're using the uppercase and lowercase
72:11 - intrinsic functions to show item 1 in
72:14 - both uppercase and lowercase form note
72:17 - that this is just being called in the
72:19 - display function so it's not altering
72:21 - the stored data that's just how it's
72:23 - going to show up when the display goes
72:25 - to show it then in this line we're
72:28 - moving the upper cased version of item 1
72:30 - into item 2 and then displaying it so in
72:34 - this last line if we display item two
72:36 - it'll show hello world in all caps
72:40 - that's going to come in handy and making
72:41 - sure we don't have any duplicate values
72:44 - otherwise first street with lowercase st
72:47 - would be a different entry than first
72:49 - street with an uppercase st which
72:52 - happens quite often if we just uppercase
72:54 - everything we can be sure that all the
72:56 - data coming in is case insensitive
72:59 - there's also math intrinsic functions
73:02 - got a bunch of values that you want
73:03 - summed up you could line them all up and
73:06 - make an equation out of it or you could
73:08 - say compute x equals function sum
73:13 - a b c divided by d that'll sign x the
73:16 - value of a plus b
73:18 - plus c divided by d and just like before
73:21 - anything within a pair of parentheses as
73:24 - seen as one operand and it needs to get
73:26 - figured out before totaling the sum
73:29 - but wait there's more
73:45 - form that one's signed with nine spaces
73:49 - we can use the function of current date
73:51 - with the argument of one colon eight and
73:55 - move that into the first variable what's
73:57 - going on there well we're specifying the
74:00 - output in this case we want the output
74:02 - from character one that's the one
74:05 - through eight that's the eight which
74:07 - just happens to be where the year month
74:10 - and day live within that output then we
74:13 - want another function integer of date to
74:16 - turn that date into a number that number
74:19 - is the number of days that have passed
74:21 - since january 1st 1601 so it's going to
74:25 - be a big number but it's also not likely
74:27 - you'll need to go back much further than
74:29 - 1601 so pretty safe bet anyway what we
74:33 - have now is essentially a count of days
74:36 - with that we can add 90 to it and now
74:39 - we're talking about a date that's 90
74:41 - days from now you see what we're doing
74:43 - now we're going to use another function
74:45 - to transform that integer form back into
74:49 - year month and day form using the date
74:52 - of integer function see what we're doing
74:54 - there we flipped it
74:56 - and now we wind up with what is a nicely
74:58 - formatted date in the form of year month
75:02 - day and that's 90 days into the future
75:05 - because we added 90 to it and that takes
75:08 - into account going through all the
75:09 - months of different lengths leap years
75:11 - and all that stuff intrinsic functions
75:15 - and there's more lots more like 60
75:18 - something more keep that in mind as
75:20 - you're writing code and you think to
75:21 - yourself gee i can't believe i have to
75:23 - write this out by hand because there
75:25 - just might be an intrinsic function that
75:27 - you can use right there
75:29 - intrinsic functions sound like something
75:31 - you might want to try oh well guess what
75:34 - act now and you can do just that with
75:36 - this intrinsic functions lab get yours
75:39 - today
75:41 - [Music]
75:48 - we are at the last section of this
75:50 - cobalt series first off i am extremely
75:53 - glad you made it here and i hope you
75:55 - feel a lot more confident in your own
75:58 - abilities as a cobalt programmer
76:00 - of course the world goes on from here
76:02 - there are lots more functions methods
76:05 - and ways of dealing with files and input
76:07 - to explore but if you made it this far
76:09 - you can tackle anything else you come
76:11 - across you'll be able to understand the
76:14 - syntax plug it into your code make
76:16 - requested changes port a program from
76:18 - one system to another you've got all
76:21 - that just like with any other
76:22 - programming language the internet is
76:24 - full of code samples mini exercises and
76:27 - forms with people looking to help go to
76:30 - the open mainframe project and go into
76:32 - the cobol section on there for a good
76:34 - head start on those resources whether
76:37 - cobol is your first programming language
76:39 - or your 15th or your 50th i hope you've
76:42 - learned what this specialized language
76:44 - is all about and you'll see why it's
76:46 - used so widely in highly transactional
76:49 - systems all around the world from our
76:51 - team to you thank you for watching thank
76:54 - you for participating and we wish you
76:55 - the best in all that you do
76:58 - stop run
77:00 - [Music]
77:03 - you

Cleaned transcript:

hello there and welcome to your introduction to cobol no matter what brought you here we're glad to see you and hope that you enjoy all that went into creating these videos first things first what is cobalt well whenever there's an acronym i like to start there and cobalt is an acronym for common business oriented language that's a big tell right there right in the name this is a business language compared with other more general purpose languages cobol was designed around data processing specifically data processing with incredibly high accuracy extreme efficiency and ease of reading and writing cobol has indeed been around for over 60 years as of this recording and surprise surprise the fundamentals of business being able to process very large amounts of data accurately and efficiently continue to be important so all of the transactions that happen when you're using a credit card visiting a store or doing pretty much anything with a bank there's a good chance some cobalt code got executed somewhere in there in fact every day about three trillion dollars in finance gets handled by cobalt so let's just make sure we're clear here cobalt pretty much runs the world it has been kept up to date to support new requirements throughout the years and 1.5 billion lines of new code are written every year suffice to say learning this language will give you a very valuable set of skills in this course you're going to be working with enterprise cobol which is an implementation written specifically to run on ibm z mainframes the banks insurance agencies energy companies retail chains that depend on cobalt to run their extremely important transactions guess what a whole lot of them also depend on ibm z mainframes to ensure their applications can keep up with the demand 24x7 learning enterprise cobol says i want to work on the most important code running on the most important systems running the types of things that no exaggeration at all the world depends on that's a pretty bold statement and i have no problem at all saying it because it's the truth you might be thinking cobalt on the mainframe am i going to need punch cards and a tie to get through this well first of all no you'll be happy to know that we're going to be teaching all this with visual studio code which as of right now is the most popular editor used worldwide visual studio code or vs code for short supports something called language server protocol which simply put makes it able to support a very large number of languages and environments so the things you'd expect to be there like code completion workspace symbols hover text references and diagnostics can all be supported without it having to be specifically written into vs code itself it gains functionality through extensions which use the language server protocol or lsp we're going to use extensions for vs code that give us all the goodness for cobalt as well as allowing us to connect to a real live mainframe system so after you download and install vs code hop into the extensions marketplace and search for ibm z open editor and hit the install button while that's installing do the same for zoe explorer zowe that's the simple version of things for more detailed instructions on installing the extensions visit the book version for the full details and screenshots couple of basics once you're in you'll also notice these vertical lines very important for cobalt these are the margins those margins segment each line of cobalt code into its various parts which we'll get into later on just know that it's easier to see whether your text is starting right next to a line than it is to count empty spaces so lines good also if you hover your mouse over some fields a little popup box will appear showing you additional information just know that this will come in really handy when you really start hacking away at cobalt code later on and you may also notice that some words get displayed differently than others that's all part of syntax highlighting it just makes things a little bit easier to understand at a glance and this bar across the top that's the breadcrumb view it shows information about what line you're currently at click on any element in that breadcrumb trail and it will highlight the block of text for that element it'll also show you a little outline view of the code over here lastly down at the bottom of your screen there should be a panel with a problem section and if it's not there go up to view and select problems from the editor menu you can click on the problems it is found and it will jump right to those in the code it will find basic logical errors without you having to run or test your code it just knows about those problems ahead of time so you'll definitely want to fix those as they come up got all that i'd say you're ready to dive into some actual cobalt so let's go cobalt is an englishlike computer language it's that way by design meaning it's fairly easy to read understand and maintain compared with other programming languages you'll find that each line of code is pretty transparent about what it's trying to do that's often the first thing people notice about cobol that what it's trying to do is very easy to figure out and you don't have to spend a whole lot of time tracing through code to make sense of it all that's thanks in part to cobalt being standardized so the way that a cobalt implementation should be approached is all described in great detail in that standardization now cobol has gone through several revisions over the years so you do need to keep in mind which particular standard you're working with particularly when you're working with code outside of this course but it mostly comes down to the addition of a few new features better support and small tweaks to fix problems cobalt written specifically for the ibm z mainframe operating system zos is said to be enterprise cobol the code you'll see here in this course is all enterprise cobol and it all gets compiled and executed differently than cobalt you might be writing for other platforms but it is also able to take advantage of hardware and operating system features unavailable anywhere else so it still follows the current cobalt standardization but it's written with enterprise systems in mind let's take a look at some of the basic cobol syntax at a high level so you can get a better feel for the cobol standard right up front one of the key aspects of cobalt some languages use spaces some use tabs cobalt is column dependent meaning it looks at a line of code and expects certain things to be at certain positions in that line specifically it's looking in five key areas of a 72 character line and those look like this the first section columns one through six are the sequence number area sometimes these are blank other times we use them to provide context to a series of statements the next section is the indicator area and it's a multipurpose area if we're going to leave a comment an asterisk a star goes in here or if we're continuing a previous line it'll be a dash or a hyphen it can also be a d for a debugging line or a slash for source code listing formatting don't worry about all that just yet we'll show you how and why you'll use those later on just remember it's column seven and it's one character next we've got the a area which goes from columns eight to eleven in here you'll find divisions sections paragraphs level indicators and other elements that give cobalt programs their structure right next to it in columns 12 through 72 is the b area this is where you put the actual statements sentences and clauses the things that make a cobol program perform calculations and do stuff then last but not least the identification area running from column 73 to 80. well the compiler might consider at least because it actually ignores it so it doesn't consider it at all it's actually an area the programmer can use for any purpose so it's often just left blank now when you're writing in a programming language there are certain words we have to be careful of words like data end file if ready set until those are cobalt reserve words and when the cobalt compiler sees those words it thinks we're telling it to do something very specific so we shouldn't say ready unless we mean what the compiler thinks it means a full list of reserve words is available at the link in your guide in the next video we're going to talk about how all this fits together in the program structure let's talk structure koval has a hierarchy structure meaning that it's got things within other things that's part of what gives it its structure the biggest things in a cobalt program are divisions and within those divisions there are sections and within those sections you'll find paragraphs those paragraphs contain sentences and sentences have statements let's start at the statement and work our way back out a statement is a single directive usually starting with one of those reserved words we just talked about so something like add divide move compute those statements go into sentences just like a spoken sentence can reveal many pieces of information a cobalt sentence can contain one or more statements it's just a nice way of placing a bunch of statements together into a logical container so here is a sentence made up of statements and you can see that the end there is a period that period is an implicit scope terminator it says all the previous statements that have not yet ended are declared as finished you can also terminate a scope of a statement using what's known as an explicit scope terminator like if you started with an if statement and you end with an end if then you don't need to specify that you're done with a period either way works and you'll see both used throughout this course so that's sentences and what do sentences go into well generally paragraphs paragraphs are user defined written by you to give your program structure generally a paragraph represents a specific action made up of smaller steps so if it's something that might get called several times throughout your program like applying interest or prompting the user for a series of input that would go into a paragraph that way you can call that paragraph by its name from elsewhere in the program paragraphs go into sections and there are all sorts of sections they can have user defined or predefined names so they can be used to give your program structure or to make sure certain information is where it needs to be for things to run correctly and then there's divisions and there are four cobalt divisions and we can cover all those right now first is the identification division which is where you'd put the name of your program who wrote it when it was written how it should be used all that helpful information then there's the environment division there are two major sections here one lets you set the type of computer environment required to run your program and the other sets of the mapping between the files in your program and the files on the actual data sets so it's the link between your program and the system it's running on the data division sets up all the data that will be used within your program that includes files data from other programs what type of storage or memory you'll use while the program is running and what it will give up when the program ends then there's the procedure division this is where all those sections and paragraphs go so the instructions for how to take data in how to set up the variables performing math on them interacting with the user and all that kind of fun stuff that happens in the procedure division are you ready to see all those statements divisions sentences and paragraphs and actions i sure hope so because it's time for a lab basic cobol syntax in this lab you'll connect to an ibm z system check out a simple cobol hello world program and then submit the jcl to compile the program and view the output good luck and have fun in this section we're going to talk all about cobol variables i'm pretty sure every programming language in existence has variables of some sort and even basic algebra has the concept of having a letter represent a value like x equals 5. cobalt is really no different though it does put its own spin on some of the details which we'll cover here simply put a variable is a name chosen by the programmer to represent a value that name is referred to as a data name that data name can be anything as long as it's 30 characters or less doesn't contain any spaces is made up of only letters digits and or hashes and isn't a reserved word so some examples of good data names might be balance inventory one two three four five and north american sales in 2020final that's exactly 30 characters there will be no problem with any of those however if we wanted a data name of top five percent with a percent sign or phone numbers with a space in the middle those would not be good we also have to think about what type of variable we want because when we declare or create a variable we have to tell cobalt what it's going to be numeric just numbers alphabetic just letters or both alphanumeric we also have to tell just how many of those letters and or numbers we think we're going to be using and we do all this because cobalt is an extremely efficient programming language and part of what lets it be so efficient is knowing exactly what's going on with all of its data right from the beginning we set this up in the picture clause picture or pick for short sets the length and the data type of a programmer selected variable name so pic9 is a single numeric value where the length is 1. the 9 means numeric it doesn't mean it's a value of 9 or a length of 9 it just means here's a variable of numeric type and since we didn't specify a length we only get one it defaults to one so i don't know maybe we're programming an elevator in a building with nine floors we could use that to store what floor we're currently on could be handy for that and if we need more than one digit we can specify that within the parentheses like here pick nine parentheses four that says it's a numeric variable and there's four of them that might be a good place to store perhaps the year because obviously you would need four digits to represent a year like 2020 or 2021 or 55 45 or 1999 four digits for the year always pick a means we have a single alphabetic character and because we didn't specify length we only get one so i could use that to store my favorite letter z pick x eight gives us eight alphanumeric characters x means alphanumeric and with that many i could store a us license plate made up of up to eight letters and numbers now not all pick clauses are created equal so you need to know that the maximum length of a numeric picture clause is 18 while an alphabetic pick clause can be up to 255 and know that there are lots of other types of pick clauses we will dive into those as we need them for now just focus on those three numeric alphabetic and alphanumeric you can use picture clauses to represent symbols that appear in the value so for example pick nine parentheses four v nine what the heck does that mean well nine parentheses four means there's four digits then we've got a v which represents the decimal position the dot then two more nines so two more digits we can use this pick clause to represent 1425.82 that could be a radio frequency or a measurement of some sort we can also do something like this pick dollar sign 9 comma nine nine nine v nine nine that can be used to represent one thousand two hundred and thirty four dollars and fifty six cents the dollar sign and comma carry through and the v indicates the decimal area when we think of a variable we often think about something variable meaning it can change cobalt also has things called literals which contain data that will not change during the course of the program so i might use a literal to store something that i'm going to use several times in a program but only want to have to set it once for all those other places so maybe the name of a company a string of characters that i use to separate lines and output or copyright information anything that's going to get used more than once and isn't going to change while a program is running cobol has a few figurative literals built in to make things easier you can use them without setting them up yourself and a few you'll find most handy are zero and zeros space and spaces low value high value null nulls and you'll notice that for some of these there's a singular as well as a plural version very handy so if you're starting a new variable and you want it to be all spaces the efficient way to set that up is using the spaces literal rather than sitting there and going space basically using literals is what efficient programmers do and i want you to be an efficient programmer up next our good friend the data division all of the data you're going to use in your program gets set up in the data division to add structure to this we use what's called a data relationship we can see that by looking at this segment of code right here in this data division we've got level indicators each with their own descriptive entry print rec has a level indicator of 01 meaning it's the highest and then the data definitions are below it at 0 5 and the file account rec has its own set of variables with their own level indicators down here don't you just love that structure it's basically saying the data this file needs are the account fields and then below it it spells out exactly what those account fields are so we've declared the data let's do something with it move and compute are reserved words that we use to alter the value of variables move does well you probably figured it out it moves the data from one place into a variable and compute is used to perform math so in this example we've got a bunch of 77 level variables up top which are who where why rate hours and gross pay you'll notice the first three are alphanumeric and the last three are numeric then down in the procedure division we're using move to set up some of those variables the who where and why are captain cobalt san jose california and learn to be a cobol expert and that's spelled out pretty clearly on those lines we're also setting the hours and rate to 19 and 23. we are not going to set the gross pay with a move instead we're going to use compute and set that to the answer of our times rate and then lastly we'll output the values of our variables with some text before them so the person using the program knows what value they're looking at pretty simple right good because it's um oh yeah it's time for a lab take a look at the payroll zero zero cobalt source code in the id.cbl dataset and when you're ready to give it a try make sure you're submitting the jcl for it and not the cobol itself you submit the jcl to run the cobol got that i know you do have fun up until now we've mostly been moving data between variables taking them from user input or outputting them to a display now we're going to take things to the next level and start working with files to do this we're going to use select and assign clauses in the environment division fd statements in the data division and from the procedure division open close read into and write from statements the environment and data division is where we describe our inputs and outputs which will get used in the procedure division because as we all know that's where the action happens let's take a look at that action in action here you can see the file control paragraph in the input output section of the environment division what we're doing here is associating each cobalt internal file name with an external data set name in this case print line is the name of the internal file name and prtline is the external data set or file so that's the select and assign clauses in the environment division further down in the data division this is where we define the level numbers variable names data types and lengths the fd reserve word is used to give the cobalt compiler more information about those internal file names so print line which is linked with the data set file prt lina has these fields types and lengths and account rec which is linked to a cct rec has these fields types and lengths when your cobalt code is running on an ibm z mainframe it'll have access to both traditional z os data sets as well as unix files for right now we're going to focus on the z os sequential data storage method because it's extremely common and a good place to start when working with files in cobol a data set in z os is made up of records and you can think of each record as a line within a data set with a defined length so like anything written out row by row you'll find the exact value you're looking for by scanning down to the right record and then across for the field you want if you take all these fields and add up their length that makes up the entirety of the length of that record you got it it's kind of simple the way data input output or io is handled is a program says hey i'd like to read this piece of data out here and then the operating system or data io subsystem goes and gets it and places it into memory where the program can go and read it if a program is requesting lots and lots of reads one right after the other that's a lot of i o operations which is somewhat inefficient and can lead to slow performance it would be like going into a restaurant and ordering a soda and then waiting until that's brought out and saying you know what i'd also like a hamburger then they bring that out you say fries too and they bring that out and you say ketchup and then they throw you out of the restaurant because that's extremely inefficient and annoying and we don't want to be inefficient or annoying in cobalt programming we have this concept of something called blocks because we know so much about the records we can load data as a block where a block is a group of records as long as the program is going to read one record followed by the next followed by the next and so on we can get the records we want in order into what's called a buffer take a look at this we can see a block of records loaded into a buffer where the overall record length is the size of each field combined we set that overall block size in the buffer with the block contains clause earlier we used the assign clause to describe a data set source file we said select account rack with a dash in it assigned to account rec if we're running this in z os using jcl we need to have a jcl dd statement to link account rec to that actual data set the jcl required for the cobalt compiler to make the connection back to the actual data set looks something like this slash slash account rec d d d s n equals my.data comma disp equals shr if you're unfamiliar with jcl this is a data declaration statement that's what the dd stands for it says that for account rec look here at my.data the disk equals shr just means it expects that the data set exists before we try to use it and that other people can use it at the same time we don't require exclusive access now i don't know about you but i kind of want to see this all spelled out from end to end so we'll start out with account rec that's what we reference within our procedure division in the actual code account rec is what's defined in the environment division's input output section slash slash account rec a cct rec seven characters then gets connected via a dd statement to my.data the actual data set on the disk now don't sweat the jcl stuff too much right now i know you came here to learn cobol not jcl and chances are if you're given some code to write or modify somebody will prepare that jcl for you or at least tell you what data sets and names to use so you won't have to guess there's a link to an online resource for basic jcl concepts in the course notes if you're curious though one other important note the cobalt compiler assumes that what you tell it for the file names is true and correct and it will work when it goes to run because it doesn't have any way of checking what's actually in your jcl or actually on the file system and if any part of that chain is broken or not correctly linked you're going to get an error at run time that's why it's important to have a good naming scheme because chasing those types of errors is no fun at all up next we'll talk about putting all that to use in the procedure division now we're in the procedure division where we actually open those files that happens in the open file section and we can open files for input and output like this here we've got account rec open for input and print line open for output and just as we open the file we should really make sure to close them when we're done this can be done at the program completion or if it's going to be a long running program when we're done using that file resource we do that with the close dash stop so we just say close account dash rec and then close print dash line and then stop run stops the processing because cobalt is often used to handle lots and lots of data it's a safe assumption that we'll need a way to process records one after the other until we're done you may have seen in other programming languages the concept of a for or a do statement cobalt uses perform and in practice it looks like this i encourage you to hit the pause button on this screen and study it for a little bit because while it's extremely straightforward there are a few bits in here that might raise an eyebrow and we'll go through all of that so i'm stalling here to give you time to find the pause button and we're back so starting at the top we've got the read next record paragraph the first thing we're going to do here is perform a read record that's the first line there are no conditions about it we're going to do a read record at least once that read dash record is defined down here that is going to read the next record from the file and if we're at the end put a y presumably for yes into lastrack then when we're done reading we have this end read and even though that terminates logically and explicitly with the end read it also terminates implicitly with that period there so we're just being complete covering all of our bases now going back up into the read next record we're indenting and our first line here is a perform until it says perform until last rec equals y and why would last rec equals y it would be y if read record detected it hit the bottom and it processed its last record and if that file was empty it would hit this first perform put a y into last rec and then the logic of this until statement would say we're done performing we're bumped out of the logic because there's nothing left to do here and we've also hit this implicit terminator so we're done with this paragraph if the file is empty if the file has a couple of records in it like we would expect then we continue and we're going to do a write record with the data we just got that's defined down at the bottom of the example code then we'll do another read record before going back up to the top of this perform loop where we'll check to see if we got a y if it does we'll end if it's values then we're going to use write record to write them out continuing that process until we've hit the bottom of the file setting last rec to y and finishing reading a file from top to bottom is like the c major scale of cobalt programming you're going to have to do a lot of it so you should know how to do it forwards and backwards and this code right here is a great example of this type of logic done right keep all that good stuff in mind as we go into lab number three you'll use everything we touched on in this lesson to fix some code remember that the all important chain of links between the procedure variables environment variables and the jcl data sets needs to be correct and if it helps write them out so you can double check things as you write it go get to it lab number three you'll often hear cobalt referred to as a structured programming language in this definition structured means that it relies on the concept of passing control and adhering to a flow structure as a program executes in other words the way that you write your code is used to spell out how it should be executed people writing code in c pli python and of course cobalt use the structure of their languages to ensure code flows exactly the way it ought to another style of programming known as object oriented programming divides code up into smaller segments called classes each having its own specific purpose and each class has its own set of variables and methods then once the classes are defined you write the code that describes the interaction between them all and if you're writing a program where you're going to benefit from this type of class object relationship it allows for you to write very capable code without needing to define each and every instance of each and every class from scratch every single time however i can tell you from a little bit of experience that it's also very easy to write something that looks very simple but behaves completely different from what you intended you're essentially building the structure of code on the fly and that has its advantages but a lot of the code people write on cobalt needs to be transparent and readable and easily diagnosed which is a lot easier to do in a structured language you get the ability to jump around a little bit in cobalt but you should be sure to use those sparingly and not rely on them to provide the backbone of your program as we saw before cobalt passes control primarily using the perform keyword and using paragraphs so how can we best make use of this structure i'm so glad you asked let's take a look at basic program control and flow through a snippet of code we're setting up the output of print line we're setting the message headers of print rec to the number is and then we're adding one to the counter variable moving that value to message to right and then writing print rec which will print something like the number is one then we do the same thing again with the exact same code adding one moving it to message to right and printing it for as many times as we feel like repeating in this section here the only indication i have that i might be done is that the name of the program is 2 10 1 so i can assume we'll do this 10 times a simple looking program but dreadfully repetitive and not a very good use of anybody's time remember we want to be efficient and that doesn't look efficient those three lines of code keep getting written again and again and again so rather than typing them out let's address that issue right here we'll move those three lines of code into a new paragraph called write new record and then we'll just call that paragraph 10 times using the perform keyword so the program will get here then run this then go here then run this and i'll do that 10 times this is called an out of line perform statement because it requires jumping down here and then back up and it's definitely less code but it still seems kind of repetitive right that's where we need to look into using a loop using an inline perform statement and once i pop that up on the screen you'll see exactly what i mean in the previous versions the part of the code we were repeating was add one to the counter move that counter value to message to right and then writing it out here we see the move counter statement that looks the same and here's that print wreck we wrap those two lines in this perform and end perform which forms our loop so what about incrementing the content of counter that happens as a condition of the loop itself perform that sets up the loop varying counter from 0 1 by 1 until counter equals 11. that i mean we really don't have to spell out what it does right it basically looks like english perform a loop where each iteration of the loop increases the counter by one starting from one until we get to 11. why did we say 11 we had to say 11 because if we said 10 we would hit 10 after incrementing it match this until clause and bump out before executing the move and print part you'll see a logic like this in other languages like this java example obviously the cobalt version involves a lot more typing but it's easier to read and you'll also get autocomplete so your editor will write a lot of that for you another way you can get around this is by using a go to now here's the thing about go to don't use go to unless you absolutely have to do it and you absolutely know exactly what it's going to do go to does exactly what it sounds like it jumps the program to where you're directing it and it just kind of picks up and runs from there the difference between go to and perform is that instead of it being a special assignment that will do and then return from it's just gonna go there and start executing from there it's like when you're reading something online you see a word or a phrase you don't understand so you search for it and you find a video about it and you watch that video ideally you go okay cool now i understand that and you jump back to where you were or if you're like me you go hey that was kind of cool what was i looking at again and there goes the whole afternoon if you were to go back to that program we showed earlier and replaced the second perform right new record call with a go to right new record like this the program would jump ahead to the right new record paragraph execute it and then just keep on going because it didn't know that was on a special assignment it just thought okay well this is where i am now just understand the difference and be careful when using goto statements because you might be losing some of that structure that your program needs to be successful if that didn't make sense you might want to rewatch this video and check your notes because right now we're going to go to the next video when you start planning a program start thinking in paragraphs if you were to start whiteboarding the overall flow of a program drawing words and boxes and connecting those boxes with arrows a lot of those boxes will get implemented as paragraphs and that's good that's kind of the point a paragraph gets defined in the procedure division starts at column eight and can have any name you like apart from a reserved cobalt keyword the declaration of a paragraph is terminated with a period the paragraph itself can contain one to many cobalt sentences and is terminated by either the start of another paragraph or the end of the entire program from an application architecture perspective you really want to spend some time up front charting out the flow of your program and deciding what part will get handled in what paragraph if you start this way instead of kind of figuring it out as you go along not only will your code be less error prone you'll have a nice reference to use later on now there are two big situations where a light should go on over your head and you'll say to yourself ah that's a good use for a paragraph the first is if you find yourself typing the same couple of lines over and over and over again like adding a bunch of numbers together and finding the average if you find yourself doing that think about packaging those up into a paragraph and giving it a name and by the way put at least a few seconds of thought into your paragraph names nobody wants to open up a bunch of source code to find paragraphs called do file stuff or test123 aim for something like open input files or check for duplicates that way you know exactly what's going on in there also if you've got a couple of lines that need to happen a bunch of times extracting those lines into a paragraph and using a perform keyword to execute them a certain number of times or until a certain condition is met is good practice for writing comprehensive code a paragraph can come before or after the code calling it but you should try to order your paragraphs close to the order that they'll be executed in at run time just to make it easier to find them what i'm saying is don't just throw new paragraphs at the bottom of the program you may see people start their paragraphs with numbers and each paragraph will look like one thousand dash open files two thousand dash read next record and so on then as you extend your program you can add them into the appropriate significant digit that way you can say you know what that paragraph should be in the three thousands and so on we kind of don't have to rely on this anymore with modern editors that can quickly jump between the paragraphs of a program but this explains why you might see this done in code that you're looking at and you may or may not choose to do the same when you write yours you may also see empty paragraphs at the end of other paragraphs like this the open files end paragraph has no code and does nothing but for someone reading through code it makes a nice visual indicator that the code for this paragraph ends here it also comes into play if you're using the perform through keyword which we'll learn about in just a little bit one of the simplest ways of setting up a loop is with times for example here we say perform 10 times and then some code finishing with end perform and we can set that up with a number just like that or with a numeric variable like this perform my new paragraph counter times whatever counter is it'll perform that paragraph that many times we can also perform through and this can be spelled out through or just th r u check out this example we have our first paragraph 1000 paragraph a that says perform 2000 paragraph b through 3000 paragraph c this is another reason to consider the order that you state your paragraphs now we'll hit this perform through jump down and execute paragraph b and c and then finish this paragraph we'll never hit d because we were only performing through paragraph c we can also perform until which will evaluate the check and if that condition is not met it'll take some action this is usually done until a number hits a certain level or two variables are the same like increment this value until it's equal to that value in this example the order is that we do the check and then do the code and if the condition is met we're done we've done it until if that doesn't match your logic we can also do perform until with test after like here this will run the loop and then do the test there's also perform varying where we say something like perform varying counter from 0 1 by 1 until counter equals 11. we just looked at that earlier and if you really want to get fancy you can nest those performs like this where we've got two counters going on counter and counter two and every time we increment counter by one we're going to step counter two from one to five in increments of one so we would get one one two three four five two one two three four five three one two three four five and so on now i don't know about you but i'm starting to get a little loopy myself in the next video we'll cover linking in other cobol programs a cobalt program can call other cobalt programs and you do that with the call keyword followed by the name of the program that can be call prog a1 with the literal program name being in single quotes or like this where we move the program name to a variable and then call that variable the way a calling program calls a called program is through something called linkage and i'm going to show you a very basic example of it the program being called has this section called the linkage section and in here it defines three variables month day and year they're all numeric two digits for month and day and four for year of course there's four for year and they've all got an ls at the end so you know they're in the linkage section as opposed to the variables up here in the working storage section which have a ws at the end so this program over here that we're calling it knows that it's going to be called and it prepares itself by setting up the linkage section it also sets up the procedure division using the using keyword so it's going to use those three variables from the linkage section in addition to the three variables from the data division working storage section now the calling program sets up those three variables in preparation for this which in this case matched the variables in the linkage section we want to set those up just like any other variable then we do this call date sub using month out day out year out there's those three variables we're calling that other program and giving it those three variables to store the output that it generates linking programs can get quite complicated but for now we're just going to leave it at that just know that there are ways of passing actual data as opposed to references to data mechanisms for getting a return value from a called program and all other sorts of goodies once a program reaches a certain size you're almost guaranteed to see everything we've talked about in these last few videos put to use so if this all makes sense you're in good shape let's keep this party going a big part of cobalt is generating reports you've got tons and tons and tons of data and you need a way to produce a report of that data so someone else can look at it and go hmm yes yes that's very good yes for that reason we've spelled out an example of generating report data here which can be very easily scaled out to handle multiple records and called any number of different ways at the end you'll be asked to complete a lab that puts all of this to use previously we looked at the select and respective assign programmer chosen names we had something like this in the environment division we used print line as the internal cobalt file name for the output now in the file descriptor marked by fd within the file control paragraph we start to connect it all together the fd entry defines the layout of the record within that print line internal file and you can see you were saying fd is a file the highest level descriptor is print wreck and then within that print wreck we have the individual fields defined first account number o presumably for output that's a value of eight alphanumeric characters then look at this filler that's an odd name for a field and it's actually not a field but a cobalt reserved word remember those we use filler to allocate memory space typically between words or variables and filler can be empty it can be dashes or any literal in this example it's eight characters of account number then two spaces and you can see that we spelled out spaces there with spaces that's a handy shortcut so you don't actually have to type out the spaces each one of those filler lines in here is just inserting two empty spaces and in this case it might seem somewhat basic but without filler your reports would just be a bunch of values slammed up against one another consider this partial program this is the working storage section we've got four headers defined there's no logic in here this is just something that defines what our data looks like notice we've got some areas up here that are just filler and we're filling them up with this text financial report for then in header two it's a mixture of literal labels and printed out variables so we'll have the word year notice it's year with a space at the end of it and that's why it's five characters then the value of hdr year header year same with month and day header three is all filler it's just account two spaces last name two spaces limit two spaces and balance and then forty spaces if you need forty spaces for your account balance i wanna be your friend send me an email once you're done learning cobalt then in header four this is more filler it's eight dashes two spaces ten dashes two spaces and so on so what i see up here so far is a header that goes up top and that says what the report is and then there's some sort of header info that spells out the time period the report is for which is kind of important and then we've got two headers for the values which i'm assuming will be listed out below makes sense so far so that header too that's date info the data name layout for the date info is defined here and it's kind of neat how this works the high level variable name is ws current date data that's ws for working storage and then within that we've got two sections ws current date and ws current time the date is divided up into the year month and day and the time is divided up into hours minutes seconds and milliseconds now we know exactly what that current date data looks like which is good because that's one of the first things we're going to do in the procedure division aka the division where all the action happens check out this procedure division we start out with a paragraph called write headers and then we've got these four move sentences the first one takes the current date from what's known as an intrinsic function more on that later but what it does is it takes the current date of when that code is actually executed and it copies it into ws current date data then because we defined how the fields of year month and day line up within that data name layout we can just tell it to move the year month and day portions of that data into those three variables then in lines five and six we write out our report header that's the financial report four part and the date info that follows it from header two we're writing those out to print rec and we're writing them out there from header one and header two then we move spaces to print rec and line seven if we didn't do this we might leave straight characters behind we want to start out with the next series of moves and writes assuming that we have a blank record and then we write it out so if you're following along at home which i hope you are we've got the financial report for then the date header and info then a blank space because in line eight we wrote out that line of spaces and put it into the print rec in line seven lines nine and ten write out the column headers of account last name limit balance and those nifty dashes that went under them now all we have to do is print out the data that goes underneath those headers and you know what that's where the lab comes in that will show you how you can take data from a file and use it to generate a report with all the nice formatting and spacing that makes it nice and easy to read after that why don't you report back here for the next lesson the path that a program takes is sometimes referred to as its logic does the user want to enter more data if yes then we'll jump to the part of our code where we'll let them put in more data if they're done then we'll jump to the part of our code where we're going to process that data it's kind of like hitting a fork in the road and we use what we know to inform that decision maybe you want to look at a bunch of accounts and find the ones that haven't been updated in the last 60 days in that case we're taking the difference between the most recent update and today's date and comparing that difference to 60. presumably if the difference is greater than 60 then we're gonna do something special with that account that's all logic and unless we insert our own logic a program is going to run from the top to the bottom until it's done so we need to learn how to express what we want to happen in a program's logic three of the most common types of cobol conditional expressions are general relation conditions class conditions and sign conditions and a lot of these are fairly simple it's taking two operands comparing them to one another and saying is this greater than that or is this equal to that or saying is this numeric is this lowercase sometimes because of the way our logic is structured we'll want to say is this not numeric because maybe we asked the user for a number and we got that something like xx and we need a way of saying if this is not numeric go and prompt that user again and remind them we're looking for a numeric answer so whenever you're writing a conditional expression they typically start out with is and then there's a test or a comparison afterwards and you can between the test and the comparison throw in a knot to flip that logic around there's another important and powerful tool you have in writing program logic known as conditional names these are used primarily to say the input we're taking needs to pass this test a conditional name is declared in the working storage section with an 88 level number in this case it has to be an 88 level number we use a conditional name to say the variable that i'm under needs to match this and it can be a literal a series of literals or a pattern or anything like that and it's a good way of verifying user input and again it always has to be an 88 take a look at this example we move az into usastate then we enter this if statement if state the only way this will pass as true is if state evaluates as true which in this case will only pass if it's equal to tx so we're going to say the state is not texas then here we're moving tx to usastate that will pass because it matches that 88 conditional statement it equals tx why would we do something like this well imagine instead of just putting in one state we put in all 50. that makes sure somebody didn't put in something like z z or one two as their state or something like that that didn't make any sense so we can use conditional names as a way of validating or limiting data before we try and do something with it there are other ways of implementing this type of logic but being able to have one place to define the scope of the data for a test is quite handy if we're comparing values like if this is greater than that we use conditional operators and those include is greater than which can be written out as is greater than sign remember those alligator mounts or is equal to which can be written out with the equal sign we can also say is greater than or equal to with is greater than equal to we can take that concept and put it to use in conditional expressions that's where we put those if then else statements to use and you're probably already familiar with those concepts either from another programming language or just from everyday talking logic if it's nice out then i'm gonna go for a hike else i'm just gonna stay inside and play video games again we've defined two possible outcomes and what will inform that decision the weather in code we might write something like this if facial expression is happy then say hey i'm glad you're happy otherwise say what can i do to make you happy obviously we would want this program to actually do stuff if you're happy or not happy maybe clap your hands but this shows a basic if then else statement we have another way of doing this that's more useful if there's more than two paths and that's an evaluate statement we set that up like this first we evaluate facial expression when it's happy we do this when it's sad we do this when it's perplexed we do this and we can keep on going until we run out of possibilities and then we hit the end where we just say end evaluate this comes in handy for menu type items like press one to show account balance press two to make withdrawal press three to transfer money etc each one of those could be a when in this big evaluate statement another thing that happens quite often in programming is performing some sort of function or set of steps until something happens maybe it's processing files until we've reached the end or adding stops to this truck driver's route until the truck is full if we're iterating over data specifically tables trying to find a specific entry we can use search statement that syntax looks like this search the facial expression table until you've found the index marked happy then presumably we do something with that record although in this example we issue a stop run so i guess they found happiness and there's nothing left to do let's get back to those conditions you know we can say if this number is equal to that number that's a test of the relationship between two operands which can be numeric or text we can also use conditions to test the content of a data item like is numeric or is not alphabetic lower or even is kanji and for numbers we can say is positive is negative and is zero and just so you know we're really only skimming the surface here to read more about all these conditions visit the ibm knowledge center for enterprise cobol there's links for that in your material we're coming up on that time time to put what you've learned to use in a lab and we're still working on those reports this time we're going to add in a special case if we happen to be in the state of virginia which will result in a special entry in the last line of your report good luck and i'll see you back here when you're done cobalt is often used to process lots and lots and lots and lots of data and a lot of data is made up of lots and lots and lots and lots of numbers so in order to deal with all those numbers we need to take a look at cobalt arithmetic expressions that's that's it that's that's the intro nope more all right let's put this graphics budget to use it's math time nice good job guys so what is arithmetic expression well an arithmetic expression can be built up with numbers variables that represent numbers the figurative constant of zero and any combination of those enclosed within parentheses including any combination of all that that i just mentioned having mathematical operations performed on them i think that about covers it for example number of people minus number of staff times three divided by eight would be how many pizzas you need in order to feed a crowd of this many people assuming we're not feeding the staff each person will want three slices and there are eight slices per pizza that's a pretty good mix of variables and literals and parentheses and we can spell expressions out with plus minus times divided by and you can also use two asterisks or stars to show exponentiation so 2 star star 8 is 2 to the 8th power meaning we keep doubling two eight times that's 2 4 8 16 32 64 128 256 2 to the eighth equals 256. sometimes it makes sense to spell out our arithmetic expressions using the compute command this can help make your code more readable or just focus a series of arithmetic operations in one place so we can say compute z equals a plus b divided by c exponent d minus e we can also say compute x y z equals all of that and it will assign the answer of whatever that might be to all three variables x y and z now you've probably heard of the order of operations before and if a part of your brain lit up that you haven't heard from in a while the word pemdas probably does the same that is the order in which we tackle an expression starting with parentheses then exponents multiplication division addition and subtraction pemdas by default cobalt will evaluate expressions this way if you want to either circumvent that order or you want to make it more clear for yourself or others who are reading your code you can also enclose sections of your expressions in parentheses cobalt will start with the most nested part of the expression the part enclosed in the most parentheses and then keep working its way out after that it'll look at the unary operators positive negative then exponents then multiplication and division from left to right and then addition and subtraction from left to right that means that an arithmetic expression must begin with either a left parenthesis a unary operator or an operand in the form of a literal number or a variable representing a number there are limitations to how far you can push arithmetic expressions in cobol the first is that exponents in fixed point expressions cannot be more than nine digits if the compiler sees this it'll truncate it and you will get a diagnostic message also while the data descriptions of operands in expressions don't need to be the same meaning you can multiply a twodigit number by a fourdigit number the maximum size of each operand is either 18 or 19 decimal digits depending on the compiler option used if you're working with data that requires either very big numbers or a very high degree of precision make sure you know if you're using compatibility or extended mode for arithmetic there are also considerations to consider when dealing with the rounding of data and there's more to get into that we can't cover in its entirety here but that's all spelled out in the procedure division statements cobalt language reference as you've probably guessed we're going to get to use some of these new skills in the upcoming lab check out this change to the working storage section here we've got t limit and t balance there's some big numbers in there and we'll learn more about data types in the upcoming data type section but i can tell you right now those are big numbers or at least able to represent big numbers they're a comp three data type and they start out with a value of zero and look at this we've got what looks like more header type content except we're calling it trailer and i'm not a betting man but i think that's going to come at the end it looks like it's showing us some sort of totals so that makes sense too and then in the read next record paragraph we now have a perform limit balance total line which is calling this which is two compute statements which look like they're keeping a running total of the balance in total from every line it's processing hmm of course we're gonna write it out so we've got this right t limit t balance paragraph which moves the running totals into the dash o variable so that when we write the trailer lines out the actual values are gonna show up in there those are the parts you'll need to finish this sections lab and by my calculations it's time to get to work computers don't have fingers i mean do they i mean i guess no no they no they don't except what about no no no computers computers do not have fingers let's let's just stick with that so so when a computer is thinking of a number like the number eight it's not going like this it's lighting up little bits of memory that represent that number eight it's got its own methods of taking numbers letters and other concepts and representing them electronically one of the ways you can make sure your programs are running as quickly and efficiently as possible is by choosing the best way for cobalt to represent that data in its memory let's start out with numerical representation there are five different computational value representations let's start with comp one comp 1 is also known as a single precision floating point number representation this is useful for numbers that are very small and close to 0 or very large up to 10 to the power of 38 however comp one has somewhat limited precision it only has about seven significant decimal digits anything beyond that gets rounded so a value like 1 234 567.89 that rate there is nine digits and it's going to get rounded which if you're dealing with dollars and cents you might not want to happen but for simple numbers a comp one might work then there's comp 2. this is a double precision floating point numeric representation and this can handle bigger numbers about 10 to the power of 307 it has more significant digits up to about 15 so it goes further than comp 1 in all regards but it is still somewhat limited and then there's can you guess we did comp 1 comp 2 yes you in the back no it's actually comp 3 comp 3 and this is where it gets interesting this is what's known as a bcd or binary coded decimal this is by far the most utilized numeric value representation in cobol it is also somewhat unique and native to the mainframe computer and z architecture and with good reason it has to do with decimal fractions when you do lots and lots of operations with decimal fractions and the data is stored in binary that's when you start to get rounding issues representing that data in binary coded decimal avoids these issues it exactly represents values with decimal places and can go up to 31 decimal digits ask someone in a banking credit card or payment processing industry why they depend on cobalt and they're probably going to mention bcd binary code of decimal and decimal fractions and then there's comp 4. comp 4 is only capable of representing integers so if you're dealing with something like a counter or you're only working in integers using comp 4 has you covered there and then there's comp 5 which is the same as com4 but with it you can specify the position of a decimal point it's got space efficiency of comp 4 with the exactness of com3 the drawback there is that cannot exceed 18 decimal digits so there's your numerical value representations numbers are good but sometimes you want to use letters and you'll be happy to know that cobalt's got you covered there as well there's ebcdec which stands for extended binary coded decimal interchange code and ascii which stands for american standard code for information interchange and it's not like one supports bigger words than the other it really just comes down to how the characters are represented in the computer's memory ebcdec has eight bits per character ascii uses seven and the characters are distributed across the possible combinations of those bits differently today the only place you're likely to see ebsydeck code is if you're on an ibm mainframe most everywhere else uses ascii or unicode however just keep this in mind if you're working on programs written a long time ago because every once in a while you'll go to load some data and it'll show up looking all weird your first instinct should be to say is it possible that this data is ebsedec and i'm trying to load it in ascii or vice versa because that happens quite often and now you'll know and you'll be prepared in this slab you'll deal with an issue just like that where spoiler alert there's a mismatch between external data and the cobalt representation of that data there's a hint and an explanation in there to help you along because this is a tricky one if you're like me one of the things you like about cobalt is how straightforward each line of code within a program is it does what it says it's going to do and there's really no mystery about what do this until this happens means however sometimes you need to do something beyond just add two numbers together or print out a line of text and it would be a shame if every time you needed to for example turn a string of characters from lowercase to uppercase you had to go and build that paragraph of logic all by yourself first off you're just repeating work and more importantly that's important code logic that needs to work right every single time being added onto whatever the primary role of the program that you're writing is there's got to be a better way well fortunately cobalt has a number of what are called intrinsic functions built in that you can use and if you're working with business data chances are there's something in there for you don't worry it's not like there's 500 new functions you have to keep track of the most recent release of enterprise cobalt for z os includes 70 intrinsic functions and they fall into the categories of math statistics date time financial character handling and general let's take a look at some of those intrinsic functions they all follow the format of function then the name of the function and then any arguments passed to that function in parentheses for example look at this we've got two variables item one and item two item one has hello world in it with a capital h and a capital w the rest lower case and then there's item two which is empty and we're going to display item one which should look exactly like it does up here with that capital h and capital w then we're using the uppercase and lowercase intrinsic functions to show item 1 in both uppercase and lowercase form note that this is just being called in the display function so it's not altering the stored data that's just how it's going to show up when the display goes to show it then in this line we're moving the upper cased version of item 1 into item 2 and then displaying it so in this last line if we display item two it'll show hello world in all caps that's going to come in handy and making sure we don't have any duplicate values otherwise first street with lowercase st would be a different entry than first street with an uppercase st which happens quite often if we just uppercase everything we can be sure that all the data coming in is case insensitive there's also math intrinsic functions got a bunch of values that you want summed up you could line them all up and make an equation out of it or you could say compute x equals function sum a b c divided by d that'll sign x the value of a plus b plus c divided by d and just like before anything within a pair of parentheses as seen as one operand and it needs to get figured out before totaling the sum but wait there's more form that one's signed with nine spaces we can use the function of current date with the argument of one colon eight and move that into the first variable what's going on there well we're specifying the output in this case we want the output from character one that's the one through eight that's the eight which just happens to be where the year month and day live within that output then we want another function integer of date to turn that date into a number that number is the number of days that have passed since january 1st 1601 so it's going to be a big number but it's also not likely you'll need to go back much further than 1601 so pretty safe bet anyway what we have now is essentially a count of days with that we can add 90 to it and now we're talking about a date that's 90 days from now you see what we're doing now we're going to use another function to transform that integer form back into year month and day form using the date of integer function see what we're doing there we flipped it and now we wind up with what is a nicely formatted date in the form of year month day and that's 90 days into the future because we added 90 to it and that takes into account going through all the months of different lengths leap years and all that stuff intrinsic functions and there's more lots more like 60 something more keep that in mind as you're writing code and you think to yourself gee i can't believe i have to write this out by hand because there just might be an intrinsic function that you can use right there intrinsic functions sound like something you might want to try oh well guess what act now and you can do just that with this intrinsic functions lab get yours today we are at the last section of this cobalt series first off i am extremely glad you made it here and i hope you feel a lot more confident in your own abilities as a cobalt programmer of course the world goes on from here there are lots more functions methods and ways of dealing with files and input to explore but if you made it this far you can tackle anything else you come across you'll be able to understand the syntax plug it into your code make requested changes port a program from one system to another you've got all that just like with any other programming language the internet is full of code samples mini exercises and forms with people looking to help go to the open mainframe project and go into the cobol section on there for a good head start on those resources whether cobol is your first programming language or your 15th or your 50th i hope you've learned what this specialized language is all about and you'll see why it's used so widely in highly transactional systems all around the world from our team to you thank you for watching thank you for participating and we wish you the best in all that you do stop run you
