With timestamps:

00:00 - If you want to create your own Chrome 
extension, you're in the right place.  
00:03 - In this course, Raman will teach you how 
to create a Chrome extension using the new  
00:08 - iteration of the web extensions platform, which is 
called Manifest v3. Rahman is a great instructor.  
00:16 - And he works for pieces that app pieces that app 
provided a grant that made this course possible,  
00:23 - but you don't have to use their extension to 
follow along share in the comments what type  
00:27 - of Chrome extension you want to make. Now the 
reason I want to teach about this particular  
00:32 - topic is I've created two web extensions in my 
career. The first is for a previous company,  
00:38 - where my extension generated a significant amount 
of revenue for the company. And the second for my  
00:43 - current company pieces, where our web extensions 
play a critical part of our product stack,  
00:49 - and help developers across the 
globe boost their productivity.  
00:53 - I'm going to be using the pieces web extensions 
and integrations quite a bit in this video. So if  
00:58 - you're interested in downloading an AI coding 
assistant that helps you save and reuse code  
01:03 - snippets, convert screenshots to code, and more, 
go ahead and download pieces in the description.  
01:10 - And you can totally follow along. So during 
my journey as a Chrome extension developer,  
01:14 - I did often notice that tutorials and 
StackOverflow answers were using outdated versions  
01:20 - of the web extensions platform. My hope for you 
after you leave this video is that you have a  
01:26 - resource to create a modern Chrome extension, 
and you understand the difference between  
01:30 - the newer version of the web extensions 
platform manifest v3, and older versions. Now,  
01:36 - before we get started, there's going to 
be three prerequisites to this course,  
01:40 - the first is required, and it's that you have 
a basic understanding of JavaScript and DOM  
01:44 - manipulation. The second is optional. If you 
want to follow along with this video and code  
01:50 - alongside with me, you can go to the description 
below, I'm gonna have a link to my GitHub repo,  
01:55 - go ahead and get cloned that and you'll be able 
to follow along. The third is also optional.  
02:00 - If you totally want to follow along, you can go 
ahead to pieces dot app and install a pieces IDE  
02:06 - integration along with the pieces Web Extension, 
and you'll be able to use pieces exactly the way I  
02:12 - do in this video. With that, let's get started. So 
as I mentioned before, the extension we're going  
02:17 - to create as a YouTube bookmarker. Basically, 
anytime you navigate to a YouTube video page,  
02:22 - an icon will show up on your YouTube video player 
to allow you to bookmark a particular timestamp on  
02:28 - any video. So let me show you how that's gonna 
work. If you're on a YouTube video page, you're  
02:33 - gonna see this item at the bottom right, you can 
go ahead and click that. And if you navigate to  
02:39 - your chrome extension icon at the top, right, 
I've pinned, so it's showing in the toolbar,  
02:45 - you're going to see a new timestamp already had 
one timestamp for 15 minutes, I added one with  
02:51 - an hour 18. I can go ahead and delete this one 
because I just decided I don't want it. And our  
02:58 - extension is going to give us that ability to do 
that. Now if I want to go back to my 15 minute  
03:04 - timestamp, you can click the play button. And it 
goes directly back to that particular timestamp.  
03:12 - I can also delete this one too. And 
when there's no bookmarks to show,  
03:16 - it's going to say there's no bookmarks to show.  
03:19 - Now we're going to add one, just so we have one on 
this video, and I can show you how storage works.  
03:24 - I'm going to navigate to a new video. And in 
this video, we have no bookmarks. So it says  
03:30 - there's no bookmarks to show. But if we go back 
to our previous video where we saved a bookmark,  
03:36 - it's going to load that previous bookmark. 
Now the last thing is if you navigate to a  
03:41 - non YouTube video page, it's going to say this 
is not a YouTube video page in the extension UI.  
03:49 - And that's basically all the capabilities of this 
chrome extension we're going to build out here,  
03:54 - there's going to be a lot more 
you can do on your own afterwards.  
03:57 - Now I also want to mention the reason we're 
working on creating this extension in particular,  
04:01 - is because it's going to show you all the 
major parts of creating a Chrome extension,  
04:05 - it's going to show you how to work with 
a content script to manipulate the DOM.  
04:09 - It's going to show you how to create a UI for your 
extension. And it's going to show you how to use  
04:13 - service workers as background scripts, which 
is a major part of the ship from manifest v2  
04:19 - to manifest v3. And to start working on 
the extension. Once you get cloned my repo,  
04:26 - you can go ahead and click on the puzzle piece in 
your Chrome browser at the top right click Manage  
04:32 - extensions. I'm going to go ahead and remove my 
extension show I can show you how it works. And  
04:38 - you're going to see this developer mode option at 
the top right go ahead and toggle that so it's on  
04:44 - click Load unpacked, then go to the repo that 
you get cloned in mind with the boilerplate code.  
04:53 - Go ahead and load that. And we're going to see 
our extension here. If we Click on this puzzle  
05:00 - piece and pin it. What we're going to see is this 
basic UI, it's just going to say your bookmarks  
05:07 - for this video with no bookmarks, and it's just 
going to show up everywhere. This is the default  
05:13 - messaging in the boilerplate code I supplied 
and the boilerplate code will also contain all  
05:18 - the files you need to follow along. The best 
place to start with creating our extension  
05:23 - is the manifest dot JSON file. This file is a 
JSON file where we can specify what version of  
05:28 - the extensions platform we will use, among other 
information that is going to serve as default for  
05:33 - loading in our extensions. Also, every extension 
you would want to create whether it's Safari,  
05:39 - Mozilla, or any chromium base extension will need 
a manifest dot JSON file. And it's probably the  
05:45 - single most important file in your extension, 
because it simply just won't work without it.  
05:51 - In our boilerplate code already added the manifest 
dot json file, so we don't have to spend too long  
05:57 - writing it out, I think it would be especially 
helpful if I just point out some of the things  
06:00 - that you should note, in case you're creating your 
own extension. So let's take a look here, as you'd  
06:07 - suspect, there's a name, there's a version number 
and a description. And basically, the version  
06:13 - number is going to populate when you loaded in the 
extension, the name you see is also going to be  
06:18 - the name of the extension when you load it in. And 
the description is pretty self explanatory. It's  
06:22 - just a description of what the extension does. Now 
things get more interesting with the permissions.  
06:29 - The permissions will be different depending 
on whatever Chrome extension you're building.  
06:33 - For this particular extension, we're 
going to request two permissions,  
06:37 - which is going to be the permission to use the 
Chrome dot storage API, and the chrome dot tabs  
06:43 - API. The chrome dot storage API is to store things 
in the user's browser for the extension. And the  
06:49 - second permission, which is a chrome dot tabs API, 
is what helps us access our browser's tab system.  
06:56 - So we can read the tab for the extension. This is 
basically going to help us identify what browser  
07:01 - tab the user is currently using, and grab the URL 
to see if they are in a YouTube video page for  
07:07 - our extension. Now, the host permissions just give 
you the ability to send cause requests to certain  
07:12 - host names. Our extension only deals with YouTube 
pages. So I have a match pattern written here just  
07:17 - for YouTube. The service worker, as I mentioned 
before, there's a big change between extensions,  
07:22 - v2, and v3. And one of the big changes is the 
use of a service worker. As you can see here, the  
07:29 - other is the ability to use promises. But let's 
just focus on service workers. For right now.  
07:35 - Service workers are just a JavaScript file that 
runs separately from the main browser thread.  
07:40 - This means that your service worker would 
not have access to content of a webpage,  
07:44 - since it is separate from main processes. 
However, your service worker does have  
07:49 - capabilities to speak to your extension using the 
extensions messaging system, which we will see  
07:56 - and use in our bookmarking extension. The next 
thing I want to point out is the content scripts.  
08:02 - The content scripts are just files that 
run in context of the webpages we're on.  
08:07 - We're going to use this to manipulate the DOM 
of our webpage that our extension is looking at.  
08:13 - And here we're just specifying that our 
content script is represented by our content  
08:18 - script J S file. As you can see, with the J s 
colon content script dot j s, the last thing I  
08:25 - want to point out is the pop up dot HTML file down 
here, under default pop up, this just specifies  
08:33 - which file was served as our UI. In our case, 
we've specified the pop up dot HTML file, and  
08:38 - in that file, we specify that the corresponding 
file that helps it with its interactivity is a  
08:43 - pop up.js file. With all that out of the way, 
let's get to coding the actual extension.  
08:48 - We're now finally going to start 
writing code to make our extension work.  
08:53 - For us even test the extension, we have to add the 
button of the YouTube player that will allow us to  
08:57 - save bookmarks with timestamps. So in order for 
us to add a button on the YouTube video player  
09:03 - will have to manipulate the DOM of the web 
page we are on. What that means is we'll have  
09:08 - to write our logic in our content script file, 
which operates in the context of the webpage,  
09:13 - as I mentioned before, so let's go ahead and add 
some code to our content script file. We're going  
09:20 - to go ahead and add the following variables 
YouTube, left, controls, and YouTube player  
09:32 - one is going to be for accessing the 
YouTube player one is going to be for  
09:36 - accessing the controls. And this is going 
to allow us to manipulate each of these.  
09:42 - But before we continue writing the logic to do DOM 
manipulation in the context strip, we also have to  
09:49 - think about how our extension is even going to 
know when we've navigated to a new web page.  
09:54 - And we need to know this so the content script 
knows to execute logic to add the plus i Call to  
10:00 - add bookmarks for our extension. Let's go 
ahead and go in our background.js file now.  
10:06 - And what we want to do here is listen to any 
updates in our tab system and find the most  
10:12 - recent tab or the tab that we're on currently 
and see if it's a YouTube page. So we're going  
10:19 - to have a listener, that's going to 
listen to tabs. And if you remember,  
10:24 - we got permissions to access the Chrome tabs API. 
And we're going to listen for an update to tabs.  
10:34 - The parameters were given is a tab ID and a tab.  
10:43 - What we're going to do from here is see if 
there's a tab URL, and if there is a tab Euro.  
10:50 - Let's see if that Euro includes 
youtube.com/watch. The way I came up with that  
11:02 - is if you look at our YouTube video, every 
individual video has YouTube slash watch.  
11:08 - And we just want to make sure we're on a 
page that has that specifically as a URL,  
11:14 - then what we want to do is set our query 
parameters. And we're going to use query  
11:20 - parameters as a unique ID for each video. So we 
can grab it from storage, you'll see what I mean  
11:26 - in a second, and I'll show you. So we're going 
to do that by using the JavaScript split method.  
11:35 - What that means is basically after this question 
mark query parameter, we're going to grab  
11:42 - this value. And this is going to be our unique 
video value this right here after the equal  
11:48 - sign. And every video on YouTube has a different 
value right here. So it's a pretty unique key that  
11:55 - will help us store videos uniquely as well in our 
storage, and it's consistent. So then we're going  
12:03 - to add your URL parameters. And this is just an 
interface to work with URLs URL search params.  
12:17 - And the final thing we want to do is there's 
a messaging system that happens between  
12:22 - the extension, we're going to send a message  
12:26 - to our content script that basically says a new 
video is loaded. And this is the video ID of  
12:33 - that video, and the video ID being that unique 
video value that we saw in the URL on YouTube.  
12:46 - And this tab, Id send message usage that I'm doing 
right here is all directly from documentation.  
12:53 - The Send Message takes a tab ID, it takes a 
unique object. So right now I'm going to type  
12:59 - type. And this is a type of event is a new 
video event. And then a video ID value,  
13:07 - which is going to be URL, parameters, dot get v. 
So if we're doing URL dot get D, it's going to  
13:18 - grab this right here. And that's basically going 
to be the code for that send message takes a tab  
13:25 - ID, it takes an object and then it can also take a 
callback function. This object right here doesn't  
13:30 - have to be type or video ID, it could also be 
something random, like I could literally pass this  
13:38 - and the content script will have access to 
random, and then the string random. In our case,  
13:45 - the only thing that's applicable is the 
type of the event and then the video ID,  
13:50 - which is a content script needs. Now in our 
content script, we're going to add a listener that  
13:56 - is going to listen to any of those incoming 
messages, we need to be able to listen to that  
14:01 - background.js message. So to do that, we're 
going to end up writing the following code  
14:07 - to add that listener, so we're going to say on 
message add listener. And this is going to accept  
14:17 - three parameters. So an object a sender, 
and a response. And the response is,  
14:24 - when a message is being sent to the content 
script, we can also send a response back where  
14:30 - the message is coming from. So I'm going 
to destructure those values we're getting  
14:40 - and if you remember, the way I'm deconstructing 
Type value video ID is basically we're given a  
14:47 - video ID right here. Later on, we're going to grab 
a value as well, and I'm just destructuring. So  
14:55 - each of these are its own variable. 
So it's a If type is equal to new,  
15:02 - so if the type of event is new video loaded, 
which we're getting from the background.js file,  
15:09 - we want to be able to set current video, which 
will be a global variable in the content script  
15:18 - as the video ID, and then we want to 
call a function to handle any actions  
15:25 - with new video. So we're going to 
call a new video loaded function.  
15:32 - And let's go ahead and set current video as a 
top level variable. And that's just going to  
15:41 - be an empty string. But it's going to be set as 
the string set from the background at js file,  
15:48 - once the message is received on this end, so let's 
go ahead and actually see if this works at all.  
15:55 - I'm gonna go ahead and just 
console dot log your parameters.  
16:06 - I'm gonna give this a reload. Open this, let's 
inspect it. And we ever URL search parameters.  
16:16 - So we know we're getting our URL search parameters 
now. Great. So so far, things look good.  
16:25 - Now, what we want to do from here is 
create that new video loaded function.  
16:32 - And after we create this function and 
all the functionality surrounding it,  
16:36 - we should see the YouTube player button on the 
YouTube video. So let's go ahead and do that.  
16:43 - So what we're going to do is create this function 
that we have right here called New Video loaded.  
16:55 - And what we probably want to do is check 
if a bookmark button already exists,  
17:02 - I know the class name that this item 
has, it's called Bookmark button  
17:06 - because I wrote the CSS code that's 
going to style this whole extension.  
17:11 - So you could just copy this part right here. But 
this is just some native Dom, slash JavaScript  
17:23 - methods that we can use. It's actually MB by 
class name. And it's going to return an HTML  
17:30 - collection. So what we're going to do is grab 
the first element that matches this class name,  
17:36 - bookmark button. And it's just going to 
exist on every single YouTube video page.  
17:43 - So if we want to test that, we could just say 
console dot log bookmark exists. And let's reload  
17:52 - this page and inspect it. Actually, let's reload 
our extension as well. reload this page inspect,  
18:03 - we're probably going to get undefined 
this is exactly what I expected.  
18:10 - Because we don't have any logic surrounding the 
Bookmark button yet. And also, we're not even  
18:15 - setting a bookmark button right now. So if the 
Bookmark button did exist, we would get true,  
18:21 - it does exist, but we're getting undefined right 
now. So what we want to do if we're getting  
18:26 - that undefined or false value that a bookmark 
button does not exist, is add some logic to say,  
18:36 - hey, let's add this bookmark button to any YouTube 
player. So we're going to create an image element.  
18:45 - That is going to be the image we 
click on for bookmark buttons.  
19:00 - As part is in, we're going to 
add a couple of attributes.  
19:07 - The first thing we're going to want to do 
is pull the image that we're using, which is  
19:15 - our assets slash bookmark. PNG, you already 
have this if you're following along with the  
19:20 - boilerplate code. The second thing we want to do 
is add a class. And the way we're going to add  
19:30 - this class is basically make it pretty dynamic 
here. So we're gonna add a YouTube button class  
19:41 - with a space and then we're going to add a 
bookmark button class in quotes. And this  
19:52 - is again, just some styling I have that 
you don't need to worry about right now.  
19:57 - And the last thing we want to do is basically 
on hover, we want to make a title show.  
20:03 - So we're just gonna say the 
title is click to bookmark,  
20:07 - current timestamp. And this is just 
a UI thing. You'll see this in a bit.  
20:14 - Next, what we want to show is a way to 
grab the YouTube controls. So these are  
20:21 - the YouTube controls over here, we want 
to be able to grab these left controls,  
20:26 - so we can add a bookmark button right here. 
So let's go ahead and find out how to do that.  
20:35 - I already know how to grab this. So I'm going 
to show you how this works. You can inspect  
20:41 - elements right here and find what elements they 
exactly are. But basically, we're going to use  
20:47 - native JavaScript methods like we have done 
previously to grab those controls and insert  
20:52 - our button. If I do document dot get elements 
by class name. And I grab YouTube left controls,  
21:07 - we should get an element back, which is 
going to be this div class over here.  
21:14 - And you can see that it gives us all the left 
controls over here, where we're going to add  
21:19 - our button. And the second thing we're going to 
want to do is grab the YouTube player as well.  
21:25 - And that's one of the global variables we set 
in our content script. And we can also do that  
21:33 - by writing document dot get elements by class 
name. And then there's this video stream class.  
21:46 - And we're going to grab the one at the zero with 
index. And it grabs a whole YouTube component  
21:55 - right there. So now we know the two elements in 
the DOM we need to manipulate. But let's set those  
22:02 - elements. First, we're going to do exactly what 
we saw in our content over there. Document get,  
22:10 - actually, I'm just gonna go back and copy 
these way easier, so don't make a mistake.  
22:20 - And then the second one is going to be 
YouTube player. Go back and copy that.  
22:32 - Okay, so after this, what we're going to 
want to do is add that bookmark button and  
22:38 - we grabbed the controls, you saw that row in 
the player, we want to add it to that row. So  
22:44 - we're going to type out YouTube left controls to 
get those left controls we stored in a variable.  
22:50 - And to use this native JavaScript method we can 
use called append child, which is going to append  
22:58 - this bookmark element inside that row.  
23:03 - And then the second thing we're going to want 
to do is probably add a listener to listen to  
23:08 - any clicks on our icon. So there's a correction I 
want to make to this portion of the video, before  
23:14 - we continue, it's going to be very important in 
order for your extension to work functionally.  
23:20 - And it's only one line of code, but it's going 
to make such a big difference. I'm also going to  
23:26 - explain an important concept of Chrome extensions 
that I neglected while I was writing this,  
23:31 - which is that in our manifest json file, we 
have a match pattern for our content script.  
23:38 - And basically the match pattern, we currently 
have checks if any youtube.com video is loaded.  
23:44 - And if it is, we're injecting our content script 
into the context of that web page. So basically,  
23:49 - what that means is, anytime a youtube.com 
page shows up, we're running a bunch of logic  
23:56 - using our content script. But the problem right 
now is that our background.js file is telling  
24:04 - us when a new video is loaded. And the 
event listener we're using is on updated,  
24:09 - which is just checking if this URL is updated. If 
you refresh this page, the URL is not updated. So  
24:15 - this button actually isn't going to show up. And 
if you continue coding without this fix right  
24:21 - here, you're gonna see some edge cases that you 
might not like. So let's go ahead and fix this,  
24:27 - we're going to do a super simple fix. It's not the 
best fix in the world, but it will fix the problem  
24:34 - here. We're just going to call a new video loaded 
anytime our content script matches youtube.com.  
24:42 - And what this is going to do is call this 
new video loaded function anytime we hit  
24:47 - that match pattern. The downside of this is now 
if the background script sees it as a new video  
24:55 - using the on updated event listener, and there's 
a condition that content script is injected,  
25:01 - we're going to hit this or call this new video 
loaded function twice, you can fix this pretty  
25:06 - easily by just adding a conditional make sure 
that doesn't happen. But to make sure everyone  
25:10 - is able to follow along with this correction, 
I will not be doing that here. And we'll just  
25:14 - only be inserting this one line of code calling 
the new video loaded function. Luckily, the only  
25:19 - thing our new video loaded function is doing is 
adding the Bookmark button to the YouTube player.  
25:24 - So there's going to be no negative implications to 
calling it twice. Since we have a condition that  
25:29 - checks if the button is already on the player. 
It's just not the most efficient implementation,  
25:33 - which is fine for the sake of this tutorial. With 
that, let's continue with the rest of the video.  
25:42 - There we go, we have the button right there. 
But right now, if we click the button,  
25:49 - it's not doing anything. And there's a reason for 
that. The reason is that we don't have any event  
25:55 - listener listening to click on this particular 
byte. Let's go ahead and add the code for that.  
26:05 - So what we're going to do is add an event 
listener to listen to a click for the button.  
26:11 - And we're literally going to use the add 
event listener method, listen for a click,  
26:17 - and then call a function called add new bookmark 
event handler. And this is a function we have not  
26:26 - coded yet. So to make this function work, we're 
going to have to do the following. We're probably  
26:33 - going to have to figure out the timestamp of the 
video at which point someone presses the button.  
26:40 - This is basically going to help us figure 
out what our bookmark should be saved as in  
26:45 - storage according to its timestamp. So how 
are we going to do that? How are we going  
26:50 - to figure out the YouTube video timestamp. 
Again, YouTube makes this pretty accessible,  
26:56 - it can be found as an attribute. So what we're 
going to want to do is grab the YouTube player.  
27:03 - And we already have a global variable that has 
it. But I'm just going to grab it again. So we can  
27:08 - see how to do this in the console, I'm going to 
create a YouTube player variable in our console.  
27:16 - Okay, now we have it saved. And then on YouTube 
player, there's going to be a property called  
27:23 - current time. And it's going to give us the 
current time in seconds. And in order for us to  
27:32 - save our bookmark, according to hours, minutes 
seconds, we're probably going to also have to  
27:39 - create a function that converts seconds into a 
standard time of how it's displayed in YouTube.  
27:49 - So let's go ahead and start with all those 
things. We're gonna go ahead and add the function,  
27:54 - add new bookmark event handler. And we're going 
to use the exact property we saw in our console,  
28:07 - YouTube player dot current time, which is going to 
give us the current time. And we're going to say  
28:13 - okay, now, this is only called when a new bookmark 
is made. So let's create a new bookmark variable.  
28:21 - And this is going to be an object that has 
the time of the bookmark and a description.  
28:29 - And the description is just going to end up 
being the title that's going to be displayed  
28:35 - in the Chrome extension. So it's going to be 
a dynamic description and skins a bookmark at  
28:43 - current time. However, the problem is that 
this is in seconds, as we said before,  
28:49 - so we're going to have to convert this. So 
we're going to use a function called get time.  
28:56 - I'm just going to insert it using pieces. So I'm 
going to do is go over to this time function here.  
29:02 - Insert snippet. And there it is. So now I'm 
able to convert my seconds into time. And then  
29:11 - the last thing I want to do here 
is sync it to Chrome Storage.  
29:16 - And what this is going to do is set Chrome storage 
with each bookmark. So basically, each video,  
29:23 - according to its video identification 
number that we're grabbing from the URL  
29:28 - will also map back to a set up bookmarks in Chrome 
Storage. So to do that, we're going to do Chrome  
29:35 - storage sync. And again, if you're interested in 
this, you can look in documentation to find out  
29:41 - what this function takes. Current video, it's 
important to remember that things need to be  
29:47 - stored in JSON in Chrome Storage. So I'm going to 
do JSON stringify. All my current video bookmarks,  
29:57 - so I'm actually going to add it A variable up here 
that's going to store all current video bookmarks  
30:07 - in an array. And I'm going 
to spread that. So we can  
30:15 - add a new bookmark to those set of current video 
bookmarks. And then the last thing I want to do  
30:22 - here is sort bookmarks by their save 
timestamp in our Chrome Storage.  
30:29 - So we're going to sort by time, and this is just 
coming from this right here, every bookmark is  
30:36 - going to have a time and a description. So we're 
going to look at that and sort accordingly. Great.  
30:46 - Now, if we reload our extension, we're going 
to see if it works as expected. And the way  
30:52 - to see that is basically console dot log, this new 
bookmark, let's do it. Great. That time it worked,  
31:01 - we just had to give it another reload. And 
we got a time in seconds and a description.  
31:08 - Now the final thing I want to do is complete this 
file before we go to the UI. And we want to make  
31:13 - this fully functional to fetch all bookmarks when 
a new video is loaded. To do this, we're going  
31:18 - to grab asynchronously, all bookmarks from Chrome 
storage, which means I'm going to write a promise  
31:24 - that resolves once we retrieve all bookmarks. 
So that code is going to look like this.  
31:29 - I'm going to create it at the top here. 
And I'm going to say const fetch bookmarks.  
31:41 - And I want to return a promise. So 
we can resolve this asynchronously.  
31:52 - And within that promise, I'm going 
to fetch from Chrome Storage. So  
31:57 - I'm going to do a Chrome storage 
sync and we did a set before to  
32:01 - set Chrome Storage, we're going 
to get this time our current video  
32:10 - it takes an object. And we're going to resolve  
32:23 - to find any bookmarks when indexing 
using our current video. So  
32:38 - basically look in storage to see if our current 
video has any bookmarks, or if it exists in  
32:44 - storage. That's what's happening right here. If 
it does exist, we're going to JSON dot parse it  
32:50 - because we JSON dot Stringify before, 
if it doesn't, what we want to do is  
32:59 - return an empty array. And this should work. 
And we're really only going to add these in  
33:07 - two places, which will be in our new video 
loaded function. So we're going to make this  
33:14 - async. And we're gonna add a fetch bookmarks. 
So actually, we're just going to add this to  
33:22 - our current video bookmarks variable. 
And call a weight fetch bookmarks.  
33:31 - async await is going to resolve this promise.  
33:35 - And then the second place we want to add this 
is to our add new bookmarks event handler.  
33:42 - To basically handle this case, and make 
sure we're always using the most up to date  
33:49 - set of bookmarks when destructuring.  
33:54 - So we're gonna do current video bookmarks equals 
the weight, veg bookmarks. And also make this  
34:03 - async. Awesome. So for right now, we finished 
everything we need for our content script file,  
34:12 - obviously, things aren't going to show in the 
UI. And we could check that out right here.  
34:18 - And as you can see, there's nothing in the UI 
because everything we've been doing so far has  
34:22 - been manipulating the DOM right here to add 
the icon. Add some logic to get us ready to  
34:29 - create a UI for our extension. Let's go ahead and 
start making some UI components show starting out  
34:35 - with some bookmarks from clicking that addition 
button in the YouTube player that we added.  
34:40 - Now, the first thing we need to figure out on any 
given page is if it's a YouTube video page or not,  
34:46 - if it is, we're going on one of fetch any 
bookmarks we may have from Chrome Storage.  
34:51 - And if it's not, we'll just want to display 
some messaging saying it's not a YouTube page.  
34:56 - If you open the Chrome extension on a 
page that is not YouTube. So to do this,  
35:01 - we're going to add a utility function that's 
going to allow us to decipher that logic.  
35:08 - So we're actually going to grab our utility 
function to find the active tab that the user is  
35:14 - on through Google Chrome documentation. I'm going 
to go ahead and use this example right here, which  
35:21 - helps us retrieved a currently focused tab 
from the Chrome documentation. And since I  
35:26 - have the google chrome pieces extension over 
every codeblock, whether it's in documentation  
35:31 - or Stack Overflow, I'm able to directly 
save on pieces with this icon that shows up  
35:37 - at the top right of any code block, I'm going 
to go ahead and save it. And then I'm going  
35:41 - to go back to my VS code and refresh my pieces 
tree, I can go ahead and insert this snippet,  
35:48 - which is the newest one, and I'm just going 
to rename this snippet to active tab Chrome.  
35:56 - Amazing and pieces automatically classified this 
as JavaScript, because it was able to decipher  
36:02 - that from some machine learning. I'm gonna go 
ahead and delete this background.js comment.  
36:09 - And awesome, we now have a function that grabs 
the current tab. But also, I want to make sure  
36:15 - I'm exporting this function. So I'm going 
to add export. And then what I want to do is  
36:21 - open up the pop up.js file. And over here, 
we're going to want to import that function  
36:26 - at the very top. So we can use it here. 
So I'm going to import Get active tab URL  
36:36 - from utils dot j, s, and I actually 
don't think the documentation called  
36:43 - it this. So I'm going to go ahead and 
change the function name, so it matches.  
36:49 - So go to utils.js. Change that thought, 
awesome. Now, the event we want to listen  
36:58 - to when opening the pop up.js file is the DOM 
content loaded event, which is right here.  
37:04 - This event is a native window event that fires 
when an HTML document has initially been loaded.  
37:10 - It's essentially when we want to load all our 
bookmarks and show them. So we're going to  
37:15 - type the following to do so what we're going 
to do is grab our active tab function first.  
37:22 - And we're going to look at the user's current 
active tab, which we already have the function  
37:30 - for from in the utiles. It's an async function. 
So we're going to async await this. And then after  
37:37 - that, we're going to grab the query parameters 
to help us identify the video. If you remember,  
37:44 - each YouTube video has a unique identifier. After 
the question mark, where the query parameter,  
37:52 - we're going to grab that, we're going to use a 
URL search params to be able to get the unique  
37:59 - identifier for each video. And to get the 
unique identifier, we're going to create it  
38:09 - current video variable and do URL parameters 
dot get V. And this is just based off of  
38:17 - what the YouTube video URLs look 
like. Now, our active tab URL  
38:24 - should have youtube.com/watch Because any specific 
YouTube video always has this in its URL. And  
38:34 - we want to make sure we're watching a YouTube 
video when our Chrome Extension has any logic  
38:39 - with bookmarks. And we want to make sure 
this current video variable is truthy  
38:44 - meaning is get actually returned something 
other than undefined or any falsie value.  
38:54 - And then what we want to do is we want 
to get any current video bookmarks from  
39:00 - Chrome storage. If you remember, we're setting 
Chrome storage with the current video as a key  
39:06 - and then all the bookmarks as a value that is 
JSON ified. And in order for us to retrieve those  
39:12 - bookmarks, we need to use a Chrome Storage API 
to get them. So to do that, we're going to grab  
39:19 - the video bookmarks using Chrome storage sync get. 
And we're going to get it with the current video  
39:26 - unique identifier, which is the YouTube 
videos unique identifier in the URL.  
39:34 - And then, we are going to set a current video 
bookmarks variable which is going to contain  
39:41 - all those JSON ified current videos. And in 
order for us to pass this to any function  
39:46 - or write some custom logic to show bookmarks, 
we're going to have to JSON dot parse any  
39:55 - bookmarks that are saved in Chrome Storage since 
it's in JSON, and we can't really work with that.  
40:00 - But if there are no bookmarks or chrome searches 
and return anything, we're just going to want to  
40:07 - return an empty array. Now, we're going to have 
to pass this over to the view bookmarks function,  
40:15 - which is basically going to help us 
view any bookmarks in our extension,  
40:21 - that Chrome Storage dot get returns. But before 
that, I'm just going to put a comment right  
40:26 - here. So we remember, we want to handle this 
else condition, which basically is for the  
40:32 - scenario where we're not on a youtube.com video 
page, or current video returns a falsie value.  
40:40 - So what we're going to want to do is add a message 
that says this is not a YouTube video page.  
40:47 - And let's just go back to chrome to 
look at what that might look like.  
40:54 - So this is our UI Currently, we have this 
container class right here that encapsulates  
41:03 - and will eventually encapsulate all the bookmarks 
we have, it has this container class name in it,  
41:09 - what we're going to want to do is get that class 
name. So we're just going to do this in the  
41:15 - console before we actually do in code just to make 
sure it works. The class was called container. And  
41:22 - that's just from the CSS in the boilerplate, 
so you don't have to worry about it, or the  
41:27 - HTML or other. So when we wrote this document that 
get elements by class name container, and then  
41:34 - grab the first element in the HTML collection, we 
get this element right here, which is containing  
41:43 - all these other elements within it. And what we 
want to do here is basically specify in the HTML  
41:54 - on pages that are not youtube.com. So 
this is actually a YouTube video page.  
42:00 - We don't want to display this message. But I 
just want to show how this is going to look,  
42:04 - we're going to want to put a new div class  
42:11 - that says, This is not a YouTube video page.  
42:15 - And let's just see if that works. Will this 
change the extension the way we want it to?  
42:24 - Container is not. So what we need to do over here  
42:29 - is actually encapsulate this in a variable. 
We're gonna set this equal to container.  
42:35 - And now let's try that. And change the extension 
to show that this is not a YouTube video page.  
42:42 - So the way we're going to do 
this dynamically in our code  
42:45 - is basically put all the code we just 
put in our console to test this out  
42:50 - within our else conditions. So every time we're 
not on a YouTube video page, or this returns a  
42:55 - falsie value, we want to show that this is 
not a YouTube video page when we try to open  
43:01 - up the Chrome extension in those scenarios. So 
we're gonna say const container equals document  
43:06 - dot get elements by class name, right there. 
Grab that container class, first element.  
43:17 - And then set the inner HTML, set that equal to div 
class equals title, title, just add some styling,  
43:25 - that's going to make it look 
slightly nicer. There's nothing  
43:29 - super special about the styling I have.  
43:35 - And since we tested it, there shouldn't be 
really any surprises here, it should pretty much  
43:40 - work as expected. So let's go ahead 
and give this extension a reload.  
43:47 - It shouldn't show the message for this page. 
It doesn't. But if we go to a non YouTube page,  
43:53 - it's gonna say this is not a YouTube 
video page. Amazing. So let's go back to  
43:59 - our code. And we're going to want to 
write this view bookmarks function.  
44:03 - So if it does meet the conditions of being on 
a youtube.com/watch page, and as you can see,  
44:10 - that's from any page that has a video page, 
it has youtube.com/watch on it. And your  
44:19 - URL params dot get the return something so it's 
a truthy value, we're going to want to view the  
44:27 - bookmarks associated with that video. So let's 
go ahead and call the view bookmarks function  
44:34 - and pass it all the current video bookmarks. 
And we're gonna go ahead and write the logic  
44:39 - that's going to help us populate the UI with all 
the bookmarks we grabbed from Chrome Storage.  
44:46 - So to do that, we're going 
to pass it current bookmarks.  
44:54 - And we're going to set a default argument of an 
empty array just in case nothing is passed to it.  
44:59 - It's just going To return or show no bookmarks, 
and we're going to grab a bookmark element.  
45:10 - Again, this is just from the HTML that I have 
given you. So it's not anything you need to  
45:17 - worry about. If you want to try this out on your 
own, you could try it out in the console. Just  
45:23 - to save some time here, I'm just going to write 
the code here. And you can go ahead and copy it.  
45:28 - But again, it's just knowing how to work with 
the DOM and inspecting the elements to figure out  
45:34 - how to do this.  
45:37 - What I'm doing right here is basically saying, 
Okay, if there are any bookmarks, let's just set  
45:43 - it to nothing. So we're not displaying anything, 
we're going to reset the whole thing, since we're  
45:49 - calling this function to view bookmarks. And we're 
going to have new bookmarks being passed in, which  
45:54 - is the current bookmarks. And we're gonna say if 
the current bookmarks length is greater than zero,  
46:00 - meaning if there are current bookmarks, 
and it's just not an empty array.  
46:08 - Let's go ahead and iterate 
over all those bookmarks,  
46:11 - and show them in our UI. So to do that, we're 
going to iterate over every bookmark in a loop.  
46:22 - And then, we're going to grab the bookmark 
through indexing, so current bookmarks.  
46:29 - With whatever iteration we are in the loop. And 
then what we're going to have to do from here  
46:36 - is call another function, add new bookmark, 
which is going to add a new bookmark row to  
46:42 - our pop up, I'm going to go ahead and remove this 
comment. And we're going to add a new bookmark,  
46:49 - we're going to pass it the bookmark 
element up here, which is going to  
46:52 - populate all our bookmarks, well, it's 
going to be where we add each of our rows.  
46:59 - And I'm going to pass it each specific bookmark. 
So we're going to add one bookmark at a time and  
47:03 - call this function every time we're adding a 
bookmark. But before that, what we want to do  
47:09 - is if there are no bookmarks to show meaning, 
current bookmarks is just an empty array.  
47:17 - We're going to want a message that 
says there are no bookmarks here.  
47:20 - So we're going to set a message using italics.  
47:30 - Saying no bookmarks. To show before we move 
on and add individual bookmarks to our pop up,  
47:42 - let's go ahead and check if this condition 
works. Where there's no bookmarks to show and  
47:47 - since we haven't added any bookmarks to this 
YouTube video that I'm looking at right now,  
47:51 - it should work, I want to go ahead and reload my 
extension. Yep, there it is no bookmarks to show.  
47:59 - Amazing. So now we're going to want to finally 
handle the case where we have bookmarks to show  
48:07 - and this is going to allow us to start seeing 
bookmarks in our UI. So the first thing we're  
48:14 - going to do is go to our add new bookmark 
function. And it's going to accept bookmark  
48:22 - bookmarks element, and it's 
going to accept a bookmark.  
48:31 - And then what we're going to do from here 
is we're going to create two elements. So  
48:36 - one element is going to be for the title, which 
is going to display in the UI of each bookmark.  
48:43 - And then one element is going to be the whole 
bookmark element that will contain the title  
48:49 - will contain the delete button and will contain 
the play button. So let's go ahead and create  
48:54 - the bookmark title element. And then after 
this one, we're also going to create the new  
49:09 - bookmark element, which will encapsulate all these 
other elements that are part of a bookmark row.  
49:24 - From here, for bookmark title element, we're 
going to want to display what the bookmark  
49:29 - is and give it a title. So we actually already 
created the title. The title is the description  
49:35 - of the bookmark. If you remember in our bookmark 
object, there's a timestamp and a description.  
49:41 - So we're gonna set our text content to the 
description, which is bookmark dot description.  
49:48 - And then our class name is going to be bookmark 
title element dot class name, and that will be  
49:55 - set equal to bookmark title and this is just 
going to add some In CSS, that is already in  
50:03 - our boilerplate code. Now for the general 
component that is going to encapsulate all  
50:09 - the play button, the title, a delete 
button, anything else you might want to add,  
50:14 - we're going to do a couple things, the first 
thing we're going to do is give it an ID of  
50:20 - bookmark element, or bookmark with the 
bookmark time, and this is going to guarantee a  
50:28 - unique ID for each element that is a row. So if 
you save any bookmark, what's gonna happen is  
50:38 - there's going to be a row associated with each 
bookmark, which is our new bookmark element.  
50:43 - And there's going to be an ID set for that 
row, which will be the bookmark along with  
50:47 - the time and they'll help us uniquely 
identify any specific row in the UI.  
50:53 - And that's later we're going to be used to delete 
elements when we're deleting a specific bookmark.  
51:02 - And then we're going to set a class name, 
which was is going to help with some styling,  
51:07 - that's going to be set to a bookmark 
class. And then we're going to set  
51:12 - an attribute which is going to help us 
with playing a video. Because basically,  
51:18 - we're going to want to know the timestamp of any 
specific bookmark. So when we play the video,  
51:24 - we know where to set the video player at what 
time we want to send it out and the attribute  
51:30 - of the bookmark element will help us find that. 
And the final things we want to do here is,  
51:35 - since we know the new bookmark element 
is encapsulating all these other things,  
51:41 - we want to append child bookmark title element, 
so it displays within the new bookmark element.  
51:50 - And then we have this bookmarks element 
that is passed in. And we're going to  
51:56 - append our new bookmark element, which is this 
element that's encapsulating all the other things.  
52:05 - Inside that since it's a container. 
So now if we go back to our UI,  
52:13 - and we give this a reload, just in case, let's 
just go to a new video. And if I press plus,  
52:20 - in this video, we see a new row, it 
says bookmark out one hour, 54 minutes.  
52:31 - And we could add another row if we 
want. And it gives us that same row,  
52:38 - we're going to handle the case of the 
deletion, there's an ADD, it's just going to  
52:41 - set at zero seconds. Bookmark it 
000. Awesome. So that works. So now  
52:52 - let's go back work on some 
additional functionality.  
52:56 - Right now, we have no functionality associated 
with each bookmark yet, so we can't play any  
53:03 - particular timestamped bookmark, we can't delete a 
bookmark. And the next thing we want to add is the  
53:09 - play button. So to do this, we're going to add a 
play button to each bookmark that will go directly  
53:14 - to this timestamp that we have saved for each 
video. To start off, we're going to have to add  
53:20 - a function that is going to add an icon for 
a play button, listen for a click and call a  
53:25 - function or event listener that will perform the 
logic to set a video at a particular timestamp.  
53:30 - The function will end up looking something like 
what we're going to code right here in a second.  
53:36 - And we're going to keep it super generic because 
it's going to be used for both our delete  
53:42 - and play functionality. So the functions 
are going to take a source attribute  
53:50 - an event listener. And it control parent element. 
And when we say control elements in our code,  
54:04 - it means the play button, the delete button, 
we're just calling those control elements.  
54:12 - So we're going to create a control element.  
54:21 - And this is just one particular functionality, 
we're going to call a singular control element.  
54:27 - So in this specific case, we're going 
to have a play button. But again,  
54:32 - this is a generic function. So think of this 
as like a play button, a delete button we want  
54:37 - this singular control element will be one 
of those. And then those control elements  
54:46 - will be linked to a image in our assets 
folder. So if we want to play button,  
54:52 - what we're going to link to is assets slash play 
dot PNG, and our schema super are predictable  
55:01 - for this. So all we're going 
to do is assets plus SRC plus  
55:08 - dot png. And there's definitely a better 
way of doing this, you can go back  
55:12 - and work on the code after this video. But we're 
just going to keep it super simple for right now.  
55:19 - We're going to give it a title that is 
the same as our source attribute, or what  
55:26 - we pass in this source. So what's going to get 
passed in here is play, edit, delete, whatever.  
55:34 - And the title will be set to that. So in this 
particular case, for play, it will be set as play,  
55:42 - we're going to add a event listener. And 
that event listener will listen for a click.  
55:53 - And we're going to pass it a function that 
is going to be performed on that clique. And  
55:59 - the last thing we want to do is there's 
going to be a container for all control  
56:03 - elements. And we're passing that in into 
this function. And we're calling it control  
56:09 - parent element. So we're going to append this 
singular control element to the parent element.  
56:18 - And the next thing we're going to want to do is 
add the function call that will add a play button,  
56:23 - a title and our event listener to each individual 
bookmark. So in the add new bookmark function  
56:29 - that we coded earlier, we're going to add a couple 
lines of code here. And these couple lines of code  
56:34 - are going to add those control elements. So we're 
going to go ahead and create the element that's  
56:39 - going to hold all our buttons, we're going 
to call it the controls element. And it's  
56:46 - going to be a div just like these other 
ones, we're going to keep it super simple.  
56:53 - And then what we want to do 
is give this some styling.  
57:01 - We're going to add the class name, but controls,  
57:05 - and you're just gonna have to trust me on 
this it exists. Then what we want to do is  
57:14 - set our attributes using a set bookmark attributes 
function that we created, we're going to pass in  
57:21 - play, the event listener is going to be called 
on Play. And we're going to code that later.  
57:26 - And then we're going to pass in the controls 
element, which is going to be the parent element.  
57:31 - And the last thing we want to do is 
append this to our new bookmark element.  
57:41 - And what we should see now is, this 
play button is going to show up in  
57:47 - our extension. So let's check this out. 
Let's give this a refresh over here.  
57:57 - There we go. We have the play button in our 
extension. But what we're going to notice  
58:02 - is it's actually not going to work. Let's go 
ahead and play this video. And we're going to  
58:09 - try to get it back to 26 minutes, 51 seconds, 
it doesn't work. And the reason it doesn't work  
58:14 - is we still need to code the On Play Event 
listener. So let's go ahead and do that.  
58:23 - What we're going to do is we're going to target 
the timestamp attribute that we set earlier.  
58:33 - So again, you could check this out in your 
console or inspect, if you want to get a  
58:39 - visualization of how this is gonna work. But I'm 
gonna go ahead and type this for the sake of time.  
58:47 - And we're gonna get that timestamp we set 
earlier. And then the second thing we're  
58:53 - gonna want to do is grab the active tab, and 
that's just using the active tab function.  
59:00 - This is an async await function. So we're going 
to have to async await it. And I'm going to add  
59:04 - async to make this async function. So 
we've actually run into a problem now,  
59:10 - we need to send the content script and message 
to manipulate the YouTube player to set it at  
59:14 - the timestamp that the bookmark is placed on. 
So in this file, we're going to have to add that  
59:20 - message. Let's go ahead and send 
a message to the content script.  
59:27 - And this is going to follow the same pattern 
of how we did it with our background script.  
59:37 - Missing comma there. We're going to have type 
of play. That's going to be our event type.  
59:44 - And then the value is going to be bookmark time.  
59:50 - And then in our content script, 
we're going to have to be able  
59:54 - to read this message. So what we're 
going to do is add a condition to our  
60:00 - On message listener here, and we're 
going to say if the type is play.  
60:11 - Let's set the YouTube player time  
60:14 - equal to the value that's passed in. So basically, 
let's just take a look at this for a second.  
60:20 - If it's sending a message of type play, 
and the value is the bookmark time,  
60:25 - then what we want to do is take that value and 
set it to the YouTube Players Current Time,  
60:29 - which will make it the time of the bookmark. 
And let's go ahead and see if this works.  
60:37 - I'm going to go ahead and reload my extension. 
And let's go ahead and go to the extension,  
60:46 - we have a bookmark at 26 minutes, 51 seconds, 
it's currently at 48 minutes, 30 seconds.  
60:52 - Let's hit that play button. It goes 
back to 26 minutes, 51 seconds.  
60:57 - And now if we also hit this addition 
button anywhere in the video,  
61:01 - we should get a new bookmark, we have 
two hours, 21 minutes, 22 seconds.  
61:07 - Now let's go forward. Let's press play 
here. And it goes back to that time.  
61:14 - Awesome. So now our Play button works. The last 
functionality we want to build is the ability to  
61:19 - delete a bookmark, which will be super similar to 
what we did for the play button. The first thing  
61:25 - we're going to want to do is go to our POP up.js 
file. And we're going to add the delete button  
61:30 - to our controls element with the code in our add 
new bookmark function to set bookmark attributes.  
61:37 - So let's go ahead and do that we're going to pass 
in delete our on delete event listener, and then  
61:44 - the parent controls element. And since we set 
the undelete function as the event listener,  
61:51 - we need to code some operations that are 
going to take care of our deletion. So we  
61:56 - already know we're going to use this active tab 
that we used over here. So let's go ahead and  
62:02 - already create this an async function ahead 
of time. Let's grab the user's active tab.  
62:13 - And then what we're going to want to do is grab 
the timestamp attribute that we set earlier.  
62:23 - And it's going to be the same code from up 
here. So I'm just going to copy and paste  
62:31 - there we go. Then what we're going to also want 
to do is grab the element that we want to delete.  
62:42 - So if you remember, I created a 
specific ID linked to timestamps,  
62:49 - what we're going to want to do is grab 
elements by the ID so we can delete them.  
62:58 - So bookmark. Plus the bookmark time will 
give us the element we want to delete.  
63:07 - And then what we're going 
to do is delete that element  
63:10 - by going to the parent node, and then removing the 
child which will be the element we want to delete.  
63:19 - And then the final thing we're going to want to 
do here is send a message to our content script.  
63:26 - Saying we want to perform a deletion type of  
63:36 - delete, and then the value is going to be bookmark 
time. And there's one final thing we want to do  
63:45 - here, this Send Message function from the Chrome's 
tabs API actually takes a callback function  
63:51 - optionally. And we're going to pass one in which 
is going to be our view bookmarks function. And  
63:56 - that's just going to refresh our bookmarks, so any 
deletions show up immediately, then in our content  
64:03 - script, we're going to add another condition, 
which is basically you're going to ingest  
64:08 - that Delete message. So we're going 
to say else if type equals Delete.  
64:19 - The current video bookmarks will be 
equal to current video bookmarks.  
64:26 - Filter, and we're going to filter by time.  
64:31 - So the time is not equal to the value 
being passed in because that's a  
64:35 - value we're deleting. And then the final 
thing we want to do is sync Chrome Storage.  
64:41 - So if this page reloads, this 
deleted bookmark does not show up.  
64:52 - We're going to JSON fi, error bookmarks and If 
that should work, the last thing we want to do  
65:03 - is add a way to send the updated bookmarks back 
to our POP up.js file in order to display the most  
65:09 - recent bookmarks, and we'll do the following. 
To do that, we're going to send a response of  
65:16 - current video bookmarks. So now we can go ahead 
and try out deleting a bookmark with a reload  
65:22 - of our extension, and it should start working. 
So I'm going to go back to our Chrome browser,  
65:31 - reload our extension. And if we 
go ahead and delete a bookmark,  
65:40 - we're gonna see that they're deleted. If we go 
ahead and add a bookmark, we're gonna see there's  
65:47 - a new bookmark. It's at a different timestamp the 
YouTube players a different time. So if we play,  
65:53 - it goes back to the timestamp of the bookmark. 
We want to delete again, it's going to delete.  
65:59 - The last thing we're going to want to 
do is distribute our extension. However,  
66:03 - I'm not going to quite go over that in this video, 
because Google gives great documentation that  
66:07 - serves as a step by step guide on how to go about 
publishing your chrome extension to the Google web  
66:12 - store for anyone to download. And with that, the 
videos over you know everything you have to do  
66:18 - in order to create a modern web extension 
using manifest v3, and I'll see you next time.

Cleaned transcript:

If you want to create your own Chrome extension, you're in the right place. In this course, Raman will teach you how to create a Chrome extension using the new iteration of the web extensions platform, which is called Manifest v3. Rahman is a great instructor. And he works for pieces that app pieces that app provided a grant that made this course possible, but you don't have to use their extension to follow along share in the comments what type of Chrome extension you want to make. Now the reason I want to teach about this particular topic is I've created two web extensions in my career. The first is for a previous company, where my extension generated a significant amount of revenue for the company. And the second for my current company pieces, where our web extensions play a critical part of our product stack, and help developers across the globe boost their productivity. I'm going to be using the pieces web extensions and integrations quite a bit in this video. So if you're interested in downloading an AI coding assistant that helps you save and reuse code snippets, convert screenshots to code, and more, go ahead and download pieces in the description. And you can totally follow along. So during my journey as a Chrome extension developer, I did often notice that tutorials and StackOverflow answers were using outdated versions of the web extensions platform. My hope for you after you leave this video is that you have a resource to create a modern Chrome extension, and you understand the difference between the newer version of the web extensions platform manifest v3, and older versions. Now, before we get started, there's going to be three prerequisites to this course, the first is required, and it's that you have a basic understanding of JavaScript and DOM manipulation. The second is optional. If you want to follow along with this video and code alongside with me, you can go to the description below, I'm gonna have a link to my GitHub repo, go ahead and get cloned that and you'll be able to follow along. The third is also optional. If you totally want to follow along, you can go ahead to pieces dot app and install a pieces IDE integration along with the pieces Web Extension, and you'll be able to use pieces exactly the way I do in this video. With that, let's get started. So as I mentioned before, the extension we're going to create as a YouTube bookmarker. Basically, anytime you navigate to a YouTube video page, an icon will show up on your YouTube video player to allow you to bookmark a particular timestamp on any video. So let me show you how that's gonna work. If you're on a YouTube video page, you're gonna see this item at the bottom right, you can go ahead and click that. And if you navigate to your chrome extension icon at the top, right, I've pinned, so it's showing in the toolbar, you're going to see a new timestamp already had one timestamp for 15 minutes, I added one with an hour 18. I can go ahead and delete this one because I just decided I don't want it. And our extension is going to give us that ability to do that. Now if I want to go back to my 15 minute timestamp, you can click the play button. And it goes directly back to that particular timestamp. I can also delete this one too. And when there's no bookmarks to show, it's going to say there's no bookmarks to show. Now we're going to add one, just so we have one on this video, and I can show you how storage works. I'm going to navigate to a new video. And in this video, we have no bookmarks. So it says there's no bookmarks to show. But if we go back to our previous video where we saved a bookmark, it's going to load that previous bookmark. Now the last thing is if you navigate to a non YouTube video page, it's going to say this is not a YouTube video page in the extension UI. And that's basically all the capabilities of this chrome extension we're going to build out here, there's going to be a lot more you can do on your own afterwards. Now I also want to mention the reason we're working on creating this extension in particular, is because it's going to show you all the major parts of creating a Chrome extension, it's going to show you how to work with a content script to manipulate the DOM. It's going to show you how to create a UI for your extension. And it's going to show you how to use service workers as background scripts, which is a major part of the ship from manifest v2 to manifest v3. And to start working on the extension. Once you get cloned my repo, you can go ahead and click on the puzzle piece in your Chrome browser at the top right click Manage extensions. I'm going to go ahead and remove my extension show I can show you how it works. And you're going to see this developer mode option at the top right go ahead and toggle that so it's on click Load unpacked, then go to the repo that you get cloned in mind with the boilerplate code. Go ahead and load that. And we're going to see our extension here. If we Click on this puzzle piece and pin it. What we're going to see is this basic UI, it's just going to say your bookmarks for this video with no bookmarks, and it's just going to show up everywhere. This is the default messaging in the boilerplate code I supplied and the boilerplate code will also contain all the files you need to follow along. The best place to start with creating our extension is the manifest dot JSON file. This file is a JSON file where we can specify what version of the extensions platform we will use, among other information that is going to serve as default for loading in our extensions. Also, every extension you would want to create whether it's Safari, Mozilla, or any chromium base extension will need a manifest dot JSON file. And it's probably the single most important file in your extension, because it simply just won't work without it. In our boilerplate code already added the manifest dot json file, so we don't have to spend too long writing it out, I think it would be especially helpful if I just point out some of the things that you should note, in case you're creating your own extension. So let's take a look here, as you'd suspect, there's a name, there's a version number and a description. And basically, the version number is going to populate when you loaded in the extension, the name you see is also going to be the name of the extension when you load it in. And the description is pretty self explanatory. It's just a description of what the extension does. Now things get more interesting with the permissions. The permissions will be different depending on whatever Chrome extension you're building. For this particular extension, we're going to request two permissions, which is going to be the permission to use the Chrome dot storage API, and the chrome dot tabs API. The chrome dot storage API is to store things in the user's browser for the extension. And the second permission, which is a chrome dot tabs API, is what helps us access our browser's tab system. So we can read the tab for the extension. This is basically going to help us identify what browser tab the user is currently using, and grab the URL to see if they are in a YouTube video page for our extension. Now, the host permissions just give you the ability to send cause requests to certain host names. Our extension only deals with YouTube pages. So I have a match pattern written here just for YouTube. The service worker, as I mentioned before, there's a big change between extensions, v2, and v3. And one of the big changes is the use of a service worker. As you can see here, the other is the ability to use promises. But let's just focus on service workers. For right now. Service workers are just a JavaScript file that runs separately from the main browser thread. This means that your service worker would not have access to content of a webpage, since it is separate from main processes. However, your service worker does have capabilities to speak to your extension using the extensions messaging system, which we will see and use in our bookmarking extension. The next thing I want to point out is the content scripts. The content scripts are just files that run in context of the webpages we're on. We're going to use this to manipulate the DOM of our webpage that our extension is looking at. And here we're just specifying that our content script is represented by our content script J S file. As you can see, with the J s colon content script dot j s, the last thing I want to point out is the pop up dot HTML file down here, under default pop up, this just specifies which file was served as our UI. In our case, we've specified the pop up dot HTML file, and in that file, we specify that the corresponding file that helps it with its interactivity is a pop up.js file. With all that out of the way, let's get to coding the actual extension. We're now finally going to start writing code to make our extension work. For us even test the extension, we have to add the button of the YouTube player that will allow us to save bookmarks with timestamps. So in order for us to add a button on the YouTube video player will have to manipulate the DOM of the web page we are on. What that means is we'll have to write our logic in our content script file, which operates in the context of the webpage, as I mentioned before, so let's go ahead and add some code to our content script file. We're going to go ahead and add the following variables YouTube, left, controls, and YouTube player one is going to be for accessing the YouTube player one is going to be for accessing the controls. And this is going to allow us to manipulate each of these. But before we continue writing the logic to do DOM manipulation in the context strip, we also have to think about how our extension is even going to know when we've navigated to a new web page. And we need to know this so the content script knows to execute logic to add the plus i Call to add bookmarks for our extension. Let's go ahead and go in our background.js file now. And what we want to do here is listen to any updates in our tab system and find the most recent tab or the tab that we're on currently and see if it's a YouTube page. So we're going to have a listener, that's going to listen to tabs. And if you remember, we got permissions to access the Chrome tabs API. And we're going to listen for an update to tabs. The parameters were given is a tab ID and a tab. What we're going to do from here is see if there's a tab URL, and if there is a tab Euro. Let's see if that Euro includes youtube.com/watch. The way I came up with that is if you look at our YouTube video, every individual video has YouTube slash watch. And we just want to make sure we're on a page that has that specifically as a URL, then what we want to do is set our query parameters. And we're going to use query parameters as a unique ID for each video. So we can grab it from storage, you'll see what I mean in a second, and I'll show you. So we're going to do that by using the JavaScript split method. What that means is basically after this question mark query parameter, we're going to grab this value. And this is going to be our unique video value this right here after the equal sign. And every video on YouTube has a different value right here. So it's a pretty unique key that will help us store videos uniquely as well in our storage, and it's consistent. So then we're going to add your URL parameters. And this is just an interface to work with URLs URL search params. And the final thing we want to do is there's a messaging system that happens between the extension, we're going to send a message to our content script that basically says a new video is loaded. And this is the video ID of that video, and the video ID being that unique video value that we saw in the URL on YouTube. And this tab, Id send message usage that I'm doing right here is all directly from documentation. The Send Message takes a tab ID, it takes a unique object. So right now I'm going to type type. And this is a type of event is a new video event. And then a video ID value, which is going to be URL, parameters, dot get v. So if we're doing URL dot get D, it's going to grab this right here. And that's basically going to be the code for that send message takes a tab ID, it takes an object and then it can also take a callback function. This object right here doesn't have to be type or video ID, it could also be something random, like I could literally pass this and the content script will have access to random, and then the string random. In our case, the only thing that's applicable is the type of the event and then the video ID, which is a content script needs. Now in our content script, we're going to add a listener that is going to listen to any of those incoming messages, we need to be able to listen to that background.js message. So to do that, we're going to end up writing the following code to add that listener, so we're going to say on message add listener. And this is going to accept three parameters. So an object a sender, and a response. And the response is, when a message is being sent to the content script, we can also send a response back where the message is coming from. So I'm going to destructure those values we're getting and if you remember, the way I'm deconstructing Type value video ID is basically we're given a video ID right here. Later on, we're going to grab a value as well, and I'm just destructuring. So each of these are its own variable. So it's a If type is equal to new, so if the type of event is new video loaded, which we're getting from the background.js file, we want to be able to set current video, which will be a global variable in the content script as the video ID, and then we want to call a function to handle any actions with new video. So we're going to call a new video loaded function. And let's go ahead and set current video as a top level variable. And that's just going to be an empty string. But it's going to be set as the string set from the background at js file, once the message is received on this end, so let's go ahead and actually see if this works at all. I'm gonna go ahead and just console dot log your parameters. I'm gonna give this a reload. Open this, let's inspect it. And we ever URL search parameters. So we know we're getting our URL search parameters now. Great. So so far, things look good. Now, what we want to do from here is create that new video loaded function. And after we create this function and all the functionality surrounding it, we should see the YouTube player button on the YouTube video. So let's go ahead and do that. So what we're going to do is create this function that we have right here called New Video loaded. And what we probably want to do is check if a bookmark button already exists, I know the class name that this item has, it's called Bookmark button because I wrote the CSS code that's going to style this whole extension. So you could just copy this part right here. But this is just some native Dom, slash JavaScript methods that we can use. It's actually MB by class name. And it's going to return an HTML collection. So what we're going to do is grab the first element that matches this class name, bookmark button. And it's just going to exist on every single YouTube video page. So if we want to test that, we could just say console dot log bookmark exists. And let's reload this page and inspect it. Actually, let's reload our extension as well. reload this page inspect, we're probably going to get undefined this is exactly what I expected. Because we don't have any logic surrounding the Bookmark button yet. And also, we're not even setting a bookmark button right now. So if the Bookmark button did exist, we would get true, it does exist, but we're getting undefined right now. So what we want to do if we're getting that undefined or false value that a bookmark button does not exist, is add some logic to say, hey, let's add this bookmark button to any YouTube player. So we're going to create an image element. That is going to be the image we click on for bookmark buttons. As part is in, we're going to add a couple of attributes. The first thing we're going to want to do is pull the image that we're using, which is our assets slash bookmark. PNG, you already have this if you're following along with the boilerplate code. The second thing we want to do is add a class. And the way we're going to add this class is basically make it pretty dynamic here. So we're gonna add a YouTube button class with a space and then we're going to add a bookmark button class in quotes. And this is again, just some styling I have that you don't need to worry about right now. And the last thing we want to do is basically on hover, we want to make a title show. So we're just gonna say the title is click to bookmark, current timestamp. And this is just a UI thing. You'll see this in a bit. Next, what we want to show is a way to grab the YouTube controls. So these are the YouTube controls over here, we want to be able to grab these left controls, so we can add a bookmark button right here. So let's go ahead and find out how to do that. I already know how to grab this. So I'm going to show you how this works. You can inspect elements right here and find what elements they exactly are. But basically, we're going to use native JavaScript methods like we have done previously to grab those controls and insert our button. If I do document dot get elements by class name. And I grab YouTube left controls, we should get an element back, which is going to be this div class over here. And you can see that it gives us all the left controls over here, where we're going to add our button. And the second thing we're going to want to do is grab the YouTube player as well. And that's one of the global variables we set in our content script. And we can also do that by writing document dot get elements by class name. And then there's this video stream class. And we're going to grab the one at the zero with index. And it grabs a whole YouTube component right there. So now we know the two elements in the DOM we need to manipulate. But let's set those elements. First, we're going to do exactly what we saw in our content over there. Document get, actually, I'm just gonna go back and copy these way easier, so don't make a mistake. And then the second one is going to be YouTube player. Go back and copy that. Okay, so after this, what we're going to want to do is add that bookmark button and we grabbed the controls, you saw that row in the player, we want to add it to that row. So we're going to type out YouTube left controls to get those left controls we stored in a variable. And to use this native JavaScript method we can use called append child, which is going to append this bookmark element inside that row. And then the second thing we're going to want to do is probably add a listener to listen to any clicks on our icon. So there's a correction I want to make to this portion of the video, before we continue, it's going to be very important in order for your extension to work functionally. And it's only one line of code, but it's going to make such a big difference. I'm also going to explain an important concept of Chrome extensions that I neglected while I was writing this, which is that in our manifest json file, we have a match pattern for our content script. And basically the match pattern, we currently have checks if any youtube.com video is loaded. And if it is, we're injecting our content script into the context of that web page. So basically, what that means is, anytime a youtube.com page shows up, we're running a bunch of logic using our content script. But the problem right now is that our background.js file is telling us when a new video is loaded. And the event listener we're using is on updated, which is just checking if this URL is updated. If you refresh this page, the URL is not updated. So this button actually isn't going to show up. And if you continue coding without this fix right here, you're gonna see some edge cases that you might not like. So let's go ahead and fix this, we're going to do a super simple fix. It's not the best fix in the world, but it will fix the problem here. We're just going to call a new video loaded anytime our content script matches youtube.com. And what this is going to do is call this new video loaded function anytime we hit that match pattern. The downside of this is now if the background script sees it as a new video using the on updated event listener, and there's a condition that content script is injected, we're going to hit this or call this new video loaded function twice, you can fix this pretty easily by just adding a conditional make sure that doesn't happen. But to make sure everyone is able to follow along with this correction, I will not be doing that here. And we'll just only be inserting this one line of code calling the new video loaded function. Luckily, the only thing our new video loaded function is doing is adding the Bookmark button to the YouTube player. So there's going to be no negative implications to calling it twice. Since we have a condition that checks if the button is already on the player. It's just not the most efficient implementation, which is fine for the sake of this tutorial. With that, let's continue with the rest of the video. There we go, we have the button right there. But right now, if we click the button, it's not doing anything. And there's a reason for that. The reason is that we don't have any event listener listening to click on this particular byte. Let's go ahead and add the code for that. So what we're going to do is add an event listener to listen to a click for the button. And we're literally going to use the add event listener method, listen for a click, and then call a function called add new bookmark event handler. And this is a function we have not coded yet. So to make this function work, we're going to have to do the following. We're probably going to have to figure out the timestamp of the video at which point someone presses the button. This is basically going to help us figure out what our bookmark should be saved as in storage according to its timestamp. So how are we going to do that? How are we going to figure out the YouTube video timestamp. Again, YouTube makes this pretty accessible, it can be found as an attribute. So what we're going to want to do is grab the YouTube player. And we already have a global variable that has it. But I'm just going to grab it again. So we can see how to do this in the console, I'm going to create a YouTube player variable in our console. Okay, now we have it saved. And then on YouTube player, there's going to be a property called current time. And it's going to give us the current time in seconds. And in order for us to save our bookmark, according to hours, minutes seconds, we're probably going to also have to create a function that converts seconds into a standard time of how it's displayed in YouTube. So let's go ahead and start with all those things. We're gonna go ahead and add the function, add new bookmark event handler. And we're going to use the exact property we saw in our console, YouTube player dot current time, which is going to give us the current time. And we're going to say okay, now, this is only called when a new bookmark is made. So let's create a new bookmark variable. And this is going to be an object that has the time of the bookmark and a description. And the description is just going to end up being the title that's going to be displayed in the Chrome extension. So it's going to be a dynamic description and skins a bookmark at current time. However, the problem is that this is in seconds, as we said before, so we're going to have to convert this. So we're going to use a function called get time. I'm just going to insert it using pieces. So I'm going to do is go over to this time function here. Insert snippet. And there it is. So now I'm able to convert my seconds into time. And then the last thing I want to do here is sync it to Chrome Storage. And what this is going to do is set Chrome storage with each bookmark. So basically, each video, according to its video identification number that we're grabbing from the URL will also map back to a set up bookmarks in Chrome Storage. So to do that, we're going to do Chrome storage sync. And again, if you're interested in this, you can look in documentation to find out what this function takes. Current video, it's important to remember that things need to be stored in JSON in Chrome Storage. So I'm going to do JSON stringify. All my current video bookmarks, so I'm actually going to add it A variable up here that's going to store all current video bookmarks in an array. And I'm going to spread that. So we can add a new bookmark to those set of current video bookmarks. And then the last thing I want to do here is sort bookmarks by their save timestamp in our Chrome Storage. So we're going to sort by time, and this is just coming from this right here, every bookmark is going to have a time and a description. So we're going to look at that and sort accordingly. Great. Now, if we reload our extension, we're going to see if it works as expected. And the way to see that is basically console dot log, this new bookmark, let's do it. Great. That time it worked, we just had to give it another reload. And we got a time in seconds and a description. Now the final thing I want to do is complete this file before we go to the UI. And we want to make this fully functional to fetch all bookmarks when a new video is loaded. To do this, we're going to grab asynchronously, all bookmarks from Chrome storage, which means I'm going to write a promise that resolves once we retrieve all bookmarks. So that code is going to look like this. I'm going to create it at the top here. And I'm going to say const fetch bookmarks. And I want to return a promise. So we can resolve this asynchronously. And within that promise, I'm going to fetch from Chrome Storage. So I'm going to do a Chrome storage sync and we did a set before to set Chrome Storage, we're going to get this time our current video it takes an object. And we're going to resolve to find any bookmarks when indexing using our current video. So basically look in storage to see if our current video has any bookmarks, or if it exists in storage. That's what's happening right here. If it does exist, we're going to JSON dot parse it because we JSON dot Stringify before, if it doesn't, what we want to do is return an empty array. And this should work. And we're really only going to add these in two places, which will be in our new video loaded function. So we're going to make this async. And we're gonna add a fetch bookmarks. So actually, we're just going to add this to our current video bookmarks variable. And call a weight fetch bookmarks. async await is going to resolve this promise. And then the second place we want to add this is to our add new bookmarks event handler. To basically handle this case, and make sure we're always using the most up to date set of bookmarks when destructuring. So we're gonna do current video bookmarks equals the weight, veg bookmarks. And also make this async. Awesome. So for right now, we finished everything we need for our content script file, obviously, things aren't going to show in the UI. And we could check that out right here. And as you can see, there's nothing in the UI because everything we've been doing so far has been manipulating the DOM right here to add the icon. Add some logic to get us ready to create a UI for our extension. Let's go ahead and start making some UI components show starting out with some bookmarks from clicking that addition button in the YouTube player that we added. Now, the first thing we need to figure out on any given page is if it's a YouTube video page or not, if it is, we're going on one of fetch any bookmarks we may have from Chrome Storage. And if it's not, we'll just want to display some messaging saying it's not a YouTube page. If you open the Chrome extension on a page that is not YouTube. So to do this, we're going to add a utility function that's going to allow us to decipher that logic. So we're actually going to grab our utility function to find the active tab that the user is on through Google Chrome documentation. I'm going to go ahead and use this example right here, which helps us retrieved a currently focused tab from the Chrome documentation. And since I have the google chrome pieces extension over every codeblock, whether it's in documentation or Stack Overflow, I'm able to directly save on pieces with this icon that shows up at the top right of any code block, I'm going to go ahead and save it. And then I'm going to go back to my VS code and refresh my pieces tree, I can go ahead and insert this snippet, which is the newest one, and I'm just going to rename this snippet to active tab Chrome. Amazing and pieces automatically classified this as JavaScript, because it was able to decipher that from some machine learning. I'm gonna go ahead and delete this background.js comment. And awesome, we now have a function that grabs the current tab. But also, I want to make sure I'm exporting this function. So I'm going to add export. And then what I want to do is open up the pop up.js file. And over here, we're going to want to import that function at the very top. So we can use it here. So I'm going to import Get active tab URL from utils dot j, s, and I actually don't think the documentation called it this. So I'm going to go ahead and change the function name, so it matches. So go to utils.js. Change that thought, awesome. Now, the event we want to listen to when opening the pop up.js file is the DOM content loaded event, which is right here. This event is a native window event that fires when an HTML document has initially been loaded. It's essentially when we want to load all our bookmarks and show them. So we're going to type the following to do so what we're going to do is grab our active tab function first. And we're going to look at the user's current active tab, which we already have the function for from in the utiles. It's an async function. So we're going to async await this. And then after that, we're going to grab the query parameters to help us identify the video. If you remember, each YouTube video has a unique identifier. After the question mark, where the query parameter, we're going to grab that, we're going to use a URL search params to be able to get the unique identifier for each video. And to get the unique identifier, we're going to create it current video variable and do URL parameters dot get V. And this is just based off of what the YouTube video URLs look like. Now, our active tab URL should have youtube.com/watch Because any specific YouTube video always has this in its URL. And we want to make sure we're watching a YouTube video when our Chrome Extension has any logic with bookmarks. And we want to make sure this current video variable is truthy meaning is get actually returned something other than undefined or any falsie value. And then what we want to do is we want to get any current video bookmarks from Chrome storage. If you remember, we're setting Chrome storage with the current video as a key and then all the bookmarks as a value that is JSON ified. And in order for us to retrieve those bookmarks, we need to use a Chrome Storage API to get them. So to do that, we're going to grab the video bookmarks using Chrome storage sync get. And we're going to get it with the current video unique identifier, which is the YouTube videos unique identifier in the URL. And then, we are going to set a current video bookmarks variable which is going to contain all those JSON ified current videos. And in order for us to pass this to any function or write some custom logic to show bookmarks, we're going to have to JSON dot parse any bookmarks that are saved in Chrome Storage since it's in JSON, and we can't really work with that. But if there are no bookmarks or chrome searches and return anything, we're just going to want to return an empty array. Now, we're going to have to pass this over to the view bookmarks function, which is basically going to help us view any bookmarks in our extension, that Chrome Storage dot get returns. But before that, I'm just going to put a comment right here. So we remember, we want to handle this else condition, which basically is for the scenario where we're not on a youtube.com video page, or current video returns a falsie value. So what we're going to want to do is add a message that says this is not a YouTube video page. And let's just go back to chrome to look at what that might look like. So this is our UI Currently, we have this container class right here that encapsulates and will eventually encapsulate all the bookmarks we have, it has this container class name in it, what we're going to want to do is get that class name. So we're just going to do this in the console before we actually do in code just to make sure it works. The class was called container. And that's just from the CSS in the boilerplate, so you don't have to worry about it, or the HTML or other. So when we wrote this document that get elements by class name container, and then grab the first element in the HTML collection, we get this element right here, which is containing all these other elements within it. And what we want to do here is basically specify in the HTML on pages that are not youtube.com. So this is actually a YouTube video page. We don't want to display this message. But I just want to show how this is going to look, we're going to want to put a new div class that says, This is not a YouTube video page. And let's just see if that works. Will this change the extension the way we want it to? Container is not. So what we need to do over here is actually encapsulate this in a variable. We're gonna set this equal to container. And now let's try that. And change the extension to show that this is not a YouTube video page. So the way we're going to do this dynamically in our code is basically put all the code we just put in our console to test this out within our else conditions. So every time we're not on a YouTube video page, or this returns a falsie value, we want to show that this is not a YouTube video page when we try to open up the Chrome extension in those scenarios. So we're gonna say const container equals document dot get elements by class name, right there. Grab that container class, first element. And then set the inner HTML, set that equal to div class equals title, title, just add some styling, that's going to make it look slightly nicer. There's nothing super special about the styling I have. And since we tested it, there shouldn't be really any surprises here, it should pretty much work as expected. So let's go ahead and give this extension a reload. It shouldn't show the message for this page. It doesn't. But if we go to a non YouTube page, it's gonna say this is not a YouTube video page. Amazing. So let's go back to our code. And we're going to want to write this view bookmarks function. So if it does meet the conditions of being on a youtube.com/watch page, and as you can see, that's from any page that has a video page, it has youtube.com/watch on it. And your URL params dot get the return something so it's a truthy value, we're going to want to view the bookmarks associated with that video. So let's go ahead and call the view bookmarks function and pass it all the current video bookmarks. And we're gonna go ahead and write the logic that's going to help us populate the UI with all the bookmarks we grabbed from Chrome Storage. So to do that, we're going to pass it current bookmarks. And we're going to set a default argument of an empty array just in case nothing is passed to it. It's just going To return or show no bookmarks, and we're going to grab a bookmark element. Again, this is just from the HTML that I have given you. So it's not anything you need to worry about. If you want to try this out on your own, you could try it out in the console. Just to save some time here, I'm just going to write the code here. And you can go ahead and copy it. But again, it's just knowing how to work with the DOM and inspecting the elements to figure out how to do this. What I'm doing right here is basically saying, Okay, if there are any bookmarks, let's just set it to nothing. So we're not displaying anything, we're going to reset the whole thing, since we're calling this function to view bookmarks. And we're going to have new bookmarks being passed in, which is the current bookmarks. And we're gonna say if the current bookmarks length is greater than zero, meaning if there are current bookmarks, and it's just not an empty array. Let's go ahead and iterate over all those bookmarks, and show them in our UI. So to do that, we're going to iterate over every bookmark in a loop. And then, we're going to grab the bookmark through indexing, so current bookmarks. With whatever iteration we are in the loop. And then what we're going to have to do from here is call another function, add new bookmark, which is going to add a new bookmark row to our pop up, I'm going to go ahead and remove this comment. And we're going to add a new bookmark, we're going to pass it the bookmark element up here, which is going to populate all our bookmarks, well, it's going to be where we add each of our rows. And I'm going to pass it each specific bookmark. So we're going to add one bookmark at a time and call this function every time we're adding a bookmark. But before that, what we want to do is if there are no bookmarks to show meaning, current bookmarks is just an empty array. We're going to want a message that says there are no bookmarks here. So we're going to set a message using italics. Saying no bookmarks. To show before we move on and add individual bookmarks to our pop up, let's go ahead and check if this condition works. Where there's no bookmarks to show and since we haven't added any bookmarks to this YouTube video that I'm looking at right now, it should work, I want to go ahead and reload my extension. Yep, there it is no bookmarks to show. Amazing. So now we're going to want to finally handle the case where we have bookmarks to show and this is going to allow us to start seeing bookmarks in our UI. So the first thing we're going to do is go to our add new bookmark function. And it's going to accept bookmark bookmarks element, and it's going to accept a bookmark. And then what we're going to do from here is we're going to create two elements. So one element is going to be for the title, which is going to display in the UI of each bookmark. And then one element is going to be the whole bookmark element that will contain the title will contain the delete button and will contain the play button. So let's go ahead and create the bookmark title element. And then after this one, we're also going to create the new bookmark element, which will encapsulate all these other elements that are part of a bookmark row. From here, for bookmark title element, we're going to want to display what the bookmark is and give it a title. So we actually already created the title. The title is the description of the bookmark. If you remember in our bookmark object, there's a timestamp and a description. So we're gonna set our text content to the description, which is bookmark dot description. And then our class name is going to be bookmark title element dot class name, and that will be set equal to bookmark title and this is just going to add some In CSS, that is already in our boilerplate code. Now for the general component that is going to encapsulate all the play button, the title, a delete button, anything else you might want to add, we're going to do a couple things, the first thing we're going to do is give it an ID of bookmark element, or bookmark with the bookmark time, and this is going to guarantee a unique ID for each element that is a row. So if you save any bookmark, what's gonna happen is there's going to be a row associated with each bookmark, which is our new bookmark element. And there's going to be an ID set for that row, which will be the bookmark along with the time and they'll help us uniquely identify any specific row in the UI. And that's later we're going to be used to delete elements when we're deleting a specific bookmark. And then we're going to set a class name, which was is going to help with some styling, that's going to be set to a bookmark class. And then we're going to set an attribute which is going to help us with playing a video. Because basically, we're going to want to know the timestamp of any specific bookmark. So when we play the video, we know where to set the video player at what time we want to send it out and the attribute of the bookmark element will help us find that. And the final things we want to do here is, since we know the new bookmark element is encapsulating all these other things, we want to append child bookmark title element, so it displays within the new bookmark element. And then we have this bookmarks element that is passed in. And we're going to append our new bookmark element, which is this element that's encapsulating all the other things. Inside that since it's a container. So now if we go back to our UI, and we give this a reload, just in case, let's just go to a new video. And if I press plus, in this video, we see a new row, it says bookmark out one hour, 54 minutes. And we could add another row if we want. And it gives us that same row, we're going to handle the case of the deletion, there's an ADD, it's just going to set at zero seconds. Bookmark it 000. Awesome. So that works. So now let's go back work on some additional functionality. Right now, we have no functionality associated with each bookmark yet, so we can't play any particular timestamped bookmark, we can't delete a bookmark. And the next thing we want to add is the play button. So to do this, we're going to add a play button to each bookmark that will go directly to this timestamp that we have saved for each video. To start off, we're going to have to add a function that is going to add an icon for a play button, listen for a click and call a function or event listener that will perform the logic to set a video at a particular timestamp. The function will end up looking something like what we're going to code right here in a second. And we're going to keep it super generic because it's going to be used for both our delete and play functionality. So the functions are going to take a source attribute an event listener. And it control parent element. And when we say control elements in our code, it means the play button, the delete button, we're just calling those control elements. So we're going to create a control element. And this is just one particular functionality, we're going to call a singular control element. So in this specific case, we're going to have a play button. But again, this is a generic function. So think of this as like a play button, a delete button we want this singular control element will be one of those. And then those control elements will be linked to a image in our assets folder. So if we want to play button, what we're going to link to is assets slash play dot PNG, and our schema super are predictable for this. So all we're going to do is assets plus SRC plus dot png. And there's definitely a better way of doing this, you can go back and work on the code after this video. But we're just going to keep it super simple for right now. We're going to give it a title that is the same as our source attribute, or what we pass in this source. So what's going to get passed in here is play, edit, delete, whatever. And the title will be set to that. So in this particular case, for play, it will be set as play, we're going to add a event listener. And that event listener will listen for a click. And we're going to pass it a function that is going to be performed on that clique. And the last thing we want to do is there's going to be a container for all control elements. And we're passing that in into this function. And we're calling it control parent element. So we're going to append this singular control element to the parent element. And the next thing we're going to want to do is add the function call that will add a play button, a title and our event listener to each individual bookmark. So in the add new bookmark function that we coded earlier, we're going to add a couple lines of code here. And these couple lines of code are going to add those control elements. So we're going to go ahead and create the element that's going to hold all our buttons, we're going to call it the controls element. And it's going to be a div just like these other ones, we're going to keep it super simple. And then what we want to do is give this some styling. We're going to add the class name, but controls, and you're just gonna have to trust me on this it exists. Then what we want to do is set our attributes using a set bookmark attributes function that we created, we're going to pass in play, the event listener is going to be called on Play. And we're going to code that later. And then we're going to pass in the controls element, which is going to be the parent element. And the last thing we want to do is append this to our new bookmark element. And what we should see now is, this play button is going to show up in our extension. So let's check this out. Let's give this a refresh over here. There we go. We have the play button in our extension. But what we're going to notice is it's actually not going to work. Let's go ahead and play this video. And we're going to try to get it back to 26 minutes, 51 seconds, it doesn't work. And the reason it doesn't work is we still need to code the On Play Event listener. So let's go ahead and do that. What we're going to do is we're going to target the timestamp attribute that we set earlier. So again, you could check this out in your console or inspect, if you want to get a visualization of how this is gonna work. But I'm gonna go ahead and type this for the sake of time. And we're gonna get that timestamp we set earlier. And then the second thing we're gonna want to do is grab the active tab, and that's just using the active tab function. This is an async await function. So we're going to have to async await it. And I'm going to add async to make this async function. So we've actually run into a problem now, we need to send the content script and message to manipulate the YouTube player to set it at the timestamp that the bookmark is placed on. So in this file, we're going to have to add that message. Let's go ahead and send a message to the content script. And this is going to follow the same pattern of how we did it with our background script. Missing comma there. We're going to have type of play. That's going to be our event type. And then the value is going to be bookmark time. And then in our content script, we're going to have to be able to read this message. So what we're going to do is add a condition to our On message listener here, and we're going to say if the type is play. Let's set the YouTube player time equal to the value that's passed in. So basically, let's just take a look at this for a second. If it's sending a message of type play, and the value is the bookmark time, then what we want to do is take that value and set it to the YouTube Players Current Time, which will make it the time of the bookmark. And let's go ahead and see if this works. I'm going to go ahead and reload my extension. And let's go ahead and go to the extension, we have a bookmark at 26 minutes, 51 seconds, it's currently at 48 minutes, 30 seconds. Let's hit that play button. It goes back to 26 minutes, 51 seconds. And now if we also hit this addition button anywhere in the video, we should get a new bookmark, we have two hours, 21 minutes, 22 seconds. Now let's go forward. Let's press play here. And it goes back to that time. Awesome. So now our Play button works. The last functionality we want to build is the ability to delete a bookmark, which will be super similar to what we did for the play button. The first thing we're going to want to do is go to our POP up.js file. And we're going to add the delete button to our controls element with the code in our add new bookmark function to set bookmark attributes. So let's go ahead and do that we're going to pass in delete our on delete event listener, and then the parent controls element. And since we set the undelete function as the event listener, we need to code some operations that are going to take care of our deletion. So we already know we're going to use this active tab that we used over here. So let's go ahead and already create this an async function ahead of time. Let's grab the user's active tab. And then what we're going to want to do is grab the timestamp attribute that we set earlier. And it's going to be the same code from up here. So I'm just going to copy and paste there we go. Then what we're going to also want to do is grab the element that we want to delete. So if you remember, I created a specific ID linked to timestamps, what we're going to want to do is grab elements by the ID so we can delete them. So bookmark. Plus the bookmark time will give us the element we want to delete. And then what we're going to do is delete that element by going to the parent node, and then removing the child which will be the element we want to delete. And then the final thing we're going to want to do here is send a message to our content script. Saying we want to perform a deletion type of delete, and then the value is going to be bookmark time. And there's one final thing we want to do here, this Send Message function from the Chrome's tabs API actually takes a callback function optionally. And we're going to pass one in which is going to be our view bookmarks function. And that's just going to refresh our bookmarks, so any deletions show up immediately, then in our content script, we're going to add another condition, which is basically you're going to ingest that Delete message. So we're going to say else if type equals Delete. The current video bookmarks will be equal to current video bookmarks. Filter, and we're going to filter by time. So the time is not equal to the value being passed in because that's a value we're deleting. And then the final thing we want to do is sync Chrome Storage. So if this page reloads, this deleted bookmark does not show up. We're going to JSON fi, error bookmarks and If that should work, the last thing we want to do is add a way to send the updated bookmarks back to our POP up.js file in order to display the most recent bookmarks, and we'll do the following. To do that, we're going to send a response of current video bookmarks. So now we can go ahead and try out deleting a bookmark with a reload of our extension, and it should start working. So I'm going to go back to our Chrome browser, reload our extension. And if we go ahead and delete a bookmark, we're gonna see that they're deleted. If we go ahead and add a bookmark, we're gonna see there's a new bookmark. It's at a different timestamp the YouTube players a different time. So if we play, it goes back to the timestamp of the bookmark. We want to delete again, it's going to delete. The last thing we're going to want to do is distribute our extension. However, I'm not going to quite go over that in this video, because Google gives great documentation that serves as a step by step guide on how to go about publishing your chrome extension to the Google web store for anyone to download. And with that, the videos over you know everything you have to do in order to create a modern web extension using manifest v3, and I'll see you next time.
