With timestamps:

00:00 - This course will prepare you for JavaScript interview questions, focusing on closures,
00:04 - functions, and currying. Throughout the course, you'll delve into various aspects of JavaScript,
00:10 - such as function declarations, expressions, scopes, and hoisting, as well as learning about
00:16 - advanced concepts like closures and lexical scope. You'll also gain a deeper understanding
00:22 - of currying and its practical applications in JavaScript. Roadside Coder created this course.
00:28 - He has created many popular courses both on our channel and his own channel. The course
00:33 - includes numerous interview style questions to help you solidify your understanding and prepare
00:39 - you for your next JavaScript interview. So get ready to gain the confidence and knowledge needed
00:45 - to tackle any JavaScript question on closures, functions, and currying that comes your way.
00:51 - This is the only video that you will need to know the most asked JavaScript interview questions
00:55 - on concepts like functions, closures, and even advanced concepts like currying.
01:00 - We will discuss different types of interview questions on hoisting, scope, call back,
01:05 - arrow function, lexical scoping, output based questions, partial application, polyfills,
01:10 - and much much more. So fasten your seat belt because in the world of JavaScript,
01:14 - the only thing worse than a syntax error is a silent error. That breaks your code without even
01:19 - telling you why or where it happened. And also if you happen to like this video and if you're
01:24 - interested to watch more such interview videos, you can check out my channel Roadside Coder,
01:28 - where I've made a complete playlist on JavaScript and React.js interview questions which has helped
01:33 - hundreds of thousands of developers to crack interviews. Link to my channel will be in the
01:37 - description down below. So let's start by basic questions first, which are mostly asked in
01:42 - entry level JavaScript interviews. So I've opened VS Code over here with HTML, CSS, and JavaScript
01:47 - file. And the first question is what is function declaration? So function declaration is nothing,
01:52 - but when we declare a function like this, so let's say function, and a square, and we give this a
02:00 - number, and this returns us anything. Let's say, so this is a normal function declaration. So this
02:09 - can also be called function definition or function statement. So next question is what is function
02:14 - expression? So when you store a function inside of a variable, it's called a function expression.
02:20 - So let's say const square, and instead of it, if I add a function with no name, this will become
02:30 - an function expression. That's it. Now an add on to this question can be what is this called?
02:38 - So you see this function doesn't have a name, but we are giving this a name by assigning this to a
02:43 - variable. But this part in itself, what is this called? This is called an anonymous function,
02:50 - which is which the function which has no name. And this anonymous function can be assigned to a
02:55 - variable or can be passed as a callback, maybe what is called back, you ask, we will discuss that
03:00 - in this video as we go forward. Now these function expressions can also be called like just like
03:05 - a normal function is called like this. And we need to console log this as well. And need to pass a
03:13 - number. Let's say five. And let's see. Yep, we get 25 over here. So a function declaration
03:19 - function expressions are kind of same. Just the difference is function expressions are assigned
03:24 - to a variable. The next question is what are first class functions? Now first, well, let's
03:29 - understand what does this first class functions mean? So in a language where a function can be
03:35 - treated like a variable, their functions are called first class functions. In these cases,
03:40 - functions can be passed into another functions can be used manipulated and returned from those
03:45 - functions. And basically, everything that a variable can do a function can also do. So this is why
03:51 - we call functions as first class function in JavaScript. So let me show you an example. So let's
03:55 - say we have the same function function square. And we have another function, which is called
04:01 - display square, which takes a function and returns. Or let's say just console logs that function
04:15 - with a message, which is square is this. So we can call this function display square
04:25 - with this square function. So we can pass this function inside of this parenthesis over here.
04:31 - And I'm going to pass five over here. Let's see. Yep. So we get this output square is 25. So you
04:39 - understand how powerful functions are in JavaScript that we can pass them inside of another function
04:44 - just like a variable. And we can also manipulate and return them from that function. So this is
04:50 - called first class function. This is a very important interview question. Now the next question is what
04:55 - is if he now this is not that much of a frequently asked question, but you should be aware of what
05:00 - and if he is. So if he means immediately invoked function expressions, what do I mean by that?
05:07 - Let's see. So we have our square function over here. So when we need to call this square function,
05:13 - we need to do this square. And then we pass any parameter if you want. And then it is successfully.
05:20 - Oops. Wait, let me instead of returning this, let me console log this over here.
05:28 - Yeah. So when we call this, this is successfully invoked, just like that, cool. But what an
05:33 - immediately invoked function expression does is we don't need this. What we can do? We can
05:39 - wrap this in a parenthesis, and we can call it right away right over here. We can pass
05:46 - argument over here as well. And you're going to see that our function is still
05:51 - called. So this is a immediately invoked function expression. Now the interview may not ask you
05:57 - exactly what if he is, but they can definitely give you an output based question based on if he.
06:02 - So let's check out one output based question. So interview can give you a question like this.
06:07 - So what is this? Let's understand. So this is an iffy. And it has another function inside of this,
06:12 - which is also an iffy. So here we are executing this function by passing this argument one over
06:18 - here. Okay, we pass the argument one. And then in the inner function, we are passing two,
06:23 - but we're not using anywhere, but we're just console logging X. And what do you think will
06:27 - be the output of this question? Now a lot of people think that this will give us undefined
06:32 - because X is not defined in this scope. But no, it will give us the output of one. So let's see.
06:42 - Yep, you see, it gave us the output of one, because it's going to search X in this inner
06:48 - scope first. And when it doesn't find this X over here, it's going to search in its parent's scope.
06:54 - And in the parent's scope, X exists. And this happens because of closure. If you don't know
07:00 - what closure is, don't worry. We will have an entirely separate video where we discuss some
07:04 - interview questions related to it. And that video will be dropping next. So subscribe if you have
07:09 - it yet. For now, you can understand this, the ability of a function to access variables and
07:14 - functions that are lexically out of its scope are called closures. So closures are created
07:20 - whenever a new function is created, because that function has the reference to its outer scope.
07:26 - Okay, so let's try and understand more about function scopes. So I've opened the official
07:30 - MDN docs for function scope in JavaScript. And we can use their example to understand how
07:35 - exactly function scope works. So let me copy this up and paste it over here. So you can see that we
07:41 - have three variables defined over here. First is num one num two and then name. So when we call
07:47 - this multiply function, what's going to happen is it's going to take num one and num two from
07:52 - the global scope, because these are defined in the global scope and not inside of this function.
07:58 - If there was a copy of these variables inside of this function, it would have taken that one.
08:02 - So let us move to the other example where we have this case. So we have this get score function
08:08 - over here, where we have num one and num two as two and three. But keep in mind, we have both
08:15 - of those variables in our global scope as well. But these will shadow the global scope variable.
08:21 - So if you don't know how where let in const works, I've made a complete video on this topic and I've
08:27 - explained this shadowing concept as well in that video. So you can click the link in the description
08:31 - to watch that video. Now, inside of this function, when this add function is run, it's going to take
08:37 - the name from the global scope. And the num one and num two will be taken from the local scope.
08:44 - And it's going to return as the output roadside coders code five. So let's see. Also, I'll provide
08:49 - you the link to this page in the description below. Now you see first returned as 60, which was
08:54 - multiplication of these two 20 and 30. And a second one returned as five with a global variable as
09:02 - well. So this was a basic example of a function scope. And you can use this example to explain
09:07 - function scope in your interviews. Now let's discuss an output based question on function scope.
09:12 - So we have this for loop over here. Inside of this, we have this set timeout, which console logs one.
09:20 - And it has a delay of I into 1000 milliseconds. What do you think the output is going to be?
09:27 - The interviewer can ask what the output for this code is going to be. So now, since we have this
09:32 - let I over here. So every time this for loop runs, it creates another block scope for this function.
09:39 - So the first time it's going to be zero, then one, then two, then three, then four, then five.
09:44 - But if it was where over here, then where doesn't have a block scope, then where would have printed
09:51 - five, five, five, five, five, five. So let me show you. In this case, we get five, five, five, five,
09:59 - five, because we have where over here. But if we change this to let, since let has the block
10:04 - scope, it's going to print one zero, one, two, three, four. Now again, to understand this question
10:09 - properly, you need to understand how let where and const works, which I have explained in my
10:14 - another video, which you can go and watch by clicking the link in the description. So let's move on
10:18 - to hosting now. So you might remember that I've explained hosting in our where let const video
10:24 - on how variables are hosted on top of our code before our code is executed, and how our code is
10:30 - first initialized, and then it's executed. So functions are hosted a bit differently than a normal
10:36 - variable does. Now when we have a function like this, and we call it over here, and when we run
10:41 - this, you're gonna see this works absolutely fine. But what will happen if we run this before the
10:49 - function is declared, it still runs the same. It's because functions are hosted completely.
10:56 - So what's what happens when a variable is hosted? So let's say if we have a variable
11:03 - x equals five. And when we log this, we're gonna get the output as five. But when we log this before
11:14 - this is even declared, then obviously, we're gonna get the undefined, because of hoisting.
11:22 - But in function, that is not the case. So let me show you, if we go to sources, let me put this
11:33 - right over here. And now when we put a breakpoint over here, and run this, yup, inside of our global
11:45 - scope, you're gonna see, we will have a variable of x, which is not defined. But obviously, this
11:50 - is hosted. So if we go down, we're gonna see we have this variable hosted as undefined. But in
11:56 - functions, in the case of function, the complete function is copied to the scope. So if we go up
12:04 - over here, we're gonna see, we have this function name with complete function copied to our scope.
12:13 - So hoisting works a little differently in case of functions. We don't have function name as
12:19 - undefined, we have the complete functions. So it doesn't matter if you call the function before or
12:23 - after declaring it, it's still going to work. So this was our global scope, right? Inside of a
12:29 - function, we have the function scope. And this that work exactly like global scope does. So instead
12:36 - of global, we have a function scope. So let's say if we have this variable defined inside of this
12:41 - function over here, and we console log it before it, it's still going to work the same. So let me
12:50 - show you, if I put a console log over here, and refresh, you're gonna see inside of this local
12:58 - scope, we still have x undefined, because it was hosted on top of this function. So don't worry,
13:05 - I'm gonna discuss an output based question, which is going to clear on how interviews can ask you
13:09 - these type of tricky concepts and understand if you have the knowledge for the same. So if you put
13:14 - a debugger over here and move forward, now you're gonna see x has five, because obviously x is
13:20 - defined now. All right, pause. If you're not yet following me on Twitter, go to
13:25 - reader.com slash pewsh underscore on or click the link in the description down below and hit that
13:30 - follow button right now. I'm waiting for you. I'm still waiting. Okay, fine, let's continue with
13:38 - the video. So we have an output based question over here on function hosting. So I need you to
13:43 - think about it before answering it, because this is a tricky one. So we have a var x as 21 over here,
13:50 - we have a function expression defined over here, and then we are calling that function expression.
13:54 - So what do you think? What is going to be the value of x over here? Is it going to be the local
13:59 - variable? Or is it going to be the global variable? A lot of us, we will think that obviously it's
14:05 - going to be local variable, right? Because this is how this works, we will take the local variable,
14:11 - because the local variable will shadow the global variable. Okay, fine. But a lot of people will
14:16 - think, no, this is not defined at this moment. This is defined after that, right? So this is
14:22 - obviously take the variable from the global scope. Okay, that makes sense as well. But let's see
14:27 - what is going to be the output for this. It's going to be undefined. Why? Why is this undefined?
14:33 - Let's see, let's go to our sources, inside of our script, yes, and here, let's run this.
14:42 - So we have this global scope, right? In our global scope, we have x right over here,
14:50 - x as 21. But inside of our local scope, we have x already present. So if you remember in our
14:56 - var let const video, I explained hosting is a two step process. First, it initializes the complete
15:02 - code. So it's gonna initialize the global scope, then it's gonna come to the local scope, and then
15:08 - it's going to initialize the local scope as well. And when it initialize the local scope,
15:12 - it's gonna first host this variable on top of this scope. So in this scope, the x is present
15:19 - and is undefined right now. So we will not take 21 or 20, we will take the x in this current
15:26 - scope, because obviously x is not being initialized at this moment. So when I put a debugger over here
15:32 - and press next, now you're gonna see we have x as 20. So keep this in mind, when we have a
15:38 - variable present in a scope, we will not go and check the global scope, we will always refer to
15:44 - the current scope. So our next question is params versus arguments. So this is one topic that
15:50 - confuses a lot of people, which of these is called params and which of these is called the argument.
15:55 - So when we have a function like this declared over here, and when we call the function,
15:59 - the values that we pass inside of here are called arguments. So these are arguments.
16:09 - And when we receive those values inside of our function, this is called params,
16:15 - or parameters. So these are called params, and this is called the argument. Pretty simple, isn't it?
16:23 - Now individuals can ask a confusing output based question on this topic as well. I'm going to
16:28 - discuss another bonus topic in this video, which is spread versus rest operators. So let's say we
16:35 - have a function called multiply, and we have number, we call this like this. All right, so
16:45 - what is spread operator when we let's say we have an array over here, let's say five comma six,
16:52 - and we want to pass both of these values to this function, we're going to what we're going to do,
16:59 - we're going to use these three dots and a so it's going to spread both of these values and pass
17:04 - it to this function. So now you're going to see that this runs just like that, and it gives us
17:09 - the output 30. And similarly, when we're passing this to this function, we can also receive it like
17:14 - this, let's say numbs. And let's just console log numbs for now, you're going to see that we
17:23 - receive five comma six. So here when we use this operator, this is called spread operator. And
17:28 - here when we use this operator, this is called rest operator. So I can probably do something like
17:33 - num of zero into numbs of one, and it's going to give us the same output. Yep, just like that.
17:41 - So let's discuss a tricky output based question on this. So let's say the interviewer gave us
17:46 - this code snippet and asked us what is going to be the output for this. So when we run this,
17:52 - so let's see the output rest parameter must be the last formal parameter. So you see,
18:00 - we combined params arguments and rest operator concepts. And we have this question over here.
18:05 - So when we use rest operator or spread operator, it should always be the last one. So just like
18:14 - this. So what this will do is it will take all of these three values. So let me add more values
18:19 - over here, comma eight comma nine. So this will take a x a x y as five six three, and the numbers
18:29 - will take the remaining value. So that's why we add it at the last of our list of parameters,
18:34 - so that it takes all of the remaining arguments. So if I say numbers,
18:40 - and now you're going to see it runs properly up six three and seven eight nine. So six three
18:46 - and seven eight nine which were the remaining arguments. Great. So I know this was a little tricky
18:51 - one if you're not aware of rest operator or spread operators, but it's fine. You're going to get
18:56 - good with time as you use this rest operator spread operators in your projects and in your apps.
19:01 - So the next question is, what is a callback function? So actually, we have already seen this
19:06 - in our first class function topic. So let me go to the official Mozilla documentation.
19:13 - And here in the definition, you can see a callback function is a function passed into another
19:18 - function as an argument, which is then invoked inside the outer function to complete some kind
19:23 - of routine or action. So as I mentioned, functions are first class function in JavaScript. So when
19:30 - we have a function like this, and a function like this, we are passing this greeting inside of this
19:36 - function, and it's taking this greeting callback. So this greeting is what a callback function is.
19:44 - So as the name suggests, the function says that you can call me back whenever you like. So the
19:49 - function is sending itself to this function, and it is calling it inside of this other function.
19:56 - So this is exactly what a callback function is all about. Now, into work can ask you question,
20:02 - like, can you give us an example on what a callback function is? So you can give that example.
20:08 - And also, you can give the example inside of the JavaScript predefined functions, which are
20:13 - something like set timeout map filter reduce. So let me give you an example, something like when
20:19 - we use event listeners, so document add event listener, this takes two things. It takes the event,
20:28 - which let's say click event, and then it takes a callback over here, just like that. So this is
20:33 - what a callback is when we are passing a function inside of another function, and then this function
20:38 - is manipulated inside of this one. So it can be event listeners, it can be function like map,
20:45 - filter reduce, or set timeout. So if you don't know, I've made up actually made up another video on
20:50 - map filter reduce as well, which is our previous video, you can click the link in the description
20:54 - to understand these topics thoroughly. Now last but not the least, we have arrow functions. Now,
21:00 - what are arrow functions? So arrow functions were introduced in ES six version of JavaScript,
21:06 - and they were kind of like similar to a normal function, but in some ways, they work differently.
21:11 - So let me show you, if you see a normal function, its syntax looks something like this. So we have
21:17 - a function called add over here, in which we takes two parameters and return some value.
21:23 - So what are we going to do if we need to convert this function into an arrow function? So we just
21:28 - need to get rid of this function keyword, and we need to add an arrow over here. And that's it.
21:34 - We're done. That is what an arrow function is. It has a bit more clean syntax. And actually,
21:39 - we can get rid of these curly braces as well, since this is returning only one line, and we can
21:44 - get rid of this return as well over here. So yep, you can see this syntax looks much cleaner than
21:50 - the previous syntax. But when we use the curly braces, we do need to use return or, I mean,
21:55 - according to our requirements. So let's discuss some of the differences between arrow function
22:00 - and a normal function, because this is a really important interview question. So the first one
22:05 - is what we have already discussed is the syntax. So the syntax of a normal function looks something
22:10 - like this with the function keyword. But the syntax of an arrow function looks something like this,
22:16 - with this arrow operator. Okay. Now the second difference, the implicit return keyword. So I've
22:24 - already showed you that in a normal function, we can use return like this. But in an arrow function,
22:29 - we can do something like we can get rid of return function. If this is a one liner, and we can
22:36 - write something like this. Third point would be is the arguments keyword. So if let me show you,
22:43 - so if we have a function inside of this with let's say we have, we don't have any parameters,
22:50 - and we just console log arguments over here. Now if I call this function
22:55 - with one, comma, two, comma, whatever. So then we're gonna see, oops, a square has already been
23:06 - declared, let me is this names. Okay, now you're gonna see we get this arguments with all of these
23:12 - arguments. So we didn't even pass the perimeter over here, but we got all of the arguments just
23:17 - like this. But can we do this in arrow function? Let's see, function keyword, and make it arrow
23:25 - function. Now, let's see, you're gonna get the output arguments is not defined. So you cannot
23:30 - have the arguments keyword inside of an arrow function. Okay, let's comment this out as well.
23:37 - Now the fourth point will be the this keyword. How does this keyword perform with normal function
23:44 - and the arrow function? Now, obviously, if you don't know what this keyword is, don't worry,
23:48 - I'll create another separate video on this topic. So let me have a question over here,
23:55 - which can be considered as an output based question. So introvert can give you something
23:59 - like this. So inside this object, we have a username, and we have two functions over here.
24:06 - First function is an arrow function, and second function is a regular function. So let's see how
24:11 - both of these performed. I have called both of these functions over here. And let's see the output.
24:16 - So the first arrow function gives a subscribe to an undefined, but the second regular function
24:22 - gives a subscribe to roadside coder. It's because this here is pointing to this object. But this
24:29 - instead of this function is pointing to the global object. So I know if you don't have the proper
24:35 - knowledge of this keyword, it's hard to understand right now. But don't worry, I will come up with
24:40 - a separate video for this keyword. So yeah, these were the major four differences between
24:45 - arrow function and a regular function. Now there can be more differences as well, like
24:49 - how the constructor is defined inside of both of these. But that would be a little advanced topic
24:55 - for this video. So I would highly recommend you to go and read more about it. And if you
24:58 - haven't access the complete playlist for our JavaScript interview series, you can go to youtube.com
25:03 - slash roadside coder. And here inside the playlists, you're gonna find the complete playlist here in
25:10 - this playlist tab section. Alright, now let's move on to our next topic, which is on closures.
25:16 - Closures is the most important topic for JavaScript interviews. And there can be literally hundreds
25:21 - of questions that can be made on it. That's why after hundreds of years of research, I have curated
25:26 - some of the most asked interview questions on closure for this video. Just kidding, I haven't
25:31 - researched for that long, but it's gonna be good. So a closure is a function that references
25:36 - variables in the outer scope from its inner scope. To understand the concept of closures,
25:41 - you need to know how the lexical scoping works first. So I've opened VS code over here with basic
25:47 - HTML CSS and JavaScript files. So what is lexical scope? So a scope refers to the current context
25:53 - of your code. It can be either globally or locally defined. And with the six version of
25:59 - JavaScript, we also have the block scope as we discussed in our where let cons to video. So
26:04 - let's see. So since we have a variable right over here, this variable, this is in the global
26:10 - scope. Right. But what if we go on and create a function over here? Let's call it local.
26:18 - And so this right here is the local scope.
26:21 - And this is the global scope. But what exactly is the lexical scope? So a lexical scope in
26:31 - JavaScript means that a variable defined outside a function can be accessible inside of another
26:36 - function defined after a variable declaration. But the opposite is not true. The variable defined
26:42 - inside the function will not be accessible outside that function. So let's see an example. So if I
26:47 - console log this name over here, let's call it username. Yeah. So let's go on and run this. Here's
26:55 - a browser. Let's go to inspect. Oops, we are not calling this function any right now. So yeah,
27:03 - now let's see. Yep, you see, we get this output roadside code over here, because the variable defined
27:09 - outside of this function can be accessible inside of this function. This is called lexical scope.
27:13 - But what if we do this? If we take this line and put it over here and try to take this console log
27:22 - outside of this function, will this still work? Let's see. No, this is going to give us the
27:28 - error username is not defined. So we cannot access the variables from inside of the function. We can
27:34 - only access the variables that are outside of this local scope. So let's see another example
27:39 - over here. So we have this function subscribe over here, which we are calling after it. And we
27:45 - have another function display name, which we are calling inside of this function. So you see,
27:50 - we have multiple scopes over here. So let's call it inner scope. We call it inner scope
27:58 - two. And then there is this global scope. Right. So we have three scopes over here. So what's
28:04 - going to happen is when we call this subscribe function over here, it's going to initialize this
28:09 - function with this name roadside coder. And when we go inside of this function, this will be still
28:15 - accessible inside of this function, because it's outside of this local scope. Right. So we will
28:21 - be able to print this name. So let's see. Yep, you see, it's printed over here. So this thing
28:27 - exactly right here is what a closure is the display name is called a closure. I know you
28:34 - might be a little confused right now, but let's go on and understand closures in depth. Also,
28:38 - if you would like to get in depth knowledge about JavaScript functions, you can go and
28:43 - check out my previous video, which was completely on functions, where we discussed all of the interview
28:48 - questions related to the functions in JavaScript. All right, so let's go to the Google and search
28:54 - closures. And we get this MD and docs over here. And according to this documentation,
29:01 - a closure is a combination of a function bundled together with references to its surrounding state,
29:07 - or the lexical environment that we just discussed. In other words, a closure gives you the access
29:12 - to an outer function scope from an inner function. So as we saw in this code, that this function
29:19 - was able to access the variable outside of this scope. So this is what a closure exactly is.
29:25 - In JavaScript, closures are created every time a function is created. So you can see right here,
29:30 - this is the example that we discussed. So if you scroll further down, they've given us another
29:35 - example. So let me just copy this up and paste it right here. So what's going on over here? Let's
29:42 - see. Instead of this alert, I'm just gonna put console log over here. Yeah, so here we have defined
29:48 - this local variable name. And instead of this, we have this function in our function called
29:53 - display name. And we are returning this display name over here. So what we're doing is we are
29:59 - calling this make function over here. And we're taking whatever that it's returning us. So it is
30:04 - it is returning us the display name. So now this gives us a function which we can call any time we
30:09 - want this is the inner function of this make function. So we can go on and call this and it's
30:14 - gonna execute this function right here. And it's still going to access its outer variable of Mozilla.
30:20 - So if you go to the browser and see, yeah, you see, Mozilla is printed right here.
30:26 - And in some of the language, you won't see this type of code working. But in JavaScript,
30:31 - this works in JavaScript, every time we create a new function, it binds itself to its environment
30:37 - or its lexical scope. So doesn't matter if you call this one directly over here,
30:42 - or if you return it from this function, it's still going to have the access to its parent scope of
30:48 - this or or let's say global scope. So it's still going to have the access to the lexical scope of
30:53 - its parents. So you must be thinking what's the use of this syntax. So closures makes it possible
30:59 - for a function to have private variables. JavaScript closure is used to control what is and isn't in
31:06 - the scope of a particular function, along with which variables are shared between sibling functions
31:10 - in the same containing scope. So if I create another function right here, with some another name and
31:16 - return that one as well. So that will also have the access to the scope of this function. So actually,
31:21 - we will discuss all of these questions and concepts as we move forward in this video,
31:24 - I just want to make sure that your basics are cleared at this moment first. So we're going to
31:28 - start one by one. Also, if you want to call this function display name, we can also do this. So
31:35 - let me remove this up. We're calling this function and inside of this sense, this is this returns
31:42 - us another function, we can do this right over here. So this returns us the display name. And then
31:49 - we are calling the display name right over here, just like that. So actually, we can pass anything
31:53 - inside of here as well. So let's see first this works or not. Yep, this works as expected. So let
31:58 - me pass number five over here. And let's receive num. And I'm gonna print num. So yep, you see
32:08 - number five is also printed over here. So this just works just like a normal function. But we have
32:13 - much more power because of this JavaScript closures on our scope. Okay, so that were the basics of
32:19 - closures. But you might have heard of this term called closure scope chain. Let's see,
32:24 - let's go to the documentation again, and see what this thing is. So right here. So according to this,
32:32 - every closure has three scopes as we already discussed, a local scope. That is, this one,
32:38 - the outer function scope, that is this one, the outer function scope, and then the global scope.
32:44 - So it has three scopes right here. So a lot of people think that, okay, this function will only
32:50 - have the access to its outer scope and not the scope of the parent. What scope chain means is,
32:56 - it's going to have the access to its outer scope as well. And the scope of its parent. So if I go
33:02 - on and say, where user name and give it a value and use this right over here, then you're gonna see,
33:16 - we still get the output because it has the access to all of the scopes of its parent scope and the
33:22 - scope of its parent's parent. So this is what a scope chain is. Let's see what example they've
33:28 - given us to explain it. So as you can see right here, they have given us this example with a lot
33:33 - of local scopes in here. So let's paste it. Okay, so as you can see, we have this function here,
33:42 - and then we have another function nested, then we have another function nested, and we have this
33:47 - sum at the top. So we're calling this sum with one, right, so it's going to give this a one.
33:53 - And then another inside of this, we have another function return. Okay, so this will return B.
33:58 - Now we're supposed to call B over here. So then we are calling B with this parenthesis,
34:03 - and we're supplying the value of two to B. Also, sorry, the name of function is not B.
34:09 - The name of parameter is B. The function is an anonymous function. Right. So after that,
34:14 - it's returning us another anonymous function. This will be returned over here. So now we're
34:19 - going to call it again with value three. So it's going to have three. And so on, it's going to
34:24 - return another function. So we're calling it with this function four. And now notice what happens.
34:30 - Inside of it, we're returning a B C D E. So this function right here will have the access to all
34:38 - of the scopes outside of it. So scope where we have C value, B value, a value, and the global
34:45 - scope where we have E value. So it's going to be able to access all of them. It's going to log
34:50 - us 20. So let's find out. Yep, just like that. So this is what a closure scope chain is all about.
34:58 - Now they've given a bunch of more examples. I would highly recommend you to go and read more
35:03 - about closure and closure scope chain from this documentation. It's going to really help you
35:08 - become good in this topic. Okay, so let's go on and discuss some of the most asked interview
35:13 - questions on closures. We're going to start from the very basics and go to the advanced level
35:17 - questions. So as you can see right here, we're given a variable, let count equals zero. And after
35:23 - that, we have an iffy over here. So if you don't know about what and if he is, you can go and watch
35:27 - our previous video on functions, they're I've explained what and if he is and so we have a
35:33 - function over here called print count. And so this we have this conditional. And we're supposed to
35:38 - tell that what this will console log and what this will console log. So okay, we have count
35:43 - equals zero. So obviously it's going to take count equals zero inside this function as we learned
35:48 - up until this video because of its lexical environment or lexical scope. But we have a problem over
35:53 - here. We have another count equals one over here. Well, this is confusing. What will we print
35:59 - inside of this count then will be print count equals one or count equals zero. Okay, so let's
36:04 - see. So this is checking if count is equals to zero, which yep, it at this point, it is zero.
36:09 - So we're going to go inside of this. Then we're saying that let count equals one. Now this concept
36:15 - right here, this is called shadowing. And I've explained this concept in our where let const
36:22 - video that this is a block scope right here. And this variable is going to shadow this variable
36:28 - from outside. So this is going to overlap the value of count with one. And it's going to print
36:33 - one over here. But outside of this, keep in mind, this is inside of this block only.
36:38 - It's not going to affect the environment outside of it. So outside of it, count is still zero. So
36:45 - count is still zero at this point. So this will print zero. It will not be affected by this let
36:53 - count equals one. So let's see the output. Yeah, you see, first one gave us one and the other one
36:59 - gave us zero. So interviewers give us questions like this to understand if the candidate is aware
37:05 - of concepts like block scope or shadowing or not. Okay, so the next question is to write a function
37:11 - that would allow you to do this. Okay, so what's going on over here, we are calling this create
37:16 - base function with certain value. And it is returning us a closure called add six. And then
37:23 - we're calling this add six closure. And whichever value that we pass inside of it, it returns us
37:29 - by adding the value that was written over here. So if we did 10, so 10 plus six, 16, 21 plus six,
37:35 - 27. Okay, so how are we going to do that? What we learned up until now, this is obviously going
37:40 - to be a closure, which will be returned from this create base function. So let's create this
37:45 - create base function first. So create base, and it's going to take a number. Cool.
37:53 - Now from inside of this, we are supposed to return a function. So let's return a function,
38:00 - which I'm going to keep as anonymous function. And this I'm going to give, let's say inner num.
38:09 - And so inside of this, what we're supposed to do, we're supposed to add inner num to this num.
38:14 - So we're gonna return inner num plus num. And obviously, since this is a closure,
38:22 - so num will be accessible inside of this function. So let's see if this works or not.
38:27 - Oh, I think I should console log this. Or maybe I think I should console log this.
38:35 - And put this inside of here. Yep. Let's see. Okay, we got this output 16 and 27. So what's
38:44 - happening over here is we have taken this create base as six. And we have created a local scope
38:50 - for both of these function calls. So we just have to do this once. And this will be initialized
38:55 - with a scope where num is six. Now doesn't matter what we pass inside of over here. If we pass 15
39:02 - over here, it's still going to add six to it, just like that. So what's happening over here is you
39:07 - can create a closure to keep the value passed to a function create base even after the inner
39:12 - function is returned. So if we don't want this value to change, then we can create a closure
39:17 - where this value is always six. We just have to pass it once. And it's going to access the value
39:22 - as only six. So this is also one of the use case of closures, which makes it so powerful. Okay,
39:28 - so this question right here is kind of similar to the previous question. But it's a little add
39:32 - on to that. How can we use closures to optimize the time of our code? So interviewer has given us
39:38 - this find function. When we call this find function right here, by the way, just ignore this console.
39:43 - Time for now, I've just added this to measure how much time does this function call takes.
39:48 - Okay, so first we're calling this find function with this six value. Okay, so it takes the six
39:53 - value right here. And it has the empty array. And what it's doing over here, we have a really long
39:59 - loop, which runs one million times. And what it's doing over his, it's assigning the value of i into
40:05 - i to each of the index of this array. Okay, that's fine. So this is being done to make this loop
40:11 - really slow. And then we are console logging the index, whatever index that we provide. So if we
40:15 - have provided the six index, so we're just supposed to print that. Okay, so let's save this and check
40:20 - this out. Okay, so you can see right here, it gives us this output, but it's taking this six
40:25 - millisecond right here. And the other call takes 12 milliseconds. If we put even higher number over
40:31 - here, let's say 50. So it's taking 135 millisecond right here. Sorry, I said six earlier, but it's
40:39 - 67 milliseconds for this one. And this is 135 milliseconds for this one. So how can we optimize
40:45 - this by using closures? So just like what we did in our previous since we are not touching this
40:50 - value anytime, right? We this value is the same for each and every time we call this function.
40:56 - So let's create a function right here. And anonymous function, which will take this console log
41:04 - inside of it, instead of passing this index over there, we're gonna pass this index over here. So
41:11 - let's do this, let's create const closure, which will have this find right here. So we have just
41:20 - created a inner function closure for us. So that this remains the same for every time we call this
41:26 - closure right here. So now I'm going to replace this with this closure. And this is 50 right here.
41:33 - So I'm going to put 50 so we can recognize this. Okay, so let's see what has changed. Okay, there's
41:41 - a huge change right here. So for six, I think it was 67 earlier, but now it's 0.25 milliseconds.
41:48 - There's a huge time optimization of this code. And for 50, it was I think 135 something, but
41:54 - now it's 0.025. So you see how closure has helped us in optimizing the time for our code. So this
42:00 - is the reason why closure is such an important topic and such a favorite topic of interviewers.
42:06 - So let's move on to our fourth question, which is on block scope and set time out with closures.
42:11 - So this question is really, really important. And this question is asked in a lot of companies.
42:15 - I've already discussed this question in my unacademy interview experience video. So I'm going to go on
42:19 - and play that clip for you right here. So the interview provided me with this code snippet.
42:23 - And obviously we're going to run this over here. So he asked me what is going to be the output for
42:28 - this. So let's think about it. Most people will think that since we are console logging over here,
42:35 - we are running a loop over here for loop. And we are console logging each of these values inside
42:40 - of over here after one second each. So most people will think that the output is going to be this 0,
42:46 - 1, 2, is it? Let's find out.
42:50 - It is three, three times. Let's refresh the page. So three, three, and three after one
42:59 - second each. So why is this happening? This is because of where. So what where does this we just
43:05 - discussed in our previous question. So where doesn't have a block scoped where has a function
43:11 - scoped. So what's happening over here is, first time this runs, where's value is 0. But this is
43:19 - not going to be printed right away, because set time out only runs after the complete code has
43:24 - ran successfully. Right. So this is not going to run. So we have a reference to that I variable
43:30 - in our memory. So we have a reference over here, let's say, okay, then again, the I is one,
43:37 - then we again have a reference to the I variable, just like that. And then I is two,
43:43 - then we again have a reference to I variable. And then the third time the value of I is three.
43:48 - But if we obviously, we won't go inside of over here, since it says that I has to be less than three.
43:53 - So we're not going to run inside of it, we come out of this loop. And then set time out has finished
43:59 - its time. And now our JS engine is going to print all of these values. So last time the JS engine
44:06 - encountered the value of I, it was three. Now here, JS engine is referring to the current value of I.
44:12 - So the current value of I was three. So it's going to print three, three, and three, just like that. Now
44:19 - what's the solution for this? You may have guessed it right. The solution for this is using let
44:26 - instead of where? Let's see the output. 012. Yes. So what's happening over here is let is
44:34 - block scoped. So first of all, let's value was zero. So it has the completely different scope. So
44:41 - in this scope, the value of I was zero. So it's going to print it later on. Then again,
44:48 - the second value of I was one. So again, after the complete code has ran successfully,
44:55 - it's going to look into the scope of that I variable. And when it looks into all the three
45:00 - scopes, it's going to find zero one and two. So this is the logic behind this question.
45:05 - So actually, this was the follower question that the interviewer asked. I just explained it to you
45:10 - in one go. So these were two different questions that the interviewer asked. The interviewer asked
45:13 - first to tell him the output of the first with where and then he asked me how we can print 012.
45:19 - So then I went on and explained him with let. So this was the question. But few of the interviewers
45:25 - extend this question even more. They're going to say you're not allowed to use let. You're going
45:30 - to have to use where instead of let and you have to print 012. You have to give this output.
45:38 - How are we going to do that? So this is a task for you all. I'm going to give you a small hint.
45:43 - It's going to use closures. All right, pause. If you're not yet following me on Twitter,
45:48 - go to Twitter.com slash pewsh underscore on or click the link in the description down below
45:53 - and hit that follow button right now. I'm waiting for you. I'm still waiting. Okay, fine. Let's
46:01 - continue with the video. Okay. So in the end of that clip, I asked you a question that how will you
46:06 - do this just by using where? How will you print 0123 by using where only instead of let? So how
46:15 - will you do that? You're going to use closures. So we're going to create a closure over here.
46:21 - Let's say inner and it's going to take I as a local variable. And I'm going to put all of this
46:28 - inside of this closure. And we will call this inner closure and pass the eye to it. So what's
46:36 - going to happen is every time this I is passed to this function, it is not going to reference
46:42 - just like we discussed, it's not going to reference that particular memory value. It's going to create
46:46 - a whole different memory space for this function right here for every time this loop runs.
46:52 - So we're passing I over here. And now I will be a local variable inside of this function
46:57 - rather than taking it from our outer scope. So let's run this. And yep, you can see we get
47:03 - this output 012. Awesome. So the next question is how would you use a closure to create a private
47:09 - counter? So what is a private counter? Let me show you. So if you create a function right here,
47:16 - called counter. And we don't take anything inside of it. And we have a variable counter equals zero.
47:24 - So I've put underscore over here because this is a convention when we create private variables,
47:28 - we put underscore before that, you don't have to follow this, but it's a good practice. So how
47:33 - can we create a private counter? So we already know that we can't access this variable outside of
47:38 - this function, right? So how are we going to update it? So I'm going to create a bunch of
47:43 - functions inside of it. First one will be the ad, which takes an increment variable by how much
47:51 - value is this going to be incremented? So this is going to return number, that's increment. So
47:57 - it's going to add this increment to this counter. And you know what, we don't need this return
48:01 - statement, my bad. So we're just going to do this, it's just going to add this increment to counter.
48:08 - Cool. Then we'll have another function, which will retrieve the value of counter.
48:13 - It's going to say return, counter, counter equals, and I'm going to provide the counter,
48:25 - just like that. Now we're going to return both of these functions. So I'm going to return, add,
48:33 - and retrieve, just like that. Cool. So let's go on and initialize this counter right here.
48:40 - So I'm going to say, const c equals counter. So this has created a new counter, a private counter.
48:50 - So what we can do is we can say c dot add, and we can provide it value, let's say five. So it's
48:55 - going to add five to that counter. And let's say if we provide it value, let's say 10. So after this,
49:03 - the counter should be at 15, right? So let's go on and call retrieve and check. So let's see,
49:13 - in our browser. Okay, I think, oh, yeah, we're supposed to console log this.
49:22 - Since it's returning the value. All right, so counter equals 15. So this is what a private
49:28 - counter is. We are not directly manipulating the counter. We are using these functions
49:33 - right here to manipulate the value of this private variable or a private or the private counter.
49:39 - Now there's a similar concept, which relates to this one, which is called a module pattern,
49:44 - which we're going to discuss in our next question. So if you can ask you this question,
49:48 - that what is a module pattern? So a module pattern looks something like this.
49:53 - So we have a if we write here, and we have a private function inside of it. And we have a public
50:00 - function which we are returning to the user. So user can make use of this public function.
50:05 - And this public function, we can write a code inside of it, which can call this private method
50:10 - right here, or the private methods or private variables of this module right here. So they will
50:17 - not be accessible outside of this module pattern. So private functions are not returned. Not returning
50:24 - these functions makes them inaccessible outside of the module namespace. But our public function
50:29 - can access our private functions, which makes them handy for like helper functions. For example,
50:34 - if you're supposed to make an API call inside of it, but we don't want the user to access it
50:39 - directly. So we can just use our public method to let's say manipulate it in some way so that it
50:45 - works exactly as the developer wants it to work. So in these cases, module pattern helps us a lot.
50:51 - So let's say if we go on and console log public. And we put this inside here called private
51:04 - method, module dot public method. And we called module dot private method. So this will be called,
51:15 - but this will give us error. So let's see. Yep, this is called and this gives us module dot
51:22 - private method is not a function because it's not going to be returned from that function.
51:26 - Cool. I would highly recommend you to go and read more about module pattern on your own,
51:30 - because this can be a really important question. And sometimes it's also asked in junior interviews,
51:35 - but mostly in the senior developer interviews. Okay, so next question is that interview provided
51:40 - us this function like the video, like the video. And instead of it, we have this variable view.
51:46 - So view is defined outside. We have declared view variable outside. And we are initializing it
51:51 - inside of our function. And then we are console logging it. So the question is to make this run
51:58 - only once. So if we call this function and again and again, you can see that we get this output
52:04 - again and again. So what can we do to make this run only once? So obviously, we're going to make
52:10 - use of closures. So we're going to create a local variable inside of it. Let's let
52:16 - called it going to be zero by default. And instead of this, I'm going to create a new
52:22 - function. I'm going to return a new function. It's going to be an anonymous function.
52:27 - And instead of this, I'm going to check if called is equals to zero, then I know what I'm going to
52:36 - say if called is more than zero, then obviously, this is already called. So I'm going to console log
52:45 - already, subscribe to roadside coder. And I hope you are also subscribed to roadside coder.
52:55 - Otherwise else, if this is not more than zero, then we're going to take this code and put it
53:02 - right over here. And after this is console log, I'm going to say called plus plus. So that called
53:09 - is not zero anymore. And then we will print already subscribed to roadside coder. So I think
53:14 - they should work first time they should print subscribe to roadside coder. And then after that,
53:18 - it should print already subscribed. Let's see. Oops, my bad. I need to call it first. So I'm going
53:25 - to say let I'm just going to remove this for now. I'm going to say is subs. Cribed. And it's going
53:34 - to take like the video. And now we can call this. So by doing this, what we did is we created a
53:43 - local scope with let called equals zero. And every time we call this, it's going to reference
53:48 - to the same called variable. So let's call it bunch of times. And let's see. So the first time
53:58 - it printed subscribe to roadside coder. And after that, it printed already subscribed to roadside
54:02 - coder. Yeah, so this is what we exactly wanted, which will make this run only once. Now this is not
54:08 - the proper implementation of this once, but you can use it if the interviewer asks you to do
54:14 - something like this. But if interviewer asks you to create a more generic function, then how are
54:18 - you going to do that? Let's see. So actually, there's a library called low dash, which already has
54:23 - an implementation of this once function. So I'm going to go on and create the polyfill for this
54:28 - once function right here. Oh, so let's create a more of a generic function. So I'm going to
54:33 - create a function with the name of once. And it's going to take two things. It's going to take a
54:38 - function. And it's going to take a context, a local context, if there's any context there.
54:44 - Now, inside of this, we're going to create a local variable called ran. And I'm just gonna
54:48 - declare it like that, which will determine if this function has been ran once or not. And after that,
54:53 - I'm going to create a closure, which is going to be anonymous function. And so this I'm going to
54:58 - check if there's something inside of the function, then go inside of it. And ran will be function
55:07 - dot apply. And I'm going to provide the context. If the context is provided, otherwise, I'm just
55:14 - going to provide the this. That is whatever the context of this function is, I'm just going to
55:19 - point to that one by using this. Don't worry. As I've already mentioned that I'm going to bring
55:24 - a complete video on this implicit and explicit binding, which will cover this this variable and
55:30 - call apply bind all of these concepts. So don't worry, that video is coming very soon.
55:35 - So all this apply does is all you need to understand for now that it's giving our function new context
55:42 - and the arguments, if any. So I'm going to pass all of the arguments. And as you know,
55:46 - this arguments will be an array. So I would highly recommend you to go and read about this
55:53 - apply function. If you don't understand how this works, because that will be a little out of scope
55:58 - for this video. So all it's doing over here is it's providing it a new context and a bunch of
56:04 - arguments. Let's say if we have one comma two, comma three, it's going to provide it just like
56:09 - that. Now after this is, now after this runs, it's going to provide the output to this ran variable,
56:15 - and I'm going to put the function to null so that we can not call it again. And after that,
56:22 - we're going to return, whoops, return ran, just like that. And this is our once function right here.
56:31 - Don't worry. I'm going to run this and I again explain you how this exactly works.
56:35 - So let's say I have variable hello, which is a function
56:44 - which console logs hello. So how are we supposed to run this only once? So if I print this
56:51 - multiple times, you're going to see that it runs multiple times. Okay. But when we wrap this inside
57:02 - of this once function that we have created right here, then you're going to see that it runs only
57:08 - once it's not going to run again and again, doesn't matter how many times you call it. So what's
57:13 - happening over here is it takes this function over here. Okay, cool. Now inside of this, we have a
57:20 - closure, which will be returned inside of this variable. The reason how we're able to call this.
57:25 - And then we're checking it if the function has some value. Yes, it has this value. Then we are
57:31 - running this function. And after we run this, it's going to have the result inside this ran variable
57:37 - and function will be null so that we can't run this again. And then we simply return the output
57:42 - of this function. But what if we had some variable, some arguments? So let's say if I pass one comma
57:47 - two. So let's take a comma B right here. And I'm going to print a comma P. And check this. Yep,
58:00 - you see, it's going to run with the provided arguments, because we are providing the arguments
58:04 - right here. So this is how once function is supposed to work. Now for our next question,
58:10 - we have to create the polyfill of this memoize. So what is memoize? So this question was also
58:16 - asked to me during one of my previous interviews. This question was asked to me during my cast 24
58:20 - interview, which I've already discussed in that video. So I'm going to show you that clip right
58:24 - here. The next question was on implementing a caching or a memoize function in JavaScript. So
58:29 - for example, if you are given with this function, which has some expensive calculation inside of
58:35 - it, which when executed every time takes a decent amount of time to run. So if I go on and run this,
58:40 - so I'm going to use console dot time to measure how much time did this took to run. And I'm going
58:47 - to run it twice actually with the same parameters. Okay, so if I go to console, you're going to see
58:53 - first time it took 40 milliseconds. And second time is also to second time it was 42 milliseconds.
58:58 - So how do we minimize this time calculation? If the parameters of the function are same,
59:03 - we need to cache the result of the previous function somewhere, right? So that is what we are going
59:10 - to implement. So let's say I'm going to go over here at the top. And I'm going to have function,
59:17 - which I'm going to say my memoize. And it's going to take a function which we are supposed to
59:22 - memoize. And we're going to take a context. And you know, let me remove this context for now,
59:27 - I'm going to show you how we're going to use that later. So right now, we're just going to take a
59:31 - function in this memoize. And first of all, let's create a variable for storing our result. So
59:37 - const, rest equals an empty object. So this will be the place where the result for our
59:44 - previously executed function will store or the cache for our function, right? Then after this,
59:50 - I'm going to return a function. And so to this, I'm going to take the arguments from the user
59:57 - after making this a memoized function. Now, first of all, I'm going to convert all of these arguments
60:02 - that we get from this function into a string. So I'm going to say where our cash equals Jason
60:12 - dot string, if I, and instead of this, I'm going to provide the arcs. So what's going to happen is
60:16 - this arcs cash will contain all of these arguments. Now we're going to take this arcs cash and check
60:22 - if we already got these arguments in our cash or not. And if we already got a result for all
60:29 - of these arguments, so I'm going to go down and say if I'm going to check it's at the rest. So
60:35 - rest, our cash. So if we don't have these arguments inside of our object, then we're going to
60:43 - calculate the result for that function. Otherwise, we're just going to return what we already have.
60:50 - So return this thing, just like this. So we're going to return all of the result for that all
60:58 - the time. So for example, if we are providing five and six, so our result object will look like
61:02 - this. So let's say a result of 30. Right. So this is how our rest object will look like. And if it
61:09 - finds out that it already has those parameters, so it's just going to return us this value. So let
61:14 - me write the logic for that. So inside of over here, I'm going to say, I'm just going to add that
61:21 - inside of our res object. So res cash will contain the result of the logic for that function. So
61:31 - function dot call. And now over here, we are going to use that context. So if you are sending any
61:38 - context, I'm just going to provide it. So obviously, this context is going to be optional. So that's
61:45 - why I'm going to say if this context doesn't exist, just use the current context. And obviously,
61:50 - we are going to use these arguments that are being sent to us. So I'm just going to spread
61:55 - all of these arcs as well over here. Cool. So I think this looks good to me. Let's go on and use
62:03 - this. So again, I'm going to show you previously, it gave us this result, both of these times. But
62:09 - now if I go on and memorize this function, so what I'm going to do, I'm going to supply this
62:13 - function. I know what first of all, let me change the name of this function. I don't think this fits
62:18 - the appropriate. So this should be clumsy. Product, that fits better. Yeah. So after this, I'm going
62:27 - to say const. And I'm going to wrap that function. So I'm just going to take this my memoirs and
62:36 - wrap this clumsy product. Just like this. And now since it's going to return us with a function,
62:44 - as you saw over here, return this function. So we are going to get a function inside of this over
62:48 - here. So I'm just going to replace this clumsy product with our newly memorized clumsy product.
62:53 - So now let's find out if it worked or not. Yep. Awesome. So you see, in the first call,
63:00 - it gave us 49 millisecond. And in the second call, it was 0.08 milliseconds. Oops, my bad,
63:06 - I made a mistake over here. So the else is not going to be over here. So this is just going to
63:11 - be returned. So it's just going to check if this is an optional condition over here,
63:14 - it's going to check if it's now if it doesn't exist inside of this array, then just add it to
63:20 - our result and then return it. Otherwise, if it is inside of our result object,
63:27 - then just return it directly. So now you're going to see, yep, now we get both of these
63:34 - result over here. Awesome. So this is how you go on and implement a caching or a memoization
63:39 - function in JavaScript. This is a really important interview question. All right.
63:43 - So our next question, which can also be very frequently asked is the difference between closure
63:48 - and scope. So whenever you create a function within another function, then the inner function
63:54 - is the closure. This closure is usually returned. So we can use the outer functions variable at a
63:59 - later time. So this is what a closure is. Whereas a scope in JavaScript defines what variable
64:05 - you have access to. There are two kinds of scope as we already discussed, global scope and local
64:10 - scope. And in case of closures, there are global scope, outer scope and local scope. So you can
64:15 - give this answer in your interviews and that should be good enough. And these were all of the interview
64:20 - questions related to the closure. All right. Now let's move on to our next topic, which is going
64:24 - to be on curring. And this is a very important section of this video, because you need to give
64:27 - me your full attention to understand this topic, because some people might find this stopping a
64:32 - little bit overwhelming. But this is very important for our JavaScript interviews.
64:36 - While preparing for this video, a lot of interviews told me that curring is the topic whose questions
64:41 - are the one a lot of candidates fail to answer. Just because they don't know how it exactly works
64:47 - or don't have their basics, right? So what is this curring anyway? Curring is a function that takes
64:53 - one argument at a time and returns a new function expecting the next argument. It is a conversion
64:59 - of functions from callable as this into callable as this. And curried functions are constructed by
65:07 - chaining closures by immediately returning their inner functions simultaneously. So if you haven't
65:12 - watched the last video of this series, which was on closures, you can watch that video by clicking
65:16 - on link in the description or I button above. Now, don't worry if you're unable to understand
65:21 - what I just explained by the end of this video, you'll be able to answer most of the questions
65:25 - that can be formed on curring. So let's understand it with an example. Okay, so I've opened VS code
65:30 - over here with basic HTML, CSS, and JavaScript files. And let's understand curring with this
65:36 - simple example. So as I mentioned, we have a function f with params a comma b. And it prints
65:46 - a comma b. So when we convert this type of normal function into this type of format,
65:53 - this is called currying. So let's see how we can do that. So instead of writing this, we can write a
65:59 - function f with param a. And as I mentioned, in currying a function takes one argument at a time
66:09 - and returns a new function expecting the next argument. So we're gonna return a new function.
66:16 - We're gonna keep it as anonymous function with no name and with the b parameter.
66:22 - And inside of this, we're just gonna simply console log a comma b, just like before. Okay,
66:28 - let's try to run this. I'm gonna console log function with value five. Let's see what do we get
66:35 - when we run this much of the code. So let me run this by opening with live server. There we go.
66:43 - Let's go to the console. And in the console, you can see we get another function over here. So how
66:48 - do we run this? We can go over here. And since this is returning us a function, what we can do is we
66:56 - can call it just like this with something else. So let's say if I enter six over here, let's see,
67:01 - what do we get? But you know what? Instead of this, I'm just gonna say return
67:05 - with a and b just like that. So and without this, we get this function return to us. So this is
67:21 - how caring work. This is how we convert a normal function into a function which is carried. There
67:26 - can be a lot of levels to this. We can have more parenthesis over here just like this. So it depends
67:32 - on how deep the caring is. And we're gonna discuss all the types of questions that interviewers can
67:37 - ask you during the interview process. Now there's an interview question where interviewer can ask
67:42 - you why do we use caring? So there can be a lot of answer to this question to avoid passing the
67:47 - same variable again and again to create higher order functions to make your function pure and
67:52 - less prone to errors. So actually, this is more of a theory question. So instead of making this
67:56 - video too long, I've written a blog on caring, which you can check out by clicking the link in
68:01 - the description below and follow along with this video. In that blog, I've included a lot of theory
68:05 - questions and all of the interview questions that I'm going to discuss in this video as we move
68:09 - along. So definitely go and check out that blog with link in the description below. All right,
68:14 - so let's get down to our first question, which is how will you implement this some function
68:19 - like this? And what this function should do is this function should sum all of the parameters
68:25 - that are provided to this parenthesis. So this is actually very similar to the example that I
68:29 - discussed a few minutes ago. So I will highly recommend you to go and try this question yourself
68:34 - first. So pause the video right now and try this question yourself and then continue with this video.
68:41 - So I hope you are able to solve this question. Let's go and understand how we can do this.
68:45 - So as I explained to you, we have a function first. Let's go from scratch. So how I would explain
68:52 - this question to the interviewer is I'll go and explain by creating a normal function first
68:57 - sum with three parameters, let's say a b and c and return a plus b plus c just like that.
69:06 - And if we go and console log this sum, let's say two comma six comma one.
69:15 - So we'll obviously get the output nine, but how do we implement it just like this?
69:20 - So right below this, actually, I'm going to comment it out first. Yeah, below this,
69:24 - I'm going to create another function sum, which takes a and inside of this,
69:30 - as we already discussed, incurring a function takes one argument at a time and returns a new
69:34 - function expecting the next argument, we're going to create a new function, which will give us
69:38 - another argument. So I'm going to create a function, an anonymous function with parameter of b.
69:47 - And after that, I'm going to create, since we have another parameter over here, another parenthesis.
69:52 - So I'm going to return another function with c, oops, c. And inside of this, finally, we can
70:01 - return our answer, which is going to be a plus b plus c. Now, if we go on and run this,
70:10 - sum, a, I mean, two, and then six, and then one, and go and check it out. Yep, we got this same
70:25 - output. Now, if you want to explain this in much more in depth to the interviewer, you can explain
70:30 - this just the way I explained you. So you can start by one parameter, you can say that if you
70:36 - provide it to, that's going to return us a function, which is going to expect another parameter b.
70:42 - And when we provide it b, which let's say we provide six, that's going to expect another
70:48 - parameter, which is c. So we're going to provide it the third parameter as well. And then we are
70:54 - going to get the final answer, which is going to be a plus b plus c. All right, so our next question
71:00 - is this, we need to create a function called evaluate. And we provide it a parameter of some
71:06 - multiply, divide or subtract. So we can provide this either of these operations. And after that,
71:12 - we're going to provide it to parameters over here, which are going to give us the result according
71:17 - to this. So if this is some, this is going to add this, if this multiply, this is going to
71:20 - multiply this, and so on. So we're going to go on and create a function over here,
71:24 - called evaluate. And first thing that is going to be taking is this type of operation. So
71:32 - I'm going to give this operation parameter. And so this is obviously going to return another
71:39 - function because it because it is expecting another argument. So we're going to provide it.
71:45 - We're going to return another function, which is going to be anonymous function. And I'm going
71:51 - to give this let's say a and inside this, it's going to be expecting another parameter. So I'm
71:55 - going to return another function, which is going to have a parameter b. And now inside this with
72:01 - respect to this operation, we're going to give the output. So I'm going to check if operation
72:08 - is equals to sum, then return a plus b. And so on. So let me write this quickly, just like that.
72:16 - Otherwise, let's return if the none of the operations are there, then I'm just going to return invalid
72:22 - operation. Cool. All right, let's try to run this. So I'm going to say evaluate. And I'm going to
72:31 - write some over here. And I'm going to provide this. Let's say four and two. Let's see what do we get.
72:40 - Oh, I need to console log this. All right, we got six over here. Let's see, we will try to give this
72:48 - multiply. Okay, we got multiply. So we so you can write this actually in some other way as well.
72:55 - So I'm going to create a const m u l. And I'm going to provide this evaluate.
73:05 - multiply. So this is one of the use cases of carrying. Since we have provided this multiply
73:10 - over here, this will always perform multiply. So you can reuse this and number of times.
73:15 - So if I go and console log, mul and mul will all obviously will have this function returned to it.
73:22 - So we can say, three, five, which should give us 15. And we can reuse it again. Let's say two
73:34 - and six, which should give us 12. So we should have 15 and 12 as an output. Yep, just like that.
73:40 - So you see, this is one of the use cases of carrying that we initialized our function once
73:45 - with multiply or whatever that we wanted to. So we will not initializing it again and again
73:50 - by providing multiply every time we call this. So we just provided it and initialized it once.
73:54 - And now we can use this mul function over here to multiply these numbers again and again.
73:59 - So during the interview, you can explain all of these things to the interviewer and the
74:02 - interviewer will really be impressed. Now our next question is on infinite carrying.
74:07 - So what is infinite carrying? So interview will ask us to write a function, which we can call
74:12 - just like this with n number of parameters. So if you have function like this, some,
74:16 - and we can say one, one and two. So this should give us three, but we can also call this function
74:23 - like this. We can add four, five, or we can add n number of parameters after this. And this should
74:32 - be flexible according to the number of parameters and should give us the answer accordingly,
74:36 - which in this case is going to be 12. So how do we do this? So this question was actually
74:40 - asked to me during my cast 24 interview. And I've already discussed in this cast 24 interview
74:45 - experience video. So I'm going to go on and play that clip right here. So the interviewer
74:49 - provided me with this code snippet. And he asked me to implement this add function.
74:54 - So let's see how we can implement that. So we create a function called add. And it takes a parameter.
75:00 - Let's say a. Okay. So we have a bunch of parameters over here. So it's obviously going to return a
75:09 - function. Then we are going to call that function with another parameter with another parameter. So
75:14 - it can go infinite. Right. It's not it's just not that we have to implement it till five to four,
75:19 - five. And then that's it. Because that will be easy. Right. So if I so let me remove this complexity
75:24 - for now. And I'm just going to implement with just two parameters. So this function a and it's
75:29 - obviously going to return a function. So I'm going to say return function B, let's say,
75:34 - or let's say an enormous function. And it's going to take B and then inside of it, I'm just
75:40 - going to return another function, which will have let's say a plus B. Okay. Right. So now if we go on
75:52 - and execute this, you're going to see we get the output as seven. Yep, just like that. But we don't
75:57 - want that. We don't want this much complexity. Right. So we want to create, we want to write a
76:02 - code which works infinitely. So if I let's say go on and add for and it over here, this should
76:10 - adapt to that code. So what I'm going to do, I'm going to remove this inner function. And I'm going
76:16 - to say we have two of these. But then I'm going to check if we have any more params or not. So I'll
76:23 - check if B has a param, then just return this add again, I'm just going to provide the value of a
76:33 - plus B and just continue this so a plus B. And that's it. But if B doesn't have any value inside
76:41 - of it, that means it's coming to an end. So I'm just going to return a. So let me explain this
76:48 - again to you. So let's say we have five, two, four, eight over here. So first of all, we provided it
76:53 - with the five and it returned us a function. Okay, so then we again called it with two,
77:00 - we called B with the two. But if it's going to check if two is there or not, if there is some
77:06 - value inside of B or not only then it's going to return the addition. Otherwise, it's just going
77:11 - to return the initial five value, the sum of those numbers up until that point. So okay,
77:17 - we did have two at that point. So we said, okay, if two is there, then return a plus B. So five
77:24 - plus two was returned. So five plus two, that is seven went inside of this function. So now its
77:30 - value is seven over here. But then again, it's going to return another function. Then it's going
77:36 - to check if we are calling that function as empty. But no, this is not empty. It has four inside of
77:42 - it. So then again, it's going to check if there's something inside of the B, then return a plus B.
77:47 - So at this point, a value was seven. So it's going to say seven plus four, that is 11. So it's going
77:54 - to pass 11 to that. So this cycle will run again and again and again, until we reach this point.
77:59 - So up until this point, the value was 19. So then it's going to have a 19 value over here.
78:06 - And it's going to return a function again. And then it's going to check if B has something,
78:10 - but here B doesn't have anything. So it's not going to go inside of it. And it's just going
78:14 - to return a that is 19 from here. So our answer is going to be 19. Yep, we got this output over here.
78:22 - Now the next question that the interviewer can ask you is the difference between carrying
78:26 - and partial application. Now what is this partial application? Let's see. Now you may have started
78:32 - to think that the number of nested functions are carried function has depends on the number of
78:37 - arguments it receives. And yes, that is what makes it a curry. Let's take some example. So if we
78:43 - have a function sum with a and it returns another function, which has B, C, and then they return
78:54 - a plus B plus C, just like that. And this can be called like this.
79:03 - And we provide it 10. And then we can call x like this. Let me console log this.
79:09 - Or it can be called as some. It can be called directly as. So you get what I'm trying to explain,
79:20 - right? So it can be called in either of these ways. So you get what I'm trying to explain,
79:25 - right? It can be called in either of this or these ways. So these function expect three arguments
79:30 - and has two nested functions. And like our previous version that expect three argument and has three
79:36 - nesting functions. So the first question that we discussed in which the sum had three nesting
79:40 - functions and had three arguments. So that is what our statement was right, that the number of
79:44 - nested functions are carried function has depends on the number of arguments it received. But in
79:49 - this case, that is not the case. In this case, we have three arguments, but we are only returning
79:55 - two functions over here. So this right here is not currying. We just did a partial application
80:01 - for this some function. What partial application does is partial application transform a function
80:06 - into another function with small arity. Also, if you don't know, arity just means the number of
80:11 - operands or the arguments are function receives. So if we were to write this same function with
80:16 - the currying, we would have written it something like this, because in this we have three arguments
80:21 - and we are returning three functions. But in this, we have three arguments, but we are returning
80:26 - only two function. So that is the difference between currying and partial application. This
80:31 - right here is partial application. Now, in some cases, interviewer can ask you to explain a real
80:36 - world scenario for using currying while developing our web applications. We can actually use currying
80:42 - to manipulate our DOM as well. So let me give you an example right here. And you can give the same
80:46 - example to your interviewer as well. So I'm going to go to the HTML file. And I'm going to add another
80:51 - h1 tag over here called hello pewsh. And here it is. Now I'm going to go to our JavaScript file.
80:58 - So right here, I'm going to create a function called update element text. And this is going to
81:02 - take an ID. And inside of this, I'm going to create another function, which will take content.
81:09 - And inside of this, I'm just going to write document dot query selector. And I'm going to provide this
81:16 - the ID has tag ID. Oops. Just like that. Dot. And I'm going to update the text content to be
81:27 - the content provided right over here. Now, what we can do is we, since we have an ID over here,
81:33 - oops, I haven't provided the ID. So let me give this ID of heading. Let's take this ID.
81:41 - Now what we can do over here is we can just initialize this function with our ID once,
81:48 - and we can update the text of our heading again and again by calling this the function that will
81:54 - be returned from this. So let me show you so const update header. And I'm going to call update
82:02 - element text. And I'm going to provide this this heading ID. Now we can use this update header
82:09 - again and again, every time we want to update the text inside of this heading right over here.
82:15 - So let me show you, I'm just going to call update header right here. And I'm going to say hello,
82:24 - roadside coder. And let's see, yep, you see, we have updated it, or we can write
82:31 - right to roadside coder. And you see, it has been updated. So yeah, we can use this function
82:38 - again and again in our code, according to let's say the condition, if we click on a button,
82:42 - we can call this function again and again, we don't need to use query selector again and again
82:46 - by providing it the ID, we just need to initialize it once and we can use it just like this. So yeah,
82:51 - you can give this answer to your interviewer and they will definitely be impressed and think that
82:54 - you've used carrying in your apps before. Now do you remember, in the beginning of this video,
82:59 - I gave you an example on how we can convert a function like this into this. And this is what
83:05 - a carried function is. So how about we write a function called curry, which converts this
83:12 - function into this function. Now this is the most important question of this video. Now this
83:17 - question is usually asked during the senior interviews, but can sometimes be asked during
83:22 - junior interviews as well. So let's start a function called curry, which converts a normal
83:27 - function into a carried function. So I'm going to write function curry. And this is obviously
83:34 - going to take a function. So I'm going to provide a function right here. And this is going to return
83:39 - as a carried function, which will look something like this. So I'm going to return carried function
83:50 - or just carried funk. So this is going to take all of the arguments of the function in the form
83:55 - of the array. So R X right here will be the array of all of the arguments. So what we'll do over
84:01 - here is I'm going to check if function dot length is more than equals to R X dot length. So that
84:10 - is what carrying is right if the function dot length is equals to R X dot length, because the
84:15 - number of argument has to be the equals to the number of functions returned. So if it's not equal,
84:19 - then what we'll do is this is this is actually our base case to check if it's not, then we're
84:24 - going to return a funk with R X else. We will return a function which will collect all of the
84:32 - next arguments that are going to be returned to us spreading the values of the arguments first
84:36 - and then the next arguments calling the carried funk recursively. So let me show you it. It's
84:41 - going to be a little confusing, but don't worry, I'm going to explain you after writing this whole
84:45 - thing. So let me write this out first. So return function with all of the next arguments. And instead
84:55 - of this, I'm going to call this carried funk with arcs and of the next arguments until this
85:05 - becomes more than all of the arguments of function length. So yeah, let's test this out. And I'm
85:10 - going to explain to you after that. So we have a function sum over here. And inside this curry
85:15 - function, we're going to provide this some function right over here. And the inside this total sum,
85:20 - we will have this carried funk. Now this thing will be a carried function. So I'm going to call
85:26 - it just like this. So let's see, we should get the output. Oops, I made a mistake over here. So
85:32 - I'm going to check if arcs dot length is more than equals function dot length. Yeah, now let's
85:41 - see. So yeah, we get this output six. Now let's understand how this whole thing is working. So we've
85:49 - created a function sum over here, right, which takes four arguments. And it calculates the sum
85:54 - for it. Okay, then we have created a variable total sum over here. And we're passing this
85:59 - sum function to this curry implementation that we have done right over here. Okay, cool. Then
86:04 - we're calling this total sum just like this in a carried way. So let's see what's happening. We've
86:12 - provided this one to this. So obviously, when we do this, this is going to return as a function,
86:17 - which is going to be this carried funk, right? So we have supplied it one first of all. So one
86:23 - will be supplied to it. Then it goes inside of it, it's going to check arcs dot length. So arcs
86:29 - length right now is just one. So let me show you, if I go on console log, and I'm going to say arcs
86:36 - dot length. And I'll also do funk dot length. Oops. First time the number of arguments were one,
86:46 - and length of the function was four, that is these four functions. Second time the length of
86:52 - argument was two, then three, then four. And the moment the number of arguments exceeded,
86:57 - it's going to call this function right over here with all of the arguments. So I'm going to explain
87:01 - you as we move along. So let's do this step by step. So I'm going to comment this line now. So
87:06 - yeah, first time we have called it with this one. So it's going to check arcs dot length. So I
87:11 - sort length right now is one, obviously, it's not more than the function dot length. So it's not
87:15 - going to go inside of it. It's going to go over here. Now this is going to call this carried funk
87:20 - over here, recursively. So what this will do is this will return us a function expecting next
87:25 - arguments. So if I remove this for now, and run this, you're going to see that it returns us another
87:32 - function, which is expecting the next arguments, because obviously the criteria for this is not
87:39 - satisfied, carrying means the number of arguments should be equal to number of functions. And the
87:44 - number of function has to be four, since the number of arguments are four, the number of
87:48 - functions are also supposed to be four, only then this is going to run. So if we provide it
87:54 - another, let's say six, then again, it's going to expect the next argument, because then
88:03 - it's going to go over here with six. And now arcs dot length is two. So over here, it's going to
88:09 - check arcs dot length two is not more than function dot length. Okay, so it's not going to go over
88:13 - here, it's going to come again over here. So in the case of third argument as well, it's going to
88:17 - again expect you to supply the next functions. But the moment we supply it with the fourth
88:24 - argument, what it's going to do, it's going to take all of these and provide it to this sum
88:29 - function, that is this function right over here. And when we run this, you're gonna see,
88:34 - we have successfully calculated the sum for all four of these. Now you can write any function
88:38 - over here, and this is going to make it a carried function. This is how much powerful this function
88:44 - is. Now I know this is a little bit confusing to you, but try to rewind the video and rewatch
88:49 - my explanation that I did just now, you'll be able to understand it properly. So yeah,
88:54 - that was carrying in JavaScript. And if you liked this video, give this video a huge
88:57 - fat thumbs up and subscribe to the channel for more such awesome interview videos.

Cleaned transcript:

This course will prepare you for JavaScript interview questions, focusing on closures, functions, and currying. Throughout the course, you'll delve into various aspects of JavaScript, such as function declarations, expressions, scopes, and hoisting, as well as learning about advanced concepts like closures and lexical scope. You'll also gain a deeper understanding of currying and its practical applications in JavaScript. Roadside Coder created this course. He has created many popular courses both on our channel and his own channel. The course includes numerous interview style questions to help you solidify your understanding and prepare you for your next JavaScript interview. So get ready to gain the confidence and knowledge needed to tackle any JavaScript question on closures, functions, and currying that comes your way. This is the only video that you will need to know the most asked JavaScript interview questions on concepts like functions, closures, and even advanced concepts like currying. We will discuss different types of interview questions on hoisting, scope, call back, arrow function, lexical scoping, output based questions, partial application, polyfills, and much much more. So fasten your seat belt because in the world of JavaScript, the only thing worse than a syntax error is a silent error. That breaks your code without even telling you why or where it happened. And also if you happen to like this video and if you're interested to watch more such interview videos, you can check out my channel Roadside Coder, where I've made a complete playlist on JavaScript and React.js interview questions which has helped hundreds of thousands of developers to crack interviews. Link to my channel will be in the description down below. So let's start by basic questions first, which are mostly asked in entry level JavaScript interviews. So I've opened VS Code over here with HTML, CSS, and JavaScript file. And the first question is what is function declaration? So function declaration is nothing, but when we declare a function like this, so let's say function, and a square, and we give this a number, and this returns us anything. Let's say, so this is a normal function declaration. So this can also be called function definition or function statement. So next question is what is function expression? So when you store a function inside of a variable, it's called a function expression. So let's say const square, and instead of it, if I add a function with no name, this will become an function expression. That's it. Now an add on to this question can be what is this called? So you see this function doesn't have a name, but we are giving this a name by assigning this to a variable. But this part in itself, what is this called? This is called an anonymous function, which is which the function which has no name. And this anonymous function can be assigned to a variable or can be passed as a callback, maybe what is called back, you ask, we will discuss that in this video as we go forward. Now these function expressions can also be called like just like a normal function is called like this. And we need to console log this as well. And need to pass a number. Let's say five. And let's see. Yep, we get 25 over here. So a function declaration function expressions are kind of same. Just the difference is function expressions are assigned to a variable. The next question is what are first class functions? Now first, well, let's understand what does this first class functions mean? So in a language where a function can be treated like a variable, their functions are called first class functions. In these cases, functions can be passed into another functions can be used manipulated and returned from those functions. And basically, everything that a variable can do a function can also do. So this is why we call functions as first class function in JavaScript. So let me show you an example. So let's say we have the same function function square. And we have another function, which is called display square, which takes a function and returns. Or let's say just console logs that function with a message, which is square is this. So we can call this function display square with this square function. So we can pass this function inside of this parenthesis over here. And I'm going to pass five over here. Let's see. Yep. So we get this output square is 25. So you understand how powerful functions are in JavaScript that we can pass them inside of another function just like a variable. And we can also manipulate and return them from that function. So this is called first class function. This is a very important interview question. Now the next question is what is if he now this is not that much of a frequently asked question, but you should be aware of what and if he is. So if he means immediately invoked function expressions, what do I mean by that? Let's see. So we have our square function over here. So when we need to call this square function, we need to do this square. And then we pass any parameter if you want. And then it is successfully. Oops. Wait, let me instead of returning this, let me console log this over here. Yeah. So when we call this, this is successfully invoked, just like that, cool. But what an immediately invoked function expression does is we don't need this. What we can do? We can wrap this in a parenthesis, and we can call it right away right over here. We can pass argument over here as well. And you're going to see that our function is still called. So this is a immediately invoked function expression. Now the interview may not ask you exactly what if he is, but they can definitely give you an output based question based on if he. So let's check out one output based question. So interview can give you a question like this. So what is this? Let's understand. So this is an iffy. And it has another function inside of this, which is also an iffy. So here we are executing this function by passing this argument one over here. Okay, we pass the argument one. And then in the inner function, we are passing two, but we're not using anywhere, but we're just console logging X. And what do you think will be the output of this question? Now a lot of people think that this will give us undefined because X is not defined in this scope. But no, it will give us the output of one. So let's see. Yep, you see, it gave us the output of one, because it's going to search X in this inner scope first. And when it doesn't find this X over here, it's going to search in its parent's scope. And in the parent's scope, X exists. And this happens because of closure. If you don't know what closure is, don't worry. We will have an entirely separate video where we discuss some interview questions related to it. And that video will be dropping next. So subscribe if you have it yet. For now, you can understand this, the ability of a function to access variables and functions that are lexically out of its scope are called closures. So closures are created whenever a new function is created, because that function has the reference to its outer scope. Okay, so let's try and understand more about function scopes. So I've opened the official MDN docs for function scope in JavaScript. And we can use their example to understand how exactly function scope works. So let me copy this up and paste it over here. So you can see that we have three variables defined over here. First is num one num two and then name. So when we call this multiply function, what's going to happen is it's going to take num one and num two from the global scope, because these are defined in the global scope and not inside of this function. If there was a copy of these variables inside of this function, it would have taken that one. So let us move to the other example where we have this case. So we have this get score function over here, where we have num one and num two as two and three. But keep in mind, we have both of those variables in our global scope as well. But these will shadow the global scope variable. So if you don't know how where let in const works, I've made a complete video on this topic and I've explained this shadowing concept as well in that video. So you can click the link in the description to watch that video. Now, inside of this function, when this add function is run, it's going to take the name from the global scope. And the num one and num two will be taken from the local scope. And it's going to return as the output roadside coders code five. So let's see. Also, I'll provide you the link to this page in the description below. Now you see first returned as 60, which was multiplication of these two 20 and 30. And a second one returned as five with a global variable as well. So this was a basic example of a function scope. And you can use this example to explain function scope in your interviews. Now let's discuss an output based question on function scope. So we have this for loop over here. Inside of this, we have this set timeout, which console logs one. And it has a delay of I into 1000 milliseconds. What do you think the output is going to be? The interviewer can ask what the output for this code is going to be. So now, since we have this let I over here. So every time this for loop runs, it creates another block scope for this function. So the first time it's going to be zero, then one, then two, then three, then four, then five. But if it was where over here, then where doesn't have a block scope, then where would have printed five, five, five, five, five, five. So let me show you. In this case, we get five, five, five, five, five, because we have where over here. But if we change this to let, since let has the block scope, it's going to print one zero, one, two, three, four. Now again, to understand this question properly, you need to understand how let where and const works, which I have explained in my another video, which you can go and watch by clicking the link in the description. So let's move on to hosting now. So you might remember that I've explained hosting in our where let const video on how variables are hosted on top of our code before our code is executed, and how our code is first initialized, and then it's executed. So functions are hosted a bit differently than a normal variable does. Now when we have a function like this, and we call it over here, and when we run this, you're gonna see this works absolutely fine. But what will happen if we run this before the function is declared, it still runs the same. It's because functions are hosted completely. So what's what happens when a variable is hosted? So let's say if we have a variable x equals five. And when we log this, we're gonna get the output as five. But when we log this before this is even declared, then obviously, we're gonna get the undefined, because of hoisting. But in function, that is not the case. So let me show you, if we go to sources, let me put this right over here. And now when we put a breakpoint over here, and run this, yup, inside of our global scope, you're gonna see, we will have a variable of x, which is not defined. But obviously, this is hosted. So if we go down, we're gonna see we have this variable hosted as undefined. But in functions, in the case of function, the complete function is copied to the scope. So if we go up over here, we're gonna see, we have this function name with complete function copied to our scope. So hoisting works a little differently in case of functions. We don't have function name as undefined, we have the complete functions. So it doesn't matter if you call the function before or after declaring it, it's still going to work. So this was our global scope, right? Inside of a function, we have the function scope. And this that work exactly like global scope does. So instead of global, we have a function scope. So let's say if we have this variable defined inside of this function over here, and we console log it before it, it's still going to work the same. So let me show you, if I put a console log over here, and refresh, you're gonna see inside of this local scope, we still have x undefined, because it was hosted on top of this function. So don't worry, I'm gonna discuss an output based question, which is going to clear on how interviews can ask you these type of tricky concepts and understand if you have the knowledge for the same. So if you put a debugger over here and move forward, now you're gonna see x has five, because obviously x is defined now. All right, pause. If you're not yet following me on Twitter, go to reader.com slash pewsh underscore on or click the link in the description down below and hit that follow button right now. I'm waiting for you. I'm still waiting. Okay, fine, let's continue with the video. So we have an output based question over here on function hosting. So I need you to think about it before answering it, because this is a tricky one. So we have a var x as 21 over here, we have a function expression defined over here, and then we are calling that function expression. So what do you think? What is going to be the value of x over here? Is it going to be the local variable? Or is it going to be the global variable? A lot of us, we will think that obviously it's going to be local variable, right? Because this is how this works, we will take the local variable, because the local variable will shadow the global variable. Okay, fine. But a lot of people will think, no, this is not defined at this moment. This is defined after that, right? So this is obviously take the variable from the global scope. Okay, that makes sense as well. But let's see what is going to be the output for this. It's going to be undefined. Why? Why is this undefined? Let's see, let's go to our sources, inside of our script, yes, and here, let's run this. So we have this global scope, right? In our global scope, we have x right over here, x as 21. But inside of our local scope, we have x already present. So if you remember in our var let const video, I explained hosting is a two step process. First, it initializes the complete code. So it's gonna initialize the global scope, then it's gonna come to the local scope, and then it's going to initialize the local scope as well. And when it initialize the local scope, it's gonna first host this variable on top of this scope. So in this scope, the x is present and is undefined right now. So we will not take 21 or 20, we will take the x in this current scope, because obviously x is not being initialized at this moment. So when I put a debugger over here and press next, now you're gonna see we have x as 20. So keep this in mind, when we have a variable present in a scope, we will not go and check the global scope, we will always refer to the current scope. So our next question is params versus arguments. So this is one topic that confuses a lot of people, which of these is called params and which of these is called the argument. So when we have a function like this declared over here, and when we call the function, the values that we pass inside of here are called arguments. So these are arguments. And when we receive those values inside of our function, this is called params, or parameters. So these are called params, and this is called the argument. Pretty simple, isn't it? Now individuals can ask a confusing output based question on this topic as well. I'm going to discuss another bonus topic in this video, which is spread versus rest operators. So let's say we have a function called multiply, and we have number, we call this like this. All right, so what is spread operator when we let's say we have an array over here, let's say five comma six, and we want to pass both of these values to this function, we're going to what we're going to do, we're going to use these three dots and a so it's going to spread both of these values and pass it to this function. So now you're going to see that this runs just like that, and it gives us the output 30. And similarly, when we're passing this to this function, we can also receive it like this, let's say numbs. And let's just console log numbs for now, you're going to see that we receive five comma six. So here when we use this operator, this is called spread operator. And here when we use this operator, this is called rest operator. So I can probably do something like num of zero into numbs of one, and it's going to give us the same output. Yep, just like that. So let's discuss a tricky output based question on this. So let's say the interviewer gave us this code snippet and asked us what is going to be the output for this. So when we run this, so let's see the output rest parameter must be the last formal parameter. So you see, we combined params arguments and rest operator concepts. And we have this question over here. So when we use rest operator or spread operator, it should always be the last one. So just like this. So what this will do is it will take all of these three values. So let me add more values over here, comma eight comma nine. So this will take a x a x y as five six three, and the numbers will take the remaining value. So that's why we add it at the last of our list of parameters, so that it takes all of the remaining arguments. So if I say numbers, and now you're going to see it runs properly up six three and seven eight nine. So six three and seven eight nine which were the remaining arguments. Great. So I know this was a little tricky one if you're not aware of rest operator or spread operators, but it's fine. You're going to get good with time as you use this rest operator spread operators in your projects and in your apps. So the next question is, what is a callback function? So actually, we have already seen this in our first class function topic. So let me go to the official Mozilla documentation. And here in the definition, you can see a callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action. So as I mentioned, functions are first class function in JavaScript. So when we have a function like this, and a function like this, we are passing this greeting inside of this function, and it's taking this greeting callback. So this greeting is what a callback function is. So as the name suggests, the function says that you can call me back whenever you like. So the function is sending itself to this function, and it is calling it inside of this other function. So this is exactly what a callback function is all about. Now, into work can ask you question, like, can you give us an example on what a callback function is? So you can give that example. And also, you can give the example inside of the JavaScript predefined functions, which are something like set timeout map filter reduce. So let me give you an example, something like when we use event listeners, so document add event listener, this takes two things. It takes the event, which let's say click event, and then it takes a callback over here, just like that. So this is what a callback is when we are passing a function inside of another function, and then this function is manipulated inside of this one. So it can be event listeners, it can be function like map, filter reduce, or set timeout. So if you don't know, I've made up actually made up another video on map filter reduce as well, which is our previous video, you can click the link in the description to understand these topics thoroughly. Now last but not the least, we have arrow functions. Now, what are arrow functions? So arrow functions were introduced in ES six version of JavaScript, and they were kind of like similar to a normal function, but in some ways, they work differently. So let me show you, if you see a normal function, its syntax looks something like this. So we have a function called add over here, in which we takes two parameters and return some value. So what are we going to do if we need to convert this function into an arrow function? So we just need to get rid of this function keyword, and we need to add an arrow over here. And that's it. We're done. That is what an arrow function is. It has a bit more clean syntax. And actually, we can get rid of these curly braces as well, since this is returning only one line, and we can get rid of this return as well over here. So yep, you can see this syntax looks much cleaner than the previous syntax. But when we use the curly braces, we do need to use return or, I mean, according to our requirements. So let's discuss some of the differences between arrow function and a normal function, because this is a really important interview question. So the first one is what we have already discussed is the syntax. So the syntax of a normal function looks something like this with the function keyword. But the syntax of an arrow function looks something like this, with this arrow operator. Okay. Now the second difference, the implicit return keyword. So I've already showed you that in a normal function, we can use return like this. But in an arrow function, we can do something like we can get rid of return function. If this is a one liner, and we can write something like this. Third point would be is the arguments keyword. So if let me show you, so if we have a function inside of this with let's say we have, we don't have any parameters, and we just console log arguments over here. Now if I call this function with one, comma, two, comma, whatever. So then we're gonna see, oops, a square has already been declared, let me is this names. Okay, now you're gonna see we get this arguments with all of these arguments. So we didn't even pass the perimeter over here, but we got all of the arguments just like this. But can we do this in arrow function? Let's see, function keyword, and make it arrow function. Now, let's see, you're gonna get the output arguments is not defined. So you cannot have the arguments keyword inside of an arrow function. Okay, let's comment this out as well. Now the fourth point will be the this keyword. How does this keyword perform with normal function and the arrow function? Now, obviously, if you don't know what this keyword is, don't worry, I'll create another separate video on this topic. So let me have a question over here, which can be considered as an output based question. So introvert can give you something like this. So inside this object, we have a username, and we have two functions over here. First function is an arrow function, and second function is a regular function. So let's see how both of these performed. I have called both of these functions over here. And let's see the output. So the first arrow function gives a subscribe to an undefined, but the second regular function gives a subscribe to roadside coder. It's because this here is pointing to this object. But this instead of this function is pointing to the global object. So I know if you don't have the proper knowledge of this keyword, it's hard to understand right now. But don't worry, I will come up with a separate video for this keyword. So yeah, these were the major four differences between arrow function and a regular function. Now there can be more differences as well, like how the constructor is defined inside of both of these. But that would be a little advanced topic for this video. So I would highly recommend you to go and read more about it. And if you haven't access the complete playlist for our JavaScript interview series, you can go to youtube.com slash roadside coder. And here inside the playlists, you're gonna find the complete playlist here in this playlist tab section. Alright, now let's move on to our next topic, which is on closures. Closures is the most important topic for JavaScript interviews. And there can be literally hundreds of questions that can be made on it. That's why after hundreds of years of research, I have curated some of the most asked interview questions on closure for this video. Just kidding, I haven't researched for that long, but it's gonna be good. So a closure is a function that references variables in the outer scope from its inner scope. To understand the concept of closures, you need to know how the lexical scoping works first. So I've opened VS code over here with basic HTML CSS and JavaScript files. So what is lexical scope? So a scope refers to the current context of your code. It can be either globally or locally defined. And with the six version of JavaScript, we also have the block scope as we discussed in our where let cons to video. So let's see. So since we have a variable right over here, this variable, this is in the global scope. Right. But what if we go on and create a function over here? Let's call it local. And so this right here is the local scope. And this is the global scope. But what exactly is the lexical scope? So a lexical scope in JavaScript means that a variable defined outside a function can be accessible inside of another function defined after a variable declaration. But the opposite is not true. The variable defined inside the function will not be accessible outside that function. So let's see an example. So if I console log this name over here, let's call it username. Yeah. So let's go on and run this. Here's a browser. Let's go to inspect. Oops, we are not calling this function any right now. So yeah, now let's see. Yep, you see, we get this output roadside code over here, because the variable defined outside of this function can be accessible inside of this function. This is called lexical scope. But what if we do this? If we take this line and put it over here and try to take this console log outside of this function, will this still work? Let's see. No, this is going to give us the error username is not defined. So we cannot access the variables from inside of the function. We can only access the variables that are outside of this local scope. So let's see another example over here. So we have this function subscribe over here, which we are calling after it. And we have another function display name, which we are calling inside of this function. So you see, we have multiple scopes over here. So let's call it inner scope. We call it inner scope two. And then there is this global scope. Right. So we have three scopes over here. So what's going to happen is when we call this subscribe function over here, it's going to initialize this function with this name roadside coder. And when we go inside of this function, this will be still accessible inside of this function, because it's outside of this local scope. Right. So we will be able to print this name. So let's see. Yep, you see, it's printed over here. So this thing exactly right here is what a closure is the display name is called a closure. I know you might be a little confused right now, but let's go on and understand closures in depth. Also, if you would like to get in depth knowledge about JavaScript functions, you can go and check out my previous video, which was completely on functions, where we discussed all of the interview questions related to the functions in JavaScript. All right, so let's go to the Google and search closures. And we get this MD and docs over here. And according to this documentation, a closure is a combination of a function bundled together with references to its surrounding state, or the lexical environment that we just discussed. In other words, a closure gives you the access to an outer function scope from an inner function. So as we saw in this code, that this function was able to access the variable outside of this scope. So this is what a closure exactly is. In JavaScript, closures are created every time a function is created. So you can see right here, this is the example that we discussed. So if you scroll further down, they've given us another example. So let me just copy this up and paste it right here. So what's going on over here? Let's see. Instead of this alert, I'm just gonna put console log over here. Yeah, so here we have defined this local variable name. And instead of this, we have this function in our function called display name. And we are returning this display name over here. So what we're doing is we are calling this make function over here. And we're taking whatever that it's returning us. So it is it is returning us the display name. So now this gives us a function which we can call any time we want this is the inner function of this make function. So we can go on and call this and it's gonna execute this function right here. And it's still going to access its outer variable of Mozilla. So if you go to the browser and see, yeah, you see, Mozilla is printed right here. And in some of the language, you won't see this type of code working. But in JavaScript, this works in JavaScript, every time we create a new function, it binds itself to its environment or its lexical scope. So doesn't matter if you call this one directly over here, or if you return it from this function, it's still going to have the access to its parent scope of this or or let's say global scope. So it's still going to have the access to the lexical scope of its parents. So you must be thinking what's the use of this syntax. So closures makes it possible for a function to have private variables. JavaScript closure is used to control what is and isn't in the scope of a particular function, along with which variables are shared between sibling functions in the same containing scope. So if I create another function right here, with some another name and return that one as well. So that will also have the access to the scope of this function. So actually, we will discuss all of these questions and concepts as we move forward in this video, I just want to make sure that your basics are cleared at this moment first. So we're going to start one by one. Also, if you want to call this function display name, we can also do this. So let me remove this up. We're calling this function and inside of this sense, this is this returns us another function, we can do this right over here. So this returns us the display name. And then we are calling the display name right over here, just like that. So actually, we can pass anything inside of here as well. So let's see first this works or not. Yep, this works as expected. So let me pass number five over here. And let's receive num. And I'm gonna print num. So yep, you see number five is also printed over here. So this just works just like a normal function. But we have much more power because of this JavaScript closures on our scope. Okay, so that were the basics of closures. But you might have heard of this term called closure scope chain. Let's see, let's go to the documentation again, and see what this thing is. So right here. So according to this, every closure has three scopes as we already discussed, a local scope. That is, this one, the outer function scope, that is this one, the outer function scope, and then the global scope. So it has three scopes right here. So a lot of people think that, okay, this function will only have the access to its outer scope and not the scope of the parent. What scope chain means is, it's going to have the access to its outer scope as well. And the scope of its parent. So if I go on and say, where user name and give it a value and use this right over here, then you're gonna see, we still get the output because it has the access to all of the scopes of its parent scope and the scope of its parent's parent. So this is what a scope chain is. Let's see what example they've given us to explain it. So as you can see right here, they have given us this example with a lot of local scopes in here. So let's paste it. Okay, so as you can see, we have this function here, and then we have another function nested, then we have another function nested, and we have this sum at the top. So we're calling this sum with one, right, so it's going to give this a one. And then another inside of this, we have another function return. Okay, so this will return B. Now we're supposed to call B over here. So then we are calling B with this parenthesis, and we're supplying the value of two to B. Also, sorry, the name of function is not B. The name of parameter is B. The function is an anonymous function. Right. So after that, it's returning us another anonymous function. This will be returned over here. So now we're going to call it again with value three. So it's going to have three. And so on, it's going to return another function. So we're calling it with this function four. And now notice what happens. Inside of it, we're returning a B C D E. So this function right here will have the access to all of the scopes outside of it. So scope where we have C value, B value, a value, and the global scope where we have E value. So it's going to be able to access all of them. It's going to log us 20. So let's find out. Yep, just like that. So this is what a closure scope chain is all about. Now they've given a bunch of more examples. I would highly recommend you to go and read more about closure and closure scope chain from this documentation. It's going to really help you become good in this topic. Okay, so let's go on and discuss some of the most asked interview questions on closures. We're going to start from the very basics and go to the advanced level questions. So as you can see right here, we're given a variable, let count equals zero. And after that, we have an iffy over here. So if you don't know about what and if he is, you can go and watch our previous video on functions, they're I've explained what and if he is and so we have a function over here called print count. And so this we have this conditional. And we're supposed to tell that what this will console log and what this will console log. So okay, we have count equals zero. So obviously it's going to take count equals zero inside this function as we learned up until this video because of its lexical environment or lexical scope. But we have a problem over here. We have another count equals one over here. Well, this is confusing. What will we print inside of this count then will be print count equals one or count equals zero. Okay, so let's see. So this is checking if count is equals to zero, which yep, it at this point, it is zero. So we're going to go inside of this. Then we're saying that let count equals one. Now this concept right here, this is called shadowing. And I've explained this concept in our where let const video that this is a block scope right here. And this variable is going to shadow this variable from outside. So this is going to overlap the value of count with one. And it's going to print one over here. But outside of this, keep in mind, this is inside of this block only. It's not going to affect the environment outside of it. So outside of it, count is still zero. So count is still zero at this point. So this will print zero. It will not be affected by this let count equals one. So let's see the output. Yeah, you see, first one gave us one and the other one gave us zero. So interviewers give us questions like this to understand if the candidate is aware of concepts like block scope or shadowing or not. Okay, so the next question is to write a function that would allow you to do this. Okay, so what's going on over here, we are calling this create base function with certain value. And it is returning us a closure called add six. And then we're calling this add six closure. And whichever value that we pass inside of it, it returns us by adding the value that was written over here. So if we did 10, so 10 plus six, 16, 21 plus six, 27. Okay, so how are we going to do that? What we learned up until now, this is obviously going to be a closure, which will be returned from this create base function. So let's create this create base function first. So create base, and it's going to take a number. Cool. Now from inside of this, we are supposed to return a function. So let's return a function, which I'm going to keep as anonymous function. And this I'm going to give, let's say inner num. And so inside of this, what we're supposed to do, we're supposed to add inner num to this num. So we're gonna return inner num plus num. And obviously, since this is a closure, so num will be accessible inside of this function. So let's see if this works or not. Oh, I think I should console log this. Or maybe I think I should console log this. And put this inside of here. Yep. Let's see. Okay, we got this output 16 and 27. So what's happening over here is we have taken this create base as six. And we have created a local scope for both of these function calls. So we just have to do this once. And this will be initialized with a scope where num is six. Now doesn't matter what we pass inside of over here. If we pass 15 over here, it's still going to add six to it, just like that. So what's happening over here is you can create a closure to keep the value passed to a function create base even after the inner function is returned. So if we don't want this value to change, then we can create a closure where this value is always six. We just have to pass it once. And it's going to access the value as only six. So this is also one of the use case of closures, which makes it so powerful. Okay, so this question right here is kind of similar to the previous question. But it's a little add on to that. How can we use closures to optimize the time of our code? So interviewer has given us this find function. When we call this find function right here, by the way, just ignore this console. Time for now, I've just added this to measure how much time does this function call takes. Okay, so first we're calling this find function with this six value. Okay, so it takes the six value right here. And it has the empty array. And what it's doing over here, we have a really long loop, which runs one million times. And what it's doing over his, it's assigning the value of i into i to each of the index of this array. Okay, that's fine. So this is being done to make this loop really slow. And then we are console logging the index, whatever index that we provide. So if we have provided the six index, so we're just supposed to print that. Okay, so let's save this and check this out. Okay, so you can see right here, it gives us this output, but it's taking this six millisecond right here. And the other call takes 12 milliseconds. If we put even higher number over here, let's say 50. So it's taking 135 millisecond right here. Sorry, I said six earlier, but it's 67 milliseconds for this one. And this is 135 milliseconds for this one. So how can we optimize this by using closures? So just like what we did in our previous since we are not touching this value anytime, right? We this value is the same for each and every time we call this function. So let's create a function right here. And anonymous function, which will take this console log inside of it, instead of passing this index over there, we're gonna pass this index over here. So let's do this, let's create const closure, which will have this find right here. So we have just created a inner function closure for us. So that this remains the same for every time we call this closure right here. So now I'm going to replace this with this closure. And this is 50 right here. So I'm going to put 50 so we can recognize this. Okay, so let's see what has changed. Okay, there's a huge change right here. So for six, I think it was 67 earlier, but now it's 0.25 milliseconds. There's a huge time optimization of this code. And for 50, it was I think 135 something, but now it's 0.025. So you see how closure has helped us in optimizing the time for our code. So this is the reason why closure is such an important topic and such a favorite topic of interviewers. So let's move on to our fourth question, which is on block scope and set time out with closures. So this question is really, really important. And this question is asked in a lot of companies. I've already discussed this question in my unacademy interview experience video. So I'm going to go on and play that clip for you right here. So the interview provided me with this code snippet. And obviously we're going to run this over here. So he asked me what is going to be the output for this. So let's think about it. Most people will think that since we are console logging over here, we are running a loop over here for loop. And we are console logging each of these values inside of over here after one second each. So most people will think that the output is going to be this 0, 1, 2, is it? Let's find out. It is three, three times. Let's refresh the page. So three, three, and three after one second each. So why is this happening? This is because of where. So what where does this we just discussed in our previous question. So where doesn't have a block scoped where has a function scoped. So what's happening over here is, first time this runs, where's value is 0. But this is not going to be printed right away, because set time out only runs after the complete code has ran successfully. Right. So this is not going to run. So we have a reference to that I variable in our memory. So we have a reference over here, let's say, okay, then again, the I is one, then we again have a reference to the I variable, just like that. And then I is two, then we again have a reference to I variable. And then the third time the value of I is three. But if we obviously, we won't go inside of over here, since it says that I has to be less than three. So we're not going to run inside of it, we come out of this loop. And then set time out has finished its time. And now our JS engine is going to print all of these values. So last time the JS engine encountered the value of I, it was three. Now here, JS engine is referring to the current value of I. So the current value of I was three. So it's going to print three, three, and three, just like that. Now what's the solution for this? You may have guessed it right. The solution for this is using let instead of where? Let's see the output. 012. Yes. So what's happening over here is let is block scoped. So first of all, let's value was zero. So it has the completely different scope. So in this scope, the value of I was zero. So it's going to print it later on. Then again, the second value of I was one. So again, after the complete code has ran successfully, it's going to look into the scope of that I variable. And when it looks into all the three scopes, it's going to find zero one and two. So this is the logic behind this question. So actually, this was the follower question that the interviewer asked. I just explained it to you in one go. So these were two different questions that the interviewer asked. The interviewer asked first to tell him the output of the first with where and then he asked me how we can print 012. So then I went on and explained him with let. So this was the question. But few of the interviewers extend this question even more. They're going to say you're not allowed to use let. You're going to have to use where instead of let and you have to print 012. You have to give this output. How are we going to do that? So this is a task for you all. I'm going to give you a small hint. It's going to use closures. All right, pause. If you're not yet following me on Twitter, go to Twitter.com slash pewsh underscore on or click the link in the description down below and hit that follow button right now. I'm waiting for you. I'm still waiting. Okay, fine. Let's continue with the video. Okay. So in the end of that clip, I asked you a question that how will you do this just by using where? How will you print 0123 by using where only instead of let? So how will you do that? You're going to use closures. So we're going to create a closure over here. Let's say inner and it's going to take I as a local variable. And I'm going to put all of this inside of this closure. And we will call this inner closure and pass the eye to it. So what's going to happen is every time this I is passed to this function, it is not going to reference just like we discussed, it's not going to reference that particular memory value. It's going to create a whole different memory space for this function right here for every time this loop runs. So we're passing I over here. And now I will be a local variable inside of this function rather than taking it from our outer scope. So let's run this. And yep, you can see we get this output 012. Awesome. So the next question is how would you use a closure to create a private counter? So what is a private counter? Let me show you. So if you create a function right here, called counter. And we don't take anything inside of it. And we have a variable counter equals zero. So I've put underscore over here because this is a convention when we create private variables, we put underscore before that, you don't have to follow this, but it's a good practice. So how can we create a private counter? So we already know that we can't access this variable outside of this function, right? So how are we going to update it? So I'm going to create a bunch of functions inside of it. First one will be the ad, which takes an increment variable by how much value is this going to be incremented? So this is going to return number, that's increment. So it's going to add this increment to this counter. And you know what, we don't need this return statement, my bad. So we're just going to do this, it's just going to add this increment to counter. Cool. Then we'll have another function, which will retrieve the value of counter. It's going to say return, counter, counter equals, and I'm going to provide the counter, just like that. Now we're going to return both of these functions. So I'm going to return, add, and retrieve, just like that. Cool. So let's go on and initialize this counter right here. So I'm going to say, const c equals counter. So this has created a new counter, a private counter. So what we can do is we can say c dot add, and we can provide it value, let's say five. So it's going to add five to that counter. And let's say if we provide it value, let's say 10. So after this, the counter should be at 15, right? So let's go on and call retrieve and check. So let's see, in our browser. Okay, I think, oh, yeah, we're supposed to console log this. Since it's returning the value. All right, so counter equals 15. So this is what a private counter is. We are not directly manipulating the counter. We are using these functions right here to manipulate the value of this private variable or a private or the private counter. Now there's a similar concept, which relates to this one, which is called a module pattern, which we're going to discuss in our next question. So if you can ask you this question, that what is a module pattern? So a module pattern looks something like this. So we have a if we write here, and we have a private function inside of it. And we have a public function which we are returning to the user. So user can make use of this public function. And this public function, we can write a code inside of it, which can call this private method right here, or the private methods or private variables of this module right here. So they will not be accessible outside of this module pattern. So private functions are not returned. Not returning these functions makes them inaccessible outside of the module namespace. But our public function can access our private functions, which makes them handy for like helper functions. For example, if you're supposed to make an API call inside of it, but we don't want the user to access it directly. So we can just use our public method to let's say manipulate it in some way so that it works exactly as the developer wants it to work. So in these cases, module pattern helps us a lot. So let's say if we go on and console log public. And we put this inside here called private method, module dot public method. And we called module dot private method. So this will be called, but this will give us error. So let's see. Yep, this is called and this gives us module dot private method is not a function because it's not going to be returned from that function. Cool. I would highly recommend you to go and read more about module pattern on your own, because this can be a really important question. And sometimes it's also asked in junior interviews, but mostly in the senior developer interviews. Okay, so next question is that interview provided us this function like the video, like the video. And instead of it, we have this variable view. So view is defined outside. We have declared view variable outside. And we are initializing it inside of our function. And then we are console logging it. So the question is to make this run only once. So if we call this function and again and again, you can see that we get this output again and again. So what can we do to make this run only once? So obviously, we're going to make use of closures. So we're going to create a local variable inside of it. Let's let called it going to be zero by default. And instead of this, I'm going to create a new function. I'm going to return a new function. It's going to be an anonymous function. And instead of this, I'm going to check if called is equals to zero, then I know what I'm going to say if called is more than zero, then obviously, this is already called. So I'm going to console log already, subscribe to roadside coder. And I hope you are also subscribed to roadside coder. Otherwise else, if this is not more than zero, then we're going to take this code and put it right over here. And after this is console log, I'm going to say called plus plus. So that called is not zero anymore. And then we will print already subscribed to roadside coder. So I think they should work first time they should print subscribe to roadside coder. And then after that, it should print already subscribed. Let's see. Oops, my bad. I need to call it first. So I'm going to say let I'm just going to remove this for now. I'm going to say is subs. Cribed. And it's going to take like the video. And now we can call this. So by doing this, what we did is we created a local scope with let called equals zero. And every time we call this, it's going to reference to the same called variable. So let's call it bunch of times. And let's see. So the first time it printed subscribe to roadside coder. And after that, it printed already subscribed to roadside coder. Yeah, so this is what we exactly wanted, which will make this run only once. Now this is not the proper implementation of this once, but you can use it if the interviewer asks you to do something like this. But if interviewer asks you to create a more generic function, then how are you going to do that? Let's see. So actually, there's a library called low dash, which already has an implementation of this once function. So I'm going to go on and create the polyfill for this once function right here. Oh, so let's create a more of a generic function. So I'm going to create a function with the name of once. And it's going to take two things. It's going to take a function. And it's going to take a context, a local context, if there's any context there. Now, inside of this, we're going to create a local variable called ran. And I'm just gonna declare it like that, which will determine if this function has been ran once or not. And after that, I'm going to create a closure, which is going to be anonymous function. And so this I'm going to check if there's something inside of the function, then go inside of it. And ran will be function dot apply. And I'm going to provide the context. If the context is provided, otherwise, I'm just going to provide the this. That is whatever the context of this function is, I'm just going to point to that one by using this. Don't worry. As I've already mentioned that I'm going to bring a complete video on this implicit and explicit binding, which will cover this this variable and call apply bind all of these concepts. So don't worry, that video is coming very soon. So all this apply does is all you need to understand for now that it's giving our function new context and the arguments, if any. So I'm going to pass all of the arguments. And as you know, this arguments will be an array. So I would highly recommend you to go and read about this apply function. If you don't understand how this works, because that will be a little out of scope for this video. So all it's doing over here is it's providing it a new context and a bunch of arguments. Let's say if we have one comma two, comma three, it's going to provide it just like that. Now after this is, now after this runs, it's going to provide the output to this ran variable, and I'm going to put the function to null so that we can not call it again. And after that, we're going to return, whoops, return ran, just like that. And this is our once function right here. Don't worry. I'm going to run this and I again explain you how this exactly works. So let's say I have variable hello, which is a function which console logs hello. So how are we supposed to run this only once? So if I print this multiple times, you're going to see that it runs multiple times. Okay. But when we wrap this inside of this once function that we have created right here, then you're going to see that it runs only once it's not going to run again and again, doesn't matter how many times you call it. So what's happening over here is it takes this function over here. Okay, cool. Now inside of this, we have a closure, which will be returned inside of this variable. The reason how we're able to call this. And then we're checking it if the function has some value. Yes, it has this value. Then we are running this function. And after we run this, it's going to have the result inside this ran variable and function will be null so that we can't run this again. And then we simply return the output of this function. But what if we had some variable, some arguments? So let's say if I pass one comma two. So let's take a comma B right here. And I'm going to print a comma P. And check this. Yep, you see, it's going to run with the provided arguments, because we are providing the arguments right here. So this is how once function is supposed to work. Now for our next question, we have to create the polyfill of this memoize. So what is memoize? So this question was also asked to me during one of my previous interviews. This question was asked to me during my cast 24 interview, which I've already discussed in that video. So I'm going to show you that clip right here. The next question was on implementing a caching or a memoize function in JavaScript. So for example, if you are given with this function, which has some expensive calculation inside of it, which when executed every time takes a decent amount of time to run. So if I go on and run this, so I'm going to use console dot time to measure how much time did this took to run. And I'm going to run it twice actually with the same parameters. Okay, so if I go to console, you're going to see first time it took 40 milliseconds. And second time is also to second time it was 42 milliseconds. So how do we minimize this time calculation? If the parameters of the function are same, we need to cache the result of the previous function somewhere, right? So that is what we are going to implement. So let's say I'm going to go over here at the top. And I'm going to have function, which I'm going to say my memoize. And it's going to take a function which we are supposed to memoize. And we're going to take a context. And you know, let me remove this context for now, I'm going to show you how we're going to use that later. So right now, we're just going to take a function in this memoize. And first of all, let's create a variable for storing our result. So const, rest equals an empty object. So this will be the place where the result for our previously executed function will store or the cache for our function, right? Then after this, I'm going to return a function. And so to this, I'm going to take the arguments from the user after making this a memoized function. Now, first of all, I'm going to convert all of these arguments that we get from this function into a string. So I'm going to say where our cash equals Jason dot string, if I, and instead of this, I'm going to provide the arcs. So what's going to happen is this arcs cash will contain all of these arguments. Now we're going to take this arcs cash and check if we already got these arguments in our cash or not. And if we already got a result for all of these arguments, so I'm going to go down and say if I'm going to check it's at the rest. So rest, our cash. So if we don't have these arguments inside of our object, then we're going to calculate the result for that function. Otherwise, we're just going to return what we already have. So return this thing, just like this. So we're going to return all of the result for that all the time. So for example, if we are providing five and six, so our result object will look like this. So let's say a result of 30. Right. So this is how our rest object will look like. And if it finds out that it already has those parameters, so it's just going to return us this value. So let me write the logic for that. So inside of over here, I'm going to say, I'm just going to add that inside of our res object. So res cash will contain the result of the logic for that function. So function dot call. And now over here, we are going to use that context. So if you are sending any context, I'm just going to provide it. So obviously, this context is going to be optional. So that's why I'm going to say if this context doesn't exist, just use the current context. And obviously, we are going to use these arguments that are being sent to us. So I'm just going to spread all of these arcs as well over here. Cool. So I think this looks good to me. Let's go on and use this. So again, I'm going to show you previously, it gave us this result, both of these times. But now if I go on and memorize this function, so what I'm going to do, I'm going to supply this function. I know what first of all, let me change the name of this function. I don't think this fits the appropriate. So this should be clumsy. Product, that fits better. Yeah. So after this, I'm going to say const. And I'm going to wrap that function. So I'm just going to take this my memoirs and wrap this clumsy product. Just like this. And now since it's going to return us with a function, as you saw over here, return this function. So we are going to get a function inside of this over here. So I'm just going to replace this clumsy product with our newly memorized clumsy product. So now let's find out if it worked or not. Yep. Awesome. So you see, in the first call, it gave us 49 millisecond. And in the second call, it was 0.08 milliseconds. Oops, my bad, I made a mistake over here. So the else is not going to be over here. So this is just going to be returned. So it's just going to check if this is an optional condition over here, it's going to check if it's now if it doesn't exist inside of this array, then just add it to our result and then return it. Otherwise, if it is inside of our result object, then just return it directly. So now you're going to see, yep, now we get both of these result over here. Awesome. So this is how you go on and implement a caching or a memoization function in JavaScript. This is a really important interview question. All right. So our next question, which can also be very frequently asked is the difference between closure and scope. So whenever you create a function within another function, then the inner function is the closure. This closure is usually returned. So we can use the outer functions variable at a later time. So this is what a closure is. Whereas a scope in JavaScript defines what variable you have access to. There are two kinds of scope as we already discussed, global scope and local scope. And in case of closures, there are global scope, outer scope and local scope. So you can give this answer in your interviews and that should be good enough. And these were all of the interview questions related to the closure. All right. Now let's move on to our next topic, which is going to be on curring. And this is a very important section of this video, because you need to give me your full attention to understand this topic, because some people might find this stopping a little bit overwhelming. But this is very important for our JavaScript interviews. While preparing for this video, a lot of interviews told me that curring is the topic whose questions are the one a lot of candidates fail to answer. Just because they don't know how it exactly works or don't have their basics, right? So what is this curring anyway? Curring is a function that takes one argument at a time and returns a new function expecting the next argument. It is a conversion of functions from callable as this into callable as this. And curried functions are constructed by chaining closures by immediately returning their inner functions simultaneously. So if you haven't watched the last video of this series, which was on closures, you can watch that video by clicking on link in the description or I button above. Now, don't worry if you're unable to understand what I just explained by the end of this video, you'll be able to answer most of the questions that can be formed on curring. So let's understand it with an example. Okay, so I've opened VS code over here with basic HTML, CSS, and JavaScript files. And let's understand curring with this simple example. So as I mentioned, we have a function f with params a comma b. And it prints a comma b. So when we convert this type of normal function into this type of format, this is called currying. So let's see how we can do that. So instead of writing this, we can write a function f with param a. And as I mentioned, in currying a function takes one argument at a time and returns a new function expecting the next argument. So we're gonna return a new function. We're gonna keep it as anonymous function with no name and with the b parameter. And inside of this, we're just gonna simply console log a comma b, just like before. Okay, let's try to run this. I'm gonna console log function with value five. Let's see what do we get when we run this much of the code. So let me run this by opening with live server. There we go. Let's go to the console. And in the console, you can see we get another function over here. So how do we run this? We can go over here. And since this is returning us a function, what we can do is we can call it just like this with something else. So let's say if I enter six over here, let's see, what do we get? But you know what? Instead of this, I'm just gonna say return with a and b just like that. So and without this, we get this function return to us. So this is how caring work. This is how we convert a normal function into a function which is carried. There can be a lot of levels to this. We can have more parenthesis over here just like this. So it depends on how deep the caring is. And we're gonna discuss all the types of questions that interviewers can ask you during the interview process. Now there's an interview question where interviewer can ask you why do we use caring? So there can be a lot of answer to this question to avoid passing the same variable again and again to create higher order functions to make your function pure and less prone to errors. So actually, this is more of a theory question. So instead of making this video too long, I've written a blog on caring, which you can check out by clicking the link in the description below and follow along with this video. In that blog, I've included a lot of theory questions and all of the interview questions that I'm going to discuss in this video as we move along. So definitely go and check out that blog with link in the description below. All right, so let's get down to our first question, which is how will you implement this some function like this? And what this function should do is this function should sum all of the parameters that are provided to this parenthesis. So this is actually very similar to the example that I discussed a few minutes ago. So I will highly recommend you to go and try this question yourself first. So pause the video right now and try this question yourself and then continue with this video. So I hope you are able to solve this question. Let's go and understand how we can do this. So as I explained to you, we have a function first. Let's go from scratch. So how I would explain this question to the interviewer is I'll go and explain by creating a normal function first sum with three parameters, let's say a b and c and return a plus b plus c just like that. And if we go and console log this sum, let's say two comma six comma one. So we'll obviously get the output nine, but how do we implement it just like this? So right below this, actually, I'm going to comment it out first. Yeah, below this, I'm going to create another function sum, which takes a and inside of this, as we already discussed, incurring a function takes one argument at a time and returns a new function expecting the next argument, we're going to create a new function, which will give us another argument. So I'm going to create a function, an anonymous function with parameter of b. And after that, I'm going to create, since we have another parameter over here, another parenthesis. So I'm going to return another function with c, oops, c. And inside of this, finally, we can return our answer, which is going to be a plus b plus c. Now, if we go on and run this, sum, a, I mean, two, and then six, and then one, and go and check it out. Yep, we got this same output. Now, if you want to explain this in much more in depth to the interviewer, you can explain this just the way I explained you. So you can start by one parameter, you can say that if you provide it to, that's going to return us a function, which is going to expect another parameter b. And when we provide it b, which let's say we provide six, that's going to expect another parameter, which is c. So we're going to provide it the third parameter as well. And then we are going to get the final answer, which is going to be a plus b plus c. All right, so our next question is this, we need to create a function called evaluate. And we provide it a parameter of some multiply, divide or subtract. So we can provide this either of these operations. And after that, we're going to provide it to parameters over here, which are going to give us the result according to this. So if this is some, this is going to add this, if this multiply, this is going to multiply this, and so on. So we're going to go on and create a function over here, called evaluate. And first thing that is going to be taking is this type of operation. So I'm going to give this operation parameter. And so this is obviously going to return another function because it because it is expecting another argument. So we're going to provide it. We're going to return another function, which is going to be anonymous function. And I'm going to give this let's say a and inside this, it's going to be expecting another parameter. So I'm going to return another function, which is going to have a parameter b. And now inside this with respect to this operation, we're going to give the output. So I'm going to check if operation is equals to sum, then return a plus b. And so on. So let me write this quickly, just like that. Otherwise, let's return if the none of the operations are there, then I'm just going to return invalid operation. Cool. All right, let's try to run this. So I'm going to say evaluate. And I'm going to write some over here. And I'm going to provide this. Let's say four and two. Let's see what do we get. Oh, I need to console log this. All right, we got six over here. Let's see, we will try to give this multiply. Okay, we got multiply. So we so you can write this actually in some other way as well. So I'm going to create a const m u l. And I'm going to provide this evaluate. multiply. So this is one of the use cases of carrying. Since we have provided this multiply over here, this will always perform multiply. So you can reuse this and number of times. So if I go and console log, mul and mul will all obviously will have this function returned to it. So we can say, three, five, which should give us 15. And we can reuse it again. Let's say two and six, which should give us 12. So we should have 15 and 12 as an output. Yep, just like that. So you see, this is one of the use cases of carrying that we initialized our function once with multiply or whatever that we wanted to. So we will not initializing it again and again by providing multiply every time we call this. So we just provided it and initialized it once. And now we can use this mul function over here to multiply these numbers again and again. So during the interview, you can explain all of these things to the interviewer and the interviewer will really be impressed. Now our next question is on infinite carrying. So what is infinite carrying? So interview will ask us to write a function, which we can call just like this with n number of parameters. So if you have function like this, some, and we can say one, one and two. So this should give us three, but we can also call this function like this. We can add four, five, or we can add n number of parameters after this. And this should be flexible according to the number of parameters and should give us the answer accordingly, which in this case is going to be 12. So how do we do this? So this question was actually asked to me during my cast 24 interview. And I've already discussed in this cast 24 interview experience video. So I'm going to go on and play that clip right here. So the interviewer provided me with this code snippet. And he asked me to implement this add function. So let's see how we can implement that. So we create a function called add. And it takes a parameter. Let's say a. Okay. So we have a bunch of parameters over here. So it's obviously going to return a function. Then we are going to call that function with another parameter with another parameter. So it can go infinite. Right. It's not it's just not that we have to implement it till five to four, five. And then that's it. Because that will be easy. Right. So if I so let me remove this complexity for now. And I'm just going to implement with just two parameters. So this function a and it's obviously going to return a function. So I'm going to say return function B, let's say, or let's say an enormous function. And it's going to take B and then inside of it, I'm just going to return another function, which will have let's say a plus B. Okay. Right. So now if we go on and execute this, you're going to see we get the output as seven. Yep, just like that. But we don't want that. We don't want this much complexity. Right. So we want to create, we want to write a code which works infinitely. So if I let's say go on and add for and it over here, this should adapt to that code. So what I'm going to do, I'm going to remove this inner function. And I'm going to say we have two of these. But then I'm going to check if we have any more params or not. So I'll check if B has a param, then just return this add again, I'm just going to provide the value of a plus B and just continue this so a plus B. And that's it. But if B doesn't have any value inside of it, that means it's coming to an end. So I'm just going to return a. So let me explain this again to you. So let's say we have five, two, four, eight over here. So first of all, we provided it with the five and it returned us a function. Okay, so then we again called it with two, we called B with the two. But if it's going to check if two is there or not, if there is some value inside of B or not only then it's going to return the addition. Otherwise, it's just going to return the initial five value, the sum of those numbers up until that point. So okay, we did have two at that point. So we said, okay, if two is there, then return a plus B. So five plus two was returned. So five plus two, that is seven went inside of this function. So now its value is seven over here. But then again, it's going to return another function. Then it's going to check if we are calling that function as empty. But no, this is not empty. It has four inside of it. So then again, it's going to check if there's something inside of the B, then return a plus B. So at this point, a value was seven. So it's going to say seven plus four, that is 11. So it's going to pass 11 to that. So this cycle will run again and again and again, until we reach this point. So up until this point, the value was 19. So then it's going to have a 19 value over here. And it's going to return a function again. And then it's going to check if B has something, but here B doesn't have anything. So it's not going to go inside of it. And it's just going to return a that is 19 from here. So our answer is going to be 19. Yep, we got this output over here. Now the next question that the interviewer can ask you is the difference between carrying and partial application. Now what is this partial application? Let's see. Now you may have started to think that the number of nested functions are carried function has depends on the number of arguments it receives. And yes, that is what makes it a curry. Let's take some example. So if we have a function sum with a and it returns another function, which has B, C, and then they return a plus B plus C, just like that. And this can be called like this. And we provide it 10. And then we can call x like this. Let me console log this. Or it can be called as some. It can be called directly as. So you get what I'm trying to explain, right? So it can be called in either of these ways. So you get what I'm trying to explain, right? It can be called in either of this or these ways. So these function expect three arguments and has two nested functions. And like our previous version that expect three argument and has three nesting functions. So the first question that we discussed in which the sum had three nesting functions and had three arguments. So that is what our statement was right, that the number of nested functions are carried function has depends on the number of arguments it received. But in this case, that is not the case. In this case, we have three arguments, but we are only returning two functions over here. So this right here is not currying. We just did a partial application for this some function. What partial application does is partial application transform a function into another function with small arity. Also, if you don't know, arity just means the number of operands or the arguments are function receives. So if we were to write this same function with the currying, we would have written it something like this, because in this we have three arguments and we are returning three functions. But in this, we have three arguments, but we are returning only two function. So that is the difference between currying and partial application. This right here is partial application. Now, in some cases, interviewer can ask you to explain a real world scenario for using currying while developing our web applications. We can actually use currying to manipulate our DOM as well. So let me give you an example right here. And you can give the same example to your interviewer as well. So I'm going to go to the HTML file. And I'm going to add another h1 tag over here called hello pewsh. And here it is. Now I'm going to go to our JavaScript file. So right here, I'm going to create a function called update element text. And this is going to take an ID. And inside of this, I'm going to create another function, which will take content. And inside of this, I'm just going to write document dot query selector. And I'm going to provide this the ID has tag ID. Oops. Just like that. Dot. And I'm going to update the text content to be the content provided right over here. Now, what we can do is we, since we have an ID over here, oops, I haven't provided the ID. So let me give this ID of heading. Let's take this ID. Now what we can do over here is we can just initialize this function with our ID once, and we can update the text of our heading again and again by calling this the function that will be returned from this. So let me show you so const update header. And I'm going to call update element text. And I'm going to provide this this heading ID. Now we can use this update header again and again, every time we want to update the text inside of this heading right over here. So let me show you, I'm just going to call update header right here. And I'm going to say hello, roadside coder. And let's see, yep, you see, we have updated it, or we can write right to roadside coder. And you see, it has been updated. So yeah, we can use this function again and again in our code, according to let's say the condition, if we click on a button, we can call this function again and again, we don't need to use query selector again and again by providing it the ID, we just need to initialize it once and we can use it just like this. So yeah, you can give this answer to your interviewer and they will definitely be impressed and think that you've used carrying in your apps before. Now do you remember, in the beginning of this video, I gave you an example on how we can convert a function like this into this. And this is what a carried function is. So how about we write a function called curry, which converts this function into this function. Now this is the most important question of this video. Now this question is usually asked during the senior interviews, but can sometimes be asked during junior interviews as well. So let's start a function called curry, which converts a normal function into a carried function. So I'm going to write function curry. And this is obviously going to take a function. So I'm going to provide a function right here. And this is going to return as a carried function, which will look something like this. So I'm going to return carried function or just carried funk. So this is going to take all of the arguments of the function in the form of the array. So R X right here will be the array of all of the arguments. So what we'll do over here is I'm going to check if function dot length is more than equals to R X dot length. So that is what carrying is right if the function dot length is equals to R X dot length, because the number of argument has to be the equals to the number of functions returned. So if it's not equal, then what we'll do is this is this is actually our base case to check if it's not, then we're going to return a funk with R X else. We will return a function which will collect all of the next arguments that are going to be returned to us spreading the values of the arguments first and then the next arguments calling the carried funk recursively. So let me show you it. It's going to be a little confusing, but don't worry, I'm going to explain you after writing this whole thing. So let me write this out first. So return function with all of the next arguments. And instead of this, I'm going to call this carried funk with arcs and of the next arguments until this becomes more than all of the arguments of function length. So yeah, let's test this out. And I'm going to explain to you after that. So we have a function sum over here. And inside this curry function, we're going to provide this some function right over here. And the inside this total sum, we will have this carried funk. Now this thing will be a carried function. So I'm going to call it just like this. So let's see, we should get the output. Oops, I made a mistake over here. So I'm going to check if arcs dot length is more than equals function dot length. Yeah, now let's see. So yeah, we get this output six. Now let's understand how this whole thing is working. So we've created a function sum over here, right, which takes four arguments. And it calculates the sum for it. Okay, then we have created a variable total sum over here. And we're passing this sum function to this curry implementation that we have done right over here. Okay, cool. Then we're calling this total sum just like this in a carried way. So let's see what's happening. We've provided this one to this. So obviously, when we do this, this is going to return as a function, which is going to be this carried funk, right? So we have supplied it one first of all. So one will be supplied to it. Then it goes inside of it, it's going to check arcs dot length. So arcs length right now is just one. So let me show you, if I go on console log, and I'm going to say arcs dot length. And I'll also do funk dot length. Oops. First time the number of arguments were one, and length of the function was four, that is these four functions. Second time the length of argument was two, then three, then four. And the moment the number of arguments exceeded, it's going to call this function right over here with all of the arguments. So I'm going to explain you as we move along. So let's do this step by step. So I'm going to comment this line now. So yeah, first time we have called it with this one. So it's going to check arcs dot length. So I sort length right now is one, obviously, it's not more than the function dot length. So it's not going to go inside of it. It's going to go over here. Now this is going to call this carried funk over here, recursively. So what this will do is this will return us a function expecting next arguments. So if I remove this for now, and run this, you're going to see that it returns us another function, which is expecting the next arguments, because obviously the criteria for this is not satisfied, carrying means the number of arguments should be equal to number of functions. And the number of function has to be four, since the number of arguments are four, the number of functions are also supposed to be four, only then this is going to run. So if we provide it another, let's say six, then again, it's going to expect the next argument, because then it's going to go over here with six. And now arcs dot length is two. So over here, it's going to check arcs dot length two is not more than function dot length. Okay, so it's not going to go over here, it's going to come again over here. So in the case of third argument as well, it's going to again expect you to supply the next functions. But the moment we supply it with the fourth argument, what it's going to do, it's going to take all of these and provide it to this sum function, that is this function right over here. And when we run this, you're gonna see, we have successfully calculated the sum for all four of these. Now you can write any function over here, and this is going to make it a carried function. This is how much powerful this function is. Now I know this is a little bit confusing to you, but try to rewind the video and rewatch my explanation that I did just now, you'll be able to understand it properly. So yeah, that was carrying in JavaScript. And if you liked this video, give this video a huge fat thumbs up and subscribe to the channel for more such awesome interview videos.
