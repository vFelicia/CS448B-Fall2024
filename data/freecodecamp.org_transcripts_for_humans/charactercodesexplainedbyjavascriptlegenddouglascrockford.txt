With timestamps:

00:03 - it really is great to be back I used to
00:08 - live about a mile from here just on the
00:09 - other side of the freeway there used to
00:12 - be a computer industry in Orange County
00:14 - that actually built Hardware built of
00:16 - many computers it's all gone now I guess
00:21 - but you're still here so it's really
00:23 - great to see all of you thank you
00:25 - everybody for helping to set this up and
00:27 - to provide us of this place and thank
00:29 - all of you so much for coming out
00:31 - tonight so I want to do for you tonight
00:34 - a brand new talk I have never done this
00:36 - one before I think it's a really
00:38 - important topic it's a really
00:40 - interesting topic it turns out the way
00:42 - our character codes work has a
00:45 - tremendous impact on how we think about
00:48 - programming and and how this whole
00:51 - professional operates a lot of stuff is
00:54 - implied by the way we handle characters
00:56 - computers are machines that manipulate
00:59 - numbers that's all computers can do
01:01 - that's literally all we can do but by
01:05 - assigning numbers to characters we can
01:09 - do text processing and all this
01:11 - information stuff happens and I'm gonna
01:15 - talk about where this stuff came from I
01:17 - think this is gonna be an interesting
01:19 - talk it's certainly interesting to me I
01:22 - love this stuff and we're gonna be
01:24 - talking a lot about the history of this
01:25 - stuff but I have not been able to figure
01:29 - out how to end this talk and I've done
01:33 - this before I've gone out and I've had a
01:35 - talk and I really like this talk and I
01:37 - go out and I don't know how to end it so
01:39 - I just go to the end and say thank you
01:41 - goodnight knowing that I you know it
01:45 - deserved a WoW finish but I didn't give
01:47 - it one because during the UA or B in the
01:51 - QA I'll get questions and some of the
01:54 - questions will will indicate that I
01:57 - completely failed and trying to describe
01:59 - what this is because the question just
02:01 - completely missed it
02:02 - but sometimes the question will focus me
02:06 - on what the whole thing was about and go
02:08 - yes thank you
02:09 - this is the moral of this story so I'm
02:12 - hoping that will happen tonight
02:13 - so you know I'm counting on you okay you
02:17 - have a part to play
02:19 - so character codes don't start with
02:22 - computer systems they start first with
02:26 - data communications or communications in
02:30 - general just human communication and
02:33 - then data processing and eventually
02:36 - communication and data processing come
02:38 - together in computing so we're gonna
02:41 - start at the very beginning the first
02:43 - character set the morse code designed by
02:47 - a samuel morris an american portrait
02:50 - painter he also had a hobby in
02:54 - electricity and he worked with some
02:58 - partners to develop a telegraph and
03:00 - Morse put together the code that
03:03 - transmitted words across their Telegraph
03:07 - and it's a very very simple code because
03:10 - they're telegraph all I could do was
03:12 - transmitted to States it was either on
03:15 - or it was off so Morris figured out a
03:19 - way to turn that into a communication
03:20 - channel so he has a language that's made
03:25 - up of two symbols dot and dash and we
03:29 - can represent these in binary so a dot
03:32 - is a single one and a dash is three ones
03:37 - and then in order to tell the difference
03:40 - between the dots and the dashes he need
03:42 - to put some zeroes in between them so
03:44 - he's got zero for the particle space
03:47 - that's the small separator between a
03:50 - zero and one and then there's a letter
03:52 - space which will be the space between
03:55 - the letters and then a word space which
03:58 - goes between the words if you're a
04:01 - musician it's easier to think about this
04:04 - musically so you can think of a dot as
04:07 - an eighth note and a dash is a dotted
04:11 - quarter note and then an eighth rest is
04:15 - the particle space a dotted quarter rest
04:19 - is a letter space and approximately a
04:21 - whole rest is the word space so here's
04:26 - an exam
04:27 - four letters representing the Morse code
04:30 - so the letter T is a dash letter eyes
04:33 - two dots letter M is two dashes and an
04:36 - EE is a dot
04:37 - so horse took a look at the frequency of
04:41 - letters in English and chose the most
04:44 - popular letters they have the shortest
04:46 - codes so this is not only a
04:48 - communication code it's also a data
04:51 - compression code it's the first data
04:53 - compression code and it it's a code that
04:56 - works in time most of our codes work in
04:59 - space you know you can think of a word
05:01 - containing some number of bits or even a
05:03 - packet containing some number bits but
05:05 - this is a because it's musical it's all
05:08 - happening in time so remembering the
05:11 - word time will help you to remember
05:13 - these symbols that the consonants are
05:15 - dashes the vowels are dots and the most
05:20 - frequent frequent things like the e will
05:22 - get the shortest code okay so you now
05:24 - know four of the letters in the Morse
05:27 - code in fact I'm going to teach you all
05:30 - 26 letters of the Morse code because you
05:33 - might need it someday you might be
05:35 - trapped in a mine or on a disabled
05:38 - submarine and you're gonna need to be
05:41 - able to get a message out and all you're
05:43 - gonna be able to do is tap on the hole
05:44 - with a rock or something but you'll be
05:47 - able to do it because you're going to
05:48 - know the Morse code okay the fifth
05:51 - symbol is the V which we can get from
05:56 - the V for victory Beethoven's fifth so
06:00 - you all remember Beethoven's fifth
06:02 - symphony begins
06:03 - dah-dah-dah-dah dot dot dot dash okay
06:07 - that's the letter V okay V for five you
06:13 - all know the SOS of the International
06:16 - distress signal its dot dot dot dot dot
06:18 - dot if we break it down into letters the
06:24 - S is three dots and the O is three
06:27 - dashes this is the opposite of the dash
06:33 - is being consonants but you know we got
06:36 - a couple exceptions so you can remember
06:37 - that right so dot dot dot is s dash
06:40 - - - is Oh a chisel of tricky to remember
06:45 - it's for dots so I recommend you think
06:50 - of the 4-h club and and the advisor to
06:54 - the 4-h club mr. 4-h himself Harry
06:57 - Herbert Hoover Hever okay for the rest
07:04 - of the letters okay so you now know six
07:06 - letters right for the for the next
07:08 - twenty we're gonna have some mnemonics
07:10 - and this is helping em onyx are gonna
07:12 - work so I'll give you a letter and I'll
07:15 - show you the the Morse code for that
07:17 - letter and then I'll have an English
07:20 - word which contains that letter in which
07:23 - the dot corresponds to a vowel and the -
07:27 - corresponds to a continent consonant so
07:30 - a is for M everybody got that
07:34 - and everybody understanding a okay let's
07:40 - move on
07:42 - B is for bow B my bow it's it's
07:49 - beautiful isn't it not my friend
07:51 - c is for Coco everybody loves Coco right
07:56 - you love Coco that's why you can
07:58 - remember that c is for Coco this next
08:01 - one is going to be really shocking and
08:03 - upsetting
08:03 - D is for die but because it's so
08:08 - shocking you're gonna remember this one
08:10 - the D is for die e you've already seen
08:14 - he is one of the the time things it's
08:17 - one dot and F is for Fe that's right
08:23 - Luffy everybody say you fee
08:27 - okay so AM Boko code ie goofy everybody
08:31 - with me so far we're learning the Morse
08:33 - code G is for ganoub for programmers
08:38 - that should be a really easy one G canoe
08:41 - G canoe is that outfit that gave us a
08:45 - failed UNIX clone and a software license
08:49 - in which free is not free right
08:50 - everybody knows that one
08:53 - we've already seen h the 4-h club Harry
08:56 - Herbert Hoover Hever I we've already
09:00 - seen i-i-i write two dots and I J hey J
09:09 - what do you say hi JJJ you what I JJJ
09:19 - k is for a kit right that's easy kit
09:23 - okay get up maybe yeah K and L is for
09:30 - soothing aloe you can't forget that L 4
09:33 - L oh of course
09:34 - so canoe 4-h III ajjj kit and aloe
09:41 - everybody still with me let's learn some
09:44 - more M we already saw is one of the time
09:48 - letters it and it's good
09:51 - mmm good that's the letter M is good and
09:57 - oh no got it okay we already saw Oh from
10:05 - the SOS P is for Expo you might imagine
10:11 - next year there's going to be a big Expo
10:14 - in which they're going to announce a
10:16 - better mnemonic for the letter P so
10:18 - we're all looking forward to that Q is a
10:22 - bit tricky cuz it's hard to make words
10:24 - out of Q so whenever you have a Q you're
10:27 - likely to have a you after it so we got
10:29 - that pair and we're gonna wrap it in
10:31 - quotes but we don't have quotes so we'll
10:34 - use the letter Q for the quotes because
10:36 - Q is for quote and so we get Q qu q okay
10:42 - got it
10:44 - r is for era this is the era of Morse
10:48 - code are ya okay s we already saw in the
10:54 - SOS and the distress signal
10:56 - we already saw T in the time letters you
11:03 - out o UT out
11:07 - okay we already saw a V Beethoven's
11:12 - fifth I thought but the W is for the
11:16 - wise old owl that's easy to remember
11:19 - w and the owl because he's so wise X X
11:25 - is another hard one but fortunately X
11:27 - rarely happens in English so we're safe
11:30 - but you know it's XO o X you're not
11:33 - gonna remember that but you'll probably
11:35 - be okay
11:37 - then why yuck
11:41 - so you know if there any little kids
11:45 - here I don't see any little kids if
11:46 - there were any little kids the two
11:48 - symbols they're gonna remember tonight
11:49 - are goofy and yuck that's for sure and
11:53 - then finally at the end of everything is
11:56 - Z of course so what comes after zu z zu
12:01 - right that's the end right z zu is the
12:04 - last so you now know Morse code you're
12:09 - not good enough to get an operator's
12:10 - license but you could probably recall
12:13 - this and make a list and then you can
12:15 - tap it out you know you might be on that
12:17 - disabled spaceship and you need to alert
12:19 - the fleet you're gonna be able to do it
12:22 - someone's gonna say my god that's Morse
12:24 - code and we'll be saved
12:28 - okay so moving on the next
12:32 - communications code was the Bedok code
12:35 - which was invented by emil Bedok it was
12:38 - a French calligrapher he wanted to
12:43 - improve on the Telegraph so instead of
12:46 - the operators having to be entering a
12:49 - stream of bits that instead you would
12:53 - have a keyboard that would look like a
12:55 - musical keyboard with five keys on it
12:58 - and you would chord in the letters that
13:01 - you want so you would have to memorize
13:03 - the letters in order to get them in and
13:06 - this keyboard would be attached to a
13:09 - paper tape punch which would produce a
13:12 - string of paper tape with the holes in
13:14 - it and then that could be transmitted
13:17 - there was another guy who came on
13:20 - so if ever heard of baud rates which is
13:24 - yeah the couple the old-timers going out
13:27 - I remember baud rates bada is usually
13:30 - bit well it actually means bits per
13:33 - second but yeah it's slow is also
13:35 - another meaning so it was named after
13:38 - this guy so Donald Murray who is a news
13:43 - New Zealander
13:44 - improved on the DOE system he came up
13:48 - with a much better keyboard so it had a
13:50 - button for each of the letters and so
13:52 - the operator didn't have to memorize the
13:53 - binary code so you just go punch punch
13:55 - punch punch and he could have picked any
13:57 - keyboard and unfortunately he picked the
14:01 - QWERTY typewriter keyboard the QWERTY
14:04 - typewriter a keyboard is terrible by
14:07 - design in order to try to prevent the
14:10 - jamming of the mechanical keys you know
14:13 - it wasn't completely successful in doing
14:15 - that but that's why it's got that
14:17 - bizarre layout and Murray could have
14:20 - said well we don't need to do that
14:23 - because you know when you push a button
14:26 - we're closing a circuit which is gonna
14:27 - drive some pins through some paper tape
14:29 - so it doesn't matter what order we put
14:32 - the keys in he could have done something
14:33 - rational but he didn't and so we're
14:36 - still stuck with the QWERTY keyboard
14:37 - everywhere this is the first time QWERTY
14:40 - is used in electronic communication and
14:44 - and it's still being used in electronic
14:47 - communication so this is a refinement of
14:51 - the code that those two guys worked on
14:53 - and it became a standard one of the
14:56 - first telegraphy standards this is
14:58 - International Telegraph alphabet number
15:00 - two it was a 5-bit code which allows
15:04 - them to encode all of the letters Murray
15:07 - scrambled the codes around in order to
15:10 - reduce wear on the machinery so that
15:13 - instead of optimizing for time he was
15:15 - optimizing for bits where each bit would
15:19 - cause a needle to drive a hole into a
15:24 - piece of paper and those pins would wear
15:30 - out and so in order to reduce wear on
15:32 - the machinery he
15:34 - have the most common codes have the
15:36 - smallest number of bits so for example e
15:41 - is a very popular letter it only has one
15:45 - bit and T is also a very popular letter
15:47 - it only has one bit and since the
15:50 - operators didn't see the codes it didn't
15:52 - matter that they were kind of random
15:54 - then there's a code for space carriage
15:58 - return and line feed two separate codes
16:00 - because that's how his printer worked
16:04 - the most interesting thing that bodo did
16:07 - was he added a couple of shift keys so
16:12 - there's the figure shift and the letter
16:13 - shift so when you're in letter mode you
16:16 - get these codes and when you're in
16:17 - Figure mode you get these codes so that
16:19 - gets you the digits and the special
16:21 - characters which was a really clever
16:25 - idea so they managed to get you know 60
16:28 - or so characters in just 5 bits and they
16:32 - decided to have 2 codes instead of 1
16:34 - they could have just had a toggle shift
16:36 - but there was a concern that the
16:40 - telegraph lines were very noisy and if
16:42 - there was a line hit then a shift code
16:45 - get get garbled and that means
16:47 - everything after that is going to look
16:49 - wildly wrong so to make the system a
16:52 - little bit more resilient they have two
16:54 - independent shift codes so the next step
16:58 - happens a bit later the Hollerith code
17:01 - so Herman Hollerith developed a data
17:05 - processing system using punch cards for
17:08 - the 19 or for the 1890 census the US
17:12 - Constitution requires that every 10
17:14 - years we have a count of everybody so we
17:17 - can figure out how to staff the House of
17:24 - Representatives and it was taking too
17:28 - long to do with pen and paper so
17:30 - Hollerith figured out a way to do a lot
17:32 - of that work mechanically and that
17:35 - turned out to be a big business a number
17:37 - of companies were formed and after a
17:40 - series of acquisitions and mergers in
17:44 - event tolerance company eventually
17:46 - becomes international business
17:48 - machines or IBM and in 1928 IBM wanted
17:53 - to figure out a way to get more
17:54 - information onto the cards because with
17:57 - Hollerith little circular punches they
18:00 - can only get so many characters and they
18:02 - wanted to get more so they came up with
18:04 - a system in which they could get 80
18:07 - columns on a card each card had 80
18:11 - columns and twelve rows in which you
18:15 - could punch holes and at the top there
18:17 - was a blank space where you could print
18:19 - stuff with ink so that humans looking at
18:22 - the card could figure out what it said
18:24 - although people who were skilled with
18:26 - this code could actually look at the
18:28 - punches and tell you what it said so
18:32 - they came up with a very straightforward
18:36 - way of encoding the characters so first
18:40 - if in the top line it's called the
18:44 - twelve row or the 12 punch or the X
18:47 - punch or the plus so if there's a punch
18:53 - there then you get a plus sign the next
18:55 - row you get a minus sign and then 0 1 2
18:59 - 3 4 and so on to 9 ok pretty
19:02 - straightforward and they wanted to be
19:04 - able to do letters too so letters are
19:07 - slightly more complicated each letter
19:09 - requires two punches because we've used
19:11 - up all the one punch codes so we use the
19:18 - the plus Rho and the digits one through
19:23 - nine and that gets us the letters A
19:26 - through I and then we do a similar thing
19:29 - with the minus row and the digits 1
19:32 - through 9 and that gets us J through R
19:35 - and we do a similar thing with the zero
19:37 - row but this time going 2 to 9 to get S
19:41 - through Z this pattern should give you
19:45 - 27 letters but we only need 26 so they
19:49 - needed to drop one of the codes and the
19:51 - code they decided to drop was 0 1 and
19:54 - the reason was that you had two holes
19:58 - with just a tiny little piece of paper
20:00 - between them and there
20:01 - a concern that given the crude machines
20:04 - of the time that they were using metal
20:07 - wire brushes to sense the holes in the
20:10 - cards that it could rip the card which
20:14 - could cause the machine to jam or cause
20:16 - bits of little pieces of paper to
20:20 - accumulate in the machine and eventually
20:22 - catch fire so to avoid that hazard they
20:25 - skipped that code but then you could
20:28 - have three-letter codes or different
20:31 - combinations of two whole codes to do
20:34 - the special characters and unfortunately
20:37 - that never got standardized very well so
20:39 - different machines would have different
20:42 - codes so taking a deck of cards and
20:45 - moving it from one system to another
20:46 - could get really complicated because all
20:49 - the special characters could get
20:50 - misinterpreted so now we finally move
20:54 - into computing when computing starts in
20:57 - the late 40s the first computers have
20:59 - six bit character sets these machines
21:02 - were mostly concerned with computation
21:05 - mathematical computation and so six bit
21:08 - character sets were were fine so this is
21:12 - one that was used at IBM their character
21:16 - set was based on a praetor that they
21:19 - were using with their punch card
21:21 - equipment which they modified in order
21:25 - to work with some of their early
21:26 - computers and so their printer only
21:31 - could print 48 different characters and
21:33 - so they left a lot of these codes blank
21:36 - and they had a few weird characters like
21:39 - like that so what is that I don't I
21:43 - don't know what it is oh it's called a
21:45 - square lozenge I don't know what it
21:47 - means but it was on their punch card
21:49 - equipment and so people would use it
21:51 - because there weren't very many
21:52 - characters available so that meant
21:55 - whatever you really wanted it to be you
21:57 - would use that because that's that's all
22:00 - it is you know they didn't put a plus
22:02 - sign in it which is like I don't
22:05 - understand as so the next step forward
22:10 - is Fortran Fortran is the first really
22:14 - successful programming
22:15 - which kind of changes the world it was
22:17 - also developed at IBM and it gets poured
22:21 - into all of the IBM machines and then
22:23 - everybody else makes their own Fortran
22:25 - systems as well it's the first big
22:28 - programming language and the guys who
22:31 - were designing Fortran couldn't figure
22:35 - out a way to make a programming language
22:36 - out of that so they said we need these
22:41 - additional characters and so they just
22:43 - said if you're going to have Fortran
22:45 - you're gonna have to neat have to get
22:47 - these characters somehow and so IBM said
22:50 - okay we'll try to figure out how in our
22:52 - next printer we can we can add those so
22:55 - in a later version of the there be CDI C
22:59 - code they've added more characters so
23:04 - something that's weird about this you
23:06 - look at the arrangements of a and J ass
23:11 - what they did was they just took the
23:13 - Hollerith code and pushed it into the
23:16 - characters head okay so we have an
23:18 - expectation that each letter is going to
23:21 - be one away from the next one but that's
23:24 - not the case here you know
23:26 - I plus one is question mark not J okay
23:30 - so it's gonna be a little challenging
23:32 - you know write a sort routine for this
23:34 - character set okay and they got some
23:38 - weird characters like these guys so they
23:46 - they created a magnetic tape system to
23:48 - work with this computer and they
23:51 - reserved these four codes has special
23:53 - marks on the tape and they recommended
23:57 - that you never use these codes in your
23:59 - programs because if you try to write
24:00 - those codes to the tape it's going to
24:02 - screw everything up so they picked
24:05 - characters that they thought no one
24:06 - would ever want to use then they had a
24:11 - problem they started selling stuff in
24:13 - Europe and found that this isn't enough
24:15 - letters that you know like in
24:18 - Scandinavia they need three more letters
24:20 - and so they decided well you can take
24:23 - those letters and/or those characters
24:26 - and replace them with letters in
24:27 - whatever country you're in
24:29 - so this kind of begins the I 18n problem
24:32 - that this is where it starts and it took
24:35 - a long long time to fix it now turned
24:39 - out every company had their own
24:41 - character set so for example control
24:43 - data started with the IBM set but kind
24:47 - of changed a little bit because they
24:49 - were more into scientific computing and
24:51 - so they added some characters that they
24:52 - thought people who are programming about
24:56 - numbers we care about things like not
24:58 - equal less than or greater than angle
25:02 - brackets or less than or greater than
25:04 - that's good stuff right another company
25:09 - that was doing brilliant work the
25:11 - Burroughs 5000 series is maybe one of
25:14 - the most interesting architectures ever
25:16 - designed and they're still doing the IBM
25:20 - thing except that kind of straightened
25:22 - it out a little bit at least a comes
25:24 - before s now so that's good and I really
25:28 - like that they put zeros at the top row
25:30 - that means the character code for 0 is 0
25:34 - does that make sense that absolutely
25:36 - makes sense that's brilliant as a
25:38 - programmer I love Burroughs I that makes
25:41 - so much sense to me and are pretty good
25:43 - my set oh and they got an arrow which is
25:47 - what we should have had for the
25:48 - assignment operator Fortran didn't have
25:50 - this because they just didn't dare to
25:53 - ask for another character and so they
25:56 - were forced to use the equal sign for
25:58 - assignment because they had no other
26:00 - options and we're still doing it it just
26:03 - doesn't make any sense we should be
26:05 - using that re that that makes sense so
26:09 - the US Army is buying lots of computers
26:12 - and you know each of its computers comes
26:16 - from a different company and they all
26:17 - have different character sets and trying
26:19 - to exchange information between all
26:21 - these machines was really really hard so
26:23 - they decided to fix the problem being
26:26 - the government so they created a
26:28 - character set of their own called field
26:30 - data and field data was a 7-bit
26:34 - character set which was intended to run
26:37 - on all army computers and that would let
26:40 - them communicate
26:42 - but because it was a and there's some
26:45 - pretty reasonable stuff so they finally
26:46 - fix the alphabet right so it it's all
26:49 - continuous so I like that a lot and it
26:53 - still got some of these weird IBM
26:54 - characters in it but you know that's
26:57 - okay and some of these could be replaced
26:59 - by other characters for and for some
27:04 - reason they they moved all of these
27:06 - characters up to the top half of the
27:08 - seven bit character set and they leaved
27:10 - the left the bottom half of the seven
27:12 - bit character set undefined so there
27:16 - were a number of projects in the army
27:17 - that started working with this character
27:20 - set and they liked it it worked well and
27:22 - they hadn't need for lots of extra
27:24 - characters and there was all this you
27:26 - know 64 characters that weren't being
27:28 - used so they just started using them
27:30 - which was fine for them until the army
27:33 - wanted to make all of these programs
27:35 - work together and they didn't because
27:37 - everybody saw that there was a hard
27:41 - lesson there that you really have to
27:43 - nail stuff down in a standard if you
27:45 - leave too much stuff free then
27:49 - programmers will abuse it as a result
27:51 - you'll lose interoperability or quality
27:54 - or whatever it is you're trying to get
27:56 - so the next big step forward is ASCII
27:59 - anyone heard of ASCII yeah ASCII is a
28:02 - big deal the American Standard Code for
28:04 - information interchange work started in
28:07 - 1963 and ASCII was a joint project
28:15 - between AT&T and IBM and a whole bunch
28:20 - of other parties it was not intended to
28:23 - be a computer character set it was
28:25 - intended to be a network character set
28:29 - or a communication character set but
28:32 - will not only have teletypes on the line
28:35 - but will also have computers on the line
28:36 - using the same code so this is a big
28:39 - step forward
28:41 - initially ASCII was going to be a six
28:44 - bit character code basically they're
28:46 - going to take the bardo idea but add one
28:48 - more bit to double its capacity and they
28:52 - wanted to be able to represent uppercase
28:54 - and lowercase
28:56 - and the way they were gonna do it which
28:57 - i think was completely reasonable was
29:00 - they were gonna borrow the shift idea
29:01 - that was in the Bedok code so they would
29:03 - have shift uppercase and shift lowercase
29:06 - and that would have been brilliant
29:09 - because the way we would deal with case
29:13 - today would be exactly the way we deal
29:15 - with color or underline or italics or
29:19 - anything else small caps it'd just be
29:22 - you know you have a code which
29:24 - represents a letter and will have some
29:26 - other means of saying what glyph we want
29:29 - for that letter but they didn't do that
29:31 - and the reason they didn't do that was
29:34 - again the line noise problem in the
29:36 - telegraph lines that the lines were
29:39 - really noisy we didn't have the error
29:40 - correcting codes that we have now our
29:42 - air correction systems are so good we're
29:44 - not even aware of them anymore but when
29:47 - this was designed line errors were a
29:50 - really big problem and their concern was
29:52 - that if one of these shift characters
29:54 - gets mangled in transmission then the
29:56 - rest of the document is going to look
29:58 - stupid when it's printed out and to deal
30:02 - with that they decided let's change it
30:05 - into a seven bit character set and give
30:08 - each of the letters a separate code
30:10 - which I think was a terrible decision
30:13 - that the reason they did that stopped
30:16 - being necessary a long long time ago but
30:19 - we are still stuck with the consequences
30:20 - so this is the code that they came up
30:24 - with 32 transmission control codes at
30:28 - the top anybody have any idea what those
30:31 - are you might recognize one or two of
30:33 - them most of them are a complete mystery
30:35 - to you but there is still in the code
30:38 - then we've got the digits are lined out
30:42 - pretty nicely it's actually a pretty
30:44 - nice thing they considered interleaving
30:47 - the upper and lowercase characters so
30:49 - you'd have uppercase a lowercase a
30:51 - uppercase B lowercase B so that most
30:53 - things would kind of sort right but they
30:57 - decided it doesn't sort perfectly and
30:59 - rather than try to figure out how you
31:01 - might fix that where you might fix it
31:03 - would be to go back to the 6 bit code
31:05 - they decided let's make it really wrong
31:08 - and
31:09 - you know we'll separate them by 32 so so
31:16 - you're probably curious about what those
31:18 - control codes are tonight for the first
31:21 - time I'm going to tell you what those
31:23 - control codes mean so AT&T insisted on
31:31 - two codes null and del delete so these
31:39 - were for punched paper tape applications
31:41 - so on the punch paper tape zero means
31:46 - there's nothing punched on the tape and
31:48 - one one means there is a punch on the
31:51 - tape so they wanted blank tape to be to
31:57 - have a code that you could recognize and
31:59 - reject so you'd have a liter of blank
32:03 - tape and you'd run that through your
32:05 - tape reader and you'd send it to the
32:08 - other side and the other side would see
32:09 - oh that's just a zero I'm going to
32:11 - ignore it which sounds bizarre in our
32:14 - modern system you know the internet
32:15 - doesn't work that way but that's the
32:18 - world that this code was designed for
32:20 - and then so offline you're editing a
32:24 - paper tape and you make a mistake and
32:27 - you go oops so what you do is you back
32:30 - up the tape and hit the delete button
32:33 - which goes junk and punches out all of
32:36 - the holes and then you can punch the
32:39 - character after it so punching out all
32:42 - the holes means this is a non character
32:45 - ignore this non character so it means
32:48 - the same thing as null but it just
32:51 - happens to have a different code because
32:52 - that's how paper tape works so then
32:59 - there was also a backspace code the the
33:03 - BS code but it did not mean erase the
33:07 - previous character it was not designed
33:10 - for user experience because there were
33:12 - no users there was no experience this
33:14 - was just designed for machines talking
33:17 - to each other so backspace meant moved
33:20 - the print head back one space which
33:22 - meet that's a completely different
33:24 - meaning later programmers said oh look
33:28 - there's a backspace key oh there's a
33:30 - delete key let's figure out what to do
33:32 - with those and the things we do with
33:34 - those now are completely different than
33:36 - what they were intended to be
33:39 - yeah we're in complete violation of the
33:41 - ASCII code in the way we use backspace
33:44 - and delete there are some codes added
33:48 - for operators for teletype operators
33:50 - there was the enquire code which when
33:52 - you sent it to another terminal would
33:54 - cause that terminal to send back a
33:56 - string which would identify the
33:58 - terminals so you know here connected to
34:00 - which sounds bizarre today how could you
34:03 - connect to something without an
34:04 - expectation of who you're talking to and
34:06 - then there's the Bell code which will
34:08 - ring the bell so you go ctrl G and on
34:13 - the other terminal go ding you know so
34:17 - you know adding a meaning now wake up
34:19 - think there was space and there was tab
34:24 - space was necessary because you need the
34:26 - inter word gap a tab was borrowed from
34:29 - manual typewriters manual typewriters
34:32 - had a tab key you press it and it would
34:34 - release the carriage until it was
34:36 - stopped by the next mechanical tab stop
34:38 - unfortunately they didn't indicate any
34:41 - way of specifying how to set a tab stop
34:45 - and they didn't specify what the default
34:48 - tab stops are it just said if you're
34:51 - going to tab this is the code and and
34:56 - they never anticipated what we're doing
34:58 - with this stuff and unfortunately this
35:01 - is a source of conflict we're still
35:03 - arguing should we use tabs should we use
35:06 - spaces it's a colossal waste of time and
35:12 - the debate goes on it will never stop
35:15 - because there is not a clear answer
35:17 - neither side can prove that they're more
35:21 - right than the other side and lacking
35:24 - any way of resolving the conflict it
35:26 - just goes on and the cost continues to
35:29 - grow and grow and grow the value of
35:32 - having these two characters zero we get
35:35 - no value
35:36 - from having two ways of doing this thing
35:38 - at least compared to the cost that it
35:41 - causes so I recommend a different way of
35:44 - resolving this problem which one can we
35:48 - get rid of we can get rid of that one
35:51 - yeah so we should get rid of tab it's
35:55 - not a question of which one is better
35:56 - it's which one can we get rid of that
35:59 - the tab character is an anachronism that
36:02 - should have died with the typewriter all
36:06 - right
36:07 - we've finally settled that okay we have
36:14 - carriage return in line feed again these
36:16 - are because of the way that the
36:18 - teleprinters worked carriage return
36:21 - would move the printhead back to the
36:23 - margin and line feed would roll the
36:24 - paper up one line and they liked having
36:27 - the two codes because the carriage
36:30 - return function was kind of slow because
36:32 - it you have to move a thing down and
36:35 - having the line feed happened just after
36:38 - it gave it a little bit more time to
36:40 - have that because if you then have to
36:42 - print another character before the
36:43 - carriage return gets back you can be
36:45 - printing ghost characters in the middle
36:47 - of the page and that looks stupid so we
36:51 - don't care about that anymore that's not
36:52 - how printers work now but we still have
36:55 - these two codes and there's still an
36:57 - argument about which one should you use
36:59 - people who think about this in terms of
37:01 - user experience will usually say it
37:03 - should be the carriage return because
37:04 - the Enter key used to say return and so
37:07 - you know that's how users think of this
37:10 - the hardware oriented people say line
37:13 - feed is really the way printers want to
37:15 - work they want to advance to the next
37:17 - thing and so you know how do you decide
37:21 - which one to do well there was a
37:23 - committee in the early days of the
37:25 - internet trying to decide which one
37:28 - should we use and they couldn't decide
37:30 - so they came up with the mutually
37:32 - disagreeable compromise which is we'll
37:35 - use both of them which doesn't make any
37:38 - sense that using both of them went out
37:40 - with mechanical teletypes but we're
37:43 - still doing that if you look at the
37:45 - internet standards look at HTTP it still
37:48 - says you have to use both
37:50 - it doesn't both at the same time it just
37:54 - doesn't make any sense we also have form
37:59 - feed which told the printer to eject the
38:02 - current page and put the next page into
38:05 - the printer so you can start printing
38:06 - and a companion vertical tab which is
38:09 - the vertical version of the horizontal
38:12 - tab but again they didn't specify any
38:15 - way of setting a vertical tab stop so it
38:19 - today it doesn't make any sense
38:21 - JavaScript still lets you say backslash
38:24 - of e representing this it doesn't mean
38:27 - anything and just it's pointless there
38:32 - were four device codes in ASCII so that
38:35 - you can control devices and generally
38:38 - that meant controlling the paper tape
38:40 - reader and the paper tape punch so
38:42 - you're telling a per tape reader on it
38:45 - and if the computer wants to start
38:47 - reading it it can send you can turn the
38:50 - reader on and then it'll start
38:52 - automatically sending characters to the
38:54 - computer and if the computer starts
38:56 - getting overwhelmed oh there's too much
38:58 - input they can then tell it to stop and
38:59 - the computer could also turn on the
39:02 - punch so you can start punching your
39:04 - paper tape those codes are still in
39:06 - ASCII then there are codes for dealing
39:10 - with protocols because they imagine that
39:12 - instead of just sending streams that we
39:15 - might actually be sending higher-level
39:17 - stuff and so this was really new stuff
39:20 - that they were kind of inventing so they
39:23 - imagined that we'd have protocols in
39:25 - which we'll have a start of header and a
39:28 - start of text code and an end of text
39:31 - and an end of block and we'll use those
39:33 - to make packets packets were still a
39:35 - really new idea and then in support of
39:40 - that we have AK the acknowledge code so
39:43 - if you successfully read a packet you'll
39:45 - send it back ACK
39:46 - and if for some reason you couldn't read
39:48 - the whole packet you'll send back nak
39:50 - and there's also the synchronous Idol
39:53 - they anticipated asynchronous mode in
39:56 - which well in a in a circus note mode
39:58 - there's a start bit and a stop bit on
40:02 - each character
40:03 - and that's so you've got an empty stream
40:07 - and then you see a start bit and you go
40:08 - Oh wake up there's a character and you
40:11 - keep getting bits until you get the stop
40:12 - and then you can go back to sleep but
40:16 - there's also a synchronous mode in which
40:17 - the characters go one after another no
40:20 - start bit no stop bit and the problem is
40:23 - how do you know where the character
40:25 - boundaries are because it's just ones
40:27 - and zeros and so they have asynchronous
40:29 - idle so when there's nothing being sent
40:32 - you send this code and on the other side
40:36 - they'll be looking for a pattern of
40:38 - those zeros and ones when they see them
40:40 - they go off that's a character and then
40:42 - they can deal with the rest of it so a
40:46 - packet might look like this you might
40:48 - have a start of text and then the body
40:50 - of the message and then the end of text
40:54 - or you could put a header on it
40:57 - the header might contain an address or
40:59 - some other information which helps you
41:01 - to deal with the packet and using the
41:06 - end of text block you could have really
41:08 - long things and you can get an ACK after
41:12 - each one because it might be too
41:13 - dangerous to try to send something
41:16 - really long because it's guaranteed
41:18 - you're gonna get an ACK so if you send
41:20 - it in smaller chunks then you might get
41:22 - stuff through there are two end codes
41:26 - one was end of transmission so at the
41:29 - end of the session
41:30 - you'd go control D yeah that's the end
41:33 - then we can hang up and and we're
41:35 - finished and there is also end of medium
41:38 - this is something you might put on a
41:40 - tape so you write a tape and at the end
41:42 - you'll write and then to medium code and
41:45 - that means that's the end of the tape
41:48 - then there are a couple of oops codes
41:51 - there's the substitute code that means
41:54 - that if you have a character and you
41:57 - don't know what it is you send the
41:59 - substitute code instead again today the
42:03 - way we think about data communications
42:05 - that doesn't make any sense how can you
42:06 - not know what a character is and still
42:09 - want to send it but you could do that
42:11 - also there's a cancel code if something
42:14 - is coming or if you're sending something
42:17 - side i never mind I'm not going to send
42:19 - the rest of it you can just send the
42:21 - cancel code and and you're done
42:26 - there's escape escape was not what we
42:29 - use it for now
42:30 - escape was for extending the character
42:32 - set they anticipated that the hundred
42:36 - twenty-eight characters in ascii might
42:38 - not be enough so escape would allow some
42:42 - way of extending the character set so
42:44 - when you see the escape code that means
42:46 - the stuff that comes after it is going
42:47 - to be interpreted differently one
42:50 - interpretation that was popular for a
42:52 - while was add an eighth bit to the
42:55 - character so that would get you up into
42:58 - the latin one set but so there is an
43:03 - escape key on the teletypes for that
43:05 - purpose but very quickly people realized
43:10 - we're in a program and we want to make
43:11 - the program stop how do we do that you
43:13 - know I've got this escape key let's
43:16 - let's hook that up and we're still using
43:19 - it right escape gets us out of a mode or
43:20 - cancels the dialog or something like
43:22 - that it was never intended for that is
43:25 - intended for enhancing the ASCII set we
43:29 - have data link escape which does a
43:31 - similar thing sometimes it's used for
43:34 - making a control code literal so if
43:38 - you've got some binary data and you want
43:40 - to be sending an end of transmission
43:41 - mark but you don't want to hang up you
43:43 - want it to be treated as data you might
43:45 - put in DLE in front of it but it could
43:47 - also be used to introduce new control
43:49 - codes because they were concerned that
43:51 - 32 control codes were not enough they
43:53 - thought they might want a lot lot more
43:55 - then I told you about the shift codes
43:59 - for uppercase and lowercase they decided
44:01 - not to use them for that but they still
44:03 - put them in the code and so you could
44:08 - shift out meaning it could shift into
44:10 - another character set and then shift
44:11 - back into ASCII another way of growing
44:15 - the code they provided information
44:19 - separators so there's the file separator
44:22 - the group separator the record separator
44:25 - and the unit separator so they did not
44:29 - intend for or
44:31 - I've heard people say that tab-separated
44:34 - data is the way asking intended us to
44:38 - format data and it's not this is how
44:41 - ASCII intended us to format data you
44:47 - have files made up of records made up of
44:49 - groups made up of units of data
44:52 - unfortunately this isn't really how data
44:55 - ended up that sometimes you have records
44:57 - that really want to contain other
44:59 - records you know so this this doesn't
45:01 - work so I should have told them about
45:05 - Jason right because that's what they
45:09 - really should have been doing but I
45:11 - didn't and my excuse is that I was eight
45:15 - at the time and I was doing other things
45:20 - it's just too busy
45:22 - ah yeah so so that's the ASCII set so
45:29 - again they did not intend this to be a
45:31 - computer character set this is just
45:34 - something that computers would use to
45:36 - communicate with each other but a number
45:38 - of manufacturers thought well let's just
45:40 - try to use this as is because then we
45:44 - don't have to translate from our set
45:46 - into their set for one very common use
45:50 - was something that I called half ASCII
45:52 - [Laughter]
45:54 - where you just take 64 characters of it
45:57 - you said you cut out the control codes
45:59 - and the lower case you just subtract 32
46:02 - from everything and that gets you a nice
46:04 - little six bit character set and there
46:06 - are a number of manufacturers that we're
46:08 - doing stuff like this it it all changed
46:12 - with the microprocessors but we'll get
46:17 - to that in a bit so the next step
46:19 - forward is Unicode Unicode starts in
46:22 - 1991 some very very smart people from
46:25 - Xerox and Apple and other places who
46:28 - have been really struggling trying to
46:30 - make products that worked all over the
46:31 - world and realize we need to figure out
46:34 - what figure out a way to unify the
46:37 - character set so we can just have one
46:38 - product that goes everywhere and so
46:41 - their goal was to make a
46:45 - after set that would serve all of the
46:47 - living languages in the world in 16bits
46:50 - and they came really close to pulling it
46:52 - off but in order to do that they had to
46:54 - do something called Han unification
46:56 - which meant taking or observing that
47:00 - Chinese was the route also of Korean
47:04 - writing and Japanese writing and taking
47:09 - all of all three of those languages
47:11 - putting them into one character said
47:12 - it's too big doesn't fit in 16-bit
47:14 - character sets but if you look at how
47:17 - common those languages still are at
47:19 - least in their orthography then we can
47:23 - squeeze it down into sixteen bits and
47:25 - they tried really hard to do that
47:28 - unfortunately they really pissed off the
47:30 - Japanese but they we're not happy about
47:34 - the way that happened so that brings us
47:36 - five years later tina code two and
47:38 - unicode two now has a much more
47:43 - expansive mission they have grown the
47:47 - character set to 21 bits and they now
47:49 - want to encode all languages even dead
47:52 - languages you know so Egyptian
47:54 - hieroglyph hieroglyphics become part of
47:57 - Unicode which is something I like a lot
47:59 - so I like that
48:02 - unfortunately in 2010 we get unicode six
48:07 - and emoji for a while there was a hope
48:12 - that some day we could finish unicode
48:15 - right we'll find all of the languages
48:18 - that have ever existed we'll write them
48:20 - all down and we'll give all the
48:21 - characters codes and we'll be done
48:23 - unicode will never be done there's no
48:26 - way for ever get in front out of emojis
48:28 - so ASCII lives on in unicode the first
48:35 - hundred twenty-eight characters of the
48:37 - unicode set are at the ASCII set even
48:40 - though ASCII was not intended to be a
48:42 - character set in unicode was intended to
48:44 - be a character set in computers ASCII is
48:49 - in there including the 32 control codes
48:51 - which you now know are mostly
48:53 - meaningless and completely ridiculous
48:56 - right they they don't serve us anymore
49:00 - and the way this stuff works is really
49:03 - important for example in the C language
49:07 - we use the null character to represent
49:09 - the end of string which is not what
49:12 - ASCII said but that's what C says which
49:15 - means that C would have broken on any of
49:19 - the earlier 6 bit character sets because
49:22 - they did not have a null code they all
49:24 - used 0 for a real code so ASCII changed
49:29 - the way we think about programming of
49:33 - letters and words but there was an even
49:36 - bigger influence than that under the
49:40 - influence of 6 bit character sets there
49:44 - are lots of different hardware
49:46 - architectures with lots of different
49:48 - word sizes but they all seem to have a
49:51 - factor of 3 in them so I saw I worked on
49:55 - carat on machines that had 12 bit
49:58 - characters 18 bit characters 24 I'm
50:01 - sorry
50:01 - 12 bit words 18 bit words 24 bit words
50:05 - 36 bit words 48 bit words 60 bit words
50:09 - the thing all of these machines had in
50:12 - common was 6 bit characters and the
50:16 - reason that worked was because that's
50:19 - what the character sets were and so you
50:22 - could pack some number of characters
50:23 - into a word and it all fit and it was
50:25 - really good and these were great
50:27 - machines and and then it all changed so
50:37 - 7-bit ascii cause the ascendance of
50:40 - computer architecture based on eight so
50:44 - IBM took ascii and weirdly mutated it
50:50 - they combined it with their terrible BCD
50:52 - IC code and came up with something a
50:54 - really awful thing called ipsa dick and
50:57 - used that as the character set for the
51:00 - 360 series so that system is based on
51:03 - eight sixteen thirty-two and all of her
51:07 - machines pretty much since then
51:09 - are based on that the the big change I
51:13 - think happened because of Intel so Intel
51:17 - built a machine called the 8008
51:20 - which was the design was brought to them
51:24 - by a company in San Antonio called data
51:28 - point they made intelligent terminals
51:30 - and they were making them out of
51:31 - discrete logic and they were difficult
51:34 - to build and they came up with a design
51:36 - for a simple CPU which would have
51:38 - greatly simplified their terminals and
51:40 - they asked Intel if they would build
51:43 - that chip for them which they did so the
51:47 - initial design of that chip was an 8-bit
51:51 - machine and the reason it was a bit was
51:54 - so that it could process ASCII that was
51:56 - the intended purpose of the 8008 but
52:00 - that 8008 grows into the 8080 and the
52:05 - 8086 and the pentium and all the crap
52:09 - that comes after and so it's all 64 bits
52:12 - now so if the ascii committee had
52:17 - successfully completed as a 6-bit
52:21 - character said 36 bit architecture would
52:25 - have survived and so I think the first
52:29 - microprocessors would have been 12 bit
52:31 - machines not 8-bit machines and that
52:34 - would have completely changed the
52:36 - evolution of stuff that the next step up
52:38 - would have been 24 and so a lot of the
52:45 - memory limitation issues that we felt on
52:47 - PCs we could have avoided those four
52:50 - years and then taking the next step up
52:52 - to 32 and today we would be running in
52:55 - 72 bit architecture which I think would
52:58 - be brilliant you know it would have
53:01 - completely changed the way we do
53:03 - internationalization Europe would have
53:05 - moved immediately to 12 bit character
53:07 - sets because 6 didn't work in exactly
53:09 - the same way that Asia moved immediately
53:13 - to 16-bit character sets because 8
53:16 - didn't work
53:17 - and by doing that we would have avoided
53:20 - all of those internationalization
53:22 - problems and
53:25 - then ultimately the world would adopt an
53:28 - 18-bit character set which would be the
53:31 - unicode set which would serve everybody
53:33 - and seventy two-bit CPUs would be the
53:37 - standard today so that's the end so I'm
53:53 - really looking forward to some excellent
53:55 - questions which will help me figure out
53:56 - what the WoW finish is to this thing so
54:00 - any questions
54:25 - are we learning from our mistakes in
54:27 - this field
54:28 - no now we generally don't do that we
54:34 - will adopt something because it seemed
54:37 - like a good idea at the time
54:38 - and we tend to never revisit it again
54:41 - and so you know as you look down into
54:45 - the history of what we've done and why
54:47 - choices were made and then see where
54:51 - they ended up you know it just you know
54:54 - if we had known where it was going to go
54:55 - we wouldn't have done that but somehow
54:57 - we're still here where we are and we
55:00 - don't recognize that we're still doing
55:02 - that that's just the way we do things
55:05 - yeah
55:26 - yeah what's the path going forward
55:28 - that's a really hard problem I mean I
55:31 - commend with the ASCII committee for
55:35 - doing as well as they did they got a lot
55:37 - of stuff right
55:39 - they were very thoughtful in the way
55:41 - that they approached the problem and
55:42 - they did the best they could where it
55:47 - went wrong I think was not in the ASCII
55:49 - committee it was after again they didn't
55:52 - intend intend for it to be a computer
55:55 - character set the intended to be a
55:57 - transmission code but there were people
56:01 - particularly in the 8-bit world who
56:05 - wanted to save the cost of a character
56:08 - translation table you know they wanted
56:11 - to save you know under 28 bytes and if
56:14 - we make that our character set we saved
56:16 - hundred 28 bytes and at the time that
56:18 - seemed like a really good trade-off but
56:22 - it was only a really good trade-off for
56:24 - a few years eventually Moore's law
56:26 - changes the economics of memory
56:28 - conservation and that it becomes a
56:30 - really bad idea
56:32 - but again once we lock something into a
56:35 - standard or a standard practice it gets
56:38 - it's virtually impossible to roll it
56:40 - back yeah
56:59 - yeah that's a really good question so
57:07 - you would think so that's a really good
57:14 - thoughtful question I'm afraid I don't
57:15 - have an adequate answer for it but thank
57:19 - you for that question
57:20 - yeah yeah so are there any alternatives
57:32 - to Unicode being considered I don't
57:35 - think so I think Unicode Unicode is
57:39 - likely to be the last character set not
57:43 - you know it's just gonna be the way it
57:45 - is and there are some things about
57:48 - Unicode that I think are extremely
57:49 - commendable that they've done some
57:51 - brilliant stuff and there's other stuff
57:53 - in Unicode where you go you know this is
57:56 - awful
57:57 - like I showed you that substitution code
58:00 - in ASCII the one that says the letter
58:03 - you're looking for it's not here or the
58:05 - code you're looking for it's not here
58:07 - not only is that code now in Unicode
58:10 - Unicode added another one so Unicode has
58:14 - its own substitution code saying when
58:16 - it's not here which go we need zero of
58:23 - those codes right and we've got two of
58:25 - those codes one of the things that was
58:28 - liberating about ASCII was because
58:30 - they've got so many characters they
58:34 - didn't have to be nearly as cautious as
58:36 - ASCII was asking when they were picking
58:39 - the characters to go in that set they
58:41 - made really really hard choices and if
58:44 - we put that one in we can't put that one
58:45 - in you know they didn't put the arrow in
58:47 - because they just couldn't make it fit
58:49 - which was it was actually in there for a
58:51 - while and then it got taken out and
58:53 - replaced I think with the underbar you
58:59 - know so you know this stuff stuff I
59:01 - could anticipate I could think of one
59:04 - thing that might propel the world to
59:06 - consider doing a new character set and
59:08 - that would be something that would try
59:10 - to solve the sorting problem
59:12 - so unicode sorts correctly for virtually
59:16 - no languages right well or at least four
59:20 - languages using the latin set that none
59:23 - of the languages sort correctly we could
59:27 - try to and there is no ordering of the
59:30 - letters that will sort correctly for all
59:32 - languages but we could come up with a
59:34 - sorting which would work for most
59:36 - languages so we could design a character
59:39 - set in which we have a followed by a
59:42 - accent followed by a umlaut and so on
59:45 - we'll just batch them all up you know
59:47 - after i comes i J and then J and then K
59:51 - and so on will just take try to take as
59:54 - many of the European characters as we
59:57 - can and put them into one linear
59:58 - sequence and maybe that becomes a good
60:02 - enough idea that we can say this becomes
60:04 - the basis of a new character set I can't
60:07 - imagine anything else you know I think
60:10 - that would be a problem that would be
60:12 - worth solving and that might get us a
60:16 - new character set but I'm really
60:17 - doubtful I don't think we could pull it
60:19 - off there is so much inertia behind
60:21 - Unicode now I think it's going to be the
60:24 - end yeah
60:30 - is there any way to work in three
60:32 - dimensions and character cells or you
60:38 - can stack them up and that's essentially
60:40 - what Unicode does so in Unicode you've
60:43 - got it stacks them in a couple of
60:46 - dimensions one is you've got planes so
60:49 - you've got the basic plane then you've
60:50 - got sixteen additional planes which are
60:53 - all in the same 16-bit set and within
60:55 - the 16-bit set you could see that is
60:57 - broken into stacks of 8-bit sets so
61:02 - that's a three dimensional character set
61:05 - yeah
61:20 - yeah that's the problem because there
61:24 - are definitely costs but all of those
61:28 - costs have already been accepted so in
61:31 - changing to something better it's really
61:35 - hard because it's obvious that there's
61:39 - going to be new costs in moving to the
61:41 - better system and it may not be
61:43 - immediately apparent to what the
61:44 - benefits are whereas we don't properly
61:48 - account for the costs in the old system
61:50 - so the new system is going to be at a
61:52 - huge disadvantage yeah could there be
62:01 - advantages to compression by altering
62:03 - the character set maybe although some of
62:08 - our our compression codes are our smart
62:13 - codes that learn in our adaptive so they
62:17 - seem to be doing pretty well I don't
62:18 - think we could get much improvement by
62:22 - changing the underlying character set
62:26 - yeah
62:33 - it's more bits yeah so the memory
62:46 - addressing problem we passed 64 bits
62:50 - looks like we're gonna be good for a
62:51 - long long time with that so and 64-bit
62:57 - is well so in JavaScript we get
62:59 - essentially 53 bits at least on our
63:02 - integers and that's quite a lot
63:06 - particularly when you compare it to the
63:08 - 32-bit architectures and much of
63:11 - JavaScript unfortunately is still 32
63:12 - bits and there's been some pressure to
63:18 - try to get JavaScript to add a 64 bit
63:20 - thing which I'm very opposed to that if
63:26 - you want extended arithmetic you can
63:28 - write a simple function in JavaScript
63:31 - that gets you extended precision so we
63:34 - don't really need to change the language
63:36 - fundamentally and if you have two number
63:39 - types and if they ever come in contact
63:42 - with each other you're guaranteed to
63:45 - have errors right because values are not
63:50 - yeah that kind of stuff so I'm very
63:54 - unhappy with the floating-point system
63:55 - we have in JavaScript it's it's horrible
63:58 - but I can't see that we're going to
64:00 - replace it because again we've accepted
64:03 - all the costs of a floating-point system
64:06 - that works really badly and so we're not
64:09 - going to get be able to overlook the
64:12 - costs of moving to something that's
64:14 - going to like add money correctly even
64:16 - though that I think is much more
64:18 - important I think Dex 64 would be great
64:23 - and I highly recommend that Dec 64 be
64:27 - the only number type in the next
64:28 - language but I have no hope that it will
64:31 - ever get a JavaScript JavaScript is
64:34 - whereas Brendan Eich used to say that
64:36 - ship has sunk
64:39 - yeah yeah quantum computing is a
64:54 - completely different thing so you've got
64:56 - these quantum bits which can be in
64:58 - multiple states simultaneously and it's
65:03 - presumed that that leads to the solution
65:05 - of problems which cannot be solved in
65:08 - linear time on conventional hardware but
65:11 - they don't act like bits so there's not
65:14 - a correspondence to bits they're
65:16 - different stuff so even if we do get
65:20 - quantum computing I think it will be
65:23 - used in very specific applications
65:26 - things where you get the benefit of the
65:28 - undecidability in order to solve very
65:30 - hard problems one of the most popular
65:34 - expected application that seems to be
65:36 - breaking of cryptographic systems so
65:39 - which will certainly be problematic but
65:43 - it doesn't appear that it's going to be
65:45 - a platform for general-purpose computing
65:48 - so I think we'll still have bits for a
65:51 - long long time now a more interesting
65:56 - breakthrough might be trying to figure
65:58 - out the neural stuff that we still
66:00 - haven't figured out how this stuff works
66:01 - yet but we know really well now that it
66:05 - works really differently than digital
66:07 - systems so it may be that eventually
66:10 - we'll figure out how to make neurons and
66:13 - stuff like that and that will work on a
66:16 - completely different principle and who
66:20 - knows what we'll do with that
66:26 - anybody else okay so I think we're done
66:31 - thank you very much so yeah yeah I think
68:05 - thank you I mean like this is amazing
68:08 - thank you guys for coming out
68:10 - stay tuned for more meetups lots to come
68:13 - does everybody know what our JavaScript
68:15 - la YouTube checklist feel like okay does
68:54 - anybody have questions I'm sorry on
69:06 - which side
69:14 - give me a better picture so I can find
69:19 - oh yeah oh great great thank you very
69:27 - much
69:43 - [Applause]

Cleaned transcript:

it really is great to be back I used to live about a mile from here just on the other side of the freeway there used to be a computer industry in Orange County that actually built Hardware built of many computers it's all gone now I guess but you're still here so it's really great to see all of you thank you everybody for helping to set this up and to provide us of this place and thank all of you so much for coming out tonight so I want to do for you tonight a brand new talk I have never done this one before I think it's a really important topic it's a really interesting topic it turns out the way our character codes work has a tremendous impact on how we think about programming and and how this whole professional operates a lot of stuff is implied by the way we handle characters computers are machines that manipulate numbers that's all computers can do that's literally all we can do but by assigning numbers to characters we can do text processing and all this information stuff happens and I'm gonna talk about where this stuff came from I think this is gonna be an interesting talk it's certainly interesting to me I love this stuff and we're gonna be talking a lot about the history of this stuff but I have not been able to figure out how to end this talk and I've done this before I've gone out and I've had a talk and I really like this talk and I go out and I don't know how to end it so I just go to the end and say thank you goodnight knowing that I you know it deserved a WoW finish but I didn't give it one because during the UA or B in the QA I'll get questions and some of the questions will will indicate that I completely failed and trying to describe what this is because the question just completely missed it but sometimes the question will focus me on what the whole thing was about and go yes thank you this is the moral of this story so I'm hoping that will happen tonight so you know I'm counting on you okay you have a part to play so character codes don't start with computer systems they start first with data communications or communications in general just human communication and then data processing and eventually communication and data processing come together in computing so we're gonna start at the very beginning the first character set the morse code designed by a samuel morris an american portrait painter he also had a hobby in electricity and he worked with some partners to develop a telegraph and Morse put together the code that transmitted words across their Telegraph and it's a very very simple code because they're telegraph all I could do was transmitted to States it was either on or it was off so Morris figured out a way to turn that into a communication channel so he has a language that's made up of two symbols dot and dash and we can represent these in binary so a dot is a single one and a dash is three ones and then in order to tell the difference between the dots and the dashes he need to put some zeroes in between them so he's got zero for the particle space that's the small separator between a zero and one and then there's a letter space which will be the space between the letters and then a word space which goes between the words if you're a musician it's easier to think about this musically so you can think of a dot as an eighth note and a dash is a dotted quarter note and then an eighth rest is the particle space a dotted quarter rest is a letter space and approximately a whole rest is the word space so here's an exam four letters representing the Morse code so the letter T is a dash letter eyes two dots letter M is two dashes and an EE is a dot so horse took a look at the frequency of letters in English and chose the most popular letters they have the shortest codes so this is not only a communication code it's also a data compression code it's the first data compression code and it it's a code that works in time most of our codes work in space you know you can think of a word containing some number of bits or even a packet containing some number bits but this is a because it's musical it's all happening in time so remembering the word time will help you to remember these symbols that the consonants are dashes the vowels are dots and the most frequent frequent things like the e will get the shortest code okay so you now know four of the letters in the Morse code in fact I'm going to teach you all 26 letters of the Morse code because you might need it someday you might be trapped in a mine or on a disabled submarine and you're gonna need to be able to get a message out and all you're gonna be able to do is tap on the hole with a rock or something but you'll be able to do it because you're going to know the Morse code okay the fifth symbol is the V which we can get from the V for victory Beethoven's fifth so you all remember Beethoven's fifth symphony begins dahdahdahdah dot dot dot dash okay that's the letter V okay V for five you all know the SOS of the International distress signal its dot dot dot dot dot dot if we break it down into letters the S is three dots and the O is three dashes this is the opposite of the dash is being consonants but you know we got a couple exceptions so you can remember that right so dot dot dot is s dash is Oh a chisel of tricky to remember it's for dots so I recommend you think of the 4h club and and the advisor to the 4h club mr. 4h himself Harry Herbert Hoover Hever okay for the rest of the letters okay so you now know six letters right for the for the next twenty we're gonna have some mnemonics and this is helping em onyx are gonna work so I'll give you a letter and I'll show you the the Morse code for that letter and then I'll have an English word which contains that letter in which the dot corresponds to a vowel and the corresponds to a continent consonant so a is for M everybody got that and everybody understanding a okay let's move on B is for bow B my bow it's it's beautiful isn't it not my friend c is for Coco everybody loves Coco right you love Coco that's why you can remember that c is for Coco this next one is going to be really shocking and upsetting D is for die but because it's so shocking you're gonna remember this one the D is for die e you've already seen he is one of the the time things it's one dot and F is for Fe that's right Luffy everybody say you fee okay so AM Boko code ie goofy everybody with me so far we're learning the Morse code G is for ganoub for programmers that should be a really easy one G canoe G canoe is that outfit that gave us a failed UNIX clone and a software license in which free is not free right everybody knows that one we've already seen h the 4h club Harry Herbert Hoover Hever I we've already seen iii write two dots and I J hey J what do you say hi JJJ you what I JJJ k is for a kit right that's easy kit okay get up maybe yeah K and L is for soothing aloe you can't forget that L 4 L oh of course so canoe 4h III ajjj kit and aloe everybody still with me let's learn some more M we already saw is one of the time letters it and it's good mmm good that's the letter M is good and oh no got it okay we already saw Oh from the SOS P is for Expo you might imagine next year there's going to be a big Expo in which they're going to announce a better mnemonic for the letter P so we're all looking forward to that Q is a bit tricky cuz it's hard to make words out of Q so whenever you have a Q you're likely to have a you after it so we got that pair and we're gonna wrap it in quotes but we don't have quotes so we'll use the letter Q for the quotes because Q is for quote and so we get Q qu q okay got it r is for era this is the era of Morse code are ya okay s we already saw in the SOS and the distress signal we already saw T in the time letters you out o UT out okay we already saw a V Beethoven's fifth I thought but the W is for the wise old owl that's easy to remember w and the owl because he's so wise X X is another hard one but fortunately X rarely happens in English so we're safe but you know it's XO o X you're not gonna remember that but you'll probably be okay then why yuck so you know if there any little kids here I don't see any little kids if there were any little kids the two symbols they're gonna remember tonight are goofy and yuck that's for sure and then finally at the end of everything is Z of course so what comes after zu z zu right that's the end right z zu is the last so you now know Morse code you're not good enough to get an operator's license but you could probably recall this and make a list and then you can tap it out you know you might be on that disabled spaceship and you need to alert the fleet you're gonna be able to do it someone's gonna say my god that's Morse code and we'll be saved okay so moving on the next communications code was the Bedok code which was invented by emil Bedok it was a French calligrapher he wanted to improve on the Telegraph so instead of the operators having to be entering a stream of bits that instead you would have a keyboard that would look like a musical keyboard with five keys on it and you would chord in the letters that you want so you would have to memorize the letters in order to get them in and this keyboard would be attached to a paper tape punch which would produce a string of paper tape with the holes in it and then that could be transmitted there was another guy who came on so if ever heard of baud rates which is yeah the couple the oldtimers going out I remember baud rates bada is usually bit well it actually means bits per second but yeah it's slow is also another meaning so it was named after this guy so Donald Murray who is a news New Zealander improved on the DOE system he came up with a much better keyboard so it had a button for each of the letters and so the operator didn't have to memorize the binary code so you just go punch punch punch punch and he could have picked any keyboard and unfortunately he picked the QWERTY typewriter keyboard the QWERTY typewriter a keyboard is terrible by design in order to try to prevent the jamming of the mechanical keys you know it wasn't completely successful in doing that but that's why it's got that bizarre layout and Murray could have said well we don't need to do that because you know when you push a button we're closing a circuit which is gonna drive some pins through some paper tape so it doesn't matter what order we put the keys in he could have done something rational but he didn't and so we're still stuck with the QWERTY keyboard everywhere this is the first time QWERTY is used in electronic communication and and it's still being used in electronic communication so this is a refinement of the code that those two guys worked on and it became a standard one of the first telegraphy standards this is International Telegraph alphabet number two it was a 5bit code which allows them to encode all of the letters Murray scrambled the codes around in order to reduce wear on the machinery so that instead of optimizing for time he was optimizing for bits where each bit would cause a needle to drive a hole into a piece of paper and those pins would wear out and so in order to reduce wear on the machinery he have the most common codes have the smallest number of bits so for example e is a very popular letter it only has one bit and T is also a very popular letter it only has one bit and since the operators didn't see the codes it didn't matter that they were kind of random then there's a code for space carriage return and line feed two separate codes because that's how his printer worked the most interesting thing that bodo did was he added a couple of shift keys so there's the figure shift and the letter shift so when you're in letter mode you get these codes and when you're in Figure mode you get these codes so that gets you the digits and the special characters which was a really clever idea so they managed to get you know 60 or so characters in just 5 bits and they decided to have 2 codes instead of 1 they could have just had a toggle shift but there was a concern that the telegraph lines were very noisy and if there was a line hit then a shift code get get garbled and that means everything after that is going to look wildly wrong so to make the system a little bit more resilient they have two independent shift codes so the next step happens a bit later the Hollerith code so Herman Hollerith developed a data processing system using punch cards for the 19 or for the 1890 census the US Constitution requires that every 10 years we have a count of everybody so we can figure out how to staff the House of Representatives and it was taking too long to do with pen and paper so Hollerith figured out a way to do a lot of that work mechanically and that turned out to be a big business a number of companies were formed and after a series of acquisitions and mergers in event tolerance company eventually becomes international business machines or IBM and in 1928 IBM wanted to figure out a way to get more information onto the cards because with Hollerith little circular punches they can only get so many characters and they wanted to get more so they came up with a system in which they could get 80 columns on a card each card had 80 columns and twelve rows in which you could punch holes and at the top there was a blank space where you could print stuff with ink so that humans looking at the card could figure out what it said although people who were skilled with this code could actually look at the punches and tell you what it said so they came up with a very straightforward way of encoding the characters so first if in the top line it's called the twelve row or the 12 punch or the X punch or the plus so if there's a punch there then you get a plus sign the next row you get a minus sign and then 0 1 2 3 4 and so on to 9 ok pretty straightforward and they wanted to be able to do letters too so letters are slightly more complicated each letter requires two punches because we've used up all the one punch codes so we use the the plus Rho and the digits one through nine and that gets us the letters A through I and then we do a similar thing with the minus row and the digits 1 through 9 and that gets us J through R and we do a similar thing with the zero row but this time going 2 to 9 to get S through Z this pattern should give you 27 letters but we only need 26 so they needed to drop one of the codes and the code they decided to drop was 0 1 and the reason was that you had two holes with just a tiny little piece of paper between them and there a concern that given the crude machines of the time that they were using metal wire brushes to sense the holes in the cards that it could rip the card which could cause the machine to jam or cause bits of little pieces of paper to accumulate in the machine and eventually catch fire so to avoid that hazard they skipped that code but then you could have threeletter codes or different combinations of two whole codes to do the special characters and unfortunately that never got standardized very well so different machines would have different codes so taking a deck of cards and moving it from one system to another could get really complicated because all the special characters could get misinterpreted so now we finally move into computing when computing starts in the late 40s the first computers have six bit character sets these machines were mostly concerned with computation mathematical computation and so six bit character sets were were fine so this is one that was used at IBM their character set was based on a praetor that they were using with their punch card equipment which they modified in order to work with some of their early computers and so their printer only could print 48 different characters and so they left a lot of these codes blank and they had a few weird characters like like that so what is that I don't I don't know what it is oh it's called a square lozenge I don't know what it means but it was on their punch card equipment and so people would use it because there weren't very many characters available so that meant whatever you really wanted it to be you would use that because that's that's all it is you know they didn't put a plus sign in it which is like I don't understand as so the next step forward is Fortran Fortran is the first really successful programming which kind of changes the world it was also developed at IBM and it gets poured into all of the IBM machines and then everybody else makes their own Fortran systems as well it's the first big programming language and the guys who were designing Fortran couldn't figure out a way to make a programming language out of that so they said we need these additional characters and so they just said if you're going to have Fortran you're gonna have to neat have to get these characters somehow and so IBM said okay we'll try to figure out how in our next printer we can we can add those so in a later version of the there be CDI C code they've added more characters so something that's weird about this you look at the arrangements of a and J ass what they did was they just took the Hollerith code and pushed it into the characters head okay so we have an expectation that each letter is going to be one away from the next one but that's not the case here you know I plus one is question mark not J okay so it's gonna be a little challenging you know write a sort routine for this character set okay and they got some weird characters like these guys so they they created a magnetic tape system to work with this computer and they reserved these four codes has special marks on the tape and they recommended that you never use these codes in your programs because if you try to write those codes to the tape it's going to screw everything up so they picked characters that they thought no one would ever want to use then they had a problem they started selling stuff in Europe and found that this isn't enough letters that you know like in Scandinavia they need three more letters and so they decided well you can take those letters and/or those characters and replace them with letters in whatever country you're in so this kind of begins the I 18n problem that this is where it starts and it took a long long time to fix it now turned out every company had their own character set so for example control data started with the IBM set but kind of changed a little bit because they were more into scientific computing and so they added some characters that they thought people who are programming about numbers we care about things like not equal less than or greater than angle brackets or less than or greater than that's good stuff right another company that was doing brilliant work the Burroughs 5000 series is maybe one of the most interesting architectures ever designed and they're still doing the IBM thing except that kind of straightened it out a little bit at least a comes before s now so that's good and I really like that they put zeros at the top row that means the character code for 0 is 0 does that make sense that absolutely makes sense that's brilliant as a programmer I love Burroughs I that makes so much sense to me and are pretty good my set oh and they got an arrow which is what we should have had for the assignment operator Fortran didn't have this because they just didn't dare to ask for another character and so they were forced to use the equal sign for assignment because they had no other options and we're still doing it it just doesn't make any sense we should be using that re that that makes sense so the US Army is buying lots of computers and you know each of its computers comes from a different company and they all have different character sets and trying to exchange information between all these machines was really really hard so they decided to fix the problem being the government so they created a character set of their own called field data and field data was a 7bit character set which was intended to run on all army computers and that would let them communicate but because it was a and there's some pretty reasonable stuff so they finally fix the alphabet right so it it's all continuous so I like that a lot and it still got some of these weird IBM characters in it but you know that's okay and some of these could be replaced by other characters for and for some reason they they moved all of these characters up to the top half of the seven bit character set and they leaved the left the bottom half of the seven bit character set undefined so there were a number of projects in the army that started working with this character set and they liked it it worked well and they hadn't need for lots of extra characters and there was all this you know 64 characters that weren't being used so they just started using them which was fine for them until the army wanted to make all of these programs work together and they didn't because everybody saw that there was a hard lesson there that you really have to nail stuff down in a standard if you leave too much stuff free then programmers will abuse it as a result you'll lose interoperability or quality or whatever it is you're trying to get so the next big step forward is ASCII anyone heard of ASCII yeah ASCII is a big deal the American Standard Code for information interchange work started in 1963 and ASCII was a joint project between AT&T and IBM and a whole bunch of other parties it was not intended to be a computer character set it was intended to be a network character set or a communication character set but will not only have teletypes on the line but will also have computers on the line using the same code so this is a big step forward initially ASCII was going to be a six bit character code basically they're going to take the bardo idea but add one more bit to double its capacity and they wanted to be able to represent uppercase and lowercase and the way they were gonna do it which i think was completely reasonable was they were gonna borrow the shift idea that was in the Bedok code so they would have shift uppercase and shift lowercase and that would have been brilliant because the way we would deal with case today would be exactly the way we deal with color or underline or italics or anything else small caps it'd just be you know you have a code which represents a letter and will have some other means of saying what glyph we want for that letter but they didn't do that and the reason they didn't do that was again the line noise problem in the telegraph lines that the lines were really noisy we didn't have the error correcting codes that we have now our air correction systems are so good we're not even aware of them anymore but when this was designed line errors were a really big problem and their concern was that if one of these shift characters gets mangled in transmission then the rest of the document is going to look stupid when it's printed out and to deal with that they decided let's change it into a seven bit character set and give each of the letters a separate code which I think was a terrible decision that the reason they did that stopped being necessary a long long time ago but we are still stuck with the consequences so this is the code that they came up with 32 transmission control codes at the top anybody have any idea what those are you might recognize one or two of them most of them are a complete mystery to you but there is still in the code then we've got the digits are lined out pretty nicely it's actually a pretty nice thing they considered interleaving the upper and lowercase characters so you'd have uppercase a lowercase a uppercase B lowercase B so that most things would kind of sort right but they decided it doesn't sort perfectly and rather than try to figure out how you might fix that where you might fix it would be to go back to the 6 bit code they decided let's make it really wrong and you know we'll separate them by 32 so so you're probably curious about what those control codes are tonight for the first time I'm going to tell you what those control codes mean so AT&T insisted on two codes null and del delete so these were for punched paper tape applications so on the punch paper tape zero means there's nothing punched on the tape and one one means there is a punch on the tape so they wanted blank tape to be to have a code that you could recognize and reject so you'd have a liter of blank tape and you'd run that through your tape reader and you'd send it to the other side and the other side would see oh that's just a zero I'm going to ignore it which sounds bizarre in our modern system you know the internet doesn't work that way but that's the world that this code was designed for and then so offline you're editing a paper tape and you make a mistake and you go oops so what you do is you back up the tape and hit the delete button which goes junk and punches out all of the holes and then you can punch the character after it so punching out all the holes means this is a non character ignore this non character so it means the same thing as null but it just happens to have a different code because that's how paper tape works so then there was also a backspace code the the BS code but it did not mean erase the previous character it was not designed for user experience because there were no users there was no experience this was just designed for machines talking to each other so backspace meant moved the print head back one space which meet that's a completely different meaning later programmers said oh look there's a backspace key oh there's a delete key let's figure out what to do with those and the things we do with those now are completely different than what they were intended to be yeah we're in complete violation of the ASCII code in the way we use backspace and delete there are some codes added for operators for teletype operators there was the enquire code which when you sent it to another terminal would cause that terminal to send back a string which would identify the terminals so you know here connected to which sounds bizarre today how could you connect to something without an expectation of who you're talking to and then there's the Bell code which will ring the bell so you go ctrl G and on the other terminal go ding you know so you know adding a meaning now wake up think there was space and there was tab space was necessary because you need the inter word gap a tab was borrowed from manual typewriters manual typewriters had a tab key you press it and it would release the carriage until it was stopped by the next mechanical tab stop unfortunately they didn't indicate any way of specifying how to set a tab stop and they didn't specify what the default tab stops are it just said if you're going to tab this is the code and and they never anticipated what we're doing with this stuff and unfortunately this is a source of conflict we're still arguing should we use tabs should we use spaces it's a colossal waste of time and the debate goes on it will never stop because there is not a clear answer neither side can prove that they're more right than the other side and lacking any way of resolving the conflict it just goes on and the cost continues to grow and grow and grow the value of having these two characters zero we get no value from having two ways of doing this thing at least compared to the cost that it causes so I recommend a different way of resolving this problem which one can we get rid of we can get rid of that one yeah so we should get rid of tab it's not a question of which one is better it's which one can we get rid of that the tab character is an anachronism that should have died with the typewriter all right we've finally settled that okay we have carriage return in line feed again these are because of the way that the teleprinters worked carriage return would move the printhead back to the margin and line feed would roll the paper up one line and they liked having the two codes because the carriage return function was kind of slow because it you have to move a thing down and having the line feed happened just after it gave it a little bit more time to have that because if you then have to print another character before the carriage return gets back you can be printing ghost characters in the middle of the page and that looks stupid so we don't care about that anymore that's not how printers work now but we still have these two codes and there's still an argument about which one should you use people who think about this in terms of user experience will usually say it should be the carriage return because the Enter key used to say return and so you know that's how users think of this the hardware oriented people say line feed is really the way printers want to work they want to advance to the next thing and so you know how do you decide which one to do well there was a committee in the early days of the internet trying to decide which one should we use and they couldn't decide so they came up with the mutually disagreeable compromise which is we'll use both of them which doesn't make any sense that using both of them went out with mechanical teletypes but we're still doing that if you look at the internet standards look at HTTP it still says you have to use both it doesn't both at the same time it just doesn't make any sense we also have form feed which told the printer to eject the current page and put the next page into the printer so you can start printing and a companion vertical tab which is the vertical version of the horizontal tab but again they didn't specify any way of setting a vertical tab stop so it today it doesn't make any sense JavaScript still lets you say backslash of e representing this it doesn't mean anything and just it's pointless there were four device codes in ASCII so that you can control devices and generally that meant controlling the paper tape reader and the paper tape punch so you're telling a per tape reader on it and if the computer wants to start reading it it can send you can turn the reader on and then it'll start automatically sending characters to the computer and if the computer starts getting overwhelmed oh there's too much input they can then tell it to stop and the computer could also turn on the punch so you can start punching your paper tape those codes are still in ASCII then there are codes for dealing with protocols because they imagine that instead of just sending streams that we might actually be sending higherlevel stuff and so this was really new stuff that they were kind of inventing so they imagined that we'd have protocols in which we'll have a start of header and a start of text code and an end of text and an end of block and we'll use those to make packets packets were still a really new idea and then in support of that we have AK the acknowledge code so if you successfully read a packet you'll send it back ACK and if for some reason you couldn't read the whole packet you'll send back nak and there's also the synchronous Idol they anticipated asynchronous mode in which well in a in a circus note mode there's a start bit and a stop bit on each character and that's so you've got an empty stream and then you see a start bit and you go Oh wake up there's a character and you keep getting bits until you get the stop and then you can go back to sleep but there's also a synchronous mode in which the characters go one after another no start bit no stop bit and the problem is how do you know where the character boundaries are because it's just ones and zeros and so they have asynchronous idle so when there's nothing being sent you send this code and on the other side they'll be looking for a pattern of those zeros and ones when they see them they go off that's a character and then they can deal with the rest of it so a packet might look like this you might have a start of text and then the body of the message and then the end of text or you could put a header on it the header might contain an address or some other information which helps you to deal with the packet and using the end of text block you could have really long things and you can get an ACK after each one because it might be too dangerous to try to send something really long because it's guaranteed you're gonna get an ACK so if you send it in smaller chunks then you might get stuff through there are two end codes one was end of transmission so at the end of the session you'd go control D yeah that's the end then we can hang up and and we're finished and there is also end of medium this is something you might put on a tape so you write a tape and at the end you'll write and then to medium code and that means that's the end of the tape then there are a couple of oops codes there's the substitute code that means that if you have a character and you don't know what it is you send the substitute code instead again today the way we think about data communications that doesn't make any sense how can you not know what a character is and still want to send it but you could do that also there's a cancel code if something is coming or if you're sending something side i never mind I'm not going to send the rest of it you can just send the cancel code and and you're done there's escape escape was not what we use it for now escape was for extending the character set they anticipated that the hundred twentyeight characters in ascii might not be enough so escape would allow some way of extending the character set so when you see the escape code that means the stuff that comes after it is going to be interpreted differently one interpretation that was popular for a while was add an eighth bit to the character so that would get you up into the latin one set but so there is an escape key on the teletypes for that purpose but very quickly people realized we're in a program and we want to make the program stop how do we do that you know I've got this escape key let's let's hook that up and we're still using it right escape gets us out of a mode or cancels the dialog or something like that it was never intended for that is intended for enhancing the ASCII set we have data link escape which does a similar thing sometimes it's used for making a control code literal so if you've got some binary data and you want to be sending an end of transmission mark but you don't want to hang up you want it to be treated as data you might put in DLE in front of it but it could also be used to introduce new control codes because they were concerned that 32 control codes were not enough they thought they might want a lot lot more then I told you about the shift codes for uppercase and lowercase they decided not to use them for that but they still put them in the code and so you could shift out meaning it could shift into another character set and then shift back into ASCII another way of growing the code they provided information separators so there's the file separator the group separator the record separator and the unit separator so they did not intend for or I've heard people say that tabseparated data is the way asking intended us to format data and it's not this is how ASCII intended us to format data you have files made up of records made up of groups made up of units of data unfortunately this isn't really how data ended up that sometimes you have records that really want to contain other records you know so this this doesn't work so I should have told them about Jason right because that's what they really should have been doing but I didn't and my excuse is that I was eight at the time and I was doing other things it's just too busy ah yeah so so that's the ASCII set so again they did not intend this to be a computer character set this is just something that computers would use to communicate with each other but a number of manufacturers thought well let's just try to use this as is because then we don't have to translate from our set into their set for one very common use was something that I called half ASCII [Laughter] where you just take 64 characters of it you said you cut out the control codes and the lower case you just subtract 32 from everything and that gets you a nice little six bit character set and there are a number of manufacturers that we're doing stuff like this it it all changed with the microprocessors but we'll get to that in a bit so the next step forward is Unicode Unicode starts in 1991 some very very smart people from Xerox and Apple and other places who have been really struggling trying to make products that worked all over the world and realize we need to figure out what figure out a way to unify the character set so we can just have one product that goes everywhere and so their goal was to make a after set that would serve all of the living languages in the world in 16bits and they came really close to pulling it off but in order to do that they had to do something called Han unification which meant taking or observing that Chinese was the route also of Korean writing and Japanese writing and taking all of all three of those languages putting them into one character said it's too big doesn't fit in 16bit character sets but if you look at how common those languages still are at least in their orthography then we can squeeze it down into sixteen bits and they tried really hard to do that unfortunately they really pissed off the Japanese but they we're not happy about the way that happened so that brings us five years later tina code two and unicode two now has a much more expansive mission they have grown the character set to 21 bits and they now want to encode all languages even dead languages you know so Egyptian hieroglyph hieroglyphics become part of Unicode which is something I like a lot so I like that unfortunately in 2010 we get unicode six and emoji for a while there was a hope that some day we could finish unicode right we'll find all of the languages that have ever existed we'll write them all down and we'll give all the characters codes and we'll be done unicode will never be done there's no way for ever get in front out of emojis so ASCII lives on in unicode the first hundred twentyeight characters of the unicode set are at the ASCII set even though ASCII was not intended to be a character set in unicode was intended to be a character set in computers ASCII is in there including the 32 control codes which you now know are mostly meaningless and completely ridiculous right they they don't serve us anymore and the way this stuff works is really important for example in the C language we use the null character to represent the end of string which is not what ASCII said but that's what C says which means that C would have broken on any of the earlier 6 bit character sets because they did not have a null code they all used 0 for a real code so ASCII changed the way we think about programming of letters and words but there was an even bigger influence than that under the influence of 6 bit character sets there are lots of different hardware architectures with lots of different word sizes but they all seem to have a factor of 3 in them so I saw I worked on carat on machines that had 12 bit characters 18 bit characters 24 I'm sorry 12 bit words 18 bit words 24 bit words 36 bit words 48 bit words 60 bit words the thing all of these machines had in common was 6 bit characters and the reason that worked was because that's what the character sets were and so you could pack some number of characters into a word and it all fit and it was really good and these were great machines and and then it all changed so 7bit ascii cause the ascendance of computer architecture based on eight so IBM took ascii and weirdly mutated it they combined it with their terrible BCD IC code and came up with something a really awful thing called ipsa dick and used that as the character set for the 360 series so that system is based on eight sixteen thirtytwo and all of her machines pretty much since then are based on that the the big change I think happened because of Intel so Intel built a machine called the 8008 which was the design was brought to them by a company in San Antonio called data point they made intelligent terminals and they were making them out of discrete logic and they were difficult to build and they came up with a design for a simple CPU which would have greatly simplified their terminals and they asked Intel if they would build that chip for them which they did so the initial design of that chip was an 8bit machine and the reason it was a bit was so that it could process ASCII that was the intended purpose of the 8008 but that 8008 grows into the 8080 and the 8086 and the pentium and all the crap that comes after and so it's all 64 bits now so if the ascii committee had successfully completed as a 6bit character said 36 bit architecture would have survived and so I think the first microprocessors would have been 12 bit machines not 8bit machines and that would have completely changed the evolution of stuff that the next step up would have been 24 and so a lot of the memory limitation issues that we felt on PCs we could have avoided those four years and then taking the next step up to 32 and today we would be running in 72 bit architecture which I think would be brilliant you know it would have completely changed the way we do internationalization Europe would have moved immediately to 12 bit character sets because 6 didn't work in exactly the same way that Asia moved immediately to 16bit character sets because 8 didn't work and by doing that we would have avoided all of those internationalization problems and then ultimately the world would adopt an 18bit character set which would be the unicode set which would serve everybody and seventy twobit CPUs would be the standard today so that's the end so I'm really looking forward to some excellent questions which will help me figure out what the WoW finish is to this thing so any questions are we learning from our mistakes in this field no now we generally don't do that we will adopt something because it seemed like a good idea at the time and we tend to never revisit it again and so you know as you look down into the history of what we've done and why choices were made and then see where they ended up you know it just you know if we had known where it was going to go we wouldn't have done that but somehow we're still here where we are and we don't recognize that we're still doing that that's just the way we do things yeah yeah what's the path going forward that's a really hard problem I mean I commend with the ASCII committee for doing as well as they did they got a lot of stuff right they were very thoughtful in the way that they approached the problem and they did the best they could where it went wrong I think was not in the ASCII committee it was after again they didn't intend intend for it to be a computer character set the intended to be a transmission code but there were people particularly in the 8bit world who wanted to save the cost of a character translation table you know they wanted to save you know under 28 bytes and if we make that our character set we saved hundred 28 bytes and at the time that seemed like a really good tradeoff but it was only a really good tradeoff for a few years eventually Moore's law changes the economics of memory conservation and that it becomes a really bad idea but again once we lock something into a standard or a standard practice it gets it's virtually impossible to roll it back yeah yeah that's a really good question so you would think so that's a really good thoughtful question I'm afraid I don't have an adequate answer for it but thank you for that question yeah yeah so are there any alternatives to Unicode being considered I don't think so I think Unicode Unicode is likely to be the last character set not you know it's just gonna be the way it is and there are some things about Unicode that I think are extremely commendable that they've done some brilliant stuff and there's other stuff in Unicode where you go you know this is awful like I showed you that substitution code in ASCII the one that says the letter you're looking for it's not here or the code you're looking for it's not here not only is that code now in Unicode Unicode added another one so Unicode has its own substitution code saying when it's not here which go we need zero of those codes right and we've got two of those codes one of the things that was liberating about ASCII was because they've got so many characters they didn't have to be nearly as cautious as ASCII was asking when they were picking the characters to go in that set they made really really hard choices and if we put that one in we can't put that one in you know they didn't put the arrow in because they just couldn't make it fit which was it was actually in there for a while and then it got taken out and replaced I think with the underbar you know so you know this stuff stuff I could anticipate I could think of one thing that might propel the world to consider doing a new character set and that would be something that would try to solve the sorting problem so unicode sorts correctly for virtually no languages right well or at least four languages using the latin set that none of the languages sort correctly we could try to and there is no ordering of the letters that will sort correctly for all languages but we could come up with a sorting which would work for most languages so we could design a character set in which we have a followed by a accent followed by a umlaut and so on we'll just batch them all up you know after i comes i J and then J and then K and so on will just take try to take as many of the European characters as we can and put them into one linear sequence and maybe that becomes a good enough idea that we can say this becomes the basis of a new character set I can't imagine anything else you know I think that would be a problem that would be worth solving and that might get us a new character set but I'm really doubtful I don't think we could pull it off there is so much inertia behind Unicode now I think it's going to be the end yeah is there any way to work in three dimensions and character cells or you can stack them up and that's essentially what Unicode does so in Unicode you've got it stacks them in a couple of dimensions one is you've got planes so you've got the basic plane then you've got sixteen additional planes which are all in the same 16bit set and within the 16bit set you could see that is broken into stacks of 8bit sets so that's a three dimensional character set yeah yeah that's the problem because there are definitely costs but all of those costs have already been accepted so in changing to something better it's really hard because it's obvious that there's going to be new costs in moving to the better system and it may not be immediately apparent to what the benefits are whereas we don't properly account for the costs in the old system so the new system is going to be at a huge disadvantage yeah could there be advantages to compression by altering the character set maybe although some of our our compression codes are our smart codes that learn in our adaptive so they seem to be doing pretty well I don't think we could get much improvement by changing the underlying character set yeah it's more bits yeah so the memory addressing problem we passed 64 bits looks like we're gonna be good for a long long time with that so and 64bit is well so in JavaScript we get essentially 53 bits at least on our integers and that's quite a lot particularly when you compare it to the 32bit architectures and much of JavaScript unfortunately is still 32 bits and there's been some pressure to try to get JavaScript to add a 64 bit thing which I'm very opposed to that if you want extended arithmetic you can write a simple function in JavaScript that gets you extended precision so we don't really need to change the language fundamentally and if you have two number types and if they ever come in contact with each other you're guaranteed to have errors right because values are not yeah that kind of stuff so I'm very unhappy with the floatingpoint system we have in JavaScript it's it's horrible but I can't see that we're going to replace it because again we've accepted all the costs of a floatingpoint system that works really badly and so we're not going to get be able to overlook the costs of moving to something that's going to like add money correctly even though that I think is much more important I think Dex 64 would be great and I highly recommend that Dec 64 be the only number type in the next language but I have no hope that it will ever get a JavaScript JavaScript is whereas Brendan Eich used to say that ship has sunk yeah yeah quantum computing is a completely different thing so you've got these quantum bits which can be in multiple states simultaneously and it's presumed that that leads to the solution of problems which cannot be solved in linear time on conventional hardware but they don't act like bits so there's not a correspondence to bits they're different stuff so even if we do get quantum computing I think it will be used in very specific applications things where you get the benefit of the undecidability in order to solve very hard problems one of the most popular expected application that seems to be breaking of cryptographic systems so which will certainly be problematic but it doesn't appear that it's going to be a platform for generalpurpose computing so I think we'll still have bits for a long long time now a more interesting breakthrough might be trying to figure out the neural stuff that we still haven't figured out how this stuff works yet but we know really well now that it works really differently than digital systems so it may be that eventually we'll figure out how to make neurons and stuff like that and that will work on a completely different principle and who knows what we'll do with that anybody else okay so I think we're done thank you very much so yeah yeah I think thank you I mean like this is amazing thank you guys for coming out stay tuned for more meetups lots to come does everybody know what our JavaScript la YouTube checklist feel like okay does anybody have questions I'm sorry on which side give me a better picture so I can find oh yeah oh great great thank you very much
