With timestamps:

00:00 - A graph data structure is a nonlinear 
data structure consisting of vertices  
00:05 - and edges. They're used to solve many real 
world problems and are commonly needed to  
00:10 - solve coding challenges. Harris from coding 
cleverly teaches this graph course using Java.  
00:16 - Harris is extremely knowledgeable 
in algorithms and data structures.
00:20 - Hey there everyone, this is coding cleverly. And 
today we're going to be talking about the graph  
00:26 - data structure. We're going to talk about how it 
works, how it's constructed, and all the important  
00:32 - stuff we need to know about it. The first thing I 
did was create three different files in the same  
00:36 - directory. Here I have graph dot Java, and then 
we have vertex dot java. And we also have edge  
00:41 - dot java. And what I'm going to do now is I'm 
going to actually write some code, and then I'm  
00:47 - going to try to interlink these, all three files. 
Because this edge, this vertex and this graph are  
00:54 - going to be used together to create our graph data 
structure. Before talking about graphs, I want to  
00:58 - talk about the graph traversals there are many 
ways to traverse a graph, but you will focus on  
01:03 - three methods depth first search breadth first 
search and Dykstra algorithm. These traversal  
01:08 - methods are core algorithms for searching a 
graph. Now what are graphs graphs are the ideal  
01:13 - data structure for modeling networks, making them 
an essential part of your data structure toolkit.  
01:18 - They are made up of nodes, or vertices, which 
hold data and edges which connect to vertices.  
01:25 - A vertex is a single node. Now all of this 
will be explained through the diagram. Here's  
01:30 - a sample of a graph that I created. These 
circles everywhere are actually vertices,  
01:34 - and they're holding data and edges, which connect 
to vertices. So these lines over here are known as  
01:41 - edges these things now I want to give an example 
consider a map of your neighborhood. As a graph,  
01:46 - we could represent bus stops, as vertices and bus 
routes, between stops as edges. So how about the  
01:53 - internet web pages can be thought of as vertices 
and the hyperlinks that connect them as edges.  
02:00 - Real world relationships are represented as 
graphs are numerous, making them an important  
02:05 - concept to grasp. The graph, which could see over 
here is actually representing a social network.  
02:12 - People are vertices and edges are friendships. 
So these lines are friendships. These circles are  
02:18 - the people Peter, Cody and Jordan are all friends, 
Peter and Cody are friends. And the same goes for  
02:24 - Cody and Peter, Peter and Jordan are also friends. 
And Jordan, all and Peter are friends as well.  
02:29 - So this bidirectional pattern is also existing 
here, Jordan and Cody are friends. And Cody and  
02:34 - Jordan are friends. One other thing that we see 
here is distinct, which is Caleb and Alex. Now,  
02:39 - these are friends. But these are not linked with 
these people over here. Interesting. A path is  
02:44 - made up of vertices connected by any number of 
intermediate edges from Peter to Cody, the paths  
02:51 - could be Peter to Jordan to Cody, or Peter to 
Cody. There is no way between Peter and Caleb, a  
03:00 - graph is disconnected when no path exists between 
two vertices. So this here is a disconnected  
03:06 - graph. Because not all of these vertices are 
connected with each other, it's impossible to  
03:11 - reach here. So this is the reason why this graph 
is a disconnected graph. Alright, so now let's  
03:15 - map out this concept in our code. Now, what we 
want to do is we want to create a graph class  
03:21 - that could be flexible enough to support directed, 
undirected, weighted and unweighted graphs. Now,  
03:30 - the difference between a directed and 
undirected graph is that for directed graphs,  
03:35 - which is so this is an undirected, disconnected 
graph, because there's no link here, and you can  
03:42 - reach here. So this is disconnected. The reason 
why it's undirected is the reason that both of  
03:49 - these paths are like bi directional. So over here, 
Peter and Jordan is Peter is friends to Jordan,  
03:55 - and also Jordan friends to Peter. So this 
is bidirectional. So and this is undirected,  
04:00 - if it's directed, it would have arrows here. 
So it would point that Peter is only friends  
04:05 - to Jordan. But Jordan doesn't like him back. And 
Jordan is friends to Cody, and Cody doesn't like  
04:09 - him back. So something like that is going 
to be directed. In case of weighted graphs,  
04:14 - you'd have weights on top of each. So I know it 
doesn't make sense over here. But if we had like,  
04:21 - stopped, bus stops, and then their 
routes, it would have been easier  
04:26 - and easy to map out. But here, if I say 
Peter, and then Jordan, it takes like,  
04:31 - let's say five. So it's something like this. And 
then we have over here we have, let's say 10.  
04:40 - And over here, let's say it's 12. So over here, 
now we got weights on top of the edges. And these  
04:47 - are just going to indicate the number or the 
expense that we're going to take here. So Peter,  
04:54 - I know it's not a good example, like I said that 
we could have done with bus stops and routes,  
04:59 - but here we're at Again, Peter is finished 
with Jordan. And I don't say five times. He,  
05:05 - he likes him five times this. Jordan likes Cody 
10 times. And Cody likes Peter 12 times, I'm  
05:12 - not sure if that was a good example. But you you 
got my point there something like that it with,  
05:18 - which associates the numbers as they're expensive 
with this in mind, we will create our graph with  
05:25 - the following requirements of vertex can store any 
data. So these circles, a vertex maintains a list  
05:31 - of connections to other vertices represented by 
a list of edge instances. So we're going to have  
05:36 - a vertex, we're going to also have its list to 
connect other ones. So those are going to be  
05:40 - called as these vertices and they're going to be 
linked through the edges. So here we have Peter,  
05:45 - but friends are Jordan and Cody, right. So 
we're going to have to put that in some kind  
05:49 - of structure here. So it's going to be a list 
of edges. So they're going to be represented  
05:55 - by all this stuff, Edge instances, a vertex can 
add and remove edges going to another vertex.  
06:01 - A graph stores all of the all of its vertices 
represented by a list of vertex instances. So all  
06:07 - of these vertices you see, are just going to be 
stored in that graph structure. Our graph knows if  
06:12 - it is directed or undirected. Like I said, this is 
undirected. And if it had some kind of direction  
06:17 - it would been directed, a graph can add and remove 
its own vertices graph can add and remove edges  
06:24 - between stored vertices with all of that other 
way, let's write the code. So to keep the concepts  
06:29 - grounded in a real world application, we'll build 
a transportation network of bus stops as we go,  
06:35 - what I want to do first thing is actually look 
into my vertex class. And because I know this is  
06:43 - a circle, which has the data, and it's also 
going to have the edges, so we're going to  
06:48 - start from this one. Here, we're gonna go into 
this class vertex here. And we're just going  
06:54 - to create some instance variables. So the first 
thing that I am saying is private string data.  
07:05 - Second thing that comes to the mind is private 
ArrayList. Because we want to store the edges,  
07:13 - right, so we say ArrayList, we put the type of 
the ArrayList here, so we're going to store edges.  
07:20 - So it's an ArrayList of edges. And we're going 
to call this as edges. Alright, so now we're done  
07:28 - with that, let's add a constructor here, we're 
gonna say public. And we're gonna say vertex.  
07:34 - Here, we're gonna have a string. And we'll 
say input data, the data that the user will  
07:43 - provide. And then for that will take the class 
variable is equal to the input parameter.  
07:52 - And then we have this dot edges, which is the 
edges, and that would equal to the new ArrayList.  
08:02 - And here we want the edge. And we also want 
this. So here, we instantiated the array list,  
08:12 - which was this edge is one. Now I know this 
is giving us problems, because it's not  
08:17 - allowing us to have this. So let's just import 
this import Java dot util dot ArrayList. And the  
08:21 - errors are gone. Here, we have a vertex 
constructor that assigns the data with  
08:28 - the input data and also instantiates the 
edges list with a new ArrayList of type  
08:35 - edge. Now we got these vertices right, now we 
want to have a mechanism that will allow us  
08:44 - to see these edges in live action, right. The 
other thing that I want to go through this is that  
08:50 - I'm going to create this as a directed graph. So 
there's going to be arrows here, a method called  
08:55 - public void, add edge. And over here, we're gonna 
add in the vertex and vertex and integer. Wait.  
09:21 - Alright, so now that this is done, and we just 
created this constructor for this, I mean,  
09:25 - know the instance variables. Let's move on to 
edge dot Java and create the instance variables  
09:30 - for here. And then after that, we're going to go 
back to this vertex dot Java and finish it up.  
09:35 - One thing I want to make clear here is that I'm 
going to create a directed graph. It's going to  
09:40 - be the ones that have the arrows, it's not going 
to be the bi directional ones, which would go both  
09:44 - ways. It's just going to be one, one stop to the 
other stop, right? It's a bus stop. So I don't  
09:49 - want to go backwards. So in this case, it's just a 
directed graph. What we're going to do here is for  
09:55 - the edge, like I said, it's just a line where you 
see in the graphical representation And by here,  
10:00 - I'm gonna have to try to map it out in code. So 
I'm going to have the start vertex, where it's  
10:05 - coming from, and where it's going to. So PRI, 
visit private vertex. And then we have the end.
10:15 - And over here, we want to wait, we're also 
going to create this as a weighted graph,  
10:19 - that will have a cost for how much expensive 
will it take to move from one place to another,  
10:24 - remember those numbers which were on top 
of those lines, so that's the weight here,  
10:28 - so it's going to be a weighted graph as well. So 
I'm going to put up weight in here as well. And  
10:32 - it's going to be called integer. And I'm gonna 
say W, RI ght, I'm going to put a integer Wait,  
10:38 - and notice I'm using integer and not int. It's the 
reason is that if I don't want to put anything,  
10:44 - I could just type in null. And it would allow me 
to just like Pass It On with no reason. And if I  
10:50 - had an integer, I'd pass in something like 
minus one. All right, so now over here, we  
10:54 - have a constructor and I will say public edge. And 
let's create the constructor here. So the vertex,  
11:02 - and I'll say the start vertex, so I'll call it 
as the start being the vertex. And we have any  
11:08 - vertex or we have envy, we have the integer. 
And we call it as the input weight, web ID.  
11:19 - So there you go. So we got the start 
vertex, the vertex and the input weight  
11:24 - that we're going to ask the user for. So 
remember, this is just an edge of that we  
11:31 - are creating as users. So the class variable, 
the start star will equal to the start vertex,  
11:36 - which will be passed in as an input parameter. 
The same thing goes for the disk dot end.  
11:47 - And it will equal to the end vertex, Jose  
11:52 - and vertex. And we have the way to so we say this 
dot w e IG ht, and we equal that to the input,  
12:00 - w e, IG HT. There you go. So now we're done 
with this. And let's just add in some other  
12:07 - helper methods. So I'm going to be adding some 
helper methods along with this. And I'm just  
12:12 - going to be copy pasting this. So here, these 
are the public vertex, get start. And it just  
12:19 - going to return the start vertex, the public start 
vertex get and will return the end vertex of the,  
12:25 - you know the edge of what's in the edge. And 
the integer gateway will just return the weight.  
12:29 - Okay, so that was cool. Let's go back to the 
vertex dot java file, and just make some methods  
12:34 - here as well. So for the vertex dot Java, and 
remember, like I said, we wanted to create a  
12:39 - function that will allow us to add some edges, 
right, we're not giving the, we're adding a layer  
12:45 - of abstraction here. And we're allowing the method 
over here, we'll just add it I just for us. So  
12:50 - what I could do here is I could say, a public. 
And I'd say, void, add, II D, so II, add, add,  
13:00 - so add edge. And if we want to add an edge to a 
vertex, so remember, the current vertex is already  
13:06 - in the context. So this will be the end vertex. 
So I'll just pass in the end vertex here. And  
13:12 - also the weight if you want to give it some kind 
of weight. Remember, I said weight is optional.  
13:17 - If you don't want to give it it will be assigned 
as not to do something like that. First of all,  
13:22 - I'm going to have the call to this, I'm going to 
say this dot edges, et je s, because it exists and  
13:29 - edges over here. And then there is a function that 
was called add for the ArrayList, because edges is  
13:34 - an ArrayList. And we just add in a new ad G, and 
we call in the constructor, so this constructor  
13:40 - will add pass in the this, it will get the edges 
and a vertex, so it's going to be an vertex,  
13:48 - and will also be the weight of the edge. So all 
of this will be mapped in here. So this is our  
13:55 - add edge, and it's gonna just gonna add some 
edges here. All right, so now we're gonna have  
14:00 - to create the Remove edge here. So we're 
gonna say public, and I'm gonna say void.  
14:06 - Remove Ed G, and we have vertex, and we 
have an vertex. And over here we have  
14:20 - the, this dot EDG II, I just got removed. And 
the method for this is, since it's a just as  
14:30 - an ArrayList removed if will allow us to add a 
predicate and remove all of the elements of this  
14:37 - collection that satisfy the given predicate. 
errors at runtime exceptions thrown during  
14:42 - iteration or by the predicate are related to the 
color parameter here is a predicate. And here you  
14:47 - can read it. It says filter a predicate, which 
returns true for elements to be removed. And I'm  
14:52 - going to add that predicate here. So over here, 
I'm going to add in, so I want to remove that  
14:57 - vertex. So here I'm saying remove edge right And 
I'm in that vertex. So I'm in the vertex, Java,  
15:03 - and I want to remove that edge that was passed 
in as this one. So n vertex, right, I want to  
15:07 - remove that edge from here. So I would say, I just 
removed if now say, I remove that kind of edge,  
15:14 - right? I know, we put this arrow bracket. So 
this is an arrow sign, and I'm gonna say edges.  
15:19 - And then we say get added, because we're getting 
actually, two things here, the edges are having  
15:25 - two places. One is the first. And the second is 
the end. So you can see in the code over here,  
15:32 - we have the start and the end. So the edge 
has two things. And what we want is the end.  
15:38 - So that's why we are getting the second one. And 
that's going to be over there. So they'll get and,  
15:45 - and then we say dot equals, so we say if that 
equals to the vertex that we passed in here, I'm  
15:51 - just gonna copy that and paste it here. And for 
that equals, then just remove that from there. So  
15:58 - we just need a semicolon here. 
If I could get a semicolon,  
16:02 - all right. And that should solve our problem here. 
So it's just going to remove that end vertex that  
16:08 - we passed in as an input parameter. And it's 
going to look at this, just dot remove if and  
16:13 - it's going to pass in this predicate logic that 
says, find that edge, which has the end vertex  
16:19 - equal to the end vertex that was passed in pretty 
easy. Okay, so now we're gonna add in some other  
16:25 - helper methods, I'm gonna copy paste this as well. 
So I'll just paste it here. So the first thing,  
16:32 - let me just zoom out and show you what I've done. 
Here, we have this remove edge, and we have the  
16:39 - Add edge perfect. Over here, we have this Get 
Data method. It's a string return type. And  
16:43 - it's just going to get the data for the vertex 
pretty easy, straightforward. And the ArrayList  
16:48 - edge. So this is the return type, and it's in 
get edges. So it's just going to return the,  
16:54 - the edges that the certain vertex has. So it's 
just going to return the list of it, this dot  
17:00 - edges. All right. Now over here, we have a public 
void, print Boolean, show eight. So over here,  
17:07 - we have this printer method that's just going to 
allow us to visualize our implementation. And it's  
17:13 - just going to show us how the graph is looking 
like inside of our structure. So it's pretty  
17:18 - easy, you don't need to go into detail for 
this. And if you want to write this down,  
17:24 - you can pause the video and start typing this in. 
We're done with the edit of Java. And we're also  
17:28 - done now with the vertex dot java. In fact, 
I don't even need this main method here. So  
17:33 - I'm just going to remove that here. And now we 
just have this so the Virta edge dot Java and  
17:39 - the vertex dot Java are done. Let's go to the 
graph dot Java, the main thing, the main boss,  
17:45 - so over here, we're just gonna add in the 
following things. Remember, like I said,  
17:49 - a graph is a list of vertices. That's exactly 
what we want to do here. So I'm gonna say private.  
17:56 - And I'm gonna say array list. And I'm gonna put 
in the type here, the type for this is vertex,  
18:02 - because we're putting in vertices, and we're 
going to pass in vertices like this has a name.  
18:07 - Now we also have a type, which I've specified 
that there could be different kinds. And my  
18:14 - graph will be a weighted graph. So I'm just 
going to put an is weighted boolean variable,  
18:20 - I'm also going to put is directed boolean 
variable. And this is just going to tell me  
18:28 - if the graph is directed with arrows, or if it's 
unidirectional, or bi directional. And so that's,  
18:34 - that's the thing. Let's create a constructor 
for the graph. And we'll just say public graph.  
18:41 - Graph, and then we'll just pass 
in Boolean. And we'll say input  
18:49 - is weighted. So the things that are passed 
in will be determined by the user. And pool  
18:58 - Boolean input is directed. So with all of this, 
and here we're gonna have the this dot vertices.  
19:10 - And we're gonna say new array list and we're just 
gonna pass and so over here we have graph and then  
19:20 - we have Boolean, input his weighted, and then we 
have input as directed. So like I said, we're we  
19:27 - have to first initialize the vertices array 
list, so I'll just say new ArrayList vertex,  
19:32 - put the round brackets and then the 
semicolon this will initialize our vertex.  
19:38 - This will initialize our vertices list and 
for the weighted thing, so we can say is W E,  
19:45 - weighted is equal to and we say 
input is weighted, so W E IG ht,  
19:53 - for the other one which is directed so is directed 
is equal to input is directed There you go.
20:03 - Cool. So now this is created. And yeah, 
I have to import the ArrayList as well.  
20:09 - So just import that as well. Now let's create 
some methods. And the important methods that  
20:15 - we want to do here is that we want to create 
a method that will allow us to add vertex,  
20:20 - add some vertices to our array list. And the 
name for that will be self explanatory. It's  
20:26 - called vertex. And that's the return type. 
So it's going to be called add vertex. The  
20:33 - data that will be passed in was a string. And over 
here, we'll say vertex. And we'll say new vertex.  
20:45 - And over here, we're just going to create 
a new vertex here. So we'll say new vertex.  
20:51 - And we'll pass in the data that was passed in.  
20:56 - And over here, we're gonna put that inside of our 
list. So we'll say this dot vertices dot add, and  
21:04 - we put the new vertex, semicolon. And then we have 
the return new vertex. Cool. So we're done with  
21:18 - this, that's the Add vertex method. And it just 
returns to us the vertex. So we'll have to assign  
21:23 - it to a variable in the main methods. So now we're 
going to create the public void, add edge method.  
21:34 - And this will allow us to pass 
in the vertex, vertex one,  
21:39 - the vertex, vertex two. So this is the start and 
the end vertex and the integer way, like I said,  
21:47 - I wanted to create a level of abstraction here. 
So I'm allowing our graph to have the Add edge  
21:54 - of functionality as well. So over here, 
it's pretty straightforward. If I said,  
21:59 - if the thing is weighted, then there's going 
to be no weight for this because I passed an  
22:04 - integer weight. And I have to first check the 
boolean variable here. So if I say is waited,  
22:11 - not directed, but is W E, IG HT. Now if the 
waiter was false, then so it says if waited,  
22:19 - is false, right. So we'll just say, the wait, 
that was passing, it will be assigned as null.  
22:29 - All right. And if it's not false, meaning if the 
thing is weighted thing, so we'll say vertex, one  
22:38 - dot add edge, and over here, we're 
actually adding the vertex to.  
22:45 - And here the weight will be passed in as 
well. And this is the Add edge method.  
22:50 - That's from the vertex class here. So the 
vertex add edge, this one. Now, over here,  
22:57 - we want to actually add in the other thing around 
as well, because we don't need bi directional  
23:02 - and unidirectional. So if it's undirected than 
both right, and if it's directed than just one,  
23:10 - so I'll say if it's not directed than both, 
so this.is directed if it's not directed.
23:19 - Then we'll have the vertex, vertex two dot, add 
vertex, or, yeah, so vertex two dot add edge,  
23:32 - here, we're gonna add the edge. 
And we're gonna say, vertex one.
23:38 - And we're also going to put in the weight over 
here as well. And there you go. Similar to how  
23:45 - we created the Add edge method, we now need 
to create the Remove edge method. So let's go  
23:52 - here a little down. And let's add the Remove edge 
method. So we're just like I said, I'm giving the,  
23:58 - the power to the user to do all of this. So 
and the user doesn't even have to know how  
24:04 - the vertex Java or Java works. So that's the 
layer of abstraction that we're creating here,  
24:11 - remove edge, Ed EDG II, and over here, we're gonna 
pass in the vertex. And we'll say vertex. So to  
24:21 - remove the edge, you'll have to need you'll need 
the vertex one. You'll also need the vertex two.
24:33 - Now to remove it, it's pretty simple. We say 
vertex, one dot remove, this is the method  
24:41 - that was there. So remove edge and it takes 
another vertex. And we have the vertex here,  
24:46 - we're just gonna pass in the vertex two. And there 
you go. And then, like I said, we have to check if  
24:51 - it's not directed. If it's bi directional, then 
we have to remove the other way around as well.  
24:55 - So I'll say if this.is done directed. So if it's 
undirected, right, so if it's bi directional,  
25:04 - then after moving the other way around, as 
well as using vertex two dot, remove edge,  
25:08 - and we put in the vertex one. Okay, so that was 
pretty much it with the Remove edge. Now we have  
25:15 - some other methods like remove vertex, so just 
add an empty move redex, quickly over here, void,  
25:22 - remove vertex. And for the Remove vertex, we 
have the vertex that's passed in as like this.  
25:33 - And what we're going to do is we're going 
to say this dot vertices, which is the list  
25:39 - that is existing here in this class, this instance 
variable, and we're going to use the remove method  
25:44 - that's provided by the ArrayList. And we're just 
going to remove the vertex that you just asked  
25:49 - for, right, so that's just going to be removed 
here. Now to save some time, I'm just pasting  
25:55 - some helper methods that we also need here. So 
I'll just paste that in. And let's see how it  
26:01 - looks like. So here we have the get vertices, 
the remover index, the get vertices method,  
26:07 - it just returns the list is weighted, is directed. 
So that the last thing we did was this one,  
26:14 - which was removed the vertex, and then after that, 
this one is just to get vertices, it's just going  
26:21 - to return the array list vertex. So the whatever 
the array list is, it's going to return all the  
26:26 - vertices here, inside of that current graph. 
Public boolean is weighted will return if the  
26:31 - graph is weighted or not. And boolean is directed 
will turn if it's directed or not. Public vertex,  
26:38 - get vertex by value, passing a value, and it will 
loop through this. For condition, it's going to go  
26:44 - vertex. So you pass in a string value, and you try 
to look for that vertex for that kind of value. So  
26:50 - let's say I have a stop in New Jersey, let's say 
Jersey City, I'm looking for Jersey City, stop  
26:56 - for my bus, you know, bus route. So in the bus 
service that I'm trying to map out here, let's say  
27:02 - I have Jersey City passed in here, now I'm gonna 
have to look for that stop if it exists in this  
27:07 - entire bus ecosystem. So if it exists in the bus 
routes, if if there is any kind of bus stop, that  
27:14 - has the name, Jersey City, and then it will be 
returned here. So over here, I go for each loop,  
27:20 - and it says over here, the vertices are listed. So 
I would say for every vertex v, if the value is So  
27:26 - I'll use the get the data value and this vertex, 
remember that I created get data over here  
27:30 - somewhere. So it's supposed to be somewhere over 
here, there you go, it returns a data string. And  
27:36 - if it equals to the value that was passed it as an 
input over here, no more return the V vertex, and  
27:42 - then you'll have it as a vertex here. So perfect. 
And if it didn't exist, it will just return null.  
27:46 - So that will help us know if the vertex exists 
here. And now over here, if you want to print it,  
27:51 - so for vertex V in this vertices, v dot print, 
and we have is weighted, so you know the print  
27:56 - method that we created here, this will allow us to 
see all of these vertices in action. Awesome. Now,  
28:01 - let's create the main deal here. Let's create some 
graph. Let's create the graph data structure. And  
28:07 - let's try to map it out. And I'm gonna remember 
I said I'm gonna create a bus station. So I'm  
28:13 - gonna say gr, a pH. And I'm gonna say, bus 
network. And I'm going to say, new graph.  
28:25 - And over here, we're going to pass in for 
the is weighted, and for the direct fizzing,  
28:31 - we're going to pass in both true true. 
So T, ru, E, and t, are you ready? Now,  
28:38 - let me tell you why it's this. The first one was 
input is weighted, so it is weighted, there's  
28:45 - going to be values associated to it. So for every 
edge of there's going to be some kind of distance,  
28:49 - and the input is directed, meaning that there's 
going to be some kind of Arrow and it's so it's  
28:54 - a it's not bi directional. It's not two ways. 
It's just one way going forward. So bus network.  
29:01 - And I'm going to use the advert x method that 
we created here in this method. So it asks us  
29:06 - for a string data, and we'll just say that, 
say, Clifton. And here we have a semicolon.  
29:14 - But remember that this add vertex method if 
you go, if you go and see the method here,  
29:19 - it's actually returning a vertex. So we're gonna 
have to store in some kind of barrier variable.  
29:23 - So let's store it in a vertex. And I'll 
call this as Cliff Clifton station.  
29:34 - And it equals to that so there you go. And the 
same goes for the next one. So I'll say bus  
29:40 - network, dot add vertex, and we'll say vertex. 
And over here, we'll have the next station I'll  
29:50 - just add a caveman station. And let's have the 
vertex here as well. So, vertex and all Say,  
30:01 - keep keep me station. And just There you go. So we 
created two stops. And I think that's enough for  
30:12 - now. So now what we have to do is add the edges 
and the connections between them. So we use the,  
30:19 - you know, the Add Agile method. So we'll 
use bus network. And we'll say add edge.  
30:29 - And to add edge, we have to put one station to 
the next Jose Clifton station, and we'll say,  
30:35 - the cape Main Station. So that's the connection. 
And we'll also have to put a weight, let's put  
30:41 - a weight as well. So I'm gonna say it takes 1000 
miles to reach there. And that's our weight. Cool,  
30:48 - now it's connected. And remember that I'm not 
putting it. So I'm just putting it one way,  
30:54 - and it's just going to connect 
it that, you know, directed way.  
30:59 - Here we have that, if I wanted to remove an 
edge, it would remove it and using the same  
31:06 - but I'm just gonna say bus network dot remove 
edge and his pet pass in the same two things,  
31:11 - not the weight that time. In this case, I just 
want to print it out and see how it looks like.  
31:15 - So bus network dot print. And this is our 
method that was that is created here. I'm  
31:22 - actually calling all the vertices, so it's going 
to be printing it through here. Awesome. So let's  
31:28 - run this baby up and see how it looks like so I'm 
gonna command from here. And I'm gonna say Java  
31:35 - seed. The name of it is called Graph. God Java, 
it compiled. And now after that, I'm just gonna  
31:46 - paste here. So over here we have the direction 
from Clifton to keep me and it takes 1000 miles.  
31:53 - So that's exactly what we did here. Let me just 
minimize it quickly. And go back here. And if I  
31:59 - look over here, I actually created a direction 
from clipped indicate man, it takes 1000 miles.  
32:03 - And I didn't do the other way around. Like I said 
this was not undirected. It was directed because  
32:08 - it was such true. And here you can see that 
there's just one way from Clifton to caveman to  
32:14 - 1000. And I can't go from caveman back to Clifton. 
And if I want to do that, I could easily do that,  
32:20 - I could just modify this so input is weighted, 
that's set to true if I just leave this as  
32:24 - nothing. So by default, it will consider that as 
false. So alright, so I'm just going to have to  
32:31 - if I add in false here, and that's just going 
to make it undirected so it's gonna go both  
32:36 - ways around. And if I do this, now it's 
gonna go bidirectionally. So I'll say this,  
32:43 - and then after that, so over here we have clipped 
into Cape May 1000, and came back to Clifton 1000.
32:51 - Using graphs to model complex networks is great 
but graph search algorithms are another way graphs  
33:02 - can be useful. A graph search algorithm can be 
used to traverse the entire graph data structure.  
33:07 - In search of a specific vertex value. There are 
two approaches to using a graph search to navigate  
33:12 - a graph DFS and BFS DFS are depth first search 
follows every possible path to its conclusion.  
33:21 - BFS on the other hand, or breadth first search 
expands the search from the point of origin to  
33:27 - an ever expanding circle of neighboring vertices 
to track down what we visited, we add a list this  
33:34 - list will be very crucial because it prevents a 
search from returning to the same vertex multiple  
33:40 - times. This is especially important for cyclical 
graphs, where you could otherwise end up in an  
33:45 - infinite loop. And we've seen this in our previous 
videos. So you might be wondering, how does one  
33:51 - compute the runtime of graph search algorithms 
in an upper bound scenario, we will examine  
33:56 - every vertex and edge. As a result, the big ol 
runtime for depth first and breadth first search  
34:02 - is all of vertices plus edges. So you have the 
O and you have bracket vertices plus edges. Now,  
34:09 - here's a question. What if you don't need to find 
a path, but you do need to find a list of all the  
34:14 - values in a graph? What should be the solution 
there? Well, it turns out that in addition to  
34:19 - pathfinding depth first search is pretty adept 
at organizing vertices, or vertex values,  
34:27 - with a clear order of visitation from beginning to 
end. So you could use depth first search to find a  
34:36 - path and you know, like, instead of pathfinding 
about you go to organize and show the layout of  
34:40 - the complete graph structure. Using depth first 
search there are three main traversal orders that  
34:45 - you'll come across for graph traversal, pre order, 
post order, and reverse post order, also known  
34:51 - as topological sort, pre order, in which each 
vertex is added to the visited list, and added  
34:57 - to the output list before getting added to the 
stack. So that's just one thing to remember here,  
35:04 - in post order in which each vertex is added to the 
visited list and added to the output list after it  
35:12 - is popped off of the stack. And then reverse post 
order, which is also known as topological sorting,  
35:17 - which returns an output list that is exactly the 
reverse of the post order list. So post order and  
35:26 - reverse post order are just like the opposites 
of each other. Here I have a cool graphical  
35:31 - representation of a graph, take a look at this 
directed graph structure that I've depicted here,  
35:36 - let's say that we want a list of all vertex 
values starting with one in the order that  
35:40 - they are added to the stack. Now a pre ordered DFS 
traversal would come in handy. Now over here, we  
35:46 - would assume that the algorithm prefers visiting 
things in numerical order if there is a choice,  
35:52 - so our target value is one. And normally you would 
get a target value from the program. So our target  
35:59 - value is one here. So we're starting with one, 
we'll go with one. So this is the first thing  
36:03 - that's visited, this is also going to be on top 
of the stack. So over here, if we have a choice,  
36:08 - we're going to prefer visiting the minimum number. 
So over here, we have three and four, we're going  
36:14 - to check three, so we're going to go and visit 
three. And we're also going to put it on top  
36:19 - of the stack over here. After that, we see that 
there's four and two. So we're going to look at  
36:24 - the smaller number. And we're going to we're going 
to visit it, so two is going to be over here, two  
36:29 - is also going to be over here. And then we're also 
going to check for five. So because it's five,  
36:34 - and there's no other option, so we're going to 
have to check five, we'll put on the stack as five  
36:39 - over here. And the visited will go over here as 
well. Now the important part came, and you could  
36:44 - see that there's nothing after this. So we'll have 
to pop this thing out of the stack. So we're going  
36:50 - to have to just pop it out like this. And now 
we'll check to so two still has nothing with it.  
36:55 - So we'll pop that out as well. And then we'll 
check three, so three has something so it has  
37:01 - thing that was not visited, and it was four 
and it's not in the visited set. So we're  
37:07 - going to add that visit four over there. So 
just add four to the top of the stack here.  
37:13 - And we're going to add four here as well. Now, 
we're going to check for the four, and we're  
37:20 - going to see, well the four doesn't have anything. 
So we're going to pop that out on the stack as  
37:25 - well. And then after that we have three, so we're 
looking at for three something and a number that  
37:31 - is already that is not visited. So everything 
is visited four and two are visited. So we're  
37:36 - going to remove three, we're going to look at one. 
And if there's anything that is not visited, we'll  
37:40 - have to check. But there's nothing everything is 
visited three and four are there. So we'll remove  
37:44 - that. So this is how our list will appear 13254. 
So this is the pre order DFS traversal. Alright,  
37:52 - so like I said, that pre order is, is the kind 
of order in which each vertex is added to the  
37:59 - visited list, and added to the output list before 
getting added to the stack. So this was our pre  
38:05 - order traversal. Now we want to look at post 
order traversal, in which each vertex is added  
38:10 - to the visited list, and add it to the output list 
after it is popped off of the stack. So if we look  
38:17 - at take a look at the post order traversal, we'll 
go like this. So for the first thing, it's one,  
38:23 - so we're just going to look at one, we're not 
going to add it to the list or anything yet,  
38:27 - then we're gonna look at the smaller number 
which is three, then we're going to look at  
38:31 - something even smaller than that, which is 
two, then we're going to look at something  
38:36 - and then we have five. So there you go, the last 
number came, so it's going to go like this five.  
38:41 - And then after that, it's going to go and see the 
two because it's going to be popped off as well.  
38:45 - So five, two, and then we're going to look at 
three. So three actually has something for this.  
38:53 - So we're going to have to add four. And 
then we have nothing over here, so four,  
38:59 - and then we have back to three. 
So back to three. And then we have  
39:07 - we have the last one, which is one. So this 
is our post order traversal. This is how it's  
39:12 - going to appear. And the reverse post order, 
which is also known as the topological sword  
39:17 - will return an output list that is exactly 
the reverse of the post order list. So this  
39:22 - is a post order traversal. And the exact 
opposite of this is 1342 and then five.  
39:36 - So this year is the reverse posed order, also 
known as the topological sword. And these are  
39:42 - just different ways to traverse the graph. The 
most common was the first one which was pre order,  
39:48 - and that's the default thing. And it's easy for 
us to get a full overview of the graph like that.  
39:55 - Alright, so let's have a conceptual overview 
of how the depth first search DFS is going to  
39:59 - work. So let's suppose we have our target value 
as one. So we're gonna go and visit one here.  
40:05 - And we're also going to put it on the stack. 
So that's the top of the stack, then we'll  
40:09 - have to look at the number that is smaller from 
this choice. Over here, we got three and four,  
40:13 - we're looking at a smaller number. And we'll put 
three on top of the stack here. And we'll put it  
40:18 - as our visited set as well. So we have three, 
and then after that, we look at the smaller  
40:23 - number from these two, and the two is a smaller 
number. So we'll put it in the visited set.  
40:27 - And we'll also put in the DFS stack. So we'll 
put it up on the top over here. And now we can  
40:32 - see that five is the only option. So we'll have 
to use five here as the visited. And then we'll  
40:37 - have to put five here on the top of the stack as 
well. Since there's nothing over here on this,  
40:42 - there's nothing after the five, so we're going 
to have to pop this out. So to do this, we're  
40:46 - going to have to just select this number and just 
pop it out. And now we're going to look at two,  
40:51 - so there's nothing with two as well. 
So we're going to have to pop this out,  
40:55 - three has some unvisited vertex, which is 
this four, one, because it's not in the set  
41:01 - over there. So we're just going to have to use 
this now. So we're going to use four, and we're  
41:05 - going to put it over here. So four is going to be 
over here, and four will be on top of the stack  
41:09 - as well. Now we look at four, because this is our 
current current vertex. And there's nothing over  
41:16 - here that's unvisited. So we're gonna have to 
pop this out again. So let's just pop it out.
41:22 - So there you go, this is popped out. And now 
we look at three, there's nothing unvisited.  
41:27 - So we'll just pop this out, look at one, and 
there's nothing unvisited, so we'll just pop  
41:31 - that out. Once the stack is complete from here, 
so it's empty, we'll have a list over here 13254.  
41:38 - And this is a list of all of the vertices inside 
of this entire graph. So we have 1325, and four,  
41:46 - this was our DFS depth first search. Now let's 
write the code for this. So here I have a class  
41:53 - graph traverser. And it has a main method. And 
also I have a sample graph that I've created  
41:59 - earlier. And it just contains up some vertices. 
And yeah, it just has a method here that says Get  
42:06 - starting vertex. And we'll get the first vertex 
here from the graph. Now, our job here is to write  
42:13 - the code for depth first, traversal reversals are 
extremely useful when trying to find a specific  
42:18 - value or path in a graph. We'll start with the 
depth first traversal method for recursively  
42:24 - traversing a directed graph. To summarize depth 
first traversal, iterate down each vertex, one  
42:30 - neighbor at a time. In this video, I'll focus on 
traversing the entire length of a single path, and  
42:36 - putting the data value of each vertex. Now in test 
graph dot Java, I've created a sample graph for us  
42:42 - to test the traversals against this is all linked 
to my last video about graphs. So we created a  
42:48 - graph here, and we have this input is weighted 
as false and is directed as true. So there's no  
42:53 - weight, but it's directed meaning it's, it has 
directions, right. And we have a vertex, start  
42:59 - node, and we have tests, we have now add vertex, 
and we have the name. So these are the names  
43:03 - of our vertices. And yeah, so they're all these 
vertices here. Now I have all of these vertices  
43:09 - that I added, and then I created these variables 
to associate to them. And then after that, what we  
43:14 - did is add edges. So connections were done. After 
that, we created a cycle here as well. And this is  
43:21 - not exactly the same graph that I've made in the 
diagram. So what I have, what I have here in the  
43:26 - diagram was just simple so that you could easily 
understand how DFS works. But here I just created  
43:32 - a complex one so that we could test out cycles as 
well. And other things. After that, we have this  
43:37 - graph traversal dot java. To keep things simple. 
I created a separate graph traversal utility class  
43:43 - in graph traversal, dot Java, and I'll implement 
the traversal iterator as a static method here.  
43:48 - Now I've seen implementations in which they 
created the iterator inside of the graph class. So  
43:53 - now let's start writing the code here in the graph 
traverser dot Java utility class, we're gonna,  
43:59 - first of all, let's just add a method that is 
for the depth first traversal. So we say public,  
44:05 - and we say static, because it's a static method 
and void. And we're gonna say depth first.  
44:15 - Because we're using a static method here, because 
this is a utility class. So depth first traversal.  
44:24 - And here, I'm just going to pass in 
the vertex to start with. So a one I  
44:30 - need the very start vertex. And also I 
need a list of all the visited vertices  
44:34 - for this start one, so that will be called 
as an ArrayList. And I'm gonna put in the  
44:44 - vertex type here. And we're also going to put in 
the name as visited, and then we have vertices.  
44:51 - Cool. So now we're done with this. Let's add 
in the things here. First, let's just print  
44:56 - out the value of our start data. So we have 
a system dot out dot print Island, and we say  
45:03 - start dot get data. So you might be asking, Where 
do I get this get data from. So I already have  
45:10 - vertex dot Java included here, and I've created 
this in my previous video. So we have a Get Data  
45:16 - method, and it's just returns the string data, 
now that we're gonna have to iterate through  
45:20 - this vertex, and we're gonna check its edges, so 
all of the edges for the start vertex, so we could  
45:26 - use an edge at V of E. So for all the edges E in 
the Start dot get edges. So this is also a method  
45:41 - inside of the vertex class. So over here, I am 
saying that for every edge inside of the start,  
45:48 - edges, so that's this means all of those, 
all of those neighbors that are connected,  
45:53 - so we have to get the neighbor vertex to get that 
we got to use E dot get. And, and this will give  
46:01 - us a vertex. So you can see that returned gave 
us a vertex, and we're gonna save it as a vertex,  
46:07 - neighbor any igvh vor. Now, one thing to note 
here is that this e is an edge and the get end is  
46:17 - from the edge class. So this is also here. So get 
end is going to be somewhere over here, there you  
46:23 - go. And it returns the vertex, and from there, so 
it's just pretty simple. This one, the end vertex.  
46:30 - Now, right after this, I'm gonna have a 
conditional here. And I'm going to check if,  
46:38 - if my visited vertices does not contain this 
thing, so I'm going to add it inside. So now  
46:44 - we even know. And we could, we could mark that 
that we already visited or not to keep track,  
46:49 - if we visited vertices or not, we're going to add 
this conditional. So if we're going to use visited  
46:55 - vertices, and then we say, dot contains. And 
then we have the, the neighbor, and I say if  
47:04 - that contains inside of the visitor vertices, 
because you know that the visited vertices was  
47:09 - passed here. And I'm saying if it's not inside 
of the visitor vertices, then we want to add  
47:15 - it. So we'll just put a negation here. And let's 
also quickly add this import. So just over a year  
47:22 - and quick fix, import the ArrayList as well 
on top. Okay, cool. Now over here, in this  
47:28 - inside the conditional, I'm going to add in the 
visited vertices, and I'm going to say dot add.  
47:35 - And I'm going to add in the neighbor 
vertex here. So I'm going to say neighbor,  
47:40 - since our visited vertices holds the vertices, 
vertices, and we could easily add a vertex here,  
47:47 - the really important recursive call here is that 
we're gonna do a recursive call that will go to  
47:53 - the graph traversal again, so you're gonna call 
the graph traverser, which is this current class,  
47:58 - and we're going to call the method which is depth 
first traversal. And now it's requiring us a start  
48:05 - and visited, so the visit of vertices will be 
the same thing. But now we're gonna go with  
48:09 - the neighbor. So an E, I VHBO. Art of so we're 
done with that. And the conditional is done. And  
48:17 - here's the for each loop, it's going to iterate 
through all of the edges for our Stryver index,  
48:22 - and it's going to go until it's done. So that's 
pretty much it with our depth first traversal,  
48:27 - we could test it out in our main method, 
we're going to create a test graph.  
48:31 - And we're going to say test. And what 
we're going to say is new test graph.  
48:37 - Okay, so where am I creating this from this 
is actually from this place. And this is just  
48:41 - creating a test graph. Remember, like I said, it 
created this whenever this is a Public Test graph  
48:46 - constructor, and in the constructor is just doing 
all of the work for us. So normally, we would put  
48:51 - this in a main method, but we're putting this 
in a constructor. So it's creating a gigantic,  
48:55 - ginormous kind of graph with so many vertices. 
So V one v two v one one, we want to all these a  
49:02 - 1234567899 vertices, and they're connected edges. 
And what's it going to do is it's going to show us  
49:11 - through this, so we're just going to create it 
here. And we're going to pass it in. So before  
49:15 - that we actually need the starting vertex of 
our test graph as well. And we have created this  
49:19 - handy method here, which was get starting 
vertex, which returns us the first vertex  
49:24 - in our graph. So we could use test, and then we 
say, Get starting vertex. And this would just give  
49:33 - us the starting vertex and we go save it somewhere 
inside because of return. This actually returns a  
49:38 - vertex type. So we could say vertex, and we say, 
starting vertex, so we'd say, starting vertex, and  
49:48 - we'll just equal it. Okay, cool. So now that it's 
equal, now, we can add in the visited vertices. So  
49:55 - now let's add up the visited vertices list. So 
array list. And I'll put the type as a vertex.  
50:04 - And I'll call this as visited vertices, visited 
vertices. And here we're gonna pass in a new array  
50:14 - list. And here, we're gonna just instantiate it. 
So like that, and a semicolon at the end. So we've  
50:24 - created a visited vertices array list as well. And 
we're going to add in the starting vertex, because  
50:30 - it's already visited. So we're just going to add 
it before all of the operations. And we'll just  
50:36 - add in starting vertex here. Cool. Now when it's 
done, we're done with this initial thing. Now,  
50:41 - we could finally call our depth first traversal. 
So this thing is really easy. It's the name of the  
50:47 - graph traverser dot depth first traversal. And 
it's asking us for the start vertex. So we'll  
50:54 - say starting vertex, and the visited vertices, 
and this should have printed out. So let's go  
51:00 - into this place, which is right here. And command 
prompt it here. And let's go down and let's say  
51:08 - Java C, and we say, graph traverser, dot java. 
And now let's just run it so Java graph for  
51:25 - a sir. So here we have, the way how this will 
work. That's pretty pretty dope. Now it's time to  
51:33 - focus on breadth first traversal. As a reminder, 
the breadth first traversal iterates through the  
51:39 - graph and layers, it goes down one layer, which 
comprises the start vertex has direct neighbors,  
51:45 - then it proceeds down to the next layer, which 
consists of all the vertices that are neighbors of  
51:50 - the vertices in the previous layer. And for this 
example, I'll focus on traversing down one layer,  
51:57 - and then take a similar approach as we did with 
the depth first traversal by keeping an array  
52:03 - of visited vertices to prevent us from iterating 
through the same vertices over and over, however,  
52:08 - we will iterate through all of the direct neighbor 
vertices instead of iterating. Down the neighbors  
52:13 - first edge, like we did in depth first traversal, 
we will also use a queue to traverse through  
52:18 - the graph instead of recursion to explore the 
different ways we can implement the traverse,  
52:22 - I'll reuse the same task graph that was used in 
the depth first traversal implementation. Alright,  
52:28 - so what I have is a directed graph. And I'm going 
to have to apply a breadth first traversal. So  
52:33 - what I'm going to do is I'm going to get my target 
value, suppose we have it as one starting value,  
52:36 - and I'm just going to put it in the visited. 
And I'm also going to put it in our BFS queue,  
52:41 - we're going to look at our adjacent vertices and 
see the smaller number. So here we have three,  
52:47 - and we're going to choose that as the first one. 
So we're going to say three, as our visited.  
52:52 - And we're also going to put three here as well. 
Now that we've done that, we look at the other  
52:56 - adjacent one, which is four, and we're going 
to add that in our visited set. And we're also  
53:00 - going to add it here in our queue. Now that we've 
exhausted our current vertex, since there are no  
53:05 - more unvisited vertices, so we're going to have to 
remove this one from our queue. So we're going to  
53:10 - remove this one, and now three will be our new 
current vertex. And we'll look at the adjacent  
53:14 - ones here. So we have two and four, but two is 
smaller. So we're going to choose two first.  
53:17 - And here we have two in the visited and two in the 
queue. Now we also have four, but four is already  
53:23 - visited here. So we're not going to look at that. 
Now that we've done this, we're going to have to,  
53:29 - since three is exhausted, now we're going to have 
to remove that as well. So we're going to DQ it.
53:35 - And we're going to now look at four now 
four is over here, and there's nothing  
53:38 - that we could visit. So we're going to have 
to remove this as well. So we'll remove four.  
53:44 - And after that we could see two is now our current 
vertex, and two has a neighboring a neighboring  
53:54 - vertex, which is five, so we'll put five here and 
it's the only neighboring vertex. So we'll just  
53:58 - put the BFS queue over here. So now that we've 
exhausted two, we'll remove it from there as well.  
54:05 - And five is also nothing. So there's nothing with 
five as well. So that's completely exhausted as  
54:10 - well. So here we have completely visited the 
entire graph using breadth first search 1342  
54:17 - and five awesome now let's write the code for 
this. So I'm going to the same file where I  
54:21 - created my depth first search and I'm going to 
add my breadth first search right after this.  
54:25 - So this is my depth first search and right after 
that, I'm going to create my breadth first search.  
54:32 - So I'm gonna say public. And we're also going 
to make this as a static method. Since this is  
54:39 - a utility class and br E A D, E H, F fi rst and 
then sc search. So depth first search. So breadth  
54:50 - first search, adding the vertex start, just like 
that. And also the array list, which is the vertex  
55:02 - And this is going to be called the visited 
vertices, just like what we did up on the  
55:08 - top for our depth first traversal. Now, since 
you saw the graphical implementation there,  
55:13 - I use a queue. So I'm going to create a queue 
here as well. So queue, and I'll call it visit to.  
55:20 - And here, we're going to equal it to new Q. So 
Q u, u. And we'll just put that as well. Now,  
55:28 - you might be asking, where is it Q 
coming from? Well, I actually have the Q  
55:34 - file here as well. So this is the queue dot 
java file. And we've created queues before,  
55:39 - but actually modified here a little bit. So the 
same exact queue that we've created in our video  
55:45 - series. But I just modified it a little bit, 
just to add vertex as the data now instead  
55:51 - of a string or some kind of integer. So removing 
that, and now let's just go here. And over here,  
55:58 - now we created our queue, it's called our 
visit to, and we're going to have the visit to  
56:06 - dot n Q, the first thing, which is the start, 
which was passed in as the input parameter,  
56:10 - and that's the vertex there. Now, we're adding 
a while loop. And this is going to go until the  
56:17 - visit queue is not empty. So I'll say visit to 
because this is a queue, it has this method,  
56:24 - which is empty, and I've created that one. So I'll 
say if it's not empty, we're going to go inside of  
56:30 - this visit queue and keep doing those removing 
queue things and, you know, traversing and  
56:37 - using breadth first search there. So for that, I 
could, let's just get something down and actually,  
56:44 - DQ the, the elements in the queue, so we 
could say visit. So we can say visit u.dq.  
56:55 - And here we have a vertex that we have to 
do. So we'll put it inside of a current  
56:59 - variable. So we'll say current. All 
right, so now that it's in current,  
57:05 - we could print out the value here, as well 
as just say, system dot out, dot print.  
57:16 - ln, and then we say, you know, current dot data. 
And there's a Get Data method that was in the  
57:25 - vertex class. So there you go, it's working 
there. Now we're using a for each loop to go  
57:30 - through each of the edges inside of this current 
vertex. Because that's what I showed you in the  
57:37 - graphical implementation. Now, I'm just mapping 
all of that entire explanation down in code.  
57:41 - So I'm gonna saying edge for every edge of the 
current vertex. So it's a current dot get edges,  
57:48 - which is returning an array list of 
edges. And what we could do here is that,  
57:53 - so now we're gonna get the neighboring vertex of 
the current vertex. To do that, we could easily  
57:58 - get it from E dot get an end. And that returns 
us a vertex, that's our neighboring vertex.  
58:05 - And we pass it in to this vertex variable, 
and we'll call it as neighbor. And over here  
58:16 - we'll apply a conditional. And we'll say if the  
58:24 - now since I'm using a visited vertices array list 
over here in my input parameter that checks if  
58:30 - something is not repeated twice, so I'm saying if 
it's not existing, so I'll say if visited vertices  
58:38 - dot contains. And neighbor thing, and e i g, h 
vor. So I'm saying if it does not contain it,  
58:47 - then you should add it. So I'm saying, if 
it does not contain that neighbor vertex,  
58:53 - then you should add it. So we'll 
say visited vertices dot add.  
59:01 - And so visited vertices dot add, 
and then we'll add in the neighbor,  
59:06 - vertex. Perfect. And then the last thing that 
we could do here, because we created this visit  
59:13 - queue, and we'll include this inside of our visit 
queue, so we'll just say visit cube dot n q,  
59:19 - which is this, and we'll put in a vertex data. So 
we'll put in that vertex, which is the neighbor  
59:25 - and e i g, h, V o r, so this will be inside 
of our visit Q, which is this queue, and it  
59:32 - just currently had only the start. But once you 
get the edge of the neighboring vertex, you also  
59:38 - pass that inside of the visit queue. So that will 
be now the current vertex and it will go until  
59:43 - there's a dead end and then we'll just remove 
from the in queue and then so once it's exhausted,  
59:50 - like you'll see over here in this while loop, so 
it's just gonna say until it's empty, not empty,  
59:54 - so it's just gonna keep going. And once it's 
exhausted, like you can see over here DQ so  
59:58 - just see the other words sees that are there to 
traverse. Now let's go Downey in the main method,  
60:06 - and just have everything over here set like this. 
So just pause the video and type along. And over  
60:14 - here for the starting vertex test dot starting 
vertex, here we have a ArrayList vertex visited  
60:20 - vertices, the same thing. And this is the same 
exact thing. So instead of depth first traversal,  
60:24 - we're gonna say, be our breadth first 
traversal. And the rest is history. And  
60:32 - compiling it and running it. Let me just label 
them as well. So don't net out dot print, ln,  
60:40 - or we just have a line here, so print and then 
we say d f s, I will say B, F s, run this.
61:05 - So here you go. The difference between the two 
of the traversal techniques here we have DFS at  
61:11 - the other side, we have BFS. So we have over 
here 011, and something like that. And then  
61:17 - we have two over here, so something's going on 
differently. But if you look at the total numbers,  
61:21 - 1-234-567-8910 123456789, and 10. So the total 
number should be 10. It's there's 10 over here,  
61:34 - and there's 10 over here. And if we look at 
the test graph dot Java here, so the start  
61:39 - node 123456789, and 10. Awesome. So that was 
it. That was my code for depth first traversal.
61:58 - Welcome to another video, today we're going 
to be talking about Dykstra algorithm. A very  
62:03 - important algorithm in the computer science world, 
finding the shortest distance between vertices is  
62:08 - one of the most common applications of graph 
searches. Finding this distance has a number  
62:13 - of applications, including determining the best 
route to a destination and transferring data over  
62:18 - a computer network. Consider the graph finding 
the shortest path between vertex A to vertex E may  
62:25 - appear simple in your mind. But telling a computer 
how to do so is a bit more difficult. Fortunately,  
62:30 - there is an algorithm that computes the shortest 
distance between any two vertices in a graph. This  
62:36 - is known as Dykstra algorithm. Now, let's look 
at the conceptual overview of how the Dijkstra  
62:42 - algorithm is going to work, we're going to start 
with the starting vertex. And you can see that the  
62:46 - start is pointing to eight. So this is my target 
vertex. Here I have a distances cube, and also  
62:51 - have this unvisited, which is on the bottom. Now, 
I'm going to look at the first step here in this  
62:57 - algorithm. And the first step is to pop off the 
minimum distance of the unvisited vertices that  
63:03 - you can see over here, the minimum distance here 
is zero, and these rest are all set to infinity,  
63:08 - meaning that the distance from A to itself is 
zero. And the distance from A to any one of  
63:13 - these vertices is infinity for now. And if we look 
at the minimum distance, right now, it's 00. So  
63:20 - we're going to pop this off, so we're going to pop 
it off from here, and then we're going to look at  
63:25 - the adjacent vertices corresponding to this first 
vertex. So you can see over here, so from A to B,  
63:31 - the distance is four. Now if you compare this with 
the original distance, which is infinity, now four  
63:37 - is less than infinity, so we could replace this 
infinity with four. Since we replaced that now,  
63:44 - we could also go and check the next corresponding 
distance, now A to C has a weight of two. Now  
63:52 - you can see that two is less than the infinity. 
Now, we can also replace this infinity with two.  
64:00 - Now we're done with that. And we're going to this 
is our first iteration of the algorithm. Now we're  
64:06 - gonna go to the next iteration. So now we're going 
to pop off the minimum distance of the unvisited  
64:11 - vertices. And you can see for now, we can see that 
too, which is the for C is the minimum vertices,  
64:18 - we're going to pop that out from here. And we're 
going to start with C. So you can see C has  
64:24 - at A, C only has one neighbor, and that 
is E, and the distance from c to E is one,  
64:30 - and you have to look at the distance from A to C 
two. So the agency was to and from C to E was one  
64:36 - total distance from A to E is three, so two plus 
one is three. So what we're going to do here is  
64:42 - we're going to make from A to E as three and then 
we're going to look at the E portion and we got to  
64:48 - see that three is less than infinity. So we're 
going to replace this infinity with three. Now.  
64:55 - Since there is no more neighbors left, we're 
going to need to do the next iteration for  
64:59 - this out Rhythm C has no more neighbors. So now 
we're going to pop off the minimum distance of  
65:05 - the unvisited vertices, you can see now that 
the minimum distance is three, so it's an E,  
65:11 - so we're gonna pop this off, and we're going to go 
to E and look at the, the neighbors for each. So  
65:17 - E has only one neighbor. And that is indeed, the 
wait for that as five, the distance will be three  
65:22 - plus five, which is eight, and eight is less than 
infinity. So we can replace this infinity with  
65:28 - eight. Now that we have replaced that, we can also 
see that there is no more corresponding vertices.  
65:35 - So we could stop here and do the next iteration 
for the algorithm. Now, we're going to pop up the  
65:41 - minimum distance of the unvisited vertices. So you 
can see that the minimum distance is b. So we're  
65:47 - going to pop this off. And over here, we're going 
to look at the corresponding neighbors. Now B has  
65:52 - one, two, and three corresponding neighbors, 
we're going to start with the first one, which  
65:56 - is C. So B to C is one. And now you can see that 
from A to B, which was already existing was four,  
66:04 - and from there to see it's one, so five, so from 
A to C will be five. And if we look at the C,  
66:14 - it already exists here, and and you can see 
five is greater than two, so we're not going to  
66:19 - change this value, then we're going to look at 
the distance from B to E, and that's three. So  
66:24 - from A to B, it's four, and from there to E, it's 
seven. So if we look at the distance from A to E,  
66:33 - that should be seven. And that is greater than 
the value that we already have here. So we're  
66:38 - not going to change that at all, either. Now we're 
going to look at the last and final neighbor of B,  
66:42 - and that is D, now we look at the weight, this 
is two, and the distance from here was four, two,  
66:49 - so it's going to be from A to B, it's four, and 
from B to D, it's going to be two, so the total  
66:54 - distance here from A to D will be six. And we will 
look at the distance over here that is actually  
67:00 - lesser than what we have existing. So we could 
replace this eight with six. And that now will  
67:08 - be the end of our iteration. And now we'll go to 
the next iteration of our algorithm. Now we're  
67:13 - going to try to pop up the minimum distance of the 
unvisited vertices. Since we only have one versus  
67:18 - left, which is D, I will look at the minimum 
distance here. And that is the minimum distance  
67:23 - rest everything has been visited. So that's D, 
so we're going to try to bring it up, pop it  
67:27 - off. And we look try to look at any neighbors 
for D but there's nothing. So that's the end  
67:31 - of our algorithm there. And that's how Dykstra 
is algorithm is implemented. So you went over  
67:36 - there and saw all of the possible distances for 
so from a to itself, the minimum distance is zero,  
67:44 - from A to B, the minimum distance is four till 
here, from A to C, the minimum distance is two,  
67:50 - right here, from A to D, the minimum distance 
is six, so, four to two here, and from A to E,  
67:58 - the minimum distance is three, so eight 
to eat at the minimum distances three.  
68:03 - So, that sums up our dexterous algorithm 
conceptual overview. Now, we're going to start  
68:07 - writing the code for this. But before getting on 
to the code, let's think of what we should add  
68:12 - in or what objects and what structures should we 
create. Looking into this algorithm. We're going  
68:16 - to instantiate a dictionary that will eventually 
map vertices to their distance from the start  
68:22 - vertex. So like you can see over here we're going 
to put that in a dictionary. A quick recap before  
68:27 - we start the code for this Dykstra does algorithm 
finds all of the shortest distances between a  
68:32 - starting vertex and the remaining vertices in a 
graph. The algorithm operates by keeping track  
68:38 - of all distances and updating them as it performs 
a breadth first search Dykstra the algorithm is  
68:44 - implemented in all of E plus V of log of V, and E 
means edges. And v means vertices, we will first  
68:51 - implement the algorithm to find the shortest 
distance to every vertex. So let's go through  
68:56 - the code and all of the conceptual overview 
that I gave. Now I'm going to try to map this  
69:01 - out in code. So here I have imported java util dot 
asterisk, meaning I'm importing everything that's  
69:08 - available in the utility package, and have it over 
here that you can see is public class Dykstra,  
69:14 - and there I have a main method. Here I have a main 
method, which is actually creating a test graph.  
69:22 - And the weighted and directed properties are set 
to true. And we also add these vertices here,  
69:29 - so A, B, C, D, E, F, G, and we also add their 
connections to each other. So those are done.  
69:39 - So what we mainly have here is a test graph 
in our main method to test the output of the  
69:44 - method. What we're going to create in this video, 
so we're going to try to create that method,  
69:49 - which is called Die extras. So for that, we're 
gonna have the public and we're gonna say static  
69:58 - dictionary And we put in this. So we're going to 
return an array of dictionaries. And I'll tell you  
70:08 - why we're doing this in just a second. So here 
we have the name of the algorithm, Dykstra, and  
70:15 - we're going to tell the parameter to add in these 
two values. First thing is to have the graph. So  
70:23 - d r a p h, and we call that as G, we also need to 
pass in a vertex. And that will be will be called  
70:32 - as starting vertex. So we're done with these two 
input parameters. Now, we're going to create two  
70:39 - dictionary objects here. And one will be used for 
the distances queue, the other one will be used to  
70:47 - keep track of your previous vertex. And this is 
very crucial in this algorithm, we're gonna make  
70:54 - a dictionary and a dictionary is just a base of 
key value pairs, we have a string, which is the  
71:00 - key and integer as the value. And we call this 
as distances. And we create a new hash table.  
71:13 - And we put in these angle brackets and the 
round bracket, and then we semicolon at the end.  
71:19 - So that's the distances Q. Now 
we also need another hash table.  
71:25 - And this one will be for the 
previous. So we add this as well.  
71:32 - And for this, we're not going to have 
the integer as the value but the vertex,
71:38 - this is going to store the data, and the also 
value that exists. So like I was doing it over  
71:49 - there in the diagram, this A, and it maps out to 
zero, and this b that maps out to four, so the  
71:57 - string is the letter, and the value is going to be 
the integer. And for the second dictionary, which  
72:04 - is previous, it's gonna keep track of the previous 
vertex. So that will have a string, which is the  
72:11 - current vertex, and vertex will be the previous. 
Now, we also need to add in a priority queue.  
72:18 - So I have added some files here. And this isn't 
one that's called queue object dot java. This is  
72:25 - actually a class that implements the Comparable 
queue object. And you can see that it has the  
72:32 - vertex and the priority as class variables. And 
you can see the, the constructor is actually  
72:38 - creating this object, and it's overriding the 
compare to method with some priority base. So if  
72:45 - it's equal in priority to the input parameter, we 
just return zero. If the class variable priority  
72:51 - is greater than the priority that was passed in 
is, then we will return one out, we will return  
72:58 - minus one. So this is just just a file. And it's 
just a fancy queue. It's just known as a priority  
73:05 - queue. The main difference between this queue and 
the priority queue is that this will look at the  
73:11 - smallest value, smallest possible value, and it 
will allow us to pop that one off. So like what  
73:18 - we're trying to do here, we were trying to look 
at the minimum value and the where you're trying  
73:22 - to pop that off, that exact implementation is 
priority kilojoule for us and without writing  
73:27 - extra code. So that's one of the biggest benefits 
for using that. So let's add the priority queue.  
73:33 - And this is the priority queues. priority queue. 
And we're gonna add in the queue objects here.  
73:41 - So if qu e we are gonna say, object that we 
created. And then we got ADD name for that as Q,  
73:49 - Q, U, e, u e, is equal to now we're going to 
add in the new and it was a priority queue.  
74:00 - And here, we're just going to add in the queue 
object once more queue, you deal with obj eects,  
74:06 - and then a semicolon at the end of perfect. 
So this is our priority queue created. And  
74:17 - I'm just adding the same exactly, just 
after that. Now, you might be asking,  
74:22 - well, the priority queue is actually empty 
right, now we got a queue something inside.  
74:27 - Now the thing that we're going to queue inside 
for the first thing is the starting vertex,  
74:32 - since we know the distance for that is zero to 
itself. So we're just going to queue that up  
74:37 - in here. So to say qu e dot add. And here 
we're just going to say a new Q object.  
74:46 - And we're going to pass in the vertex V and 
the int p, which is the priority of the vertex  
74:52 - v is just going to be the starting vertex. 
And the priority for this would be zero.  
74:58 - Awesome. Now we're gonna try to iterate through 
this entire graph that was passed in as an input  
75:04 - parameter. And we're going to try to iterate 
through and try to find all the vertices here. So  
75:09 - we can use a for each loop for this purpose, we're 
gonna say, for every vertex v. So we can say,  
75:15 - for every vertex V, in the G dot, get vertices. 
And this is returning an ArrayList of vertex. And  
75:25 - you're just doing this really easily. And this is 
also added here. So I have a graph dot java file.  
75:34 - And this is also added. So that's why I'm 
able to get the method get vertices. So  
75:42 - this is get vertices. And it should be over 
here. So we're good vertices. So this is the get  
75:49 - vertices method. And I'm also adding this edge 
dot Java as well as this vertex dot Java, you  
75:56 - could look at my older videos. And from there, 
I'm actually using all of those classes that  
76:02 - have created in the graph dot Java, the vertex, 
dot Java, and the edge dot Java are all done in  
76:09 - a single video, which was called graphs in Java. 
So watch that video. And for this cool object,  
76:15 - I'm just gonna let you see this code for now, you 
can just pause the video and copy this. And once  
76:22 - you have all of these, we could go back here 
in the Dykstra dot Java, and we're just going  
76:27 - to iterate through the vertices which are in this 
graph, which was passed in as an input parameter.  
76:33 - Now, we're going to have to iterate through this. 
And we're going to actually update our distances,  
76:38 - which was over here. So we're going to actually 
have to update our distances and previous  
76:43 - dictionaries. So we're going to try to add all 
these vertices from this graph to this distances  
76:48 - and previous dictionaries, we could do. First of 
all, we don't want the starting vertex to have a  
76:56 - maximum integer of max value, because we know 
that the starting vertex to itself is zero. So  
77:01 - we're going to give a condition here and say, 
if the vertex you get is the starting vertex,  
77:07 - and this is just going to work. So we're 
gonna say if that one is the starting vertex.  
77:13 - We don't want that. So if it's not, right, so 
we want to update the distances, and we're going  
77:21 - to have to add input. This is a method available 
in the dictionary. And this is, this allows us  
77:27 - to add a key and value pair. So the string is 
the key, and the value is the integer. So what  
77:32 - we could do here is for the string, we could say 
V, which is the vertex, or we say golf dot get.  
77:41 - So we could say, Get Data, and that will return 
a string here. And this is also added in the  
77:46 - vertex dot java. So that's why it's working here. 
And for the integer, we're just adding the maximum  
77:52 - or we want to use the infinity symbol, right, 
we're going to use integer dot max value, this  
77:56 - would give us the maximum value for the integer 
in Java, and that will be stored inside of the  
78:02 - value pairs. So key values are done. And for the 
other case, where we have the previous dictionary,  
78:08 - so we'll say previous, previous a previous output. 
And for this second dictionary will also have a  
78:15 - key value pair, but the value is a vertex. So the 
key is going to be the get data, the same thing.  
78:21 - But for the value in this case, will be the 
previous vertex so that we could keep track of  
78:27 - this. So we're just going to add in a vertex that 
will be set to null for now. And then after that,  
78:31 - we're going to update it inside of our code. So 
right now just set everything to know, including  
78:38 - the starting vertex. All right, so right after 
this, we needed to add in the starting vertex here  
78:46 - in our distances, because we don't have it. So to 
do that, we'll just add in the distances again.  
78:54 - That was a foot. And now we want to add in 
the key value pair for that. And for this add  
79:00 - in the starting vertex, and we actually need 
the value for this, I'm gonna say, Get Data,  
79:05 - and that will give us the string data. And for the 
value, I'm not going to give the maximum value,  
79:09 - we're not going to give infinity because if 
we look at this code over here, initially,  
79:13 - it was set to zero, so we want to just set it to 
zero here, I'll put it there. And there you go.  
79:19 - So we created this entire thing, what you can see 
over here, so you can see this entire thing that  
79:24 - we've created, which has a set to zero, and the 
rest are all set to the infinity or the max value.  
79:32 - Now, let's go back. And we're going to 
actually do the second step for this  
79:40 - algorithm. Now it's the fun part. We're going 
to have to iterate through the while loop. And  
79:46 - we're going to check if the queue is not empty. 
So we say qu e u e, this, this is our priority  
79:53 - you I will say the size method here. And if 
we say of that size is not equal to zero.  
79:59 - We're going to do Do some operations inside of 
this queue. First of all, we're gonna get the  
80:03 - current vertex here. And that is pretty simple Q 
dot call, retrieves and removes the head of this  
80:11 - queue, or returns null if this queue is empty. 
So we're gonna actually remove an item from the  
80:17 - queue using this method. And we want the vertex 
here. So we just say the vertex, because we had  
80:26 - this over here as this queue object, and we 
wanted to vertex here. So we're removing that  
80:32 - from the priority queue. So the first thing will 
just be the starting vertex. And that was added  
80:36 - in our queue. So this was added over here to 
to Add New Objects, starting with x with the  
80:43 - value zero. So that was zero was actually it's a 
value to itself. So this is now set to current,  
80:52 - and we removed it from the queue. 
Perfect. Now we're going to iterate  
80:57 - through this current variable, which is the 
starting vertex. So we're going to look at  
81:01 - all of the edges or the neighbors for a 
year. So we say, for every edge of Eid.
81:08 - And we say, mapping out to the current 
dot get edges, which is the ArrayList,  
81:14 - returning of edges. So for every edges, or every 
neighbors inside of this current, so every edge,  
81:21 - an edge contains vertices, remember, so we're 
actually going to first look at the value of what  
81:29 - the edges giving us remember, like I did in this 
first one, that we were looking at the values,  
81:34 - and we also judging inside of our distances. So we 
looked at, let's say, for, for the distance to D,  
81:41 - we had some already included distance was 215, 
which was eight. So that was already passed in.  
81:48 - But we also want to keep track of the newer one. 
So this is like four two, which is six. And now  
81:53 - this is an alternative one, we have to add that 
somewhere, and then we have to judge something  
81:58 - like if it's less than the original one, then we 
could replace it. So we won't have an alternative.  
82:03 - And we want to also have the original. So for 
the alternative case, we'll add in an integer.  
82:11 - And I'll say alternative. And I could 
add the distances here. So distances,  
82:20 - and this is the distances dictionary, and I'll get 
the current dog get data. And that is the string.  
82:33 - And we also want the plus to the eat, get wage, 
so we're going to get the weight as the end. So  
82:42 - this is the distance from the current distance of 
the variable and the edge distance. So what this  
82:49 - means is, whatever the distance is existing for 
this current nugget data, the starting vertex is  
82:55 - actually zero to the distance where it's leading 
to with its vertex. So the edge where it's leading  
83:01 - to with its edge, it's make sense because this is 
zero to itself. But if we're moving forward, we  
83:09 - have an edge with it, and we have some weight, so 
we're adding that weight as well. So get weight.  
83:16 - That's the alternative. And we all 
need a reference to our string,  
83:20 - neighbour variable. So we got to have that as 
any igvh vor. So this is our neighbor value.  
83:30 - And we just have to keep it just keep it inside. 
So we could eat, get and so this is the vertex.  
83:41 - And we want the value for this. So we 
have Geat EDA and we have get data.  
83:48 - So over here, it's pretty simple, we have a 
neighbor value, and we want to have the edge  
83:53 - vertex. So we want to have the edge and we want to 
get the end. So we're gonna get the vertex through  
83:59 - this. And to get the data, we just say this, so 
we're gonna get the vertex through this get end,  
84:04 - and we're gonna get the data so that string is 
actually stored in the neighbor value. Now that  
84:11 - the string is stored, we could use a conditional 
here to check if the alternative value is lesser  
84:18 - than the original value. So what we're gonna 
do here is pretty simple, we'll say alternative  
84:25 - is less than the distances and we want the 
dictionary so this is the distances dot get, and  
84:33 - we want to get the value for this, we can just 
use the neighbor value, so that's why I stored it  
84:37 - over there, so that we can get the value of their 
neighbor value. Alternative value is less than our  
84:42 - neighbor value. So what we're going to do is that 
neighbor value is actually the original distance  
84:47 - that was stored inside of our distances object 
which is on top. So over here we have distances.  
84:53 - If that is possible. We're just trying to override 
it and so we're going to say distances dot put  
85:00 - it I'm going to get the neighbor value. So 
that exact neighbor value, but we're going  
85:04 - to change it the value to the alternative. So 
we're going to get the key and the value. So  
85:11 - this is the string neighbor value, and then the 
integer will be now the alternative distance.  
85:17 - Also, we're going to have to modify our 
previous, so we're going to have to add in  
85:22 - the neighbor value as well. So for the neighbor 
value, we actually need the previous reference.  
85:29 - And the previous reference will now be for our 
current instance, with the current one, which  
85:34 - is now which is actually starting vertex will 
be the previous vertex for our neighbor value,  
85:40 - which is the current one over there. So it's 
just gonna keep iterating this and updating our  
85:44 - previous reference. And the last thing, what we 
want to do is we want to add the neighboring value  
85:50 - to our two u two u, eu object, and we have to add 
in the vertex here, so we're gonna say e dot get,  
85:58 - and so that's just gonna give us the vertex 
here. And to get the priority, we could say,  
86:06 - the distances structure dot get. And to get the 
value, I'm just going to add in neighbor value,  
86:17 - and that will give us the value. So this is 
a neighbor value is the key, and it will give  
86:22 - us the value which is associated to this key. And 
that will be updated to our cue. And that's going  
86:27 - to be our priority. So that will be added. And 
once it's done, we're actually going to break out  
86:33 - from this for loop when all of these edges are 
done. And that will be updated. And after that,  
86:38 - until the wild size is not less than zero. 
So this is just a line that will pop off the  
86:45 - minimum distance of the unvisited vertex. And the 
rest is history over here, what you saw all in the  
86:51 - conceptional overview, everything is happening 
and adjusting, and the right at the end, so  
86:58 - when the while loop breaks, so that I Dykstra 
is requiring us to return a dictionary array,  
87:04 - right? So we want to return that. So over here, 
right after the while loop, we could return  
87:11 - a new dictionary. And so over here, we're going 
to return a new VI, C T, IO N ar y. And we're  
87:23 - going to get this way racket over here, which 
is the array for this dictionary. And this is  
87:29 - the array of the dictionary. And we want to pass 
in the distances, distances with the previous  
87:39 - structure here, this is a return statement, 
we're going to return a new dictionary,  
87:43 - and it will have the distances and the previous 
dictionaries. So we'll have both the distances  
87:49 - and previous dictionaries inside of this 
dictionary array, which is returning here  
87:54 - in our function. So we're going to hear that 
dictionary arrays returning. So this is the  
87:59 - return statement at the end. And yeah, so 
that was pretty much it with this function.  
88:05 - This is minimizing it, so you can see the entire 
thing. So this is the entire method for extra.  
88:10 - Now, we also have this helper method on this 
bottom, so I'm just going to paste this in.  
88:17 - This is called the Dykstra result, printer method. 
And what it accepts is an array of dictionaries,  
88:23 - well, how convenient, we're just going to use 
this entire thing, I'm just going to return it  
88:27 - and so we can pass it inside of this. And this 
will just actually print all the distances. So  
88:33 - what you'll see over here, so it's gonna 
print out the updated distances like this.  
88:37 - And it's also going to print out the previous 
positions. So you're going to see that as well.  
88:43 - So since the these both were dictionaries, we're 
going to use enumeration as keys to get the values  
88:48 - of all of this and it's just going to give 
us the key and value pairs, and it's going  
88:53 - to be pretty cool. So these both are going to be 
allowing us to print these structures. So we're  
88:58 - going to add this process here. So let's just 
create this call. So we had this test graph.  
89:06 - And what we want to do is we want to use this 
method here, which is Dykstra. To use this we  
89:12 - have to pass that inside. So we're going to use 
Dykstra here. I ran a passing the test graph,  
89:18 - alternate paths in the starting vertex, and that 
is a because over here is the first vertex and  
89:24 - that's going to be our starting vertex. You 
can set anything you want later on. And then  
89:29 - after that, we're actually calling this inside 
of this method, which is dexta result printer,  
89:35 - since it's accepting a dictionary array of 
D, so I'm gonna paste this thing inside,  
89:41 - and we're gonna wrap it around the Dykstra. So 
there you go. And this will just print out the  
89:49 - things. So cool. So now let's run this code. So 
let's go and add an CMD here. And let's run this  
89:58 - code. So Java C, ed i j, k, s t r a dot java. 
And now let's just run it using Java DIJKSP  
90:14 - Ra. Alright, so we have an error here, something 
no pointer exception, okay? What's the shortest  
90:22 - path between two vertices. To calculate 
that we'll just create a new method here.  
90:26 - And we'll call this as public static, void. 
And we'll call this as shortest path between.  
90:35 - Inside here we'll have a graph DRA 
p h, and we'll call as graph G,  
90:41 - we're also going to have the vertex, 
and we're gonna get the starting vertex.  
90:47 - And we also need the targeted vertex. 
So we're gonna say, target work at x.
90:57 - Here, we have the shortest path between method in 
which we're going to input the graph the starting  
91:02 - vertex and the target of vertex because 
we want the minimum distance between two  
91:07 - vertices. So we're gonna use this method for 
that case, we're gonna have the dictionary  
91:13 - array object here, and we're going to 
call this as Dykstra has dictionaries.  
91:23 - And that will be equal to the dictionaries. 
So we're going to call the extra method here,  
91:30 - we're going to call it using the graph and the 
starting vertex. What actually it gives us is  
91:35 - the distances and the previous dictionaries. And 
I'm getting an error here. It's actually di J.  
91:44 - The method Dykstra is defined for undefined 
for the type Dykstra. So the reason why I'm  
91:50 - getting an error here is because I don't have a 
k. So di, j, k. And if I do that, I'm all set.  
91:58 - Now we want to put the distances and 
previous in their own variables. So  
92:04 - we're gonna have the scope for that. 
So I'm gonna say, distances dictionary.  
92:10 - And it will contain all the values which we had, 
and then we're gonna manipulate this. So we're  
92:16 - gonna say dictionaries. So Dykstra, D ij, k, 
s, t, R, A, and we have Dykstra dictionaries.  
92:25 - And we have this sub zero, that will contain 
our Dix distances. And for the second one,  
92:34 - and for the second one, we could have 
that as one. And that will be our previous  
92:45 - awesome, to get the distance of our target 
word that we're gonna say distances.  
92:52 - docket, and we need to get the target vertex. And 
we want the value for that we can say get data,  
93:01 - that will return a string. And that will actually 
map us to the value from our distances, which will  
93:08 - be something like, you know, the value of what it 
will take for us to reach from A to that point,  
93:14 - and that we could store in 
some variable called distance.  
93:24 - So make sure you have the type set to 
integer here. And then that should go away.  
93:36 - Now, what we want to do here is we want a 
print screen, that will just show us the  
93:42 - shortest distance path between these two. So 
what we could do is, we could paste this in.  
93:48 - And this is just going to print out the shortest 
distance between the starting vertex get data and  
93:53 - the target vertex dot get data. So just in between 
the two vertex, this is just going to give us the  
94:01 - letters, you know the distance between A to 
whatever. And system dot out dot print ln will  
94:07 - just print us the distance, which was inside of 
the target vertex. Now we actually need the, the  
94:15 - generated path that we should follow to create the 
path, we're going to create an ArrayList for us.  
94:23 - And that will be of type vertex. And we will 
call that as path we initialized an ArrayList  
94:30 - to get the target vertex and assign it to a 
variable is very important here. So we're gonna  
94:37 - have target vertex and assign it to a variable. 
So we're gonna go from the target vertex to the  
94:42 - starting vertex. It's a bit like the reverse 
linked list. So we're going to use some kind  
94:47 - of functionality like that. We're going to use 
a while loop and we say while the V, the vertex.  
94:55 - So if the V is data, and the Get Data will pass 
in a string I'd say that is not, no, because we  
95:03 - know that the first one which has started will is 
no, we're gonna add in the path. So the path is  
95:09 - actually the ArrayList, we're gonna say the path 
dot add, we're gonna add a zero here, because  
95:13 - the path is actually making us add something 
inside of this. So we're going to add in a zero.  
95:19 - And this will mean that it will be popped in the 
for direction, it's not going to go backwards,  
95:25 - it's not going to queue there. But every time a 
new value exists, it will come in the beginning,  
95:31 - every time a new value is added to this 
ArrayList, it will be added in the beginning.  
95:36 - So patha, add zero will be added. So every value 
will be added to the beginning of the queue,  
95:44 - not the end. And the other thing that we 
want to do is we want to pass it that VT,  
95:49 - so that vertex that we set up will be also 
passed in here. And then the next step here is to  
95:58 - get the previous instance here. So we can say 
previous structure, which is a dictionary,  
96:03 - dot get. And what we need is the data here, so we 
say v dot get data. That would give us a string,  
96:13 - previous dot get, and we got the value 
over here, and we're going to assign that  
96:19 - to the vertex. So since we have that get 
process here, we actually need the vertex here.  
96:25 - And that will assign it to the vertex. So 
it's just going to keep going like that.  
96:32 - After this while loop, we could just print out 
system dot out dot println in the shortest path.  
96:37 - And what we'd have now is the shortest path 
as well. So we could go from vertex path  
96:43 - vertex to from the path structure, which is over 
here somewhere. So vertex path vertex. So so we  
96:51 - have this path, which is this entire array list 
that now contains all of the vertices for that  
96:58 - directed path. Now all we're going to do is 
iterate through this for every path vertex,  
97:03 - we're going to print path vertex dot get 
data, and I will just print the letters of  
97:09 - the port corresponding path. Now the only 
thing that I'm going to do right now is,  
97:12 - like I said, I called Dykstra dot Dykstra 
result printer, and I passed in these two.  
97:20 - So what I happened here was that I was on an 
error. And whenever I was running this code, I was  
97:25 - getting this error over here at line number, 26, 
and 94. So over here in line number 26, and 94,  
97:31 - it doesn't give me any clue of what's happening. 
But you could tell that alternative is less than  
97:36 - distances dot that get the more value. So I was 
looking at the alternative value very carefully,  
97:42 - here, I noticed that I did get an error while I 
was doing this. So this is actually a syntactical  
97:48 - error, I was trying to get the alternative 
path distance, and I was getting the value  
97:53 - from the distances dictionary, and I wanted to 
current dot get data. And this is what's gonna,  
97:58 - this was going to actually give 
us the value for this one. So  
98:03 - I didn't need this parenthesis over 
here, I actually needed that closed here.  
98:07 - And now it was just going to give us the value 
here, which was string. So it was going to give us  
98:12 - the value of that current data. So it's just going 
to be an integer here. And then that was going  
98:19 - to be added with the edge dot gateway. So that 
will also be an in so both of these ends added  
98:24 - will result in this alternative value. So 
now it's proper. And if I run the code now  
98:35 - you can see now that this created it for 
me. So here what I had was these vertices,  
98:42 - 12345677 vertices, and these were the 
connections to them. I just called the  
98:49 - Dykstra nothin past in the past graph, and 
put in the starting vertex. After that,  
98:55 - I use the shortest path between method. 
And this is all showing up pretty cool.
99:03 - So now we're gonna test it out and see over 
here that the distance is, is updated. And  
99:10 - it's according to what these vertices are. 
So these are, I believe, seven vertices,  
99:14 - and over here we have the connections to them. So 
you can see a is connected C a is connected to b,  
99:19 - a is connected to D, I want you to see over here 
is that the previous here we have a as no and the  
99:25 - rest, when I said a is connected to B, D, and C, 
if you look at B, D, and C, they're all connected  
99:32 - to a, so d is connected to a. So over here, 
you can see that this is the structure here,  
99:37 - where we have all these vertices and their 
corresponding values. So these are all the  
99:42 - values that have been have been updated. So the 
distance from A to itself is zero, the distance  
99:46 - from A to D is minus 30 A the distance from A to 
F F to 3020. So we just pass it these values here,  
99:53 - and then just allowed us to get the minimum 
distance from this graph to just telling if the  
99:58 - distance from A to B is slope. So the minimum 
distance from A to B is three, the minimum  
100:03 - distance from A to D is four and so on over here 
in the previous, we have a has a previous of No,  
100:09 - but the rest vertices show their previous vertex 
as well. For the last method that we created,  
100:15 - we want to call that shortest path between task 
graph. And we've got the starting vertex and the  
100:20 - target vertex. Now we want the path shown, and 
also the shortest path. So what we can do is  
100:25 - short paths, we pass an A and G. And this is going 
to call this method over here, which is going to  
100:31 - call that method and it will return us some cool 
looking path here. So we'll clear the screen and  
100:39 - then run it and then see the shortest path here 
we got the shortest distance from A to G, which  
100:44 - is correct, we got a to g, and it was minus 38, 
the shortest path and it showed how it was working  
100:49 - here, so A to D to eat to G. So if we map this out 
and draw this in a diagram, or if we look at it,  
100:57 - everything will be correct according to these 
results. And that actually sums up our video

Cleaned transcript:

A graph data structure is a nonlinear data structure consisting of vertices and edges. They're used to solve many real world problems and are commonly needed to solve coding challenges. Harris from coding cleverly teaches this graph course using Java. Harris is extremely knowledgeable in algorithms and data structures. Hey there everyone, this is coding cleverly. And today we're going to be talking about the graph data structure. We're going to talk about how it works, how it's constructed, and all the important stuff we need to know about it. The first thing I did was create three different files in the same directory. Here I have graph dot Java, and then we have vertex dot java. And we also have edge dot java. And what I'm going to do now is I'm going to actually write some code, and then I'm going to try to interlink these, all three files. Because this edge, this vertex and this graph are going to be used together to create our graph data structure. Before talking about graphs, I want to talk about the graph traversals there are many ways to traverse a graph, but you will focus on three methods depth first search breadth first search and Dykstra algorithm. These traversal methods are core algorithms for searching a graph. Now what are graphs graphs are the ideal data structure for modeling networks, making them an essential part of your data structure toolkit. They are made up of nodes, or vertices, which hold data and edges which connect to vertices. A vertex is a single node. Now all of this will be explained through the diagram. Here's a sample of a graph that I created. These circles everywhere are actually vertices, and they're holding data and edges, which connect to vertices. So these lines over here are known as edges these things now I want to give an example consider a map of your neighborhood. As a graph, we could represent bus stops, as vertices and bus routes, between stops as edges. So how about the internet web pages can be thought of as vertices and the hyperlinks that connect them as edges. Real world relationships are represented as graphs are numerous, making them an important concept to grasp. The graph, which could see over here is actually representing a social network. People are vertices and edges are friendships. So these lines are friendships. These circles are the people Peter, Cody and Jordan are all friends, Peter and Cody are friends. And the same goes for Cody and Peter, Peter and Jordan are also friends. And Jordan, all and Peter are friends as well. So this bidirectional pattern is also existing here, Jordan and Cody are friends. And Cody and Jordan are friends. One other thing that we see here is distinct, which is Caleb and Alex. Now, these are friends. But these are not linked with these people over here. Interesting. A path is made up of vertices connected by any number of intermediate edges from Peter to Cody, the paths could be Peter to Jordan to Cody, or Peter to Cody. There is no way between Peter and Caleb, a graph is disconnected when no path exists between two vertices. So this here is a disconnected graph. Because not all of these vertices are connected with each other, it's impossible to reach here. So this is the reason why this graph is a disconnected graph. Alright, so now let's map out this concept in our code. Now, what we want to do is we want to create a graph class that could be flexible enough to support directed, undirected, weighted and unweighted graphs. Now, the difference between a directed and undirected graph is that for directed graphs, which is so this is an undirected, disconnected graph, because there's no link here, and you can reach here. So this is disconnected. The reason why it's undirected is the reason that both of these paths are like bi directional. So over here, Peter and Jordan is Peter is friends to Jordan, and also Jordan friends to Peter. So this is bidirectional. So and this is undirected, if it's directed, it would have arrows here. So it would point that Peter is only friends to Jordan. But Jordan doesn't like him back. And Jordan is friends to Cody, and Cody doesn't like him back. So something like that is going to be directed. In case of weighted graphs, you'd have weights on top of each. So I know it doesn't make sense over here. But if we had like, stopped, bus stops, and then their routes, it would have been easier and easy to map out. But here, if I say Peter, and then Jordan, it takes like, let's say five. So it's something like this. And then we have over here we have, let's say 10. And over here, let's say it's 12. So over here, now we got weights on top of the edges. And these are just going to indicate the number or the expense that we're going to take here. So Peter, I know it's not a good example, like I said that we could have done with bus stops and routes, but here we're at Again, Peter is finished with Jordan. And I don't say five times. He, he likes him five times this. Jordan likes Cody 10 times. And Cody likes Peter 12 times, I'm not sure if that was a good example. But you you got my point there something like that it with, which associates the numbers as they're expensive with this in mind, we will create our graph with the following requirements of vertex can store any data. So these circles, a vertex maintains a list of connections to other vertices represented by a list of edge instances. So we're going to have a vertex, we're going to also have its list to connect other ones. So those are going to be called as these vertices and they're going to be linked through the edges. So here we have Peter, but friends are Jordan and Cody, right. So we're going to have to put that in some kind of structure here. So it's going to be a list of edges. So they're going to be represented by all this stuff, Edge instances, a vertex can add and remove edges going to another vertex. A graph stores all of the all of its vertices represented by a list of vertex instances. So all of these vertices you see, are just going to be stored in that graph structure. Our graph knows if it is directed or undirected. Like I said, this is undirected. And if it had some kind of direction it would been directed, a graph can add and remove its own vertices graph can add and remove edges between stored vertices with all of that other way, let's write the code. So to keep the concepts grounded in a real world application, we'll build a transportation network of bus stops as we go, what I want to do first thing is actually look into my vertex class. And because I know this is a circle, which has the data, and it's also going to have the edges, so we're going to start from this one. Here, we're gonna go into this class vertex here. And we're just going to create some instance variables. So the first thing that I am saying is private string data. Second thing that comes to the mind is private ArrayList. Because we want to store the edges, right, so we say ArrayList, we put the type of the ArrayList here, so we're going to store edges. So it's an ArrayList of edges. And we're going to call this as edges. Alright, so now we're done with that, let's add a constructor here, we're gonna say public. And we're gonna say vertex. Here, we're gonna have a string. And we'll say input data, the data that the user will provide. And then for that will take the class variable is equal to the input parameter. And then we have this dot edges, which is the edges, and that would equal to the new ArrayList. And here we want the edge. And we also want this. So here, we instantiated the array list, which was this edge is one. Now I know this is giving us problems, because it's not allowing us to have this. So let's just import this import Java dot util dot ArrayList. And the errors are gone. Here, we have a vertex constructor that assigns the data with the input data and also instantiates the edges list with a new ArrayList of type edge. Now we got these vertices right, now we want to have a mechanism that will allow us to see these edges in live action, right. The other thing that I want to go through this is that I'm going to create this as a directed graph. So there's going to be arrows here, a method called public void, add edge. And over here, we're gonna add in the vertex and vertex and integer. Wait. Alright, so now that this is done, and we just created this constructor for this, I mean, know the instance variables. Let's move on to edge dot Java and create the instance variables for here. And then after that, we're going to go back to this vertex dot Java and finish it up. One thing I want to make clear here is that I'm going to create a directed graph. It's going to be the ones that have the arrows, it's not going to be the bi directional ones, which would go both ways. It's just going to be one, one stop to the other stop, right? It's a bus stop. So I don't want to go backwards. So in this case, it's just a directed graph. What we're going to do here is for the edge, like I said, it's just a line where you see in the graphical representation And by here, I'm gonna have to try to map it out in code. So I'm going to have the start vertex, where it's coming from, and where it's going to. So PRI, visit private vertex. And then we have the end. And over here, we want to wait, we're also going to create this as a weighted graph, that will have a cost for how much expensive will it take to move from one place to another, remember those numbers which were on top of those lines, so that's the weight here, so it's going to be a weighted graph as well. So I'm going to put up weight in here as well. And it's going to be called integer. And I'm gonna say W, RI ght, I'm going to put a integer Wait, and notice I'm using integer and not int. It's the reason is that if I don't want to put anything, I could just type in null. And it would allow me to just like Pass It On with no reason. And if I had an integer, I'd pass in something like minus one. All right, so now over here, we have a constructor and I will say public edge. And let's create the constructor here. So the vertex, and I'll say the start vertex, so I'll call it as the start being the vertex. And we have any vertex or we have envy, we have the integer. And we call it as the input weight, web ID. So there you go. So we got the start vertex, the vertex and the input weight that we're going to ask the user for. So remember, this is just an edge of that we are creating as users. So the class variable, the start star will equal to the start vertex, which will be passed in as an input parameter. The same thing goes for the disk dot end. And it will equal to the end vertex, Jose and vertex. And we have the way to so we say this dot w e IG ht, and we equal that to the input, w e, IG HT. There you go. So now we're done with this. And let's just add in some other helper methods. So I'm going to be adding some helper methods along with this. And I'm just going to be copy pasting this. So here, these are the public vertex, get start. And it just going to return the start vertex, the public start vertex get and will return the end vertex of the, you know the edge of what's in the edge. And the integer gateway will just return the weight. Okay, so that was cool. Let's go back to the vertex dot java file, and just make some methods here as well. So for the vertex dot Java, and remember, like I said, we wanted to create a function that will allow us to add some edges, right, we're not giving the, we're adding a layer of abstraction here. And we're allowing the method over here, we'll just add it I just for us. So what I could do here is I could say, a public. And I'd say, void, add, II D, so II, add, add, so add edge. And if we want to add an edge to a vertex, so remember, the current vertex is already in the context. So this will be the end vertex. So I'll just pass in the end vertex here. And also the weight if you want to give it some kind of weight. Remember, I said weight is optional. If you don't want to give it it will be assigned as not to do something like that. First of all, I'm going to have the call to this, I'm going to say this dot edges, et je s, because it exists and edges over here. And then there is a function that was called add for the ArrayList, because edges is an ArrayList. And we just add in a new ad G, and we call in the constructor, so this constructor will add pass in the this, it will get the edges and a vertex, so it's going to be an vertex, and will also be the weight of the edge. So all of this will be mapped in here. So this is our add edge, and it's gonna just gonna add some edges here. All right, so now we're gonna have to create the Remove edge here. So we're gonna say public, and I'm gonna say void. Remove Ed G, and we have vertex, and we have an vertex. And over here we have the, this dot EDG II, I just got removed. And the method for this is, since it's a just as an ArrayList removed if will allow us to add a predicate and remove all of the elements of this collection that satisfy the given predicate. errors at runtime exceptions thrown during iteration or by the predicate are related to the color parameter here is a predicate. And here you can read it. It says filter a predicate, which returns true for elements to be removed. And I'm going to add that predicate here. So over here, I'm going to add in, so I want to remove that vertex. So here I'm saying remove edge right And I'm in that vertex. So I'm in the vertex, Java, and I want to remove that edge that was passed in as this one. So n vertex, right, I want to remove that edge from here. So I would say, I just removed if now say, I remove that kind of edge, right? I know, we put this arrow bracket. So this is an arrow sign, and I'm gonna say edges. And then we say get added, because we're getting actually, two things here, the edges are having two places. One is the first. And the second is the end. So you can see in the code over here, we have the start and the end. So the edge has two things. And what we want is the end. So that's why we are getting the second one. And that's going to be over there. So they'll get and, and then we say dot equals, so we say if that equals to the vertex that we passed in here, I'm just gonna copy that and paste it here. And for that equals, then just remove that from there. So we just need a semicolon here. If I could get a semicolon, all right. And that should solve our problem here. So it's just going to remove that end vertex that we passed in as an input parameter. And it's going to look at this, just dot remove if and it's going to pass in this predicate logic that says, find that edge, which has the end vertex equal to the end vertex that was passed in pretty easy. Okay, so now we're gonna add in some other helper methods, I'm gonna copy paste this as well. So I'll just paste it here. So the first thing, let me just zoom out and show you what I've done. Here, we have this remove edge, and we have the Add edge perfect. Over here, we have this Get Data method. It's a string return type. And it's just going to get the data for the vertex pretty easy, straightforward. And the ArrayList edge. So this is the return type, and it's in get edges. So it's just going to return the, the edges that the certain vertex has. So it's just going to return the list of it, this dot edges. All right. Now over here, we have a public void, print Boolean, show eight. So over here, we have this printer method that's just going to allow us to visualize our implementation. And it's just going to show us how the graph is looking like inside of our structure. So it's pretty easy, you don't need to go into detail for this. And if you want to write this down, you can pause the video and start typing this in. We're done with the edit of Java. And we're also done now with the vertex dot java. In fact, I don't even need this main method here. So I'm just going to remove that here. And now we just have this so the Virta edge dot Java and the vertex dot Java are done. Let's go to the graph dot Java, the main thing, the main boss, so over here, we're just gonna add in the following things. Remember, like I said, a graph is a list of vertices. That's exactly what we want to do here. So I'm gonna say private. And I'm gonna say array list. And I'm gonna put in the type here, the type for this is vertex, because we're putting in vertices, and we're going to pass in vertices like this has a name. Now we also have a type, which I've specified that there could be different kinds. And my graph will be a weighted graph. So I'm just going to put an is weighted boolean variable, I'm also going to put is directed boolean variable. And this is just going to tell me if the graph is directed with arrows, or if it's unidirectional, or bi directional. And so that's, that's the thing. Let's create a constructor for the graph. And we'll just say public graph. Graph, and then we'll just pass in Boolean. And we'll say input is weighted. So the things that are passed in will be determined by the user. And pool Boolean input is directed. So with all of this, and here we're gonna have the this dot vertices. And we're gonna say new array list and we're just gonna pass and so over here we have graph and then we have Boolean, input his weighted, and then we have input as directed. So like I said, we're we have to first initialize the vertices array list, so I'll just say new ArrayList vertex, put the round brackets and then the semicolon this will initialize our vertex. This will initialize our vertices list and for the weighted thing, so we can say is W E, weighted is equal to and we say input is weighted, so W E IG ht, for the other one which is directed so is directed is equal to input is directed There you go. Cool. So now this is created. And yeah, I have to import the ArrayList as well. So just import that as well. Now let's create some methods. And the important methods that we want to do here is that we want to create a method that will allow us to add vertex, add some vertices to our array list. And the name for that will be self explanatory. It's called vertex. And that's the return type. So it's going to be called add vertex. The data that will be passed in was a string. And over here, we'll say vertex. And we'll say new vertex. And over here, we're just going to create a new vertex here. So we'll say new vertex. And we'll pass in the data that was passed in. And over here, we're gonna put that inside of our list. So we'll say this dot vertices dot add, and we put the new vertex, semicolon. And then we have the return new vertex. Cool. So we're done with this, that's the Add vertex method. And it just returns to us the vertex. So we'll have to assign it to a variable in the main methods. So now we're going to create the public void, add edge method. And this will allow us to pass in the vertex, vertex one, the vertex, vertex two. So this is the start and the end vertex and the integer way, like I said, I wanted to create a level of abstraction here. So I'm allowing our graph to have the Add edge of functionality as well. So over here, it's pretty straightforward. If I said, if the thing is weighted, then there's going to be no weight for this because I passed an integer weight. And I have to first check the boolean variable here. So if I say is waited, not directed, but is W E, IG HT. Now if the waiter was false, then so it says if waited, is false, right. So we'll just say, the wait, that was passing, it will be assigned as null. All right. And if it's not false, meaning if the thing is weighted thing, so we'll say vertex, one dot add edge, and over here, we're actually adding the vertex to. And here the weight will be passed in as well. And this is the Add edge method. That's from the vertex class here. So the vertex add edge, this one. Now, over here, we want to actually add in the other thing around as well, because we don't need bi directional and unidirectional. So if it's undirected than both right, and if it's directed than just one, so I'll say if it's not directed than both, so this.is directed if it's not directed. Then we'll have the vertex, vertex two dot, add vertex, or, yeah, so vertex two dot add edge, here, we're gonna add the edge. And we're gonna say, vertex one. And we're also going to put in the weight over here as well. And there you go. Similar to how we created the Add edge method, we now need to create the Remove edge method. So let's go here a little down. And let's add the Remove edge method. So we're just like I said, I'm giving the, the power to the user to do all of this. So and the user doesn't even have to know how the vertex Java or Java works. So that's the layer of abstraction that we're creating here, remove edge, Ed EDG II, and over here, we're gonna pass in the vertex. And we'll say vertex. So to remove the edge, you'll have to need you'll need the vertex one. You'll also need the vertex two. Now to remove it, it's pretty simple. We say vertex, one dot remove, this is the method that was there. So remove edge and it takes another vertex. And we have the vertex here, we're just gonna pass in the vertex two. And there you go. And then, like I said, we have to check if it's not directed. If it's bi directional, then we have to remove the other way around as well. So I'll say if this.is done directed. So if it's undirected, right, so if it's bi directional, then after moving the other way around, as well as using vertex two dot, remove edge, and we put in the vertex one. Okay, so that was pretty much it with the Remove edge. Now we have some other methods like remove vertex, so just add an empty move redex, quickly over here, void, remove vertex. And for the Remove vertex, we have the vertex that's passed in as like this. And what we're going to do is we're going to say this dot vertices, which is the list that is existing here in this class, this instance variable, and we're going to use the remove method that's provided by the ArrayList. And we're just going to remove the vertex that you just asked for, right, so that's just going to be removed here. Now to save some time, I'm just pasting some helper methods that we also need here. So I'll just paste that in. And let's see how it looks like. So here we have the get vertices, the remover index, the get vertices method, it just returns the list is weighted, is directed. So that the last thing we did was this one, which was removed the vertex, and then after that, this one is just to get vertices, it's just going to return the array list vertex. So the whatever the array list is, it's going to return all the vertices here, inside of that current graph. Public boolean is weighted will return if the graph is weighted or not. And boolean is directed will turn if it's directed or not. Public vertex, get vertex by value, passing a value, and it will loop through this. For condition, it's going to go vertex. So you pass in a string value, and you try to look for that vertex for that kind of value. So let's say I have a stop in New Jersey, let's say Jersey City, I'm looking for Jersey City, stop for my bus, you know, bus route. So in the bus service that I'm trying to map out here, let's say I have Jersey City passed in here, now I'm gonna have to look for that stop if it exists in this entire bus ecosystem. So if it exists in the bus routes, if if there is any kind of bus stop, that has the name, Jersey City, and then it will be returned here. So over here, I go for each loop, and it says over here, the vertices are listed. So I would say for every vertex v, if the value is So I'll use the get the data value and this vertex, remember that I created get data over here somewhere. So it's supposed to be somewhere over here, there you go, it returns a data string. And if it equals to the value that was passed it as an input over here, no more return the V vertex, and then you'll have it as a vertex here. So perfect. And if it didn't exist, it will just return null. So that will help us know if the vertex exists here. And now over here, if you want to print it, so for vertex V in this vertices, v dot print, and we have is weighted, so you know the print method that we created here, this will allow us to see all of these vertices in action. Awesome. Now, let's create the main deal here. Let's create some graph. Let's create the graph data structure. And let's try to map it out. And I'm gonna remember I said I'm gonna create a bus station. So I'm gonna say gr, a pH. And I'm gonna say, bus network. And I'm going to say, new graph. And over here, we're going to pass in for the is weighted, and for the direct fizzing, we're going to pass in both true true. So T, ru, E, and t, are you ready? Now, let me tell you why it's this. The first one was input is weighted, so it is weighted, there's going to be values associated to it. So for every edge of there's going to be some kind of distance, and the input is directed, meaning that there's going to be some kind of Arrow and it's so it's a it's not bi directional. It's not two ways. It's just one way going forward. So bus network. And I'm going to use the advert x method that we created here in this method. So it asks us for a string data, and we'll just say that, say, Clifton. And here we have a semicolon. But remember that this add vertex method if you go, if you go and see the method here, it's actually returning a vertex. So we're gonna have to store in some kind of barrier variable. So let's store it in a vertex. And I'll call this as Cliff Clifton station. And it equals to that so there you go. And the same goes for the next one. So I'll say bus network, dot add vertex, and we'll say vertex. And over here, we'll have the next station I'll just add a caveman station. And let's have the vertex here as well. So, vertex and all Say, keep keep me station. And just There you go. So we created two stops. And I think that's enough for now. So now what we have to do is add the edges and the connections between them. So we use the, you know, the Add Agile method. So we'll use bus network. And we'll say add edge. And to add edge, we have to put one station to the next Jose Clifton station, and we'll say, the cape Main Station. So that's the connection. And we'll also have to put a weight, let's put a weight as well. So I'm gonna say it takes 1000 miles to reach there. And that's our weight. Cool, now it's connected. And remember that I'm not putting it. So I'm just putting it one way, and it's just going to connect it that, you know, directed way. Here we have that, if I wanted to remove an edge, it would remove it and using the same but I'm just gonna say bus network dot remove edge and his pet pass in the same two things, not the weight that time. In this case, I just want to print it out and see how it looks like. So bus network dot print. And this is our method that was that is created here. I'm actually calling all the vertices, so it's going to be printing it through here. Awesome. So let's run this baby up and see how it looks like so I'm gonna command from here. And I'm gonna say Java seed. The name of it is called Graph. God Java, it compiled. And now after that, I'm just gonna paste here. So over here we have the direction from Clifton to keep me and it takes 1000 miles. So that's exactly what we did here. Let me just minimize it quickly. And go back here. And if I look over here, I actually created a direction from clipped indicate man, it takes 1000 miles. And I didn't do the other way around. Like I said this was not undirected. It was directed because it was such true. And here you can see that there's just one way from Clifton to caveman to 1000. And I can't go from caveman back to Clifton. And if I want to do that, I could easily do that, I could just modify this so input is weighted, that's set to true if I just leave this as nothing. So by default, it will consider that as false. So alright, so I'm just going to have to if I add in false here, and that's just going to make it undirected so it's gonna go both ways around. And if I do this, now it's gonna go bidirectionally. So I'll say this, and then after that, so over here we have clipped into Cape May 1000, and came back to Clifton 1000. Using graphs to model complex networks is great but graph search algorithms are another way graphs can be useful. A graph search algorithm can be used to traverse the entire graph data structure. In search of a specific vertex value. There are two approaches to using a graph search to navigate a graph DFS and BFS DFS are depth first search follows every possible path to its conclusion. BFS on the other hand, or breadth first search expands the search from the point of origin to an ever expanding circle of neighboring vertices to track down what we visited, we add a list this list will be very crucial because it prevents a search from returning to the same vertex multiple times. This is especially important for cyclical graphs, where you could otherwise end up in an infinite loop. And we've seen this in our previous videos. So you might be wondering, how does one compute the runtime of graph search algorithms in an upper bound scenario, we will examine every vertex and edge. As a result, the big ol runtime for depth first and breadth first search is all of vertices plus edges. So you have the O and you have bracket vertices plus edges. Now, here's a question. What if you don't need to find a path, but you do need to find a list of all the values in a graph? What should be the solution there? Well, it turns out that in addition to pathfinding depth first search is pretty adept at organizing vertices, or vertex values, with a clear order of visitation from beginning to end. So you could use depth first search to find a path and you know, like, instead of pathfinding about you go to organize and show the layout of the complete graph structure. Using depth first search there are three main traversal orders that you'll come across for graph traversal, pre order, post order, and reverse post order, also known as topological sort, pre order, in which each vertex is added to the visited list, and added to the output list before getting added to the stack. So that's just one thing to remember here, in post order in which each vertex is added to the visited list and added to the output list after it is popped off of the stack. And then reverse post order, which is also known as topological sorting, which returns an output list that is exactly the reverse of the post order list. So post order and reverse post order are just like the opposites of each other. Here I have a cool graphical representation of a graph, take a look at this directed graph structure that I've depicted here, let's say that we want a list of all vertex values starting with one in the order that they are added to the stack. Now a pre ordered DFS traversal would come in handy. Now over here, we would assume that the algorithm prefers visiting things in numerical order if there is a choice, so our target value is one. And normally you would get a target value from the program. So our target value is one here. So we're starting with one, we'll go with one. So this is the first thing that's visited, this is also going to be on top of the stack. So over here, if we have a choice, we're going to prefer visiting the minimum number. So over here, we have three and four, we're going to check three, so we're going to go and visit three. And we're also going to put it on top of the stack over here. After that, we see that there's four and two. So we're going to look at the smaller number. And we're going to we're going to visit it, so two is going to be over here, two is also going to be over here. And then we're also going to check for five. So because it's five, and there's no other option, so we're going to have to check five, we'll put on the stack as five over here. And the visited will go over here as well. Now the important part came, and you could see that there's nothing after this. So we'll have to pop this thing out of the stack. So we're going to have to just pop it out like this. And now we'll check to so two still has nothing with it. So we'll pop that out as well. And then we'll check three, so three has something so it has thing that was not visited, and it was four and it's not in the visited set. So we're going to add that visit four over there. So just add four to the top of the stack here. And we're going to add four here as well. Now, we're going to check for the four, and we're going to see, well the four doesn't have anything. So we're going to pop that out on the stack as well. And then after that we have three, so we're looking at for three something and a number that is already that is not visited. So everything is visited four and two are visited. So we're going to remove three, we're going to look at one. And if there's anything that is not visited, we'll have to check. But there's nothing everything is visited three and four are there. So we'll remove that. So this is how our list will appear 13254. So this is the pre order DFS traversal. Alright, so like I said, that pre order is, is the kind of order in which each vertex is added to the visited list, and added to the output list before getting added to the stack. So this was our pre order traversal. Now we want to look at post order traversal, in which each vertex is added to the visited list, and add it to the output list after it is popped off of the stack. So if we look at take a look at the post order traversal, we'll go like this. So for the first thing, it's one, so we're just going to look at one, we're not going to add it to the list or anything yet, then we're gonna look at the smaller number which is three, then we're going to look at something even smaller than that, which is two, then we're going to look at something and then we have five. So there you go, the last number came, so it's going to go like this five. And then after that, it's going to go and see the two because it's going to be popped off as well. So five, two, and then we're going to look at three. So three actually has something for this. So we're going to have to add four. And then we have nothing over here, so four, and then we have back to three. So back to three. And then we have we have the last one, which is one. So this is our post order traversal. This is how it's going to appear. And the reverse post order, which is also known as the topological sword will return an output list that is exactly the reverse of the post order list. So this is a post order traversal. And the exact opposite of this is 1342 and then five. So this year is the reverse posed order, also known as the topological sword. And these are just different ways to traverse the graph. The most common was the first one which was pre order, and that's the default thing. And it's easy for us to get a full overview of the graph like that. Alright, so let's have a conceptual overview of how the depth first search DFS is going to work. So let's suppose we have our target value as one. So we're gonna go and visit one here. And we're also going to put it on the stack. So that's the top of the stack, then we'll have to look at the number that is smaller from this choice. Over here, we got three and four, we're looking at a smaller number. And we'll put three on top of the stack here. And we'll put it as our visited set as well. So we have three, and then after that, we look at the smaller number from these two, and the two is a smaller number. So we'll put it in the visited set. And we'll also put in the DFS stack. So we'll put it up on the top over here. And now we can see that five is the only option. So we'll have to use five here as the visited. And then we'll have to put five here on the top of the stack as well. Since there's nothing over here on this, there's nothing after the five, so we're going to have to pop this out. So to do this, we're going to have to just select this number and just pop it out. And now we're going to look at two, so there's nothing with two as well. So we're going to have to pop this out, three has some unvisited vertex, which is this four, one, because it's not in the set over there. So we're just going to have to use this now. So we're going to use four, and we're going to put it over here. So four is going to be over here, and four will be on top of the stack as well. Now we look at four, because this is our current current vertex. And there's nothing over here that's unvisited. So we're gonna have to pop this out again. So let's just pop it out. So there you go, this is popped out. And now we look at three, there's nothing unvisited. So we'll just pop this out, look at one, and there's nothing unvisited, so we'll just pop that out. Once the stack is complete from here, so it's empty, we'll have a list over here 13254. And this is a list of all of the vertices inside of this entire graph. So we have 1325, and four, this was our DFS depth first search. Now let's write the code for this. So here I have a class graph traverser. And it has a main method. And also I have a sample graph that I've created earlier. And it just contains up some vertices. And yeah, it just has a method here that says Get starting vertex. And we'll get the first vertex here from the graph. Now, our job here is to write the code for depth first, traversal reversals are extremely useful when trying to find a specific value or path in a graph. We'll start with the depth first traversal method for recursively traversing a directed graph. To summarize depth first traversal, iterate down each vertex, one neighbor at a time. In this video, I'll focus on traversing the entire length of a single path, and putting the data value of each vertex. Now in test graph dot Java, I've created a sample graph for us to test the traversals against this is all linked to my last video about graphs. So we created a graph here, and we have this input is weighted as false and is directed as true. So there's no weight, but it's directed meaning it's, it has directions, right. And we have a vertex, start node, and we have tests, we have now add vertex, and we have the name. So these are the names of our vertices. And yeah, so they're all these vertices here. Now I have all of these vertices that I added, and then I created these variables to associate to them. And then after that, what we did is add edges. So connections were done. After that, we created a cycle here as well. And this is not exactly the same graph that I've made in the diagram. So what I have, what I have here in the diagram was just simple so that you could easily understand how DFS works. But here I just created a complex one so that we could test out cycles as well. And other things. After that, we have this graph traversal dot java. To keep things simple. I created a separate graph traversal utility class in graph traversal, dot Java, and I'll implement the traversal iterator as a static method here. Now I've seen implementations in which they created the iterator inside of the graph class. So now let's start writing the code here in the graph traverser dot Java utility class, we're gonna, first of all, let's just add a method that is for the depth first traversal. So we say public, and we say static, because it's a static method and void. And we're gonna say depth first. Because we're using a static method here, because this is a utility class. So depth first traversal. And here, I'm just going to pass in the vertex to start with. So a one I need the very start vertex. And also I need a list of all the visited vertices for this start one, so that will be called as an ArrayList. And I'm gonna put in the vertex type here. And we're also going to put in the name as visited, and then we have vertices. Cool. So now we're done with this. Let's add in the things here. First, let's just print out the value of our start data. So we have a system dot out dot print Island, and we say start dot get data. So you might be asking, Where do I get this get data from. So I already have vertex dot Java included here, and I've created this in my previous video. So we have a Get Data method, and it's just returns the string data, now that we're gonna have to iterate through this vertex, and we're gonna check its edges, so all of the edges for the start vertex, so we could use an edge at V of E. So for all the edges E in the Start dot get edges. So this is also a method inside of the vertex class. So over here, I am saying that for every edge inside of the start, edges, so that's this means all of those, all of those neighbors that are connected, so we have to get the neighbor vertex to get that we got to use E dot get. And, and this will give us a vertex. So you can see that returned gave us a vertex, and we're gonna save it as a vertex, neighbor any igvh vor. Now, one thing to note here is that this e is an edge and the get end is from the edge class. So this is also here. So get end is going to be somewhere over here, there you go. And it returns the vertex, and from there, so it's just pretty simple. This one, the end vertex. Now, right after this, I'm gonna have a conditional here. And I'm going to check if, if my visited vertices does not contain this thing, so I'm going to add it inside. So now we even know. And we could, we could mark that that we already visited or not to keep track, if we visited vertices or not, we're going to add this conditional. So if we're going to use visited vertices, and then we say, dot contains. And then we have the, the neighbor, and I say if that contains inside of the visitor vertices, because you know that the visited vertices was passed here. And I'm saying if it's not inside of the visitor vertices, then we want to add it. So we'll just put a negation here. And let's also quickly add this import. So just over a year and quick fix, import the ArrayList as well on top. Okay, cool. Now over here, in this inside the conditional, I'm going to add in the visited vertices, and I'm going to say dot add. And I'm going to add in the neighbor vertex here. So I'm going to say neighbor, since our visited vertices holds the vertices, vertices, and we could easily add a vertex here, the really important recursive call here is that we're gonna do a recursive call that will go to the graph traversal again, so you're gonna call the graph traverser, which is this current class, and we're going to call the method which is depth first traversal. And now it's requiring us a start and visited, so the visit of vertices will be the same thing. But now we're gonna go with the neighbor. So an E, I VHBO. Art of so we're done with that. And the conditional is done. And here's the for each loop, it's going to iterate through all of the edges for our Stryver index, and it's going to go until it's done. So that's pretty much it with our depth first traversal, we could test it out in our main method, we're going to create a test graph. And we're going to say test. And what we're going to say is new test graph. Okay, so where am I creating this from this is actually from this place. And this is just creating a test graph. Remember, like I said, it created this whenever this is a Public Test graph constructor, and in the constructor is just doing all of the work for us. So normally, we would put this in a main method, but we're putting this in a constructor. So it's creating a gigantic, ginormous kind of graph with so many vertices. So V one v two v one one, we want to all these a 1234567899 vertices, and they're connected edges. And what's it going to do is it's going to show us through this, so we're just going to create it here. And we're going to pass it in. So before that we actually need the starting vertex of our test graph as well. And we have created this handy method here, which was get starting vertex, which returns us the first vertex in our graph. So we could use test, and then we say, Get starting vertex. And this would just give us the starting vertex and we go save it somewhere inside because of return. This actually returns a vertex type. So we could say vertex, and we say, starting vertex, so we'd say, starting vertex, and we'll just equal it. Okay, cool. So now that it's equal, now, we can add in the visited vertices. So now let's add up the visited vertices list. So array list. And I'll put the type as a vertex. And I'll call this as visited vertices, visited vertices. And here we're gonna pass in a new array list. And here, we're gonna just instantiate it. So like that, and a semicolon at the end. So we've created a visited vertices array list as well. And we're going to add in the starting vertex, because it's already visited. So we're just going to add it before all of the operations. And we'll just add in starting vertex here. Cool. Now when it's done, we're done with this initial thing. Now, we could finally call our depth first traversal. So this thing is really easy. It's the name of the graph traverser dot depth first traversal. And it's asking us for the start vertex. So we'll say starting vertex, and the visited vertices, and this should have printed out. So let's go into this place, which is right here. And command prompt it here. And let's go down and let's say Java C, and we say, graph traverser, dot java. And now let's just run it so Java graph for a sir. So here we have, the way how this will work. That's pretty pretty dope. Now it's time to focus on breadth first traversal. As a reminder, the breadth first traversal iterates through the graph and layers, it goes down one layer, which comprises the start vertex has direct neighbors, then it proceeds down to the next layer, which consists of all the vertices that are neighbors of the vertices in the previous layer. And for this example, I'll focus on traversing down one layer, and then take a similar approach as we did with the depth first traversal by keeping an array of visited vertices to prevent us from iterating through the same vertices over and over, however, we will iterate through all of the direct neighbor vertices instead of iterating. Down the neighbors first edge, like we did in depth first traversal, we will also use a queue to traverse through the graph instead of recursion to explore the different ways we can implement the traverse, I'll reuse the same task graph that was used in the depth first traversal implementation. Alright, so what I have is a directed graph. And I'm going to have to apply a breadth first traversal. So what I'm going to do is I'm going to get my target value, suppose we have it as one starting value, and I'm just going to put it in the visited. And I'm also going to put it in our BFS queue, we're going to look at our adjacent vertices and see the smaller number. So here we have three, and we're going to choose that as the first one. So we're going to say three, as our visited. And we're also going to put three here as well. Now that we've done that, we look at the other adjacent one, which is four, and we're going to add that in our visited set. And we're also going to add it here in our queue. Now that we've exhausted our current vertex, since there are no more unvisited vertices, so we're going to have to remove this one from our queue. So we're going to remove this one, and now three will be our new current vertex. And we'll look at the adjacent ones here. So we have two and four, but two is smaller. So we're going to choose two first. And here we have two in the visited and two in the queue. Now we also have four, but four is already visited here. So we're not going to look at that. Now that we've done this, we're going to have to, since three is exhausted, now we're going to have to remove that as well. So we're going to DQ it. And we're going to now look at four now four is over here, and there's nothing that we could visit. So we're going to have to remove this as well. So we'll remove four. And after that we could see two is now our current vertex, and two has a neighboring a neighboring vertex, which is five, so we'll put five here and it's the only neighboring vertex. So we'll just put the BFS queue over here. So now that we've exhausted two, we'll remove it from there as well. And five is also nothing. So there's nothing with five as well. So that's completely exhausted as well. So here we have completely visited the entire graph using breadth first search 1342 and five awesome now let's write the code for this. So I'm going to the same file where I created my depth first search and I'm going to add my breadth first search right after this. So this is my depth first search and right after that, I'm going to create my breadth first search. So I'm gonna say public. And we're also going to make this as a static method. Since this is a utility class and br E A D, E H, F fi rst and then sc search. So depth first search. So breadth first search, adding the vertex start, just like that. And also the array list, which is the vertex And this is going to be called the visited vertices, just like what we did up on the top for our depth first traversal. Now, since you saw the graphical implementation there, I use a queue. So I'm going to create a queue here as well. So queue, and I'll call it visit to. And here, we're going to equal it to new Q. So Q u, u. And we'll just put that as well. Now, you might be asking, where is it Q coming from? Well, I actually have the Q file here as well. So this is the queue dot java file. And we've created queues before, but actually modified here a little bit. So the same exact queue that we've created in our video series. But I just modified it a little bit, just to add vertex as the data now instead of a string or some kind of integer. So removing that, and now let's just go here. And over here, now we created our queue, it's called our visit to, and we're going to have the visit to dot n Q, the first thing, which is the start, which was passed in as the input parameter, and that's the vertex there. Now, we're adding a while loop. And this is going to go until the visit queue is not empty. So I'll say visit to because this is a queue, it has this method, which is empty, and I've created that one. So I'll say if it's not empty, we're going to go inside of this visit queue and keep doing those removing queue things and, you know, traversing and using breadth first search there. So for that, I could, let's just get something down and actually, DQ the, the elements in the queue, so we could say visit. So we can say visit u.dq. And here we have a vertex that we have to do. So we'll put it inside of a current variable. So we'll say current. All right, so now that it's in current, we could print out the value here, as well as just say, system dot out, dot print. ln, and then we say, you know, current dot data. And there's a Get Data method that was in the vertex class. So there you go, it's working there. Now we're using a for each loop to go through each of the edges inside of this current vertex. Because that's what I showed you in the graphical implementation. Now, I'm just mapping all of that entire explanation down in code. So I'm gonna saying edge for every edge of the current vertex. So it's a current dot get edges, which is returning an array list of edges. And what we could do here is that, so now we're gonna get the neighboring vertex of the current vertex. To do that, we could easily get it from E dot get an end. And that returns us a vertex, that's our neighboring vertex. And we pass it in to this vertex variable, and we'll call it as neighbor. And over here we'll apply a conditional. And we'll say if the now since I'm using a visited vertices array list over here in my input parameter that checks if something is not repeated twice, so I'm saying if it's not existing, so I'll say if visited vertices dot contains. And neighbor thing, and e i g, h vor. So I'm saying if it does not contain it, then you should add it. So I'm saying, if it does not contain that neighbor vertex, then you should add it. So we'll say visited vertices dot add. And so visited vertices dot add, and then we'll add in the neighbor, vertex. Perfect. And then the last thing that we could do here, because we created this visit queue, and we'll include this inside of our visit queue, so we'll just say visit cube dot n q, which is this, and we'll put in a vertex data. So we'll put in that vertex, which is the neighbor and e i g, h, V o r, so this will be inside of our visit Q, which is this queue, and it just currently had only the start. But once you get the edge of the neighboring vertex, you also pass that inside of the visit queue. So that will be now the current vertex and it will go until there's a dead end and then we'll just remove from the in queue and then so once it's exhausted, like you'll see over here in this while loop, so it's just gonna say until it's empty, not empty, so it's just gonna keep going. And once it's exhausted, like you can see over here DQ so just see the other words sees that are there to traverse. Now let's go Downey in the main method, and just have everything over here set like this. So just pause the video and type along. And over here for the starting vertex test dot starting vertex, here we have a ArrayList vertex visited vertices, the same thing. And this is the same exact thing. So instead of depth first traversal, we're gonna say, be our breadth first traversal. And the rest is history. And compiling it and running it. Let me just label them as well. So don't net out dot print, ln, or we just have a line here, so print and then we say d f s, I will say B, F s, run this. So here you go. The difference between the two of the traversal techniques here we have DFS at the other side, we have BFS. So we have over here 011, and something like that. And then we have two over here, so something's going on differently. But if you look at the total numbers, 12345678910 123456789, and 10. So the total number should be 10. It's there's 10 over here, and there's 10 over here. And if we look at the test graph dot Java here, so the start node 123456789, and 10. Awesome. So that was it. That was my code for depth first traversal. Welcome to another video, today we're going to be talking about Dykstra algorithm. A very important algorithm in the computer science world, finding the shortest distance between vertices is one of the most common applications of graph searches. Finding this distance has a number of applications, including determining the best route to a destination and transferring data over a computer network. Consider the graph finding the shortest path between vertex A to vertex E may appear simple in your mind. But telling a computer how to do so is a bit more difficult. Fortunately, there is an algorithm that computes the shortest distance between any two vertices in a graph. This is known as Dykstra algorithm. Now, let's look at the conceptual overview of how the Dijkstra algorithm is going to work, we're going to start with the starting vertex. And you can see that the start is pointing to eight. So this is my target vertex. Here I have a distances cube, and also have this unvisited, which is on the bottom. Now, I'm going to look at the first step here in this algorithm. And the first step is to pop off the minimum distance of the unvisited vertices that you can see over here, the minimum distance here is zero, and these rest are all set to infinity, meaning that the distance from A to itself is zero. And the distance from A to any one of these vertices is infinity for now. And if we look at the minimum distance, right now, it's 00. So we're going to pop this off, so we're going to pop it off from here, and then we're going to look at the adjacent vertices corresponding to this first vertex. So you can see over here, so from A to B, the distance is four. Now if you compare this with the original distance, which is infinity, now four is less than infinity, so we could replace this infinity with four. Since we replaced that now, we could also go and check the next corresponding distance, now A to C has a weight of two. Now you can see that two is less than the infinity. Now, we can also replace this infinity with two. Now we're done with that. And we're going to this is our first iteration of the algorithm. Now we're gonna go to the next iteration. So now we're going to pop off the minimum distance of the unvisited vertices. And you can see for now, we can see that too, which is the for C is the minimum vertices, we're going to pop that out from here. And we're going to start with C. So you can see C has at A, C only has one neighbor, and that is E, and the distance from c to E is one, and you have to look at the distance from A to C two. So the agency was to and from C to E was one total distance from A to E is three, so two plus one is three. So what we're going to do here is we're going to make from A to E as three and then we're going to look at the E portion and we got to see that three is less than infinity. So we're going to replace this infinity with three. Now. Since there is no more neighbors left, we're going to need to do the next iteration for this out Rhythm C has no more neighbors. So now we're going to pop off the minimum distance of the unvisited vertices, you can see now that the minimum distance is three, so it's an E, so we're gonna pop this off, and we're going to go to E and look at the, the neighbors for each. So E has only one neighbor. And that is indeed, the wait for that as five, the distance will be three plus five, which is eight, and eight is less than infinity. So we can replace this infinity with eight. Now that we have replaced that, we can also see that there is no more corresponding vertices. So we could stop here and do the next iteration for the algorithm. Now, we're going to pop up the minimum distance of the unvisited vertices. So you can see that the minimum distance is b. So we're going to pop this off. And over here, we're going to look at the corresponding neighbors. Now B has one, two, and three corresponding neighbors, we're going to start with the first one, which is C. So B to C is one. And now you can see that from A to B, which was already existing was four, and from there to see it's one, so five, so from A to C will be five. And if we look at the C, it already exists here, and and you can see five is greater than two, so we're not going to change this value, then we're going to look at the distance from B to E, and that's three. So from A to B, it's four, and from there to E, it's seven. So if we look at the distance from A to E, that should be seven. And that is greater than the value that we already have here. So we're not going to change that at all, either. Now we're going to look at the last and final neighbor of B, and that is D, now we look at the weight, this is two, and the distance from here was four, two, so it's going to be from A to B, it's four, and from B to D, it's going to be two, so the total distance here from A to D will be six. And we will look at the distance over here that is actually lesser than what we have existing. So we could replace this eight with six. And that now will be the end of our iteration. And now we'll go to the next iteration of our algorithm. Now we're going to try to pop up the minimum distance of the unvisited vertices. Since we only have one versus left, which is D, I will look at the minimum distance here. And that is the minimum distance rest everything has been visited. So that's D, so we're going to try to bring it up, pop it off. And we look try to look at any neighbors for D but there's nothing. So that's the end of our algorithm there. And that's how Dykstra is algorithm is implemented. So you went over there and saw all of the possible distances for so from a to itself, the minimum distance is zero, from A to B, the minimum distance is four till here, from A to C, the minimum distance is two, right here, from A to D, the minimum distance is six, so, four to two here, and from A to E, the minimum distance is three, so eight to eat at the minimum distances three. So, that sums up our dexterous algorithm conceptual overview. Now, we're going to start writing the code for this. But before getting on to the code, let's think of what we should add in or what objects and what structures should we create. Looking into this algorithm. We're going to instantiate a dictionary that will eventually map vertices to their distance from the start vertex. So like you can see over here we're going to put that in a dictionary. A quick recap before we start the code for this Dykstra does algorithm finds all of the shortest distances between a starting vertex and the remaining vertices in a graph. The algorithm operates by keeping track of all distances and updating them as it performs a breadth first search Dykstra the algorithm is implemented in all of E plus V of log of V, and E means edges. And v means vertices, we will first implement the algorithm to find the shortest distance to every vertex. So let's go through the code and all of the conceptual overview that I gave. Now I'm going to try to map this out in code. So here I have imported java util dot asterisk, meaning I'm importing everything that's available in the utility package, and have it over here that you can see is public class Dykstra, and there I have a main method. Here I have a main method, which is actually creating a test graph. And the weighted and directed properties are set to true. And we also add these vertices here, so A, B, C, D, E, F, G, and we also add their connections to each other. So those are done. So what we mainly have here is a test graph in our main method to test the output of the method. What we're going to create in this video, so we're going to try to create that method, which is called Die extras. So for that, we're gonna have the public and we're gonna say static dictionary And we put in this. So we're going to return an array of dictionaries. And I'll tell you why we're doing this in just a second. So here we have the name of the algorithm, Dykstra, and we're going to tell the parameter to add in these two values. First thing is to have the graph. So d r a p h, and we call that as G, we also need to pass in a vertex. And that will be will be called as starting vertex. So we're done with these two input parameters. Now, we're going to create two dictionary objects here. And one will be used for the distances queue, the other one will be used to keep track of your previous vertex. And this is very crucial in this algorithm, we're gonna make a dictionary and a dictionary is just a base of key value pairs, we have a string, which is the key and integer as the value. And we call this as distances. And we create a new hash table. And we put in these angle brackets and the round bracket, and then we semicolon at the end. So that's the distances Q. Now we also need another hash table. And this one will be for the previous. So we add this as well. And for this, we're not going to have the integer as the value but the vertex, this is going to store the data, and the also value that exists. So like I was doing it over there in the diagram, this A, and it maps out to zero, and this b that maps out to four, so the string is the letter, and the value is going to be the integer. And for the second dictionary, which is previous, it's gonna keep track of the previous vertex. So that will have a string, which is the current vertex, and vertex will be the previous. Now, we also need to add in a priority queue. So I have added some files here. And this isn't one that's called queue object dot java. This is actually a class that implements the Comparable queue object. And you can see that it has the vertex and the priority as class variables. And you can see the, the constructor is actually creating this object, and it's overriding the compare to method with some priority base. So if it's equal in priority to the input parameter, we just return zero. If the class variable priority is greater than the priority that was passed in is, then we will return one out, we will return minus one. So this is just just a file. And it's just a fancy queue. It's just known as a priority queue. The main difference between this queue and the priority queue is that this will look at the smallest value, smallest possible value, and it will allow us to pop that one off. So like what we're trying to do here, we were trying to look at the minimum value and the where you're trying to pop that off, that exact implementation is priority kilojoule for us and without writing extra code. So that's one of the biggest benefits for using that. So let's add the priority queue. And this is the priority queues. priority queue. And we're gonna add in the queue objects here. So if qu e we are gonna say, object that we created. And then we got ADD name for that as Q, Q, U, e, u e, is equal to now we're going to add in the new and it was a priority queue. And here, we're just going to add in the queue object once more queue, you deal with obj eects, and then a semicolon at the end of perfect. So this is our priority queue created. And I'm just adding the same exactly, just after that. Now, you might be asking, well, the priority queue is actually empty right, now we got a queue something inside. Now the thing that we're going to queue inside for the first thing is the starting vertex, since we know the distance for that is zero to itself. So we're just going to queue that up in here. So to say qu e dot add. And here we're just going to say a new Q object. And we're going to pass in the vertex V and the int p, which is the priority of the vertex v is just going to be the starting vertex. And the priority for this would be zero. Awesome. Now we're gonna try to iterate through this entire graph that was passed in as an input parameter. And we're going to try to iterate through and try to find all the vertices here. So we can use a for each loop for this purpose, we're gonna say, for every vertex v. So we can say, for every vertex V, in the G dot, get vertices. And this is returning an ArrayList of vertex. And you're just doing this really easily. And this is also added here. So I have a graph dot java file. And this is also added. So that's why I'm able to get the method get vertices. So this is get vertices. And it should be over here. So we're good vertices. So this is the get vertices method. And I'm also adding this edge dot Java as well as this vertex dot Java, you could look at my older videos. And from there, I'm actually using all of those classes that have created in the graph dot Java, the vertex, dot Java, and the edge dot Java are all done in a single video, which was called graphs in Java. So watch that video. And for this cool object, I'm just gonna let you see this code for now, you can just pause the video and copy this. And once you have all of these, we could go back here in the Dykstra dot Java, and we're just going to iterate through the vertices which are in this graph, which was passed in as an input parameter. Now, we're going to have to iterate through this. And we're going to actually update our distances, which was over here. So we're going to actually have to update our distances and previous dictionaries. So we're going to try to add all these vertices from this graph to this distances and previous dictionaries, we could do. First of all, we don't want the starting vertex to have a maximum integer of max value, because we know that the starting vertex to itself is zero. So we're going to give a condition here and say, if the vertex you get is the starting vertex, and this is just going to work. So we're gonna say if that one is the starting vertex. We don't want that. So if it's not, right, so we want to update the distances, and we're going to have to add input. This is a method available in the dictionary. And this is, this allows us to add a key and value pair. So the string is the key, and the value is the integer. So what we could do here is for the string, we could say V, which is the vertex, or we say golf dot get. So we could say, Get Data, and that will return a string here. And this is also added in the vertex dot java. So that's why it's working here. And for the integer, we're just adding the maximum or we want to use the infinity symbol, right, we're going to use integer dot max value, this would give us the maximum value for the integer in Java, and that will be stored inside of the value pairs. So key values are done. And for the other case, where we have the previous dictionary, so we'll say previous, previous a previous output. And for this second dictionary will also have a key value pair, but the value is a vertex. So the key is going to be the get data, the same thing. But for the value in this case, will be the previous vertex so that we could keep track of this. So we're just going to add in a vertex that will be set to null for now. And then after that, we're going to update it inside of our code. So right now just set everything to know, including the starting vertex. All right, so right after this, we needed to add in the starting vertex here in our distances, because we don't have it. So to do that, we'll just add in the distances again. That was a foot. And now we want to add in the key value pair for that. And for this add in the starting vertex, and we actually need the value for this, I'm gonna say, Get Data, and that will give us the string data. And for the value, I'm not going to give the maximum value, we're not going to give infinity because if we look at this code over here, initially, it was set to zero, so we want to just set it to zero here, I'll put it there. And there you go. So we created this entire thing, what you can see over here, so you can see this entire thing that we've created, which has a set to zero, and the rest are all set to the infinity or the max value. Now, let's go back. And we're going to actually do the second step for this algorithm. Now it's the fun part. We're going to have to iterate through the while loop. And we're going to check if the queue is not empty. So we say qu e u e, this, this is our priority you I will say the size method here. And if we say of that size is not equal to zero. We're going to do Do some operations inside of this queue. First of all, we're gonna get the current vertex here. And that is pretty simple Q dot call, retrieves and removes the head of this queue, or returns null if this queue is empty. So we're gonna actually remove an item from the queue using this method. And we want the vertex here. So we just say the vertex, because we had this over here as this queue object, and we wanted to vertex here. So we're removing that from the priority queue. So the first thing will just be the starting vertex. And that was added in our queue. So this was added over here to to Add New Objects, starting with x with the value zero. So that was zero was actually it's a value to itself. So this is now set to current, and we removed it from the queue. Perfect. Now we're going to iterate through this current variable, which is the starting vertex. So we're going to look at all of the edges or the neighbors for a year. So we say, for every edge of Eid. And we say, mapping out to the current dot get edges, which is the ArrayList, returning of edges. So for every edges, or every neighbors inside of this current, so every edge, an edge contains vertices, remember, so we're actually going to first look at the value of what the edges giving us remember, like I did in this first one, that we were looking at the values, and we also judging inside of our distances. So we looked at, let's say, for, for the distance to D, we had some already included distance was 215, which was eight. So that was already passed in. But we also want to keep track of the newer one. So this is like four two, which is six. And now this is an alternative one, we have to add that somewhere, and then we have to judge something like if it's less than the original one, then we could replace it. So we won't have an alternative. And we want to also have the original. So for the alternative case, we'll add in an integer. And I'll say alternative. And I could add the distances here. So distances, and this is the distances dictionary, and I'll get the current dog get data. And that is the string. And we also want the plus to the eat, get wage, so we're going to get the weight as the end. So this is the distance from the current distance of the variable and the edge distance. So what this means is, whatever the distance is existing for this current nugget data, the starting vertex is actually zero to the distance where it's leading to with its vertex. So the edge where it's leading to with its edge, it's make sense because this is zero to itself. But if we're moving forward, we have an edge with it, and we have some weight, so we're adding that weight as well. So get weight. That's the alternative. And we all need a reference to our string, neighbour variable. So we got to have that as any igvh vor. So this is our neighbor value. And we just have to keep it just keep it inside. So we could eat, get and so this is the vertex. And we want the value for this. So we have Geat EDA and we have get data. So over here, it's pretty simple, we have a neighbor value, and we want to have the edge vertex. So we want to have the edge and we want to get the end. So we're gonna get the vertex through this. And to get the data, we just say this, so we're gonna get the vertex through this get end, and we're gonna get the data so that string is actually stored in the neighbor value. Now that the string is stored, we could use a conditional here to check if the alternative value is lesser than the original value. So what we're gonna do here is pretty simple, we'll say alternative is less than the distances and we want the dictionary so this is the distances dot get, and we want to get the value for this, we can just use the neighbor value, so that's why I stored it over there, so that we can get the value of their neighbor value. Alternative value is less than our neighbor value. So what we're going to do is that neighbor value is actually the original distance that was stored inside of our distances object which is on top. So over here we have distances. If that is possible. We're just trying to override it and so we're going to say distances dot put it I'm going to get the neighbor value. So that exact neighbor value, but we're going to change it the value to the alternative. So we're going to get the key and the value. So this is the string neighbor value, and then the integer will be now the alternative distance. Also, we're going to have to modify our previous, so we're going to have to add in the neighbor value as well. So for the neighbor value, we actually need the previous reference. And the previous reference will now be for our current instance, with the current one, which is now which is actually starting vertex will be the previous vertex for our neighbor value, which is the current one over there. So it's just gonna keep iterating this and updating our previous reference. And the last thing, what we want to do is we want to add the neighboring value to our two u two u, eu object, and we have to add in the vertex here, so we're gonna say e dot get, and so that's just gonna give us the vertex here. And to get the priority, we could say, the distances structure dot get. And to get the value, I'm just going to add in neighbor value, and that will give us the value. So this is a neighbor value is the key, and it will give us the value which is associated to this key. And that will be updated to our cue. And that's going to be our priority. So that will be added. And once it's done, we're actually going to break out from this for loop when all of these edges are done. And that will be updated. And after that, until the wild size is not less than zero. So this is just a line that will pop off the minimum distance of the unvisited vertex. And the rest is history over here, what you saw all in the conceptional overview, everything is happening and adjusting, and the right at the end, so when the while loop breaks, so that I Dykstra is requiring us to return a dictionary array, right? So we want to return that. So over here, right after the while loop, we could return a new dictionary. And so over here, we're going to return a new VI, C T, IO N ar y. And we're going to get this way racket over here, which is the array for this dictionary. And this is the array of the dictionary. And we want to pass in the distances, distances with the previous structure here, this is a return statement, we're going to return a new dictionary, and it will have the distances and the previous dictionaries. So we'll have both the distances and previous dictionaries inside of this dictionary array, which is returning here in our function. So we're going to hear that dictionary arrays returning. So this is the return statement at the end. And yeah, so that was pretty much it with this function. This is minimizing it, so you can see the entire thing. So this is the entire method for extra. Now, we also have this helper method on this bottom, so I'm just going to paste this in. This is called the Dykstra result, printer method. And what it accepts is an array of dictionaries, well, how convenient, we're just going to use this entire thing, I'm just going to return it and so we can pass it inside of this. And this will just actually print all the distances. So what you'll see over here, so it's gonna print out the updated distances like this. And it's also going to print out the previous positions. So you're going to see that as well. So since the these both were dictionaries, we're going to use enumeration as keys to get the values of all of this and it's just going to give us the key and value pairs, and it's going to be pretty cool. So these both are going to be allowing us to print these structures. So we're going to add this process here. So let's just create this call. So we had this test graph. And what we want to do is we want to use this method here, which is Dykstra. To use this we have to pass that inside. So we're going to use Dykstra here. I ran a passing the test graph, alternate paths in the starting vertex, and that is a because over here is the first vertex and that's going to be our starting vertex. You can set anything you want later on. And then after that, we're actually calling this inside of this method, which is dexta result printer, since it's accepting a dictionary array of D, so I'm gonna paste this thing inside, and we're gonna wrap it around the Dykstra. So there you go. And this will just print out the things. So cool. So now let's run this code. So let's go and add an CMD here. And let's run this code. So Java C, ed i j, k, s t r a dot java. And now let's just run it using Java DIJKSP Ra. Alright, so we have an error here, something no pointer exception, okay? What's the shortest path between two vertices. To calculate that we'll just create a new method here. And we'll call this as public static, void. And we'll call this as shortest path between. Inside here we'll have a graph DRA p h, and we'll call as graph G, we're also going to have the vertex, and we're gonna get the starting vertex. And we also need the targeted vertex. So we're gonna say, target work at x. Here, we have the shortest path between method in which we're going to input the graph the starting vertex and the target of vertex because we want the minimum distance between two vertices. So we're gonna use this method for that case, we're gonna have the dictionary array object here, and we're going to call this as Dykstra has dictionaries. And that will be equal to the dictionaries. So we're going to call the extra method here, we're going to call it using the graph and the starting vertex. What actually it gives us is the distances and the previous dictionaries. And I'm getting an error here. It's actually di J. The method Dykstra is defined for undefined for the type Dykstra. So the reason why I'm getting an error here is because I don't have a k. So di, j, k. And if I do that, I'm all set. Now we want to put the distances and previous in their own variables. So we're gonna have the scope for that. So I'm gonna say, distances dictionary. And it will contain all the values which we had, and then we're gonna manipulate this. So we're gonna say dictionaries. So Dykstra, D ij, k, s, t, R, A, and we have Dykstra dictionaries. And we have this sub zero, that will contain our Dix distances. And for the second one, and for the second one, we could have that as one. And that will be our previous awesome, to get the distance of our target word that we're gonna say distances. docket, and we need to get the target vertex. And we want the value for that we can say get data, that will return a string. And that will actually map us to the value from our distances, which will be something like, you know, the value of what it will take for us to reach from A to that point, and that we could store in some variable called distance. So make sure you have the type set to integer here. And then that should go away. Now, what we want to do here is we want a print screen, that will just show us the shortest distance path between these two. So what we could do is, we could paste this in. And this is just going to print out the shortest distance between the starting vertex get data and the target vertex dot get data. So just in between the two vertex, this is just going to give us the letters, you know the distance between A to whatever. And system dot out dot print ln will just print us the distance, which was inside of the target vertex. Now we actually need the, the generated path that we should follow to create the path, we're going to create an ArrayList for us. And that will be of type vertex. And we will call that as path we initialized an ArrayList to get the target vertex and assign it to a variable is very important here. So we're gonna have target vertex and assign it to a variable. So we're gonna go from the target vertex to the starting vertex. It's a bit like the reverse linked list. So we're going to use some kind of functionality like that. We're going to use a while loop and we say while the V, the vertex. So if the V is data, and the Get Data will pass in a string I'd say that is not, no, because we know that the first one which has started will is no, we're gonna add in the path. So the path is actually the ArrayList, we're gonna say the path dot add, we're gonna add a zero here, because the path is actually making us add something inside of this. So we're going to add in a zero. And this will mean that it will be popped in the for direction, it's not going to go backwards, it's not going to queue there. But every time a new value exists, it will come in the beginning, every time a new value is added to this ArrayList, it will be added in the beginning. So patha, add zero will be added. So every value will be added to the beginning of the queue, not the end. And the other thing that we want to do is we want to pass it that VT, so that vertex that we set up will be also passed in here. And then the next step here is to get the previous instance here. So we can say previous structure, which is a dictionary, dot get. And what we need is the data here, so we say v dot get data. That would give us a string, previous dot get, and we got the value over here, and we're going to assign that to the vertex. So since we have that get process here, we actually need the vertex here. And that will assign it to the vertex. So it's just going to keep going like that. After this while loop, we could just print out system dot out dot println in the shortest path. And what we'd have now is the shortest path as well. So we could go from vertex path vertex to from the path structure, which is over here somewhere. So vertex path vertex. So so we have this path, which is this entire array list that now contains all of the vertices for that directed path. Now all we're going to do is iterate through this for every path vertex, we're going to print path vertex dot get data, and I will just print the letters of the port corresponding path. Now the only thing that I'm going to do right now is, like I said, I called Dykstra dot Dykstra result printer, and I passed in these two. So what I happened here was that I was on an error. And whenever I was running this code, I was getting this error over here at line number, 26, and 94. So over here in line number 26, and 94, it doesn't give me any clue of what's happening. But you could tell that alternative is less than distances dot that get the more value. So I was looking at the alternative value very carefully, here, I noticed that I did get an error while I was doing this. So this is actually a syntactical error, I was trying to get the alternative path distance, and I was getting the value from the distances dictionary, and I wanted to current dot get data. And this is what's gonna, this was going to actually give us the value for this one. So I didn't need this parenthesis over here, I actually needed that closed here. And now it was just going to give us the value here, which was string. So it was going to give us the value of that current data. So it's just going to be an integer here. And then that was going to be added with the edge dot gateway. So that will also be an in so both of these ends added will result in this alternative value. So now it's proper. And if I run the code now you can see now that this created it for me. So here what I had was these vertices, 12345677 vertices, and these were the connections to them. I just called the Dykstra nothin past in the past graph, and put in the starting vertex. After that, I use the shortest path between method. And this is all showing up pretty cool. So now we're gonna test it out and see over here that the distance is, is updated. And it's according to what these vertices are. So these are, I believe, seven vertices, and over here we have the connections to them. So you can see a is connected C a is connected to b, a is connected to D, I want you to see over here is that the previous here we have a as no and the rest, when I said a is connected to B, D, and C, if you look at B, D, and C, they're all connected to a, so d is connected to a. So over here, you can see that this is the structure here, where we have all these vertices and their corresponding values. So these are all the values that have been have been updated. So the distance from A to itself is zero, the distance from A to D is minus 30 A the distance from A to F F to 3020. So we just pass it these values here, and then just allowed us to get the minimum distance from this graph to just telling if the distance from A to B is slope. So the minimum distance from A to B is three, the minimum distance from A to D is four and so on over here in the previous, we have a has a previous of No, but the rest vertices show their previous vertex as well. For the last method that we created, we want to call that shortest path between task graph. And we've got the starting vertex and the target vertex. Now we want the path shown, and also the shortest path. So what we can do is short paths, we pass an A and G. And this is going to call this method over here, which is going to call that method and it will return us some cool looking path here. So we'll clear the screen and then run it and then see the shortest path here we got the shortest distance from A to G, which is correct, we got a to g, and it was minus 38, the shortest path and it showed how it was working here, so A to D to eat to G. So if we map this out and draw this in a diagram, or if we look at it, everything will be correct according to these results. And that actually sums up our video
