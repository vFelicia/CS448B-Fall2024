With timestamps:

00:00 - welcome to this immersive course on
00:01 - springing Boot and spring data jpa two
00:05 - pivotal Technologies in modern Java
00:07 - development spring boot simplifies the
00:10 - process of building Standalone
00:12 - production grade spring-based
00:14 - applications with minimal effort while
00:16 - spring data jpa is a powerful tool for
00:19 - simplifying data access operations in
00:22 - Java applications seamlessly integrating
00:24 - with databases Bali Ali designed this
00:27 - course to provide a comprehensive
00:29 - understanding of of both
00:31 - Technologies welcome future spring boot
00:34 - masteress are you ready to embark on an
00:36 - Epic Journey Through the word of spring
00:39 - Boot and spring data jpa join me for an
00:43 - immens of 13-hour tutorial where we
00:46 - domestify the complexity and unlock the
00:49 - full potential of these gamechanging
00:52 - Frameworks why spring boot well in
00:55 - today's market it stands tall as one of
00:58 - the most s after Frameworks mastering it
01:02 - can truly be a GameChanger for your
01:05 - career consider this the demand for
01:08 - skilled spring boot developers is
01:10 - soaring and it shows no signs of slowing
01:13 - down top tier companies worldwide are
01:16 - actively seeking professional like you
01:19 - picture Landing that dream job or better
01:22 - yet forging your own path to success
01:25 - armed with spring boot expertise so how
01:29 - do you grab these opportunities it's
01:32 - just straightforward join me on this
01:34 - course now let's take a sneak peek Into
01:37 - The Incredible Journey that you're about
01:39 - to embark on so this course is composed
01:43 - of two main parts first of all spring
01:46 - boot where we will discover and unreal
01:49 - the secrets of spring core spring boot
01:52 - dependency injection spring profiles
01:54 - magic restful apis data persistence dto
01:59 - pattern robust service layer data
02:01 - validation techniques testing Paradigm
02:04 - mokito and much much more then embark on
02:09 - a journey into the heart of spring data
02:12 - jpa where you'll gain a comprehensive
02:16 - understanding of repositories
02:19 - relationships and the Art of playing
02:22 - with inheritance Del into the
02:24 - intricacies of embedded entities ID
02:27 - generation and master the art of
02:29 - querying data with named queries and
02:32 - specifications and of course much much
02:34 - more than that we will dive deep into
02:37 - the magic and learn the ins and outs of
02:40 - spring data jpa and raveling the secrets
02:44 - of repositories relationships and
02:46 - inheritance from embedded entities to
02:49 - Advanced querying with
02:51 - specifications we cover it all get ready
02:55 - to take your data persistence skills to
02:57 - the highest level before we dive in I
03:00 - would like to invite you to join me on
03:02 - my YouTube channel where I publish
03:05 - exciting and engaging content every week
03:09 - join me there and be part of the Great
03:12 - Community we are building right now you
03:15 - can find all the links in the
03:17 - description of this video as well as
03:19 - this is the ID of my YouTube channel
03:23 - finally a big shout out to free code
03:25 - camp for giving me the opportunity to
03:28 - share this awesome content with you guys
03:31 - and I'm really honored that my video
03:34 - will be here to help you improve your
03:36 - skills now with no further Ado let's get
03:43 - started what is spring
03:45 - framework the spring framework is an
03:48 - open-source framework for building
03:49 - Enterprise Java
03:51 - applications spring aims to simplify the
03:54 - complex and cumbersome Enterprise Java
03:57 - application development process by
03:59 - offering in a framework that includes
04:01 - Technologies such as aspect oriented
04:04 - programming dependency injection plain
04:06 - old Java objects and so and so forth
04:10 - even with all these Technologies spring
04:13 - is a lightweight framework that can be
04:15 - used to create scalable secure and
04:17 - robust Enterprise applications at a
04:20 - micro level we can consider this spring
04:23 - framework a collection of subf
04:24 - Frameworks such as spring web flow
04:27 - spring MVC spring orur and so and so
04:31 - forth core features of spring
04:35 - framework the ioc container or the
04:38 - inversion of control cont container ioc
04:42 - container is one of the core features of
04:44 - spring that provides a streamlined way
04:47 - to configure and manage Java objects
04:50 - this container is responsible for
04:53 - managing the life cycle of a defined
04:55 - Java object significantly increasing the
04:58 - configurability
05:00 - of a spring based application ioc use
05:03 - dependency injection or dependency
05:05 - Lookout patterns to provide the object
05:08 - reference during
05:09 - runtime aop aspect oriented programming
05:13 - aop aims to provide more modularity to
05:16 - the Cross cutting concerns which are
05:18 - functions that span across the
05:20 - application such as logging caching
05:24 - transaction management authentication
05:26 - and so and so
05:28 - forth and then data access framework so
05:31 - spring simplifies the database
05:33 - communication process by providing
05:35 - direct support for popular data access
05:37 - framework in Java such as jdbc hibernate
05:42 - Java persistence API also known as jpa
05:46 - additionally it offers features such as
05:48 - Resource Management exception handling
05:51 - and resource wrapping for all the
05:53 - supported data access Frameworks further
05:56 - simplifying the development
05:58 - process finally we have spring MVC so
06:02 - the spring MVC enables developers to
06:04 - create applications using the popular
06:07 - MVC pattern it is a request based
06:09 - framework that allows developers to
06:12 - easily create customized MVC
06:15 - implementations that exactly suits their
06:17 - needs the core components of the spring
06:19 - MVC is the dispatcher seret class which
06:23 - handles user requests and then forward
06:25 - them to the correct controller this
06:27 - allows the controller to Pro process the
06:29 - request create the model and then
06:32 - provide the information for the end user
06:34 - via a specified
06:37 - View Spring
06:39 - beans a spring Bean refers to an object
06:42 - that is managed by the spring framework
06:45 - in a Java application the term Bean is
06:48 - used in the context of the spring
06:52 - framework the spring framework creates
06:55 - these beans manage their life cycle and
06:57 - organizes their dependencies with other
07:00 - beans it takes care of the instantiation
07:03 - configuration and wiring up of objects
07:06 - saving developers from a lot of manual
07:10 - work also the spring beans can be
07:13 - configured using XML Java annotations or
07:17 - Java code life cycle of a spring Bean
07:20 - first let's understand the life cycle of
07:22 - an object so the life cycle of an object
07:26 - means when and how it is born how it
07:28 - behaves Liv throughout its life and when
07:31 - and how it dies similarly the bean life
07:34 - cycle refers to when and how the bean is
07:37 - instantiated what action it performs
07:40 - until it leaves and when and how it is
07:44 - destroyed so the bean life cycle is
07:47 - managed by the spring container when we
07:50 - run the program the first of all the
07:53 - spring container gets started after that
07:56 - the container creates the instance of a
07:58 - bean as for the request and then
08:01 - dependencies are injected and finally
08:04 - the bean is destroyed when the spring
08:06 - container is closed now let's see how we
08:09 - can configure a bean so first we can use
08:13 - the configuration annotation which
08:15 - declares a class as a full configuration
08:18 - class and here you need to note that a
08:21 - class must be nonf final and
08:24 - public also we can use The atban
08:28 - annotation which declares a bean
08:30 - configuration inside of a configuration
08:33 - class and the method must be non-final
08:37 - and non private so it can be public
08:40 - protected or package private and here is
08:43 - an example so we see we have the app
08:46 - config class annotated with the ad
08:48 - configuration annotation and inside it
08:51 - we have a payment service which has The
08:54 - atbin annotation so this will return a
08:58 - new payment service implementation and
09:00 - we can pass any other dependency for
09:03 - example in this case we have the account
09:05 - repository as a dependency for the
09:08 - payment service implementation B Also
09:12 - let's see a full example where we can
09:14 - declare multiple beans so again we have
09:17 - the app config class annotated with the
09:19 - ad configuration and inside that we have
09:21 - a payment service Bean we have account
09:24 - repository bean and a data source Bean
09:27 - so the data source will return the data
09:29 - source connection to our database for
09:31 - example or our data source and then we
09:34 - have in the middle the account
09:35 - repository which is also a bean that
09:38 - takes a parameter or as a parameter the
09:40 - data source Bean that we already created
09:43 - and finally from the top we have the
09:46 - bean payment service that takes the
09:48 - account repository as a dependency and
09:51 - spring will manage all that so spring
09:54 - will know that we need to create a data
09:56 - source first and then pass it to the
09:57 - account Repository and then we create
10:00 - the account repository bean and pass it
10:02 - as an injectable Bean to the payment
10:06 - Service Spring component sample so the
10:10 - spring component contains class level
10:12 - annotation that marks a class as a
10:15 - spring component using the add component
10:19 - annotation so the Constructor dependency
10:21 - injection is automatically done using
10:24 - the ad a word by injecting the
10:27 - Constructor parameters
10:30 - so the autowired on Constructor is
10:32 - optional if there is only one
10:36 - Constructor and here we see an example
10:39 - so we have our payment service
10:41 - implementation class which is marked as
10:43 - a component so this means that we want
10:46 - to mark this class as a spring bean and
10:49 - then we have a private final account
10:52 - repository which is refers to another
10:54 - spring bean and we have a Constructor
10:57 - payment service implementation with The
10:59 - annotation Auto and we have or we pass a
11:02 - parameter of type account repository and
11:05 - then we assign the local or the the
11:08 - class instance account repository we
11:10 - assign it to the account repository that
11:13 - we get as a parameter from The
11:14 - Constructor so in this way we are
11:17 - injecting via the Constructor the
11:20 - account repository bin into the variable
11:23 - or the local variable account
11:25 - repository spring components so spring
11:29 - provides component stereotype to
11:31 - classify classes as spring components
11:35 - the subtypes are available as a
11:37 - refinement for the standard components
11:41 - so the component annotation as general
11:43 - component annotation indicating that the
11:46 - class should be initialized configured
11:48 - and managed by the core container also
11:52 - at repository at service and at
11:54 - controller as meta annotation for the
11:57 - components that allows to further refine
12:01 - components own stereotype annotation can
12:05 - and should be defined to support General
12:07 - architecture principles now let's
12:10 - understand the bean naming so here
12:13 - assuming that we have this configuration
12:15 - class that contains the three beans that
12:18 - we explained already before payment
12:20 - service account repository and data
12:23 - source now we see that in the data
12:26 - source Bean we provided a name we call
12:29 - it the S so now let's see how spring is
12:32 - going to name these bein so first when
12:35 - we talk about the first Bean payment
12:38 - service which returns a payment service
12:41 - object so this will give it a name or a
12:44 - bean name payment Service as for the
12:46 - method name the same for the account
12:49 - repository if we don't provide a name
12:52 - for the Bean spring automatically will
12:54 - use the method name as a bean name so
12:57 - the bean of type type account repository
13:00 - will be named account repository finally
13:03 - for the data source when we provide the
13:05 - name so spring will take that one as a
13:08 - name for the Bean so the data source
13:10 - Bean name will be DS so Bean naming is
13:15 - really important in case we want to
13:17 - fetch or to get programmatically any
13:20 - bean from our application context so now
13:23 - we know how spring names the
13:26 - beans beans injection
13:29 - when we talk about beans injection we
13:32 - also mean dependency injection so the
13:34 - spring framework provides four ways to
13:37 - inject beans so the spring can configure
13:40 - dependencies on different injection
13:42 - elements first we have Constructor
13:45 - injection so the Constructor parameter
13:47 - to receive dependencies during Bean
13:50 - construction so the we call this also
13:52 - the Constructor injection then we have
13:55 - field injection and this field
13:57 - definition to receive dependency
13:59 - injected with the reflection axis also
14:03 - called field injection then we have
14:06 - configuration methods with one or many
14:08 - parameters receiving dependencies
14:10 - through method parameters also called
14:13 - method
14:15 - injection and finally we have Setter
14:18 - injection or Setter method injection so
14:20 - so the Java Setter method are
14:23 - specialized configuration method with
14:25 - only one parameter and a defined name
14:29 - scheme called also Setter injection so
14:32 - the injection Target can be referred
14:34 - using two different modes type injection
14:37 - injects an object of matching type or
14:40 - name injection injects any object by
14:43 - name Constructor
14:46 - injection so here let's first see the
14:49 - example of uh the case of a service so
14:52 - we have here a class uh called default
14:54 - payment service that contains uh a final
14:57 - account reposit itory and then we have
15:00 - the Constructor default payment service
15:03 - so in the default payment service
15:05 - Constructor we are declaring also an
15:07 - object or we passing a parameter of type
15:09 - account repository and like that spring
15:11 - will be automatically injecting this
15:14 - account repository being then we have
15:18 - for example in case we have a repository
15:20 - so we see that we have a jdbc account
15:23 - repository implements account repository
15:26 - so then we have a final or private final
15:30 - data source and then we have the
15:32 - Constructor gdbc account repository and
15:34 - we pass also a parameter which is the
15:37 - data source and then spring will
15:39 - automatically inject that using the
15:42 - Constructor also for injecting beans we
15:45 - can specify or we can tell spring which
15:48 - Bean to inject and for this one we can
15:51 - use the The annotation called qualifier
15:54 - and here let's see an example so here we
15:57 - have a class called application config
15:59 - annotated with a configuration and
16:01 - inside that we have two beans of the
16:04 - same type so two beans are of type
16:07 - account repository and we have a primary
16:09 - and a secondary so this means that we
16:11 - will create two beans the first one will
16:13 - be called primary and the second one
16:15 - will be called secondary but these two
16:18 - beans are referred by type which is the
16:21 - account repository so here we can give a
16:24 - qualifier for each Bean so the first one
16:27 - we will call it or we give it a
16:28 - qualifier primary and the second one we
16:31 - will give it a qualifier secondary and
16:34 - when we want to inject one of these
16:36 - beans we can also on the class level or
16:39 - for example the service level let's say
16:41 - we have the default payment service and
16:44 - we want to autowire or to inject a bean
16:46 - of type account uh repository and here
16:50 - we want to choose or we can choose which
16:52 - Bean to inject so we can use again the
16:55 - qualifier annotation on the ser service
16:58 - or the object level and as we can see in
17:01 - the default payment service Constructor
17:04 - we are telling spring that we want to
17:06 - inject the bean that has the name or the
17:10 - qualifier called primary so this is how
17:13 - we can use the qualifier annotation to
17:16 - inject the bean also if we want to to
17:21 - define a bean as primary we can use the
17:24 - primary annotation to Define which Bean
17:27 - should be primary or should be prior or
17:30 - prioritized for springing to be injected
17:33 - so in this case we don't we don't need
17:35 - the qualifier annotation so assuming
17:38 - again that we have the application
17:40 - config uh class uh configuration class
17:43 - and then we have the same two uh beans
17:46 - but now instead of giving a qualifier
17:48 - annotation we can choose which is the
17:51 - primary so for example we have the the
17:53 - account repository primary and then we
17:56 - give it the primary annotation and then
17:59 - when we want to inject a bean of type
18:02 - account repository all we need to do is
18:05 - just to inject it using the Constructor
18:07 - or the field and so on so forth and
18:09 - spring will know automatically that the
18:12 - account repository Bean which is called
18:14 - primary is prioritized Bean so it will
18:17 - inject that one unless we want to change
18:20 - for example we can give a qualifier and
18:23 - then when we use the qualifier so spring
18:25 - will use that one over the primary
18:29 - field injection so field injection
18:32 - allows direct injection into field
18:34 - declaration without Constructor or
18:36 - method delegation but here you need to
18:39 - note that this type of injection is
18:42 - discouraged because it makes testing of
18:44 - component in isolation more complex
18:47 - therefore should only be used in test
18:50 - classes and here is an example we have
18:53 - the default payment service which is a
18:55 - class annotated with ad service
18:57 - annotation and then we have a variable
19:00 - or a field of type account repository
19:03 - and then when using The autowired
19:05 - annotation this means that we want to
19:08 - inject this account repository using
19:11 - field injection method injection so the
19:15 - method injection allows setting one or
19:18 - many dependencies by one method so it
19:21 - also allows for initializing work if
19:24 - needed while receiving dependencies and
19:27 - here we see an example we have our
19:29 - default payment service annotated with a
19:31 - service annotation and then we have a
19:34 - method called configure class which is
19:36 - of type void void and then we have two
19:40 - variables or two feeds which is account
19:42 - repository and fee calculator for
19:44 - example and assuming these two um these
19:47 - two classes or these two objects are
19:49 - beans and then all we need to do is to
19:52 - set The autowire annotation on the
19:55 - method level and then spring will
19:57 - understand automatically Al that we need
19:59 - to inject these two beans so this is
20:02 - what we called method injection Setter
20:05 - injection so the setter injection
20:07 - follows Java bin naming convention to
20:09 - inject dependencies and here we see an
20:12 - example so assuming again that we have a
20:14 - class called default payment service
20:17 - annotated with the ad service annotation
20:20 - and then all we need to do is to declare
20:22 - our field and then use the setter method
20:26 - to inject this Bean so here we see that
20:28 - we have a public void set account
20:30 - repository and then it takes as a
20:32 - parameter account repository and then
20:34 - it's just a classic set method annotated
20:37 - with at Auto wir annotation so spring
20:40 - will understand that this is a Setter
20:43 - injection and it will inject the field
20:46 - using the setter method now let's see
20:49 - the official recommendation for
20:51 - Constructor based or Setter based
20:53 - dependency injection so I copied this
20:57 - from the spring Cod documentation and
20:59 - you can see the link down here so here
21:03 - since you can mix Constructor based and
21:05 - Setter based dependency injection it's
21:07 - good rule to them to use Constructor for
21:10 - mandatory dependencies and Setter for
21:13 - method or configuration method for
21:15 - optional dependencies and here like you
21:19 - can read it uh your on your own and then
21:22 - here the spring team generally Advocates
21:24 - Constructor injection so it's always
21:27 - recommended and it's always better to
21:29 - use Constructor injection to inject your
21:32 - beans into a class Bean scoping so first
21:36 - let's understand what is a beans scope
21:39 - so beans scope in Spring framework
21:41 - refers to the life cycle of a spring
21:43 - bean and its availability in the context
21:46 - of the application so when a bean is
21:48 - instantiated or looked up its Scopes
21:51 - determines its life cycle and which
21:54 - other beans can in can interact with it
21:58 - so the spring provides multiple Scopes
22:01 - to register and configure beans and
22:03 - scoping has an impact on State
22:06 - Management of the components also the
22:09 - default scope model is Singleton means
22:12 - one instance per application context
22:14 - shared instance will be accessed by
22:17 - other components therefore components
22:20 - must be thread safe so now let's see
22:24 - what are the bin Scopes provided by
22:26 - Spring so first of all we have the
22:30 - Singleton and as we mentioned it's the
22:32 - default so this is the default Bean
22:34 - scope in Spring container only one
22:37 - instance of The Bean Is created and all
22:39 - requests of that bean will receive the
22:42 - same instance this is useful for bean
22:45 - that do not do not hold state or where
22:48 - the same state is to be shared by all
22:51 - users or threads then the second one is
22:54 - prototype so this means a new instance
22:57 - is created each time a bean is requested
23:00 - from the container this is useful for
23:03 - beans to carry state that is specific to
23:06 - the uh to other user or thread and thus
23:09 - can't be shared the third type is
23:12 - request so this scope is only valid in
23:15 - the context of web over spring
23:17 - application context for a single HTTP
23:20 - request a new Bean is created for each
23:23 - HTTP request then we have session so the
23:27 - scope is also valid only on the context
23:30 - of webware spring application context of
23:33 - an HTTP session so it's it's different
23:36 - from the request so the HTTP request or
23:39 - the request scope is available for the
23:41 - HTTP request and the session is for HTTP
23:45 - session so this means a new Bean is
23:47 - created for each HTTP session by the
23:50 - container then we have application so
23:53 - this scope is also valid only in the
23:55 - context of webware spring application
23:58 - context for the life cycle of a serlet
24:00 - context so this ban is scoped at the
24:03 - application Level and finally we have
24:07 - web socket so this scope is valid only
24:10 - in the context of webware spring
24:12 - application context for the life cycle
24:14 - of a websocket The Bean Is scoped at the
24:17 - web socket level so Bean scoping is
24:20 - really important if you want to
24:22 - correctly manage your beIN and as I
24:25 - mentioned before by default the bin
24:27 - scope is
24:28 - Singleton now let's see how we can
24:31 - define a scope for specific mean so
24:34 - whether we can specify it by name so for
24:36 - example let's say we have B one
24:38 - annotated with a ban annotation and then
24:41 - we can give it the scope annotation and
24:43 - then we just provide the name of the
24:45 - scope also we can use The annotation to
24:49 - provide the scope annotation for example
24:51 - let's say session annotation so we have
24:53 - a specific annotation for that
24:55 - personally I recommend using The
24:58 - annotation to specify the scope just to
25:01 - avoid mistakes or to avoid
25:07 - typos now let's talk a little bit about
25:10 - some special spring beans so first of
25:13 - all we have the bean environment so the
25:17 - bean
25:18 - environment is an environment abstra
25:21 - abstraction so spring provides an
25:23 - environment AB abstraction to the couple
25:25 - application code from the environment
25:28 - with a support for bean definition
25:30 - profiles that allow different sets of
25:32 - beans depending on the environment for
25:34 - example we have local environment Dev
25:37 - environment Cloud prod and so on so
25:39 - forth also it helps resolving properties
25:42 - for external s sources for example
25:45 - database settings from the configuration
25:48 - file or reading cred credentials from uh
25:51 - CLI arguments and so and so forth
25:54 - environment can also be injected into
25:57 - the code if needed and now let's see an
26:00 - example so here we have the application
26:02 - config class annotated with ad
26:04 - configuration and then we can inject the
26:07 - environment Bean so all we need to do is
26:10 - to create or to declare a field of type
26:12 - environment and then autowired and as
26:15 - you can see we can get for example uh we
26:18 - have uh in this payment service method
26:21 - which is a bean we have a profile so we
26:23 - can read or create a profiles of type
26:26 - cloud and then we can say this.
26:29 - environment. accepts profile and we can
26:31 - pass the cloud profile as an environment
26:34 - and then for example we can also read
26:36 - some property so all we need to do is
26:38 - this. environment. getet property and
26:41 - then the property name so this is how we
26:44 - can use this predefined Bean then we
26:47 - have the bean
26:49 - profiles so a profile in Spring is a
26:52 - named logical grouping that may be
26:55 - activated programmatically or set as
26:57 - active through configuration so this
26:59 - feature is particularly useful when you
27:03 - have beans that should be active or
27:06 - registered and used in certain
27:08 - environments or conditions for instance
27:11 - you may have different configuration for
27:13 - development testing and production
27:15 - environment and you want to make sure
27:17 - that certain beans are only used in one
27:20 - of these
27:21 - environments this is how we can use this
27:24 - profile Bean or the profile annotation
27:27 - we can use it in three different ways
27:29 - first of all on a spring component so
27:32 - here we have the first one is the
27:34 - default payment service class and I want
27:37 - this service to be only available for
27:40 - the profile Cloud then we can use it on
27:43 - the configuration level so I want this
27:45 - configuration to be scanned and and
27:49 - applied by Spring only for the cloud
27:51 - profile also also we can declare the
27:55 - profile on the ban configuration so this
27:58 - means that a specific Bean is only
28:01 - available for the cloud profile also a
28:05 - bean can be active or activated
28:08 - programmatically for example let's see
28:11 - this code right here so first of all we
28:14 - create a variable of type annotation
28:16 - config application context so this is
28:19 - our application context so it it's
28:21 - equals new annotation config application
28:24 - context and then we have the application
28:28 - context and we have a method called get
28:30 - environment and then we can set the
28:32 - active profiles and then all we need to
28:34 - do is just to provide the profile name
28:38 - then we need for example if we have a
28:40 - different package to scan so we said
28:43 - also application context. scan and then
28:45 - we can provide the base package and then
28:48 - of course don't forget to refresh so
28:50 - spring will refresh its own context and
28:53 - then for example we can get the bean
28:56 - which is available for this Cloud
28:58 - profile so we can get for example the
29:00 - payment service equals application
29:02 - context. gbin and then we pass the
29:05 - service class so also we have another
29:09 - different way to define the active
29:12 - profile so using the properties file so
29:15 - for example we can use the yaml
29:17 - representation and it will be spring
29:20 - profiles active and then the profile
29:21 - name or using the application properties
29:25 - which is also spring. profiles. active
29:27 - equals
29:31 - Cloud so in Spring framework the value
29:34 - annotation is used at the field level or
29:37 - method or Constructor parameter level
29:39 - for expression driven dependency
29:42 - injection this annotation is commonly
29:44 - used for injecting values into variable
29:47 - in a class whether they are Primitives
29:49 - strings or complex types these values
29:53 - can come from properties files system
29:55 - properties or they can be hardcoded and
29:58 - here is an example how we can inject
30:01 - values using the value annotations so
30:04 - assuming that we have an application
30:06 - config class annotated with
30:08 - configuration and then we have for
30:10 - example we want to create a data source
30:13 - bean and for that we need the the URL
30:16 - the username and password of our
30:18 - database and assuming that these
30:20 - properties are stored in in a file
30:23 - called database. properties under our
30:27 - resource folder so first of all we need
30:30 - to inject or to tell spring from where
30:32 - we want to read these property sources
30:35 - and for that we use the property Source
30:37 - annotation and then we provide the class
30:40 - path so the class path will refer to the
30:43 - the resource folder and then we provide
30:45 - the file name so it's it's it's called
30:48 - database. properties for example and
30:51 - then if I want to inject the URL
30:54 - variable or the URL property which is
30:56 - called in my properties file jdbc URL I
31:00 - use The annotation at Value and then
31:03 - dollar and then curly brackets and
31:05 - between the curly brackets is the
31:07 - property name also the value annotation
31:11 - can also resolve Dynamic expression to
31:13 - access other beans or well-known beans
31:16 - like for example system properties so if
31:19 - I want to get a property from my system
31:22 - properties Bean all I need to do is to
31:24 - use the value annotation and then I use
31:26 - the D
31:27 - uh symbol and then between the curly
31:29 - brackets I can use the system properties
31:32 - and then I read the property called
31:35 - user. region for example to inject the
31:38 - default loc or to look up the default
31:40 - loc from the system properties let's see
31:43 - now some best practices for the spring
31:46 - framework so first of all split
31:49 - configuration so configuration class can
31:52 - be split into several classes first of
31:55 - all to avoid large configuration classes
31:58 - and also to allow splitting classes
32:00 - based on architecture or other drivers
32:03 - so the class can classes can import each
32:06 - other or application context can be
32:08 - constructed with multiple classes and
32:11 - here is an example so for example we
32:14 - have a first configuration class called
32:16 - server uh service config and this one it
32:19 - will configure a beIN of type payment
32:21 - service we have then repository config
32:24 - and this one it it will contain a bin of
32:27 - type account repository and then we have
32:30 - a class which is also a configuration
32:32 - class called app config and then for
32:35 - this app configuration we need the
32:37 - service config and the repository config
32:40 - and for that we can use the import
32:42 - annotation to import the two previous
32:46 - configuration classes so like that we
32:48 - are applying the best practices and we
32:51 - are splitting our configuration into
32:54 - multiple configuration classes and then
32:56 - we can import only what we need so like
32:59 - that we will have a more maintainable
33:01 - code spring initializer provides a
33:04 - simple web UI to configure the project
33:07 - to generate uh an endpoint that you can
33:11 - use via plane HTTP all you need to do is
33:14 - to go to start. spring. AO website and
33:17 - you will have this user interface so the
33:21 - service allows you to customize the
33:23 - project to generate the build system and
33:26 - using for example groovy Maven or or
33:29 - Gradle also you can choose the language
33:32 - whether you want to use Java cotlin or
33:34 - groovy and then you can choose the
33:37 - spring boot version that you want to use
33:40 - so here like at the time of recording
33:42 - this course the most recent version the
33:45 - stable one is
33:46 - 3.1.0 and then we have a set of metadata
33:50 - where we can provide and give the
33:52 - information about the group ID the
33:54 - artifact ID the application name and
33:57 - description and then the base package
33:59 - name then we provide the packaging
34:02 - whether we want to package our
34:03 - application as a jar file or War file
34:06 - and the recommended one is always to use
34:08 - jar file with spring Boot and finally we
34:11 - have the Java version that we want to
34:14 - use for example for spring 3 the minimum
34:16 - required version is Java 17 and if you
34:19 - want for example to use uh to use spring
34:21 - 2.7 something you can use Java 11 or
34:25 - Java 8 so the the project generated by
34:28 - the spring initializer contains a spring
34:30 - boot application and we will have a demo
34:33 - application. Java and then if you run
34:36 - the main method of this demo application
34:38 - you will see an empty spring boot
34:40 - application starting at local host and
34:42 - then the port 8080 which is we need for
34:46 - that case the web dependency at least to
34:48 - be able to run the spring boot
34:50 - application as a web
34:55 - environment spring boot is an approach
34:58 - to develop spring based applications
35:00 - with very less or no configuration it
35:03 - leverage existing spring boot projects
35:06 - as well as third party projects to
35:08 - develop production ready
35:10 - applications it provides a set of
35:13 - starters pal or Gradle buil file which
35:16 - can use to add required dependencies and
35:20 - facilitate Auto
35:22 - configuration also spring boot comes
35:24 - with a lot of Auto configuration so
35:27 - depending on the libraries on its class
35:29 - path spring boot is able to
35:32 - automatically configure the required
35:34 - classes now let's see why we need to use
35:37 - spring boot first of all it comes with
35:39 - Standalone applications and also it
35:42 - comes with embedded servers such as
35:45 - Tomcat or Jetty so there is no need
35:48 - anymore to deploy War files also it it
35:52 - provides opiated starters pal or Gradle
35:56 - depending on your project configuration
35:58 - to simplify the maven or the project
36:01 - configuration generally
36:03 - speaking spring boot automatically
36:06 - configure the spring framework whenever
36:10 - possible also it provides production
36:12 - ready features such as metrics health
36:15 - check and externalized
36:18 - configurations and finally there is no
36:21 - more requirements for XML configuration
36:24 - or any other type of configuration it
36:27 - only needs configuration whenever it's
36:30 - required first of all let's start with
36:33 - creating a new spring Bo project so as
36:35 - we explained before all we need to do is
36:37 - to go to the start. spring. website and
36:41 - you will have this nice looking UI where
36:44 - you can create a new spring boot project
36:46 - so first of all let's choose our uh
36:50 - dependency manager so in this case we'll
36:52 - be using Maven because personally I
36:54 - prefer Maven because I'm so familiar
36:56 - familar with the maven structure and
36:58 - also the XML structure then we have the
37:02 - language so we will be using Java as a
37:04 - programming language for our course and
37:07 - then let's choose or let's select a
37:09 - spring boot version so here as you can
37:12 - see at the time of recording this video
37:15 - the most recent stable version is the
37:17 - spring
37:18 - 3.1.0 but we will be using the 3.0
37:22 - something so make sure you use the
37:25 - version 3.0 because as for now like the
37:28 - spring 3.1 comes with with some
37:31 - deprecations and even for for the future
37:35 - I assume that companies they will not
37:37 - migrate yet to the spring version 3 even
37:40 - or even the spring
37:41 - 3.1.0 I will make a video explaining
37:45 - why you need to skipe the
37:48 - 3.1.0 all right so let's select the
37:51 - version here and then let's provide the
37:53 - metadata of our project so first first
37:56 - this is the group ID so the group ID
37:59 - refers to the company if we may say so
38:02 - for example let's take meta or like the
38:05 - old Facebook company now it's called
38:08 - meta so for example for the group ID it
38:11 - it will be com. meta so this is the
38:14 - company
38:15 - name and then the artifact refers to the
38:19 - project or to the sub company for
38:21 - example here let's say Facebook or
38:25 - Instagram
38:27 - or WhatsApp and so and so forth so here
38:30 - The com. Meta or like the group ID
38:33 - refers to the company and the artifact
38:35 - refers to the project itself so here I
38:38 - will say com do com. alibu let's use
38:42 - alibu as a group ID and here let's say
38:45 - example okay so here it will
38:48 - automatically use the artifact ID as the
38:51 - project name so let's also keep it
38:53 - example and here you can also provide a
38:56 - description for your project so here
38:58 - it's a demo project for spring boot
39:00 - application so this is also fine with us
39:03 - and also the package name is the
39:05 - concatenation of the group and artifact
39:07 - ID and of course you can update or you
39:10 - can modify the package name and this
39:13 - will be the base package of our
39:15 - application and then we have the
39:17 - packaging what is the the format or the
39:21 - package format of our final application
39:23 - whether we want to use jar files which
39:25 - is Java archive or War file which is War
39:29 - web archive and then we need to specify
39:32 - the Java version okay so the Java
39:35 - version right here if we use the spring
39:38 - 3.0 something or spring 3.1 the minimum
39:42 - required version of java is Java 17 all
39:46 - right so now after specifying this we
39:48 - can move on and add dependencies so as
39:51 - explained before spring boot comes with
39:54 - a set of starters and the starter is
39:56 - already a spring boot application which
39:59 - comes with a lot of
40:01 - autoconfiguration which will simplify
40:03 - our life of coding so here we need to
40:06 - click on ADD dependency and then we can
40:09 - filter or we can search for the
40:12 - dependency that we want to use for
40:14 - example if we want to create a web
40:17 - application or restful application we
40:19 - can filter or like we can search for web
40:22 - and here you will see that we have the
40:23 - spring web starter and as the
40:25 - description says build web including
40:28 - restful application using spring MVC use
40:31 - Apache Tomcat as the default embedded
40:34 - container so for now let's say that we
40:37 - want to use web so I will select this
40:39 - dependency and also we can click and add
40:42 - more dependencies so for example if you
40:45 - need jpa or if we if we want to
40:47 - implement a persistent layer on our
40:50 - application we can choose spring data
40:52 - jpa or for example if we want to use
40:54 - post degrees SQL we can also search for
40:57 - postgress SQL or for example even for my
41:00 - SQL and so and so forth okay so for now
41:03 - let's start with this simple dependency
41:06 - which is spring web and then we will we
41:09 - will see how we can even add manually a
41:12 - new dependency so here you can whether
41:15 - click on this explore button and here
41:18 - you will see the project structure or
41:20 - like the future project that will be
41:22 - generated and as you can see here we
41:24 - have the pom.xml selected
41:26 - and I will explain this in the coming
41:28 - video so now you can close this one and
41:32 - click on generate and this will download
41:35 - a zip file containing the project that
41:38 - we already created so now I will just
41:41 - place this one in my workspace so it
41:44 - will be
41:45 - here and then source code and I will
41:49 - just save it here so now I have my zip
41:52 - file downloaded now let's move on and
41:54 - open this file using anell now start
41:58 - your anell and then click on open so if
42:02 - you have already opened project you will
42:04 - see a button right here called open or
42:07 - all you can do is just go to file and
42:09 - then open all right so this will open a
42:12 - prompt right here and then navigate to
42:15 - the location of your source code and
42:18 - then select the pom.xml so here I have
42:21 - the example dotzip file which is which
42:23 - is I already unzipped and as as you can
42:26 - see here we have this list of files and
42:29 - this SRC folder so all you need to do is
42:32 - to select the pom.xml file and then
42:35 - click on open and then say open as a
42:39 - project and of course trust this one and
42:42 - then start so this will open a window
42:45 - like this containing the project
42:47 - structure that we see right here and as
42:50 - you can see we have this this structure
42:53 - right here so in the next video I will
42:55 - explain everything think but before that
42:57 - I want to show you something so before
43:00 - we start exploring our project and
43:03 - checking the project structure first of
43:05 - all I want to highlight something
43:07 - because so many of you have been
43:09 - requesting and asking the same question
43:11 - about the theme or the UI of my anti J
43:14 - so as you can see here for example if I
43:17 - select this file right here you'll see
43:20 - that it's really nice looking and we
43:22 - have all these icons and so and so forth
43:24 - so this is is part of the newest version
43:27 - of anj and you need to go and activate
43:31 - this UI so what you need to do go to anj
43:34 - and then settings or file settings for
43:37 - Windows
43:38 - users and then go to appearance and
43:41 - behavior and here you will see that you
43:43 - have a menu called new UI and it's in
43:46 - the beta version for now so here you can
43:48 - click on enable new UI and then you have
43:52 - this compact mode that you see in my
43:54 - screen right now so like like this you
43:56 - will have the same UI as me as me and
43:59 - this might be also helpful for you to
44:01 - have a better and a nice looking anj or
44:04 - Nic looking IDE and also it will be
44:07 - easier for you to follow what I'm doing
44:10 - right now so I'm going to click on
44:12 - cancel and now let's go back and and
44:15 - explore our
44:17 - project now before we move on let me
44:20 - show you few things that you might need
44:22 - to set up also your working environment
44:25 - and in order to use enj in a in a in a
44:28 - good way so first let's click on file
44:31 - and then select project
44:34 - structure and in here you will see in
44:36 - the project so here you see the SDK so
44:39 - here you will have a list of sdks that
44:42 - you can use within your project so if
44:44 - you don't have for example the Java 17
44:47 - all you need to do is to click for
44:49 - example no SDK or you can click on ADD
44:52 - SDK and then you can click on download
44:55 - jdk so so this will provide you a list
44:58 - of the the available jdks for example if
45:01 - you want for example let's say Java 19
45:04 - and then you can select the vendor or
45:06 - the provider so it's whether Amazon
45:08 - coretto and so on and so forth so you
45:10 - can select that one and here you can
45:12 - keep the location by default so anj will
45:16 - store it in its location like the
45:18 - location that anj will choose and then
45:20 - all you need to do is to click on
45:22 - download and then you will have it in
45:23 - the list right here so like this
45:26 - you won't be prompted or like blocked if
45:29 - you don't have already the SDK or the
45:32 - jdk installed all right so this is an
45:35 - important step for you before we start
45:38 - coding or before we start diving into
45:40 - our code so then click on apply once you
45:44 - download the SDK or or change the
45:46 - version just click on okay or apply and
45:49 - then you will have your SDK ready to
45:52 - use all right now we can start to check
45:56 - out our project structure so here when
45:59 - you create a new spring boot project you
46:01 - will find this IDE idea or uh yeah it's
46:04 - called idea folder which is uh
46:07 - automatically created by anj so we can
46:09 - just ignore that because it depends on
46:11 - your IDE you will have this folder right
46:14 - here and then we have this mvn folder
46:18 - that contains a wrapper and then we have
46:21 - this Maven wrapper. jar and Maven
46:23 - wrapper. properties so this means means
46:26 - that you really don't need to download
46:29 - manually and install manually Maven
46:31 - because when you create a new spring
46:33 - boot project with uh using the using
46:36 - Maven so it it will create or it will
46:39 - download automatically a maven wrapper.
46:41 - Jr file and you can use this one in your
46:44 - command line to run some commands and we
46:47 - will see that later on how we can use
46:49 - this Maven wrapper because for example
46:52 - for my machine I did not install Maven
46:54 - or my machine so I always use the maven
46:58 - wrapper provided by the spring boot
47:00 - project and I would say this is a good
47:02 - approach because like that you are not
47:04 - depending on a specific version which is
47:07 - installed on your machine but you depend
47:09 - on the version which is provided by the
47:12 - spring initializer so then we have this
47:16 - Source folder which contains two main
47:18 - subfolders we have this Main and we have
47:21 - the test so first of all let's check the
47:23 - main folder the main folder contains
47:26 - also two subfolders we have first of all
47:28 - this Java folder where we will have all
47:31 - the Java files of our applications all
47:34 - the classes and object of our
47:35 - application will go into this Java
47:38 - folder and then we have the resources
47:41 - folder so the resources folder contains
47:44 - two subfolders static and templates so
47:47 - the static is for example if we want to
47:49 - put some static files like HTML files or
47:52 - we want to build for example a UI for
47:55 - our rest API that we will be building so
47:58 - we can move or put all the files in here
48:00 - but I really don't recommend that
48:02 - because we need to think rest okay so we
48:05 - need to have a rest API and then if we
48:08 - need we can create a front end using any
48:11 - front end framework and then we have
48:14 - this application. properties files so by
48:17 - default it has the the file extension
48:20 - Properties or we can also use yaml
48:23 - representation so the difference between
48:25 - properties and yaml files is just the
48:28 - representation and the way we write
48:30 - things and the application properties
48:32 - will hold all the properties that are
48:35 - needed by Spring boot or even custom
48:38 - properties that we want to read from our
48:41 - application okay so now let's go back to
48:45 - this com. alibu example and as you
48:48 - remember this is the base package or the
48:51 - concatenation of the group ID and
48:53 - artifact ID so here we see that we have
48:56 - this example application which is a
48:59 - simple class with just a static void
49:01 - Main and it contains a spring boot
49:04 - application annotation so this will be
49:06 - the main class for our application so if
49:09 - you want to start the application all
49:11 - you need to do is to run this file by
49:14 - right clicking and then run example
49:16 - application or just clicking on here or
49:19 - also clicking on this button right here
49:22 - so you have multiple ways to run the
49:24 - application from your ID then we can
49:27 - move to the test F test folder so this
49:30 - test folder this is where we have all
49:33 - the test files that we will create so
49:35 - all the unit tests all the integration
49:37 - test all the end to end test that we
49:39 - want to create for our rest API they go
49:42 - to this test folder so next let's have a
49:46 - look on the pom.xml file so the pom.xml
49:50 - file looks exactly like this I'm going
49:52 - to make it full screen so if we start
49:55 - from the beginning so here is just
49:57 - providing or specifying the XML version
50:00 - and here like we we provide also the
50:03 - project and the XML name space which is
50:05 - Maven Apache org and so and so forth so
50:08 - this is some information that you need
50:10 - and also the schema location and so on
50:12 - so forth and also this is the model
50:14 - version of our project and then we see
50:17 - here that we have a parent tag so the
50:21 - parent tag contains also group ID
50:23 - artifact ID version and roll path so
50:26 - this parent means that this Maven
50:29 - project extends from this parent okay so
50:33 - this means that this spring boot
50:35 - application extends already the spring
50:37 - boot starter parent having the version
50:41 - 3.0.7 which we already specified and
50:43 - selected in our spring initializer and
50:46 - then we have the group ID that we
50:49 - specified which is com. alibu and the
50:51 - artifact which is example and then we
50:54 - have a default version which is
50:57 - 0.0.1 Das snapshot snapshot means it's
51:00 - still under uh under progress or like in
51:03 - progress and then we have the name which
51:06 - is we mentioned before it takes by
51:09 - default the artifact ID you can also
51:11 - change it and then we have the
51:13 - description all right and then it comes
51:15 - uh a tag called properties and here we
51:18 - can provide a set of properties for our
51:21 - application so here for example we have
51:23 - this java. version and you are
51:25 - specifying that you are using the Java
51:27 - version 17 after that comes the the most
51:30 - important part which is the dependencies
51:33 - so we see that we have a tag
51:35 - dependencies and this is a list of
51:38 - dependency so here we see that we have
51:40 - this dependency uh tag so also here we
51:44 - provide the group ID and the artifact ID
51:46 - so for example here it's or. springf
51:48 - framework. Boot and the artifact is the
51:51 - spring boot starter web which is the
51:53 - dependency that we added when we created
51:56 - our project and also by default when you
51:59 - create a new spring boot project you
52:01 - will have always provided dependency
52:04 - which is the spring boot starter test
52:06 - and the scope of this dependency is test
52:09 - so this dependency will be available
52:11 - only when we run the tests also there is
52:14 - something which is really important in
52:16 - here when we use spring boot so spring
52:19 - boot really makes it easy to manage
52:21 - versions so here we don't need to
52:24 - provide any version because here if we
52:27 - check we we have already a property
52:29 - called version and we can provide any
52:32 - version that we want but when we use
52:34 - spring boot we don't need to provide the
52:37 - version because it will automatically
52:39 - extend the parent version so this in
52:41 - case of an upgrade or a downgrade of the
52:44 - spring version you don't need really to
52:46 - worry about the spring boot starter
52:49 - starters dependencies all we need to do
52:51 - is to update this one refresh the
52:53 - project and then we will have our
52:56 - project totally and fully migrated to
52:58 - the newest to the new version that we
53:00 - provided all right so this is the
53:04 - application so now let's start our
53:07 - application and see and try to analyze a
53:09 - little bit what we have so first just
53:12 - click on this button right here or this
53:15 - play button right here and run example
53:17 - application or right click on this file
53:20 - and then run example application or
53:23 - select the file from here right right
53:25 - click and then run this application so
53:27 - it it's up to you to choose the way that
53:30 - suits you the best so here let's analyze
53:34 - a little bit what we have so here we see
53:37 - that we have this Banner right here and
53:40 - I will show you in a few seconds how we
53:41 - can also change that then we see that we
53:44 - have a bunch of logs so here we have a
53:47 - list of info logs and as we can see here
53:50 - starting application using Java 17 with
53:54 - process ID sign something and here also
53:56 - we see that we have no active profile
53:59 - set so then we later on we will see how
54:02 - we can work with profiles so here
54:04 - falling back to one default profile
54:06 - which is called default and even if you
54:08 - don't Prof provide this profile name it
54:11 - will be selected by default then we see
54:14 - Tomcat initialized with port 8080
54:16 - starting service and then we see that we
54:19 - have started example application in 0.5
54:24 - seconds and then the application or the
54:26 - Tomcat already started on the port 8080
54:29 - with a context path which is empty all
54:32 - right so now this is not the most
54:34 - important part first I want to show you
54:36 - how we can change this Banner right here
54:40 - and to make our service or our
54:42 - application looks really nicer first
54:45 - let's go to our
54:47 - browser and here this is uh a cool
54:50 - website that I really like or even you
54:52 - can just Google text Banner generator I
54:55 - will leave you this this link in the in
54:57 - the description of this video and then
55:01 - for example if you type something let's
55:03 - say alibu and then we can choose the
55:05 - font so here I will choose uh this one
55:09 - so I prefer this one this an regular or
55:12 - you can use Al also an regular with
55:14 - Shadow and you can use like you can play
55:17 - with it you can change the character
55:19 - width you can change the spacing and so
55:22 - and so forth okay so here for example if
55:25 - change it to full fitted you will see
55:27 - that it will change and it will be
55:29 - different from one one the
55:32 - other so once you generate a banner just
55:35 - click on select and copy so this will
55:38 - copy this text to the clipboard now
55:40 - let's go back to our application and
55:43 - also I will stop the application right
55:45 - now and reduce this and now in the
55:49 - resources so spring will automatically
55:52 - scan and look for a file called banner.
55:55 - txt so I will create a new file right
55:58 - here and I will call it
56:01 - banner. txt and I will just paste the
56:04 - content here okay so now if I restart my
56:08 - application we will see this Banner
56:10 - showing up instead of the old one so
56:13 - here maybe I will CH change a little bit
56:16 - so let's say spring boot
56:19 - 3.0.7 just something like that and here
56:23 - maybe let's say all right let's just
56:25 - adjust a little bit the spacings and now
56:28 - let's start our
56:30 - application so now instead of the Old
56:33 - Spring boot Banner we see that we have a
56:36 - new Banner which is alibu and we
56:38 - generally use the Banners To Give the
56:42 - the service name so when we start the
56:43 - application we know which service or
56:46 - what is the service that we are starting
56:48 - right here so as you can see we have
56:50 - this alibu and we have the alibu and
56:53 - then the Springwood version for example
56:55 - and so and so forth also we have the
56:57 - same logs as we had before and the
56:59 - application again started on the port
57:01 - 8080 bar which is the default one and we
57:04 - have also the application started the
57:07 - example application Java file in few
57:11 - seconds so let's create our first ban
57:14 - class so here in the the package com.
57:18 - al.ex example right click and then new
57:21 - and then Java class and let's call it my
57:24 - first class for example or my first
57:27 - component or my first service just you
57:29 - can call it whatever you want so in this
57:32 - my first class I will just create a
57:34 - public string it's a method that will
57:38 - just say
57:39 - hello so this method will return hello
57:43 - from the first class or from my first
57:46 - class for example just to know where the
57:49 - message is coming from so now in order
57:52 - to use this first class and call this
57:55 - method called say hello what we need to
57:58 - do for example let's go to our main
58:00 - method and here let's say first or my
58:04 - first
58:06 - class let's call it my first class
58:09 - equals new my first class so all we need
58:12 - to do is to create an instance and then
58:15 - I will use
58:17 - system.out.println just to print out the
58:21 - message so I will use my first class
58:24 - instance object and then I will call the
58:27 - method say hello so now if I run the
58:30 - application we will see that here we
58:33 - have the message hello from my first
58:36 - class but this is not really recommended
58:40 - when we use the spring framework because
58:43 - we are not using the power or the the
58:46 - the core feature of the spring framework
58:49 - which is dependency injection so to do
58:52 - that let me show you how we can and
58:54 - transform this my first class or this
58:57 - simple class to a spring Bean so now
59:01 - going back to our example application
59:04 - class file and here I will create a bean
59:08 - so this is a ban annotation and then I
59:12 - will do public my first class and I will
59:15 - call it for example my first class okay
59:19 - and then when I need a bean of type my
59:22 - first class I need to return a new
59:25 - instance or new my first class instance
59:28 - all right so I will just keep this line
59:30 - right here now let's see how we can if I
59:34 - remove this one so if I remove the
59:37 - instance or the manual creation of the
59:40 - my first class and delegate that to
59:43 - spring so spring will be able to inject
59:46 - and create a bean of type my first class
59:49 - okay so now first of all let's see what
59:53 - this run method is able to return so
59:56 - this run method method will return a a
59:59 - class or an object of type configurable
60:02 - application context so I will just
60:05 - assign this one to a variable and I will
60:08 - call it context so
60:10 - CTX just as a short
60:14 - name so when we run our application it
60:18 - will return a context which is the
60:20 - context of our application so here my
60:23 - first class now I want to get the my
60:26 - first class from the context or from the
60:29 - application context of my spring
60:32 - container so here I will just go equals
60:36 - and then
60:37 - context. get bean so I have a method
60:40 - called get bean so actually we have uh
60:44 - three or four uh four or five methods of
60:47 - type uh called get bean and the first
60:49 - one for example it takes a class then we
60:52 - can pass a name and the required types
60:54 - also also we can pass the required types
60:56 - and object or just a string or just a
60:59 - string name and object arguments and the
61:01 - arguments for example if I say or if for
61:05 - example I need a string for or to
61:07 - instantiate my class and so on and so
61:09 - forth so it's any parameter or any field
61:12 - required in order to create an instance
61:14 - of my object but in this case we can use
61:18 - whether the first one which is just
61:20 - passing the class or we can use the
61:23 - second one which is passing the name and
61:25 - the required type so it will transform
61:27 - it automatically or we can use also the
61:30 - get bean with a parameter string name
61:33 - but after that we need to cast the
61:35 - object to the required class so here
61:38 - since I already know the return type of
61:40 - the type of my bean I will use the first
61:43 - one and then it will be just my first
61:45 - class do class as a parameter all right
61:49 - so here as you can see I did not do
61:52 - anything or I did not create a manual
61:54 - instance for my first class object I
61:58 - just created a bean or transformed this
62:01 - class to a bean so it will be fully
62:04 - managed by the spring framework so now
62:06 - all I need to do is just to restart the
62:09 - application and see if it still Returns
62:12 - the same output or not so as we can see
62:14 - here we have always hello from my first
62:17 - class so now this is the first way or
62:20 - like this is how we can create a bean
62:23 - now let me show you a different way how
62:25 - we can also tell spring that this is a
62:28 - bean so now if I remove this Bean
62:32 - annotation or even if I comment out or
62:35 - totally remove this method right here
62:38 - and try to run the application let's see
62:40 - what will
62:43 - happen so first we have an exception and
62:47 - the exception is saying no such Bean
62:49 - definition exception so this means there
62:52 - is no qualifying Bean of type my first
62:55 - class available in the application
62:57 - context so we are not able to get or to
63:00 - look up a bean of type my first class so
63:04 - why because we just commented out this
63:08 - Bean annotation so when the application
63:10 - starts spring will not be able to find
63:13 - or to instantiate a bean of type my
63:16 - first class so we said or I mentioned
63:19 - before that I will show you a different
63:21 - way or a second way how to use or how to
63:25 - declare a bean in spring so now I will
63:28 - just stop the application for now and
63:31 - then to Mark a class as a spring Bean
63:35 - all I need to do is to add an annotation
63:37 - so this annotation I can use the
63:40 - component annotation that we already
63:43 - spoke about before so when I use
63:45 - components automatically spring will
63:48 - consider this class so when the
63:50 - application starts up and spring starts
63:53 - scanning all the packages and all the
63:55 - classes each time it will see this
63:57 - annotation it will consider the class as
64:01 - a spring Bean so now all I need to do is
64:04 - to restart my application so here if I
64:07 - restart my application we will see that
64:09 - we no longer have the exception and we
64:12 - see the hello from my first class all
64:14 - right so now let me also show you the
64:18 - other annotations that we can use we can
64:21 - use The annotation service and The
64:22 - annotation repositories which as which
64:25 - are uh uh refinement of the component
64:29 - annotation as we mentioned
64:33 - before so we using for example service
64:37 - and if I restart
64:39 - again so we see also that the message is
64:44 - showing up and the application starts
64:46 - with no issues and also if I go to the
64:48 - definition of this service and then
64:51 - click on download source to download the
64:53 - source code of of this class so we see
64:57 - right here the first thing this is like
64:59 - the public interface service and then
65:02 - this annotation or this interface class
65:05 - is already annotated with ad component
65:08 - so in in a different way the service
65:12 - annotation already extends the component
65:15 - so both of them are the same thing so
65:19 - here as also mentioned in the
65:20 - documentation you can also see component
65:23 - and repository so it's the same way if I
65:26 - use also a
65:29 - repository and I go to the documentation
65:32 - I will see also that it's a component
65:34 - all right so whether using service or a
65:37 - component or a repository these are a
65:39 - markdown annotations to mark an object
65:42 - or a class as a spring Bean so I will
65:46 - bring it back to service if I start
65:48 - again the application so I will have my
65:51 - bean and I will also be able to dis
65:54 - display the message that I already
65:56 - return in here in this say hello
66:02 - method as mentioned before splitting the
66:05 - configuration is one of the best
66:07 - practices so first let's start with a
66:09 - cleanup so I will remove this service
66:11 - annotation and I will optimize the
66:13 - import to to remove the unused one so
66:16 - also if I use a shortcut you can use a
66:19 - popup right here telling you what was
66:21 - the shortcut I used to do tou action so
66:25 - now I will go back to my example
66:27 - application right here and then I will
66:30 - open the project and I will create a new
66:34 - application config class so I will call
66:37 - it application config and then I will
66:40 - just take this Bean declaration and move
66:43 - it to the application
66:46 - config so now I will bring back this
66:49 - Bean
66:50 - annotation and of course import it and
66:53 - then don't for forget to add the
66:56 - configuration annotation to your class
66:58 - so spring will scan this class at the
67:01 - startup so now the
67:04 - application configuration is ready to
67:06 - use and again if I start my application
67:09 - I will see that everything is still
67:11 - working as expected so we see here that
67:14 - we have the hello from the first class
67:17 - so now I will also optimize the Imports
67:20 - right here so whether you move it
67:21 - manually or you use the shortcut Control
67:25 - Alt o for uh Linux and windows or option
67:29 - control o for Mac
67:32 - users now let's understand the bean
67:35 - naming in Spring application context so
67:39 - here as we mentioned before to get a
67:42 - bean we can use the class or the object
67:46 - class or we also can use another method
67:49 - which takes the the bin name and the
67:52 - required type so for example here to get
67:55 - this my first class and just to to
67:58 - remind you that in the application
68:00 - config we created a bean we gave it the
68:03 - name my first class so if I copy this
68:06 - name and I go back here and pass this
68:10 - the bin name as parameter and I run the
68:13 - application so spring will also
68:15 - understand that we are looking for this
68:18 - Bean so for example if I change this one
68:21 - to wrong Bean name and I restart the
68:24 - ation it will tell me that there is no
68:26 - such Bean okay so no such Bean
68:28 - definition exception and it says that
68:31 - that we don't have any Bean named wrong
68:34 - be name because by default spring will
68:37 - use the method name or the the method
68:40 - that we created here and we annotated as
68:42 - a bean as the bean name okay so now let
68:46 - me bring this back or let's see a
68:49 - different way how we can name a bean so
68:52 - here we have a bean
68:54 - and for example let's call it my
68:57 - bean and now spring when it scans and
69:00 - and declares this class as a bean it
69:03 - will automatically give this spring Bean
69:06 - or this string bean name as the B name
69:10 - so I will copy this one and now I will
69:12 - use it instead okay so if I rerun the
69:16 - application we see that the application
69:18 - is running and now we are using or we
69:21 - are showing the message coming from the
69:24 - say hello method of my first class Bean
69:27 - okay so now this is how the bean naming
69:31 - Works in springbot also if I go back
69:35 - again and just remove this parameter
69:37 - right here and for example I changed the
69:39 - name to my first my first Bean so I can
69:44 - use here my first Bean as a be name and
69:48 - I can just run the application and it
69:50 - will show the message that we already
69:52 - have in our say hello Method All right
69:56 - so now let's move on and see more things
69:59 - and more features about how to
70:01 - manipulate and work with spring beans
70:04 - now let's extend a little bit my first
70:07 - class Bean so here first I will create a
70:10 - private variable it will be a string and
70:14 - let's call it my VAR for example okay
70:17 - and now I will add a Constructor
70:20 - parameter so I'm just using shortcuts
70:23 - again so so you can see it in here so
70:25 - here I will select the option add
70:27 - Constructor parameter and then it will
70:30 - propose what will be the variable and
70:32 - say do refactor and as you can see here
70:35 - it will we have a Constructor having a
70:37 - string myar and then this myar equals
70:41 - VAR and just I will adjust the say hello
70:44 - so it will be hello from the first class
70:47 - and then let's for example display the
70:51 - myar so it will be myar
70:54 - equals and then just my VAR okay so now
70:58 - we see that we have already one problem
71:01 - so what we need to do we need to go back
71:03 - to the application config and pass this
71:05 - myar as a parameter so here let's say
71:09 - first been and now if I run the
71:11 - application the application will be
71:13 - running correctly and it will display
71:16 - here the variable or the the value of
71:19 - the myar that we passed to this my first
71:23 - ban Bean okay so it says hello from the
71:26 - from my first Bean class or my first
71:28 - class and my VAR equals first Bean now
71:32 - let's move on and dig more and explore
71:35 - more how we can work with beans to
71:38 - better understand dependency injection
71:41 - let's start by preparing the groundup
71:43 - for for it so first I will create a new
71:47 - class and I we call it my first service
71:50 - so my first service as a class and and
71:53 - this one I will mark it as a service and
71:57 - then for this my service I will just
72:00 - create uh a method so I will do
72:03 - public string and then say message or
72:08 - tell story for example so this tell a
72:11 - story it will just use one of the
72:14 - existing services or the existing beans
72:16 - that we have which is the my first class
72:19 - in here to just display the message or
72:22 - like to to make a call to the say hello
72:25 - Method All right so here I will just
72:28 - first need to inject a bean so so all I
72:33 - need to do is to create a private my
72:36 - first class and I will call it my first
72:39 - class so I will make this one full
72:41 - screen and then I will just return so
72:45 - the bean is saying or like let's say the
72:49 - dependency is saying and then I will
72:53 - just concatenate the my first class do
72:56 - say hello method okay so when I run this
73:00 - class and I run this tell a story I
73:03 - expect to have an output in my console
73:07 - telling that the dependency is saying
73:09 - and then we have the hello method or the
73:12 - say hello method that we have right here
73:15 - so now let's move on and understand in
73:17 - deep the dependency injection and the
73:20 - different types of dependency injection
73:23 - now if we go back to our example
73:25 - application class and here let's do some
73:28 - changes instead of my first class I will
73:31 - just try to inject my first service and
73:34 - I will just rename this one to my first
73:37 - service as a variable name and then I
73:41 - will tell spring to get bean I can also
73:43 - remove the name and instead of my first
73:46 - class I will just change it to my first
73:48 - service and here I will just call the
73:51 - tell story okay I will just rename this
73:54 - one so it's
73:57 - service and now if I run the application
73:59 - let's see what will
74:01 - happen so here we have a null pointer
74:05 - exception in the my first class. say
74:09 - hello okay so if I click to check the
74:12 - trace so the my first class is null okay
74:16 - so now I will rerun again in the buug
74:18 - mode so I will just add a breakpoint
74:21 - right here and I will make the later on
74:23 - a special video how we can debug in
74:26 - details so now just click on this debug
74:30 - example
74:33 - application and then when the example
74:36 - application here so first we start by
74:38 - running the application and then we look
74:41 - up or we try to load the my first
74:43 - service Bean which is already a service
74:47 - right here so that's why we are able to
74:49 - load the bean and then we try to call
74:52 - the my first service tell the story and
74:54 - this is when the break point hits okay
74:57 - so we are trying to concatenate this
75:00 - string with the string coming from the
75:03 - say hello method so as we can see here
75:05 - in inj we have already a n pointer
75:08 - exception because the my first class is
75:11 - null why it is null because it's not yet
75:14 - injected by spring because we did not
75:17 - tell spring how to inject this class
75:20 - okay so that's why we have our null
75:22 - pointer except so let's resume the
75:24 - program and now if I go back to the
75:26 - console we see again we have this n
75:28 - pointer exception so now let's see how
75:31 - we can inject a dependency using the
75:36 - Constructor so all I need to do here I
75:39 - will use the auto completion and uh or
75:41 - the code generation and I will ask anj
75:44 - to create a Constructor using this my
75:47 - first class so here I just asked it and
75:51 - now it also anj is is recommending to
75:54 - make my first class Final so we will
75:56 - also add this final keyword so now all I
75:59 - need to do is to add the keyword
76:02 - autowired and this annotation needs to
76:05 - be on the Constructor level so like that
76:08 - when I start the application spring we
76:10 - know that we need to fetch a bean of
76:13 - type my first class the one that we
76:16 - declared right here and it will be
76:18 - assigned to this my first class so since
76:22 - here in our application config we have a
76:24 - bean of type my first class spring will
76:27 - know that this is a bean and then the my
76:30 - first service needs this Bean to be
76:33 - injected so it will automatically
76:35 - injected so now let's just restart the
76:38 - application and now I will just restart
76:40 - it not with debug
76:43 - mode and here we have the magic so here
76:47 - the dependency is saying hello from my
76:49 - first class and my VAR equals first been
76:53 - as we specify it in our application
76:56 - configuration right here so now I guess
76:58 - you are able to link things so this is
77:01 - how Constructor injection works now let
77:03 - me show you a little bit of enhancement
77:06 - that was introduced by the spring
77:08 - framework so now if I go back to my
77:11 - first service I can also remove this
77:13 - breakpoint here with spring boot if we
77:17 - have or if we want to use Constructor
77:19 - injection we no longer need the autowire
77:23 - keyword I will also optimize the Imports
77:25 - so we no longer need the autowired
77:28 - keyword or annotation because spring it
77:30 - will try to inject all anything that is
77:34 - injectable so when the application
77:36 - starts and spring start creating this my
77:39 - first service Bean or uh or service it
77:43 - will first see that in the Constructor
77:45 - we need an object of type my first class
77:48 - okay so it will look up in its context
77:51 - if it finds a bean of type my first
77:54 - class if yes it will inject it so now
77:56 - after removing The annotation I will
77:59 - rerun again the application and make
78:01 - sure that everything is working fine so
78:04 - here as you can see we no longer need
78:07 - The autowired annotation so this is how
78:11 - Constructor injection
78:13 - works now I will go to my application
78:16 - config and create a second Bean of type
78:20 - my first class so I will duplicate this
78:22 - one
78:23 - and I will call it my second Bean so
78:27 - this my second bean I will pass a
78:29 - parameter I will call it second Bean
78:32 - okay so now I have two beans of type my
78:36 - first class now if I rerun the
78:38 - application and try to fetch or to
78:41 - display the message in here I expect
78:45 - things not to work and even ndj is able
78:48 - to highlight this so if I highlight this
78:51 - one it says could not Auto to wire there
78:53 - is more than one bean of my first class
78:56 - type and this is what will happen or
78:59 - what will be displayed in our console so
79:03 - I will run the
79:06 - application and here we see that we have
79:09 - application failed to start and it says
79:13 - parameter zero of Constructor my first
79:16 - service required a single Bean but two
79:19 - were found okay and here it give H it
79:22 - gives us more details so we have first
79:24 - my first Bean defined in my by Method so
79:28 - defined by Method my first Bean in class
79:30 - application config and we have the same
79:33 - for my second Bean so also it gives us
79:36 - some actions so consider marking one of
79:38 - the beans as primary or use qualifier so
79:42 - this is this introduces us to the
79:45 - qualifier topic so now what I will do I
79:49 - can just come here and add a qualified
79:52 - fire annotation and for example I will
79:55 - say Bean one I will copy this and here I
80:00 - will say Bean two so I have the first
80:02 - Bean called Bean one and the second Bean
80:05 - has a qualifier called Bean two so this
80:08 - qualifier doesn't mean that the bean
80:11 - will be called Bean one and bean two no
80:13 - the bean will stay my first bean and my
80:17 - second Bean of type my first class but
80:20 - as an extra information we will give it
80:22 - a qualifi fire called bin one and Bin 2
80:25 - now if I go back to my first service I
80:28 - can just come here and add a qualifier
80:33 - information to this Bean so for this
80:36 - Bean here I will just tell it to use the
80:38 - qualifier for example Bean one or Bean 2
80:42 - Okay so let's use Bean two because
80:44 - before we used the bean one and here
80:46 - let's just make sure that we have second
80:48 - Bean as a variable all right so now
80:52 - spring will be able to locate or to load
80:55 - or to inject the correct Bean using its
80:59 - qualifier okay so now if I run the
81:01 - application
81:04 - again so we see that we have the message
81:07 - and now the variable my VAR has a value
81:10 - second Bean which is this Bean right
81:13 - here okay so this is how we can use
81:16 - qualifier to inject a a specific Bean if
81:21 - we have m multiple beans of the same
81:24 - type so as this example right here we
81:26 - have two beans of type my first class so
81:29 - now we just give it a qualifier for the
81:31 - first Bean and the qualifier for the
81:33 - second one and then spring will be able
81:36 - to locate and decide which one to inject
81:40 - also when working with beans we can tell
81:43 - spring which one to inject first so
81:46 - instead of using qualifier so I'm going
81:48 - to remove this qualifier from here and
81:51 - then I will go back back to my
81:53 - application config and I will also
81:55 - remove these two qualifier annotations
81:59 - so for example let's say that I have a
82:02 - third bin right here so I just duplicate
82:05 - the code and I will say this is my third
82:08 - bin and then I want spring for example
82:13 - to inject this third bin so I will just
82:15 - change also the text here so all I need
82:18 - to do is to use the primary
82:21 - annotation so this primary annotation
82:24 - will give a higher priority to this Bean
82:28 - called my third Bean now if I go back to
82:30 - my first service we see that the
82:33 - Highlight from uh from anj is already
82:35 - gone because spring will know that there
82:38 - is a higher Bean of these three beans
82:41 - which are of the same type so when this
82:45 - service my first service needs a bean of
82:48 - type my first class it will look up all
82:51 - the beans and it will choose the this
82:52 - primary Bean as a higher priority bean
82:56 - and it will inject that one so now when
82:58 - I start the application I'm expecting to
83:01 - have this third Bean printed as an
83:05 - output so as we can see here we have
83:07 - this dependency is saying and the bar
83:09 - now is saying third bin so this comes
83:13 - from this primary annotation so like
83:16 - this we can define a priority or higher
83:19 - priority to our beans
83:24 - now let's see dependency injection using
83:27 - field injection so I will keep my
83:30 - configuration as it is I will keep my
83:32 - third Bean as a primary and I will go
83:35 - back to my service now I'm going to
83:38 - remove the Constructor so I don't need
83:40 - the Constructor because I will use field
83:43 - injection so to inject uh a dependency
83:47 - using the field all I need to do is to
83:49 - add the autowired keyword or the
83:52 - autowire annotation to the the property
83:54 - or to the bean that I want to inject
83:57 - also already you can see right here that
84:00 - it's already also highlighted and field
84:03 - injection is not recommended as I
84:05 - explained before it's always recommended
84:07 - to use Constructor injection or Setter
84:09 - injection over field injection so also
84:13 - the the spring Advocates they always
84:15 - recommend using Constructor injection so
84:18 - now if I start the application I will
84:20 - get the same output telling third bin so
84:24 - as we can see right here so now it's
84:26 - telling third bin also we can mix this
84:30 - in the field injection we can mix with
84:33 - with the qualifier so here I will just
84:37 - uh comment out the primary and now I
84:40 - will show you how to use qualifier even
84:43 - without having the
84:44 - qualifier um name or the qualifier
84:47 - annotation on the bean declaration so
84:49 - here we see that we have three beans and
84:51 - now I will use the qualifier keyword or
84:54 - the qualifier annotation and all I need
84:57 - to do is to provide the bean name so the
85:00 - qualifier will use or will try to look
85:02 - up the bean by its name or by its
85:05 - qualifier name if we provide it so for
85:07 - example if I want to use my second bean
85:10 - I will just copy the method name because
85:12 - as I mentioned before when we don't we
85:15 - don't provide a bean name it will take
85:17 - the method as a bin name so now I will
85:20 - go back to my first service and give it
85:22 - my second Bean as a qualifier so if I
85:25 - restart the application I'm expecting to
85:28 - see this second Bean so this is what we
85:31 - see already in here so the field
85:34 - injection also works with qualifiers and
85:37 - also qualifiers we don't need to provide
85:39 - them on the bean level all we need to do
85:42 - is to use whether the method name or the
85:44 - bean name if we provide it so for
85:47 - example if I give a name to this Bean so
85:50 - let's call it for example Bean
85:53 - one and then for I will copy this name
85:57 - and I use it as a qualifier and I
85:59 - restart the
86:02 - application so here we see that we have
86:05 - first Bean instead of Bean 2 because the
86:07 - qualifier will be also using the bean
86:10 - name the next type of dependency
86:13 - injection is Method injection so I will
86:17 - go back to my service right here and I
86:19 - will remove these two I will just do
86:22 - command X to keep them in my uh
86:25 - clipboard and I will create a public
86:28 - void method and I will call it init or
86:31 - inject beans for example inject beans or
86:35 - inject dependencies so this inject
86:38 - dependencies it will take as parameter
86:41 - my first class so here my first class
86:45 - and I will call it my first class and
86:48 - then all I need to do is this do my
86:50 - first class equals my first class so now
86:55 - all I need to do is to add The autowired
86:58 - annotation and here of course because we
87:01 - have three uh beans of type my first
87:04 - class so I need the qualifier keyword
87:07 - right here so I will just remove this
87:09 - one and for example let's say I want to
87:11 - use the qualifier bin one and now when I
87:14 - start the application this method will
87:17 - inject the needed or the required
87:19 - dependencies so let's start let's try it
87:21 - out
87:23 - so here as you can see we have the the
87:26 - message and here we have first been and
87:29 - for example if I switch to the second
87:31 - one and I use this qualifier with the my
87:34 - second bean bean and restart the
87:36 - application we will see that it will
87:38 - print out second bean and it will be the
87:41 - same if also I change the other one so
87:44 - here what happens is spring when each
87:47 - time it sees that we have this Auto
87:49 - annotation it will try to use that that
87:52 - one whether it's a a simple method a
87:55 - Setter or Constructor in order to inject
87:59 - uh the the necessary beans that are
88:01 - required for this
88:05 - class the final type of dependency
88:08 - injection is called the setter injection
88:11 - so all we need to do is to create a set
88:14 - method for uh for our dependency that we
88:18 - want to inject if we have multiple we
88:20 - need to create a Setter for each so here
88:23 - for example if I say set my first class
88:26 - and also I need to provide the auto
88:29 - method and of course here we need the
88:31 - qualifier because we have three beans of
88:34 - type my first class and like this it
88:36 - will be using the setter method to use
88:40 - or to inject this my first class Bean so
88:43 - now if I restart the application I will
88:45 - see that I have the correct output that
88:49 - I'm expecting also if I switch to B one
88:52 - for example it will print out first Bean
88:54 - instead of second Bean so this is what
88:57 - we see if we restart the application and
88:59 - here we have first Bean so this is the
89:02 - final one and this is called Setter
89:06 - injection also as I as I mentioned
89:08 - before always use Constructor injection
89:11 - because this is the best way and the
89:14 - recommended way by the spring Advocates
89:16 - to inject beans or dependencies into a
89:20 - class
89:23 - as explained before spring also provides
89:26 - some special beans so for example we
89:28 - have the environment Bean which is a
89:30 - bean that help us to read some
89:32 - environment properties some environment
89:35 - uh system and also access the
89:37 - application properties and read the
89:39 - properties from there even reading the
89:42 - command line arguments so let me show
89:44 - you how we can read the environment or
89:48 - the system properties using this
89:50 - environment Bean so first I will create
89:53 - a private environment and I will call it
89:56 - environment for that I need of course to
89:59 - create a set and a Setter and add the
90:02 - auto keyword so here I will add Auto so
90:06 - this to inject the environment Bean into
90:09 - my first first service class and then I
90:13 - will just create a method I will just
90:16 - duplicate this one and I will call it
90:18 - for example get Java version so I want
90:22 - to return the Java version used for this
90:26 - project okay so I will remove this one
90:29 - and then all I need to do is
90:31 - environment. getet property and then I
90:34 - know that in the system properties I
90:36 - have a property called java. verion and
90:40 - now all I need to do is to go to my
90:43 - example application when where where I
90:45 - have the main method and I will
90:47 - duplicate this one and here I will just
90:50 - get Java version so now if I run the
90:54 - application we will see that the
90:56 - application will print the Java version
90:59 - okay so here we see that the Java
91:01 - version that I'm using is
91:03 - 17.0.2 for example if I create another
91:07 - method let's call it get Os or get OS
91:11 - name so I want to return the operating
91:13 - system name so it will be
91:16 - os. name so this is the property to
91:19 - return the operating system name and
91:21 - then I will also just display it right
91:24 - here so I will use or call the method
91:26 - getos name and then I will restart the
91:28 - application and I'm expecting to see the
91:31 - operating system name which is for my
91:34 - case the Mac OS
91:37 - X the environment Bean is also capable
91:41 - of reading any property defined in our
91:43 - application properties file so for
91:46 - example here if I go to application
91:48 - properties and I will create a random
91:51 - property or or a custom property so it
91:53 - will be my custom. property and I will
91:57 - give it a value hello alibu students for
92:01 - example okay so now this environment
92:05 - Bean will allow me or can help me read
92:08 - the property from the yaml file okay so
92:12 - here all I need to do I will create um a
92:15 - new method so I will call it read
92:18 - property or read prop just to say uh
92:21 - property
92:22 - and here I will just copy this property
92:24 - name and I will paste it here instead
92:28 - okay so now I will go back to my example
92:31 - application. Java and I will applicate
92:34 - this one and I will just call the read
92:37 - prop method that I just created so here
92:41 - if I start the application let's see if
92:43 - spring is able to read it or not so it's
92:46 - the case so here we have hello alibu
92:48 - students so this means that this
92:50 - environment being we'll try to read the
92:53 - all the properties whether from the
92:55 - system or even if we provide an
92:58 - application or a property declared in
92:59 - our application properties so it will
93:02 - understand and scan also these
93:04 - application properties and like that we
93:06 - can read this custom property before we
93:09 - move on let's clean up a little bit what
93:11 - we created so here I will remove the
93:14 - environment since we already uh saw how
93:17 - it works so I will remove all this code
93:21 - and then I will just move this to the
93:23 - bottom or I will create or inject it in
93:26 - a Constructor so I will add the final
93:28 - keyword here and then I will say add
93:30 - Constructor parameter and here I will
93:33 - also provide the qualifier uh name so
93:37 - for my bean so it will be qualifier and
93:40 - then for example let's say Bean one so
93:44 - this is one of the beans that we have so
93:46 - this is my Constructor and I have now
93:48 - tell story so I will go back here I I
93:51 - will just remove all this so now I will
93:54 - go back also I guess we need to optimize
93:56 - import but yeah I guess we I already did
93:59 - it so now we have our code cleaned up
94:02 - and now we can move on and see what
94:05 - comes
94:07 - next now let's assume that we have
94:10 - another application. properties file
94:13 - where we are storing some custom
94:15 - properties for example I will create a
94:17 - new file right here and I will call it
94:20 - custom do
94:24 - properties so in this properties file I
94:28 - will create for example my prop okay
94:33 - equals alibu let's say okay just just an
94:36 - example now I want to inject this my
94:40 - prop into my first service so normally
94:43 - now you get it if you want to do that
94:46 - all I need to do is here so here I will
94:49 - here I will say my custom property y
94:52 - from another
94:55 - file and then I will use the value
94:58 - annotation and for the value an
95:01 - annotation I just need to use this my.
95:04 - propop as a property name okay so here
95:07 - I'll just paste this one and now let's
95:10 - create a getter method for this
95:14 - one and now let's go to our example
95:18 - application and try to read this one
95:21 - okay
95:23 - so from another file if I start the
95:27 - application so here we see that we have
95:30 - an exception saying that could not
95:33 - resolve placeholder my. propop okay so
95:37 - we are not able to resolve the property
95:40 - or the placeholder called myprop because
95:43 - it's not in our application. properties
95:47 - file because spring is able to scan only
95:50 - the only a file called application do
95:54 - Properties or yaml so now how to provide
95:57 - or how to tell spring that I want to
95:58 - read properties from a different file
96:01 - okay so all I need to do I go I need to
96:04 - go to the class level right here and
96:06 - here I need to use an annotation called
96:09 - property
96:11 - source so here we see that we have
96:13 - property source and property sources so
96:16 - I will use the first one and here I need
96:19 - to provide the class path so I'm going
96:22 - to make it full screen again so it's
96:24 - class path and then custom because we
96:27 - called we call the file custom do
96:31 - properties okay so now if I run the
96:34 - application let's see what will
96:37 - happen so we see right here that we have
96:40 - this message from the previous
96:42 - implementation and then we have hello
96:44 - alibu students because the hello alibu
96:46 - students is coming from the application
96:48 - properties and also we have this int
96:51 - which is is 1 to three and now spring is
96:54 - able to read the custom property from
96:57 - this customproperties file because here
97:01 - in this class we told spring also to
97:04 - load the properties coming from this
97:07 - file right here so if we provide a wrong
97:09 - file name of course we will get an
97:11 - exception so now let's duplicate this
97:14 - one so let's say
97:18 - custom file to for for
97:22 - example and here let's say my prop
97:26 - do2 and here let's say hello alibu okay
97:31 - so now I can inject multiple files so
97:35 - here instead of using property Source I
97:38 - need to use another annotation so it's
97:41 - just property sources and this property
97:44 - Source it takes a table of type property
97:47 - sources so here I will provide the the
97:51 - table so it will be a property Source
97:54 - this one and then the same again but
97:57 - here I will call it custom- file das2
98:01 - okay so here I will duplicate this one I
98:05 - will call it uh read property from
98:08 - another file to just an example and here
98:12 - I will just move the value and make prop
98:15 - do2 because this is the value or the
98:18 - property that we want to read and then
98:21 - all I need to do now just to test this
98:23 - one I will create a getter for this
98:25 - method so now if I go back to my main
98:30 - class and duplicate this one and use the
98:34 - two now if I restart the application
98:37 - let's see what will
98:38 - happen so here we have alibu coming from
98:42 - the customproperties and we have hello
98:45 - alibu coming from the custom file to so
98:49 - in this way we can inject multiple
98:51 - property sources and we can tell spring
98:54 - to use that one to load the properties
98:57 - that we
98:59 - need what we will see now is how we can
99:02 - inject a property from our application
99:06 - properties into our Java class so for
99:10 - example let's say here I have a private
99:13 - string custom property and I will just
99:17 - create a getter for this custom property
99:20 - okay so here create a getter for custom
99:24 - property and I will use this get custom
99:27 - property just to display this custom
99:29 - property in my main class so here I will
99:32 - just use get custom property if I run
99:35 - the application right now so by this
99:38 - custom property I want to read this one
99:40 - okay so what we see right here we have a
99:43 - null value because we did not tell
99:46 - spring how to read or that we want to
99:48 - read this custom property so I close
99:51 - this one now I will go back to here and
99:55 - then what we can do to in order to
99:58 - inject a value from our application.
100:01 - properties file into a variable whether
100:04 - it can be string or an integer or
100:06 - something like that so we can use the
100:08 - value annotation okay and the value
100:11 - annotation it takes as a parameter a
100:13 - string which is the value so the value
100:15 - should be in this in this way dollar and
100:18 - then curly brackets and inside the curly
100:21 - brackets so I can use my custom property
100:25 - so like this when the application starts
100:27 - up and spring starts initializing the
100:30 - beans and the the components anytime it
100:33 - sees that we have a value annotation it
100:36 - will try to read this property from the
100:39 - application. property or the
100:41 - application.yml file so now if I restart
100:44 - the application I'm expecting to see uh
100:47 - the message coming from here so it's
100:49 - hello alibu students for example let's
100:53 - go and let me show you that we can
100:55 - inject also other values so here I will
100:58 - just duplicate my custom
101:01 - properties my custom property and then I
101:04 - will say it's an INT and here for
101:06 - example let's say 1 2 3 okay so now if I
101:10 - go back here and I will just duplicate
101:14 - this one and I make it as an INT and
101:17 - here I will say it's an integer okay so
101:20 - I'm going to make this full screen and
101:22 - then I will also use the same uh value
101:26 - annotation and here instead of property
101:28 - I will say do int because this is what
101:31 - we created in here and
101:34 - now I will create a get method for this
101:38 - one so create getter for custom property
101:41 - int and here I have the get customer
101:44 - property int so here again I would just
101:47 - applicate this one and call this int so
101:51 - this is just to show you that spring is
101:53 - able to convert types so if I restart
101:57 - the
101:59 - application we see that we have alibu
102:02 - students and one to three and for
102:03 - example if I do one to three and with
102:06 - the string and reside the application
102:09 - let's see what spring will do so here we
102:12 - see that we have a number format
102:14 - exception so here spring was not able to
102:17 - cast this string to an INT okay okay so
102:21 - you need to be really careful with that
102:23 - so if you uh it depends on the property
102:26 - that you want to inject you need to have
102:28 - the correct or the exact exact
102:31 - type spring profiles provide a way to
102:35 - segregate parts of your application
102:37 - configuration and make it available only
102:39 - in certain environments they can be used
102:42 - to apply certain Bean definitions
102:44 - conditionally for example different
102:47 - beans might be registered in development
102:49 - environment versus is a production
102:51 - environment so each profile corresponds
102:54 - to a set of configuration that Define
102:57 - how the application should run in a
102:58 - specific environment so an environment
103:01 - might be a development test staging
103:04 - production or another similar concept
103:07 - the beans that are part of a profile can
103:09 - be registered in the spring application
103:11 - context only when the profile is active
103:15 - this capability can be particularly
103:17 - benefical in several scenarios for
103:20 - example in environment specific
103:22 - configuration you might have certain be
103:25 - that should only be active in
103:28 - development environment and different
103:30 - ones that should be active in a
103:31 - production environment for example in a
103:34 - development environment you might want
103:36 - to use a bean that clears and recreates
103:39 - your database with this data every time
103:42 - you start your application in a
103:43 - production environment you would
103:45 - certainly not want this Bean to be
103:47 - active also uh profiles can be used for
103:51 - component switching you can use profiles
103:54 - to switch out entire entire component or
103:57 - services for example you may have a
104:00 - quick in memory database for development
104:02 - while in production you would use a
104:04 - fullblown database server also profiles
104:08 - can be used for toggling features
104:11 - profiles can be used to enable or
104:13 - disable features if you're developing a
104:16 - new feature that's not quite ready to be
104:18 - deployed in production you can put this
104:21 - in its own profile until it's ready and
104:25 - in the next part we will see how we can
104:27 - work in action with profiles let's see
104:31 - now how we can work with profiles on the
104:34 - level of the application properties so
104:37 - for example here we have our
104:38 - application. properties containing two
104:41 - property my custom property and my
104:43 - custom property int so now in order to
104:46 - create a profile specific application
104:49 - property all we need to do is to create
104:52 - another file called
104:54 - application- profil name. properties so
104:57 - what I will be doing I will copy this
104:59 - one and then paste it so here let's say
105:02 - for example I will call it Dev so this
105:05 - application Dash Dev properties will be
105:08 - available or will hold all the
105:10 - information for the profile Dev so here
105:13 - in this application- dev. properties I
105:16 - will change a little bit the the values
105:20 - so here hello alibu students in Dev
105:24 - environment okay so here let's skip this
105:26 - one or like let's make it 3 to1 so in
105:29 - order to see the changes now let me show
105:32 - you how to run or how to set a specific
105:35 - environment while running the
105:37 - application from your IDE so here click
105:41 - on this uh Arrow just to have the list
105:44 - here and then click on edit
105:46 - configuration and then you see this is
105:49 - the configuration of your main class and
105:52 - then we see here that we have active
105:54 - profiles so here we can we can set
105:57 - multiple profiles to be active at the
105:59 - same time okay so now I want to set my
106:03 - profile or my active profile to Dev and
106:06 - then click okay so here spring when the
106:10 - application starts it will see that we
106:12 - have an application properties so first
106:15 - of all it will be loading all the
106:17 - information in the application
106:18 - properties and then it will set the
106:20 - active profiles to the dev okay and then
106:24 - what spring will be doing it will be
106:26 - overriding all the properties which are
106:29 - similar in the application Properties or
106:32 - and the application dev. properties so
106:35 - here let me explain it so at the
106:37 - application startup spring will load all
106:40 - these properties in its context and then
106:43 - it will see that it has an uh an active
106:46 - profile and it will check that this
106:49 - property already EX exists in here so it
106:51 - will override the value using this one
106:55 - okay so now let's go back to our main
106:57 - application and we know that we have
107:00 - already something to display this
107:03 - property so all I need to do is to
107:05 - Simply run the
107:07 - application and here we see that we have
107:10 - hello alibu students in Dev environment
107:13 - and also we have the value 3 to 1 so
107:16 - again if I stop the application and
107:18 - remove the active profile from this
107:21 - configuration right here click okay and
107:24 - then if I run again the application it
107:27 - will be displaying hello alibu students
107:29 - as you can see right
107:31 - here also we can change the profiles
107:35 - using the application properties itself
107:37 - so here in the main application.
107:40 - properties so also I want to highlight
107:42 - something it is always recommended to
107:45 - have an application. properties that
107:47 - holds all the common properties of your
107:50 - application and then you can change and
107:52 - override all the properties depending on
107:54 - the environment so here in the
107:57 - application. properties we can also tell
108:00 - spring which profile we want to be
108:02 - active so here all we need to do let's
108:05 - put it in the first line so here we have
108:08 - a property called spring. profiles.
108:11 - active and here this spring. profiles.
108:14 - active accepts a list of profiles with
108:18 - comma separation but in our case we want
108:20 - to set the dev environment as our active
108:24 - environment and that's all now if I run
108:27 - the application we will see that spring
108:29 - will or the our application will be
108:30 - displaying this message instead of this
108:34 - one so let's try it out so if I click on
108:37 - start the application and then we see
108:39 - that we are displaying this also let me
108:42 - show you how it's how it will be
108:44 - displayed in the
108:46 - logs so here we see that spring is
108:49 - detecting that that we have one profile
108:51 - active so it says the following one
108:54 - profile is active which is Dev for
108:56 - example if I said if I set another
109:00 - profile or let's say test for example
109:03 - and custom all right and if I restart
109:07 - the application even if we don't have
109:10 - these environments or these application
109:12 - properties specific for the environments
109:15 - it doesn't matter so spring will not
109:17 - block the application spring will not
109:19 - throw any exception if it doesn't find
109:22 - any properties for that environment
109:24 - because the environment is the developer
109:27 - responsibility so when you set an
109:29 - environment here or if you set an active
109:31 - environment make sure that you have the
109:34 - properties or like the necessary
109:36 - properties and configuration for that
109:38 - environment so here in the logs we see
109:41 - that the following three profiles are
109:43 - active Dev test and custom so here let
109:47 - me show you also something which is
109:49 - really important
109:50 - now I will just duplicate this Dev
109:53 - properties and I will make it test so
109:56 - since we already set an active profile
109:58 - test so here I will just save for the
110:02 - test in test environment so I just want
110:04 - to show you if the order matters or not
110:08 - so now all I need to do is to restart my
110:11 - application and here we want to focus on
110:14 - the output of this one okay so let's
110:17 - restart the
110:19 - application so here we see that test
110:22 - environment okay we are displaying the
110:24 - properties from the test environment and
110:27 - here here here how it works so let me
110:29 - show you in a different way so I will
110:32 - set test first and then Dev and then I
110:35 - will remove test from here and I will
110:37 - restart my application and let's see
110:40 - what will happen so here we see it's
110:42 - displaying in Dev environment so here
110:45 - spring first of all it will start
110:46 - loading the properties from the
110:48 - application. properties and then it will
110:51 - check the first profile and then it will
110:53 - override all the properties that can be
110:56 - overridden and then it will check the
110:58 - next one and again it will override the
111:01 - properties and so and so forth so you
111:03 - need to really be careful about the
111:05 - order for the
111:07 - profiles and also this information can
111:10 - be useful for you in case for example
111:12 - you set some active profiles and you see
111:15 - that a property is not correctly
111:18 - overwritten or is not correctly said so
111:20 - you may want to check the order of your
111:23 - properties the active profile can also
111:27 - be set programmatically so let's do this
111:29 - I will comment out this property so it
111:32 - will not override our configuration and
111:34 - I will close all this and then I will go
111:38 - back to my example application in our
111:40 - main method and here I will externalize
111:44 - a little bit so here I will create a
111:46 - variable app equals new applic new
111:49 - spring application
111:50 - and for this spring application I will
111:53 - just pass the example application. class
111:56 - which is our main class and then all I
112:00 - need to do here is switching up. run and
112:04 - we need to remove this so here after set
112:08 - or after getting the application or the
112:10 - spring application what we can do we can
112:13 - say up do set default properties and for
112:17 - this property we need to pass a map of
112:19 - type
112:20 - string and object so we can use
112:23 - collections do Singleton map and here we
112:26 - can pass the key and the value so the
112:29 - key is the property spring. profiles.
112:33 - active and the value is for example
112:37 - let's say Dev now if I run the
112:40 - application we will see that it will
112:43 - display alibu students in Dev
112:45 - environment and again if I switch it to
112:47 - test since we have also our application
112:50 - test. properties and then if I rerun
112:53 - again I will see student in in test
112:56 - environment so this is how we can
112:59 - programmatically set the active profile
113:02 - in our spring application next we will
113:04 - see how we can also have beans which are
113:08 - available only for a specific profile
113:12 - now let's see how we can make a Bean
113:14 - available only for specific environment
113:17 - so let's go back to our application
113:19 - config I'm going to make this one full
113:21 - screen and now in order for example to
113:24 - make this bin one available only for Dev
113:27 - environment and this being available for
113:30 - test environment all I need to do is to
113:33 - add an annotation called profile and in
113:36 - here all I need to do is to provide the
113:39 - profile name so let's say this one is uh
113:42 - sorry it's profile not primary and let's
113:46 - say this Bean my first Bean should be a
113:49 - available only for Dev environment and
113:53 - again I'm going to duplicate this one
113:55 - and make the second Bean available for
113:58 - the test environment okay so now if I go
114:01 - back to my first service and here I'm
114:04 - using my second bin so if I use for
114:08 - example this bin one in here so now I
114:12 - want to inject bin one in the my first
114:15 - service and then if I go back to the
114:18 - example application and try to run the
114:20 - application and here remember that we
114:22 - have our active profile which is Dev and
114:25 - again just to remind you before we start
114:28 - we are injecting the bean having the ID
114:30 - Bean one so it is this one which is
114:33 - available for the dev environment so now
114:36 - if I run the
114:39 - application we see that we have hello
114:42 - alipo students in Dev environment now if
114:45 - I switch to test environment I'm
114:48 - expecting the application not work
114:51 - because this Bean will not be registered
114:55 - for the test environment so spring will
114:57 - only register the Bean for the profile
115:01 - environment so now let's restart the
115:04 - application and let's see so here as I
115:06 - mentioned before we have an we have an
115:09 - issue so here it says that the injection
115:12 - Point has the following annotation we
115:14 - want to inject a bean qualifier but
115:17 - these following candidates were found so
115:19 - we have my second bean and my third Bean
115:22 - because in the application config we
115:25 - have my second Bean available for the
115:27 - test environment and also my third Bean
115:30 - available for all the environments but
115:33 - the bean one is no longer and is not
115:36 - registered for the test environment or
115:39 - sorry for the test profile which is the
115:41 - active one so we can say environment or
115:44 - profile it's also correct so in this way
115:48 - we understand that spring or if we set a
115:51 - bean or even a configuration available
115:54 - for specific profile it will not be
115:57 - registered for the other profiles so
116:00 - also let's try it out with a
116:02 - configuration in here so also we can set
116:05 - the profile annotation on the class
116:07 - level and here let's say these all these
116:10 - configuration should be available only
116:12 - for Dev so I can remove all the uh all
116:15 - the profile annotations from here and
116:18 - this means that I want to inject this
116:21 - profile or this application
116:23 - configuration only for the dev profile
116:25 - so here if I go back to example
116:28 - application I'm expecting again to have
116:31 - or to get the same issue but now we
116:33 - should not also see this one okay so
116:36 - let's try it out and see what will
116:39 - happen so here we see that again we have
116:42 - the same issue or like the same
116:44 - explanation that injection point this
116:47 - means that spring is looking for a bean
116:49 - with a qualifier Bean one but here it
116:51 - says that we did not find any other Bean
116:54 - of the same type okay so it's already
116:56 - mentioning consider defining a bean of
116:59 - type com. alibu my first class in your
117:02 - configuration so here if I go back again
117:05 - and change the active profile to Dev in
117:09 - here and rerun the application so the
117:11 - application will be up and running
117:14 - correctly so here you need to be careful
117:17 - how you how to define your profiles so
117:19 - now you understand that when you define
117:22 - a profile or you set the annotation
117:25 - profile on the class level this means
117:27 - that the whole class will not be
117:29 - registered if you set it on a method
117:31 - level this means that the specific
117:33 - method will not be registered when the
117:36 - application starts
117:45 - up rest stands for representational
117:48 - State transfer it's a software
117:50 - architecture style that defines a set of
117:53 - constraint to be used for creating web
117:56 - services these web services are often
117:58 - called restful apis or restful
118:01 - application programming interfaces if
118:04 - they adhere these constraints rest was
118:08 - first defined by Roy fien in his 2000
118:11 - doctoral dissertation the main idea
118:13 - behind rest is to treat networked
118:16 - resources as object that can be accessed
118:19 - us using standard HTTP methods such as
118:22 - get post put delete Etc and here are
118:26 - some of the fundamental elements of the
118:28 - rest
118:30 - architecture first client server
118:32 - architecture this principle establishes
118:35 - that the client and the server should
118:37 - act independently they can interact with
118:40 - each other but each side can be
118:42 - developed and updated independently
118:45 - stateless each HTTP request that happens
118:48 - from a client to a server should contain
118:51 - all the necessary information to
118:53 - understand and respond to the request in
118:56 - other words the server should not store
118:58 - any data between requests which keeps
119:02 - each request isolated and independent
119:05 - then cachable restful architecture
119:08 - allows client to cach responses
119:10 - responses must implicitly or explicitly
119:13 - Define themselves as cachable or not
119:15 - prevent clients from reusing outdated or
119:19 - appropriate data in response to further
119:21 - request then layered system the
119:24 - architecture allows for layers within
119:26 - the system architecture a client cannot
119:29 - ordinarily tell whether it is connected
119:32 - directly to to an end server or to an
119:35 - intermediary along the way which can
119:38 - include load balancing security measures
119:41 - and so and so forth then code on demand
119:44 - this this is the only optional
119:47 - constraint it allows the server to
119:49 - extend functionality of a client by
119:52 - transferring executable code and finally
119:55 - uniform interface this is a fundamental
119:58 - to the design of any restful system it
120:01 - simplifies and decouples the
120:03 - architecture which enables each part to
120:06 - evolve independently the four guiding
120:08 - principles of the uniform interface are
120:12 - first identification of resources then
120:16 - manipulation of resources through these
120:19 - representations and then
120:21 - self-descriptive messages and finally
120:24 - the hyper media as the engine of
120:26 - application state or also known as
120:29 - haos so restful API have become a very
120:33 - popular in modern web
120:36 - application development due to their
120:39 - Simplicity scalability State
120:41 - statelessness and compatibility with the
120:44 - web they are often used to create
120:47 - interactive applications mobile
120:49 - applications and web
120:50 - services however they are not suitable
120:53 - for all type of applications and other
120:56 - architectures or protocols such as
120:58 - graphql or grpc might be used to to
121:02 - depending on the specific needs of the
121:04 - application to resume the rest is the
121:08 - web architecture principles unique
121:11 - identification of resources or also
121:13 - known as URI different resources
121:16 - representation hyper Media Link or link
121:19 - of resources stateless communication and
121:23 - finally standard methods such as get
121:25 - post put delete and responses such as
121:28 - 200 404 and so and so forth when
121:32 - designing a restful API there are some
121:34 - standards that we need to follow first
121:37 - the resource should be always plural
121:40 - nouns in the API endpoint and if one
121:43 - instance resource should be retrieved
121:45 - pass the ID in the URL for example we
121:48 - can have have get/ accounts or if we
121:51 - want one single account it should be a
121:53 - get method SL accounts slash the ID or
121:57 - for example for deleting one single
121:59 - element it's delete SL accounts SL2
122:03 - which is or which represents the ID of
122:05 - the resource that we want to delete in
122:08 - case of nested
122:10 - resources which means resource under a
122:13 - resource the resources should be
122:15 - accessible as follows for example if we
122:18 - want to get the payment from the
122:21 - accounts it will be accounts SL1 which
122:23 - is the account id/ payment and then the
122:27 - payment
122:28 - ID so use the HTTP methods to specify
122:32 - what to do with this resource with the
122:35 - method get post put uh patch delete you
122:38 - can provide crude functionalities the
122:41 - crude stands for create read update and
122:44 - delete use HTTP methods also as known as
122:48 - verbs to specify what to do with this
122:50 - resource with the method get postp
122:53 - delete you can provide crude
122:56 - functionalities and here this is an
122:58 - explanation how we can design our
123:02 - resources for example here if we want to
123:05 - get the if we have slash accounts and
123:07 - this means when we have a get method
123:09 - with slash accounts this means that we
123:13 - want to get all the accounts post this
123:15 - means we want to create a new account
123:18 - put a bulk update all accounts this
123:21 - means we want to update all the accounts
123:24 - and delete this means we want to delete
123:25 - all the accounts now let's see when we
123:28 - have a single resource so when we have
123:31 - account slash the account ID then it's
123:34 - get account with ID one so for the post
123:37 - this should be an error because we
123:39 - should not allow that we post a resource
123:42 - with an with an ID then for the put this
123:46 - means that we want to update an account
123:48 - with ID one one and for the delete it's
123:50 - deleting an account with the ID
123:53 - one then for for the resource for
123:56 - example for the nested resources the SL
123:58 - account accounts SL1 SL payments this
124:01 - means when we have a get verb this means
124:04 - get all the payments for the account ID
124:06 - one post this means that you want to
124:09 - create a new payment for the account ID
124:12 - 1 and then for the boot this is a bulk
124:14 - update all payments for account ID one
124:18 - and the same for the delete this means
124:19 - that we want to delete all the payments
124:21 - with the account ID
124:23 - one when designing restful apis we need
124:27 - to use HTTP methods all also known as
124:31 - verbs so here we have the following
124:35 - verbs that we can use to design our
124:37 - restful API first we have the get method
124:40 - or the get verb this method is used to
124:43 - retrieve data from a server it is a
124:46 - readon operation meaning it does not not
124:49 - affect the state of the resource and
124:51 - then we have the post post this method
124:54 - is used to send data to the server to
124:56 - create a new resource the data is
124:58 - included in the body of the
125:01 - request then we have the put so this
125:04 - method is used to update an existing
125:06 - resource or create it if it does not
125:09 - exist the update or new data is included
125:12 - in the body of the
125:14 - request then we have delete so this
125:17 - method is used to delete a resource
125:19 - specified by a URL then we have patch
125:23 - patch this method is used to apply
125:26 - partial modification to a resource as
125:28 - opposed to the put method which is
125:30 - useful for full updates like post and
125:33 - put this data for the update is included
125:37 - in the body of the request then we have
125:40 - options so this method is used to return
125:43 - the HTTP methods that the server
125:46 - supports for the specified URL it can be
125:49 - used to check the functionality of a web
125:52 - server then and finally we have head so
125:56 - this method is similar to get but only
125:59 - Returns the header of the response not
126:01 - the actual data for example the body so
126:05 - this is useful when you want to check if
126:07 - a resource exists before trying to
126:09 - download it or check if it has been
126:12 - modified when implementing restful apis
126:16 - we cannot skip talking about status
126:19 - codes so the response status code R HTTP
126:22 - status codes are three-digit codes
126:25 - returned by the server as part of the
126:27 - HTTP response indicating the outcome of
126:30 - the request made by the client the first
126:33 - digit of the status code defines the
126:36 - class of response while the last two
126:38 - digit do not have any categorization
126:40 - role the there are five classes ranging
126:44 - from 1xx which is informational
126:47 - responses to 5X x x which is server
126:50 - error response so the first one is
126:52 - informational the second one which is
126:55 - 2xx means success the 3 XX means
126:59 - redirection and the 4xx means client
127:03 - error and then finally as mentioned
127:05 - before we have the 5xx which means that
127:08 - we have a server error now let's move on
127:11 - and check each one of them the first
127:13 - category is the success category which
127:16 - is represented by the code two
127:19 - 2xx so this 2xx has some some codes
127:24 - first of all we have for example the 200
127:26 - with which means okay so this is the
127:29 - standard response for the successful
127:31 - HTTP requests when you make a get
127:34 - request for example and the server
127:36 - successfully processes the request and
127:39 - provides the requested resources in the
127:41 - response it will return a 200 status
127:44 - code this status code simply means that
127:46 - everything went as planned and and the
127:49 - result data if any exists is included in
127:52 - the
127:53 - response then we have two one created so
127:57 - this 21 status code in indicates that
128:00 - the request was successful and a new
128:02 - resource was created as a result this is
128:05 - typically the response sent after a post
128:08 - request or something or sometimes put if
128:11 - you're creating a resource with that
128:13 - method where a new resource is created
128:15 - and the server based on the data set to
128:18 - the
128:19 - request then we have also a 2004 which
128:23 - means no content the 2004 status code
128:26 - means the server successfully processed
128:29 - the request and there is no additional
128:31 - content to send in the response payload
128:34 - body this is often the response to the
128:37 - delete request put or post request when
128:40 - there is no particular information to
128:43 - send back in the HTTP response body but
128:46 - header is useful in other words
128:48 - it's a way to for the server to say I
128:51 - did what you asked where and we're done
128:55 - so you don't need to go anywhere else
128:57 - this response may also be used when the
129:00 - server doesn't want to return any
129:02 - information like as a result of a delete
129:05 - request confirming the deletion is
129:10 - successful the redirection category also
129:13 - represented by the 3 XX response codes
129:16 - so the HTTP status code for this
129:19 - category will we will mainly focus on
129:22 - one which is the most important and the
129:24 - most used in in restful apis which is
129:28 - the 304 not modified so the HTTP status
129:31 - code 304 not modified is a special type
129:35 - of response that is used for caching
129:37 - purposes when a client sends a request
129:40 - to the server it can include a header
129:43 - such as if modified sense or if non
129:46 - match these headers are used to ask the
129:49 - server to validate if the client's
129:52 - cached version of the of the resource is
129:55 - still up to date if modified since uh
129:58 - use a timestamp to determine if the
130:01 - resource has been updated since the last
130:03 - time the client requested also we have
130:05 - the if non match it also works with e
130:08 - tags or entity tags which is a token
130:11 - associated with a specific version of
130:14 - the resource so if the resource has not
130:17 - been modified since the given date time
130:19 - in the case of for example if modified
130:22 - sense or the entity tag still matches so
130:26 - in this case if non match so the server
130:29 - will respond with a 30 or4 not modified
130:32 - status and not send the body for the
130:35 - response because the client cash is
130:38 - still valid by utilizing a 304 response
130:42 - you can save bandwidth and make your web
130:44 - application Faster by not unnecessary
130:47 - resending resources that the client has
130:49 - already cached so these leverages one of
130:53 - the main principles of HTTP which is the
130:56 - idea of being stateless but still
130:58 - allowing for optimizing through caching
131:01 - client error category are represented
131:03 - also with
131:05 - 4xx so here we will check the most used
131:09 - responses and first we will start with
131:11 - the 400 bad request this status code
131:14 - means the server was unable to
131:17 - understand the request due to invalid
131:19 - syntax this could be malformed request
131:22 - or a request with invalid arguments the
131:25 - client should modify the request before
131:27 - repeating it then we have a 401
131:30 - unauthorized so this status code means
131:33 - the request requires us user
131:36 - authentication if the user already
131:38 - included authentication credentials then
131:40 - the forward the for 4001 response
131:44 - indicates that the authorization has
131:46 - been refused for for these
131:49 - credentials this could be due to a wrong
131:52 - username password or the user does not
131:54 - have the necessary privileges this
131:57 - status is similar to to the 403
132:00 - Forbidden but specifically for cases
132:03 - where authentication is expected but has
132:05 - failed or not yet been
132:08 - provided then we have the 403 Forbidden
132:12 - so this status code means the client
132:14 - does not have the necessary permission
132:17 - for the request resource in contrast to
132:20 - the 401 unauthorized response
132:22 - authenticating will make no difference
132:25 - this status code can also be used when
132:27 - the server does not want to reveal
132:30 - exactly why the request has been refused
132:33 - or when no other responses is appliable
132:36 - so for all these status code are part of
132:39 - the 4xx class of HTTP status code which
132:43 - indicates that server was likely an
132:45 - error in the request sent by the client
132:48 - that prevented the server from
132:50 - processing it as a best practice the
132:53 - client should after its request or
132:56 - authenticate and authenticate
132:58 - appropriately based on these
133:01 - responses now let's see an example how a
133:04 - r API looks like when we implement it
133:07 - use using spring boot so here for
133:10 - example we have a payment rest
133:13 - controller and this is the class where
133:15 - we will expose the sources for a payment
133:19 - object for example and in order to make
133:22 - this class a controller or exposed as a
133:25 - rest resource we need to add The
133:27 - annotation rest controller and then as
133:30 - you can see here we have a method so
133:34 - this method will will return a response
133:36 - entity of type payment information so
133:39 - the payment information will be the
133:41 - response body of this method called
133:44 - initiate payments and here as you can
133:47 - see we have a post mapping which is the
133:49 - verb or the HTTP method that will be
133:51 - used to uh in to invoke this endpoint
133:56 - and then it has a value SL payment as
133:59 - explained before the way that we need to
134:02 - name
134:03 - our endpoints then we see that we have a
134:07 - body coming within this request and it's
134:10 - annotated with annotation request body
134:12 - and then we have our business code and
134:15 - then we want to return like the result
134:17 - location
134:18 - which is for example SL payment slid
134:21 - which is the ID that was returned after
134:24 - persisting or saving the payment into
134:26 - our database and then we return a
134:29 - response entity dot created so the dot
134:32 - created this F this method right here
134:35 - will return an H status code for the
134:39 - created representation which is the 2011
134:42 - and then the body we because we can also
134:44 - return a body within the within the RIS
134:47 - response of this method which is the
134:49 - confirmation that we created before also
134:53 - in addition to that we can specify the
134:56 - response code to this method and this is
134:59 - how it looks like so here we have a
135:02 - response status annotation that we can
135:04 - use so to specify the response stat
135:07 - status of a controller method annotate
135:10 - the method with the response status and
135:13 - then we can give it the status code that
135:15 - we want to return so spring only uses
135:19 - the response status when the marked
135:21 - method completes successfully without
135:23 - throwing any exception in the coming
135:26 - parts we will see in action all what we
135:29 - discussed
135:31 - before server error category so for this
135:35 - class we will see the 500 internal
135:39 - server error so this is a generic error
135:42 - message given when an unexpected
135:45 - condition was encountered by the server
135:47 - and no more specific message is
135:50 - suitable in other words it means that
135:53 - something has gone wrong on the server
135:55 - itself it doesn't provide a clear reason
135:58 - because thereor could be for a variety
136:00 - of reasons such as server
136:03 - misconfiguration or ancot exception on
136:05 - the server side code or a server
136:07 - resource issue like memory depletion
136:11 - then we have the 503 which is service
136:14 - and available this status code indicates
136:16 - that the server is currently unavailable
136:19 - to hand the request because it's
136:21 - temporarily overloading or down for for
136:24 - maintenance generally this is a
136:26 - temporary state it may include an
136:29 - optional retry after header indicating
136:32 - how long to wait before making a new
136:34 - request so both of these status codes
136:37 - are part of the 5xx class of HTTP status
136:41 - codes which indicates situations where
136:44 - the server is aware that it has
136:46 - encountered an error or or is otherwise
136:49 - incapable of Performing the request
136:51 - these types of error are often outside
136:54 - of the client's control and may require
136:57 - attention from the servers
136:59 - operators that's good you made it this
137:02 - far so now before we move we move on to
137:04 - the spring rest let's first clean up our
137:08 - code so what I will be doing is I will
137:11 - remove all the unnecessary classes and I
137:13 - will just leave this example application
137:16 - which is our main applic ation and
137:18 - afterwards we will start implementing
137:21 - our first rest API so what I will be
137:24 - doing I will remove this classes so just
137:27 - select them and then click on delete and
137:29 - then just click okay so you click delete
137:32 - anyway just also okay and then we will
137:36 - clean up the code that we have right
137:37 - here so I will just copy this one and
137:40 - make this Spring Run and then let's
137:43 - remove this and also let's remove all
137:47 - this code and then we need and then we
137:49 - need to pass the example. class as a
137:53 - parameter so now we have our application
137:55 - back as it was and now I will optimize
137:57 - the Imports and also I will remove these
138:01 - properties because we no longer need
138:03 - them we will see them afterwards if we
138:06 - want to work with profiles so now we
138:08 - have our application back as it was now
138:11 - just to make sure that everything is
138:13 - working fine just try to run the
138:15 - application and always we need to check
138:18 - is that the application is up and
138:20 - running as we can see here so the
138:22 - application started on the port 8080 and
138:25 - started example application in some time
138:28 - like it depends on your machine so now
138:31 - we are up and ready to continue with our
138:33 - rist API now let's create our first
138:37 - controller so here I would just right
138:39 - click here and then new and then Java
138:42 - class so here I will call it first
138:46 - controller and then this is the class
138:49 - that will represent our first controller
138:51 - so here in order to make the first
138:54 - controller as a controller that will be
138:57 - scanned by the spring boot all we need
138:59 - to do is to add the rest controller
139:02 - annotation and in order to have this
139:05 - rest controller annotation just make
139:07 - sure that you have the spring boot
139:10 - starter web dependency in your pom.xml
139:14 - or Gradle do properties
139:19 - so now let me first make this one full
139:21 - screen in order to create an endpoint
139:25 - first we need to Define what is the verb
139:27 - or the HTTP method for this point for
139:30 - this end point so let's assume that we
139:32 - want to perform a get method so here we
139:35 - have an annotation called get mapping if
139:38 - we use this get mapping annotation so
139:41 - this means that inside this rest
139:43 - controller we have a get mapping or a
139:46 - get method method so here let's say for
139:49 - example a public string this method will
139:52 - return string and let's say or let's
139:55 - call it say
139:57 - hello and then all I need to do is to
140:01 - return hello from my first controller
140:04 - for example and then of course don't
140:08 - forget to give the your endpoint a path
140:12 - okay so here we can even work without a
140:16 - path so let's
140:17 - let's try it like that and then let's
140:20 - see how we can enhance this so I will
140:22 - run my
140:23 - application so here we also see that the
140:26 - application is up and running now I will
140:29 - go to the browser and as you saw in the
140:32 - logs the application started on the port
140:35 - 880 so to access any get end points
140:38 - using the browser all we need to do is
140:40 - to access the local host and then the
140:42 - port number which is 8080 in our case
140:45 - and then just hit enter so here we have
140:48 - a 404 because we don't have any end
140:52 - point defined on this URL so if I add
140:55 - the slash right here it's also the same
140:57 - so that's why we need to define a
140:59 - mapping for our endpoint so let's go
141:02 - back to our
141:03 - anj and here in this get mapping so I
141:07 - will add slash hello for example okay so
141:11 - this is not respecting the the naming
141:13 - conventions of course but we will see
141:15 - that in details later on so now I will
141:18 - restart my
141:21 - application again the application is up
141:23 - and running on the port 8080 with a
141:25 - context path empty I will explain to you
141:28 - what is this context path later on so
141:30 - now let's go back to the
141:32 - browser and all we need to do is to
141:34 - refresh and here of course we need the
141:37 - slash hello so when I hit or when I try
141:41 - to reach the/ hello endpoint spring will
141:45 - go and we'll know that we have an end
141:47 - point Point called /hello available
141:49 - after or under the default context path
141:52 - that we have and this is the message
141:55 - that we provided with within our
141:58 - endpoint so let's go back to anti J
142:00 - again so here if for example I duplicate
142:04 - this one and I create another endpoint
142:07 - so let's say
142:08 - hello-2 and here let's say for example
142:11 - hello to and here say hello to from my
142:16 - first controller and then if I add a
142:19 - response status we will see the
142:20 - difference but before adding the
142:22 - response status let's go to the browser
142:25 - again and inspect a little bit more and
142:28 - see what happens so here if you click on
142:31 - F12 or right click and then inspect so
142:35 - you will have you will have uh this
142:38 - interface and then you can go to network
142:41 - now if I refresh we see and then you
142:44 - need to click on all we see that we have
142:47 - this endpoint hello and here this one
142:50 - let me make it let me Zoom it in so here
142:53 - we see that we have a banch of
142:55 - information so we have the request URL
142:58 - here it's it it goes to the Local Host
143:00 - 8/ hello and the method is a get because
143:05 - we in in our endpoint we defined it as a
143:08 - get mapping and then we have a status qu
143:11 - 200 and also we have the remote address
143:13 - and the bench of other information we
143:16 - also have some response headers which
143:18 - are the default response headers even if
143:21 - we don't specify them also we have a
143:23 - request headers which are included by
143:25 - the browser itself okay so now let's go
143:30 - back to anj and here for example if I do
143:34 - response status and here this response
143:37 - status let me show you how like the
143:39 - implementation or the code of this one
143:42 - what we can pass as a parameter which is
143:44 - the value right here it's an object of
143:46 - type type HTTP status so this HTTP
143:50 - status class it's aam actually contains
143:54 - a bench of methods okay or variables so
143:58 - for example continue is 100 and here for
144:01 - example let's go back and here for
144:04 - example if I search for the 200 2001 you
144:08 - will see that the 2001 is created okay
144:11 - or okay is 200 so the default one is 200
144:15 - if everything goes fine so now let's
144:17 - play a little bit with with this so
144:20 - let's say that I want to use accepted as
144:23 - a response status for my second endpoint
144:26 - so here all I need to do is to provide
144:29 - an HTTP status. accepted so it will
144:33 - automatically go to this one and return
144:36 - to O2 okay so now let's resp let's
144:39 - restart the application and see the
144:42 - changes so again in the browser if I
144:45 - access the hello -2 and point we see
144:49 - here that we have a status 202 which is
144:52 - the one that we specified before so here
144:55 - it's a get method again and we have a
144:57 - 202 as our status code which is the one
145:00 - that we already specified as an
145:02 - annotation in here so like this we can
145:05 - specify a response status for each
145:08 - method or we can leave it to the default
145:10 - one which is 200 but it's always
145:13 - recommended to specify the Response Code
145:15 - or the response St status as the verb or
145:19 - as the method or as the requirement of
145:21 - our
145:22 - application okay that's good so now you
145:25 - understand how we can create an endpoint
145:28 - and also how we can specify the response
145:31 - status so now I will just clean up this
145:33 - one also I will optimize the Imports and
145:36 - let's create our first post mapping
145:39 - endpoint so for the Post mapping it's
145:42 - always the verb and then mapping so the
145:44 - annotations with spring boot are always
145:47 - like verb and then mapping so post
145:49 - mapping get mapping put mapping and so
145:51 - and so forth so here let's say post
145:54 - mapping and let's give it for example SL
145:57 - poost and then I will just perform a
146:00 - public string post for example and here
146:05 - I will just return request accepted for
146:09 - example or saved or like you can say
146:12 - whatever you want so here for this post
146:15 - mapping we need and as we mentioned
146:18 - before when we perform a post mapping
146:20 - this means that we want to post some
146:22 - data or to send some data from the
146:24 - client to the server so the client in
146:26 - this case is our browser or any other
146:29 - tool that we want to use to perform rest
146:32 - requests so here we need to provide a
146:35 - body for example so the body in here I
146:39 - want for example let's say string and
146:41 - let's say message okay so here I I will
146:45 - just update this a little little bit
146:47 - request accepted and message is and then
146:52 - just message we will just display the
146:55 - message that we get as a parameter okay
146:57 - so now if I if I start my application
147:00 - and I go to the browser and try to hit
147:02 - this post and Point Let's see what will
147:04 - happen so again let's check the server
147:07 - is up and running now if I go back to my
147:10 - browser let me reduce this one and let's
147:13 - try to access SL poost and hit enter so
147:17 - here we see that we have an error
147:20 - message so this application has no
147:23 - explicit uh mapping for error and so on
147:25 - so forth and here we see that we have
147:28 - this post 40 405 and this is because the
147:33 - browser does not support post requests
147:36 - so it does not support post request this
147:39 - means that the browser address bar right
147:42 - here typically sends get request when
147:45 - you enter your URL and press enter so
147:48 - this part of the design and
147:50 - specification of web browser a get
147:52 - request is meant to retrieve a resource
147:55 - which is exactly what you're doing when
147:57 - you enter a URL you're asking to to
148:00 - retrieve and view the web page so the
148:03 - post request on the other hand are
148:05 - designed to send data to server to
148:08 - create or update a resource so post data
148:10 - is sent in the body of the HTTP request
148:14 - not in the URL this is the part of the
148:17 - HTTP specification so now since we are
148:20 - not able to use the browser address bar
148:23 - to send post requests let's see what is
148:26 - the alternative for
148:28 - that now let's see what is the
148:32 - alternative for using or as a HTTP
148:35 - client to send request to our backand
148:38 - server so for this if you are already
148:41 - familiar with Postman you can skip this
148:44 - video and move on to the next part but
148:47 - before that let's first see or let's see
148:50 - or Define what is Postman so Postman is
148:53 - a popular API client that helps
148:55 - developer for build test and debug HTTP
148:59 - requests it's used for API development
149:02 - and testing and it simplifies each step
149:05 - for the API life cycle including design
149:08 - mocking testing documentation and
149:10 - monitoring so first let's see how we can
149:13 - install
149:14 - Postman so it's so simple just go to the
149:18 - browser go to Google and then just
149:20 - search for download Postman you will
149:22 - find the first link which is posting or
149:25 - like which is referring to the Post
149:27 - man.com website and then click on
149:29 - download Postman and get started for
149:32 - free so here as you can see we have or
149:35 - like we can download the app and this is
149:37 - how Postman looks like so also you can
149:39 - change the the theme you can make dark
149:42 - theme or light theme and here depending
149:44 - on your uh on your operating system you
149:47 - will see the download button right here
149:50 - so here for example for my case I have
149:52 - an apple chip or if you have an Intel
149:54 - one or if you have Windows or Linux and
149:56 - so on so forth you can just click and
149:59 - download Postman and then install it so
150:01 - the installation is quite easy and
150:04 - straightforward so now let's go back to
150:06 - postman and start exploring Postman and
150:10 - its different features so this this is
150:13 - how the post manual looks like so first
150:15 - let's start by defining the theme so how
150:18 - you can manage and how you can Define
150:20 - the theme so here you see this Cog right
150:23 - here then click on settings and then you
150:26 - have themes so for the theme you for the
150:28 - theme you can whether choose the system
150:30 - default so it will be depending on the
150:33 - system uh layout and and look and feel
150:36 - also you can make it uh a light version
150:39 - or also you can use the dark one which
150:41 - is the developers preferred theme so I
150:44 - will keep it dark for the sake of this
150:46 - course
150:47 - then what we can see in here we have
150:50 - this plus button this is when and where
150:52 - we can perform HTTP calls to any backend
150:57 - so here what we see we have the URL or
151:00 - we have the URL that we can that we want
151:02 - or the URL of the endpoint that we want
151:04 - to invoke and here we have the list of
151:07 - the supported HTTP operations and as we
151:10 - can see here here we have get post put
151:13 - patch delete head and options so these
151:16 - are the HTTP methods that we already
151:19 - explained and spoke about before and
151:21 - here all we need to do is to perform or
151:23 - like or to paste or type the URL of our
151:27 - API so here we also see that the the
151:30 - history of my uh previous uh URLs that I
151:34 - used in here and so for example if I use
151:37 - one of these and since our API is also
151:40 - available on the Local Host 880 and if I
151:43 - try to reach the hello end point and
151:46 - click on send so we see here that we
151:49 - have the response that we also saw on
151:51 - the browser so also here this is a get
151:54 - mapping and here let's explore what we
151:58 - have in here okay so for depending on
152:01 - the depending on the method or the verb
152:04 - that we want to do we we have a list of
152:08 - uh few things here that we can do for
152:10 - example here we can pass request params
152:14 - and here for example if I have for
152:16 - example I want to pass a parameter as
152:19 - like first name equals Ali for example
152:22 - you see here that it's immediately
152:25 - changing and like doing a binding
152:28 - between this request param or query
152:31 - param and the one right here so for
152:33 - example if I add a second one last name
152:37 - you see that it's also changing in the
152:39 - in the URL or in the in the uh URL
152:42 - address bar right here so here for
152:43 - example if I say bu Ali
152:46 - as a last name you see that it's also
152:49 - reflecting in here so here where where
152:51 - we can pass query params then we have
152:55 - the authorization tab so here if we have
152:58 - a secure back end or secure API here
153:01 - where we can specify the type of the
153:04 - security we have and we can pass the
153:06 - values for it for example if my API is
153:10 - secured with an API key so all all I
153:12 - need to do is to select API key and then
153:15 - I paste like give the key name the key
153:17 - value and where I want to include this
153:20 - one as a header or as a query param
153:22 - depending on how you implemented on your
153:25 - backend then we have the headers tab so
153:28 - the headers tab by default we have few
153:31 - few headers which are hidden these
153:33 - headers are automatically injected and
153:35 - included by Postman or even the browser
153:38 - itself as we saw before so here for
153:40 - example we have the postman token we
153:42 - have the host user agent and so on so
153:44 - forth also if I want to specify a
153:47 - special header that I need for my back
153:50 - end I can also call it for example here
153:53 - my header and then value for example and
153:57 - then we can also specify description so
153:59 - this is where we can where and how we
154:02 - can pass extra headers to our back end
154:06 - and then we have the body so this body
154:09 - tab is mainly for all the requests like
154:12 - of type post put patch and and that's it
154:16 - for the delete I we we don't need to
154:18 - pass any uh any bodies so for example if
154:21 - I have a post request and here I can H
154:25 - or I have different types of uh of
154:28 - bodies so the body can be know this
154:30 - means that I don't have a body for this
154:32 - request which is also valid for some uh
154:35 - for some apis or for some endpoints so I
154:37 - will just clean up the URL and then we
154:40 - have also form data so the form data
154:42 - it's just a key value and for example we
154:45 - can pass a text or for a file in case I
154:47 - want to upload a file all I need to do
154:49 - is to select file in here and then
154:51 - select the file from from my
154:54 - system uh then we have also another type
154:57 - of body which is the URL encoded which
154:59 - is a key value
155:01 - map then we have row which is the part
155:04 - that we will see and we will use later
155:06 - on or we can also pass a binary so we
155:09 - can also select the file and and send it
155:12 - and even also if we have a graphql we
155:14 - can pass the query and the query
155:16 - variables and so on so forth so now
155:18 - let's go back to to this row and here so
155:21 - the the body can be whether a text or
155:24 - JavaScript or Json or HTML or XML and
155:27 - those are the supported body types then
155:31 - we have another tab right here which is
155:33 - the pre-quest script so Postman also
155:36 - supports scripting so we can before
155:39 - sending the request we can perform a
155:41 - script for example I can perform a
155:43 - script or I can write a script to grab
155:46 - grab some data or to grab a token from
155:48 - somewhere and inject it or save it to an
155:50 - environment variable that that I can use
155:53 - for example in my authorization or even
155:55 - in the header and so and so forth also
155:58 - we have the test tabs so when I run or
156:01 - when I want to test some um to test my
156:05 - endpoint and if everything is working
156:07 - fine I can perform test scripts here so
156:11 - that the scripts are JavaScript based
156:13 - and here like you can see for example
156:16 - that you have some some code Snippets so
156:18 - for example here if you want to test
156:20 - that the status code is 200 all you need
156:22 - to click on that and you will have the
156:24 - code ready to use so also you can refer
156:27 - to the official documentation of Postman
156:30 - and you will understand and you will get
156:32 - everything you want to get started with
156:34 - testing with Postman so here I will just
156:37 - go back to the authorization and move it
156:39 - back to non because we don't have any uh
156:42 - security also I will just remove this
156:44 - test and finally we have some settings
156:46 - this for example if you have some
156:48 - specific requirements for uh for your
156:51 - application or for your backend so this
156:53 - is where you can specify these settings
156:56 - but for now it's not something that
156:58 - which is really important for us and
157:00 - relevant so we will skip this part also
157:02 - with Postman we have a bunch of other
157:05 - features so here we can create
157:08 - Collections and this is the part that we
157:09 - will cover later on when we when we
157:11 - implement the the test part so we have
157:14 - here collections we can create a set of
157:17 - collections which is a set or like a
157:19 - group of the the request that we want to
157:22 - perform and we can have them for example
157:25 - this is one one of the requests of a
157:27 - previous boot camp that I already
157:28 - animated so here for example we can
157:31 - specify the order and the flow that we
157:33 - want to uh that we want to execute
157:35 - within a single collection and also this
157:38 - is this can be part of the endtoend
157:41 - tests later on also we have API here so
157:45 - we can switch to workspace or like to
157:47 - like we need to set up a workspace and
157:50 - here for example we can collaborate with
157:52 - other teams and so on so forth also we
157:55 - can Define environments so environments
157:57 - it's something similar to what we
157:59 - explained before we can work with
158:01 - environments on Postman too so for
158:03 - example let's say I have this uh this
158:06 - URL right here and I can run it on for
158:09 - example on a Dev environment on
158:11 - pre-production on production staging and
158:13 - so on and so forth so I don't need to
158:16 - change or to switch every time the URL
158:19 - from one environment to to another all I
158:22 - need to do is to set up my environment
158:24 - and just click or select or set that
158:27 - environment to the active one also with
158:29 - Postman we can use mock servers so users
158:33 - can create mock servers to simulate API
158:36 - responses which is useful in the early
158:39 - stages of development when the back end
158:42 - is not fully built so here you can you
158:44 - can say for example when you access this
158:47 - endpoint return this and this is what we
158:49 - call mock or mock server and also
158:52 - mocking this is a part that we will be
158:54 - covering in this course later on also we
158:57 - have some monitorings and here we see
158:59 - also the history of all the requests
159:02 - that you perform on Postman so this is a
159:05 - global overview for uh for Postman and
159:08 - now we let's move on and try to test our
159:12 - post method now we can use postm to
159:16 - perform this post request so let's open
159:19 - Postman and let's click on this plus
159:22 - icon and then all I need to do is to
159:25 - specify my EUR my URL so I will use just
159:28 - an old one and then I will clean up so
159:31 - my endpoint is localhost 880 slost as we
159:35 - have it in our back end so here it's a
159:39 - post request so I need to select the
159:41 - verb or the method which is a post and
159:44 - all I need to do is to click click on
159:46 - send so here let's check ah okay so we
159:49 - did not start our backend so let's start
159:52 - it and now let's go back to postman and
159:56 - here because we saw this message uh
159:59 - could not send request so this means
160:01 - that the that the server is not up and
160:03 - running so that's why I had to run it so
160:06 - now let's click on send again and here
160:10 - we see that the response or the answer
160:12 - from our post method saying that request
160:15 - accepted and message is null so the
160:18 - message is null because we did not pass
160:20 - anybody because my post end point is
160:24 - expecting a string message as a body so
160:27 - I need to pass that so as I explained
160:30 - before to pass a body click on the body
160:33 - and then we have the type Pro because
160:35 - all we need to do is to pass a text or a
160:38 - Json uh body or XML it depends on on the
160:41 - body type that we want to expect but in
160:44 - this case it's just a message message so
160:46 - it's just uh a classic test or or a
160:50 - normal test body so here let's say alibu
160:54 - for example and I will click on send
160:57 - again but even if I have my body right
161:01 - here the value of the message variable
161:04 - is always null even I have a 200 okay
161:07 - coming back from my back end so maybe
161:10 - let's change this one to Json and click
161:13 - on send it's still always null let's try
161:16 - with XML or HTML it's always null as a
161:20 - response so let's go ahead and check why
161:24 - this is null let's quickly restart our
161:26 - application in debug mode and let's add
161:29 - breakpoint to the line 19 and then let's
161:32 - send the request again and see maybe
161:34 - there is we receive correctly the value
161:36 - for this message variable and maybe we
161:39 - have something wrong with our
161:40 - implementation so let's jump back to
161:42 - postman and let's click on send again
161:46 - so here we see that we have our
161:48 - breakpoint and don't worry about that
161:50 - about debagging because I will make a
161:52 - full video just to cover how to debug
161:55 - with anj but as you can see here the
161:58 - value of our message is null so this
162:02 - means that we don't have any issue with
162:03 - our implementation this means that we
162:06 - well no no issue so far because maybe we
162:10 - missed something but for this case we
162:12 - are receiving null so this means that we
162:15 - are not able to map or to transform the
162:18 - message or the value of the message we
162:20 - received from Postman or or uh our rest
162:23 - client and we are not able to map it to
162:26 - this variable now let me show you and
162:29 - let me explain why when we work with
162:32 - spring framework we need always to tell
162:34 - spring and to indicate for each step
162:37 - what is the request body what is the
162:39 - response body what is this what is that
162:42 - because spring is smart enough is a
162:45 - complete framework but it will not do
162:47 - the job for us so in this case we need
162:51 - to indicate that this parameter we have
162:54 - right here is a request body or should
162:57 - represent the body of our request or of
163:00 - our method we have right here so in
163:03 - order to fix that what we need to do we
163:05 - need to add one annotation which is a
163:08 - request body so this means this is the
163:11 - body of our request and the request body
163:14 - annotation is used in the spring MVC to
163:17 - bind the HTTP request body with the
163:20 - method parameter it's part of the
163:22 - Spring's approach to build restful web
163:25 - services and is used in the controller
163:27 - layer where the HTTP request is handled
163:31 - so as you can see here we have our
163:33 - request body in our method right here
163:36 - which is already part of our rest
163:38 - controller so now let's restart the
163:40 - application in a normal mode and let's
163:43 - test again and see what will happen so
163:45 - again in Postman if I click on send now
163:48 - we see that we have alibu so here let me
163:52 - explain a little bit what happened so
163:55 - here when we send alibu as a message or
163:59 - as a body for our request then here in
164:03 - anj using this annotation so when we
164:06 - annotate the method parameter with
164:08 - request body spring will use the HTTP
164:11 - message converter to convert the HTT CP
164:15 - request body into the specified Java
164:18 - object so here for example it can
164:20 - convert Json data to the request body
164:23 - into the Java object or if it's for
164:26 - example here uh the case of a string of
164:28 - a simple string it was able to convert
164:32 - anything coming from the from the re the
164:35 - body uh of our request to this string
164:38 - message so here let me show you
164:39 - something else here we see that the type
164:43 - of the body or the type of this row uh
164:46 - object is text now if I transform it to
164:49 - Json and here so here this is how we map
164:53 - or rematch the Json representation so
164:56 - our parameter is called message and then
164:58 - let's give it a value alibu then let's
165:01 - click on send and see what is the output
165:03 - so as you can see so the request
165:06 - accepted and the message it just
165:08 - returned back this object so for us it's
165:11 - a Json because we selected Json as a
165:14 - type in here and we passed an ad Json
165:16 - object but here in our implementation
165:20 - the object is of type string so it it's
165:24 - just transforms this Json representation
165:27 - which is also a string to just string
165:30 - message but if I have a complex object
165:32 - or a Java object in here it will also be
165:36 - able to transform this to the Java
165:38 - object we will see this in details later
165:41 - on now let's assume that I want to PST
165:45 - post an object that should hold the
165:47 - information or the data of an order
165:50 - object this means I want to post the
165:53 - customer name the product name and a
165:56 - quantity to save it or to do whatever
165:59 - logic we need behind so let's go ahead
166:01 - and create such class so here on our
166:04 - base package right click and then new
166:06 - and then Java class and let's call it
166:09 - order dto or let's just call it order
166:12 - for now so click enter and here let's
166:15 - define some Fields so I will have
166:19 - private string customer name and then
166:22 - let's say we have also a private string
166:25 - product ID or or product name it also
166:28 - works and then let's have finally public
166:31 - in quantity and this is the
166:33 - representation of our object that we
166:36 - want to post right now because in the
166:38 - previous example we just so uh we just
166:41 - saw how to send a simple string as
166:44 - object now let's let's see how we can
166:45 - send a complex object to our controller
166:50 - now if we go back to our first
166:51 - controller class and let me make this
166:53 - one full screen and I will duplicate
166:56 - this method and or for the mapping I
166:59 - will call it post- order and here
167:02 - instead of having a string message I
167:05 - will request or ask to have the order
167:07 - object which is part of com. al. example
167:11 - the class that we just created and let's
167:13 - call it order okay
167:15 - so here let's say the request accepted
167:17 - and order is and let's simply say our
167:21 - object order dot to string so this is
167:24 - going to be the default to string method
167:27 - let's see what will be the output but
167:29 - first of all let's start our application
167:31 - and go to our Postman and test this one
167:33 - so first I'm going to start the
167:34 - application so we will get this new
167:37 - endpoint ready to use so as you can see
167:39 - the application is up and ready now if I
167:42 - go to postman and here here I will
167:45 - duplicate this tab so just right click
167:47 - on it and here you have duplicate
167:50 - tab so here I will just change the url
167:53 - to post order and then I will change the
167:56 - body so here we have the type it's Json
167:59 - and to represent the object that we
168:01 - created in our backend to ad Json type
168:05 - all we need to do is the is the
168:07 - following so here in the this order
168:10 - object all we need to do is to take
168:12 - these names right here the f names copy
168:16 - them and then go back to postman and
168:19 - here I will remove all this and just
168:21 - paste this so here the name should be
168:24 - exactly the same so no type was in in
168:27 - there and then I will show you how we
168:29 - can perform the types so here for string
168:32 - it should be also in double column so
168:35 - let's say alibu for the customer name
168:37 - and then for the product name let's see
168:39 - let's say for example iPhone and for the
168:42 - quantity since it's an integer so it
168:45 - will be just one and then don't forget
168:47 - to add a comma after each field so now
168:50 - let me format this and now we have this
168:52 - is the Json representation of our Java
168:55 - object so the names should match and
168:58 - then I will show you how we can also if
169:00 - we want change the Json uh property
169:03 - names so we can also do that so now
169:06 - let's go ahead and click on send and see
169:09 - what will happen so here we have this
169:11 - com. alibu example so this is the object
169:14 - now I will restart my application in
169:16 - debug mode and let's add a breakpoint
169:19 - and see what's happening exactly going
169:21 - back to our first controller I would
169:23 - remove this breakpoint and move it to
169:25 - line 27 since here we receive the order
169:28 - object and then I will restart my
169:30 - application in debug mode and then I
169:32 - will go back to postman and click on
169:35 - send again so here we have our order
169:38 - object so let's check what we have we
169:41 - see here that we have customer name is
169:42 - null product name is null and quantity
169:45 - is null okay so I will resume this also
169:49 - I will just go back to my order class
169:51 - and generate the two string method so
169:54 - here just use the autoc
169:57 - completion and here we see that we have
169:59 - this two- string method and I want this
170:02 - two string method to include all the
170:04 - fields that I have and then I will click
170:06 - okay so here this will be the string
170:08 - representation of my order class so if I
170:12 - restart again just to make sure that we
170:15 - uh we see exactly uh these two string
170:17 - method or what we expected let's go back
170:20 - to
170:21 - postman click on Sand and then I will
170:23 - resume since I have my breakpoint
170:26 - activated and then let's go back so here
170:29 - as you can see we have null null null
170:32 - but we already sent an object in here
170:35 - okay so we sent values alibu iPhone and
170:38 - one but we see that we have null values
170:41 - so let me explain to you why we have
170:43 - this when when we sent our request
170:46 - containing this request body right here
170:48 - with the following values alibu iPhone
170:50 - and one we saw that the response was
170:53 - containing null values so as we saw
170:56 - customer name was null product name was
170:59 - null and the quantity was there was Zero
171:01 - which are the default values of the
171:03 - types that we chose and this is because
171:06 - we didn't create any accessors for our
171:09 - order class so coming back to this
171:12 - order. Java class we see that we has
171:14 - created private Fields customer name
171:17 - product name and quantity and this is
171:20 - without any accessors so the accessors
171:24 - are Getters and and Setters also known
171:27 - as accessors are mutator methods they
171:30 - play a crucial role in the serialization
171:33 - and deserialization process in the
171:36 - context of a Frameworks like spring and
171:38 - libraries like Jackson which are
171:40 - commonly used for serializing and
171:42 - deserializing data and
171:45 - and uh from formats such as Json so
171:49 - these methods have specific uses so for
171:52 - example the Getters when an instance of
171:55 - an object is serialized into a format
171:57 - like Json the getter methods are called
172:00 - to access the current state of the
172:02 - object the values returned by these
172:04 - methods are then written into the
172:07 - serialized
172:08 - format now for the Setters during this
172:11 - realization Setters are used to populate
172:14 - the field of a newly created object with
172:17 - the data from the serialized format so
172:20 - now to fix the issue all we need to do
172:22 - is to generate Getters and Setters so I
172:24 - will click on generate and here we see
172:27 - that have we have Getters and Setters
172:29 - and also as I mentioned before each time
172:32 - I use a shortcut you will see the green
172:34 - popup right here to to see or to learn
172:37 - which uh shortcut I used so now I will
172:40 - generate Getters and Setters for all the
172:43 - fields that I have right right here so
172:45 - it will be for customer name product
172:46 - name and quantity and then I will click
172:49 - on okay so now we have the accessors so
172:52 - now if I restart my application I can
172:55 - also leave this breakpoint I will
172:57 - restart the application and then I will
172:59 - go back to postman and send again the
173:01 - request so here I will click on send and
173:05 - now let's evaluate this order so we see
173:08 - that the customer name is alibu iPhone
173:10 - and we have also the quantity if I
173:12 - resume the program and go back to
173:14 - postman we see that we have the object
173:18 - that we already sent so now I guess you
173:21 - understand the importance of having
173:23 - accessors while you use object to
173:26 - transfer data from a client or rest
173:29 - client which is in our case Postman or
173:31 - it can be any other application like a
173:34 - front end framework like angular or
173:36 - react or even native JavaScript and you
173:39 - need accessors to serialize and
173:42 - deserialize the object so so now as a
173:45 - Next Step let's see how for example I
173:47 - can customize the name of this Json
173:51 - field so for example I want to have a
173:53 - different name for my Json
173:55 - representation and another different
173:57 - name in my Java object now to specify a
174:01 - different property name and this case
174:04 - can happen for example in case I want to
174:06 - consume or I want to send data to a
174:09 - third party API and the names are not
174:12 - the same as my Java object for example
174:15 - we can have a casee of uh a customer
174:18 - name it might be C name p name for
174:20 - product name and Q for example just for
174:22 - quantity and I want to create a decent
174:25 - and comprehensive comprehensive Java
174:27 - object with customer name product name
174:30 - and quantity and also I want to uh I
174:33 - want Java or my spring framework and
174:35 - Jackson to correctly map these objects
174:38 - so all I need to do is to use an
174:40 - annotation called Json property and this
174:43 - Json property comes from the from the
174:46 - package com. faster xml. jackson.
174:48 - annotation which is the Jackson Library
174:51 - which is used by the spring framework
174:53 - for the serialization and
174:55 - deserialization process so here let's
174:57 - say that this customer name I wanted to
175:00 - have a c name for example to reference
175:04 - or to say that this is the customer name
175:07 - but before going forward let's quickly
175:09 - check the Json property annotation and
175:12 - here in the official documentation of
175:13 - this annotation it says that it marker
175:16 - annotation that can be used to define
175:18 - non-static methods as a Setter or getter
175:21 - for logical property depending on its
175:23 - signature and so on so forth so here
175:26 - this is the most important
175:27 - part the default value is empty as you
175:31 - can see in here indicates that the field
175:33 - name is used as the pro as the property
175:36 - name without any modification but it can
175:39 - be specified to nonempty Value to
175:42 - specify different names so here this is
175:46 - what we are doing right now and now
175:48 - let's just duplicate this and specify it
175:50 - also for the second property and I will
175:54 - call this one p name and let's say for
175:57 - example I want to call this as just Q or
176:01 - let's let's leave this one to quantity
176:03 - for example okay now if I restart my
176:05 - application in thebug mode and go back
176:08 - to postman and try to perform
176:11 - the the request let's see what will
176:14 - happen if I leave the properties like
176:17 - this so I'm going to click on send so I
176:19 - can also here uh leave the breakpoint
176:22 - and as you can see we see we have the
176:24 - customer name is null the product name
176:26 - is null but the quantity was correctly
176:29 - mapped so the quantity was mapped
176:31 - because we have this J this Json
176:34 - property right here and it's it has the
176:37 - same name as the Java property of the
176:40 - Java field okay but for the customer
176:42 - name and product name the names are
176:45 - different because we specified this Json
176:47 - property right here so all we need to do
176:49 - I'm going to resume the program right
176:51 - here and I will go back to uh
176:54 - Postman and all I need to do is to
176:56 - change this property to C
177:00 - name and then product name or p- name
177:04 - and
177:05 - here also I left on purpose this name
177:09 - right here with a capital N also to see
177:12 - if if it's case sens positive or not so
177:14 - let's try this out also we see that we
177:17 - have customer name and product name as
177:19 - null so yes the answer is yes
177:22 - it's uh case sensitive so you need to be
177:27 - really careful about that so here we
177:29 - have C name with uh small letter or
177:32 - small n or like a lowercase n so I will
177:35 - change this one and send again and we
177:37 - will see that we have correctly the
177:39 - mapping to the correct values that we
177:42 - sent from our rest client so here I'm
177:45 - going to resume the program and also I
177:47 - will show you that we have the correct
177:49 - output right here so now we understand
177:52 - how we can map properties with different
177:55 - names than the Java objects so now let's
177:59 - move on and see more interesting
178:04 - Parts since Java version 14 a new type
178:09 - of objects was introduced which is Java
178:12 - records we can also use records to
178:15 - represent our objects so like we did
178:17 - with this order here it's just a class
178:20 - we can create records to represent our
178:23 - uh request bodies so let's go ahead and
178:26 - try this one so here I will create a new
178:28 - Java class and then select record in
178:31 - here and let's call it order record and
178:34 - within this order record all I need to
178:37 - do is to create or to declare the same
178:39 - properties that we have in here so I'm
178:41 - going to just copy paste them so here
178:43 - here I will use a shortcut to uh to
178:46 - select all the properties just copy and
178:49 - then I will close this one and paste
178:52 - this in here so and then I need of
178:54 - course commas and now I have my record
178:57 - object created so here I have order uh
179:00 - order record and all I need to do is
179:02 - between these parentheses all I need to
179:04 - do is to declare my fields and I don't
179:08 - need any type of accessories like
179:09 - private public okay so now we have our
179:12 - order record ready let's move on and now
179:15 - and create an endpoint that should
179:17 - accept the order or the record as a
179:20 - request body and now if I go back to my
179:22 - first controller and I will again I will
179:25 - duplicate this method let me make it
179:27 - full screen and here I will call it uh
179:30 - post order record just to uh to make the
179:33 - difference and here I will call the
179:35 - method post record and here in this
179:39 - order uh or request body it will be
179:41 - order record Okay so so then I will also
179:45 - use the order. two string method so all
179:48 - I need to do is just to run my
179:50 - application again and check what will be
179:53 - the output of this endpoint so I'm
179:55 - restarting the application and as you
179:57 - can see the app is up and running now if
180:00 - I go back to postman and all I need to
180:03 - do is to change this endpoint to order-
180:06 - record and then I will click on send so
180:09 - here we still we see that we have null
180:11 - null null because we don't have the same
180:14 - property names also the Json property
180:17 - works with records so whether we can fix
180:19 - it on the Java side or we just rename
180:22 - this one so what I will be doing I will
180:23 - duplicate this tab and then in the body
180:27 - I will just use for example customer
180:29 - name and also I will just rename this
180:31 - one to product name so like this I don't
180:34 - need to change my Java object so I will
180:36 - click on send again and we see that we
180:38 - have here request accepted and the
180:41 - object is correctly displayed okay so
180:44 - now in this case we saw that we didn't
180:47 - need to create any Getters any Setters
180:50 - we didn't need to do anything for our
180:52 - record okay so here you see that we
180:55 - created three fields and then we created
180:58 - we we had to generate Getters and
181:00 - Setters because we need those ones also
181:03 - we saw that we have we had to override
181:06 - the two string method but for the order
181:08 - record we didn't need to do that let me
181:11 - explain to you in the next part
181:14 - what is the difference between uh poos
181:16 - or plain old Java objects like the older
181:19 - object right here and Records when it
181:22 - comes to data transfer objects whether
181:26 - to use poos or plain old Java objects or
181:29 - records for data transfer objects in
181:32 - Java depends on the use case and the
181:34 - Java version you are using Java records
181:37 - introduced as a preview feature in Java
181:40 - 14 and finalized in Java 16 so there are
181:44 - new kind of type declaration in the Java
181:47 - language a record class is shallowly IM
181:50 - mutable transparent carrier to for fixed
181:54 - set of values values which can be
181:56 - accessed with accessors method that that
182:00 - have the same names as the fields
182:02 - records reduce the verbosity of java and
182:06 - make it make it more suitable for data
182:08 - Centric applications poos have been used
182:12 - for many years in Java
182:14 - for such tasks they are versatile and
182:17 - work with all Java versions but require
182:20 - more code to write you have to declare
182:23 - fields and then you have to write or
182:26 - generate Constructors Getters Setters
182:29 - equals hash code and two string method
182:31 - if you are using Java 16 or later and
182:35 - your dto are simple carriers of data
182:39 - without any additional logic records may
182:42 - be a better choice they provide a
182:44 - concise and convenient syntax and
182:47 - automatic implementation of equals hash
182:50 - code and two string as we saw in the
182:53 - examples previously also you need to
182:56 - note that records are final by default
182:59 - and all their fields are final so they
183:02 - can't be used with libraries uh that
183:05 - require mutable beans such as uh some
183:08 - older versions of hibernate or jpa if
183:11 - you are using a Java version earlier
183:14 - than Java 16 or if you need mutable
183:17 - objects or if your dto need to include
183:20 - logic Beyond uh just storing data pojos
183:25 - may be a better choice so as always the
183:28 - right choice depends on your specific
183:30 - needs and
183:32 - constraints now let's see how we can
183:34 - pass parameter to a method so let's go
183:38 - back to our first controller and let's
183:40 - see how I can pass a parameter to a
183:43 - specific method so here I will just
183:46 - create or copy this get mapping method
183:49 - right here and I will put it in the
183:51 - bottom so this works for any type of uh
183:55 - of methods whether get post put delete
183:58 - and so on and so forth so it's it's
184:01 - appliable
184:02 - and correct for all of them so here
184:05 - let's say for example
184:08 - um path
184:11 - variable this means that I want want to
184:14 - pass my parameter or my variable in the
184:17 - path so to pass it in the path here
184:20 - let's say for example my value equals
184:25 - and then let's concatenate this with the
184:28 - result so then the first thing that we
184:30 - need to do is in this get mapping right
184:34 - here so let's say that we have um a
184:37 - method called hello let's keep it as
184:40 - hello and now I want to
184:42 - pass my variable in the path so this
184:45 - means I want to have something like this
184:47 - so HTTP and then colon SL slash and then
184:51 - Local Host and then the port number
184:54 - slash for example hello SL alibu let's
184:59 - say so this is or I want this one a
185:02 - variable so it can be alibu it can be
185:04 - Ali it can be Buu it can be any variable
185:08 - that I want to pass so here in this case
185:11 - first all I need to do is to have my my
185:14 - variable so it's of type string for
185:17 - example and let's say usern name just an
185:20 - example and now I need to tell spring
185:23 - that this username will come in the path
185:27 - right here or I will receive it in the
185:29 - path of my request so to do that just go
185:32 - here whether you have for example SL
185:35 - hello or you have nothing all all you
185:37 - need to do is Slash and then curly
185:40 - brackets and then for example let's say
185:42 - use user Dash
185:45 - name so like this spring will know that
185:48 - this user- name is a path variable now
185:52 - all we need to do is to link this one to
185:55 - this one so here we have two cases so
185:58 - the first one whether I pass the path
186:01 - variable exactly within the same name
186:05 - like the same naming as my variable
186:07 - right here so it will be just like that
186:10 - okay so spring will automatically refer
186:14 - this usern name here to this username
186:17 - right here so here here I will just
186:18 - concatenate my username or the best case
186:22 - which I recommend is to use user-name
186:25 - for example and here all you need to do
186:28 - is to say that this is a path variable
186:31 - okay and this path variable as I
186:34 - mentioned before whether we use it like
186:37 - this so the path variable is always
186:39 - needed you need always to specify or to
186:42 - add this path variable annotation to the
186:44 - field that you want to map because like
186:47 - this we will mention to Spring that this
186:49 - username right here this variable or
186:52 - parameter that we want to receive right
186:54 - here is the same that we have it here
186:57 - and first we can mention the same name
187:00 - so the same variable name or for example
187:03 - if I have a different one so to use it
187:06 - like this user- name here this path
187:09 - variable also accepts a parameter it's
187:12 - called Val so by default it's empty and
187:15 - by default it will take the variable
187:17 - name as the variable of as the variable
187:20 - of the default value so here let's
187:23 - specify it like that and let's say user
187:26 - Dash name so the value we put in here
187:29 - should be exactly the same in here so
187:32 - what I recommend also try to have like
187:35 - correct namings so user- name is more
187:38 - readable than for example username like
187:41 - this uh or for example example if you
187:43 - have long complex names always
187:45 - separating them with a dash is much much
187:48 - easier to read so now if I restart my
187:51 - application and go and test this one we
187:53 - will see that we have my value equals
187:55 - the value that we will pass in the
187:58 - parameter so I will just restart in
188:00 - debug mode and then I will go to my
188:02 - Postman and in here I will just
188:05 - duplicate one of these and here I have
188:08 - for example hello slash and then let's
188:11 - say alibu and of course it's a get
188:13 - mapping so let's click on the get so we
188:16 - don't have anybody so we can click on
188:18 - none and now all I need to do is to
188:20 - click Send so here we see that I have my
188:23 - value equals alibu and if I say for
188:26 - example hello or even with spaces as you
188:30 - want it also able to map the value so
188:33 - here this is how we can pass a variable
188:36 - in the path we call it also path
188:38 - variable now let's see how we can pass
188:42 - request parameters now let's see how we
188:44 - can pass a variable as a request param
188:47 - so here I will just duplicate this
188:50 - method just to keep the code and then I
188:52 - will just here rename it to param
188:56 - variable and I will just command this
188:58 - out to keep the same URL so here I will
189:02 - just remove this one so it will be just
189:04 - /hello and here the URL or the final URL
189:08 - will be hello and then like this and
189:11 - then it will be param and _ name or like
189:14 - this is this will be the Pam name equals
189:17 - and then the value so here param value
189:20 - and if I have a second parameter it will
189:22 - be end and param name two for example
189:27 - equals value two just an example okay so
189:32 - now let's transform this username to a
189:35 - Pam or or request param so here all I
189:38 - need to do instead of using path
189:41 - variable it will be a request param and
189:45 - this request param whether we can keep
189:48 - the request param as the this parameter
189:51 - or this field right here or uh sorry
189:54 - it's param not part and or here in the
189:58 - same way as we did before so let's say
190:01 - for example user- name okay so if I have
190:05 - another parameter all I need is to do is
190:08 - to duplicate it or to add another
190:11 - request param so for examp example
190:13 - username and here let's say last name
190:16 - and here let's say for example last name
190:19 - and here all I need to do is just to
190:21 - display this plus user last name and
190:26 - this is how it will look like now all I
190:29 - need to do is restart my application and
190:32 - go back to postman and send this request
190:35 - again so when we started the application
190:37 - we have an exception and this is
190:39 - actually is going to introduce us to the
190:41 - next topic that I will explain just
190:43 - later on but for the moment I will just
190:46 - comment out this get mapping right here
190:49 - and I will explain that later on so
190:52 - let's restart the application again and
190:54 - make sure that everything is up and
190:55 - running so here the application started
190:58 - and let's go back to postman and all we
191:01 - need to do is just change this one and
191:04 - as I mentioned before we have user Dash
191:07 - name also you can remark that here we
191:11 - everything every time we Type A
191:12 - parameter and the value it will be
191:14 - reflected automatically in the query
191:16 - params so here let's say alibu and for
191:20 - example a end and then for example we
191:23 - have
191:23 - user- last name and then equals for
191:27 - example bu Ali so this is my last name
191:30 - and then let's click on send so here we
191:33 - see that we have alibu and then bu Ali
191:35 - as a last name exactly as we mentioned
191:38 - in our code right here okay so this is
191:42 - how you can and pass request params now
191:45 - let's move on to the next part which is
191:47 - how we should name or how we can name
191:50 - our methods and URLs and how spring is
191:53 - already interpreting that and how
191:56 - requests are dispatched from our rest
191:59 - client to the back end so now let's
192:02 - understand the difference between path
192:04 - variables and request params so in
192:06 - Spring boot path variables and request
192:09 - params are annotation used for
192:12 - extracting values from the URL of an
192:14 - HTTP request they are used in the spring
192:17 - MVC Handler methods and here how they
192:21 - differ so first when we start with the
192:23 - path variable right here so this
192:26 - annotation is used to extract values
192:29 - from the URI path so it's typically used
192:32 - in restful web services where the URL
192:35 - contains a value representing some sort
192:37 - of resources identifier so the annotated
192:40 - parameter in the method declaration is
192:43 - bound to the path variable of the same
192:46 - name so as we mentioned before so here
192:49 - if you have weather Spring is capable of
192:51 - referencing the name that you pass right
192:54 - here as a path variable with the
192:56 - parameter name or the field name or when
193:00 - you use path variable also like you need
193:02 - to use path path variable and you can
193:05 - also pass the name right here to match
193:07 - the name that you have in your url from
193:10 - the other hand when we use request Pam
193:13 - so this annotation is used to extract
193:16 - query parameters from the URL so query
193:19 - parameters are typically used to carry
193:22 - context information for the request and
193:25 - are separated from the URI using the
193:29 - exclamation mark symbol and are chained
193:32 - with the end symbol so in summary path
193:35 - variable is used when a value you want
193:38 - is actually part of the URI while
193:41 - request peram is is used when the value
193:43 - is passed as a query parameter in a
193:47 - spring MVC or spring boot application
193:50 - the framework uses annotations to Define
193:53 - which method should handle which HTTP
193:56 - request so we have the controller or the
193:59 - rest controller annotations are used at
194:03 - the class level to indicate that an
194:05 - annotated class is a controller so
194:08 - Springs component scanning mechanism
194:10 - detects these classes and and create
194:13 - pins of them in the application context
194:16 - so then we have the request mapping
194:18 - annotation or as a shortcut we have the
194:21 - get mapping post mapping put mapping Etc
194:25 - so this one is used as the method level
194:28 - Within These controller classes so this
194:31 - annotation tells spring that the
194:33 - annotated method should handle an HTTP
194:36 - request of a certain type and for
194:38 - example a post get put and so and so
194:41 - forth and when when the application
194:43 - starts up Spring creates a mapping
194:46 - between the URLs HTTP methods and the
194:49 - corresponding controller methods so this
194:52 - is done by a class called request
194:55 - mapping Handler mapping which scans the
194:58 - controller classes and builds up a
195:01 - registry of such mappings so when an
195:04 - HTTP request comes in the dispatcher
195:07 - seret which is the front controller in
195:10 - Spring MVC consults these mappings to
195:13 - determine which method should handle the
195:16 - request so then the appropriate method
195:19 - is then invocated and its return value
195:22 - is used to generate the HTTP response
195:25 - next we will see in the diagram how this
195:28 - is working so now let's understand in
195:31 - action and even a little bit in details
195:34 - how this works so in a springut
195:36 - application or in the rest API
195:38 - application we have some kind of rest
195:41 - clients
195:43 - and it can be a mobile application
195:45 - another rest API or the internet or even
195:48 - Postman as a rest client and then the
195:51 - first step is is sending a request so we
195:54 - call this an incoming request and the
195:57 - first thing or the first object that
195:59 - will receive this request is the front
196:02 - controller which is the dispatcher
196:04 - serlet then the dispatcher serlet will
196:07 - forward the the request to the Handler
196:11 - mapping class the hander mapping object
196:14 - and this hander mapping will consult the
196:17 - mapping registry and it it will tries to
196:20 - find a mapped controller and this
196:23 - mapping registry as I explained before
196:26 - so it will map or it has a registry of
196:29 - the method plus the path plus the path
196:32 - variables and types and it will refers
196:35 - to a specific method of the controller
196:38 - then when it finds match it will return
196:41 - the controller and the meth method that
196:42 - needs to be invocated and then the fifth
196:46 - step it will forward this request to the
196:48 - to the required controller and then we
196:51 - of course have all the business logic
196:53 - goes uh goes along like uh service
196:56 - validation database registration
196:59 - Consulting another API and so on so
197:01 - forth and after that we have the
197:04 - response so the response will go back to
197:07 - the controller and the controller will
197:09 - send back the response to the dispatcher
197:11 - surve
197:12 - and then it will go back to the customer
197:15 - or to the client of this request and
197:18 - this is how it exactly works now let's
197:21 - have a quick look on this so for example
197:24 - if we have a get method with the
197:26 - following path SL s path SL string and
197:29 - then an integer as path variable and for
197:32 - example we have a get s/ ali1 so this is
197:36 - correct then if we have the same path
197:39 - but with a different uh verb or
197:42 - different method in this case for
197:43 - example a post so we have post SL
197:47 - something/ A1 so this is also correct
197:50 - because we have two different verbs so
197:53 - that's why I mentioned here that the
197:55 - concatenation of of the URL should be
197:58 - unique so the concatenation or like the
198:01 - composition of the URL is Method plus
198:03 - path plus path variables and here I
198:06 - mention type because we need to have
198:09 - different types so for example here if
198:12 - in case I have sth SL string SL aner and
198:16 - then even if I pass a different value
198:19 - spring will say that we have uh we have
198:21 - an ambiguity and it it's not able to
198:24 - determine which one to use so you you
198:27 - really need to be careful about that and
198:29 - we will see in action how this works so
198:32 - this is globally how request dispatching
198:36 - Works in Spring boot so now coming back
198:40 - to our first controller class and let's
198:42 - bring this back so here we have a get
198:45 - mapping and then it it has a mapping SLO
198:49 - and in the bottom if you remember we
198:51 - have a get mapping so also it has the
198:55 - same URL so it's /hello and here we see
198:58 - that request perams they did they do not
199:01 - interfere or they do not make a a method
199:04 - unique so now if I start the application
199:07 - I will get an exception telling me that
199:10 - spring is not able to determine or to
199:13 - know which is what so here the error
199:16 - that we have so we have application run
199:19 - failed and the exception here it says
199:21 - that error creating being with name
199:23 - request mapping Handler mapping so this
199:26 - is the class that we spoke about defined
199:28 - in the class path blah blah blah and so
199:31 - on so forth and here it's mentioning
199:34 - that so here in the end of this
199:37 - exception we see that we have ambiguous
199:40 - mapping so cannot map first controller
199:43 - method and the method is com. alibu do
199:47 - example. first controller which is our
199:50 - class and then the method called Pam
199:52 - variable so this is the method that we
199:54 - are talking about and then this method
199:57 - it contains two string uh parameters to
200:01 - a get/ hello because there is already a
200:04 - first controller Bean method com. alibo
200:08 - example and the method is called say
200:10 - hello which is already mapped so in this
200:14 - case we see that this method even the
200:17 - method name is different but spring
200:20 - doesn't refer uh the method names but
200:22 - first the ID or the Unicity is about the
200:27 - parameter and the path so you you really
200:29 - need to be careful about that and even
200:31 - if you get such an example or such an
200:34 - exception you now are able to understand
200:38 - where this comes from before moving
200:41 - forward let's first clean up our code so
200:44 - first I will remove this order record I
200:47 - will create one later on if we if we
200:50 - need to and then I will keep um I can
200:55 - keep this order we might use it but also
200:58 - let's just clean clean up everything and
201:00 - let's restart everything from scratch
201:02 - and for this controller I will just
201:05 - leave the first get method just to have
201:08 - our controller up and working so here I
201:11 - will just leave this get mapping and
201:13 - this post mapping and now let me also
201:16 - optimize the Imports and that's it so
201:19 - now we have our project again clean and
201:22 - we can start from scratch to introduce
201:25 - and to dig deep and deep in this
201:29 - part first of all we need to install all
201:32 - the required softwares to in order to
201:35 - correctly and easily communicate and
201:37 - interact to the database for this course
201:40 - we will be using post SQL as a database
201:44 - management system so for you you can
201:47 - whether uh install postgress SQL on
201:50 - premises this means you download and
201:53 - install the the software or you can use
201:56 - Docker so first let me show you how you
201:59 - can install go to Google and all you
202:02 - need to do is to Type download postgress
202:04 - SQL and then you just select because you
202:08 - will have two or more links like uh the
202:11 - sponsor uh sponsored links but then you
202:14 - need to go to the official website which
202:16 - is 3w postgressql dorg and then go to
202:20 - the downloads page so here you will have
202:23 - the download page for the different
202:26 - operating systems like Linux Mac OS
202:28 - windows and so on so forth and all you
202:30 - need to do is to follow the installation
202:32 - instructions for example for Mac OS here
202:35 - you can download the installer certified
202:38 - by the EDB and so on so forth also for
202:41 - example if you want to use the postgress
202:43 - do app or home brew or and so and so
202:46 - forth the same for Windows just click on
202:50 - the Windows link and then you have
202:51 - download the installer also you can see
202:54 - the versions and what are what versions
202:56 - are available and so and so forth so
202:59 - this is how you can install postgress
203:02 - SQL on premises for your operating
203:05 - system now in the next part let's see in
203:08 - case you want to use Docker let me show
203:11 - you how to install postgress SQL as a
203:14 - Docker image or Docker container running
203:16 - on your Docker machine now if you want
203:19 - to use post agress SQL on Docker all you
203:22 - need to do is to go to hub. do.com so
203:26 - this is the dockerhub website and all
203:28 - you need to do is to search for post
203:30 - address okay so here we see that we have
203:33 - the first image and always try to look
203:36 - or to search for the docker official
203:38 - image so then in order to install it so
203:41 - let's say we want to use the latest
203:43 - version so here we have all the the
203:45 - information we need and here we see that
203:48 - we have this Command right here so all
203:50 - we need to do is to copy this command
203:53 - and here we see that we have this
203:55 - environment variable which is important
203:57 - and which is mandatory in order to make
203:59 - post agress SQL running correctly on
204:02 - Docker so here we have post agress
204:05 - password and you need to provide the
204:06 - password for your P post agress SQL and
204:09 - the user will be postag just like this
204:12 - by default so then I will show you how
204:15 - we can use this in order to connect to
204:18 - our database and display all the data we
204:20 - need so all you need to do just copy
204:22 - this one and run it on your terminal and
204:26 - also make sure you to have a Docker
204:28 - desktop installed on your machine and
204:31 - then you're good to go so I assume if
204:34 - you have Docker and a little bit
204:36 - familiar with Docker so it will not be
204:39 - an a complex task to set up and install
204:42 - a Docker container on your machine now
204:45 - let's see how we can explore our
204:48 - database so here if you have an DJ with
204:51 - the ultimate version all you need to do
204:53 - is to select and click on this database
204:57 - otherwise you can go to view and then
204:59 - you will have tool window and then you
205:02 - will have database right here so just
205:04 - click on it and it will display this bar
205:07 - right here so then in this plus so let
205:10 - me make it full screen so then on this
205:12 - plus just click on you to select a new
205:15 - data source so when you highlight this
205:17 - new data source you will have this popup
205:19 - right here and then all you need to do
205:21 - is to search for the database that you
205:23 - are using so in our case let's search
205:26 - for post
205:27 - digress and then when you click on okay
205:30 - you will have this popup right here so
205:33 - here all you need to do is like to
205:35 - provide the name so also you can for
205:38 - example let's say
205:40 - test just an example so this will be the
205:43 - name of of your data source and then so
205:47 - if you if it's the first time that you
205:49 - are using this tool you will have a link
205:52 - right here telling to download the
205:54 - driver so just go ahead and click click
205:57 - on it but for my case since it's already
205:59 - downloaded so I don't have it anymore
206:02 - then the next step is here we need to
206:05 - provide the information about the host
206:07 - and the port so the host it's always
206:09 - Local Host whether you are running your
206:11 - postgress SQL on premises or on a Docker
206:14 - container so it's always Local Host and
206:17 - the port if you did not change it it's
206:19 - by default
206:22 - 5432 then we need to provide the
206:24 - authentication so these are the username
206:27 - and password that you provided when you
206:29 - installed postag SQL so for my case it's
206:32 - alibu and then alibu as a username and
206:35 - password and now all I need to do is to
206:38 - click on test connection for the
206:39 - database just leave the datab as a
206:42 - database by default which is the
206:43 - postgress so you don't need to changes
206:46 - to change it or if you have different
206:48 - ones all you need is just to select
206:50 - database that you want to connect to so
206:53 - here we see that we have this URL right
206:56 - here and we will need this one later on
206:59 - so I will show you again how we can also
207:02 - retrieve it again so now all we need to
207:04 - do is to click on test connection to
207:06 - make sure that we are correctly or we
207:09 - can correctly connect to our database so
207:12 - make sure you have this succeeded
207:13 - message otherwise you need to check the
207:16 - information or the inputs that you
207:18 - provided in here so now all I need to do
207:21 - is to click apply and then okay so here
207:24 - let's explore together this UI so here
207:27 - this this is the the data source that we
207:30 - call test and here we see that we have a
207:33 - postgress SQL it's one of three and then
207:36 - we have the public schema so here also
207:38 - we can select all the databases that we
207:40 - have or that we will create in this okay
207:44 - so now for the moment we don't have any
207:46 - database selected later on when we
207:49 - create our first database we will be
207:51 - able to select it and display it in here
207:54 - okay so that's it now I will show you if
207:57 - you don't have the anj ultimate version
208:01 - what is the alternative to connect and
208:04 - to explore the
208:05 - database for the students that they
208:08 - don't have the ultimate version of anti
208:11 - J and you want to have a different tool
208:14 - that will help you exploring any
208:17 - database you want so I recommend using a
208:20 - tool called Deaver so this Deaver is an
208:23 - open source and free crossplatform
208:26 - database for developers database
208:28 - administrators and so and so forth so
208:31 - all you need to do is to whether to
208:32 - Google D Beaver or just go to D beaver.
208:37 - and when you click on the link you will
208:39 - have this interface and then you can
208:41 - click on the download link but before
208:43 - going to the download all you need to do
208:45 - like let's first uh explore the the UI
208:49 - so it looks a little bit similar to the
208:51 - UI that we are using on anj so here you
208:55 - have the databases that you can select
208:57 - or the data sources also like U even to
209:01 - connect to a database like you can
209:02 - change the theme from light to dark also
209:06 - uh you can see the diagrams you can see
209:08 - almost everything and even to connect to
209:11 - the database it's pretty much similar as
209:14 - the steps that we follow together this
209:16 - is uh something that I recommend for
209:19 - people that they don't have the ultimate
209:22 - version of antj but for me personally I
209:25 - prefer having everything in one place
209:27 - and in one UI so that's why I I will be
209:31 - using anj for the database but for you
209:34 - it should be the same exactly the same
209:36 - way even if you don't have the ultimate
209:38 - version to work with spring data J jpa
209:41 - and data persistency in Spring boot
209:44 - project all we need to do first of all
209:46 - is to add the required dependency so to
209:49 - add a new dependency we need to go to
209:51 - our pom.xml and then let's make this one
209:55 - full screen and let's add a new
209:58 - dependency in here so after the spring
210:00 - boot starter web here open um a new tag
210:05 - and then you will have the autoc
210:06 - completion dependency so I will click on
210:09 - it otherwise the dependency look looks
210:11 - exactly like this so it's a dependency
210:14 - tag and it contains a bunch of
210:16 - information so we have first of all the
210:18 - group ID and the artifact ID so the
210:21 - group ID for for most of the spring boot
210:25 - starters it's always or. spring boot
210:28 - framework. boot sorry it's or springf
210:31 - framework. boot so then I will paste
210:34 - this one in here and then the artifact
210:37 - is the starter name and all the starters
210:40 - or or the all the spring boot starters
210:44 - they always start with spring Das Boot
210:47 - Das starter and then the starter name
210:51 - and here as you can see in this list we
210:53 - already see that we have data jpa so
210:56 - this is the dependency that we need for
210:59 - our project so let's select this one and
211:02 - then of course it will suggest the the
211:05 - group ID since it's the same one we can
211:07 - also double click it or even ignore that
211:11 - and also don't forget to right click on
211:14 - this uh on this pom.xml and here we have
211:17 - you have Maven and then reload project
211:20 - so this will allow and will tell Maven
211:24 - to download all the dependencies and as
211:27 - you can see here so now anj is
211:30 - downloading all the required
211:31 - dependencies including this spring boot
211:34 - starter data jpa so now if we uh
211:37 - integrate and add the spring boot
211:40 - starter data jpa we can now run the
211:43 - project and see what will happen so
211:45 - let's also explore the logs together and
211:48 - see what will happened so the first
211:50 - thing the application is not running
211:52 - because we have an issue and the issue
211:54 - is fail to configure a data source or a
211:58 - URL attribute is not specified and no
212:02 - embedded data source could be configured
212:04 - so I will explain this in the next video
212:06 - so now we added the dependency and now
212:09 - we can start configuring our database as
212:12 - we mentioned before spring boot starters
212:16 - they leverage Auto configuration
212:17 - whenever it's possible and after adding
212:20 - the dependency for the spring boot data
212:23 - uh starter data jpa we saw that when we
212:26 - started the application we had a failing
212:29 - so here the mention on of the
212:31 - description says failed to configure
212:33 - data source and the attribute URL is not
212:36 - specified this means that we need at
212:39 - least to give some configur uration and
212:41 - some details to this starter in order to
212:44 - autoconfigure the connection to the
212:46 - database and this is what we will be
212:48 - doing in this phase and first of all
212:51 - let's go to our application properties
212:53 - file and here as I mentioned before so
212:56 - let me first clean it up and as I
212:59 - mentioned before and in this course I
213:01 - will be using the yaml representation so
213:03 - to do so you have two options whether to
213:06 - remove this application. properties file
213:09 - and create another one with the yaml
213:12 - extension or all we can do is just
213:15 - rename it using this shortcut and change
213:19 - the properties to
213:21 - yaml so you can use whether yaml or
213:25 - yml okay so here I will click on
213:28 - refractor so now my application file is
213:32 - using the yaml representation so now
213:34 - let's start configuring the connection
213:37 - to our database and to start the
213:40 - configuration first of all we start with
213:42 - providing the data source configuration
213:45 - so with the data source configuration is
213:48 - uh located under
213:50 - spring and then colum and then here you
213:54 - need to be careful so this is a tab it's
213:57 - not a space or it's not three spaces or
213:59 - two spaces but you need to use the tab
214:02 - okay so here for example if I remove it
214:05 - I need to use the tabulation as you can
214:07 - see in the shortcut here and then data
214:10 - source and you see here that we have
214:12 - this autoc completion already so it's
214:14 - spring. data source and then we need to
214:18 - specify the URL as mentioned in the
214:20 - exception that we have so here also we
214:23 - will type URL and we see here already in
214:26 - the description it's jdbc URL of the
214:28 - database so it's not Hikari it's not DBC
214:32 - cp2 and so on so forth so you need to be
214:35 - sure and to be careful choosing the
214:37 - right property so here I will choose URL
214:40 - and then where can I where can I get
214:43 - this URL from so here we can go back to
214:46 - the database and then rightclick on this
214:49 - data source that we uh created before
214:52 - and then click on
214:55 - properties and here we will see that we
214:58 - have this tab again and this window to
215:00 - configure the connection and then the
215:02 - URL is exactly this one so let's copy it
215:06 - close this one and we can also close
215:08 - this and then paste this this one here
215:12 - now let me explain to you what is or
215:14 - like how this URL is composed so here is
215:17 - the connection type so we want to have a
215:19 - jtbc connection which is Java database
215:23 - connectivity and then this is the the
215:26 - database type which is in our case is
215:28 - postgress SQL because we want to use
215:31 - postgress SQL for example if you are
215:33 - using MySQL or Oracle or something like
215:35 - that it will be the exactly that one and
215:39 - then we we need the the host name of our
215:44 - database and in our case since we are
215:46 - using locally uh our database it's not a
215:49 - remote one so it's local host or even
215:51 - you can provide the machine or like the
215:54 - remote machine uh address or IP address
215:57 - and then the port by default it's this
216:00 - one and if you have a different one you
216:02 - can also use it and finally this is the
216:04 - database name and for the database name
216:07 - I will create a database later on and I
216:09 - will call it demo underscore DB and this
216:12 - is will be our database so in the next
216:15 - next phase we will create this database
216:17 - so first of all let's continue with the
216:19 - configuration and then of course within
216:21 - the data source we need to provide other
216:24 - information which is the username and
216:26 - password which are the credentials for
216:29 - uh our database or for spring data jpa
216:31 - to be able to connect to the database
216:34 - and it will be exactly the same as we
216:37 - provided here when we try to connect the
216:38 - first time to our database
216:41 - which is in our case uh in my case sorry
216:43 - it's alibu as a username and alibu as a
216:46 - password so here I will also provide
216:49 - this information so use uh choose
216:52 - username and again be careful it's not
216:54 - Hikari it should be ex directly data
216:57 - source. username and in this case it
216:59 - will be alibu and then
217:02 - password and also choose the second one
217:05 - not hiar okay and it will be also alibu
217:09 - and then we need to tell uh spring data
217:12 - GPA which driver to use in order to
217:15 - connect to the database because as you
217:17 - know to connect to any database we need
217:20 - a driver so here if I choose also driver
217:23 - class name it is under spring.
217:25 - datasource driver class name and here I
217:29 - need to provide the class name for our
217:31 - postgress SQL and in this one we just
217:36 - need another dependency to add to our
217:38 - configuration so let's let's go ahead
217:40 - and add it to add the postgress SQL
217:43 - driver we need to go again to our
217:45 - pom.xml file and then we need to add
217:48 - another dependency so here I will click
217:51 - and add dependency and then the
217:53 - dependency it has an artifact ID which
217:56 - is called postgress SQL or postgre SQL
218:00 - and then the group ID is org. postgre
218:02 - SQL also we can add a scope which is in
218:07 - our case it should be runtime so here
218:10 - this is the scope of this uh of this
218:12 - dependency so it's available on the
218:14 - runtime and then I click on this popup
218:17 - right here or as I mentioned before just
218:19 - right click and then Maven and then
218:22 - reload project to reload and download
218:24 - all the necessary dependencies so now we
218:27 - have our postag gr SQL driver available
218:30 - let's go back and continue with our
218:33 - database
218:34 - configuration so now if you go back to
218:36 - our application. yaml and in this driver
218:39 - class name name if I just type command
218:42 - uh space and here we will see that
218:45 - automatically anj will propose driver
218:48 - coming from org. postre SQL package as a
218:51 - driver class name otherwise you can just
218:54 - manually type orpos SQL do driver and
218:58 - then you will have the driver and in
219:00 - case you don't include or you forgot to
219:02 - include the driver it will be
219:04 - highlighted as uh as a nonf found or a
219:07 - class notfound exception or error right
219:09 - here so don't worry about that in case
219:11 - you forgot to add it uh anj will
219:14 - highlight it automatically so now the
219:17 - first part is ready and now I can start
219:20 - the application and see what will happen
219:22 - so here let's start the application and
219:25 - check if spring will be able to locate
219:27 - and start the application so yes the
219:30 - first part is done so let's check right
219:32 - here and here only thing that we have
219:35 - the database demod DB does not exist so
219:39 - it was able ble to locate the database
219:41 - using the the username and password but
219:44 - it didn't find any database called
219:46 - demoore DB also I want to show you
219:49 - something for example if I change the
219:51 - username and the password or just
219:53 - username or password to provide wrong
219:55 - credentials and restart the application
219:58 - we will see a different exception so
220:00 - here it will say that enable to
220:03 - authenticate so here it says password
220:05 - authentication failed for user alibu DDD
220:09 - so even if I fix the username and
220:12 - provide a wrong password we will see
220:14 - again the same exception uh fatal
220:17 - authentication as you can see right here
220:19 - but this time it will say that password
220:22 - authentication failed for the user alibu
220:25 - so here like we know now we understand
220:27 - that spring is able to connect to the
220:30 - database now let's move on and create
220:32 - our database and restart the
220:37 - application so in this step let's let's
220:40 - go ahead and create our database so in
220:42 - here click on database and on your data
220:45 - source that we created we called it test
220:48 - right click and then we have new and
220:50 - then so let me just make it wider right
220:53 - here so again right click and then new
220:56 - and you see here database so select
220:58 - database and then let's provide the
221:01 - database name as we mentioned before
221:03 - demo andore DB and even you will see the
221:06 - SQL uh query command that it will be
221:10 - executed which is create database and
221:12 - then the database name so click click
221:14 - okay so here we see that we have this
221:16 - demod DB but it says here that no schema
221:20 - selected so all we need to do is to
221:22 - click on zero of three right here and
221:24 - select the public schema which will hold
221:27 - our database later on and the list of
221:29 - the tables that we have so in here we
221:31 - have empty schema for now and we don't
221:34 - have any tables so let's move on and
221:36 - check that so now let's create our first
221:40 - first Java class which will represent a
221:42 - table in our database so I will explain
221:45 - everything later on but first let's
221:47 - start with creating a new class and
221:50 - let's call it student for example and in
221:53 - this case so here the student will hold
221:56 - the information of our student so let's
221:59 - say first our student has a private
222:02 - integer ID so this will be the
222:05 - identifier or the unique identifier of
222:07 - our student also it has a string first
222:10 - name and then a private string last name
222:14 - so let me make this one uh full screen
222:17 - and string last
222:19 - name and then let's say also our student
222:23 - has a private string email and finally a
222:28 - private string H uh sorry the AG should
222:32 - be an
222:33 - INT so here this is the representation
222:36 - of our student so again let's go ahead
222:39 - and generate create some Getters and
222:40 - Setters because as we mentioned before
222:43 - we need Getters and Setters let's click
222:45 - okay and then we need for for example a
222:49 - Constructor if you want to so let's
222:51 - create a
222:53 - Constructor and for this Constructor you
222:56 - let's use all the parameters except the
222:59 - ID so this is how we can construct a
223:02 - student uh using all the fields that we
223:04 - have right here also you can just uh
223:06 - ignore that and we can use Setters later
223:09 - on to create our user so now we have our
223:12 - object student or student class ready
223:15 - let's move on and let's see how we can
223:17 - transform this student class to an
223:21 - entity which will be persistent entity
223:23 - into our
223:27 - database before transforming our class
223:30 - to an entity let's first Define what is
223:32 - an entity so in Spring data jpa the term
223:35 - entity refers to a Java object that is
223:38 - meant to be persisted in a relational
223:41 - database using using the jpa or AKA Java
223:45 - persistence API so any entity represents
223:48 - a table in a database and each instance
223:51 - of an entity represents a row in a table
223:55 - so the entity Fields represent the
223:57 - column of the table and the state of an
224:00 - entity represents the data in a row so
224:03 - to map an object to a database with the
224:06 - jpa we need to annotate with enti and
224:10 - the class must have a no arcs
224:12 - Constructor which can be public or
224:15 - protect protected also it should contain
224:18 - an identifier ID and it's a best
224:22 - practice also to include the table
224:24 - annotation to specify the table name if
224:27 - the table is not specified so the table
224:30 - name default to the class name so spring
224:33 - data jpa uses these entity classes to
224:36 - generate SQL queries and to convert the
224:39 - results of those queries back into
224:41 - objects that you can use in your Java
224:43 - code so the actual database interaction
224:46 - is performed by the underlying jpa
224:48 - implementation such hibernate in our
224:51 - case so in the next next phase let's
224:54 - move on and transform our student Java
224:57 - class to an
224:59 - entity so as mentioned in the previous
225:02 - video we need within uh spring data GPA
225:05 - and if you want to transform a Java
225:07 - class to uh to an entity first of all we
225:10 - need to have an empty Constructor or a
225:12 - default Constructor with no arcs so
225:15 - let's go ahead and generate that one so
225:17 - here let's generate a Constructor and to
225:19 - generate a an empty Constructor just
225:21 - click or select the class name right
225:23 - here and then click okay so now we have
225:26 - our default Constructor let's move on
225:28 - and transform this student class or
225:31 - student Java class to an entity so as we
225:34 - mentioned and explained before all we
225:36 - need to do is first of all to have the
225:38 - entity annotation on the top or on the
225:41 - class level and here be careful the
225:44 - entity is coming or comes from the
225:46 - Jakarta persistence if you are using the
225:49 - spring uh version three also if you are
225:52 - using uh a lower version it will be Java
225:55 - x. persistence so here let's select this
225:58 - one and here directly we see that anj is
226:01 - highlighting the class name and if I
226:04 - highlight and check what is the error so
226:06 - it see it says that the persistent
226:08 - entities to student should have a
226:10 - primary key so we need to specify a
226:14 - primary key every time you create an
226:16 - entity and to provide a primary key it's
226:19 - so easy just go ahead and choose what is
226:22 - the primary key of your class or of your
226:25 - entity and add the ID annotation it's
226:28 - all also coming from the jackart
226:30 - persistence package and now we have our
226:33 - student entity so now let's go ahead and
226:36 - see if we are able to uh generate or to
226:40 - manipulate or to start the application
226:42 - Within These small changes so if I click
226:45 - here to start the application we see
226:48 - that the application is up and running
226:50 - and also let's see if we have any um any
226:55 - logs that we can use uh also we see here
226:58 - like starting the application and we
227:00 - also see that we have some uh some
227:02 - annotations or some logs from hibernate
227:05 - so here it's hibernate version uh
227:08 - 6.1.7 and also it's using the dialect
227:11 - post SQL dialect and the JTA platform
227:14 - implementation which is the no JTA
227:16 - platform and so and so forth so here the
227:20 - application is up and running and if I
227:22 - go to my database and I try to refresh
227:25 - this one and check the public schema
227:28 - also if I refreshed again I don't see
227:30 - anything spring and jpa and the the
227:35 - hibernate implementation of jpa they
227:38 - provide a tool and config configuration
227:40 - to autocreate and to autogenerate the
227:43 - tables within the database so in the
227:46 - next part let's go ahead and see how we
227:48 - can tell spring and tell spring data at
227:51 - jpa to be specific to generate or to
227:54 - autogenerate our
227:58 - database so now to to define the extra
228:01 - properties first I will stop the
228:03 - application and then I will go back to
228:06 - our application. yaml let me make it
228:09 - full screen
228:10 - and then we need to provide few
228:11 - properties so here within the properties
228:14 - we see here that we have spring. dat
228:16 - Source now at the same level of data
228:19 - source it will be spring and then jpa
228:22 - and then we can specify some information
228:25 - so here within jpa we have hibernate and
228:29 - then within hibernate we have this
228:31 - information or this property which is
228:34 - called ddl Auto so this ddl AO or like
228:38 - this mode it stands like the DL stands
228:41 - for data definition language and this is
228:43 - the behavior or like what we want
228:46 - exactly hibernate to do when we start
228:48 - the application so here we have uh five
228:51 - options first we have create this means
228:54 - that it will create the schema and
228:56 - Destroy previous data so you need to be
228:58 - careful when choosing this option this
229:00 - means that every time you start the
229:02 - application hibernate will create a new
229:04 - schema and destroy the previous data so
229:07 - you it's okay on on the development
229:09 - phase or like on the early phases of uh
229:12 - your application development since you
229:14 - don't have the schema fully implemented
229:16 - you can keep it as create otherwise I
229:19 - would say you keep it to uh validate or
229:21 - to update so the next option is create
229:24 - drop so create a drop it will create
229:27 - this schema and then at the end of the
229:30 - session it will destroy the schema so it
229:33 - will remove the whole database so it's
229:35 - like you don't have any database at all
229:37 - so we have also none so this mean that
229:40 - we want to disable this ddl Auto and
229:43 - this is valid uh for example in
229:45 - production mode if we want to use um a
229:48 - database migration tool like Flyway uh
229:51 - or liquid base to manage our database we
229:54 - have update so it will update the schema
229:56 - if necessary so if we don't have a
229:58 - schema it will create it and every time
230:00 - we make changes it will try to update
230:03 - the schema if there is CH changes and
230:06 - the final one is validate so it will
230:08 - validate the schema and it will make no
230:10 - changes to the database so assuming that
230:13 - we are managing our database using a
230:15 - database migration tool like Flyway for
230:18 - example and this option validate it will
230:20 - try to compare the existing database to
230:23 - the representation or to the Java
230:25 - representation in our code and it will
230:28 - validate this one so here let's go ahead
230:30 - and choose create since we still in
230:33 - development mode also we have other
230:36 - properties under jpa so for example we
230:39 - can also show the SQL queries so here
230:42 - when I choose jpa do show sqlquery uh
230:46 - show SQL here we see that by default
230:49 - it's false and then we can change it to
230:51 - true so this means when we run uh the
230:54 - application and we try to execute any
230:56 - query or any method that will interact
230:58 - with the database we will see the we
231:01 - will see the query displayed in the
231:03 - console then under jpa we have also
231:06 - properties and within these properties
231:09 - we have hibernate and format SQL so if
231:12 - we have an SQL query if we don't add
231:14 - this uh format option it will be
231:17 - displayed as a full line otherwise we
231:19 - can format this SQL query and it will be
231:23 - nicely displayed so the property for
231:25 - this one is uh spring jpa properties and
231:29 - then
231:30 - hibernate and then we have format SQL so
231:35 - this format SQL all we need to do is to
231:37 - set it to True also we we have another
231:39 - property which is available again under
231:42 - jpa so it's spring. jpa and here we have
231:45 - database so it's the second option so
231:48 - here this is the target database to
231:50 - operate on so it it's autodetected by
231:54 - default if you want to so hibernate will
231:56 - try or jpa will try to autod detect what
231:58 - is the database that we are using and
232:01 - also we can see it here in the logs so
232:04 - as mentioned here before so here as we
232:06 - can see using the dialect hibernate
232:08 - dialect and then post agress SQL direct
232:11 - so I will also copy this one and then we
232:14 - can even provide provide it manually so
232:17 - we can tell uh jpa that we are using
232:20 - this database to be more specific and
232:23 - more precise also we have another option
232:26 - which is called database platform so the
232:29 - database platform uh it's also so this
232:33 - property specifies the hibernate dialect
232:35 - for the Target database so the dialect
232:39 - defines the specific SQL syntax and
232:41 - features supported by the database in
232:44 - this case we will use this one just the
232:46 - one I just copied from uh from the
232:48 - console and to set it to indicate that
232:51 - the postgress SQL dialect should be used
232:54 - so now we have everything and all the
232:56 - properties that we need for jpa now
232:59 - let's go back again and restart our
233:00 - application and see what will happened
233:03 - so just click on start again and let's
233:06 - check what will happen within our table
233:09 - so first of all if we check the log
233:10 - right here so we see that since we used
233:13 - this show SQL true we see that we have
233:16 - the SQL query right here so this is the
233:19 - SQL query for creating the student table
233:22 - also we have this format SQL true so we
233:25 - have a formatted query all right so now
233:28 - if I go back and check my database in
233:31 - here so select public or the schema or
233:34 - even the database right here and click
233:36 - on refresh and here if we expand we see
233:39 - that we have one table right here so we
233:42 - have a table student and the table
233:44 - student contains all the information or
233:46 - all the properties that we provided ID
233:49 - first name last name email and age so
233:51 - the age is of type integer same for the
233:53 - ID and we have email first name last
233:56 - name of type varar which is the the SQL
233:59 - representation for the string type so
234:02 - now let's move on and see how we can
234:05 - again play more and more with the
234:08 - hibernate on the or the annotations for
234:10 - our
234:12 - entity what if we want to change the
234:15 - table name so by default this entity
234:18 - annotation it will use the class name as
234:22 - a table name but what if we want to have
234:25 - a different one so let's say for example
234:27 - I want to call my table students not
234:29 - just student so in this case we can use
234:32 - the table annotation and it always comes
234:36 - from the Jakarta persistence package and
234:38 - and here we can specify the property
234:41 - equals name and let's have a look on
234:44 - this annotation so here it says that
234:47 - specifies the primary T table of
234:49 - annotated entity so we need to have the
234:51 - entity annotation so additional tables
234:54 - may be specified using secondary table
234:56 - and so on so forth so here if no table
234:59 - annotation is specified for an entity
235:01 - class the default value applies so here
235:04 - for example we have entity and we have
235:06 - the name cast for example for cast
235:08 - customer and the schema we can also
235:11 - specify the schema so by default if we
235:13 - don't add this table annotation it will
235:16 - take or the entity annotation will use
235:18 - the entity name or the class name as a
235:20 - table name so here let's say for example
235:24 - T and score student just to T to say
235:27 - table student and if I rerun the
235:30 - application we will see that the
235:32 - database will change and the table will
235:34 - be again changed so here we see that
235:37 - create table even in this SQL query
235:40 - create table T underscore student so
235:43 - here if I refresh my tables we see that
235:46 - we have a table now it's named the
235:49 - student and also we have the same
235:51 - columns ID age email and so and so forth
235:54 - so this is the use case of this table
235:57 - annotation we also can have extra
236:00 - control on the different fields so for
236:03 - example if I want to change a column
236:06 - name there is an annotation called
236:08 - column
236:09 - and this colon annotation has a bunch of
236:12 - properties so we have name and here the
236:15 - name of the colum so defaults is the
236:17 - property of the field name we have
236:19 - unique notable insertable updatable
236:22 - colum definition table length and so and
236:24 - so forth so here we can specify many
236:28 - properties for the specified colum so
236:30 - for example let's start by changing the
236:33 - name so for example for this first name
236:35 - I wanted to have ccore F name just C to
236:39 - say colon and then F name again like we
236:42 - can use the same annotation for the
236:44 - other fields but let's just try on on
236:47 - only one so here if I restart my
236:49 - application and check again the database
236:52 - here even in the SQL query we see that
236:55 - we have again CF name so if I refresh my
236:59 - table right
237:01 - here we see that we have the first name
237:05 - is now called ccore f name as we
237:08 - mentioned in here so now we have our
237:11 - first name named to ccore F name also we
237:16 - have other properties that we can
237:17 - specify so in case for example I want to
237:21 - have extra or like I want to have some
237:23 - Precision or size so I can also use the
237:27 - length so as you can see here by default
237:30 - so let me make it full screen and as you
237:33 - can see the length of uh of a string by
237:36 - default is 225 so h I bernate will
237:39 - detect that automatically but I can
237:41 - specify for example the length of my
237:44 - first name should be exactly 20
237:46 - characters and if I restart my
237:48 - application just to recreate everything
237:50 - from scratch we see that here the CF
237:54 - name or the column first name it's a
237:56 - type varar and now the the length is 20
237:59 - instead of 225 you can increase it or
238:02 - you can even decrease it to have for
238:05 - example if you have some specific cases
238:07 - where you need for some spe specific
238:08 - field or colum to have uh a specific
238:11 - length so you you can use this property
238:14 - length to specify or to provide more
238:17 - Precision to that so here if I if I
238:19 - refresh my
238:22 - table and in the columns and again if I
238:25 - go to C name we see that the CF name is
238:27 - of type varar and the length of this
238:30 - varar is 20 characters so now let's say
238:35 - let's see if we want to have a unique uh
238:38 - um entry for specific column so for
238:41 - example for this email we know that
238:43 - emails should be unique per user or per
238:45 - student or per person so again I can use
238:49 - the colum annotation in here at this
238:51 - level and here there is a property
238:54 - called unique and the unique is by
238:56 - default equals false this means that we
238:58 - can have duplications for this specific
239:02 - colum but if we if we uh change it to
239:04 - Unique true and if I restart the
239:07 - application
239:09 - and let's first check the logs we see
239:11 - that we have here the email is of type
239:14 - varar 225 and after that we see that we
239:18 - have alter table if exists T student and
239:22 - add constraint this is the constraint
239:25 - name it's UK and this is generated uh
239:28 - value and we have this unique constraint
239:31 - for the column email and again if I
239:34 - refresh my table right here let's see
239:37 - what are the changes that we
239:40 - have so we see that we have an email
239:42 - right here and then we have the keys so
239:45 - first we have the T student P key p
239:48 - means primary and key it's uh for key
239:51 - and then we have the unique constraint
239:53 - applied on the email column right here
239:56 - so this is what exactly the result of
239:59 - this SQL query we can also add some
240:03 - extra uh some
240:06 - extra properties and constru brains
240:09 - let's say for example I have right here
240:12 - private string uh let's say just some
240:18 - colum just like that and now I will use
240:21 - the colum annotation and I can specify
240:24 - if this some colon is insertable or
240:27 - updatable let's say for example let's
240:29 - make it updatable true so by default any
240:33 - column is updatable true by default and
240:35 - then I can make it updatable false and
240:38 - we we have a specific or we might have a
240:40 - specific use case for uh a field that
240:43 - should not be updatable which is for
240:45 - example the creation date so we can have
240:48 - a creation date for any field or for uh
240:51 - for our entry in the database and we
240:53 - want we don't want this creation date
240:56 - field to be updatable every time so we
240:59 - can just make it updatable to false and
241:01 - also we have another property which is
241:04 - insertable and by default it's true we
241:07 - can make this insertable false so this
241:09 - means that we cannot create or we cannot
241:12 - insert value for this specific field so
241:15 - now let's stick with this updatable and
241:18 - here let's again restart the application
241:20 - and we will see that we might have
241:22 - another constraint so here if I refresh
241:25 - my table and for the T student we see
241:28 - that we have Sam column which is a varar
241:31 - and then we don't have any keys but
241:34 - hibernate will manage this automatically
241:36 - and will at and it will make this field
241:39 - called Sam colon not
241:43 - updatable in this part we will see how
241:46 - we can play a bit more with the IDS so
241:50 - when it comes to the identifiers of
241:52 - tables and especially when we use uh the
241:54 - type or the the the digit uh digits type
241:57 - which is integer uh float double um also
242:02 - long and so on so forth we can tell
242:04 - spring and hibernate to automatically
242:08 - generate the ID for us and to do that we
242:11 - can use an annotation annotation called
242:13 - generated value and this generated value
242:16 - again it's from Jakarta persistence API
242:19 - and let's have a look on this annotation
242:21 - so if I go to the definition of this
242:23 - generated value and have a look on the
242:26 - on the documentation for it so it says
242:28 - provides for the specification of
242:30 - generation strategies for the values of
242:33 - primary keys so the condition here it
242:35 - works only with primary keys so the
242:37 - gener ated value annotation may be
242:40 - applied to a primary key property or
242:42 - field of an entity of maid super class
242:45 - in conjunction with the ID annotation so
242:48 - we we need to have the generated value
242:50 - always within the ID annotation so the
242:53 - use of the generated value annotation is
242:56 - only required to be supported for the
242:58 - simple primary Keys use of the generated
243:01 - value annotation is not supported for D
243:04 - derived primary keys so we cannot use um
243:09 - the generated value annotation on
243:11 - derived primary keys for example like
243:13 - strings or composed keys so here also
243:17 - there is an important property which is
243:20 - the generation type so the generation
243:22 - type as you can see it's optional and it
243:24 - has a default value which is Auto and
243:28 - then the primary key generation strategy
243:30 - that the persistence provider must use
243:32 - to generate the annotated entity primary
243:35 - key and then let's have a look on the
243:37 - different types of the generation type
243:40 - so here if we go to the to the enam
243:43 - generation type we see that first we
243:45 - have table so the table indicates that
243:48 - the persistence provider must assign
243:50 - primary keys for the entity using an
243:53 - underlying databased table to ensure
243:55 - uniqueness so this means that hibernate
243:58 - will create a table within our schema
244:01 - and it will use that table to store the
244:04 - the IDS of the entities that we want to
244:07 - use again we have another property which
244:10 - is sequence so this indicates indicates
244:13 - that the persistence provider must
244:15 - assign primary keys for the entity using
244:18 - database sequence so database sequence
244:20 - it's something related to a database and
244:23 - it's like somehow like a table where we
244:26 - have a sequence of
244:28 - values then we have the identity so this
244:32 - means that indicates that the
244:33 - persistence provider must assign primary
244:36 - keys for an entity using data database
244:38 - identity column so the database or like
244:41 - the provider will use a database
244:43 - identity column to
244:46 - autogenerate the IDS also we have
244:49 - another property which is called uu ID
244:52 - and The UU ID is for Unique uh Universal
244:56 - unique identifier and this indicates
244:58 - that the persistent provider must assign
245:01 - primary keys for the entity by
245:03 - generating an RFC of type 4122 which is
245:07 - a unique Universal unique identifier and
245:10 - finally we have this one this AO which
245:13 - is always uh recommended and this
245:16 - indicates that the persistence provider
245:18 - should pick an appropriate strategy for
245:21 - the particular database so this means
245:23 - that when we when we set it to AO which
245:25 - is the default one hibernate will check
245:27 - within the within the database provider
245:29 - or the persistence provider and in our
245:32 - case for example it's postgress SQL and
245:34 - it will choose the appropriate and the
245:37 - best uh generation strategy for our
245:40 - database and here there is something
245:42 - which is really important so the
245:44 - autogeneration strategy may expect a
245:47 - database resource to exist or it may
245:50 - attempt to create one so it will attempt
245:53 - to create the resource for example let's
245:55 - say it uses a sequence so the auto uh
245:58 - the auto strategy will try or will
246:00 - attempt to create this resource if
246:02 - possible if not it will raise an
246:04 - exception telling that it's not able to
246:07 - create this one and for example I can
246:09 - give you an example from my my previous
246:12 - experience so Oracle databases they work
246:15 - with sequences and you need to manually
246:17 - create the sequence in order to use it
246:20 - as a generation type so now let's go
246:23 - back to our code and let's restart the
246:25 - application and see if we have any
246:28 - changes so first let's check the logs
246:31 - and as you can see first we have this
246:33 - hibernate uh query that was executed
246:37 - which is create sequence T student
246:39 - sequence starts with one and increment
246:42 - by 50 so here hibernate created a
246:46 - sequence called it tore student uncore
246:49 - sequence or seek to uh and it starts
246:52 - from one and the incrementation is done
246:54 - by 50 and then we have the table and we
246:57 - have the unique constraints that we that
246:59 - we added so now if I refresh again my
247:02 - tables we see that we have the student
247:05 - and now we have one sequence packet or a
247:08 - folder that was created if I expand it
247:11 - we see that we have a t student sequence
247:13 - which is of type big int and this is
247:16 - just a sequence as as you can see in the
247:18 - icon right here so now let's hit with
247:21 - this with the annotations that we can
247:23 - use within our entities now let's move
247:26 - on and see how we can persist data into
247:28 - the database and how we can perform uh
247:32 - queries like inserting reading updating
247:35 - deleting and so and so forth
247:40 - so when it comes to data persistence and
247:43 - to persist data in uh in a database
247:46 - spring provides us with a list of
247:49 - interfaces that we can use to simplify
247:52 - the life of developers so spring
247:55 - provides an interface called repository
247:58 - and this interface is extended by
248:01 - multiple other interfaces and we have
248:04 - here for example we have this repository
248:06 - and we have the crude repository and
248:08 - list crude repository and also on the
248:11 - left hand side we have the paging and
248:13 - sorting repository and list paging and
248:16 - sorting repository and all of them like
248:19 - the the basic one or like the first one
248:22 - is jpa repository which extends all
248:25 - these interfaces so if you extend or if
248:27 - you use the jpa interface or the jpa
248:30 - repository interface you have access to
248:33 - all these interfaces right here and all
248:36 - we need to do in order to to access or
248:38 - to have a data access layer in our
248:41 - application is to create an interface
248:43 - and extend one of these five interfaces
248:46 - that we see right here which is whether
248:48 - jpa repository list crude list paging
248:51 - and sorting crude repository or paging
248:54 - and sorting repository so each one of
248:57 - them comes with a list of methods
248:59 - predefined methods that we can use to
249:01 - operate or to to execute some SQL
249:05 - queries so the jpa Repository uh is
249:08 - designed to simplify the development of
249:10 - access layer code by abstracting away
249:13 - the common data persistent operations so
249:16 - it provides methods such as save find
249:18 - one find all delete and more allowing
249:22 - you to interact with underlying database
249:24 - without writing explicit SQL queries so
249:28 - this is the important thing and the
249:30 - important part of using jpa repositories
249:33 - or using the repositories from the
249:36 - spring data jpa and the jpa repository
249:40 - interface comes with some features first
249:43 - we have the crow operations Crow stands
249:45 - for create read update and delete which
249:48 - inherit inherits from the basic crud
249:51 - operations from these interfaces we see
249:55 - right here enabling you to perform
249:57 - standard database operations like saving
250:00 - entities retrieving entities by ID
250:02 - deleting and finding all entities and so
250:05 - and so forth also so we have query
250:08 - methods so jpa repository supports the
250:12 - creation of query methods based on
250:14 - method names by following name and
250:16 - Convention you can Define method
250:18 - signature that automatically generate
250:21 - the appropriate SQL queries for example
250:23 - if we want to have a method F find uh by
250:27 - first name and we provide the string
250:30 - first name as a parameter or find all by
250:34 - age uh greater than in age and so and so
250:37 - forth both so this can be implemented
250:39 - without writing explicit queries and we
250:42 - will see later on by example how we can
250:45 - implement this also we have the derivate
250:48 - query methods so along with query method
250:50 - based on method names jpa repository
250:53 - supports the creation of more complex
250:56 - queries using derivate query methods so
250:59 - this method derive the query based on
251:01 - the structure of the method signature
251:04 - and the names of the parameters so this
251:06 - allows you to Define queries with
251:08 - conditions and join multiple entities
251:11 - together we can also have a custom query
251:14 - definition so in addition to the query
251:16 - method the jpa repository allows you to
251:19 - Define custom queries using the at query
251:23 - annotation or the query annotation and
251:25 - you can write J jpql which is the Java
251:28 - persistence query language or native SQL
251:31 - queries and map the query result to The
251:34 - Entity or a custom dto that you want to
251:37 - return
251:38 - so by utilizing this the features
251:40 - provided by the jpa repository you can
251:43 - significantly reduce the amount of
251:45 - boilerplate code required for data
251:48 - access operations and Leverage The Power
251:50 - of query derivation and handle p
251:53 - pagination and sorting with ease in your
251:57 - spring data jpa based application so now
252:00 - let's move on and see in action how we
252:02 - can create uh repositories and how we
252:05 - can generate methods and how we can even
252:08 - persist data to create a repository all
252:11 - we need to do is to create a new
252:13 - interface so select new and then Java
252:16 - class and select interface right here
252:19 - and let's call our interface student
252:22 - repository so in this way we are
252:25 - creating a new interface and to
252:27 - transform this student repository
252:29 - interface to jpa repository all we need
252:32 - to do is to extend the jpa repository
252:36 - and the J APA repository is a generic uh
252:39 - interface and let's see here click
252:41 - always on download source to see
252:43 - everything and all the source code and
252:45 - here we see that we have a t and ID so
252:48 - the T represents the entity and the ID
252:50 - represents the identifier of our entity
252:54 - so let's go back here and provide these
252:56 - types so here this is a jpa repository
252:59 - for our student entity okay so this is
253:03 - like from the name but here like our
253:05 - goal is to create a repository for our
253:08 - student object so select the student
253:10 - here and then comma and the type of the
253:14 - ID so in our case the type of our unique
253:17 - ID of this student table is integer as
253:21 - you as you can see here so we have Inger
253:23 - ID annotated with the ID annotation so
253:26 - this is how you can identify or you can
253:29 - check the ID and that's it that's pretty
253:32 - much it and here even you don't need to
253:35 - add any repository or any component
253:38 - annotation because spring data jpa will
253:42 - automatically understand that this is a
253:44 - repository and it will transform this uh
253:48 - this interface to to a managed be or to
253:51 - a component or to a repository all these
253:54 - names are valid for the jpa repository
253:58 - so now let's move on and use this jpa
254:00 - repository and try to persist some data
254:04 - now in order to use this student
254:06 - Repository all we need to do is to
254:08 - inject it somewhere in some class or in
254:10 - another spring bean and let's inject it
254:13 - in this first controller so I will make
254:15 - it full screen and here I can also even
254:19 - clean up this one and here I will create
254:22 - a private final student repository and
254:26 - let's call it repository or even student
254:28 - repository and then we need to generate
254:30 - of course a Constructor
254:32 - parameter and here we see that we will
254:35 - use the Constructor injection so as I
254:37 - mentioned before we no longer need to
254:40 - use The autowired annotation so here we
254:42 - have our repository available and now we
254:45 - can just use it so here in in this post
254:49 - method so let's say slash students and
254:54 - like to follow the namings so now we
254:55 - have our first controller and I want to
254:58 - use the post for the Post mapping SL
255:00 - student and here as a request body let's
255:03 - change this one to type student okay so
255:07 - here we have the student and I will just
255:10 - rename this one to student so then it
255:14 - will not return a string but I wanted to
255:17 - return the student object instead so
255:19 - here it will return the student so I we
255:22 - will go back to this later on and here
255:25 - all we need to do after receiving the
255:27 - student object all we need to do is to
255:30 - call the repository instance that we
255:33 - created and then we have a method called
255:36 - save save so the save it takes an S of
255:39 - type entity so here if I pass student so
255:44 - this means that the student will be
255:46 - persisted and as you can see this method
255:49 - it will it takes the entity as parameter
255:52 - and it will return the same entity of
255:54 - the saved one so all I all I need to do
255:57 - is to just return repository Dove and
256:01 - now let's start the application and go
256:03 - to postman and start this and test this
256:07 - method so this is our Postman interface
256:10 - again let's change the url to
256:13 - students and then we have a body and for
256:16 - the body it will be exactly the same way
256:19 - as the student object right here so we
256:22 - need the first name last name email and
256:25 - age so first name last name email and
256:28 - age and I will copy these ones and then
256:30 - I will just create an object of type
256:34 - student so let me remove this and then
256:36 - adding The Columns everywhere so here
256:40 - and also for the AG and here for the
256:42 - first name let's say Ali and for the
256:45 - last name let's say bu Ali and for the
256:48 - email so this is my email if you want to
256:51 - get in touch with me so it's contact at
256:54 - alibu coding.com and age let's say I'm
256:59 - 34 years old I'm getting old but it's
257:02 - totally fine so here we have our Json
257:07 - representation for the student object
257:09 - now if I click on send let's see what
257:12 - will happen so first we see that we have
257:14 - this 200 okay and we persisted our
257:18 - object and now we have the ID equals 1
257:21 - so if I go back to my
257:23 - database click on here let's refresh the
257:27 - tables and if I open this student we see
257:30 - that we have an object that that got
257:33 - persisted in the database so here we
257:36 - still have the is uh some colum colum
257:39 - that we added but we can ignore it for
257:41 - the moment and here we see that we have
257:44 - the object or the user or the student
257:46 - that we just inserted so let's go ahead
257:48 - and insert another one and see the
257:50 - changes so here let's
257:53 - say John John
257:56 - do and here for example let's say John
258:00 - at alibu coding.com and let's leave the
258:03 - age as it was and hit enter so so here
258:07 - we see that we have a different ID and
258:09 - we return the saved object so if I go
258:12 - back to my
258:13 - database and refresh so here you have
258:16 - the icon to refresh or to to reload the
258:18 - page and now we see that we have this
258:21 - user again inserted so here let's just
258:24 - check again um our entity and we see
258:28 - that the email is unique okay so now if
258:31 - I go back to
258:32 - postman and try to insert the same
258:35 - object click on send and we see that we
258:39 - have a 500 internal server error so if I
258:43 - go back to anj and inspect this one
258:46 - let's see the type of the exception so
258:49 - here we see that we have an error
258:50 - duplicate key value violates unique
258:53 - constraint for this constraint that we
258:55 - created before so just to remind you
258:58 - this is the constraint that we created
259:00 - for the Unicity of the email so it's
259:04 - this one and now we see the except that
259:07 - we have a violation and even we have
259:09 - more details it says that the key email
259:12 - like the field called email and the
259:14 - value John alibu coding.com already
259:18 - exists so hibernate is performing all
259:21 - the checks and checking that the email
259:24 - should be unique within our database so
259:27 - this is how we can persist an entity now
259:30 - let's see how we can update an entity
259:33 - and how we can delete fetch all and the
259:36 - operations that we can use now let's
259:38 - Implement another method that will
259:40 - return a student by its ID so here we
259:43 - have student and then I will pass as a
259:46 - path variable and let's say
259:48 - student- ID and here it will return just
259:52 - a single student so let's change the
259:54 - type and here find student by ID so this
259:59 - will be the method name and of course we
260:01 - need our path variable and here let's
260:04 - call it student - ID and then tiger ID
260:10 - so here we have our method ready and now
260:13 - all we need to do is to use the method
260:16 - find by ID and here this find by ID it
260:20 - will return an optional of type student
260:23 - so here let's pass first the ID and then
260:26 - let's say or
260:28 - else for example null okay so if we
260:32 - don't find the student with a specified
260:34 - ID it will return a null object or let's
260:37 - say even some new student okay like an
260:41 - empty student object so let's restart
260:43 - the application and let's go to our
260:46 - Postman and try to test this endpoint so
260:49 - first let's insert uh an object or like
260:52 - few a few elements so this one and this
260:56 - one and we have three elements so here
260:59 - if I test again the/ student we see that
261:02 - we are returning three elements with the
261:04 - specified uh object and values that we
261:07 - provided and now if I say SL students
261:10 - SL1 so it should return this first
261:13 - object and if I click on send so we see
261:16 - that we have only one object and here
261:18 - before it was a list so just to make
261:20 - sure and as you cane can see it's a list
261:23 - in here and it's a list of objects so
261:26 - now SL students
261:28 - SL1 and if I try to find an object that
261:32 - does not exist so for example a student
261:34 - with the ID number 10 which which we
261:36 - don't have in the database we see that
261:38 - we have an empty object with n values
261:41 - and this because when we retrieved the
261:45 - the student we say or else new student
261:48 - or we can just say or else null or
261:50 - whatever you want so this is how we can
261:53 - retrieve and this is the the method find
261:56 - by ID that we can use to retrieve an
261:59 - object by its ID so now in the next part
262:02 - let's see how we can create a custom
262:04 - query and for example find a student by
262:08 - the first name now let's see how we can
262:10 - retrieve the list of students that are
262:12 - persisted in the database so I will
262:15 - duplicate first of all this method and
262:17 - instead of post I will just use get so
262:21 - here it will be get mapping and I will
262:23 - use the same URL students and here like
262:27 - I will say find all students and here
262:30 - instead of returning a single student I
262:33 - need to return a list of students so
262:36 - here I will use list as a return type
262:38 - and then I will just give it the type
262:40 - student so here list of students and
262:44 - here we don't have any request body
262:46 - since it's a get and we don't have any
262:49 - parameters and now instead of saving we
262:52 - have a method called find all so this
262:55 - find all method will return all the
262:58 - students that we have in the database so
263:00 - let's restart the application and go to
263:03 - our Postman and test this one so
263:06 - opening Postman first I need to persist
263:09 - few data so this is the first one second
263:13 - one and let's say this is the third one
263:17 - and again I will duplicate this tab and
263:20 - here I will change this one to get and I
263:22 - don't have a body and all I need to do
263:25 - is to click on send so here we see that
263:28 - we have this 200
263:30 - okay and we see that we are fetching and
263:33 - displaying all the students or all the
263:35 - objects that we have persisted in the in
263:38 - the database so it's Ali B Ali and we
263:41 - see that the email is changing and this
263:44 - is contact one and contact 31 the one
263:47 - that we just inserted so this is how we
263:49 - can retrieve data from the database and
263:52 - as you can see here I did not create any
263:56 - SQL query for that but all these methods
263:58 - they come from the spring data jpa or
264:02 - from the jpa repository that we extended
264:05 - right here so if I open this one we see
264:07 - that we have a bunch of method right
264:09 - here and even this find all it comes
264:12 - from other uh from other interfaces so
264:15 - here we have the save all we have this
264:17 - find all method that we just used so
264:19 - click on download source and this is all
264:22 - the methods that are available so let's
264:25 - see more and more methods and try to
264:27 - perform the crow operation so then so
264:30 - here we have the create and you have the
264:33 - read here so let's check the delete op
264:36 - operation and the update operation so
264:39 - again let's duplicate this method right
264:42 - here and here it will be SL student SL
264:46 - search for example and then let's say
264:48 - student name okay so here it will return
264:52 - also a list of students so I'll just
264:54 - copy this one and replace it in here so
264:58 - here we will say find students by first
265:01 - name or by name it's also okay and here
265:05 - we need to stent name instead of student
265:07 - ID and the type should be of type string
265:11 - but here as we can see we don't have any
265:14 - method that will return uh student by
265:18 - name or by first name so what we need to
265:20 - do we need to go to our student
265:23 - repository right here and let me show
265:25 - you how we can create a method that can
265:28 - filter or behind that hibernate will
265:32 - generate the query for for us so what we
265:35 - want to do is searching for the list of
265:39 - students so first we need to provide the
265:41 - type which is list and the object which
265:45 - is our entity or a d or any other object
265:48 - that hibernate can be able to map it so
265:52 - we have list of student and then our
265:55 - method should start find all by and find
265:58 - all because we want to have a list if
266:01 - for example we just we want to return
266:03 - only a single student we can use find by
266:06 - instead okay but in this case we want to
266:09 - use find all by and then after the find
266:12 - all by all I need to do is to specify
266:16 - the colon name like the Java colon name
266:19 - like from the class that I want to use
266:21 - it as a filter so for example here I
266:24 - want to use first name so you don't use
266:27 - the ccore F name but you use the Java
266:30 - field of the Java class okay so I want
266:33 - to use the first name as my filter so
266:36 - all you need to do is to
266:38 - use a capital letter for the first uh
266:42 - for the field name so as you can see
266:45 - here already anate so this this uh is
266:48 - part of the ultimate version this Auto
266:50 - completion and as you can see hibernate
266:53 - uh sorry anj is already suggesting first
266:56 - name as a filter okay so now I say first
267:01 - name and also I can add like Okay so
267:05 - this means that the first name so
267:07 - contains this value or I can say
267:11 - containing so containing this means any
267:14 - string I pass it should be part of the
267:17 - first name so for example if I have a
267:19 - first name Ali if I pass just L it
267:22 - should return and filter all the
267:24 - students containing this L letter so
267:27 - here all I need to do is to pass my
267:30 - string P so here I P me uh means
267:33 - parameter so I'm um on on purpose I
267:36 - mentioned P because I don't you don't
267:38 - need to specify first name for example
267:41 - so because the type what really matter
267:44 - so the type of the first name here
267:46 - should match the type of the parameter
267:48 - that you are passing right here okay so
267:50 - now we have our method let's go back to
267:53 - our controller and call this method to
267:56 - return the list of students so here we
267:58 - have find all by and here we have first
268:02 - name containing and then when we start
268:04 - the application and when we execute the
268:07 - query we will see what is the output of
268:09 - this query so here instead of this
268:11 - string ID let me just change it to name
268:15 - and here pass name as a parameter now if
268:18 - I restart the application and let's go
268:20 - back to postman so here I can clean the
268:23 - console so we can see the query that
268:25 - will get executed I will go back to
268:27 - postman first I need to insert some data
268:30 - so this is the first one and let's call
268:33 - the second one John and let's let's call
268:36 - uh C for
268:39 - example and now let's go back in here
268:42 - and now instead of passing this um this
268:46 - ID I can pass for example SL Ali okay
268:49 - and if I click on send we see that first
268:52 - we have a bad request let's check why we
268:54 - have that so we have a bad request
268:57 - because in enj here when we created this
269:01 - method we added SL search and with
269:05 - within the ad and the object or the
269:07 - value Ali so spring is trying to map the
269:10 - Ali to an integer and as we can see here
269:13 - let's check the exception and it will
269:15 - say that it was not able to map or to
269:19 - convert the value Ali to an integer ID
269:22 - so now let's go back to uh to our enj
269:25 - and also I need to insert some other uh
269:28 - data and here let's click on send and
269:31 - then also John for example and let's
269:35 - change this and click on send again
269:39 - because I guess I uh it was it was not
269:41 - inserted before so now if I go back to/
269:44 - students SL search and now if I pass Ali
269:47 - as a parameter and click on send so we
269:51 - see that we have a list containing this
269:54 - object which is Ali B Ali and so on and
269:57 - so forth now let's go back to the
269:58 - console and see the query that was
270:01 - generated so here we have select and we
270:04 - have the fields from from student where
270:08 - the CF name so hibernate was
270:12 - automatically capable of transforming
270:15 - this first name to use the colon called
270:18 - ccore f name and here we have like and
270:22 - then so this is the value because it's
270:24 - an interrogation Mark and then escape
270:27 - the the back slashes so this for example
270:30 - in case we pass a back slash as a value
270:33 - so this is the query that was generated
270:35 - behind and all this came from just this
270:38 - method that we created right here so we
270:40 - just told spring data jpa to search the
270:44 - list of students by first name
270:46 - containing so any first name or like the
270:49 - first name contains the a portion of the
270:53 - string that we pass right here all right
270:55 - so now you understand how we can create
270:58 - queries now let's move on and see how we
271:00 - can delete objects for example now let's
271:03 - create another method to delete student
271:06 - so here I will use a delete mapping and
271:10 - then for the delete for the delete
271:11 - mapping it will be/ students slash and
271:14 - then I will need the student ID so it
271:17 - will be student- ID and then I will have
271:20 - a public void and then I will call it
271:23 - delete so here of course we need a path
271:26 - variable and then let's call it student
271:29 - ID as you mentioned before and then I
271:32 - will need the tiger ID and all we need
271:36 - to do is to call our
271:40 - repository. delete and then we have a
271:44 - method to delete whether to pass the
271:47 - whole student entity or just delete by
271:50 - ID so the delete by ID we can just pass
271:53 - the ID and here we can also use as
271:56 - explained before the response status
271:59 - annotation and here for example let's
272:02 - say accepted or or just Okay so for
272:05 - example let's say HTTP status and of
272:08 - course we need to import the HTTP status
272:11 - so now let's restart the application and
272:13 - let's go ahead and try deleting student
272:16 - by the ID so now the application is up
272:19 - and running again so let's go back to
272:22 - postman and of course I need to insert
272:25 - some
272:26 - students and I will insert another one
272:29 - so here we have two students Also let's
272:31 - check in the database so let's open the
272:34 - student table and we see here that we
272:36 - have two students created and now if I
272:40 - try to delete the second one or the
272:42 - student with the ID number two let's see
272:44 - what will happen so now let's duplicate
272:48 - this tab so duplicate Tab and then
272:50 - instead of post I want to send a delete
272:53 - and then SL student
272:55 - slash2 and all I need is to do is to
272:58 - click Send and we see that we have 200
273:01 - okay and also let's go back and check in
273:03 - the database so if refresh we see that
273:06 - the student with the ID number two was
273:09 - successfully deleted all right so we
273:12 - performed all the crud operations we saw
273:15 - how to filter we saw how to create um a
273:17 - custom method using the jpa repository
273:21 - and now let's see how we can
273:23 - perform and add relationships to our
273:26 - entity so here we have our student
273:29 - entity and let's try to create other
273:32 - entities which will have some relation
273:34 - and mapping between
273:37 - them so in order to uh create mappings
273:41 - and relationships with different
273:42 - entities first we need to create the
273:44 - entities that we want to uh to create
273:47 - the mapping for so here let's assume
273:50 - that a student is part of a school or
273:52 - studies in a school and a student has a
273:55 - profile so first let's start with
273:57 - creating uh The Entity school so I will
274:01 - create an entity called school and then
274:04 - of course we need the entity annotation
274:06 - so we don't need the table because we
274:08 - can leave it just to school and then we
274:11 - need the ID so this is will be the
274:13 - identifier and then generated value and
274:16 - let's say private integer ID so this
274:19 - will be the ID of the school and simply
274:21 - let's say this school has a string
274:23 - school name or just a name okay so this
274:26 - is our school entity and of course we
274:29 - need to generate Getters and Setters so
274:32 - let's select both of them and generate
274:34 - Getters and setters for the ID and the
274:36 - name and also let's generate a
274:39 - Constructor and this Constructor we can
274:41 - say a Constructor using just the name
274:44 - and Another Empty Constructor because if
274:46 - you remember we need that so here we
274:49 - have our school entity ready now let's
274:52 - move on and create the profile entity
274:55 - and then we will start implementing
275:00 - relationships now let's create the other
275:02 - entity which is will be the student
275:06 - profile so the student profile again we
275:08 - need the entity annotation and we need
275:12 - also the ID so this will be the
275:14 - identifier and it will be a generated
275:17 - value managed by hibernate and then we
275:19 - will need a private aner ID and then
275:23 - let's say the the student has a private
275:26 - string bio so this will be like just a
275:29 - bio or description for the student we
275:31 - can also add many other fields for the
275:34 - profile but for now let's just keep it
275:36 - simple and let's generate now Getters
275:39 - and Setters so let's select both of them
275:42 - and then again let's generate a
275:44 - Constructor let's generate an empty one
275:46 - and let's also generate a Constructor
275:49 - using the bio so we can just create or
275:51 - in instantiate user uh student profile
275:55 - just using the bio so now we have our
275:58 - student profile and stent School ready
276:01 - to use let's move on and understand the
276:03 - class diagram that we need to implement
276:05 - and the relationships between these
276:07 - three entities this is how our class
276:11 - diagram looks like so as mentioned
276:13 - before we have one student and a student
276:16 - has a student profile so the student has
276:18 - only one profile so that's why we see a
276:21 - onetoone relationship between the
276:24 - student and the student profile and then
276:26 - a student studies in one school so here
276:29 - that's that's why we have a relation
276:32 - from the student to the school which is
276:34 - mapped with the one right here and then
276:37 - the school has many students so one
276:40 - school has zero or many students so this
276:43 - means that we can have a school but
276:45 - without any students yet but what if we
276:48 - have a student the student should be
276:50 - assigned to one school so this is how
276:53 - our class diagram looks like now let's
276:55 - start implementing the relationship
276:58 - between these three entities and we will
277:01 - start with student and student profile
277:04 - which will be one to one
277:06 - relationship now let's create the first
277:08 - mapping one to one between the student
277:11 - and the student profile so I will move
277:13 - this to the right so I'm going to split
277:15 - it and move it to the right to have both
277:18 - classes open at the same time so first
277:21 - what we need to do so let me first
277:23 - remove this column because we don't need
277:25 - it anymore and first thing we need to do
277:28 - is to create an object or a field of
277:32 - type student profile inside this student
277:34 - stent class so let's go ahead
277:38 - private student profile and let's call
277:41 - it student profile okay now in the from
277:46 - the other side we need also to create an
277:49 - object or a field of type student in the
277:51 - student profile but we will come back to
277:53 - this just in a few moments so now to
277:57 - declare and to tell hibernate that this
277:59 - is a onetoone uh relationship between
278:02 - the student and the student profile or
278:04 - we need to do is to add the one to one
278:07 - annotation and this one: one annotation
278:09 - comes with some properties first we need
278:12 - the property mapped by and this mapped
278:15 - by should reference to the field of type
278:18 - student in the student profile so let's
278:20 - say here student and then I will explain
278:23 - later on and that's it so here we have
278:26 - one: one and also we can add the cascad
278:30 - type A cascad type. all so this means
278:33 - this cascading type this this means if I
278:35 - perform or if I delete a student this
278:38 - means automatically I will remove the
278:40 - student profile at the same time without
278:43 - even performing a delete operation on
278:45 - the student profile itself now from the
278:48 - other hand on the student profile I need
278:51 - to create a field of type student so
278:54 - here let's call it student and here be
278:57 - careful this student should be exactly
279:00 - the same as the object mapped by because
279:03 - the mapped by will look for an object of
279:06 - type student called student so for
279:08 - example just an example if I say St and
279:12 - I start the application so the
279:13 - application will fail because here in
279:15 - the student profile we don't have any
279:17 - attribute or field called student so you
279:21 - need to be careful about this one and
279:23 - then we need to add one to one
279:25 - annotation also from this side and now
279:28 - let's define where to add the join
279:30 - column so this means because you know in
279:33 - class diagrams where when we have a
279:35 - relationship we need to have a foreign
279:37 - key in one of the tables so here our
279:40 - primary entity is student and then we
279:43 - have the student profile so we can
279:45 - create a student but we can Skip and
279:48 - update the student profile later on so
279:51 - this means that the student is the
279:53 - primary entity and the student profile
279:56 - is the secondary one so in this case we
279:59 - need to add the join colum annotation so
280:02 - here we have a join colum so this means
280:05 - that we want to declare a join column
280:07 - let's give it a name for example student
280:10 - andore
280:12 - ID so this means that when we start the
280:15 - application we will have an extra field
280:19 - in the student profile class or table
280:22 - having the name student ID so let's
280:24 - start the application and check that all
280:27 - right so the application is up and
280:28 - running let's check the logs first of
280:30 - all so here we have first we are
280:33 - creating the school the table school so
280:36 - this we will come back to this one later
280:37 - on and then we have a student profile
280:40 - and after that we have the table called
280:43 - the student so here for the student we
280:45 - have the primary key which is the ID and
280:48 - in here we have the student profile and
280:50 - the student profile we see that
280:52 - hibernate created a new field called
280:55 - student ID and it chose an integer as
280:58 - the type so the integer it chose it from
281:01 - the ID or the ID type of our student
281:04 - class so now let's go back let's go
281:06 - ahead and check the tables right here so
281:09 - if I refresh we see that we have three
281:12 - tables so here if I open the student
281:14 - profile we see that we have one foreign
281:17 - key and if I expand this one we see that
281:20 - we have this foreign key with these
281:22 - constraints so FK for foreign key and
281:24 - this is the key or the ID for this
281:26 - foreign key and this one it's the field
281:29 - student uncore ID which is the field
281:31 - that we defined already and it refers
281:34 - the table called tore student with the
281:37 - ID or the field or the primary key
281:39 - called ID so in this way we performed or
281:43 - recreated our first relationship one to
281:45 - one between student and student profile
281:50 - so now let's go ahead and create the
281:52 - mapping between the student and the
281:55 - school all right now let's move on and
281:58 - create the relationship between the
281:59 - school and the student so we said that
282:02 - the relationship between the school and
282:04 - the student student is one too many this
282:06 - means that the school has many students
282:09 - and students can study in one school so
282:13 - let's start from the school side here we
282:16 - need to create first of all a list of
282:19 - students so because here we have one
282:24 - school can figure out many times in one
282:27 - in multiple students so this means like
282:29 - this the school has multiple students so
282:33 - I will create a list of students let's
282:35 - call it students and then we need to add
282:39 - The annotation one to many so this means
282:43 - one school can figure out or can be uh
282:48 - or can exist in many students lines or
282:51 - many students Row in the students table
282:54 - that's how or that's why that's how we
282:56 - can determine what is the type or which
282:59 - annotation to use so then within the one
283:02 - to many we need an the attribute Mapp it
283:05 - by and the Mapp by should be exactly the
283:09 - same like the one to1 should be for
283:11 - example in this case school and the
283:13 - school should be an attribute of type
283:16 - School in the student. Java class or the
283:19 - student entity so the first thing is to
283:22 - create a list of students when we have
283:25 - one to many so here from the school side
283:28 - just as I mentioned before we have a
283:30 - list of students and then this list of
283:33 - students so any time or every time you
283:35 - have a list here just go ahead and don't
283:38 - think twice and use the one too many
283:41 - annotation and also use the ma by
283:44 - attribute to map this list of students
283:47 - to the school from the other side and of
283:50 - course let's not forget to generate
283:51 - Getters and Setters so let's generate
283:53 - Getters and Setters for the for the
283:56 - students let's click okay and now we
283:59 - have students Getters and Setters so let
284:02 - me just move them to the bottom and now
284:04 - we have our student list so this is how
284:07 - we can create a one too many mapping so
284:10 - now let's move on and create the many to
284:13 - one mapping from the other side so now
284:16 - let's perform the the link and the
284:18 - mapping from the student side so here
284:21 - let's create a
284:23 - private school field let's call it
284:26 - school as exactly the name right here so
284:30 - then soic colon and here so this means
284:34 - that we have many students to one school
284:37 - so many students can study in one school
284:40 - and every time you have the Min to one
284:43 - annotation always think about adding the
284:46 - join column so here let's give it a name
284:50 - so here let's say school ID school
284:53 - uncore ID so now if I restart the
284:56 - application we will see all the changes
284:59 - that we will have within our database
285:01 - and of course let's not forget
285:03 - generating getter and Setters so I will
285:05 - generate the Getters and Setter and also
285:08 - the student profile which I guess we
285:10 - forgot the last time so let's click okay
285:13 - and also let me move them to the bottom
285:15 - and now let's restart our application
285:18 - and see the
285:19 - changes so here first we can also check
285:23 - the check the logs so here we have alter
285:27 - table student profile if not exist and
285:30 - then we have alter table to student and
285:33 - we are adding all the references and the
285:35 - links and the relationships so here
285:38 - let's open this again and let's refresh
285:41 - the tables so we see that we still have
285:44 - three tables but let's let's check now
285:46 - the school uh sorry the student table we
285:49 - see that we have two foreign keys so
285:51 - here we have the t uh two keys for sorry
285:55 - and then we have one foreign key which
285:57 - is this one which is called school ID
286:00 - and it's referencing the school and the
286:02 - ID from the school it and here from the
286:05 - school we have again the ID and the name
286:08 - and we don't have any other foreign keys
286:10 - because the foreign key belongs to the
286:12 - student table and the same here for the
286:15 - student profile we have again our
286:18 - student ID which is reference the T
286:20 - student ID so like this we are able and
286:24 - this is how we can perform and create
286:27 - mappings between the different entities
286:29 - using annotations from the jpa and Hyper
286:32 - Nate and using spring data jpa now let's
286:36 - move on and see how we can insert Data
286:39 - before we move on to implement the
286:41 - controllers let me first show you a way
286:43 - how you can check that you implemented
286:46 - correctly the mappings between the
286:47 - different entities so here open the
286:50 - database and let me make it a bit full
286:53 - screen and then on the on the schema
286:56 - that you have or the database that you
286:57 - created right click and then you have
287:01 - this diagram menu and then you can click
287:03 - on show show diagram so here it will
287:07 - show maybe two options maybe not for you
287:09 - but click on database schema if it shows
287:12 - the diagram type so then let me close
287:15 - this one we see here that we have two
287:19 - the three tables that we already created
287:21 - we have the student we have the school
287:23 - and we have the student profile so let
287:26 - me just organize a little bit and here
287:30 - let's move this
287:31 - one and then also you have this um this
287:35 - link right here and then when we make
287:38 - when you make for example like when when
287:40 - you move entities and so on so forth and
287:42 - to organize these lines right here all
287:45 - you need to do is to click on apply
287:47 - current layout and it will adjust itself
287:50 - in a smooth way so here we have our
287:54 - student table which also named tore
287:57 - student and also if you highlight it you
288:00 - will see also the the script or the SQL
288:03 - script script for it and then we have
288:05 - here the student profile and we see that
288:07 - we have the student ID as a foreign key
288:10 - so the the primary key will be with um
288:13 - with this golden key and the foreign key
288:16 - it will be with blue one and the same
288:18 - here for the student and we see also
288:20 - that we have the school so now let's
288:23 - move on and start creating the
288:25 - controllers for the the school and let's
288:29 - Implement few methods to insert some
288:31 - school and then insert students and
288:33 - assign them to school school and see how
288:35 - we can do that now let's create our
288:39 - school controller so right click and
288:42 - then new Java class and let's call it
288:44 - school
288:46 - controller and then of course we need
288:49 - our rest controller annotation and now
288:52 - let's create our first post mapping and
288:56 - then it will be slash schools and then
288:59 - it we have a public school and it will
289:03 - be create or save for example and here
289:06 - we have our request body and then we
289:10 - need the school object so request body
289:13 - it will be object of type school and
289:16 - then let's name it school so after that
289:19 - we need of course to inject our
289:21 - repository so it will be private final
289:25 - School repository which we don't have
289:27 - for for the moment but we will create it
289:30 - in just a few seconds and let's call it
289:32 - school Repository and now even if you
289:35 - don't have it so here just highlight it
289:37 - and use the autoc completion and it will
289:39 - suggest you to create a class cor
289:41 - repository or an interface or enam and
289:43 - so on so forth so in our case we want to
289:46 - create an interface School repository
289:48 - and we want to create it in the same
289:50 - package so let's just hit enter and here
289:54 - we just made a typo so let's rename this
289:56 - one so let's call it school repository
290:01 - and then of course we need to extend the
290:03 - the jpa repository and we need to pass
290:07 - this schol as an object and integer for
290:10 - the ID then let's go back to our
290:12 - controller and here we need of course to
290:15 - add a Constructor so let me make this
290:18 - one full screen and now we have our
290:20 - school repository and now we can use it
290:24 - so here in this method all we need to do
290:26 - is just return School repository Dove
290:30 - school not save all just save and then
290:33 - this schol that we get as a parameter so
290:36 - then I will just duplicate this one and
290:39 - instead of Opp post mapping I will
290:41 - create a get mapping so now you are
290:43 - familiar how we create controllers how
290:45 - we return objects and so on so forth so
290:47 - we don't have anybody and we need to
290:51 - return a list of schools so here we have
290:54 - a list and then let's import this list
290:57 - and then let's say find all and here
291:00 - instead of save let's say find all all
291:04 - all right now let's start the
291:07 - application and insert some schools and
291:10 - since we also have our student
291:12 - controller which is already named uh
291:14 - first controller so let's go ahead and
291:16 - just rename it and call it student
291:20 - controller to be consistent so now let's
291:23 - start the application and go to postman
291:25 - and start our new API and see how we can
291:28 - insert schools and assign students to
291:32 - schools so our application is up and
291:34 - running now let's move to postman and
291:37 - test the the school controller and try
291:39 - to insert some schools and then let's go
291:42 - and insert also some
291:45 - students now let's duplicate this tab
291:49 - and then instead of students it will be
291:52 - schools and in the body we will need
291:55 - only one attribute which is the name so
291:58 - let's just change this one and let's
292:00 - call it alibu school and here all I need
292:05 - to do is to click on
292:06 - send and here we see that we have a 200
292:10 - okay so this means that the school was
292:12 - inserted and we see that we have the ID
292:14 - and the student for now it's not because
292:17 - we don't have any students assigned to
292:19 - this school yet also let's go to the
292:21 - database and check that so here if I
292:24 - refresh my database and open the school
292:27 - table we see that we have the school
292:29 - that we just inserted called alibu
292:32 - school now if if I want to insert a
292:35 - student so let's see the structure we
292:37 - have right here we have the first name
292:40 - last name email and age and also we have
292:43 - an object called school so let's go to
292:46 - postman and structure and create an
292:48 - object of type student to insert the
292:51 - student and assign it to the school that
292:53 - we just created so here let's go back to
292:55 - the first tab where we have the school
292:58 - the students to insert and here I all I
293:01 - need to do is to add another attribute
293:03 - mute of type school and this one is an
293:07 - object so here and all I need to provide
293:10 - is the ID because spring data jpa uses
293:14 - the ID to insert an object as you can
293:16 - see the school that we inserted has the
293:18 - ID equals 1 so this is all we need to
293:21 - provide so here we have the school and
293:23 - the ID you can also provide the name and
293:25 - so on so forth but it will not affect
293:28 - anything because hibernate and spring
293:30 - data jpa only needs the ID so now let's
293:34 - let's click on send and we see now this
293:38 - is the result so first we have a 200
293:40 - okay and here we have the ID with the
293:42 - first name last name and the student
293:44 - profile for now it's null and we see
293:47 - that we have the school which is ID
293:49 - equals 1 name student and the name and
293:52 - the student is null so this is also is
293:54 - not a problem now if I go back and
293:57 - duplicate the school request and change
294:00 - it to a get and of course for the body
294:04 - we don't have anything and I click on
294:06 - send and here we see that we don't have
294:09 - a response yet and this is because here
294:12 - we have let's let's understand the
294:14 - structure let's go back to the code and
294:17 - let me open the student and the school
294:19 - so here we have the school object and
294:22 - the school object it has a list of
294:24 - students okay and then it will try to
294:27 - get the school and the students list and
294:29 - then from the student it will try also
294:32 - to load the the school information and
294:35 - then it will go back to the school and
294:37 - it will try to load the list of students
294:39 - and so on so forth so we have here an
294:41 - infinite Loop and this is because
294:44 - hibernate will try to load all the
294:46 - information Al together so let me show
294:48 - you how we can fix that before fixing
294:51 - the problem let's have a look on the
294:53 - exception so here I will use this uh
294:55 - soft trap just to have everything
294:58 - wrapped and here we see that we have
295:00 - this main exception and failure trying
295:03 - to resolve exception from this uh spring
295:06 - framework and call send error after this
295:10 - response and this means that we encount
295:12 - encountered uh an infinite recursion
295:16 - with with the Json mapping so here when
295:19 - Jackson tries to map the the object so
295:22 - when it tries to map or to transform or
295:25 - to create adjacent response for the
295:28 - school it has a list of student and then
295:30 - as I explained before it will go to the
295:32 - student and then the student has also an
295:35 - object of type school so it will try
295:37 - also to um to serialize the school and
295:41 - back again so we have an infinite
295:43 - recursion Loop so or an infinite Loop
295:45 - and let me show you how we can fix that
295:48 - using the Jackson annotations so for
295:50 - this one we will be using two
295:52 - annotations one on the parent level and
295:55 - the second one on the CH on the child
295:57 - level so the the parent level is where
296:00 - we have the list so the school is the
296:02 - parent of the student
296:03 - students I'm going to make this one full
296:05 - screen and here on the list level we we
296:09 - need to use an annotation called Json
296:12 - managed
296:14 - reference and this Json managed
296:16 - reference so this tells Jackson that the
296:19 - parent is in charge of serializing the
296:22 - child and it prevents the child from
296:24 - trying to serialize the parent now so we
296:27 - need the Json managed reference on the
296:30 - parent level and then we need to go to
296:33 - the child level which is the student
296:34 - right here and we need to go to the
296:36 - field of type school and here we need an
296:40 - annotation called Json back reference so
296:43 - this is the back reference or this will
296:45 - tell that this entity the student entity
296:48 - or the student object doesn't need to
296:51 - serialize the parent which is in in our
296:54 - case the school so now let's restart the
296:56 - application again and let's go back to
296:59 - postman and try to insert the data once
297:01 - again so here the application is up and
297:03 - running so also let me keep it like this
297:07 - I will clean up the console so here
297:09 - again we need to insert this school and
297:12 - insert the student and assign it to the
297:14 - school and now if I try to fetch all
297:17 - schools and I click on send we see that
297:20 - we have a response and we have the
297:22 - status 200 okay and here we see that we
297:24 - have the ID and the school name and then
297:27 - we have the list of the students so for
297:29 - example if I insert a new student so
297:32 - here let's say uh contact to and within
297:35 - the same school ID and here let's say
297:38 - Ali B Ali and I will click on send so
297:41 - the school the student is correctly
297:42 - inserted and now if I fetch again the
297:45 - list of schools we see that we have the
297:48 - school with the ID number one and we
297:51 - have the list of students we have this
297:53 - id2 it's the student we just inserted
297:56 - and we have the first one which is John
297:58 - Bali and with this email address so now
298:02 - we have our application functioning but
298:05 - there is one thing which is a little bit
298:08 - uh not okay with all that is because we
298:11 - are exposing almost everything and even
298:14 - when we want to insert a student we have
298:17 - or we need to provide the full School
298:19 - object and imagine that we have other
298:22 - relationships within the school within
298:24 - the student like for example the student
298:26 - profile and imagine we have subjects and
298:29 - so on so forth so this will make our
298:31 - object or our student object more and
298:34 - more complex and it will prevent us and
298:37 - it will add more complexity when we want
298:39 - to save or to interact with the student
298:42 - entity so this is introducing us to a
298:46 - really important topic we will see just
298:49 - in few moments so let's move on and
298:53 - explore the next topic of our course dto
298:58 - stands for data transfer object which is
299:01 - a pattern often used inof Ware design
299:04 - the main purpose of a dto is to
299:06 - encapsulate and structure data that
299:08 - needs to be transferred between
299:10 - different parts of a system or different
299:13 - systems entirely a dto typically
299:16 - includes only simple data fields or also
299:19 - called attributes and lacks the behavior
299:22 - of the model or entity it represents so
299:26 - here if we take the example of our
299:28 - application we have a student and we
299:31 - have a school we have also a student
299:33 - profile which will hold some sensitive
299:35 - information about the student like the
299:38 - address like phone number date of birth
299:40 - and so and so forth and mainly we don't
299:43 - need to expose this information to the
299:46 - outside word and also even for example
299:48 - if you want to ret the retrieve the
299:50 - information of the school we only need
299:53 - to expose the school information and
299:56 - since these information are represented
299:59 - by entities and stored into a database
300:02 - system which which is secured system so
300:05 - we need to expose only what the user or
300:09 - the end user is expecting and no more
300:12 - extra information so for example as I
300:14 - mentioned for the user we for the
300:16 - student we don't need to expose uh
300:18 - sensitive information such as address
300:21 - date of birth phone number even if if
300:24 - the if the student has a password so we
300:26 - don't need to expose that so then what
300:29 - we need to do we need to include a a
300:33 - mechanism in the middle in between
300:35 - between the entity itself and the
300:38 - outside word so we need to to add a
300:41 - mapper and this mapper is just a simple
300:43 - mechanism you can use many
300:45 - implementation or many tools and
300:47 - libraries to map objects and then if we
300:51 - use a mapper we can have multiple
300:54 - representations for the same object for
300:56 - example for the student we can have a
300:58 - representation one only to expose first
301:01 - name last name and we can have another
301:04 - representation to expose or to receive
301:06 - data from the outside world in order to
301:08 - create a new student and for example we
301:11 - need only first name last name and email
301:14 - and so and so forth so this is one of
301:16 - the advantages is we can have multiple
301:19 - representations for only one object or
301:22 - only one entity and this also appliable
301:25 - for school student or the student
301:27 - profile in our case and generally
301:29 - speaking it's appliable to any kind of
301:32 - ENT entity and the rest API should
301:36 - communicate with the client through
301:38 - these representations and we can have
301:40 - one representation for the read and
301:43 - other representation for the write for
301:45 - example to create a student we can have
301:47 - one representation which holds the
301:50 - information or like the minimum required
301:52 - information to create a student and for
301:55 - the read represent representation we can
301:58 - have a different one or a different
301:59 - object that will be responsible for
302:03 - exposing only the necessary and
302:06 - non-sensitive information to the outside
302:08 - board so when building a restful API dto
302:12 - play a crucial role and now let's give
302:16 - you some reasons why they are important
302:19 - first of all we have data separation so
302:21 - the data transfer object pattern helps
302:24 - to separate the internal domain model
302:26 - from what is exposed exposed through the
302:29 - API this way you can change your
302:33 - internal model without affecting the
302:35 - external representation it also helps in
302:38 - not exposing exposing sensitive or
302:41 - unnecessary data to the API customers
302:45 - then abstraction dto provide an
302:47 - abstraction layer they give you a clear
302:50 - structure of what your API will provide
302:53 - to the client abstracting the complexity
302:56 - of the domain model then performance
302:59 - improvements instead of sending entire
303:02 - entity over the network you can instead
303:05 - send a dto which include only the
303:08 - necessary information these can
303:10 - significantly improve the performance of
303:12 - your API as you can control the size of
303:16 - your response payload then we have
303:18 - flexibility since dto are separate from
303:21 - your domain model they allow you to
303:24 - tailor your API response to exactly what
303:27 - your client need even if that does not
303:30 - exactly match your domain model and here
303:33 - we are talking about multiple
303:34 - representations for the same object and
303:37 - finally versioning so dto make it easier
303:41 - to maintain different versions of your
303:43 - API by using different sets of dto you
303:47 - can support multiple versions of an API
303:50 - simultaneously and then in the next part
303:53 - we will see how we can use this dto
303:55 - pattern in our
303:58 - application now let's go ahead and
304:00 - create a new object that will represent
304:03 - a student request for example so let's
304:06 - start with a student and here we have in
304:08 - our student controller we have the bunch
304:11 - of methods that we created to persist a
304:13 - student to fetch a student and so and so
304:16 - forth now let's see what are the changes
304:19 - that we need to apply after creating our
304:22 - student dto object so I will close
304:25 - everything and here right click and then
304:27 - new and then Java class and for this
304:30 - example and for the dto we will be using
304:33 - records as I explained before what is
304:36 - the difference between records and
304:38 - normal poos so let's say
304:42 - student dto for
304:45 - example and here for this student dto it
304:48 - will be a similar representation to The
304:50 - Entity itself so here to create a
304:54 - student we need the first name we need
304:57 - the last name and we need let's say just
304:59 - the email and the age is not mandatory
305:02 - to create create a new student so I will
305:04 - copy these fields right here I will copy
305:07 - them and then let's paste them in the
305:10 - student dto so here I will just paste
305:13 - these fields and I will add the comma
305:16 - and now we have our record ready to use
305:20 - so also since we have a relationship
305:23 - within the school so a student is linked
305:26 - to a school all we need to do is to pass
305:28 - a school ID instead of the whole object
305:31 - so let's imagine that the information we
305:33 - have within the school is uh address uh
305:37 - location and like a bench a bench of
305:39 - information about the school but for
305:42 - hibernate and for persisting the data
305:45 - all we need to do is the ID of the
305:47 - entity so here within the student dto
305:50 - after the email I will add also an
305:53 - integer school ID so I will create an
305:56 - object and then we call it school ID
305:58 - like this so now we have our student
306:01 - record or student object ready to use
306:04 - now let's move on and create an object
306:06 - for uh for school Al also and let me
306:09 - show you how we can use these dto to
306:12 - persist data and to send back
306:14 - information so now if I close all these
306:17 - classes right here and if I go back to
306:20 - the student controller let me make it
306:23 - full screen and here in the post mapping
306:25 - or when we want to create a student so
306:28 - here we are requesting an object of type
306:30 - student which is our entity but let's
306:34 - change this and instead of requesting
306:36 - the student uh entity let's request
306:39 - student D object so now we are asking
306:44 - the the the rest client to send a
306:47 - student dto which is represented by the
306:50 - first name last name and and an field
306:52 - called school ID which represents the
306:55 - identifier of our
306:57 - school so then we see that the
307:00 - repository. save is now not working
307:03 - because here it's expecting a type
307:06 - student and we are passing a student dto
307:10 - so here as you can see in this error
307:13 - method so infer Type S of type parameter
307:17 - s is not within its bound so it should
307:20 - extend com. al. example. student so we
307:23 - need to pass an object of type student
307:26 - so now let's see how we can use this dto
307:29 - to save an object so as we explained
307:31 - before here we need to transform this
307:35 - student D object to a student object so
307:38 - here let me just let me create a private
307:42 - student method and let's call it two
307:45 - student okay and this two student method
307:48 - will receive exactly this object so
307:51 - let's call it dto right here just for
307:54 - clarity and here what I will do I will
307:57 - create a VAR student equals new student
308:03 - so here I just have a new student so I
308:06 - can use also this Constructor that we
308:08 - that we created before or we can use the
308:11 - Getters and Setters so it's actually up
308:14 - to you to choose which way you want but
308:16 - let's go ahead with with sets and
308:18 - Getters so here let's say student. set
308:21 - first name and then the first name is
308:24 - the one coming from the dto doget or do
308:27 - first name and then we have student.
308:30 - last name so here it's a set instead of
308:33 - a get and then we need the dto do last
308:37 - last name and then we have student. set
308:40 - email and then again from the dto doget
308:44 - email so here it's not a get like within
308:47 - records we don't have gets but we have
308:50 - methods representing like with the field
308:52 - name so now we have all the three fields
308:55 - that you specified for this student D
308:58 - first name last name email and now we
309:00 - need to set an object of type school and
309:03 - Link it to this student object so here I
309:06 - will create a VAR School equals new
309:10 - school and then for this school I can
309:12 - just use D dto and just set the ID so
309:16 - here just school and then
309:20 - dto so here I need to set the ID sorry
309:23 - so it will be my dto do school ID so
309:27 - here I have or I prepared my school
309:29 - object now I need to assign the school
309:31 - object to the student so here I will say
309:34 - student do set school and then the
309:38 - school object I just created right now
309:40 - so now we have our two student method so
309:43 - again let's just return the student
309:46 - object so here we have our two student
309:49 - method so all I need to do here is just
309:51 - replacing this method code right here so
309:54 - we will create a variable and here I
309:57 - will just rename this one to dto or
309:59 - student dto you can name it as you want
310:02 - and here I will create VAR student
310:05 - equals to student from my dto Okay and
310:09 - like this I will be able to persist the
310:12 - data okay so let's go ahead and try this
310:15 - so now the application is up and running
310:18 - also I will just do a small change here
310:21 - in the application. yaml instead of
310:23 - using Create drop I will use just update
310:27 - so because I don't want to lose the data
310:28 - each time I restart the application and
310:30 - now I will just restart again and let's
310:33 - go ahead to postman and try to create a
310:36 - new
310:37 - student so here in Postman first we need
310:40 - to create a school so let's just send
310:42 - this one and we have the ID number one
310:45 - and here we have the the method that
310:48 - will allow me to create a new student
310:52 - okay so it's a post and then student so
310:55 - here we said that we no longer need the
310:56 - age since it's just a requirement from
310:59 - us and here instead of passing the
311:01 - school object all I need to do is to
311:03 - pass a school ID right here and this
311:07 - school ID I will give it the name one uh
311:10 - sorry value not name and then let's
311:12 - click on send and see what will happen
311:15 - so here we have 200 okay so this means
311:18 - that the student was persisted and it
311:20 - was linked to the school that we
311:22 - recently created so let's go back to the
311:25 - to our database and check if we have
311:27 - everything persisted and working as
311:30 - before so here let let's go to the
311:32 - database let's
311:34 - refresh and then here we have our school
311:38 - and if I open the student we see that I
311:40 - have the student that I just created
311:42 - with the name Ali B Ali and we have also
311:45 - the school ID equals one so like this we
311:48 - saw that we using the dto we are no
311:51 - longer requiring all the information or
311:53 - all the fields from all from the entity
311:57 - but it's just a representation that
311:59 - suits our need but we still have one
312:01 - small issue we are returning again the
312:04 - student object so we are returning or
312:06 - exposing the student entity and here as
312:09 - you can see in Postman and the response
312:11 - we have the age which we don't want uh
312:14 - to expose and also have this object uh
312:16 - student profile which is null and so on
312:19 - so forth also we have the ID and maybe
312:21 - we don't want to expose that so now
312:24 - let's see how which dto we need to
312:26 - create in order to return a proper uh a
312:30 - proper object and a proper response to
312:32 - the user so now let's create another
312:36 - record and it with this one we will call
312:38 - it so it's a record and we will call it
312:41 - Student Response or student
312:43 - representation dto so let's say Student
312:46 - Response dto and exactly as we did right
312:50 - here so we need the first name last name
312:52 - and email for example so these are the
312:54 - information that we want to expose to
312:56 - the end user or to the to our client uh
312:59 - to our RIS client so let me stop the
313:01 - application
313:02 - and here all I need to do I need to go
313:04 - back to my controller and then instead
313:07 - of returning a student I will return a
313:09 - Student Response dto okay but here again
313:13 - we see that this repository. saave is
313:16 - returning a student object and I need to
313:19 - return another type so again we need
313:22 - another meth method right here so we
313:25 - need a private
313:28 - student response dto and let's say to to
313:32 - Student Response dto and this to Student
313:35 - Response dto should receive student
313:39 - object as a parameter okay and then all
313:42 - I need to do is return New Student
313:45 - Response dto and then I need to pass all
313:48 - the information that I need so it will
313:50 - be student. get first name and then so
313:53 - let me inline this
313:56 - one so it will be student. getet first
313:59 - name and then student. last name and
314:02 - finally student. getet
314:05 - email and like this we have our Student
314:09 - Response dto and here semicolon and now
314:12 - we have our representation ready so here
314:16 - I will say just VAR saved
314:19 - student equals this one or like the
314:22 - result of saving the student and and
314:26 - then all I need to do is to return to
314:29 - Student Response from the saved student
314:32 - and like this I have again a new object
314:36 - or a new representation of the response
314:39 - that I want to expose to the customer or
314:42 - to my rest client so let's go ahead
314:44 - start the application and let's try this
314:47 - out so now if I go back to postman and
314:52 - let me duplicate this tab and let's use
314:54 - a get in here and let's search student
314:57 - by its ID so let's say for example
314:59 - student SL1 or or let's save another
315:03 - student again and we will come back to
315:05 - that method later on so here for example
315:08 - if I say Ali or like John do and here
315:11 - let's say it's John do alibu coding.com
315:15 - and now if I click on send we see that
315:17 - we have the response or a different
315:19 - response from our back end and we do not
315:22 - expose extra information so here the
315:24 - response is really encapsulated and an
315:27 - abstract response without any further
315:30 - information that we should not Expos to
315:32 - the outside word so here we are exposing
315:35 - only the necessary information even if
315:37 - you see for example that this email is a
315:40 - sensitive information all you need to do
315:41 - is just remove it from the dto and
315:44 - adjust the
315:46 - mapping now for our school object let's
315:49 - create a dto for that so again just new
315:52 - and then record let's say school dto and
315:57 - here in this record all we need to do is
315:59 - a string name so or string school name
316:02 - you can name it as you want so now we
316:05 - have our school dto record or School dto
316:09 - object and we can use this one now in
316:12 - the school controller in order to save
316:14 - and expose information about our schools
316:17 - so again let's move go ahead and
316:21 - Implement that let's now introduce all
316:24 - the necessary changes to our school
316:26 - controller in order to receive a school
316:28 - dto and expose also a school cool dto so
316:32 - here let's check back again here if I go
316:35 - back to postman and let me start the
316:38 - application I will explain to you what I
316:40 - mean so now if I go back to postman and
316:43 - here if this is the the school or like
316:46 - to retrieve the school with all the
316:48 - students we see how we see here that we
316:50 - have the information of the school and
316:52 - we have the list of the students so now
316:55 - it's it's okay to have it like this
316:58 - because in this case and so far we have
317:00 - only students assigned to this uh to
317:03 - this school but imagine the case we have
317:06 - hundreds and even thousands of students
317:09 - assigned to the same school when you
317:10 - request the information or like you need
317:13 - just a light information about the
317:15 - school we will be loading the school and
317:17 - all the students and imagine also we
317:20 - have other relationships for the
317:21 - students and like the response will be
317:24 - really really heavy and it will take
317:27 - time until it gets from the back end to
317:29 - the rest client so what we need to do
317:32 - again we need to just use dto and expose
317:35 - only the information that we need and I
317:38 - will then show you how we can expose or
317:41 - like fetch the students for a specific
317:44 - school so now let's go back to our code
317:46 - and let's adjust our controller to only
317:49 - Expose and receive all the ne only the
317:51 - necessary information for the school
317:54 - object so here for the Post mapping or
317:57 - to create a school first I need to
318:00 - return a school dto again I just want to
318:02 - remind you that the school dto takes
318:05 - only as a parameter the school name and
318:08 - then here we also need to get a school
318:12 - dto as an input or as a request body so
318:15 - here all I need to do is just to have
318:18 - VAR
318:20 - school so here let's call this one dto
318:23 - and school equals to school for example
318:27 - because I need a method that should do
318:30 - or make uh or perform the mapping and
318:33 - the object transformation from school
318:35 - dto to an object school so here we don't
318:38 - have yet this method so let's create a
318:40 - method School in school controller so
318:43 - here it should return school and that's
318:46 - it so now all I need to do is just
318:48 - return a new school and for this new
318:51 - school it will be d.name since our
318:54 - school contains only one attribute which
318:57 - is this one and we don't really need to
318:59 - pass any students
319:01 - then we need to perform saving or like
319:04 - we need to save the school and all I
319:06 - need to do so in this case I can whether
319:08 - return or like have for example saved
319:12 - School equals school. repository and
319:16 - then I will do VAR and then I need
319:19 - another method to transform this school
319:22 - dto uh this school object to a school
319:25 - dto but here as you can see it's just
319:28 - for this case the school object is the
319:30 - same as as the for the input as the
319:33 - output so all I can do is return dto
319:37 - again so this also valid and this
319:42 - will allow me to have or to save some
319:45 - time on the execution level so here we
319:47 - have our our method right here it's a
319:50 - post mapping and we receive the school
319:52 - dto and then we save this the school and
319:56 - return the object back so let's go ahead
319:58 - let's restart and let's try out this so
320:01 - if you go back to postman and here this
320:04 - is the tab for posting a school so let's
320:07 - say alibu School 2 and then if I click
320:10 - on save so we see that the the school
320:14 - was persisted and here I have the
320:16 - response that I already get from my back
320:19 - end now if I go back and check the
320:21 - database and here let's
320:24 - open our school table we see that we
320:27 - have alibu school and alibu school to
320:30 - sorry not do which is was persisted into
320:34 - our table now for fetching the list of
320:38 - schools that we have in the database we
320:41 - don't need to expose the school but we
320:44 - need to return a school dto object so
320:47 - here I will just change this return type
320:50 - to school dto and then we need to
320:53 - perform also a mapping so we need to do
320:55 - a transformation for each element of the
320:58 - list to a school dto object so here
321:01 - let's create private and then school dto
321:06 - and let's call it to school dto and
321:09 - these two school dto will receive a
321:12 - parameter of type school and then all I
321:14 - need to do is to return a new school dto
321:19 - and then it's will it will be School
321:21 - dot get name now we have our method and
321:26 - this method it will transform like it
321:27 - will take a school object as a parameter
321:30 - and then it will return a school dto out
321:33 - of it so here what we need to do so
321:36 - first let's have a
321:38 - stream and then let's perform a mapping
321:42 - so then stream so it will this will
321:44 - return a stream of schools and then a
321:46 - map so we can do this and then we can
321:48 - use the method reference and then we can
321:51 - call this method to school dto and then
321:54 - of course we need to collect and return
321:56 - a list so here now we have a
322:00 - transformation so after finding all the
322:02 - students which will return a list of
322:05 - schools then we open a stream so this
322:07 - will transform our list to a stream of
322:09 - schools and then we will do a mapping so
322:12 - we will do a transformation of object so
322:15 - this means for each element of this list
322:18 - of schools or of this stream of schools
322:21 - we can or we will perform a
322:23 - transformation and then it will we will
322:25 - call the two School dto method which
322:28 - will return later on a stream of school
322:31 - dto object and then we call a reduce
322:34 - meth method which is collect and then we
322:36 - want to collect all of this as list so
322:39 - now let's go ahead and try this one and
322:42 - see the output so let's open again
322:44 - Postman and here we have the method or
322:47 - like the request to call or to get the
322:50 - list of schools if I click on it we see
322:53 - that we have now an object name alibu
322:55 - school and then name alibu School 2 so
322:58 - we don't expose anym the list of
323:01 - students or any extra object or any
323:04 - extra information that we don't want to
323:06 - expose it to the outside world or to our
323:09 - rest customer all right so now we have
323:12 - everything uh we need so let's move on
323:16 - and and talk about a really interesting
323:19 - topic so see you in the next lecture as
323:23 - the application and the business
323:25 - requirement grows we see that the code
323:28 - that we are producing in here in this
323:30 - controller student controller and also
323:32 - in the school controller has grown
323:35 - significantly and for that we need to
323:38 - introduce another layer in order to make
323:41 - our code more you more reusable and we
323:45 - we need to create a separation of
323:47 - concerns so for that we need to create
323:50 - another layer which is called the
323:52 - service layer so the service layer in
323:54 - rest API plays a crucial role in
323:57 - separating the concerns of handling
323:59 - business logic and application specific
324:02 - operations from the presentation layer
324:05 - which is the controller and the data
324:07 - access layer which is the repository so
324:10 - it serves as an intermediary between the
324:13 - controller and the repository
324:15 - encapsulating the business logic and
324:17 - providing a reusable modular and
324:20 - testable code base and here are some key
324:23 - reasons why the service layer is
324:25 - important in RIS apis first we have
324:29 - business Logic on capsulation so the
324:31 - service layer is responsible for
324:33 - implementing the business logic and
324:35 - Performing complex operations required
324:38 - by the API it encapsulates the logic
324:42 - that goes beyond simple data retrieval
324:44 - or modification such as validation
324:47 - calculation transformation or
324:49 - coordination of multiple operations so
324:52 - by centralizing the business logic in
324:54 - the service layer you promote code
324:57 - reusability maintainability and
324:59 - readability also the service layer
325:02 - provides a separation of concerns so the
325:05 - service layer helps to maintain a clear
325:08 - separation of concerns within the API
325:11 - architecture controllers are responsible
325:13 - for handling incoming HTTP requests and
325:17 - providing appropriate responses while
325:20 - repositories handle the data persistence
325:22 - and retrieval the service layer sits in
325:25 - between ensuring that the business logic
325:28 - and application specific operations are
325:31 - decoupled from the other layers so this
325:34 - separation improves code organization
325:37 - makes the code easier to understand and
325:40 - allows for independent changes and
325:42 - testing of each layer and finally
325:45 - testing and maintainability so the
325:47 - service layer provides a boundary of
325:50 - unit testing as you can test the
325:52 - business logic independently for the of
325:54 - the controllers and repositories by
325:57 - mocking or stabbing the dependencies you
326:00 - can for Focus solely on testing the
326:02 - logic within the service methods so this
326:05 - makes it easier to write comprehensive
326:07 - and targeted tested enhancing test
326:10 - coverage and ensuring the correctness of
326:13 - business logic Additionally the
326:15 - separation of concerns achieved by the
326:18 - service layer improves the
326:19 - maintainability of the code base as
326:22 - changes to the business logic and can be
326:25 - isolated to the service layer without
326:27 - affecting the other layers so in the
326:29 - next part let's go ahead and create the
326:33 - service layers that we need for our
326:35 - application so now let's start with
326:38 - refactoring the student controller and
326:41 - create and extract the code for each
326:43 - layer so here let's first start with
326:46 - this two methods the method that can
326:49 - convert and map an object student dto to
326:53 - an object student and also we have
326:55 - another method which converts a student
326:58 - to a student response dto so for that
327:01 - let's go ahead and create a new class
327:04 - and let's call it student mapper so this
327:08 - class or this service is responsible for
327:11 - mapping or creating mapping for our
327:14 - students so first to make this class
327:18 - service all we need to do is to add the
327:21 - service annotation on this level right
327:24 - here and then let's go back to our
327:26 - student controller and let's copy or
327:29 - let's cut this two methods right here so
327:32 - I'm going to use command X to cut these
327:35 - two methods and then we go back to the
327:38 - student mapper and then just paste the
327:41 - code right here and don't forget to make
327:44 - these methods
327:46 - public and again here let's make the
327:49 - second method public so now we have
327:52 - these two methods available in this
327:55 - student mapper service so now in order
327:57 - to use the student mapper and the
327:59 - student controller all we need to do is
328:01 - to inject our student mapper so let's go
328:05 - ahead and do it so here we have private
328:07 - final student
328:09 - mapper and then let's call it student
328:12 - mapper and here of course we need to
328:14 - include that or to add this to our
328:17 - Constructor so let's go ahead and do it
328:20 - and now we have our student mapper
328:22 - injected I'm going to make this one full
328:24 - screen and now let's fix the test so
328:27 - here instead of calling directly the two
328:29 - student we need to call student mapper
328:32 - do to student and here we see that the
328:35 - code still works and we don't have any
328:37 - compile issues and the same here so for
328:40 - the other method to Student Response dto
328:43 - so here we started or we extracted our
328:46 - first service and we have our student
328:48 - mapper service which can handle the
328:51 - mapping and the objects transformation
328:53 - so now let's move on and create another
328:57 - service for this student controller in
328:59 - order to make our code more and more
329:02 - reusable and make our code maintainable
329:06 - and uncapsulated
329:08 - so now we extracted the code and we make
329:12 - we made our
329:13 - code less complex on the student
329:16 - controller but we still see that we have
329:19 - more logic which is happening around
329:22 - here so here we have like mapping saving
329:25 - and then returning the mapped object so
329:28 - the idea is always to make the student
329:30 - or the controller layer responsible only
329:33 - for receiving the requests and sending
329:36 - back the responses and all the logic and
329:39 - all the business logic needs to go to to
329:42 - a separate service so for that let's go
329:45 - ahead and create a a new class and let's
329:48 - call it student service so here student
329:51 - service class and again to make the
329:54 - student service a service we need to
329:57 - give it The annotation service so here
329:59 - we can use whether the annotation
330:00 - service or just a component but since we
330:04 - decided that this is a service layer so
330:06 - we can annotate it with a service
330:08 - annotation so then we see here that we
330:11 - are using repository and mapper so we
330:14 - need to move these two dependencies to
330:17 - the service layer so I'm going to close
330:20 - this one and then I will just cut this
330:23 - student uh these two dependencies and I
330:26 - will paste them here and again let me
330:29 - make it full screen and now I need to
330:31 - create or to add a Constructor with
330:33 - these two objects or two dependencies in
330:36 - order to you inject them using
330:38 - Constructor injection and here let's go
330:41 - back to uh to this one and now instead
330:44 - of injecting the repository and the
330:47 - mapper all we need to do is to inject
330:49 - the service that we just created and we
330:51 - will come back to this in a few seconds
330:54 - so here we see that we have this post
330:56 - method so first I'm going to uh change
330:59 - this one and make it save student so I
331:02 - will just re rename the method and here
331:05 - in the student service I need to create
331:08 - also a method that will perform these
331:11 - three operations this means transforming
331:14 - a student dto to a student and then
331:16 - saving the student and then finally
331:19 - mapping the student to a student
331:21 - response dto so I'm going to cut this
331:25 - one and here I will go back to my
331:27 - student service and I will create a
331:31 - public method so I will call it or like
331:35 - it should return a student response dto
331:38 - so let's call it also save student if
331:40 - you want to and this save student needs
331:43 - to take as a parameter the same object
331:47 - that we have right here so let's pass
331:49 - our student
331:52 - dto as an input and then let's open this
331:57 - and just paste the code that we we
331:59 - copied from the controller so now if I
332:02 - go back to my student controller and
332:05 - then I will just remove this constru
332:07 - Constructor and again I will inject my
332:11 - private final student service the one
332:14 - that we just created and let's call it
332:16 - student service and of course we need to
332:18 - create or inject it through the
332:20 - Constructor and here we have our student
332:22 - service so here in this save student
332:26 - method let's just do this do student
332:29 - service do saave student and then we
332:32 - pass this the dto as an object so for
332:35 - this method we see that we have only one
332:38 - line and of course we need the return
332:40 - keyword and how here we have only one
332:43 - line which is calling the student
332:45 - service in order to perform all the
332:49 - business logic that we need so here
332:52 - let's go ahead and also migrate and move
332:55 - all the logic for the other methods also
332:58 - to the student service so now before we
333:01 - move on I want to give you a small
333:03 - exercise and I'm pretty confident that
333:05 - you will handle it your own so here I
333:08 - want you to migrate and to move all the
333:11 - logic in this controller to the student
333:14 - service so this means you need to create
333:16 - a method find all student in the student
333:18 - service and the same for find student by
333:21 - ID and find student by name and the same
333:24 - for deleting a student so go ahead and
333:27 - do it and I will give you the solution
333:29 - just afterwards that's good so now let's
333:32 - correct this exercise so first of all
333:35 - let's create a method in our service and
333:37 - let's call it find all students so we
333:40 - can just copy this
333:42 - one and then move it to the student
333:45 - service so here I will have my method so
333:48 - find all students and now if I go back
333:51 - here instead of repository and I will
333:54 - call this the service so here I have
333:56 - student service do find all students
334:00 - and now we migrated the find all
334:03 - students to the student service so in
334:05 - case we need to perform any other
334:07 - operations on the student on the find
334:10 - all students we can just do it on the
334:13 - service layer and we no longer need to
334:15 - update or to change anything on the Ser
334:18 - on the controller layer so again let's
334:20 - do or let's migrate this one and then of
334:23 - course I will give you another exercise
334:25 - just to transform or to return the
334:28 - Student Response dto instead of the
334:30 - student for this controller so let's go
334:33 - ahead and let's do this so here we have
334:37 - we need the integer ID and then all we
334:39 - need to do is just to return this one so
334:42 - let's copy this code from here and then
334:45 - paste it here and now instead of calling
334:48 - the repository so it will be the student
334:52 - service doind student by ID and then we
334:55 - need to pass the ID as a
334:58 - parameter so we Mig ated also the fine
335:00 - student by ID and now let's go ahead and
335:04 - migrate this method
335:06 - to so let's copy it and then let's go to
335:09 - the service and here we need the string
335:12 - name as a parameter and then also we can
335:16 - just go back and copy this line of code
335:20 - and paste it in here so again let's go
335:23 - back to the controller and here instead
335:26 - of returning the repository so it will
335:28 - be student service do find all by name
335:31 - or find students by name so here find
335:34 - students by name and then we need the
335:37 - string name so now also we migrated this
335:39 - method and finally we need to migrate
335:42 - this delete method so let's make it also
335:44 - a void so let's go back to student
335:47 - controller and let's spacee this one and
335:50 - we need our integer
335:52 - ID and then we need just this line of
335:55 - code so let's just copy
335:58 - it and then paste it in here so then we
336:02 - know we go back to the student
336:03 - controller and instead of calling the
336:05 - repository let's just call student
336:08 - service and then just the method called
336:11 - delete so now we migrated all the code
336:14 - to the service and as you can see here
336:17 - in the controller methods we see that we
336:20 - just making a call to the student
336:22 - service so we have no logic in here so
336:26 - that's good now we migrated everything
336:28 - and The Next Step let's see what we need
336:31 - to do
336:34 - again now I want to give you another
336:36 - exercise so as I mentioned before here
336:39 - we see or we need to return always the
336:42 - dto or the dto representation and we
336:44 - want to do the same for all the other
336:47 - methods so here instead of returning the
336:49 - student object I want you to return the
336:52 - Student Response did you object instead
336:55 - so now I will leave it to you and just
336:58 - go ahead fix this and change the return
337:01 - type and I will see you in the solution
337:04 - for this exercise that's good you made
337:06 - it this far so now let's correct
337:08 - together this exercise so here instead
337:11 - of returning a student we need to return
337:14 - a Student Response Toto so let's first
337:17 - change the type of this list and here in
337:20 - this find all method let's start an open
337:23 - a stream and then let's make a map and
337:27 - then we need our mapper so so student
337:30 - mapper and then we can make a method
337:32 - reference to Student Response dto and
337:35 - finally we need to collect our objects
337:39 - so here we have collect and then
337:41 - collectors as list and of course we see
337:44 - that we have still one related problem
337:46 - which is the student controller or the
337:48 - return type of the student controller so
337:50 - we need also to change that so now we
337:53 - have our Student Response dto for the
337:57 - find all student methods so next next
337:59 - let's go ahead and also migrate and
338:02 - change the the return type for the find
338:05 - student by ID so let's go back to our
338:08 - student service and here in the find
338:10 - student by ID let's just paste this one
338:14 - so we change the return type and here
338:17 - this find by ID as you can see it
338:20 - returns an optional of student So within
338:23 - the optional we have also the map method
338:26 - so we can also perform a transformation
338:28 - and return turn the transformed object
338:31 - so for the transformation we need also
338:33 - the student mapper and then to Student
338:36 - Response D otherwise here we need to
338:40 - return a new student or we can just
338:42 - return null for the moment and then I
338:44 - will show you in the in the future
338:47 - sections how or how to deal with this
338:50 - kind of objects in case we don't find
338:52 - any student with the specified ID so now
338:55 - let's go back to the controller and also
338:58 - change the return type for this method
339:01 - so here it should be Student Response
339:02 - dto and now let's move on and also
339:06 - change the return type for the find
339:09 - students by name so again let's go back
339:12 - to the service and here instead of
339:14 - student we need to return Student
339:16 - Response dto and here also we know that
339:19 - this find all by first name returns a
339:22 - list of student so it will be exactly
339:25 - the same thing as in here so we can just
339:28 - copy this code to make it faster and
339:32 - just paste it in here so we have the
339:34 - find all and then stream and then we
339:36 - perform the mapping and then we collect
339:38 - the response and of course don't forget
339:41 - to change the return type in the
339:43 - controller so here I will just use the
339:46 - content to paste so here I want or I
339:49 - need my Student Response dto and we have
339:52 - the issue fixed once and for all so now
339:56 - we have everything fixed in the student
339:59 - controller and we migrated and moved all
340:02 - the business logic to the student
340:04 - service so here as you can see if we
340:06 - need to perform any operation or to
340:08 - apply any business logic we just do it
340:10 - on the student service and also for
340:13 - example if we need anything or a new
340:15 - method on the M for the mapping or if we
340:18 - want to return another type or another
340:20 - representation of the student all we
340:22 - need to do is to perform and do this
340:24 - transformation on the student mapper
340:27 - level so now we have our student
340:29 - controller clean let's go ahead and also
340:33 - migrate the business Logic for this
340:36 - school controller to a school service
340:40 - that's good you made it this far now I
340:43 - want to give you another exercise so now
340:46 - let's move to the student controller and
340:48 - I want you to extract all the logic that
340:50 - we have in here to separate services so
340:54 - just to give you a hint just I want to
340:56 - remind you that we have mapping methods
340:58 - right here and we also we have some
341:01 - logic in here and also we have some
341:03 - logic in here so just go ahead and do
341:06 - this and extract all this code to
341:08 - separate services and I will see you in
341:11 - the solution for this exercise good you
341:14 - made it this far and I'm pretty sure
341:16 - that you correctly implemented the
341:19 - services and extracted the services for
341:21 - the school controller so now let's fix
341:23 - that together first we need to create a
341:26 - new class so let's call it school mapper
341:30 - so this school mapper of course we need
341:32 - the service annotation to make it a
341:34 - service and to make it injectable and
341:37 - first let's move these two methods right
341:39 - here so I'm just going to cut them so
341:42 - let me make it full screen and then
341:45 - let's paste these two so here also we
341:47 - need to make these two methods public in
341:50 - order to be able to use them from
341:52 - outside this class and now also let's
341:56 - create another class and let's call it
341:58 - school service so here we have school
342:01 - service class and again we need the
342:04 - required or the sorry the service
342:07 - annotation and again we need to create
342:10 - two methods since we have just two
342:12 - methods right here so I'm going to just
342:14 - copy this one or like I'm going to copy
342:17 - the whole method and I will paste it in
342:20 - here so here we don't need this request
342:22 - body and we can also make the
342:25 - code a bit cleaner and I'm going to make
342:28 - it full screen screen and here of course
342:30 - we need to inject our mapper so private
342:34 - final school mapper and then let's call
342:38 - it school mapper and of course we need
342:40 - our Constructor for that so add a
342:43 - Constructor and here instead of using to
342:46 - school I'm going to use my school mapper
342:49 - do to school and the same in here so
342:52 - here we need also the school repository
342:54 - so let's go ahead and inject it so we
342:57 - have private School repository and let's
343:01 - call it school repository and also let's
343:04 - make it final and inject it and add it
343:06 - as a parameter into our Constructor so
343:09 - here we extracted the create method so
343:11 - let's go back to the controller and
343:13 - instead of calling this we need to
343:16 - return the call from the school service
343:19 - so here I will just change this one to
343:21 - school service and also I will rename
343:24 - this one to school service so let me
343:26 - just remove the controller and inject it
343:28 - again so here let's call it school
343:30 - service and let's create a new
343:33 - controller with a school service so here
343:35 - I will just remove everything and
343:38 - instead of REM just returning the dto I
343:41 - will just return my school service.
343:44 - create and then I need to pass the dto
343:46 - as a parameter so now we just
343:49 - successfully migrated and extracted the
343:52 - code for the create let's do the same
343:54 - within the school or the find all method
343:58 - so I will copy this one so or I can just
344:00 - copy everything and here I will go to my
344:03 - school service and I will paste this
344:06 - method right here so here instead of
344:09 - this for the mapping part instead of
344:11 - this I need to call my school mapper and
344:14 - then the method to school dto and of
344:17 - course let's not forget to change or
344:19 - make the changes in the school
344:22 - controller so here let's call our school
344:25 - service do findall method so again we
344:28 - ALS also need to optimize the import and
344:32 - now we have our code migrated and
344:35 - extracted to separate services so here
344:38 - we see that the code is more and more
344:41 - readable and maintainable so if we need
344:44 - to again to perform any business logic
344:47 - we only have one place to perform it and
344:49 - we don't need to make everything in one
344:52 - place or in the controller and this will
344:54 - make our life easier later on when we
344:57 - move to the to the unit tests part you
345:00 - will see the impact and the advantages
345:03 - of extracting the code to service
345:06 - layers as our application grows we see
345:09 - that each time we need new classes new
345:11 - interfaces and new objects to create and
345:15 - this
345:15 - is too much and makes our code really
345:19 - not easy to Target and for example if
345:21 - you search a specific class or specific
345:24 - object to update or to perform any
345:27 - operation on it it's really Prett a bit
345:29 - hard to to to find it and here it's just
345:33 - a simple example imagine if you are
345:35 - working on on a bigger application and
345:39 - let's say for example an e-commerce
345:40 - application within the same codebase so
345:43 - this makes our life a bit complicated to
345:47 - find and identify the correct class and
345:51 - the correct object to update so for this
345:54 - I want to introduce you to a topic which
345:56 - is the best way to organize your code
345:59 - within your application and for for this
346:02 - one we have several approaches and I
346:05 - will walk you through each one of them
346:07 - and explain how to organize this the
346:09 - code using each of these approaches and
346:12 - then we will choose together the best
346:14 - approach or I will give you my
346:16 - recommendation for the best approach to
346:19 - organize the code but you are always
346:21 - free to choose the best approach that
346:24 - suits you so now let's first start
346:26 - explaining the approach the first first
346:29 - approach is called by feature in this
346:32 - approach the code is organized around
346:34 - the business capabilities of features of
346:37 - the applications for instance if you're
346:39 - developing an e-commerce application you
346:42 - might have packages like product order
346:45 - customer and payment and each of these
346:48 - packages would then contain all classes
346:50 - related to that particular feature such
346:53 - as controller Services repositories and
346:55 - models so this organization style is is
346:58 - benefical for large teams and project
347:01 - because it's easy to locate code related
347:04 - to specific feature the second approach
347:07 - is the layer approach so in this
347:09 - approach the code is organized around
347:12 - its architectural layers common layers
347:15 - might include controllers Services
347:18 - repositories models and utils for
347:20 - example so these Styles is benifical
347:23 - when the focus is more on technical
347:25 - roades classes rather than they their
347:28 - business roles so however one downside
347:31 - is that change to a single feature could
347:35 - affect multiple packages and the next
347:37 - approach is by domain so in a domain
347:40 - driven design or also called DDD
347:43 - approach the focus is on the business
347:45 - domain packages so packages are formed
347:48 - around different bounded context of
347:50 - subdomains within the large domain so
347:53 - for instance in a Health Care system for
347:55 - example there might be packages like
347:58 - patient management billing scheduling
348:00 - and medical records and finally and the
348:03 - Final Approach is by component so in a
348:07 - more modularized approach you may have
348:10 - top level packages for each highlevel
348:13 - component or of your system within each
348:17 - of these packages you can further
348:19 - organize code by feature layer for
348:21 - example if we have a user component we
348:24 - can have Sub sub packages like
348:26 - controllers Services models and so on so
348:28 - forth same for product component we can
348:31 - have controllers Services models utils
348:34 - and so and so forth and personally I
348:37 - prefer the layer approach so here we can
348:40 - have packages for product order customer
348:44 - and payment and inside of each package
348:47 - we will have all the related classes to
348:50 - the product so in this in our case we
348:52 - will have a package for school a package
348:54 - for student another package for user
348:57 - profile and so and so for forth and if
348:59 - we need a common package like for
349:01 - example let's say validators or
349:03 - exception handlings or like custom
349:05 - exceptions and so on so forth we can
349:07 - create a specific package for that so
349:10 - now let's move on and organize our code
349:14 - together so now in order to move all
349:18 - these classes to the appropriate
349:19 - packages there are several ways and let
349:22 - me show you how you can use your IDE to
349:24 - do that here in the first line of each
349:27 - class you will see a line called package
349:31 - and it refers to the package that holds
349:33 - the this class so here for example if I
349:36 - want to move the school class to a
349:39 - package that I want to call school all I
349:41 - need to do is to add dot school and then
349:45 - anj will say that we don't have a
349:48 - package for that and if I open this one
349:51 - this small popup right here we see that
349:53 - we have set package name to com. alibu
349:56 - example since entj is is considering
349:59 - this as a typo or it will propose also
350:01 - to move to package. al. example. school
350:05 - so let's go ahead and choose this option
350:08 - and here if you uncheck this button
350:11 - right here you see that inside this
350:13 - example package it will ask to create a
350:16 - school package so let's go ahead and
350:18 - click on okay and see that here we have
350:21 - this school package okay but this will
350:24 - come with some related issues because we
350:27 - need to import now the appropriate
350:29 - classes but first let's move all the
350:32 - school related uh classes to the school
350:35 - package so here we can just perform a
350:37 - drag and drop so let's just drop this
350:40 - one here and ask an to refactor same for
350:44 - school dto and then refactor and also
350:47 - school mapper so here and finally we
350:50 - need the school repository and the
350:52 - school service so it's easy to do it
350:54 - within the within the ID so here let's
350:57 - check if we have another school object
350:59 - so we don't here if I go back to the
351:01 - school I need again just to import the
351:04 - student but let's do it for later and
351:07 - then what I can do also like a different
351:11 - way I can just create a package like new
351:14 - and then package and then let's say for
351:17 - example student so here this package
351:19 - will hold all the information about the
351:21 - student and now I can select multiple
351:24 - classes so student student controller
351:26 - student dto student student repository
351:29 - and then Student Response dto and
351:32 - student service and finally student
351:34 - mapper and then I all I need to do is
351:37 - just to drag and drop them to the
351:39 - student package and then click on
351:41 - refactor and let entj take care of the
351:44 - rest and finally we see that we have the
351:47 - student profile so let's also create a
351:49 - new package for that so let's call it
351:52 - student profile and finally we need to
351:55 - move the student profile to this student
351:59 - profile package and then let's go back
352:01 - to here and let's check everything so
352:04 - here we see that the school we need just
352:06 - to import this one and if you just type
352:10 - or uh open the auto uh code completion
352:13 - it will propose that to import the
352:15 - school from this package so just select
352:17 - this one and now we have our school
352:19 - object ready to use so then if I go to
352:22 - the school and also open let's import
352:26 - our student object here and now we have
352:29 - everything fixed and if I go back to the
352:31 - school we see that our application is
352:33 - compiling successfully and also to make
352:36 - sure that everything is compiling just
352:38 - go to build and then build project and
352:41 - let's see if our project is successfully
352:43 - built so we still see that we have one
352:46 - issue is with the student mapper so
352:48 - let's click on this one and again we
352:51 - need to import this school from here so
352:54 - now let's check back again and we see
352:56 - that we have in this school mapper and
352:59 - the student mapper sorry not the school
353:01 - mapper because we are using the school
353:03 - object in here so we need to import it
353:05 - from the appropriate package since they
353:08 - are now in different packages so again
353:11 - let's check if our application is
353:12 - building and then click build on and
353:15 - build project so now the project is is
353:17 - successfully built and everything looks
353:20 - bit nicer and pretty much nicer not just
353:24 - a bit so here we have our code organized
353:26 - if I need something school related all I
353:29 - need to do is to go to the school
353:30 - package and here we have all the classes
353:33 - related to the school the same for the
353:36 - student so now let's move on and check
353:39 - what comes next now after all this
353:41 - refactoring and the code organization
353:44 - let's go ahead and check if our
353:46 - application is still working so let me
353:48 - close all this and then let's start the
353:50 - application and go to postman and make
353:53 - sure that the application is still
353:55 - working so here we see that we have the
353:57 - application is up and running and
353:59 - everything is totally okay so let's go
354:02 - to our Postman and make sure that
354:04 - everything is working fine so here in
354:07 - Postman so for example if I go to
354:09 - schools and try to retrieve the list of
354:11 - schools we see that we have the response
354:13 - and we have 200 okay and now for example
354:17 - in case I want to insert uh a new
354:19 - student let's say alibu and I will just
354:22 - provide the first name and the school ID
354:24 - and let's click on send we see that we
354:27 - have our student persisted and we
354:30 - receive a 200 okay but here we see that
354:32 - we have the last name and the email are
354:35 - null and also let's go check in the
354:37 - database and see the changes so here I'm
354:41 - going to make this full screen and now
354:43 - let's open the student class or the
354:45 - student table we see here that this is
354:48 - the the latest student that we inserted
354:51 - and we inserted it with the first name
354:53 - alibu but we see that the email and the
354:56 - last name and even the age are null so
355:00 - the age is zero because it's of type in
355:02 - so by default the int is zero but we see
355:05 - also that we have the email and the last
355:06 - name they are null and this is not
355:09 - really appropriate when it comes to
355:12 - database and for the data we want to
355:14 - persist there we can accept null values
355:17 - uh for some Fields but for other fields
355:20 - we cannot accept null values for example
355:23 - when we talk about the email or the
355:25 - student so the email can be also a
355:27 - unique identifier and important and
355:29 - sensitive information for student so we
355:33 - need always to have the email and the
355:35 - last name for the student so this also
355:38 - introduces us to the next section of
355:41 - this course so let's go ahead and
355:43 - introduce that and let me explain to you
355:46 - the issue and how we can fix
355:53 - that data validation is crucial in RIS
355:56 - API for several reasons First Data
356:01 - Integrity data validation ensures that
356:04 - the data being received and processed by
356:06 - API meets certain rules and restrictions
356:10 - this helps maintain the the consistency
356:13 - and real reliability of your data for
356:16 - instance validating an email address
356:19 - format ensure that you won't have
356:21 - invalid email addresses in your
356:24 - database preventing attacks and
356:27 - validated data can expose your API to
356:31 - security vulnerabilities malicious users
356:34 - can send harmful input to your API in an
356:37 - attempt to perform SQL injection
356:40 - cross-site scripting also known as xss
356:43 - and other types of attacks proper data
356:46 - validation can significantly reduce
356:48 - these risks error preventing by
356:51 - validating Data before it's processed
356:54 - you can prevent errors that might occur
356:57 - during string processing if you receive
356:59 - a number where you expect a string it
357:02 - can cause errors in your code data
357:05 - validation helps detect these issues
357:07 - early user experience validating input
357:11 - on the server side and providing clear
357:14 - ER message can greatly improve user
357:17 - experience it lets users know what they
357:20 - did wrong and how to correct it rather
357:23 - than leaving them guessing performance
357:26 - receiving large amount amount of
357:28 - incorrect or poorly formatted data can
357:31 - affect your API performance validation
357:34 - can serve as a first line of defense
357:36 - against unnecessary processing such data
357:40 - and finally business logic compliance
357:43 - often business rules determine the
357:45 - acceptable values or formats for certain
357:48 - data fields validation ensures that the
357:52 - data your API receives and processes
357:55 - complies with these business rules now
357:57 - now let's see in action how we can
358:00 - implement this in a spring boot
358:02 - application the first thing that we need
358:04 - to do is to add the required and the
358:07 - needed dependency for validation and
358:11 - spring boot provides already a starter
358:13 - for validating objects so let's go to
358:16 - our pom.xml file and here after spring
358:20 - data jpa for example I'm going to make
358:22 - this one full screen let's add a new
358:25 - dependency so here we need the
358:27 - dependency called Spring boot starter
358:31 - validation and it comes from the same
358:34 - group ID which is org. springframework
358:36 - dop put and then all you need to do is
358:39 - to click on this button to load the
358:41 - maven project or the maven changes or
358:44 - right click and then reload project and
358:47 - like this Maven will download this new
358:49 - dependency and now we are ready and able
358:53 - to use this dependency within our
358:55 - project so the next step let me show you
358:58 - how you how we can validate objects just
359:01 - using some annotations and use the power
359:04 - of spring wot starters to delegate
359:07 - almost everything now the question that
359:10 - you need to ask is where to add the
359:12 - validation so we mentioned before that
359:15 - validation within spring boot starter
359:17 - validation it's just a bunch of
359:20 - annotations that we need to add to some
359:22 - fields and then spring will do the rest
359:25 - for us of course it will not do it by
359:27 - itself self but we need to tell spring
359:30 - that we want to validate this object
359:33 - that contains the validation annotations
359:36 - so the answer is we need to add the
359:38 - validation on the first entry point
359:41 - object that we use to interact with our
359:43 - rest API so now I guess you get what I
359:47 - what I mean and this is on the on the
359:49 - dto level so for example here if we go
359:53 - to our student controller and go to the
359:56 - Post mapping the method that helps us to
359:58 - create or to save a new student we
360:01 - request a student dto object so the
360:04 - validation needs to be done on this
360:07 - level all right so let me show you how
360:09 - we can validate this object so first as
360:13 - I mentioned we need to add some
360:14 - annotations telling spring boot stter
360:17 - validation what are the validations or
360:20 - what are the controls that we want to
360:22 - add on each field of our object and
360:25 - these annotations are valid whether you
360:29 - work with records or if you work with
360:31 - only simple classes or simple poos let's
360:35 - first start by validating for example
360:38 - our first name and let's say that we
360:41 - want to make sure that the first name
360:43 - should not be empty okay so here we have
360:47 - an annotation called not empty and here
360:51 - to make sure that this is the right and
360:53 - the correct annotation it comes from
360:56 - Jakarta validation. constraints or if
360:59 - you are using spring 2.7 something or
361:02 - like a pror version before the spring 3
361:06 - it will be Java x.v validation.
361:08 - constraints so now let's use this not
361:11 - empty annotation on the first name so
361:14 - I'm going to make this one full screen
361:16 - so this not empty annotation let's go
361:20 - and check the documentation and the code
361:22 - of this annotation always don't forget
361:24 - to download the source code so you have
361:27 - everything think clear and and complete
361:29 - so here it says that the annotated
361:31 - element must not be null or empty okay
361:35 - so if we add um the not empty annotation
361:39 - to a field of type string or here we can
361:42 - see the lists or the support types for
361:45 - this annotation so here the supported
361:48 - types are so here we have char sequence
361:51 - so this means the length of character
361:53 - sequence is evaluated or a collection so
361:56 - the collection size is evaluated a map
361:59 - the map size is evaluated or an array
362:02 - this means that the array L length is
362:05 - evaluated so here it will make sure so
362:08 - this annotation will make sure and
362:10 - ensure that the first name is not null
362:13 - and is not empty this means that the
362:15 - length should be greater than zero so
362:19 - also I will add this not empty
362:21 - annotation to the last name just to make
362:23 - sure that the first name and the last
362:25 - name are not empty when we try to create
362:28 - a new student so now let's move on and
362:31 - let me show you how we can make or how
362:33 - we can tell spring to validate the
362:36 - student dto when we receive a request
362:39 - body from the user or from the rest
362:41 - client sending us an object and we want
362:44 - to transform it to student dto so let's
362:47 - see how we can validate that so this
362:49 - student dto is used to interact with the
362:52 - student controller so as we can see here
362:55 - we have in the post mapping for the
362:57 - method save student we have a request
362:59 - body of type student dto so we need to
363:02 - tell spring that this object should be
363:05 - validated so now how to do that all we
363:08 - need to do is to add an annotation
363:11 - called valid and this annotation valid
363:14 - comes from Jakarta do validation so it's
363:17 - the same package as the the not empty so
363:21 - here this one is Jakarta Dov validation.
363:23 - constraints so these are the constraints
363:25 - that we can use and here is is the valid
363:28 - comes from the Jakarta validation
363:30 - package so you need to be careful about
363:33 - that because if you import the wrong
363:35 - annotation the application might not
363:37 - work so now let's start our application
363:40 - and test these changes so let's start
363:43 - the application and then let's go to
363:45 - postman and send an student dto object
363:48 - but with the first name and the last
363:50 - name with n values so here this is our
363:54 - post request and here we see that we
363:56 - have only first name and the school ID
363:59 - so here we don't have the last name so
364:01 - I'm expecting to have an exception or an
364:04 - error or validation error raised by
364:06 - Spring if we don't pass the last name so
364:08 - let's go ahead and click on it so here
364:10 - let's say Katherine as a student name
364:13 - and let's click on send so here we see
364:16 - that we have a bad request so our back
364:18 - end raised automatically a bad request
364:21 - response so let's go and check what we
364:24 - have as exceptions or what we have as
364:26 - logs so now let's check this and here we
364:30 - see that we have nothing like but we see
364:34 - just one warning so here we have a Warn
364:37 - and we have a default exception Handler
364:40 - resolver and it says here resolved an
364:43 - exception of type method argument not
364:46 - valid exception and here validation
364:49 - failed for argument zero in public
364:51 - Student Response dto and so on so forth
364:54 - so save student controller and here we
364:57 - say that field last name rejected value
365:01 - null all right so here we have an
365:03 - exception raised and rest client
365:06 - received a 400 response 400 means bad
365:10 - request as we can see right here so it's
365:12 - a bad request but with no further
365:16 - information about what happened exactly
365:19 - and here we are missing one something
365:22 - important that we explained before which
365:24 - is the user experience so the so the
365:26 - user that doesn't know what happened or
365:28 - what he missed exactly so he needs to in
365:31 - this case he needs to recheck the
365:34 - everything and then try to send a new
365:36 - request so let's see how we can catch
365:40 - this type of exception and how we can
365:42 - handle and return a proper response to
365:45 - the to the end user as we can see here
365:47 - in the logs spring validation through an
365:51 - exception of type method argument not
365:53 - valid exception so I'm going to copy
365:56 - this one and now what we need to do is
365:58 - to handle this exception inside this
366:01 - student controller so what I will be
366:03 - implementing right now I will explain it
366:06 - in details really in deep details just
366:09 - in the next lecture so now I just want
366:13 - to show you how we can handle an
366:14 - exception inside the controller and then
366:17 - we raise a proper and clear message for
366:20 - our end user so now I would just scroll
366:24 - down and here I will create a public
366:27 - method so a public and then response
366:30 - entity and then this response entity
366:33 - will be of any type and then so here I
366:36 - will say handle and then the method
366:39 - argument not valid exception and here as
366:42 - a parameter I'm expecting an exception
366:45 - of type method argument not valid
366:48 - exception so we need to import this one
366:50 - so let's import it and then let's write
366:53 - the logic for this one and of course to
366:56 - make this method a Handler method or an
366:59 - exception Handler method we need to add
367:02 - an annotation called exception Handler
367:05 - and this exception Handler takes a list
367:07 - of classes or a single class as value so
367:11 - here we want in like within this method
367:14 - we want to handle the exception of type
367:17 - method argument not valid exception so
367:20 - each time we receive or this controller
367:23 - the student controller throws an
367:25 - exception of type method argument not
367:27 - valid exception this exception will be
367:29 - handed inside this method so as I
367:32 - mentioned don't worry about that I will
367:34 - explain all this in details in the next
367:36 - lecture so for now let me create a uh a
367:40 - map let's call it errors equals new
367:44 - hashmap and this hashmap will be of type
367:47 - string and string so the first string
367:50 - will hold the field name and the second
367:53 - one will hold the message name okay and
367:56 - then what I need to do I need to get the
367:59 - exception or the validation exception
368:01 - from this method argument not valid
368:03 - exception and then transform them and
368:06 - send back a map of Key value and the key
368:10 - is the field name and the value is the
368:13 - message that was raised by the
368:15 - validation so here all I need to do is
368:17 - exp like or my exception and then that
368:21 - do get binding result and then we have a
368:24 - method called get all errors and as you
368:27 - can see it will return a list of object
368:30 - error so let's do that and then I will
368:33 - do for each so for each element or for
368:36 - each error which is returned by the get
368:39 - all errors here so like the these errors
368:42 - that we have are coming from the
368:45 - annotations that we used in here so for
368:47 - example if we use multiple annotations
368:50 - even on the same level name here so we
368:53 - will get all the errors then so now what
368:56 - need to do is I need that my object
368:59 - which is let's call it error and then I
369:01 - will use the Lambda expression and for
369:04 - each element what I will be do doing is
369:07 - I want to extract the field name and the
369:09 - error message so I will have here a VAR
369:12 - field name equals and then I need my
369:15 - error and then I need to get the field
369:19 - but I need to cast this error object to
369:22 - another type so it should be casted to a
369:25 - type of type field error so then it will
369:29 - be field error and then I have a method
369:31 - called get field so this will return the
369:34 - field name and then I need another
369:36 - variable which is the error message so I
369:40 - will call it error message equals again
369:42 - we need to we need to go to error. get
369:45 - default message so this will return the
369:48 - default error message that will be
369:50 - thrown by the exception and also get we
369:53 - get this error message from this
369:55 - annotation right here so now once we get
369:58 - the field name and the error message all
370:00 - I need to do is to store this in the
370:02 - errors map and then put and the key is
370:06 - the field name and the value is the
370:08 - error message and like this we gathered
370:11 - or like we captured all the error
370:13 - messages and we formed a proper object
370:16 - that we can expose to our customer and
370:19 - now of course we need to return a new
370:22 - response entity and then for this
370:25 - response entity we will pass the errors
370:28 - object and then a bad request so it will
370:30 - be HTTP status do bad request so now
370:35 - every time a method argument not valid
370:38 - exception will be raised inside the
370:40 - student controller this method will
370:43 - intercept this exception and try to
370:46 - extract and transform the error message
370:49 - messages that are coming from the
370:51 - validation process and transform them to
370:54 - a proper response that we can send to
370:56 - the user so now let's restart the
370:58 - application and see what happens all
371:01 - right our application is up and running
371:03 - let's go back to post none and let's
371:05 - just click on send so here we see that
371:08 - we have a proper response so here we see
371:11 - that last name must not be empty and
371:13 - even if I remove for example the first
371:15 - name we will see that we have two error
371:18 - messages because for now we have two
371:21 - annotations one is on the first name
371:23 - level and the last one is on the last
371:25 - name level so now let's let's move on
371:29 - and explore more annotations and how we
371:31 - can validate and give proper validation
371:34 - and proper control on the fields that we
371:37 - have for each object all right before we
371:40 - move on and explore more annotations
371:43 - first let's see something or a property
371:45 - which is really important and let's see
371:48 - here we have first name and then we have
371:51 - a message must not be empty so this
371:54 - message is the default message coming
371:56 - from the spring boot starter validator
371:59 - and then what we need to do or what we
372:01 - can do we can customize this message so
372:05 - instead of having first name must not be
372:08 - empty we can set our proper or our
372:11 - custom error message so let me show you
372:14 - how we can do that so here on the
372:16 - student dto level where we have the not
372:19 - empty annotation here we have a property
372:22 - called message and as you can see here
372:25 - by default it's just carta. validation.
372:28 - constraints.
372:29 - empty. message but we can provide our
372:32 - own proper message and here for example
372:35 - let's say first name should not be empty
372:39 - and this should not be empty and this
372:43 - message will be returned to the user
372:46 - also I can copy that and add this
372:50 - message to the last name and here I will
372:52 - say instead of first name I will just
372:54 - say last name so now let's restart the
372:57 - application and see the impact or how
373:00 - this is going to be displayed on our
373:02 - postm now all I need to do is to click
373:04 - on send again and here we see we have
373:07 - first name should not be empty and last
373:10 - name should not be empty and in this
373:13 - case we can even enhance a bit a little
373:15 - bit the code that we created so we no
373:18 - longer need to expose the field name
373:21 - that we have in our back end all right
373:24 - so let's go ahead maybe UND do this or
373:26 - we can just for now leave it as it is
373:29 - because I will show you a better way how
373:31 - to validate objects so now we can move
373:34 - on and explore the rest of the
373:36 - annotations that we can use to validate
373:39 - the different type of objects and the
373:41 - its different boundaries so in the
373:44 - project if you go to external libraries
373:46 - and then scroll down it's almost in the
373:48 - middle and you will see a dependency
373:51 - called Jakarta validation so this is the
373:54 - dependency that we added already in the
373:56 - pom.xml file and then if you if you
373:59 - expand this one you will see a package
374:02 - called Jakarta validation and then you
374:04 - have a sub package called constraints
374:07 - and here we we see the list of all the
374:10 - annotations that we can use to validate
374:13 - fields in a class and now let's walk
374:16 - through these annotations and see what
374:19 - are the use cases for each one so for
374:22 - example here we have the first one
374:24 - assert fals and and from the
374:26 - documentation the annotated element must
374:29 - be false and the same for us or true
374:32 - this means that the annotated element
374:35 - must be true for example if you have a
374:37 - Boolean field and you want to add the
374:41 - validation that this Boolean field
374:43 - should be true or false you can use The
374:45 - annotation assert true or assert false
374:49 - now we let's move on to the decimal Max
374:51 - and this one this annotated element must
374:54 - be a number whose value must be lower or
374:57 - equal to the specified maximum so if you
375:00 - want for example that a field or a value
375:04 - should not pass the value equals 100 for
375:08 - example you can use the decimal Max and
375:10 - give it the value 100 and then the
375:13 - validation will take care of the rest
375:14 - and make sure that the value we that the
375:17 - value we receive should not go beyond
375:20 - 100 and the same for the decimal Min so
375:24 - this will check and validate if this
375:27 - decimal or if the value should not be
375:30 - under that value we specified and here
375:33 - also you need to check the supporter
375:35 - types so here we have so for the B
375:38 - decimal Max and decimal mins so we have
375:41 - it applies to Big decimal big integers
375:44 - Char sequence bite short in long and
375:47 - their perspective wrappers so wrappers
375:51 - means the integer class and the long
375:53 - with with uh an uppercase or a capital L
375:57 - and so and so forth the next one we have
375:59 - digits so this annotation the annotated
376:03 - element must be number within accepted
376:06 - range so here we have a message group
376:09 - and we have fraction and we have a list
376:11 - of properties that we can specify when
376:14 - we use this annotation and the next one
376:17 - is email so as the name mention so this
376:21 - one it will make sure that an email
376:23 - address or string email address should
376:27 - be well formed and here we have by
376:30 - default or we have a default rejects for
376:33 - the email so this is the one provided
376:36 - already by the Jakarta validation but if
376:39 - you want to provide your own email
376:41 - formatting rejects just use the the
376:44 - property called rejects p and you will
376:47 - be able to format or to give the rejects
376:50 - for your email then we have the future
376:53 - annotation so this annotation is a
376:56 - appliable to all the date types as you
376:59 - can see here so here this annotated
377:02 - element must be an instant date or time
377:05 - in the future so when for example when
377:08 - you have a field date let's say for
377:10 - example uh event or event date or
377:13 - something like that and we want to make
377:15 - sure that this event date should be in
377:17 - the future we can annotate this field
377:20 - with the future annotation and then of
377:23 - course the spring boot starter validator
377:26 - will take care of the rest so also if we
377:29 - want the DAT to be future or present we
377:32 - can use this future or present
377:34 - annotation to validate that then we have
377:37 - the Max and Min so the Max and Min so
377:40 - this annotated element must be a number
377:43 - whose value must be lower or equal to
377:45 - the specified maximum and the same for
377:48 - the minimum and here we see also the
377:50 - list of the supported types then if we
377:53 - want a value to be negative or you need
377:56 - to do is to an annotate the field with
377:59 - the negative annotation so this
378:01 - annotated the annotated element must be
378:03 - a strictly negative number for example
378:06 - zero is considered as an valid value so
378:09 - it will should be or the value should be
378:12 - lower than or strictly lower than zero
378:16 - and then we have if we want to accept
378:18 - zero values for example we have The
378:20 - annotation negative or zero and it will
378:23 - do the same except that that this
378:25 - annotation accepts the zero value then
378:28 - we have the not blank annotation so this
378:32 - annotated element must be not null and
378:35 - must contain at least one nonwhite space
378:39 - character so this is important so for
378:41 - example if I pass a white space and I
378:44 - use the not blank annotation to validate
378:46 - the field so this will throw a
378:49 - validation exception as we saw before so
378:52 - here we have the not empty and the not
378:54 - empty we already used and we saw in
378:57 - action so this will just ensure that the
379:00 - element must not be null or empty but it
379:03 - accepts white spaces and then we have
379:06 - the not null so for the not null it just
379:08 - checks that if the value or if the
379:10 - element must not be null and then we
379:13 - also of course have the null so since we
379:15 - have the not null we have also the null
379:18 - so this checks or um specify uh that the
379:23 - annotated element must be a null Val
379:25 - value and here it says accepts any type
379:29 - so we can use this null or not null on
379:31 - any type so then we have we go back
379:35 - again to the to the date annotations so
379:37 - here it's exactly the same as future and
379:40 - uh and future or present we have also
379:43 - past or past or present so for example
379:45 - past we can apply it to date of births
379:48 - to uh a date that we wanted to be in the
379:51 - past also we have the past or present
379:53 - where we can use this annotation to make
379:56 - sure that the date should be in the past
379:58 - or we also accept a present date so
380:01 - present date means today's date then we
380:04 - have the pattern annotation so this
380:06 - pattern annotation is appliable on
380:09 - annotated uh or a field of type chge
380:12 - sequence must be a match for the
380:14 - specified regular expression so here we
380:17 - have like 100% freedom to specify the
380:20 - regular expression that we want to to to
380:24 - use it to validate the this field and
380:27 - then we have positive so this ensures
380:29 - that the the annotated element must be a
380:32 - strictly positive number so zero is Al
380:35 - also considered as an invalid value so
380:39 - here you need to know exactly the
380:41 - difference between for example positive
380:43 - and positive or zero so pos positive or
380:46 - zero just the difference that it accepts
380:49 - zero and finally we have the size
380:52 - annotation so the annotated element size
380:55 - must be between the specified boundaries
380:57 - and for example here if I have a string
381:00 - and I want the size or the length of
381:02 - that string to be between a minimum and
381:05 - a maximum value all I need to do is to
381:07 - use the size and then specify the minan
381:10 - and the max values so these are the the
381:13 - all the annotations or all the
381:15 - validation annotations that we can use
381:18 - also we can create custom annotations
381:21 - but this we might cover in the future
381:23 - lesson for now let's move on and let me
381:26 - show you how to validate or like how
381:28 - like it's a proper way to validate
381:31 - objects all right so now we implemented
381:35 - or we are almost done with the
381:36 - implementation of our rest API we also
381:39 - organized the code we added the
381:41 - validation we are the mapping our code
381:43 - is well organized and each part and each
381:46 - domain is in uh is in its own package
381:49 - and everything is all right also we test
381:52 - the application and the application is
381:54 - working fine but the question is are we
381:57 - done with this implementation so let me
382:01 - give you the answer so the answer is no
382:04 - because we are missing really a crucial
382:07 - part and a critical part of the
382:10 - application which is testing yep exact
382:14 - it's all about testing because why we
382:16 - need test because for example if I do a
382:19 - small change in one of the domains that
382:22 - we have what are my guarantees to say
382:25 - that this change won't impact anything
382:28 - else so software testing is a crucial
382:31 - process in the realm of software
382:34 - development designed to identify and
382:37 - rectify defects errors and
382:40 - inconsistencies with a software
382:42 - application it serves as a quality
382:45 - assurance mechanism ensuring that the
382:47 - software performs as intended and meets
382:51 - the requirements and expectations of
382:53 - both developers and and users through a
382:56 - systematic and a structured approach
382:59 - software testing evaluates various
383:01 - aspects of programs functionality
383:04 - usability security and performance so
383:08 - then in the next part first we will see
383:10 - what is the importance and how spring is
383:13 - going to help us for testing and after
383:16 - that we will try and we will do testing
383:19 - and we will see software testing in
383:22 - action so we will implement the three
383:24 - parts of Tes testing so unit testing
383:27 - integration testing and endtoend testing
383:30 - so stick with me and I'm really happy
383:34 - you reach this part and let's go
383:40 - ahead implementing tests for a spring
383:43 - boot application is important for
383:46 - several reasons first we talk about
383:49 - quality assurance so tests help ensure
383:53 - that your application functions as a
383:55 - expected they identify bugs error and
383:58 - expected Behavior early in the
384:00 - development process allowing you to fix
384:04 - issues before they reach production and
384:07 - then regression testing as you make
384:09 - changes or add new features to your
384:12 - application tests act as a safety net to
384:16 - the catch regressions they ensure that
384:20 - existing functionality continues to work
384:23 - as intended even after code changes also
384:28 - test serves as documentation for your
384:30 - code base they provide examples of how
384:33 - your code should be used and demonstrate
384:37 - its expected Behavior this is especially
384:40 - helpful for other developers who may
384:43 - join the project later on also a well
384:46 - written tests encourage good coding
384:49 - practices and modular design they often
384:53 - lead to the more modular Lo L coupled
384:56 - code that is easier to maintain and
384:59 - refactor when you want to refactor or
385:02 - optimize your code tests provide a
385:04 - safety net they allow you to make
385:07 - changes with the confidence that you'll
385:10 - immediately know if something
385:13 - breaks also the test facilitate
385:16 - collaboration among developers when
385:19 - multiple team members are working on the
385:21 - same codebase tests ensure that changes
385:25 - made by one developer don't negatively
385:28 - impact the work of others also in a cicd
385:32 - pipeline or like continuous integration
385:34 - continuous deployment pipeline tests are
385:37 - run automatically whenever new code is
385:41 - pushed this helps catch issues early in
385:44 - the development process and prevents
385:47 - faulty code from reaching
385:49 - production also wrting tests can take
385:53 - more time up front but it can
385:55 - significantly reduce the time spent on
385:58 - debugging later in the development
386:01 - process it's much easier to identify the
386:04 - root cause of a failure when you have a
386:07 - well- defined
386:09 - tests as your application grows the
386:12 - complexity also increases tests provide
386:15 - a safety net that allows you to
386:17 - confidently make changes and add
386:20 - features without introducing unexpected
386:23 - issues and finally
386:25 - of course tests certain types of tests
386:28 - like security and vulnerability tests
386:31 - help identify potential security
386:33 - weaknesses in your application this is
386:36 - crucial for protecting sensitive data
386:39 - and ensuring the overall security of
386:41 - your application so generally speaking
386:44 - in a Springwood application you can
386:47 - Implement various types of tests
386:50 - including unit tests integration tests
386:53 - and even endtoend tests so each type of
386:56 - test focuses on a specific aspect of
386:59 - your application's functionality and
387:01 - provides a comprehensive safety net to
387:04 - ensure its reliability and
387:08 - correctness now let's see how spring can
387:11 - help us in implementing the test and
387:13 - what spring provides exactly so first
387:17 - spring provides utilities and
387:19 - annotations for testing applications so
387:22 - the test support is provided by two
387:24 - modules the spring boot test contains
387:27 - core items and the spring boot test Auto
387:30 - configure supports Auto configuration
387:32 - for
387:33 - testing and then we have also the spr
387:36 - spring boot starter test which Imports
387:39 - the following modules first of all we
387:42 - have the spring boot test module we have
387:44 - also junit assertj hum Crest and number
387:48 - of other useful
387:50 - libraries so a springbot application is
387:54 - a spring application context and this I
387:57 - will explain it more in details when we
388:00 - go to the practice
388:02 - part so the spring boot provides a
388:05 - spring boot test annotation when you
388:07 - need spring boot features during test so
388:10 - for example if you want to load the
388:12 - application context in your tests all
388:14 - you need to do is to annotate your class
388:17 - with the spring boot test
388:19 - annotation and then in case you are
388:22 - using junit 4 you need to add the The
388:25 - annotation run with spring runner. class
388:28 - to your test otherwise The annotation
388:30 - will be
388:32 - ignored other than that if you are using
388:35 - junit 5 there is no need to add the
388:38 - equivalent extend with spring extension
388:42 - as the spring boot test annotation and
388:45 - the other annotations will be already
388:48 - annotated within the at Spring boot test
388:51 - so now we mentioned that spring comes
388:54 - with a spring uh spring test Auto
388:56 - configuration module so the spring boots
388:59 - Auto configuration system works well for
389:01 - applications but can sometime be a
389:04 - little too much for tests so it often
389:07 - helps to load only the parts of the
389:09 - configuration that are required to test
389:12 - a slice of your application so the
389:14 - spring boot test autoconfigure module
389:17 - includes a number of annotations that
389:19 - can be used to automatically configure
389:22 - such slices and finally each slice
389:25 - restricts component scan to appropriate
389:29 - component and loads a very restricted
389:32 - set of autoconfiguration classes now we
389:34 - are done with the theoretic part this
389:37 - might be a little bit too much or like
389:39 - too much talking now we will move to the
389:42 - practice part and you will be able to
389:44 - understand and start implementing tests
389:47 - your own so let's move on and let's go
389:50 - ahead and do it all right now let's dive
389:54 - into the implementation of tests for our
389:57 - different classes so here this is the
390:00 - diagram or the composition or the class
390:02 - diagram of our small application and I'm
390:05 - focusing only on the student domain so
390:08 - here we see from the bottom to the top
390:10 - we have the student composed of the
390:12 - student service this means that the
390:14 - student controller uses the student
390:16 - service and the student service use both
390:20 - uh of student repository and student
390:22 - mapper and the student mapper will use
390:25 - both object student and Student Response
390:27 - dto so now I want to tell you and
390:31 - explain to you what you need to
390:33 - implement test for so what do you need
390:35 - to test which classes and which objects
390:37 - you need to implement tests for so here
390:40 - we see that the Student Response D and
390:42 - the student object they are just classes
390:45 - so there is no logic inside it so it's
390:48 - just a class holding some information
390:50 - about the student and this class or this
390:52 - record is only holding some information
390:55 - about the Student Response dto now if we
390:58 - go a level down we see that we have the
391:00 - student mapper and then we have the
391:02 - student repository so the student
391:04 - repository we can also Implement test
391:07 - for that but it doesn't make sense or
391:09 - it's not really required to implement
391:12 - tests for repository so we will skip
391:15 - this one now let's start with the
391:16 - student mapper so the student mapper
391:19 - right here so if we go to the navigation
391:21 - or if we navigate to the student mapper
391:23 - right here to this class class we see
391:25 - that we have two methods all right so
391:28 - now I want you to change a little bit
391:30 - your mindset and suppose that you don't
391:34 - know the code before so you just have a
391:36 - mission or you're asked just to
391:38 - implement tests for these classes so
391:40 - here we have two methods to student and
391:43 - to Student Response dto so the first one
391:45 - will return student object and the
391:47 - second one will return a student
391:49 - response dto so normally from the name
391:52 - of the method we can understand what is
391:55 - its functionality otherwise we can go
391:57 - ahead and read the code so we don't need
391:59 - that because we already implemented this
392:00 - our own and now what we need to do is to
392:04 - create a test class for this student
392:07 - mapper so to create a student mapper
392:10 - test class let's start with the
392:12 - recommendation so here we see that we
392:14 - have the Java and this is the base
392:17 - package that we have which is com. al.
392:20 - example and then we have school and
392:22 - student and student profile and so and
392:24 - so forth forth here if we check the test
392:27 - we have also Java and then com. alibu
392:30 - example and here we have also example
392:32 - application test which is the same or
392:35 - like the same loader class or the class
392:38 - that will load the application context
392:40 - for our test so for now we will just
392:42 - ignore this one and I will explain it in
392:45 - the coming sections all right now the
392:48 - first recommendation is when you create
392:50 - a test class for one of the for one of
392:53 - the services or the CL classes that you
392:55 - want to test be sure and make sure that
392:57 - you keep the same package naming so you
393:01 - you need to keep the same hierarchy of
393:04 - of packages and folders just to make it
393:06 - easy to find so you can just create it
393:09 - anywhere or like even without creating
393:11 - packages but the recommendation to make
393:14 - your test classes clean and clear and
393:17 - easy to understand and easy to point you
393:19 - just need to keep the same hierarchy or
393:23 - like the same package hierarchy and we
393:25 - are lucky because our IDE whether you
393:28 - are using anj Eclipse net beIN and so on
393:32 - so forth you always have some shortcuts
393:35 - and you have the instruction and menu to
393:37 - generate test classes for the class that
393:39 - you want to test so here if I open back
393:42 - my test student or like my student
393:44 - mapper class and I want to generate a
393:48 - test class for it so if I do like um
393:51 - right click and then let's click on
393:53 - generate right here so here we see that
393:56 - we have many options and among these
393:59 - options we have test so if I click on
394:01 - test you will see that it will be it
394:03 - will be generating a student mapper and
394:06 - then it will have or it will give it a
394:07 - suffix called test all right and here
394:11 - you see the destination package it will
394:13 - be com. al. example. student you can
394:16 - select a different one or you can change
394:18 - the name and so on so forth but as I
394:20 - mentioned before I recommend you keep
394:22 - the same the same hierarchy and then you
394:26 - also can generate methods for setup tear
394:29 - down or also showing the inherited
394:31 - methods and even you can generate two
394:34 - methods or like two test methods for the
394:35 - two student and two Student Response dto
394:39 - but for now we won't do that we will do
394:41 - it one by one and step by step so I will
394:45 - cancel then we have a different option
394:47 - so here just um focus on this area you
394:51 - will have this green popup to show you
394:53 - which uh command or which shortcut or
394:56 - keyboard shortcut that I will be using
394:58 - in order to navigate to the test so here
395:03 - if you do uh command shift t or Control
395:06 - Plus shift plus T if you are using
395:08 - Windows or Mac anj will try
395:10 - automatically to navigate you to the
395:12 - test class of this student mapper all
395:15 - right but if it can't find any test
395:17 - class it will suggest you to create a
395:19 - new one so it will also open and display
395:23 - the same window that we use before or
395:25 - that we saw together before and here for
395:27 - the testing Library since we are using
395:29 - Java like recent version of java and
395:31 - also like a recent version of spring
395:33 - boot so we we can keep or we can use the
395:36 - junit 5 also if you have another project
395:40 - uh using junit 4 for example I already
395:42 - explained that before that you need to
395:44 - add few annotations or like one
395:46 - annotation in order to make it work so
395:49 - now all we need to do is to click on
395:52 - okay button and here you see see that
395:55 - automatically a new package was created
395:58 - and it contains a new student mapper
396:01 - class test all right so now we have
396:03 - everything ready let's go ahead and
396:05 - start implementing or let's start
396:07 - writing the first test method that we
396:10 - have for our student mapper
396:12 - class all right so first of all let's
396:15 - generate a first test method to create a
396:18 - test method all you need to do is to
396:20 - create a public void so this is this
396:24 - signature and it should be always public
396:27 - void and then the method name so let's
396:30 - call it test method one so this this
396:33 - will be the first test method and the
396:35 - test method is a method without any
396:38 - parameters so here to make this test
396:42 - method as a test method so all we need
396:45 - to do is to add The annotation test so
396:48 - the test it comes from org. gun.
396:51 - jupiter. API so here once we are this
396:54 - test you see automatically that now we
396:56 - have this button to run this single
396:59 - method or you have this button right
397:02 - here to to run all the test methods
397:04 - inside this class so let's first of all
397:07 - just add a system.out do print Ln and
397:11 - here my first test method and now let's
397:15 - run this test class using this play
397:18 - button to run only this method since we
397:20 - have only one or if we want we can run
397:23 - the whole test so let's run student
397:25 - mapper test class and then you will see
397:28 - that it will open the test View and here
397:32 - we have the
397:34 - system.out.println the message that we
397:36 - printed my first test method and the
397:40 - test was green since we have nothing to
397:42 - assert yet we will come to this in few
397:45 - moments but before that we need to
397:48 - understand what are the properties and
397:50 - what are the things that we can do
397:52 - within a test class so the first thing
397:54 - that we need to know is that we have a
397:57 - setup method or we can create a setup
398:00 - method so if you click on generate here
398:03 - you will see that you have a setup
398:05 - method you can generate it automatically
398:08 - or you can even write it your own so
398:10 - let's generate it and see what it what
398:12 - is this method so it's just a void
398:15 - called setup and it contains an
398:17 - annotation called before each so this
398:20 - means that this before each method or
398:23 - this setup method will be executed
398:26 - before each test that we have and we
398:29 - mainly use this setup in order to
398:31 - initialize few things or few parameters
398:34 - or anything that we want to initialize
398:37 - before running any test method that we
398:39 - have so I will just copy this message
398:42 - right here and here I will just write
398:45 - inside before each method and now if I
398:48 - run again my
398:50 - class let's see what will be the output
398:53 - so here we have have if I click in here
398:55 - we have inside the before each method
398:57 - and then my first test class so now I
399:00 - will just duplicate this method right
399:02 - here and I will call it my test method
399:05 - two and here I will say my second test
399:09 - Method All right so I will rerun again
399:12 - the
399:13 - class and here we see that this one we
399:17 - have inside the before each method my
399:19 - first test and here we have also inside
399:22 - the before each method and then my
399:24 - second test so as I mentioned this
399:27 - before each will be executed before each
399:30 - test class so in case as I mentioned
399:32 - before in case we want to initialize
399:35 - anything before running the test Method
399:38 - All right so also as before each we have
399:41 - other methods and let's go ahead and
399:43 - explore them one by one in order to
399:47 - understand the structure of a test class
399:50 - and what are the usages and the benefits
399:52 - of using this methods all right also if
399:56 - we want to execute any script for
399:59 - example to reset the values of variables
400:02 - or classes or services or whatever we
400:05 - also have a method we call it tear down
400:08 - so the tear down is after each execution
400:12 - of test method so here let's use the
400:15 - generate again and here we see that we
400:17 - have the tear down method so let's
400:19 - generate it and here you see after each
400:22 - so let's copy this same message and here
400:26 - inside the after each method when we run
400:29 - the test class we will see inside before
400:31 - each method and then my first test
400:34 - method and finally inside after each
400:37 - method so let's go ahead and execute it
400:39 - and see the output of this execution so
400:43 - now I'm going to select the first method
400:45 - and as I mentioned we see inside before
400:47 - each my first test and then inside after
400:50 - each so as I mentioned before in case
400:53 - you want to reinitialize or for example
400:56 - to change the value of a specific
400:58 - attribute or for example if you are
401:01 - running your test against database so
401:03 - you can just initialize and insert some
401:05 - data in the before each and after each
401:08 - you can delete them or re-update the
401:10 - data in order to be able to use them in
401:14 - in the next Method All right so now
401:16 - let's move on and let's see what are the
401:19 - other methods other than the before each
401:21 - and after each all right now the
401:25 - question is what if I want to execute a
401:29 - setup or to initialize a few attributes
401:31 - and variables only before the execution
401:34 - of the the whole class so I don't want
401:37 - to run this method before each method
401:41 - but I just want want it to be executed
401:43 - only once so in this case we have also
401:47 - another method so let's click on
401:49 - generate and here we see we have a
401:51 - before class so when I use a before
401:54 - class so it's called a before all again
401:57 - I will copy this message and here I will
402:00 - say inside the before all method so now
402:03 - when I run my test so you can whether
402:05 - run it from here or again click on this
402:08 - play button or just run one of the tests
402:11 - so let's go ahead and run and rerun the
402:14 - whole class and see what we have so for
402:16 - example let's select this one so here we
402:19 - have first when we select the method we
402:22 - see only this three output messages
402:25 - which is the before each the method and
402:28 - then the after all but when I select the
402:30 - class we see that we we are inside the
402:33 - before all methods and then inside the
402:35 - before each method and the after each
402:38 - method and we have it again for the
402:40 - second method so now just I want to make
402:42 - this output clear so I will be running
402:45 - only one method so like that you will
402:47 - see it in a better way so now we see
402:51 - that we are inside the before all method
402:53 - and then inside the before each my first
402:56 - method and then inside the after all
402:58 - method so this is the case if I want to
403:02 - initialize something a service for
403:03 - example or to create a new instance of
403:06 - an instance or an array list uh or
403:08 - something like that but I just want it
403:10 - to I want to do it only one time I don't
403:13 - want to do it each time so in this case
403:16 - we need or we use the before all method
403:19 - so now in the same way we have another
403:22 - method called after all so let's go
403:25 - ahead and try this one and then let's
403:28 - move to the real implementation of the
403:30 - real test cases of our student mapper
403:33 - class all right in the same way let's
403:36 - generate an after class or an after all
403:39 - method and again I will just copy paste
403:42 - and here inside the after all method so
403:46 - if I run one of the test classes or the
403:49 - test methods that we have and here let's
403:51 - go ahead and check the output so here we
403:54 - have inside the before all and then
403:56 - inside the after all and in between we
403:59 - have the before each the the test method
404:01 - and the after each so the use case of
404:04 - the after all and the before all is for
404:07 - example I want to initialize or insert
404:10 - some data into my database in case we
404:12 - are using for example an inmemory
404:14 - database so I want to insert some data
404:17 - and then once I'm done I want to remove
404:20 - them for example or even if I'm working
404:22 - against my Dev environment uh database
404:25 - or something like that so in this in
404:27 - this way we can initialize data work
404:30 - with them and once we are done we can
404:32 - remove all the data that we already
404:35 - inserted so in this in this way we are
404:37 - safe from polluting and inserting wrong
404:41 - data into our database all right so now
404:44 - you know the structure of a test class
404:47 - what are the methods that we can use
404:49 - within a test class so now let's go
404:52 - ahead and start and implementing few
404:55 - test cases for our student mapper
404:58 - class all right now let's start
405:01 - implementing our tests first of all
405:03 - let's start by cleaning up all this code
405:06 - so let's remove it and also let's
405:07 - reoptimize the Imports and now let's
405:11 - implement the first method so here just
405:13 - to remind you we have our student mapper
405:17 - class that performs a mapping so it
405:20 - transforms a student dto to a student
405:23 - object object and then we have to
405:24 - Student Response and it transforms a
405:27 - student to a student response dto so now
405:30 - coming back to our student mapper test
405:33 - so here the first thing that you need to
405:35 - do is to declare the service that you
405:38 - want to test so here we want to test our
405:41 - student mapper so let's create an object
405:44 - of type student mapper and then let's
405:47 - call it mapper for example and then the
405:50 - first method or like the first use case
405:52 - or the test case that we want to
405:54 - implement is that we want to make sure
405:57 - that these two student mapper performs a
406:00 - correct mapping from student dto to the
406:02 - student object so here let's create our
406:05 - first method public void and let's call
406:09 - it should map student dto to student
406:14 - class all right so this is our first
406:17 - method and to make it a test method we
406:19 - need to add always the test annotation
406:22 - so the then you see that this student
406:25 - mapper right here is not yet
406:27 - instantiated so we don't have an
406:29 - instance or an object of type student
406:31 - MPP so it's just the variable or the
406:33 - field so now we have two options whether
406:37 - to initialize it in here so we can do
406:39 - new student mapper or we can use one of
406:42 - the test of of the setup methods so here
406:46 - we can add a before each and then we can
406:49 - move this part right here to this setup
406:52 - method so we can make it this way or the
406:55 - other way around so let's go ahead with
406:57 - the before each so now we have our
406:59 - mapper object initialized and now let's
407:02 - start creating and implementing our
407:05 - first test method so here the first
407:07 - thing that we need to do we need to
407:10 - create an object of type student dto
407:13 - since this is the input of our two
407:15 - student method so now let's go ahead and
407:18 - do it so here we have an object of type
407:20 - student dto let's call it dto equals new
407:25 - student dto and for this let's call it
407:29 - John and then for the last name let's
407:32 - call it
407:33 - do and we have an email so John mail.com
407:38 - for example and then we have an INT the
407:41 - school ID so in this way so I'm going to
407:44 - just inline this one so in this way we
407:47 - have our student object so after that
407:50 - all we need to do is to call the to
407:53 - student method so here let's create an
407:56 - object of type
407:57 - student and let's call it student equals
408:01 - our mapper DOT to student and then we
408:04 - pass the student dto and then we will
408:08 - start asserting that the output of this
408:12 - mapping method is what we expect so here
408:16 - let's go back to this two student method
408:19 - and we know that we when we call this
408:21 - student method we just set these fields
408:25 - and then we have an object of type
408:27 - school so again we can test so what we
408:29 - want to focus on is that we have also a
408:32 - mapping for this school object and that
408:34 - we have all the fields not changed so
408:37 - now let's first start by asserting and
408:40 - in order to assert so here we have
408:43 - assert equals and this assert equals so
408:47 - it comes from assertions so the
408:50 - assertions is from the package org. gun.
408:53 - jupiter. api. assert equals and here for
408:58 - the assert equals we have multiple
409:00 - implementation so we can assert equals
409:03 - shorts bytes uh strings integers and so
409:06 - and so forth so here let's do assert
409:09 - equals and then what we want to test we
409:12 - want to make sure that our dto doget
409:15 - first name to be equals our student
409:18 - object. getet first name so here we want
409:22 - to make sure that that this first name
409:24 - is the same for the class student all
409:27 - right so now also we can import
409:30 - statically this assert equals and we can
409:32 - do that by add static import for the
409:36 - unit uh Jupiter API assertions do assert
409:39 - equals so when we do that and when we go
409:42 - up so you will see right here that we
409:44 - have a static import for that method so
409:47 - the next time you see assert equals or
409:50 - any static usage of a method so you know
409:53 - that it's statically imported in here
409:55 - all right so now let's continue the
409:57 - assertion and here we have the first
409:59 - name let's also test the last name and
410:02 - here get last name and after that we
410:05 - have the email and also here get email
410:09 - and finally we want to make sure that
410:12 - this the school is not null so here for
410:14 - example we have the assert not null so
410:18 - as you can see here so I want to assert
410:21 - not null that my student student. getet
410:24 - school is not null all right so then we
410:29 - can also make sure that the school ID
410:32 - was correctly set so what I can do we
410:35 - can assert equals so our dto do school
410:39 - ID is the same as student. getet
410:44 - school.get ID so at this level we are
410:48 - safe because we have an assertion that
410:50 - the school is not null but if if we
410:53 - change the order we might encounter a
410:55 - null pointer exception in case this
410:58 - school is not correctly mapped so now
411:00 - let's just go ahead and run this test
411:03 - method and let me show you what is the
411:05 - impact and the execution of this method
411:08 - so here we see that the method was green
411:11 - but now you might ask the question I'm
411:13 - just making sure that this object that I
411:16 - created manually is the same as I called
411:19 - this method so now let's go to our
411:21 - student and for example Le let's say
411:24 - that I forgot to set the school to the
411:26 - student object and now if I go back and
411:29 - rerun again the test let's see what will
411:31 - happen so here we have a test failed so
411:35 - here we see that expected not null but
411:38 - the object was null at this point so
411:42 - here you see that assert not null of the
411:45 - school so this means that the school was
411:47 - null and I'm expecting the school to be
411:50 - not null so now step by step you see the
411:53 - importance of having unit tests within
411:56 - our application so let's go back to the
411:58 - mapper and let's bring this back and
412:01 - then for example let's say when I
412:04 - transform the first name or the last
412:06 - name I just I just do to
412:09 - uppercase all right so I transform the
412:12 - first name to an uppercase if I rerun
412:14 - the test
412:15 - again you will see that the test will
412:18 - fail and here we see this message so
412:21 - here we have assertion failed error and
412:24 - the expected was John which is the
412:27 - object right here that we initialized
412:30 - with with our dto and the output was
412:32 - drawn with an uppercase so this is also
412:35 - another or a different assertion level
412:38 - or an assertion test that we make sure
412:41 - that the input should be exactly the
412:43 - same as the expected output all right so
412:46 - now let's go back to our mapper and
412:48 - let's just remove this one and in case
412:50 - for example you have changed the
412:52 - implementation of these two student
412:54 - method you need also to update the test
412:57 - okay so in this case you make sure that
413:00 - everything works fine so let's run the
413:03 - test one more time and make sure that
413:05 - everything works fine so our test is
413:07 - green now we can move on and Implement
413:10 - other tests all right so now since you
413:14 - know and you understood how to implement
413:16 - tests so I want to give you a small
413:18 - exercise I want you to implement the
413:21 - test method for for testing these two
413:24 - Student Response dto and it should take
413:27 - a student object and then return a
413:29 - student response dto so you can also
413:33 - Inspire and follow the same example we
413:35 - did right here I want you to create
413:37 - another method and you call it should
413:39 - map student to Student Response dto so I
413:43 - will let you do it and I will provide
413:46 - you the correction in the next lecture
413:48 - that's good I was sure that you will
413:50 - implement it correctly so let's do it
413:53 - together all right so first of all we
413:55 - need to create a public void method and
413:58 - then let's call it should
414:01 - map a student or student to Student
414:05 - Response dto all right and then
414:07 - parentheses and then the brackets and
414:09 - don't forget the test annotation all
414:12 - right so the first thing as we did
414:14 - before we need to create an object of
414:17 - type student all right so here go
414:20 - student student calls new student and
414:24 - then let's initialize our student object
414:27 - so here let's say Jane as a first name
414:30 - and then Smith as a last name and then
414:33 - let's provide an email so Jan
414:36 - mail.com and then we need an age let's
414:39 - say for example it's 20 and let me
414:42 - inline this all right so now we have our
414:44 - student then all we need to do is to
414:47 - create an object of Student Response dto
414:50 - and let's call it response equals our
414:54 - mapper and then to Student Response T
414:57 - and we need to pass our student all
414:59 - right now comes the assertion part so
415:02 - the first thing we need to do is to
415:05 - assert first name last name and email
415:07 - and make sure that the result is the
415:10 - same since within our Student Response
415:12 - dto we only have three attributes all
415:15 - right so now let's say assert equals and
415:18 - then I want my response. first name to
415:22 - be the same as my student. getet first
415:25 - name the same for last name so here last
415:29 - name and then get last name the same for
415:33 - the age I want the age to be the same as
415:37 - the student. get
415:39 - H uh sorry we don't have an H for the
415:42 - response dto but it's email and here it
415:45 - should be the same as get email all
415:47 - right so now let me add a few comments
415:50 - so here how how we can read the test so
415:54 - here we have given a student object and
415:58 - then when we map the student to a
416:01 - Student Response dto then I want or I
416:05 - expect this result so now let's go ahead
416:08 - and run the test and make sure that
416:10 - everything works fine and we did not
416:12 - forget anything so the test is green
416:15 - Also let's go ahead and run the whole
416:18 - class and here we have all the tests are
416:21 - green and passing okay so that's it
416:24 - let's move on and let me talk to you
416:26 - about something really really important
416:29 - when you implement an application and
416:31 - mainly you can detect that with the
416:33 - tests all right now let me talk to you
416:36 - about something else so here I will just
416:40 - start by creating a new test method and
416:43 - after this method I will just create a
416:45 - method called public void and then this
416:49 - is also a different way of writing the
416:52 - the method name so we can write it in
416:54 - this way should map student dto to
417:00 - student object all right but this new
417:03 - method I want to add if or let's make it
417:08 - when student dto is null so this means I
417:13 - want the mapping to be or to perform
417:16 - correctly or in an expected way even if
417:20 - the student dto that I'm passing right
417:22 - here here is null so what I will be
417:23 - doing I will just copy this part right
417:26 - here and then paste it in this method
417:30 - and instead of passing the dto I will
417:32 - pass a null object so here what I will
417:35 - be doing let's say for example so we
417:37 - will change this later on but let's
417:40 - start expecting this so here let's say
417:44 - an empty string and here empty string
417:48 - all right now if I run this test method
417:51 - let's make it a test and if I run this
417:54 - test method let's see what will
417:57 - happen so here we have a null pointer
418:01 - exception cannot invoke the student dto
418:04 - do first name because dto is
418:07 - null all right and the exception
418:10 - happened inside the mapper itself so if
418:13 - I click here we see that the the problem
418:16 - is exactly in here because we are trying
418:18 - to get the first name from a null object
418:21 - and here we mainly talk about code
418:24 - coverage so we need to cover all the use
418:27 - cases that our method and our service
418:30 - class and our class generally speaking
418:33 - should handle so here you see and you
418:35 - noticed that we did not handle the case
418:38 - when we pass null dto object so in this
418:42 - case what we need to do we need to go
418:43 - back to our student mapper and then we
418:46 - need to add a test or a check or do
418:49 - whatever just to make sure that when we
418:51 - receive null object we want to do
418:54 - something whether raise an exception or
418:57 - just printing a message or even for
418:59 - example initializing an empty student
419:02 - object with for example let's say empty
419:05 - values so the implementation always
419:07 - depends on the requirements of of your
419:09 - story or of the application that you are
419:12 - implementing so now let's go ahead and
419:15 - start doing this so in this case or in
419:18 - this use case we will see many things so
419:21 - the first thing let's go back to to to
419:22 - student and here I want to do if my dto
419:26 - is null for example I want to throw a n
419:30 - pointer exception all right so here we
419:33 - need the new keyword so a new n pointer
419:36 - exception and here the student for
419:39 - example as a message the student dto is
419:43 - null all right so now we add we added a
419:46 - coverage to our method so now let's go
419:50 - back to the test and make sure to to
419:52 - readjust the test right here in order to
419:55 - make sure that this student method
419:58 - should throw a null pointer exception
420:00 - when we get a n dto student so we don't
420:04 - need this one since we don't have any
420:06 - assertions and now let's just rename
420:08 - this method to make it more relevant and
420:11 - here instead of should map so let's say
420:14 - should throw and then a null pointer
420:16 - exception when student dto is null so
420:20 - now we have this mapper do to student
420:23 - and then we are assigning it to a
420:25 - student so we can also remove this
420:27 - assignment since we know that it will
420:29 - throw an exception and it will return
420:31 - nothing so now how can how can I expect
420:34 - or make sure that these two student is
420:37 - going to throw a null pointer exception
420:39 - so in order to do that all I need to do
420:41 - I need to assert that this method is
420:44 - going to throw a null pointer exception
420:46 - so I'm just going to remove it and now
420:48 - I'm going to use assert throws so here
420:52 - this throws method first of all it gets
420:54 - the expected type so in our case it's a
420:57 - null pointer exception. class and then
421:00 - it's a Lambda expression so here when we
421:03 - call the mapper do2 student I'm
421:06 - expecting to have null pointer
421:08 - exception. class thrown so let's run
421:11 - this method and make sure that it passes
421:13 - green right now so now this method is
421:16 - throwing this exception so now what if I
421:20 - want to check the message that the
421:23 - message should be the student dto is
421:26 - null or should not be null so here let's
421:28 - just rename it should not be null and
421:31 - I'm going to copy this message and now I
421:33 - will go back here so in order to do that
421:36 - all I need to do let's create a VAR
421:39 - message equals this so as you can see
421:42 - this a assert throws it will return the
421:45 - exception itself all right so now if I
421:49 - do MSG Dot and here here I have access
421:53 - to the method get message from the NP
421:55 - pointer exception or from the exception
421:58 - generally speaking so now I want to do
422:01 - assert equals I want this error message
422:04 - to be equal to my message or exception.
422:08 - getet message so let's just rename this
422:11 - one to exp to say it's an exception so
422:14 - exp for exception and now if I run again
422:18 - let we need to be sure that the the
422:21 - method through this exactly the correct
422:23 - error message so here for example if I
422:26 - add a DOT and run again the method
422:29 - should
422:30 - fail and as you can see now the method
422:33 - failed and the assertion failure is we
422:36 - are expecting this but we got this one
422:39 - so in this case we gained two things the
422:42 - first one is that we add a coverage to
422:45 - our two student method and then we also
422:49 - covered this with within the test so for
422:51 - example in case I want to change from
422:54 - null pointer exception to a different
422:56 - exception it will be automatically
422:58 - detected by this test method again if I
423:02 - change for example the exception message
423:05 - it will be also automatically detected
423:07 - so now let me run it again and make it
423:09 - green and now we added a new coverage to
423:13 - our method so this is how you can test
423:16 - exceptions and this is how you can catch
423:18 - exceptions and make sure or you can do
423:21 - whatever you want even if you work with
423:23 - custom exceptions that you create your
423:25 - own you can also capture that and do
423:28 - whatever you need to assert everything
423:30 - is as expected all right so now let's
423:34 - move on to the next part all right so we
423:37 - finished the implementation of the
423:39 - student mapper and we saw how we can
423:42 - create a test class how we can create
423:44 - test methods also we saw how we can or
423:47 - how how much we need to cover our code
423:50 - like we need to cover all all the use
423:52 - cases now let's move and start testing
423:56 - or writing tests for our student service
423:59 - so we know that this student service is
424:01 - a spring component and it has a strong
424:05 - dependency with student mapper and the
424:08 - student repository and especially when
424:10 - we talk about student repository we talk
424:13 - about communicating with database so
424:16 - when it comes to testing how can we test
424:20 - and how can we tell spring or this
424:22 - student service that we have a student
424:24 - repository and this one needs to
424:26 - communicate with the database and what
424:28 - happens in case we don't have a real
424:30 - database for testing because testing it
424:34 - does not necessar necessarily need to
424:37 - have a database for testing so that's
424:39 - why we will talk about test isolation so
424:43 - test isolation means that we want to run
424:47 - and to write tests for this student
424:49 - service in isolation of its dependencies
424:52 - in a different way I want to execute and
424:55 - write test for this student service but
424:58 - I don't necessarily need to have the
425:00 - real instance and the real object of my
425:04 - student repository the same for my
425:07 - student mapper so what do I need to do I
425:11 - need to mock these two objects so to do
425:14 - that we have there is a framework called
425:18 - mokito so mokito is a popular Java test
425:21 - in framework that helps you create mock
425:24 - objects and stab behaviors when writing
425:27 - unit tests so it's especially useful
425:30 - when you want to isolate a specific
425:33 - component of your code and test it in
425:36 - isolation from its dependencies so now
425:39 - we know what we need to do we need to
425:41 - isolate and we need to mock so you need
425:43 - to remember this term we need to mock
425:46 - our objects we need to mock the student
425:48 - repository and the student mapper to be
425:51 - a able to run the student service test
425:54 - in an isolated way so let's go ahead and
425:58 - let me show you how we can isolate and
426:00 - how we can marck the objects and the
426:02 - methods for each service that we have
426:05 - right here so now as always the next
426:08 - step is we need to go and create a test
426:11 - class for our student service so all I
426:14 - need to do navigate here and then
426:16 - command shift T and create a new test so
426:20 - here we don't need any of these
426:22 - we just maybe need or use the setup
426:24 - method so I will just check it out and
426:27 - then click on okay so here we have our
426:30 - before each and we have our student
426:33 - service test class so as we did for the
426:36 - student mapper what we need to do here
426:38 - first of all which service that we we
426:42 - want to test so in this case we want to
426:45 - test our student service so I will
426:49 - create an object of student service and
426:51 - I will call it student service and then
426:55 - when it comes to objects that have
426:57 - dependencies let's check in here so we
427:00 - see that our student service has two
427:03 - dependencies that we need to inject all
427:05 - right so our Constructor is a
427:08 - Constructor with parameter and it
427:10 - requires an object of type repository
427:13 - and an object of type student mapper so
427:16 - let's just go ahead and do that I'm just
427:19 - going to copy this one and and in here
427:22 - declare the dependencies all right I'm
427:25 - going to paste this and then I will just
427:27 - fix the code all right so now I have my
427:30 - service and I have the dependencies so
427:34 - what I need to do so we said that in
427:37 - order to run the student service in an
427:40 - isolated way what we need to do we need
427:43 - to marck this student repository and the
427:46 - student mapper so what we need to do
427:49 - there is an annotation called mock
427:52 - so this mock annotation comes from or.
427:55 - mokito it's not the one coming from the
427:58 - or. spring framework we want to use the
428:00 - mock from org. mokito so let's select it
428:04 - one and the same we need to add it to
428:06 - our student mapper so in this in this
428:09 - way we are telling our test class and
428:12 - the mokito framework that we want to
428:15 - create mock for this repository and a
428:17 - mock for this student mapper all right
428:20 - now how can we tell this mocking
428:23 - framework that we want to inject these
428:26 - two properties and these two
428:28 - dependencies into this service right
428:31 - here so the answer is kind of
428:34 - straightforward because I just mentioned
428:36 - injecting so we have an annotation
428:40 - called inject MOX so inject MOX always
428:43 - is coming from the or. moku package and
428:46 - like this our mocking framework will try
428:50 - to find any dependencies annotated with
428:54 - the mock annotation that is compatible
428:57 - with the dependencies that are required
429:00 - from our student service so this means
429:03 - when we try to create an instance or to
429:05 - initialize this student service the
429:08 - mocking framework will look for two
429:11 - object annotated with the mock
429:14 - annotation and that are of type one of
429:16 - them is of type repository and the
429:18 - second one is of type student maper
429:21 - all right so now we prepared everything
429:24 - we still need to do one more step so
429:28 - then what we need to do we need to tell
429:30 - the moito framework that we want to open
429:33 - the mock or like we want to start the
429:36 - mock for this current class so this
429:39 - means that in the before each here what
429:42 - we need to do we need to use the moito
429:45 - annotations class doop Mox and this open
429:50 - MOX takes an object which is the test
429:52 - class as you can see right here so let's
429:55 - give it this because we want to open the
429:57 - mock for the current class all right so
430:00 - may you might see this warning right
430:02 - here this is because the open mock
430:04 - methods return and autoc closable so and
430:08 - this the anj or your IDE will recommend
430:12 - to you that you might need to you might
430:14 - want to use a try with resource but we
430:17 - can ignore that for the moment it's not
430:19 - something really important or really
430:21 - really uh going to break our test all
430:23 - right so now we set up our test class
430:27 - now let's move on and implement the
430:29 - first test method that will allow us to
430:33 - save a student so the first one it will
430:36 - be this save
430:38 - student that's good now let's analyze
430:41 - our save student so we have here first
430:43 - of all we are doing a mapping and then
430:46 - saving the repository and then again we
430:49 - are doing a second mapping P so this is
430:52 - what we need to test in our test method
430:54 - so let's go back to our student service
430:56 - test and here I will create a public
431:00 - void and then should successfully save a
431:03 - student all right so this is our test
431:05 - method let's not forget the test
431:08 - annotation and now here let's remember
431:11 - the given when and then so here given
431:16 - what so here in our save method we have
431:19 - a student D so let's first of all all
431:21 - create a student dto object so let's go
431:24 - back here and here I have first of all
431:26 - my student dto object also this class is
431:31 - going to need an object of type student
431:35 - which is this one so let's also go ahead
431:38 - and prepare our student so it will be
431:40 - almost the same so just copy the
431:43 - signature right here and here I will
431:45 - create an object of type student let's
431:47 - call it student equals and then new
431:51 - student all right here let's remove this
431:54 - one all right here we have also our
431:56 - student object and our student dto so
432:00 - what we want to do or like how this is
432:03 - going to work this means is when we call
432:08 - our student service do saave student we
432:10 - are expecting an object of type Student
432:13 - Response dto all right so here I will
432:17 - create an object of type Student
432:19 - Response dto I will call it response dto
432:22 - equals our student service do save
432:26 - student and then we have a dto so this
432:29 - is the dto that we will pass as a
432:30 - parameter and then what we need to do is
432:33 - to start asserting so let's say assert
432:36 - equals and then we have our dto object.
432:40 - getet first name should be equal our
432:43 - response dto do get first name all right
432:47 - let's do the same also for the last name
432:50 - and also the email so we can stick just
432:53 - to these few fields we don't need to
432:56 - test everything so this is what we want
432:59 - to test so now if I run the test what
433:02 - should happen so let's go ahead and
433:04 - check together so I will run this test
433:07 - method and let's see what will be the
433:09 - output here we see that we have a null
433:12 - pointer exception saying that we cannot
433:14 - invoke Student Response do get first
433:18 - name because the response is null and
433:20 - this this is happening in here so this
433:24 - means what I'm going to just add a break
433:26 - point right here and I will run again
433:29 - this test in debug
433:31 - mode so here let's see our student
433:34 - service so we have an object since it's
433:36 - already mocked the same for our
433:38 - repository so we as you can see we have
433:40 - a moito Interceptor and so and so forth
433:43 - so now if I evaluate this expression and
433:47 - then evaluate expression and then
433:49 - evaluate we see that the result is null
433:52 - okay so let me explain to you why we
433:54 - have this null result so this null
433:57 - result is because the student service is
434:00 - trying to call the student mapper and
434:03 - then we have the student repository is
434:06 - also going to call the save method but
434:10 - remember here we have a mock so we don't
434:12 - have the real instance or the real
434:15 - service running for our test because we
434:18 - decided to run our student service in
434:20 - isolation mode so to do that what we
434:23 - need to do here we need to mock the
434:27 - calls so which calls that we need to
434:29 - mock we need to mock every call that
434:32 - uses another service or another
434:35 - dependency in our student service and in
434:37 - this case we have the student mapper and
434:40 - we have the repository do saave so let
434:43 - me show you now how we can mock these
434:45 - calls so the first thing that we need to
434:47 - mock is the as you can see here the
434:51 - first thing that we that we do is the
434:53 - mapping so let's mock the mapping all
434:55 - right so now in order to mock the calls
434:58 - so the first thing that we need to mock
435:00 - is our two student so student mapper do
435:02 - two student method so this comes from
435:06 - moito we have a static method called
435:09 - when so this means when we call a method
435:13 - so we have as a parameter the method to
435:15 - call so here we have student mapper do
435:19 - to student so when we call these two
435:22 - students with our dto object so make
435:26 - sure that the mock will work only if we
435:29 - pass this object right here so then what
435:32 - we want to do then we have so many
435:35 - options so we can return we can return
435:38 - with a student we can also a student and
435:41 - a list of other students we can return
435:43 - an answer or we can even throw an
435:45 - exception so in our case we want to
435:48 - return an object which is our student
435:51 - right here so let's return the student
435:54 - and now we are done with the first mock
435:57 - of our student mapper do to student
436:00 - method so here when we say when we are
436:03 - mocking a method all right so this when
436:06 - we call the student mapper do2 student
436:09 - dto then we need to return the student
436:12 - object so this means that our student
436:15 - service will run in isolation mode and
436:18 - it does not 100% depend on the real
436:21 - implementation or the uh not the real
436:23 - implementation but the real instance of
436:25 - the student mapper so also let's import
436:28 - this in statically so when student
436:30 - mapper then return all right so let's do
436:33 - the same for our repository so when our
436:37 - repository dot save and then student
436:41 - then return our student itself all right
436:45 - because we know that when we save a
436:48 - student we return another student or if
436:51 - you want to be more consistent or if you
436:53 - want to have like more uh details you
436:56 - can even create another student object
436:59 - you can call it like saved student and
437:01 - set the ID and set everything and also
437:03 - you can return that one so let's just do
437:06 - it it's it's totally fine so I will call
437:09 - it saved student and then I will just do
437:12 - saved student. set ID and let's give it
437:16 - the ID number one and in here I will
437:19 - return our saved student all right so
437:22 - now we have three objects so first we
437:25 - have the dto and then the student that
437:27 - will come from the mapping and now this
437:30 - is the student that should be saved in
437:32 - the database so now again we mocked the
437:35 - second call which is our repository so
437:38 - if we go back in here we still need to
437:41 - return another call so here we need to
437:43 - mock also the student mapper do to
437:46 - Student Response dto so in order to do
437:49 - that just in the same way so here we
437:52 - have when we call our student mapper do
437:57 - to response dto of our student object
438:01 - which one which is the saved student all
438:04 - right so here we have then return let's
438:08 - now just return a new student response
438:11 - dto and all we need to do is to pass the
438:13 - first name last name and email so this
438:16 - is the first name last name and email so
438:20 - let's let's just copy them from here so
438:22 - we have our John do I'm also going to
438:25 - inline this so you can see the full code
438:28 - and the email is just John email.com all
438:32 - right so now we have our test set and
438:36 - ready so let's go ahead and run the test
438:39 - right now and see the output so I'm just
438:42 - going to click and run this one and
438:45 - let's see what will happen so now our
438:48 - test is green so we have all the
438:51 - expectations and everything was running
438:53 - in a successful way because we have here
438:57 - we mocked everything and in case for
438:59 - example I just change anything or you
439:02 - forget to uh to mock a step your test
439:05 - will
439:06 - fail that's good now we created our
439:09 - first test method and we saw how we can
439:12 - mock objects and also do some assertions
439:15 - so this is the classic assertions but
439:18 - now what if we ask the question how can
439:22 - I check that my application is
439:23 - performing well so here for example in
439:27 - this save student I want to make sure
439:30 - that I only save one time the student
439:33 - into the database this means for example
439:36 - I don't want to have some error or like
439:39 - someone typing two or three times this
439:43 - repository. saave because this will save
439:46 - the student many times and in case for
439:49 - example you have a un constraint it
439:51 - might throw an exception and this will
439:53 - break the application so let me show you
439:56 - how we can prevent this from happening
439:59 - so if I go back to my student service
440:03 - right here we can do this in the same
440:05 - place since we have our code already set
440:08 - up all right so here we are
440:11 - mocking and now what I want to do I want
440:14 - to make sure that this student mapper2
440:18 - student was called only one time same
440:20 - for the repository and the same for this
440:23 - one all right so to do that mokito also
440:28 - provides us with a method called verify
440:30 - as you can see here so we want to verify
440:33 - and then we need to to type the mock
440:37 - object so our mock object is the class
440:39 - or the instance itself and then we can
440:42 - pass a parameter so it's a verification
440:45 - mode so here we have okito do times also
440:49 - we have out we have so many other
440:52 - options I can for example check that a
440:55 - method call should take only just just
440:58 - as an example should take only 2 seconds
441:00 - maximum to be executed if it goes beyond
441:04 - 2 seconds the test will fail and like
441:06 - that I can also make sure that I have
441:09 - performance issues with my application
441:12 - all right so now let's continue with
441:14 - this times so I want to be sure that
441:17 - this student mapper dot to
441:20 - student and then the object student dto
441:24 - or the dto object that we created it has
441:27 - been called only one time all right so
441:31 - let's do the same for
441:33 - repository and then times one and then
441:38 - the save method when we pass the student
441:41 - object again I will do I will duplicate
441:45 - this one and here student mapper and
441:47 - then to response dto or to Student
441:51 - Response dto and here just to make sure
441:55 - that we passed the saved student as an
441:58 - object all right so here we need to say
442:00 - saved student all right I'm just going
442:03 - to align these methods right here just
442:07 - so you can see everything so here verify
442:10 - that this method or these three methods
442:13 - of the different Services were called
442:16 - only one time so let's go ahead and run
442:18 - the method again so run this and then
442:23 - the test passed so now let's suppose for
442:27 - example that one of the developers or me
442:30 - for example as also as a developer of
442:32 - this application I accidentally forgot
442:36 - to remove this extra line all right so
442:39 - now if I rerun the test again let's see
442:42 - what will happen so the test will fail
442:44 - and we will see here that wanted one
442:47 - time so this means that we wanted to
442:50 - have our call only one time but it was
442:53 - called two times and here so as you can
442:58 - see here you have student service. save
443:00 - student that was called two times all
443:03 - right and it was pointing to here and
443:06 - then to here so here we see that even
443:08 - the test will point us directly where
443:12 - the issue has happened all right so
443:14 - that's good now let's move on and let me
443:17 - give you a small exercise and I'm pretty
443:19 - sure sure that you will be implementing
443:22 - it really easy without any issues now
443:26 - let me give you an exercise I want you
443:28 - to implement the test for these find all
443:31 - students so it needs to cover and to
443:34 - make sure that when you make a call to
443:38 - this repository. find all it should
443:41 - return the exact same list that you
443:43 - already expect and in the next lecture I
443:47 - will show you how to fix this one all
443:49 - right that's good I'm sure that you
443:51 - correctly implemented the test for this
443:53 - find all students but also let's go
443:56 - ahead and do it together so I will
443:59 - create as usual a public void and then I
444:03 - will call it
444:04 - should return all students and then we
444:09 - have the given so for the given the
444:12 - first thing that we need to do is to
444:14 - create a list so let's create a list of
444:17 - students so this is the object that will
444:19 - be be returned so let's call it students
444:23 - equals new array list and then let's add
444:27 - one student so student. add and we can
444:30 - even copy the student from the previous
444:33 - method right here so I'm just going to
444:36 - copy this one and I will insert this
444:39 - student
444:41 - here all right so now we have one
444:43 - element
444:45 - in in our student
444:47 - list and then we need need to mock the
444:52 - calls so the first call that we need to
444:54 - marck is when we call our student
444:58 - repository or the repository object do
445:02 - findind
445:03 - all then I need to return the students
445:07 - list that we created all right and then
445:11 - what we need to do we need to marck the
445:14 - call for the mapping all right so here
445:16 - we have when mapper or student student
445:20 - mapper dot to Student Response dto and
445:25 - here since we might add or pass any
445:28 - student so we can use the power of moku
445:31 - and here we have argument matchers do
445:34 - any and here when we say any we can also
445:38 - specify the class so when we receive any
445:41 - class of type student do class then I
445:44 - want to return for example a new like a
445:48 - new object of type response Student
445:50 - Response dto something like that so I'm
445:53 - just going to inline this so when we
445:56 - call the student mapper to Student
445:59 - Response passing any object of type
446:02 - student we want to return this object we
446:05 - can also make it more Dynamic but for
446:08 - the sake of a simple um test case it's
446:12 - also easy and it's also okay to make it
446:14 - like this and here we just forgot the
446:17 - test annotation so we need to add it and
446:20 - now all we need to do is to have a list
446:24 - of type Student Response dto and then
446:27 - let's call it response dto equals our
446:31 - student
446:32 - service do find all all right and here
446:36 - so this is given and now it's when when
446:40 - we call this one so then so here for
446:44 - here we do assert equals that our
446:47 - students list do size to be equal to our
446:51 - students dto do size or response dto do
446:55 - size all right so this is the
446:57 - implementation let's go ahead and run
446:59 - this method and make sure that
447:01 - everything is fine all right also should
447:04 - return all students is green we can also
447:06 - add an extra test and make sure that for
447:09 - example this repository. find all was
447:12 - called only once so let's go ahead and
447:15 - test it just to make sure always that we
447:18 - have our application performing really
447:21 - well so here we have our repository and
447:24 - then times one and then dot find all to
447:28 - be called only one time let's rerun
447:31 - again all right so the the test is still
447:34 - green so now let's move on and let me
447:37 - tell you what we will be doing next all
447:40 - right now I want to give you another
447:42 - exercise and I want you to implement the
447:45 - test for this fine student by ID I'm
447:48 - pretty sure you're going to do it in a
447:49 - correct way and I will see you in the
447:52 - correction all right so as usual let's
447:55 - go back to our student service test.
447:57 - Java class and the first thing that we
447:59 - need to do is adding this test
448:01 - annotation and then creating a public
448:04 - void and let's call the method should
448:07 - find student by ID or should return
448:10 - student by ID all right so here always
448:13 - the given and here we have an INT
448:16 - student
448:18 - ID or an integer let's make it an
448:22 - integer student ID equals 1 and then
448:25 - let's create a student object we can
448:28 - also take it from here so let's call it
448:32 - student so here we have student student
448:35 - equals new students and then we have
448:40 - when so here we need to mock so here we
448:44 - have when we call our repository. find
448:48 - by ID
448:50 - and then we pass our student ID and then
448:54 - I want to return an optional do off my
448:59 - student all right and you might ask the
449:02 - question why I used optional because
449:04 - this finded by ID is going to return an
449:07 - optional the second mock that we need to
449:10 - do we need to marck the two Student
449:13 - Response D from this from the student
449:15 - mapper class and to return that one so
449:18 - from that we can can just copy this one
449:22 - and then let's paste it in here so here
449:25 - we have when we make a call to our
449:26 - student mapper we are going to map this
449:29 - one and again we can just go up and copy
449:35 - this assertions so here I will create an
449:40 - object of type Student Response
449:43 - dto I will call it dto equals my student
449:48 - service Dot find by ID and then I will
449:52 - pass the student ID that I
449:54 - created and now we have the then so here
449:58 - we start the assertions so here we have
450:01 - our the dto do first name should be
450:04 - exactly the same one as the student.
450:07 - getet first name so here I will just
450:10 - copy the student from here and I will
450:13 - just replace it in here so now we can
450:16 - select all and here we have get and then
450:20 - let's make this one uppercase and now
450:23 - that's it also we can add another check
450:27 - we want to verify that our repository
450:29 - has been called one time for the method
450:33 - find by ID so passing also the student
450:37 - ID as an object as a uh as a parameter
450:40 - and now let's go ahead and run this new
450:43 - test
450:45 - Method All right so we might miss
450:47 - something okay so here expected John
450:51 - example.com but the actual was john.
450:55 - mail.com so maybe let's fix it so here
450:58 - we have mail let's change this one also
451:01 - to mail and let's rerun again and the
451:05 - test is green and fine all right so that
451:09 - was it for this method let's move on and
451:11 - implement the next one that's good you
451:15 - really made a really good progress and
451:17 - I'm really proud of you so the next
451:20 - method that we need to implement the
451:22 - test for is find student by name and
451:26 - just I want to give you a quick hint you
451:28 - can Inspire from the previously
451:31 - implemented methods in order to
451:33 - implement it in a correct way so take
451:36 - your time and I will see you in the next
451:38 - lecture to provide you the solution for
451:41 - this exercise all right you did a good
451:45 - job now let's correct this exercise
451:47 - together and you might learn learn
451:49 - something new so as always we need to
451:52 - add the test annotation and then we have
451:54 - a public void and let's call the method
451:58 - should find student by name all right so
452:04 - then what we need to do the first thing
452:07 - we can also copy things from what we
452:09 - have before so I'm going to explain it
452:12 - one by one so we can copy this part
452:16 - right here we can also copy this one
452:19 - right here so here we copi it so also
452:22 - let's copy it with a given so here the
452:25 - initialization of the students list and
452:28 - then we have the mock for the find all
452:30 - this one we will change later on and
452:33 - also we need to copy the mapping so
452:36 - let's go back here and now so when we
452:41 - call the find student by first name
452:45 - containing and here I just need also to
452:48 - declare
452:49 - a string student name let's call it John
452:54 - all right so here containing student
452:57 - name then return the students list and
453:01 - then when we call the student mapper do
453:03 - to Student Response dto of any student
453:07 - object I want also to return this mapped
453:11 - object or the Student Response dto now
453:14 - when I call so here let's use VAR just
453:17 - to make it shorter I I will call it
453:19 - response dto equals our service do find
453:25 - all by name and here I need to pass the
453:29 - student name so then I need to do some
453:32 - assertions so I want to do assert equals
453:36 - that the
453:37 - students do size is equals to our
453:41 - response dto do size so this is what we
453:45 - need to do or what we need to check also
453:48 - we can add a verify that our repository
453:52 - has been called one time for the method
453:56 - find all by first name containing our
454:00 - student name so I'm going to break the
454:03 - line for this one and now let's run the
454:08 - test and check the
454:11 - result all right so the test is green
454:14 - and our method is correctly implemented
454:18 - all right that's good so now we still
454:20 - have only one method in our student
454:24 - service so let's go ahead and create an
454:27 - exercise for that and also we will see
454:30 - the solution together congratulations on
454:32 - mastering the intricate Dance of the
454:35 - spring framework you've built a solid
454:38 - foundation but guess what there's a
454:41 - whole universe waiting to be explored
454:44 - the enigmatic realm of spring data jpa
454:47 - ever wondered how the Pros handle data
454:51 - persistence in style we're about to
454:54 - reveal the secrets that will transform
454:56 - you from a spring Enthusiast to a data
455:00 - wizard back up for a thrilling right
455:04 - through repositories relationships and
455:06 - the Art of querying with finest you've
455:09 - tasted the sweetness of spring boot
455:11 - access now let's add the spice of spring
455:15 - data jpa to your coding Journey get
455:18 - ready to play play with embedded
455:19 - entities Master the Nuance of ID
455:22 - generation and harness the power of
455:25 - named queries and specifications before
455:27 - we dive into the nitt gritty don't
455:29 - forget to subscribe to my YouTube
455:31 - channel and join our Vibrant Community
455:35 - elevate your coding skills with Fresh
455:37 - weekly content delivered straight to
455:40 - your virtual doorstep all the links are
455:43 - conveniently waiting for you in the
455:45 - video description don't miss out the
455:47 - coding Adventure your seat is already
455:50 - reserved now that you're locked loaded
455:53 - and subscribed let's get back to
455:55 - business spring boot was just the
455:57 - beginning spring data jpa is the next
456:01 - Frontier ready to unravel the Mysteries
456:04 - grab your coding gear hit play and let's
456:06 - embark on the Epic coding journey
456:09 - together let's get
456:12 - started first of all we will start by
456:14 - setting up our database management
456:17 - system and and for the purpose of this
456:20 - uh course I will be using Docker and I
456:23 - will show you how you can install post
456:26 - degree SQL or my SQL uh database so you
456:30 - have multiple choice also if you have
456:33 - them already installed on your machine
456:36 - you can skip this part so this part is
456:38 - only about installing and setting up the
456:41 - database management system on your
456:44 - machine so uh first of all make sure
456:47 - that you have Docker desktop running uh
456:50 - installed and running and here like when
456:52 - you open the docker uh dashboard you
456:56 - will see this green uh part like here or
456:59 - this green icon so this means that the
457:02 - engine is running so if it's an orange
457:05 - uh color means that the engine is
457:07 - whether is starting or it's not started
457:09 - so you need to make sure that this is
457:12 - green and this is all you need to do
457:15 - okay now let's let's move and uh and St
457:19 - the docker image for post degree
457:23 - SQL the command that we need to run is
457:26 - the following so here we need to use the
457:29 - command Docker run and then Min D to be
457:33 - to say we want it to be running uh in
457:35 - detached mode so we don't want to wait
457:38 - for it and now we want uh our Docker
457:42 - image to be persistent or to have a
457:45 - persistent volume within our system
457:48 - because as you know every time you start
457:50 - a Docker image it will it will start
457:52 - like uh from scratch and it will
457:54 - consider that nothing uh is persistent
457:57 - so if you want to have a persistent
458:00 - Docker volume you need to add this
458:02 - option minus V it's for volume and now
458:06 - for the volume first of all you need to
458:08 - specify the path where you want to store
458:12 - the the data of uh post-degree SQL and
458:16 - for example in my case so it will be in
458:19 - here so I just called it this way it's
458:22 - my personal project data
458:24 - slpg uh for post degree and data for
458:27 - data and then just column here and slash
458:33 - VAR so here we are trying to map the
458:35 - volume from our local machine to the
458:38 - volume that postre SQL will be using
458:41 - okay so uh it will be /var slash lib
458:47 - slash postre
458:51 - SQL SL data so this is the path that
458:55 - postgre SQL uses to store the data okay
458:59 - so now we mapped already the the volume
459:02 - now we can also pass some environment
459:04 - variable uh and these environment
459:07 - variables we need them for uh the
459:09 - username and the password okay so to
459:12 - pass an environment variable it's like
459:14 - following it's minus
459:16 - E and then we have post post
459:19 - agree underscore username this are
459:23 - predefined uh environment variable that
459:25 - postgre SQL will look for and here I
459:27 - will call it just post agress or post
459:30 - degree and then Min E I want to pass a
459:34 - second uh environment variable and this
459:37 - one it will be a postre
459:40 - password okay it's a post degree _
459:43 - password and here I will call it alibu
459:47 - coding the for the password okay and now
459:50 - we need to map the port so this means on
459:54 - which Port we want to run our
459:56 - application so let's keep it the default
459:58 - one which is 4
460:01 - 5432 colum
460:03 - 5432 okay so we will be using or we will
460:07 - be connecting to uh our post degree SQL
460:10 - on the port
460:12 - 5432 okay so now all all we need to do
460:17 - now is to precise or to specify the
460:19 - image name which is in our case like we
460:22 - said we want to use post agress so it's
460:24 - going to be
460:26 - postgress now let's hit the enter button
460:29 - and see how it will it will
460:31 - do so here it says that uh unable to
460:35 - find the image post postig latest
460:38 - locally so it will be pulling it from uh
460:41 - Library SLP scale so means it will
460:44 - download the the image and now we see
460:48 - that we have the status downloaded image
460:51 - or new image from post degree uh latest
460:54 - and here we have the hash of the image
460:57 - also you can you can go to Docker
460:59 - dashboard and you will see here that we
461:02 - have this image and if you go to
461:05 - Containers you will see the container
461:08 - which is running okay
461:10 - so and here you can see that we have
461:13 - this container which is up and and
461:16 - running
461:17 - okay so to install my SQL uh using
461:22 - Docker we will follow the same steps so
461:25 - it will be Docker run Min d as uh D for
461:30 - detached and now we want our database or
461:33 - we want our image to be persistent or to
461:35 - have a persistent volume so we can also
461:38 - precise the Min V which stands for
461:41 - volume and I want my volume or my
461:45 - persistent volume to be in this uh in
461:48 - this path so it's up to you to choose
461:50 - where you want to have your persistent
461:52 - volumes and then colum slash VAR SL uh
461:59 - lib SL MySQL SL dat so this is what my
462:06 - SQL uses uh for for data and now we need
462:10 - also to precise some environment
462:13 - variables uh and in this case or for my
462:16 - SQL if we do not precise uh for example
462:20 - the username it will take the root uh as
462:23 - default username so I will I will keep
462:26 - it just uh just root so I will only
462:29 - precise my SQL or
462:32 - this or this environment variable which
462:35 - is the root
462:37 - password
462:39 - okay so it's my SQL andore uh rotor
462:44 - password uh equals and I will keep it
462:47 - empty or you can leave it empty so I
462:49 - want to have an empty password for my
462:51 - SQL uh next we need to we need to
462:54 - precise the port so it will be 3306
462:57 - mapped also to
463:00 - 3306 okay and then of course the image
463:03 - it's my SQL or my SQL okay now let's hit
463:08 - enter button and it will download or
463:11 - pull the image so now it's it's
463:15 - extracting and in just few seconds it
463:17 - will be done and we will be able to see
463:20 - the hash so this is this is the digest
463:22 - or the Sha of um of the pulled image and
463:26 - this is the ID of the image and also to
463:28 - make sure that everything was fine and
463:32 - okay you can go to image refresh in here
463:35 - and you can see we have the MySQL
463:38 - running and it's already in new so if
463:40 - you click on this one you will see it
463:43 - here that it's up and running
463:46 - okay to create new spring boot project
463:49 - the the recommended way and also the way
463:52 - that I really recommend is to go to the
463:55 - spring initializer website which is at
463:58 - this address start.
464:01 - spring.io and here you have uh a graphic
464:04 - user interface or website where that you
464:06 - can use to create a spring boot project
464:09 - okay so let's go ahead step by step and
464:12 - create our spring boot project so first
464:15 - of all you can choose
464:19 - which um which project
464:22 - um first of all you can use which
464:25 - dependency manager want to use so if you
464:27 - want a maven or Gradle project or here
464:30 - you have also the option for gradel
464:32 - cotlin for people that wants to use
464:35 - cotlin instead of java and here you can
464:37 - also uh specify the language Java cotlin
464:40 - or groovy so for us we will go for the
464:43 - standards which is Maven and
464:46 - Java uh for the this tutorial or for
464:49 - this course because spring 3 is already
464:51 - out so we will be from now on we will be
464:53 - using the spring 3 version okay now
464:57 - let's specify or precise the project
465:00 - metadata so here the group ID it will be
465:04 - um let's call it com. alibu
465:09 - coding and the artifact let's call it
465:13 - because this is a spring data jpa course
465:15 - I will call it just jpa
465:19 - so this is spring uh and the description
465:22 - you can leave it or you can put whatever
465:23 - you want so let's just leave it and this
465:26 - will be our base package or the package
465:29 - name so we want a jar packaging and of
465:32 - course we will use the Java 17 for our
465:36 - project
465:37 - okay now let's add uh some dependencies
465:41 - that we will need within our project so
465:44 - first of all we need spring data
465:47 - jpa and for the people that would be
465:50 - using post degree SQL just choose post
465:53 - degree SQL driver for the people that
465:56 - they want to use the MySQL just go ahead
465:59 - with the MySQL driver
466:01 - okay uh next we need lombok so lombok
466:07 - it's as you know it's an annotation
466:09 - which helps us to reduce the boilerplate
466:12 - code and I will be explaining uh all the
466:15 - annotations that we will use within our
466:18 - project and also I will add uh spring
466:22 - web just in case um we need for example
466:25 - to if you want to need to expose some uh
466:28 - controllers or something like that you
466:31 - can you can use the spring web okay so
466:34 - now once everything is set up you have
466:37 - all the dependencies you have uh all the
466:40 - metadata and you configured everything
466:43 - so we can first go and explore the
466:46 - project before downloading it it and as
466:49 - you can see here we have all the
466:51 - information so is the parent is a spring
466:53 - boot start parent with the version three
466:56 - and here we have the group ID and the
466:58 - artifact that we precised by default the
467:00 - version is 001 snapshot and the name is
467:04 - jpa
467:06 - okay also we have the properties Java 17
467:09 - and so on so forth and here we have all
467:11 - the dependencies that we want to use and
467:15 - in the end we have this build plugin
467:18 - which is the default one from the spring
467:20 - boot
467:21 - framework and yeah okay so now let's
467:25 - just go ahead and click on download and
467:28 - open our project using inj or your
467:32 - preferred
467:33 - IDE to connect to our database there are
467:36 - so many ways to do it my perfect way I
467:39 - want to have everything in one place so
467:42 - I always go with a database option
467:45 - within anj so by the way this is the new
467:47 - interface so you can download the latest
467:51 - version and enable the beta UI and you
467:54 - will you will have the same uh the same
467:56 - view as me uh okay so let's go back to
467:59 - our
468:00 - database so in order to connect uh you
468:03 - have this um menu right here which
468:06 - called database but if you don't see it
468:09 - um you can go to view and then you have
468:13 - tool
468:14 - window and then you can see here
468:18 - database so if you click on database it
468:20 - will it will open up this this window
468:23 - right here all right so now let's create
468:26 - or connect to our data source let's
468:28 - start with uh post degree SQL so just
468:30 - click on this plus
468:33 - icon let me make it a bit bigger like
468:36 - that so uh when you click on data source
468:39 - you have here a list of um of databases
468:43 - or uh databases um management system so
468:47 - here for example you can also filter
468:50 - type post agree uh to filter for post
468:53 - agree SQL and then click on it okay so
468:56 - this window will show and here we will
469:00 - have a default name which is uh post
469:02 - address Local Host and here you can you
469:05 - can add some
469:06 - comments uh you can also see the
469:09 - connection type which is default and the
469:11 - driver which is post degree SQL driver
469:14 - so this is not the driver that we
469:17 - included to our pom.xml but it's the
469:19 - driver needed by anj or the the database
469:24 - view system that you want to use uh to
469:28 - to be able to connect to the database so
469:31 - um here uh you have postre SQL but for
469:34 - the first time it will it might require
469:37 - you to download the driver so just go
469:39 - ahead and click on download the driver
469:42 - it will be in the bottom here next to
469:44 - test connection and now let's go and
469:47 - configure our database so as you
469:49 - remember from the previous um part we
469:52 - when we set up our postgre SQL we chose
469:56 - the default Port which is
469:58 - 5432 and then we chose uh username and
470:01 - password so for the username we said
470:03 - it's suppos to Gray and for
470:06 - the for the password we chose alibu
470:09 - coding as a password okay now just go
470:13 - and click on test connection once you
470:15 - provide all the correct information so
470:17 - so if you used a different port in here
470:20 - just precise it same for the local host
470:22 - and so on so
470:26 - forth so when you click on test
470:29 - connection so you need to expect this
470:32 - succeeded otherwise you have something
470:34 - wrong whether the password or something
470:36 - like that so let's do apply okay and
470:40 - let's check what we have in
470:42 - here so here we see that we have our
470:46 - post degree SQL and here you have uh one
470:49 - of three schemas or one of three
470:51 - databases so these also are my old
470:53 - databases or the one that I'm using for
470:56 - uh other projects so now the first thing
470:59 - let's go ahead and create our database
471:02 - okay so right click and then new and
471:06 - then you choose database to create the
471:08 - new schema uh let's call it
471:14 - um let's call it data jpa okay okay
471:18 - dataor jpa because this is the purpose
471:21 - of uh of this course now just click okay
471:25 - it's updating or creating the database
471:28 - and then all you need to do click on
471:31 - this uh zero of three icon and then just
471:35 - select the public so you have you will
471:37 - have the public schema by default okay
471:40 - and then every u in the in the future or
471:43 - when we create a new table it will
471:45 - appear under this public right here okay
471:49 - so now we have our post degree SQL set
471:51 - up and running within our application so
471:54 - let's move to the next for the students
471:57 - or for the users that prefer using MySQL
472:00 - instead of post degree SQL so in the
472:03 - same way you have this icon right here
472:06 - that represents the database when you
472:08 - click on it it will open a window like
472:11 - that but if you can see it just go to
472:14 - view menu and then tool windows and then
472:17 - you will see database just click on it
472:20 - and you will have this view available
472:22 - for you all right now let's click on
472:25 - this plus icon to add a new data source
472:28 - and here like I have it uh already in
472:30 - the recent used but also you can filter
472:34 - by typing MySQL and it will pop up okay
472:39 - so uh then you need to preise the same
472:42 - information that you gave when when
472:45 - creating the docker image
472:48 - so the local host or the host it's
472:49 - always Local Host and the port if you
472:52 - follow my exact uh same configuration it
472:55 - should be also
472:57 - 3306 and for the user it's root and the
473:02 - password will precise so just go ahead
473:05 - and click on test
473:12 - connection okay so when you just provide
473:15 - the username and password if you have
473:18 - username and password but if you didn't
473:20 - uh provide a password so just leave it
473:23 - empty and when you click you will see
473:25 - this succeeded means that you are able
473:28 - to connect to your database also one
473:31 - hint be careful and make sure that you
473:33 - have your container running so otherwise
473:37 - you will not be able to connect to the
473:39 - database okay so I will click on okay
473:42 - and now we see that we have our Local
473:46 - Host for my
473:49 - SQL let's configure our project to be
473:53 - able to connect to our database and we
473:56 - will start with uh connecting to post
473:59 - degree SQL but this is important because
474:02 - it's the same configuration and only few
474:05 - changes would be um would be different
474:09 - from MySQL or uh postre SQL so the first
474:13 - thing just go to resources in here and
474:17 - and here we have our application
474:19 - properties files so I like or I prefer
474:22 - using yaml representation so it's the
474:25 - same thing the the only or the main
474:28 - difference is just the way we write the
474:31 - properties so I will use uh yamama
474:35 - representation if you want to use
474:37 - properties it's also okay so just go
474:40 - ahead first of all rename the
474:41 - application properties to application.
474:44 - yaml okay next now we will start
474:48 - providing information or providing
474:51 - properties to our application or to
474:53 - Spring container to be able to connect
474:56 - to the database so first of all our the
474:59 - first property would be
475:03 - spring dot data
475:07 - source and then we need to provide the
475:11 - URL okay
475:13 - so uh to be able to connect to a
475:16 - database we need to provide few
475:18 - information because we have the spring
475:20 - data jpa starter within our uh
475:23 - dependencies so uh we need to provide
475:26 - the minimum required of information okay
475:29 - so for that case we need the URL I will
475:32 - just come back to it uh later we
475:35 - need username so in our uh no not Hikari
475:41 - just just username so for our case for
475:44 - postre scl we say we said that it's post
475:47 - gr and for the password we why this car
475:53 - and for the password we said we want to
475:55 - use alibu
475:57 - coding as
475:59 - password uh and then we need to provide
476:02 - also the driver class name and the
476:04 - driver class name you see here that we
476:06 - have already two or three suggest we
476:09 - have three suggestions so the so the
476:11 - first one or the the first one is for my
476:13 - SQL or my SQL the second one is for post
476:16 - degree s because anj is smart enough to
476:19 - detect that we have these
476:21 - dependencies in our pom.xml so it will
476:25 - suggested okay so now what we need to
476:29 - what we need to do the first one we want
476:31 - to configurate for post degree SQL so
476:34 - just choose the second option or the or
476:36 - the first I don't know the order that it
476:39 - will uh pop up for you and yeah that's
476:42 - it now let's add some other
476:44 - configuration okay here I will add jpa
476:48 - and here I want to tell or to give some
476:51 - extra properties to Spring configuration
476:54 - or to the spring data
476:55 - jpa on how to connect or how to manage
477:00 - or how or how to uh work with my
477:03 - database okay and the first property is
477:07 - part of hibernate and it's called ddl
477:10 - Auto this means what do we want to do
477:13 - when the application starts Okay so we
477:17 - have many options the first one is
477:20 - create drop this means that we'll create
477:23 - and destroy the schema at the end of the
477:25 - execution or the life cycle of our
477:27 - application so when the application
477:29 - starts we will create the the schema and
477:32 - the tables and when we stop the
477:34 - application we will uh we will drop or
477:38 - we will remove everything so be careful
477:40 - when choosing this one the second option
477:43 - is create so when when the application
477:46 - starts it will destroy all the previous
477:49 - data and recreate the schema from
477:51 - scratch so this is also you need to be
477:53 - careful about it we have also the non
477:56 - options mean that we want to disable the
478:00 - ddl handling that that this means that
478:02 - we don't want to do anything when the
478:04 - application
478:06 - starts uh last but not least the update
478:10 - option means that we want to update the
478:12 - schema if necessary so this means what
478:16 - this means that hibernate will compare
478:19 - the the Java representation or the
478:22 - entities it will compare them to the
478:25 - table or the database schema that we
478:27 - have and it will try to to make it uh
478:31 - even but here you need to put in mind
478:34 - something which is really important the
478:36 - update option it will not remove
478:39 - attributes so for example if you have an
478:42 - entity and you create uh and you want to
478:45 - to remove um an attribute and replace it
478:49 - or like create other ones it will create
478:51 - the new attributes but it will not
478:53 - remove the existing ones okay so also
478:56 - you need to know that and you need to be
478:58 - careful about
478:59 - this the last option is validate this
479:04 - means what means validate this it will
479:07 - do it will not do any changes but it
479:11 - will just validate the schema comparing
479:13 - to the Java representation or the entity
479:15 - representation so we have for
479:18 - example um user entity and we have a
479:22 - user table so the validate will check if
479:25 - we have the same table same table name
479:28 - same attributes same attribute names
479:31 - same types and so on so forth so it will
479:33 - just validate that what we have as code
479:36 - is the same as what we have within our
479:40 - database so for our configuration let's
479:43 - say create drop because this is um
479:47 - learning uh course so we don't need to
479:49 - purchase data forever so create drop
479:52 - should be fine for us so let's go with
479:55 - create drop and now we can also precise
480:00 - the database this like will help uh
480:04 - spring or will help also hibernate to
480:06 - know which database we are dealing with
480:09 - so it will just enforce the way that we
480:12 - will uh the way that we will uh update
480:16 - and manage our database okay so here we
480:19 - have also the option uh show SQL let's
480:22 - set it to true because we want to see um
480:26 - we want to see SQL queries okay so now
480:31 - this is the main configuration or this
480:33 - is the configuration that we need to do
480:35 - now uh we will need to go back to this
480:38 - URL and the difference between for
480:40 - example configuring my SQL and
480:43 - configuring post-degree SQL is just
480:45 - providing the URL the correct driver
480:48 - class name and here this option right
480:50 - here you can also change it to say it's
480:53 - my SQL okay so now going back to this
480:58 - URL so it's
481:00 - jdbc it's always like that jdbc do
481:04 - postre
481:07 - SQL colum SL slash and then you need to
481:11 - provide the local host or like um well
481:15 - whether it can be Local Host it's if
481:17 - it's locally or it can be an IP address
481:20 - or it can be a URL and so on so forth so
481:23 - now we need to provide the port which is
481:26 - 5432 and then the database name as a
481:30 - reminder the database name we created
481:33 - here we called it dataor jpa so here
481:38 - let's
481:39 - just provide it so now our application
481:43 - will be able to connect to this one so
481:47 - how to test it what we can do we can
481:49 - just go ahead and start the application
481:52 - and see if we are able to connect to the
481:55 - database now I will enable annotation
481:58 - processing because we have lbook within
482:01 - our application and as you can see here
482:04 - so the application already started in
482:07 - 2.9 seconds and without any issues so
482:12 - everything is up and because we don't
482:14 - have any tables so we don't have any any
482:16 - further uh information but if something
482:20 - is wrong we would see that we have
482:23 - exceptions in here and I will just show
482:25 - it to you so for example if I provide
482:29 - the wrong Port name uh number sorry not
482:33 - name so if we provide the wrong port
482:37 - number uh and we try to connect to the
482:39 - database we will see that we have a
482:42 - connection issue and it will say that
482:45 - enable to connect to this Local Host uh
482:48 - 5431 so connection refused and so on so
482:51 - forth so this just to ensure you that
482:54 - when you have the correct configuration
482:56 - you will have no issues when connecting
483:00 - or when starting the application okay so
483:04 - now our application is ready to use
483:07 - let's move
483:10 - on we will add now the properties to
483:13 - connect to my SQL database and to do
483:17 - that I highly recommmend that if you
483:19 - skipped the the first part to connect or
483:22 - to configure uh post degree SQL I would
483:25 - really recommend that you go back
483:26 - because we explained all these parts so
483:30 - it's really really important that you
483:32 - that you go back and check that uh now I
483:35 - would show you how to configure or how
483:38 - to connect to my SQL the first thing
483:42 - let's go ahead and duplicate this
483:45 - application. yam just copy and paste
483:48 - just command C command V also just as a
483:51 - reminder you every time I use a shortcut
483:53 - you can see the green uh popup uh down
483:57 - here so yeah you can always follow what
484:00 - I'm doing so now I will just say my SQL
484:05 - or just uh the new file I will call it
484:08 - application- MySQL so this we can use it
484:12 - as a profile as a spring profile and I
484:15 - will show you how you can run the
484:17 - application whether for my SQL or my SQL
484:21 - or post degree SQL so uh how you can
484:24 - configure until J to run with a specific
484:26 - profile we will see it just in the end
484:28 - of this video okay just go ahead and
484:31 - click okay and let's start do the
484:34 - changes that we need okay let's put this
484:37 - in full screen or even I guess it's also
484:40 - like that is readable
484:43 - so uh the first thing we need to of
484:45 - course change change the username and
484:47 - password so for my SQL it's root root
484:51 - and we will see if it works or not let's
484:54 - go ahead and change the driver and now
484:57 - we want to use the my SQL driver okay
485:02 - and for the database we want also to use
485:05 - my my SQL or my SQL now we need to
485:09 - change or we need to update this URL and
485:13 - connect to the database so uh the good
485:16 - good thing is within my SQL you can ask
485:19 - him to create the database automatically
485:22 - if it doesn't exist or if the database
485:24 - does not exist so my SQL will create it
485:28 - sorry yeah so my SQL will create it
485:30 - automatically for you the URL is here
485:35 - instead of uh let's remove it let's
485:37 - write it from scratch so it's jdbc and
485:40 - here my SQL and then column SL slash now
485:45 - we need to provide uh the URL of the
485:48 - database so it's Local Host uh column
485:53 - 3306 this is the port that we want to
485:56 - use and then we want to use also the
485:59 - same database or the same database name
486:01 - here so just we just for to be uh
486:05 - convenient so I will call it also data
486:07 - jpa okay and also you remember that that
486:12 - we did not create manually the database
486:15 - because as I I mentioned uh my SQL has
486:20 - the the option or has the capability to
486:23 - automatically create a database if not
486:26 - exists so to do so just add
486:28 - interrogation Mark and add this uh
486:32 - parameter which called
486:34 - create
486:35 - database if not
486:40 - exists equals true and that's it so like
486:44 - that it automatically um my SQL will try
486:47 - to create or will create a database
486:50 - called Data jpa if not exists okay now
486:54 - to run the application using this
486:58 - configuration first before clicking on
487:00 - this play button right here to the to
487:03 - run the application just click on jpa
487:06 - application and you will see edit
487:09 - configurations here and here you see
487:13 - that we have active profiles so spring
487:16 - now if I precise it as my SQL spring
487:20 - what will do when starting the
487:22 - application he will try to find an
487:24 - application properties file or
487:27 - properties uh file have uh having the
487:31 - suffix my SQL as precised in the
487:35 - configuration in here okay so here we
487:38 - said that the active profile we want it
487:41 - to be my esql we can we by the way we
487:43 - can provide many active profiles uh uh
487:46 - as you can see here it's profiles not
487:48 - profile so we can U provide many but in
487:51 - our case we want to connect to
487:53 - application- mySQL yl file so spring
487:57 - will automatically try to scan and read
488:00 - this file if exists okay I will click
488:04 - the
488:05 - run and let's see if the application is
488:09 - going to start correctly or not
488:12 - yes um all right so uh we see here here
488:16 - something that I didn't know uh so here
488:18 - we see that loading class this one but
488:21 - it's deprecated and the new driver is
488:24 - the one that we saw in the options okay
488:26 - so we will just update it later on now I
488:29 - want to go and check the
488:33 - schema let's refresh this one and here
488:37 - we see that we have now five schemas and
488:40 - we see our database data jpa so we don't
488:43 - have nothing yet but this one once we
488:46 - create the table the tables and the
488:48 - entities we will have all the tables in
488:51 - here so uh let's do the final
488:56 - update and let's replace this with a new
488:59 - driver using this package and that's it
489:04 - for this course we will implement the
489:06 - following database class diagram so uh
489:10 - this database class diagram is about uh
489:14 - e-learning platform
489:16 - and what it's about exactly so it talks
489:20 - about um how we can for example if you
489:24 - go to uh alibu coding and check the
489:27 - courses that I have there so what you
489:30 - see this is what we have behind the
489:33 - scenes so we have courses sections
489:37 - lectures and for each lecture we have uh
489:40 - a resource and the course has an author
489:43 - and so on so forth so this is what we
489:45 - will see but first let me explain to you
489:48 - uh in depth this class
489:50 - diagram
489:52 - so uh we have a course so for example
489:56 - this one that you are following right
489:58 - now which is mastering uh spring data
490:01 - jpa uh step by step so we have a course
490:05 - and this course has an author okay but a
490:10 - course can be done by many authors
490:13 - right and the same author
490:16 - can create many courses so for example
490:20 - me I can create so many
490:22 - courses and one course can be created uh
490:27 - within a collaboration of multiple or
490:30 - many uh authors okay so that's why here
490:33 - we have this many to many
490:36 - relationship but uh here create an
490:40 - author having an author within our
490:43 - database doesn't mean uh that this
490:47 - author should already have a course
490:49 - within the database but if we have a
490:53 - course we should have at least one
490:56 - author assigned to that because when we
490:59 - want to create a course we need to
491:01 - assign it to at least one one author
491:04 - okay so that's why you see it this you
491:07 - see this symbol right here and you see
491:09 - this one right here means that the
491:11 - author is optional to have courses but a
491:14 - course is is mandatory to be assigned or
491:18 - to be done or to be created by an
491:22 - author then uh you know that a course
491:25 - has one or many sections okay so um here
491:32 - when we create a course we need to
491:33 - create at least one section but we can
491:37 - have multiple sections for for one
491:40 - course and here just uh put few uh few
491:44 - attribute attributes just simple ones uh
491:47 - like title description uh name and order
491:50 - for the section and so on so forth um
491:53 - okay so uh as I mentioned a course has
491:57 - one or many sections but one section if
492:01 - we take one section it belongs to one uh
492:05 - one course and within the course we can
492:08 - have many sections that belong to that
492:11 - to that course
492:13 - okay all right
492:16 - next one when we talk about sections we
492:20 - have uh many lectures okay we have so
492:23 - many one or many lectures and one
492:27 - lecture one lecture if we take one
492:30 - lecture it belongs to one section so
492:34 - this means that we cannot have one
492:36 - lecture that belongs or can figure out
492:40 - with in different sections okay so if we
492:43 - take the section A that has uh lecture
492:47 - one and lecture two so this lecture one
492:50 - it belongs only to this section A it can
492:53 - we cannot find it as part of uh section
492:57 - c or section D for example okay now
493:02 - after that a lecture um has a type or
493:06 - has a resource okay so a lecture has one
493:11 - resource and this resource belongs only
493:14 - to this one lecture so that's why here
493:16 - we have this onetoone relationship
493:19 - between the lecture and the resource and
493:22 - for the resource we have of course the
493:23 - ID name size and URL and the resource
493:28 - can be of different types so I just
493:32 - created a simple uh simple types here
493:35 - for example video file or text so this
493:39 - represents a resource okay so here what
493:42 - we have we have um inheritance
493:46 - between this resource class or resource
493:50 - table and this video file and text
493:54 - objects okay so for the video we have
493:57 - the length for example for example how
493:59 - many minutes um this video for the file
494:02 - we have the type for example whether if
494:04 - it's uh PDF MP3 and so on so forth and
494:08 - we have the te for the text we have the
494:11 - content and all of them all these three
494:14 - types or three uh types of resources
494:18 - they are already uh resource and they
494:21 - can be assigned to lecture okay so this
494:25 - is our class diagram and this is what we
494:27 - will
494:29 - Implement during this course so we will
494:31 - go uh through all this one by one and
494:35 - each time or every time we need to
494:38 - explain something we will go ahead and
494:40 - create and see how we do that and also
494:43 - we will see how to create advanced
494:46 - search queries how to work with
494:49 - transactions and so on so forth so you
494:51 - already saw the plan of the of the
494:54 - course and this is what we will be
494:58 - implementing before we go further let's
495:02 - first understand and explain the
495:04 - difference between hibernate and spring
495:07 - data jpa so first spring data jpa is
495:12 - just an abstraction layer on top of jpa
495:16 - to reduce the amount of boilerplate code
495:19 - required to implement data access
495:22 - objects or what we call Da or D
495:26 - Dao but jpa what is jpa jpa is just a
495:31 - specification that facilitates object
495:34 - relation mapping to manage relational
495:38 - data in Java applications this means
495:40 - what we can consider jpa as uh a Java
495:44 - inter pH where we have or where we
495:48 - Define the methods that we want to be
495:52 - that we want them to be implemented by
495:54 - any class that wants to use or implement
495:57 - this interface and why is that because
496:00 - we have so many implementations like for
496:04 - example we have hibernate we have
496:06 - Eclipse link we have ibus and so on so
496:09 - forth that all of them they should
496:12 - implement the jpa specification and the
496:15 - reason behind that is we want to make uh
496:20 - coders or developers life much much
496:23 - easier so for example if you want to
496:25 - move from hibernate to Eclipse link all
496:28 - you need to do is to do a minimum
496:30 - configuration or minimal changes like uh
496:34 - CH changing the the dependency or maybe
496:39 - or maybe some basic configurations but
496:43 - for example if you have a save method
496:46 - it's the same it's exact the same method
496:49 - for hibernate uh and Eclipse link for
496:53 - example this this is what jpa exactly as
496:57 - as I mentioned jpa is just the
497:00 - specification okay now if we go to the
497:03 - hibernate level so hibernate is a jpa
497:08 - implementation and also hibernate
497:11 - generates uh SQL query and executes us
497:15 - using jdbc so hibernate is the omm the
497:19 - object relational mapping that will use
497:22 - jdbc to handle all the database side
497:27 - mean like saving uh reading deleting and
497:30 - so on so forth okay so this is the main
497:34 - difference between hibernate and spring
497:37 - data jpa so let me also re explain this
497:41 - part so instead of doing all the
497:44 - implementation
497:45 - and defining the S the session
497:48 - management and so the transaction
497:50 - management also and so on so forth that
497:53 - uh hibernate provides so spring data jpa
497:56 - will do all this job for us because as
498:00 - you know when using the spring data jpa
498:04 - starter it will autoconfigure almost
498:07 - everything for us so yeah this is the
498:11 - power of the spring data jpa let's see
498:15 - see first how we can transform a table
498:18 - or database table to a Java class and to
498:23 - be able to manipulate it uh within our
498:26 - application so let me explain this
498:28 - diagram right here so we have this
498:31 - author. Java that we will take as a
498:34 - first example and we want to process
498:37 - this object into our database and we
498:40 - want it to be stored directly into the
498:42 - author table okay
498:45 - so uh we have our author. Java that
498:49 - contains a set of attributes uh ID first
498:52 - name last name email and
498:55 - age and then what we will see next is
498:59 - which annotations that we need to use in
499:02 - order to make uh spring data jpa
499:06 - understand that this is a table or this
499:08 - is an entity and needs to be persisted
499:11 - and so and so forth okay so uh let's go
499:15 - to our anti J now let's create within
499:20 - our base package com. alibu coding. jpa
499:24 - let's create a new class or um yeah
499:28 - let's create a new class A Java class in
499:31 - here but if you want for example if you
499:33 - don't have the right package uh ready to
499:36 - use just uh when you want to create the
499:39 - class you can
499:40 - precise the package uh the package name
499:43 - for example if if you want to call to
499:46 - call them models or if you want to call
499:48 - them entity or entities it's up to you
499:51 - so you just um call uh give the the
499:55 - package name for example let's say
499:57 - models in here and then you
500:02 - can precise the class the class name so
500:05 - for us it we want to create the author
500:07 - Java class and we want it to be within
500:10 - the models package so when you hit enter
500:13 - so this is what we see in here and we
500:16 - have author created under the package
500:19 - models okay so now as we mentioned
500:23 - before let's just
500:26 - create our attributes so here just a
500:30 - reminder we want to create ID of type
500:32 - integer first name last name and email
500:35 - of type string and we have an age of
500:37 - type int here I
500:42 - have a private entity
500:48 - ID and they have a string first
500:58 - name and they have also a last
501:04 - name private string email and finally I
501:09 - have a private int
501:12 - H so this is my Java class now what we
501:17 - need to do or like normally or usually
501:20 - what needs to be done when you create uh
501:23 - a Java class or when you create
501:25 - especially when we talk about entities
501:27 - and so on so forth so always think about
501:30 - generating Getters and Setters so make
501:32 - all the fields private and generate
501:36 - Getters and Setters so to do so there is
501:39 - a
501:41 - shortcut uh in here like as you can see
501:44 - like you can generate uh using this
501:46 - shortcut and here we have getter and
501:50 - Setter here you can select all the
501:53 - fields that you want to generate Getters
501:55 - and Setters for and then just click okay
501:58 - and you will see that we have all these
502:01 - methods ready to use but if you remember
502:06 - we I will just roll back this so if you
502:10 - remember we already added lombok to our
502:13 - uh project or to our pom.xml so let's
502:16 - use lbook for that okay so the Lum book
502:21 - annotations we have many annotations
502:24 - many useful annotations we have the
502:27 - getter
502:28 - annotation and as you can see it's
502:30 - always from the package lbook so this
502:33 - will
502:35 - generate uh Getters for this class and
502:38 - also we want
502:40 - Setters so this will generate this
502:43 - annotation will will help us generate
502:47 - Setters or Setter methods for all the
502:50 - attributes in this class if you want
502:53 - also for example a no arcs Constructor
502:55 - means a Constructor with no parameters
502:58 - you have the no arcs Constructor
503:01 - annotation also if you need uh all Arc
503:05 - Constructor you can also add it using
503:08 - this annotation also all arcs
503:10 - Constructor but we have another
503:13 - annotation it's called
503:16 - Data always from uh from lombok and if
503:20 - we go and read the documentation always
503:24 - try to download uh sources to be more
503:26 - readable for you and to get all the
503:30 - information that you need so here this
503:32 - data annotation it generates Getters for
503:35 - all Fields uh useful to string method
503:39 - hash code uh hash code and equals
503:41 - implementation and so on so forth so
503:43 - this dat
503:45 - annotation it's the equivalent to getter
503:49 - Setter required AR Constructor to string
503:52 - and equals and hash code annotation
503:56 - so always to reduce the amount of boiler
504:00 - plate code we can remove
504:04 - this and we can remove this too so we
504:07 - can just work with two annotations data
504:11 - and no arcs Constructor and also if you
504:13 - need other annotations is also easy to
504:17 - use so we have now our uh our class or
504:22 - our Java object ready to use let's move
504:25 - on and try to make this an entity or to
504:29 - make it a table now let's try to answer
504:32 - one question is having a Java class
504:35 - containing all the attributes that we
504:38 - need for our table is it enough to tell
504:41 - spring that this is an entity so spring
504:45 - or spring data
504:46 - jpa how he will know that this is an
504:49 - entity and needs to be managed so the
504:52 - answer first of all the answer this is
504:55 - not enough having just a Java class is
504:57 - not enough and we need to tell spring
505:01 - that this is an entity so we need to
505:04 - provide and some annotations or some
505:07 - some information in order for spring to
505:11 - be able to scan and pick up this object
505:15 - so I already told you the answer so we
505:17 - need to give an annotation and this
505:19 - annotation is entity okay so this entity
505:25 - just let
505:27 - me show it to you first so now we are
505:32 - using spring boot
505:34 - 3.0 and as you know one of the uh
505:38 - breaking changes or like the biggest
505:40 - changes is using Jakarta E9 and when we
505:46 - use Jakarta e so we the package is no
505:50 - longer Java x.p persistence so all the
505:53 - Java X not all of them 100% but all the
505:56 - Java X packages that uh belongs to the
505:59 - Jakarta e now they they have been
506:03 - renamed to Jakarta okay and from now on
506:07 - we need to use Jakarta do persistence
506:10 - for all these annotations okay uh all
506:14 - right so here uh using this annotation
506:17 - and when we run the application
506:21 - automatically hibernate spring and
506:24 - spring data jpa like all of them are
506:27 - working together so they will be able to
506:30 - pick and tell this is an entity so we we
506:34 - need to use it okay and I want to show
506:37 - you also the
506:39 - documentation and it says that this
506:41 - specifies that the class is an entity so
506:45 - it specifies that the class that has
506:48 - this annotation is an entity okay and
506:52 - also this is so important this
506:53 - annotation is applied to the entity
506:56 - class so here it's um it's a type type
506:59 - level or type targets so like this we
507:03 - covered this part this entity part and
507:07 - we have here the same package as we
507:10 - already saw together so now spring will
507:12 - be able to know or to recognize this
507:16 - author. Java class as an entity let's
507:20 - move on and see what we need to provide
507:23 - as minimum information in order to have
507:27 - this entity created in our
507:30 - database after annotating this Java
507:34 - class this author Java class with the
507:36 - entity so this means that spring data
507:39 - jpa will recognize this class as an
507:42 - entity and it will create the table for
507:45 - example based on the configuration we
507:47 - specified in the ddl auto when we first
507:50 - configured the application so it will
507:53 - automatically create this table
507:55 - otherwise it will consider it as a table
507:58 - all right but here we see that we still
508:01 - have an issue even by having this entity
508:04 - annotation we still see that we have
508:06 - some error right here and let's go ahead
508:09 - and check it together so here it says
508:12 - that the persistent entity author so we
508:14 - see that now our class is a persistent
508:17 - entity should have a primary key so you
508:22 - may ask the question I already have a
508:24 - key field right here but yes this is a
508:28 - key for us we are human being and we
508:31 - understand and we can read that this
508:33 - field is ID and even Our intention is to
508:36 - have it as an ID for our entity but
508:40 - spring data jpa doesn't understand this
508:44 - spring dat data jpa is just a program
508:47 - it's just uh zero and one is a binary so
508:49 - it understands only annotations okay so
508:53 - to make this field an ID or any other
508:56 - field an ID we need to add an annotation
508:59 - and this annotation is as the name says
509:03 - so it's The annotation ID and here while
509:07 - we are using the spring 3.0 always make
509:10 - sure that you are using The annotation
509:12 - from the correct package okay so the
509:15 - package is always Jakarta dop
509:18 - persistence all right I will insert this
509:20 - one and we see that the error now is
509:23 - gone but first let me explain to you
509:27 - what is this idea so in Spring data jpa
509:30 - the ID annotation is used to Mark a
509:33 - field as the primary key of an entity it
509:37 - is used to specify the identifier
509:40 - property of an entity which is used to
509:43 - unique identify an instance of the
509:46 - entity in the
509:48 - database okay so when the entity is
509:52 - persisted to the database the value of
509:54 - this field will be used as a primary key
509:57 - of the corresponding database table so
510:01 - this means the value of this integer ID
510:04 - is unique within our table and also it
510:08 - might be unique within our database
510:10 - depends on the generation type or the
510:13 - strategy that we will use to generate
510:16 - this ID all right so here I want also to
510:19 - answer one small question you might ask
510:22 - so why we are using integer here instead
510:25 - of instead of int okay so the answer is
510:29 - as follow so the int value by default is
510:34 - zero but the integer value by default is
510:38 - null and this is super
510:41 - important because spring data jpa
510:44 - and when we talk and we talk mainly here
510:46 - about hibernate because we are using the
510:49 - hibernate
510:51 - implementation so uh hibernate each time
510:54 - when we try to save or to persist a new
510:57 - row or new line into our
511:00 - table hibernate will check the value of
511:03 - this ID or the field annotated with the
511:06 - ID if the value is null hibernate will
511:09 - understand that we want to create or to
511:12 - persist a new element into into the
511:14 - database otherwise if the value is
511:17 - different from null or is not null he
511:20 - will try to fetch the element within the
511:23 - table that has this value okay so if we
511:27 - use the int if we use the Primitive type
511:30 - so the default value will be zero so
511:32 - hibernate will try to find an element or
511:35 - a row with a value zero and it will
511:37 - never find it okay so that's why it's
511:40 - always recommended to use wrappers over
511:42 - primitive types
511:44 - okay so um I hope this is clear if you
511:48 - have any questions just go ahead reach
511:50 - out to me otherwise let's move
511:55 - on we already explained that this ID is
512:00 - the unique identifier of of our table
512:03 - and we mentioned that we want to use or
512:06 - we need to use the wrapper classes or
512:08 - the classes like objects in here because
512:11 - the integer is the wrapper class of the
512:13 - Primitive type in because when hibernate
512:16 - sees that uh this ID has a null value it
512:21 - will
512:22 - automatically uh generate a new ID and
512:25 - insert a new line into our table but how
512:29 - hibernate will generate this ID so here
512:34 - we talk about gener generation types or
512:37 - generated values for our IDs and here
512:42 - let's explain or let's see which
512:45 - annotation or which mechanism can help
512:47 - us generate this ID all right so the
512:52 - answer is easy and here we have an
512:56 - annotation called generated value and
512:58 - just a reminder always from Jakarta
513:01 - persistence and once we mention or once
513:05 - we annotate a field with this generated
513:08 - value here let's check the documentation
513:11 - what is written in here so it it says
513:14 - that it provides for the
513:16 - specification of generation strategies
513:19 - of for the values of primary keys so
513:22 - here this is a keyword means that we
513:25 - work with primary keys so this generated
513:27 - value works with primary keys so the
513:31 - generated value annotation may be
513:33 - applied to a primary key property or
513:35 - field of an entity or mapet super class
513:39 - in conjunction with ID annotation so
513:42 - this property of this annotation might
513:45 - work with primary key uh property of a
513:48 - field or an entity or mapped super class
513:51 - we will see all these uh terms
513:54 - together and always in conjunction with
513:57 - ID annotation the use of the generated
514:00 - value annotation is only required to be
514:03 - supported for simple primary keys so we
514:07 - cannot use this generated value with
514:10 - complex uh Keys means complex Keys means
514:14 - we can have for example uh an ID
514:18 - composed of two Fields let's say for
514:20 - example an integer and a date so this we
514:23 - can create a composed key and and we
514:25 - will see that
514:27 - also uh somewhere like after in the in
514:30 - this course okay so uh use the generated
514:34 - use of the generated value annotation is
514:37 - not supported for derivate primary Keys
514:40 - okay so um here we have this annotation
514:44 - generated value and we know that it will
514:47 - generate uh it will generate an ID or
514:50 - autogenerate a value for us let's check
514:53 - what we have in here or what which
514:56 - properties we have within this
514:58 - annotation so we have a strategy which
515:01 - is of generation type and also we have a
515:05 - generator so this strategy is the
515:08 - primary key so it's optional but it's
515:11 - the primary key generation strategy that
515:14 - the persistence provider must use to
515:16 - generate the annotated entity primary
515:19 - key so here it we we can Define or we
515:23 - need to Define what which strategy we
515:26 - want to use so the persistence provider
515:29 - and the persistence provider here means
515:32 - the database provider or the database
515:34 - management system we are using must use
515:37 - to generate the annotated entity primary
515:40 - key so here we have a default value for
515:43 - this
515:44 - and we will check what are the types we
515:46 - have right here the second one it's also
515:50 - optional we don't need to specify this
515:52 - property and this is the name of the
515:55 - primary key generator to use and
515:57 - specifies the sequence sequence
516:00 - generator or the table generator
516:02 - annotation defaults to the ID generator
516:05 - supplied by persistence provider so here
516:09 - based on the on the generation type that
516:11 - we want to use we can also create our
516:15 - own generator so this means what let's
516:18 - go ahead first and check this generation
516:21 - types so for this generation types we
516:23 - will go and understand them one by one
516:26 - we have table sequence identity and we
516:29 - have this UI ID and this Auto okay all
516:35 - right so we will understand this in a
516:38 - few
516:39 - seconds and now I want to go back
516:44 - to this generated value annotation and
516:47 - talk about this generator so we saw that
516:51 - within this generation type we saw that
516:53 - we have one value called table and one
516:56 - value called sequence so this sequence
516:58 - generator and table generator they are
517:01 - responsible if we want to create
517:03 - manually our sequence generator or table
517:06 - generator so we will understand that in
517:09 - the SEC in the next
517:12 - lecture
517:13 - [Music]
517:17 - so now let's understand the different
517:20 - types of this generation strategies so
517:24 - as we mentioned the default value of
517:26 - this generated value the strategy
517:29 - default value of it is the auto and we
517:32 - also have the sequence table and
517:34 - identity so first let's understand what
517:37 - this strategy equals Auto means so this
517:41 - means that hibern will try to connect to
517:45 - the database or to the persistence
517:47 - provider and try to determine which is
517:50 - the best strategy to use so to
517:54 - understand this more in practice so just
517:58 - a reminder here we see that you have
518:01 - within this this uh generated value
518:03 - annotation we have the default strategy
518:06 - is Auto and now in order to understand
518:10 - that all we need to do is to start our
518:12 - application so by default our
518:14 - application is connected to post degree
518:18 - SQL and we will see that within post
518:20 - degree SQL it will choose one strategy
518:23 - but when we choose uh MySQL or we start
518:27 - with the MySQL uh profile it will choose
518:30 - a different one okay so let's go ahead
518:33 - and start our
518:37 - application so our application has
518:39 - started and we let's check the log first
518:42 - and then we will check the database so
518:45 - here it's just a normal log and a
518:47 - classic one but we see here we have some
518:50 - hibernate logs so now what we have we
518:53 - have create sequence author sequence
518:57 - start with one increment by 50 okay and
519:01 - then we create a table author with the
519:04 - following uh attributes integer ID not
519:07 - null and so and so forth and we have
519:09 - here or we are defining here a primary
519:12 - key ID okay
519:15 - so this is good let me reduce this and
519:18 - here within this uh data jpa or our
519:21 - database let's refresh it and here if
519:23 - you see Zero of three you need to select
519:26 - the public schema okay now let's open
519:30 - this one within the public we see that
519:32 - we have one table which is our author
519:35 - table right here with the fields or the
519:37 - columns that we defined which is uh ID
519:40 - age email first name and last name
519:43 - and also we see that we have one
519:46 - sequence which is the author sequence so
519:49 - by
519:51 - default hibernate determined that the
519:55 - best strategy to generate IDs for this
519:59 - uh database for the Post degree SQL
520:02 - database is US using sequence so it
520:05 - created a
520:06 - sequence and it named it author sequence
520:10 - by default like it takes the
520:12 - concatenation of of the table name
520:14 - within a suffix _ sequence and then it
520:18 - using it will use this sequence to
520:20 - generate values so if we have multiple
520:23 - tables or like more than one entity the
520:26 - sequence name will be hibernate sequence
520:29 - okay but for now we have on one single
520:31 - table so it will take the table name
520:34 - with this sequence suffix all right now
520:37 - let's restart our application but using
520:40 - the MySQL profile and let's see what
520:44 - will happen within this MySQL okay so
520:48 - let's do it and in order to profile uh
520:53 - in order to define the different profile
520:56 - so all we need to do here with an entity
520:58 - J you see this uh little card right here
521:01 - just click on it and then open edit
521:04 - configurations select your application
521:07 - right here so you might have multiple
521:09 - ones but select the one jpa application
521:12 - it's the our application name and here
521:15 - specify the profile name and the profile
521:17 - name how you can find it let me close
521:21 - this one
521:23 - first and you open here and you see for
521:27 - um here for our application it it's
521:29 - called application- MySQL so this MySQL
521:33 - is the profile name so now let's go
521:37 - ahead edit the configuration and in the
521:40 - active profiles right here I will just
521:42 - provide my SQL so like that when we
521:45 - start up the application spring we'll
521:47 - pick up this configuration
521:50 - file so now the application is running
521:54 - and we see that uh we have drop table if
521:57 - exist drop table if exist and here what
522:00 - do we have here we are creating first
522:02 - create table author with the with the
522:05 - attributes or the IDS that we precised
522:08 - and we see here instead of creating a
522:11 - sequence we have have create table
522:15 - author sequence so it contains a next
522:19 - value attribute of type big in okay so
522:22 - here MySQL and hibernate determined that
522:26 - the best strategy for my SQL is uh using
522:32 - table okay using strategy table and this
522:36 - might not be the best strategy but maybe
522:39 - MySQL or any other database management
522:42 - system does not support one or another
522:45 - strategy for example my SQL does not
522:47 - support sequences so it will fall back
522:49 - to the second option maybe I don't know
522:52 - the exact order but I'm just trying to
522:54 - explain it like that so it will fall to
522:56 - the next strategy which is author uh
522:59 - which is table strategy okay so let's
523:02 - check our tables right now click here
523:05 - refresh and now we see that we have two
523:09 - tables the one is our author with the
523:11 - five columns that we already precised
523:13 - and the author sequence is only one
523:16 - column which is the next value so if I
523:18 - open this table you see that for now it
523:21 - contains only one line and the value is
523:24 - one and if I insert any
523:27 - data it will
523:29 - automatically increase it by one and use
523:32 - it for the next value all right so this
523:35 - is the auto strategy and now let's move
523:39 - on and talk about the next
523:41 - one
523:43 - so here we saw together how hibernate is
523:47 - able to detect which strategy is the
523:49 - best for our persistence provider now
523:53 - let's talk a bit more into in details
523:56 - about this sequence generation okay so
524:00 - by default hibernate will create a
524:03 - sequence if possible of course but let's
524:06 - assume that we are using postre SQL and
524:09 - the best strategy is sequence so
524:11 - hibernate will automatically create a
524:13 - sequence but what if we don't have the
524:17 - right to create sequences what if we
524:20 - have a database admin that creates
524:22 - everything for us so we need or we need
524:26 - to specify which sequence we have
524:29 - already or like we need to point
524:31 - hibernate to that sequence and the name
524:34 - might be different one might be a
524:36 - different sequence so we need to point
524:38 - hibernate to that so this is one use
524:40 - case the Second Use case I want to
524:43 - create my own the sequence and I want
524:46 - also to autogenerate or to Auto
524:49 - configure manually the allocation size
524:51 - so we saw in the previous uh lecture
524:54 - that hibernate will use the value 50 as
524:57 - an
524:57 - incrementation or as a step value so we
525:01 - want for example to be one all right so
525:04 - let's see how we can do this so now in
525:08 - order to do that first of all we need to
525:11 - specify the strategy right here and the
525:14 - strategy if you hit control space we see
525:17 - the the options that we have and let's
525:19 - choose sequence okay now I just want to
525:22 - remind you that within this generated
525:25 - value annotation we have the strategy
525:27 - and the generator and the generator here
525:29 - it's the name of the primary key
525:32 - generator all right so let's give it
525:36 - right here I would just put it into new
525:40 - lines and here I will precise the
525:43 - generator and my generator is a string
525:46 - like we should we need to give it uh a
525:48 - string name and I will call it author
525:51 - generator or sequence author sequence
525:54 - okay I would call it author sequence or
525:57 - SE like let's call it sequence to to see
526:00 - the difference between the one we
526:02 - generated before or that was
526:04 - automatically generated I'm talking
526:06 - about this one so our name would be
526:09 - author sequence all right okay so now we
526:13 - have author sequence but when we start
526:15 - the application hibernate will will not
526:18 - find this author sequence so it will
526:21 - claim or it will raise an exception
526:23 - telling that we don't find this
526:25 - exception all right so what we need to
526:27 - do is we need to create or to manually
526:31 - create this sequence okay and to do that
526:34 - it's really easy
526:36 - peasy we have an annotation called
526:39 - sequence
526:40 - generator and this annotation sequence
526:44 - generator it takes a name as a parameter
526:47 - so this is uh the name and the name
526:51 - should be the same like as this one all
526:54 - right so I'm just going to copy paste it
526:57 - to avoid uh
527:00 - typos and let me align it so after
527:04 - providing the name we need also to
527:06 - specify the sequence name the sequence
527:09 - name is the sequence that all also we
527:13 - want to use as a name all
527:15 - right so sequence Name by default it's
527:18 - empty but let's also use this author
527:22 - sequence as a name next we talked about
527:26 - uh allocation size means the step of
527:29 - increasing or incrementing this sequence
527:32 - and it's called allocation size and as
527:35 - you can see here the default value of
527:38 - this one is 50 and this is what we saw
527:41 - before in the
527:42 - that's this is where this allocation
527:45 - size or 50 is coming from all right so
527:48 - for us we want an allocation size of one
527:52 - and now that's it we have our sequence
527:55 - generator and we have our generated
527:57 - value for this ID let's go ahead start
528:00 - the application and see what will
528:04 - happen so here we see that we have this
528:08 - log right here uh create sequence author
528:11 - sequence so now it's called author
528:13 - sequence start with one increment by one
528:16 - so it starts from the position number
528:19 - one and it's incremented by one and this
528:22 - start by one so it's from the initial
528:25 - value so you can also change it if you
528:27 - want to start your sequence from
528:29 - specific value all right next we are
528:32 - creating the table and now let's go and
528:34 - check the database and make sure that we
528:37 - have everything in order so I will just
528:39 - refresh this
528:41 - one and we see that we have our table
528:44 - and now our sequence is called author
528:47 - sequence so in case you want to create a
528:50 - uh specific sequence or um yeah a
528:54 - specific sequence for each entity this
528:57 - is the way how to do it all right so now
529:01 - this is how sequences works and then you
529:05 - don't need to do anything hibernate will
529:07 - automatically use this author sequence
529:10 - to generate the ID
529:12 - all right so that's it if you have any
529:15 - questions just reach out to me on
529:18 - contact alibu coding.com or you know all
529:22 - my contacts on social media otherwise
529:24 - let's move on now what if we want to
529:27 - choose different strategy of generation
529:31 - what if we want to use table instead of
529:33 - sequence and we want to create our SE or
529:37 - table generator instead of sequence
529:39 - generator so let me show you how to do
529:42 - that first of all I will just comment
529:44 - out this sequence generator I will let
529:47 - it I will leave it here in the code so
529:49 - you can use it then we need to change
529:53 - this generation type from sequence to
529:57 - table and I will call or rename this
530:00 - generation or generator instead of
530:03 - author sequence I will call it uh author
530:06 - ID generation generator okay so ID gen I
530:11 - would call it like that okay now uh
530:14 - instead of using this sequence generator
530:17 - we have a similar annotation which is
530:20 - table generator okay this table
530:22 - generator it takes a name as parameter
530:27 - so the name I don't need to mention it
530:29 - again but it should be the same name as
530:32 - in here after precising the name I want
530:36 - to precise Also the table
530:39 - right so the table right here let's call
530:43 - it ID generator for
530:46 - example all right next we need to
530:49 - precise the primary colum
530:52 - name comma here PK colon name and this
530:57 - is going to hold the column name of our
531:00 - primary key let's call it um ID name for
531:04 - example just to make it uh easy for you
531:07 - I will call it ID name and the
531:11 - value
531:13 - and the value colum name is the value
531:16 - for this colum so I will call it ID
531:19 - value just to be consistent with that
531:22 - and make it easy for you and of course
531:24 - we can Define the allocation size as you
531:27 - can see here it's always default 50 and
531:30 - I want to make it one all right so I
531:33 - will keep the same profile the the
531:36 - postre SQL profile so we can see the
531:39 - difference or we can see what will
531:41 - happen when I restart the application so
531:44 - I'm going to stop it right now and
531:46 - restart
531:47 - it so here let's first check what we
531:51 - have as information so we have here
531:54 - create table author so this is our main
531:56 - table and then we are creating a table
531:59 - called IG ID generator and the ID name
532:02 - is type of V chart 255
532:05 - 255 and ID value and so and so forth so
532:10 - here what we are doing and insert into
532:12 - ID generator and we are inserting the
532:15 - first value which is the author and the
532:18 - and the value is zero all right so let's
532:22 - check what we have in here I'm going to
532:24 - refresh this
532:26 - one let
532:28 - me so here we no longer see this
532:32 - sequence generator right here we no
532:34 - longer have the sequence but instead we
532:36 - have this generator table and this
532:39 - generator table it contains only uh
532:42 - already one line which is the author
532:44 - which is our entity name and the ID
532:47 - value is zero so when we use this table
532:51 - generator the one that we created
532:54 - manually it will create one line for
532:56 - each entity and it will initialize the
532:58 - ID value for it so if we want to insert
533:01 - another entity it will come here query
533:04 - it by the name and as you can see the
533:07 - name is is an ID so it should be unique
533:10 - and it will increment the the value for
533:12 - that one so this is how we can also use
533:16 - tables as uh generators but here before
533:20 - we finish this
533:22 - part I want just to bring everything as
533:26 - it was before so I will also comment
533:29 - this out just to leave it in the
533:32 - code like that and also I will change or
533:36 - just remove this okay so I will just
533:40 - leave it as generation type Auto and
533:44 - like that I don't need to care about uh
533:46 - which strategy to use all right so
533:49 - that's it if you have any questions
533:50 - don't forget to reach out to me
533:52 - otherwise let's go ahead and
533:57 - continue in the background I restarted
533:59 - the application so we have the previous
534:02 - state so now we have our table and we
534:04 - are using the sequence as a generator so
534:08 - what we what I want to show you in this
534:10 - part is as you can see here we have this
534:13 - ID age email first name last name and so
534:16 - on and so forth but the question is what
534:20 - if I want to have more control over
534:24 - these columns okay so for example this
534:28 - first name I want to have a different
534:30 - name and I want to have a different name
534:31 - for this last name I want something
534:34 - which is different from the field that I
534:36 - have right here so this is the first
534:38 - thing the second I want to have uh you
534:41 - unique or I want to make sure that my
534:43 - email is unique so uh this will prevent
534:47 - me from having duplications uh when we
534:50 - talk about email because we know that an
534:52 - email is unique per per user all right
534:56 - so to do so we have an annotation that
535:00 - can help us um Reach This goal so let me
535:04 - make this one full
535:05 - screen and first of all let's talk about
535:09 - this annotation so The annotation is
535:10 - colon
535:12 - and first let's check what this column
535:15 - is what this annotation so it specifies
535:18 - the mapped column of a persistence
535:21 - property or field if no colon this is so
535:24 - important if no colon annotation is
535:27 - specified the value of the default value
535:30 - apply so default value means what means
535:33 - the default values of this annotation of
535:36 - this column annotation and let's quickly
535:39 - check the attributes that we have right
535:41 - here here so as you can see all of them
535:44 - are optional here so the first one we
535:48 - have this name so this is the name of
535:50 - the column otherwise it will take the
535:52 - property or the field name so if we
535:55 - don't precise anything in here so the
535:57 - default name will be first name and here
536:00 - as you can see that uh when we write it
536:03 - in camel case it will be transformed
536:05 - automatically into snake
536:08 - case all right now let's go back to this
536:11 - colon annotation we have a unique
536:14 - attribute so this specifies whether the
536:17 - colon is unique or not uh also if it's
536:20 - nullable if we accept null values by
536:23 - default it's true but if we accept null
536:26 - values or not and here we have this
536:30 - insertable uh property so this means
536:32 - what this means that if we accept the
536:36 - that we can insert new value for this
536:40 - colum you may ask the question why I
536:43 - should prevent inserting and the answer
536:46 - is when we talk about for example dates
536:49 - and we have an update date or the last
536:51 - modified date of this column so here we
536:55 - want we don't want it to be insertable
536:58 - but we want it to be only updatable okay
537:02 - so here we have insertable true
537:04 - updatable true and the same the same for
537:07 - this updatable property so for creation
537:11 - date or like the the date of creation of
537:15 - a new line or when we insert a new row
537:17 - into a table we want to track the
537:20 - creation date so the creation date
537:22 - should be only insertable and we need to
537:25 - insert it only when we when we create a
537:28 - new line but when we update the same
537:31 - line we don't want to update it so this
537:34 - field should not be updatable okay and
537:38 - here we have a table we have length and
537:40 - also length for example for Strings we
537:43 - can specify or we can say for example
537:46 - that um username or a login name or uh
537:50 - AO name uh should be only maximum or
537:53 - have the length of eight uh eight
537:55 - characters maximum okay and when it
537:58 - comes also to uh numeric numbers or
538:02 - decimals we can talk also about
538:04 - precisions and scale so okay now we we
538:08 - talked enough let's go and see this in
538:10 - action all right so the for the first
538:13 - name I want to have uh my name or the
538:18 - name of this field to be like that for
538:20 - example F name all right and why we have
538:25 - or why we we need to change this so like
538:29 - um for projects from scratch it's it's
538:32 - okay because we will Define everything
538:35 - but imagine you want to work on on a
538:37 - project where the database already
538:39 - exists and for example let's take the
538:42 - financial um domain and the database
538:45 - already exists but believe me you don't
538:47 - want to know how they call the fields or
538:50 - the columns so it's totally totally
538:53 - different because they are using really
538:55 - technical names uh Financial technical
538:58 - names so we want to have a more
539:02 - understandable for our Java application
539:04 - we need to have a more understandable
539:06 - names so we need to stick to the same
539:10 - names to the datab base but we want to
539:12 - have our own all right so when we
539:15 - manipulate objects within our uh Java
539:18 - Java project we want to use first name
539:21 - instead of this F name or it can be F1 2
539:24 - 3 4 so we don't want to name our field
539:27 - F1 2 3 4 we want to name it first name
539:29 - and then we can reference it or we can
539:32 - give it a name that will be used within
539:33 - our database
539:38 - okay so this is the first one now I will
539:42 - move on to this email so for the email
539:45 - for example it's okay it's fine for me
539:48 - to keep the name as it is but for this
539:51 - email I want for example to I want it to
539:53 - be unique so as you can see and also as
539:56 - I showed you before this unique
539:58 - attribute has a default value false so
540:01 - by default the field or the colum is not
540:03 - unique but let's make it unique so when
540:06 - we use this property this means that the
540:08 - email will become unique so we can
540:11 - cannot insert a duplicate values for
540:15 - this email all right also I can make it
540:19 - non nullable because also nullable by
540:22 - default is false but I want to specify
540:26 - or like make the user uh pass a value
540:30 - for this email so the email I want I
540:32 - don't want to see any emails into my
540:34 - database with null values okay also if
540:38 - you want to I I know this is um this is
540:41 - not okay but let's go back and do it in
540:44 - here I was going to talk about the
540:46 - length if I want to have a specific
540:49 - length so the default is
540:51 - 255 and let's say for example I want to
540:54 - have uh 35 as max length for this first
540:58 - name so this is the property to use all
541:02 - right so here if we talk for example as
541:06 - we mentioned before I will
541:09 - create a local date time field right
541:12 - here uh created at so this is the
541:16 - creation date and I will give it also
541:19 - the colon annotation all right and for
541:21 - this colon annotation I want this to be
541:26 - not updatable all right so as you can
541:28 - see it's by default true but I don't
541:31 - want this field or this colum to be
541:35 - updated so I want it only to be
541:37 - insertable so I don't need to specify
541:40 - the insert because by default it's true
541:43 - but I don't want this one to be
541:46 - updatable and this one cannot be null
541:50 - all right so this also nullable false
541:54 - now I will create another column and I
541:57 - will call it last updated at or last
542:01 - updated or last modified let's call it
542:04 - like
542:06 - that so for this last modified I will
542:09 - also use the colum annotation
542:11 - and within this colum annotation I want
542:15 - this one to not to be insertable so I
542:18 - don't want to insert this last modified
542:22 - when I first created when I first create
542:24 - a new line or when I first insert a new
542:27 - line I want this last modify to be null
542:30 - so because if I insert it it might be
542:33 - confusing because for example I want to
542:36 - query all the data where the all the
542:39 - data that were not modified okay so I
542:42 - don't want to insert it all right uh I
542:45 - want it also to be updatable and it will
542:48 - be nullable so I just keep the default
542:51 - value because nullable is by default
542:57 - true so using this column annotation we
543:01 - can have more control over our columns
543:05 - within the within our entity and on the
543:08 - database level so we can precise the
543:11 - name we can precise the length we can
543:13 - also um check the Unicity and the
543:16 - nullability of of our field also we can
543:20 - decide if it's updatable or not and if
543:22 - it's insertable or or not so this
543:26 - annotation gives us more more and more
543:28 - control over our uh our columns okay so
543:33 - I'm going to restart the application and
543:35 - let's see the impact of these uh of
543:39 - these annotations right here so let's
543:41 - see what what was the impact of this so
543:46 - um here so it's here it's just updating
543:49 - the constraint so here we see that first
543:52 - of all we are we are adding a con new
543:55 - constraint to our email with this unique
543:59 - so now it's Unique and here for example
544:03 - for the age uh it's an integer not null
544:06 - and we have this created at it's not
544:09 - null the Emil mail is also this the same
544:13 - and we see that the first name is now
544:15 - called f name and and is no longer
544:18 - called first name all right so we see
544:22 - also that the last modified is a
544:24 - timestamp but we don't have any control
544:26 - over it like uh not null and so and so
544:29 - forth same for the last name and here we
544:32 - are defining the primary key as our ID
544:35 - colum let's see the changes directly
544:39 - visually I will refresh
544:44 - this and now we have our seven columns
544:48 - so we see here that we have this ID the
544:51 - age created at email and we see this
544:53 - small circle right here so this means
544:57 - that these objects are not null or so
544:59 - they should not be null okay also we see
545:03 - that we have two keys so we have the
545:05 - author primary key and we have a second
545:08 - one which is referencing the email
545:11 - because we don't want this email to be
545:14 - null and we want it to be unique so here
545:17 - you see this UK is unique stands for
545:20 - Unique key PK stands for primary key all
545:23 - right so I hope this was clear for you
545:25 - otherwise drop me a message and let's
545:28 - move
545:32 - on now let's take the following example
545:36 - what if we want our table to be named
545:39 - author and _ TBL as a table name in the
545:44 - database and we have our Java class
545:48 - called author so in this case how we can
545:52 - map or how we can tell this entity or
545:56 - the Java class or we mainly talking
545:59 - about spring data jpa and hibernate how
546:02 - we can tell hibernate to name this
546:04 - entity and give it the name author
546:07 - underscore TBL in the database so the
546:11 - answer is in here we see this annotation
546:14 - this the table annotation is the one
546:16 - that can help us do this so let's see
546:21 - the power of this
546:23 - annotation so let's go back to the code
546:25 - right here and now I will use this table
546:29 - annotation right here so first of all
546:31 - let's check what are the properties of
546:34 - of this annotation so first of all uh it
546:38 - says that it specifies the primary table
546:40 - of of uh for the annotated entity
546:42 - additional tables may be specified using
546:45 - secondary table and secondary tables so
546:49 - here if no table annotation is specified
546:52 - for an entity class so the default
546:54 - values apply so if we don't use this
546:57 - annotation we will apply this default
546:59 - Valu so the name will be empty catalog
547:02 - and so on so forth so let's now discover
547:06 - quickly these these fields or these
547:08 - properties so name this is the name of
547:10 - the table so we already have the answer
547:12 - how we can change or how we can give a
547:15 - specific table name here we can also
547:18 - specify a catalog and the same for the
547:21 - schema so for example if my table is
547:24 - located in a different schema so I can
547:28 - provide it in here so I can give this
547:30 - information so for example if I have a
547:32 - schema 1 schema 2 and schema 3 within
547:35 - the same uh within the same database so
547:38 - uh I can spe specify or I can precise
547:42 - which schema for each entity or each
547:45 - table also if I have unique constraints
547:49 - like the one we did before we want uh
547:51 - for example our email to be unique we
547:54 - want we want to add a new indexes and so
547:57 - and so forth so we can add a list or a
548:01 - table of unique constraints okay the
548:04 - same for indexes all right let's go back
548:08 - here so for our case we only want want
548:11 - or we only need to give uh to give a
548:13 - name to our table because the we have
548:17 - only one schema so if you have a
548:19 - different one you can give also the
548:21 - schema name so here I will call it
548:23 - author
548:26 - TBL and I will restart the application
548:30 - and let's see the changes so click on
548:32 - restart right
548:35 - here and let's check again what we have
548:38 - so we have this sequence this AU auth
548:41 - tlore sequence and we have our table now
548:44 - is called author TBL okay so just for
548:47 - record uh databases are not case
548:49 - sensitive just in case you don't know
548:52 - this information so that's why we see
548:54 - here that the table is written is lower
548:57 - case and here it's already in uppercase
549:00 - so we see we see now that the table or
549:03 - the table name has changed and now it's
549:05 - called author TBL all right so yeah
549:09 - that's it I will just clean up the code
549:13 - make comment out this annotation and I
549:16 - will leave the rest for you so thank you
549:19 - so much um drop me a message if you have
549:22 - any questions otherwise let's move on so
549:25 - far we learned how to
549:28 - manipulate date tables how to create
549:31 - entities which are the annotations that
549:33 - we need to use which properties of these
549:36 - annotations we can use like for example
549:39 - when we talk about uh generated values
549:42 - how and the strategies how they work how
549:44 - we can also customize them and create
549:47 - our own uh and private sequence and
549:50 - table uh table generator and so and so
549:52 - forth but now we didn't reach yet the
549:56 - point where we need to discuss or where
549:59 - we need to manipulate and interact
550:01 - directly with a database interact means
550:04 - for example crude operations like read
550:07 - uh create read update and delete and
550:10 - this we will see right here for example
550:14 - we have as always our author table in
550:18 - the database so this author table has
550:21 - its own representation in our Java code
550:24 - as an author. Java and we need to
550:28 - persist this object to this database so
550:31 - the link between the author and the
550:32 - database right here because the DAT a
550:35 - table already belongs to a database but
550:38 - when we talk about Java program and
550:40 - programs and also when we talk about
550:42 - spring boot framework we talk about uh
550:46 - entities all right so um what we need to
550:49 - do to in order to better interact with
550:54 - this
550:55 - database so here comes the power of
550:58 - spring data jpa so spring data
551:01 - jpa uh made it so easy for us because he
551:05 - proposed something really really nice
551:08 - which is a repository and and the
551:10 - repository is an abstraction to reduce
551:13 - the amount of boiler plate code needed
551:16 - to implement the Dow layer or the data
551:19 - access object to interact with the data
551:22 - stores okay so let's go a bit deeper
551:26 - within this definition so in Spring data
551:29 - jpa a repository is a Java interface
551:32 - that is used to abstract the data access
551:35 - layer from the business logic it is used
551:39 - to perform crude oper ations crude just
551:41 - a reminder stands for create read update
551:44 - and
551:45 - delete as well as other common database
551:48 - operations such as pagination and
551:52 - sorting repositories are typically
551:55 - defined as
551:57 - interfaces and uh that extend one of the
552:01 - spring data jpa repository interfaces
552:04 - such as uh jpa repositories crude
552:08 - repository paging and sorting repository
552:11 - so these are the three main uh
552:14 - repositories or jpa repositories that we
552:17 - can extend like we create an interface
552:20 - and extend this interface to to have our
552:24 - own repository okay so because these
552:27 - interfaces provide a number of
552:29 - predefined methods that can be used to
552:33 - perform common database operations such
552:35 - as uh saving deleting entities finding
552:38 - entities by their primary Keys finding
552:41 - entities based on various criteria and
552:44 - this is what we will see in details
552:45 - later on okay but
552:48 - first let's understand and see this
552:52 - hierarchy of
552:54 - repositories so far we learned how to
552:57 - create a Java class out of a database
553:00 - table and this Java class is the
553:03 - representation of the table in our
553:05 - database now we have another question is
553:09 - what can we do do or how can we do when
553:12 - it comes to database manipulation and
553:14 - interacting with the database means if I
553:17 - want to persist a new object into or a
553:20 - new row into this author table so how
553:24 - can I do this so the answer is using jpa
553:29 - repositories all right so but first
553:32 - let's understand and give a quick
553:34 - definition of this repository so a
553:37 - repository is an abstraction to reduce
553:40 - use the amount of boilerplate code
553:43 - needed to implement the Dow layer or the
553:46 - data access object to interact with the
553:49 - data stores in theep in Spring data jpa
553:54 - a repository is a Java interface that is
553:57 - used to abstract the data access layer
554:00 - from the business logic it is used to
554:03 - perform crude operations such as create
554:07 - read update and delete so this is what
554:09 - crude stands for uh like and then as
554:13 - well as other common database operations
554:16 - such as paging and sorting so
554:19 - repositories are typically defined as
554:22 - interfaces that extend one of the spring
554:25 - data jpa repository
554:28 - interfaces such as crude repository
554:31 - paging and sorting repository or jpa
554:35 - repository so this has been a bit
554:40 - changed since uh spring 3.0 and I will
554:43 - show you the difference right now so
554:46 - these interfaces provide a number of
554:49 - predefined methods that can used to
554:52 - perform common database operations such
554:55 - as saving and deleting entities finding
554:58 - entities by their primary Keys finding
555:01 - entities based on various criteria and
555:04 - so and so forth and we will see in deep
555:08 - how we can create data or can create
555:11 - queries using the spring data jpa
555:15 - repositories so but first let's
555:18 - understand or see the hierarchy of the
555:21 - spring data jpa
555:24 - repositories so as we can see here
555:26 - that's why I told you before that it was
555:29 - slightly uh changed about when we talk
555:32 - about paging and sorting repositories
555:34 - because now the new architecture looks
555:37 - like that so we start as we mentioned by
555:41 - creating an interface so for our for our
555:44 - example we want to create an author
555:47 - repository and then we need to extend
555:49 - one of these five repositories that we
555:52 - see right here all right but let's start
555:56 - start and see the uh inheritance from
556:00 - the lower level from the lowest level to
556:02 - the from the highest level to the lowest
556:04 - one actually it's the the other way
556:05 - around so we first can start by EX
556:10 - standing jpa repository right here and
556:13 - this jpa interface uh repository it also
556:18 - extends two other interfaces at the same
556:21 - time so it extends the list paging and
556:24 - sorting repository and list crude
556:27 - repository so this list crude and list
556:30 - paging so both of them they contain
556:33 - methods like that's that this is where
556:35 - comes the difference because there have
556:37 - been a small refactoring in this
556:39 - interfaces so now we have all the
556:42 - methods that returns list they are
556:45 - within this list paging and sorting
556:47 - repository so this in order also to to
556:51 - reduce more the the boilerplate code
556:55 - because for example if I want only to
556:57 - perform crude operations with I don't
556:59 - need list so I can only extend this
557:03 - crude repository same for paging and
557:06 - sorting but if I want everything all I
557:08 - need to do is extending this jpa
557:11 - repository so let's continue so here we
557:14 - see or we said that uh the jpa
557:16 - repository extends at the same time list
557:19 - crude repository and list paging and
557:21 - sorting repository and the list crude
557:25 - repository already extends crude
557:27 - repository and this crude repository
557:30 - also extends the basic uh interface
557:33 - which called repository the same way
557:36 - when we when we take the left hand side
557:39 - uh part so when we talk about jpa
557:42 - extending list paging and sorting
557:44 - repository this interface itself it also
557:47 - extends the paging and sorting
557:49 - repository so now let's go
557:52 - ahead and see the code or the Implement
557:55 - well not the implementation but the
557:57 - interface which was created by Spring
557:59 - data jpa so go back to your
558:03 - inj hit command shift o or control shift
558:07 - plus n for Windows and Linux users and
558:10 - just type jpa repository and you will
558:12 - see that we can open the Java class or
558:15 - the repository if you already downloaded
558:17 - the code and we can open it and it's the
558:21 - one spring data jpa the version
558:23 - 3.0.0 so if you are using a previous
558:27 - version of spring boot this might be
558:29 - slightly different
558:31 - okay but our course is fully focusing on
558:35 - Spring 3.0 because we want to see the
558:38 - new changes and we want to use also the
558:41 - most recent versions all right let's go
558:44 - back in here so we see that we have here
558:46 - our jpa repository interface which is
558:49 - extending at the same time list cud
558:52 - repository and list paging and sorting
558:55 - repository so this query by example
558:58 - executor so this is something else we
559:00 - will see uh later on so that's why I
559:03 - didn't mention it in the in in this uh
559:07 - in the diagram so let's go back and and
559:09 - focus on this so here we have this list
559:13 - crude repository if we open it we see
559:15 - that this list crude repository is
559:18 - already extending the crude repository
559:21 - and list crude repository contains all
559:23 - the listing methods so save all find all
559:27 - find all by
559:29 - ID and then when we open this crude
559:32 - repository we see that it also extends
559:35 - the repository interface and this screw
559:38 - repository contains
559:40 - uh these methods like the crude method
559:42 - save save all find find by ID and so and
559:45 - so forth all right and the same way if
559:49 - we want to go to list paging and sorting
559:52 - so here we have this find all within
559:55 - this list paging and sorting repository
559:57 - the same when we go to the paging and
559:59 - sorting repository interface we see that
560:02 - we have this find all find all and so
560:04 - and so forth and this one like we see
560:07 - when we talk because when we talk about
560:09 - p paging and sorting we mainly talk
560:11 - about lists so we have here the first
560:14 - parameter for the find all is sort and
560:16 - the second one it's a pageable and the
560:19 - pageable also contains the Sorting so we
560:21 - can when we if we want we want to use
560:24 - this one so it already covers this all
560:27 - right but make sure that the return type
560:29 - of this one is iterable and this one is
560:32 - page so this is just to mention and as
560:35 - we said both of them they extend the
560:37 - repository interface all right
560:41 - so if you have any questions don't
560:44 - hesitate to drop me a message otherwise
560:46 - let's move on and
560:49 - continue first of all we will create a
560:51 - repository for this author model or this
560:55 - author entity but first of all Don't
560:57 - Panic if you see that I removed the code
561:00 - and don't worry you will not be losing
561:02 - the code because here it's just a
561:04 - cleanup and you can find all the code
561:07 - when you go to git right here and then
561:09 - you click on the logs you will see that
561:12 - after each chapter I will commit or have
561:15 - a full commit right here so if you
561:17 - double click on this author you will see
561:19 - all that you all you need so here you
561:22 - have the entity you have all the
561:24 - annotations the strategies and so and so
561:26 - forth so you will see all the changes
561:29 - that we will do in each chapter so don't
561:31 - panic don't worry about about that so
561:34 - it's just for me to have a clean code
561:36 - for each step all right so now in order
561:40 - to create a repository it's so easy so
561:43 - here I will create a
561:45 - new package or I can create a class and
561:49 - a package at at the same time so here
561:53 - create a package called it
561:55 - repositories and then Dot and the class
561:58 - name or the repository name and don't
562:00 - forget to select interface because we
562:03 - mentioned that a repository is an
562:05 - interface that extends another interface
562:08 - one of the jpa repository interfaces so
562:13 - uh let's call it author
562:16 - repository hit enter so here we see that
562:19 - we have a public interface author
562:21 - repository and in order to transform or
562:24 - to tell spring that this is a jpa
562:26 - repository we need to extend one of the
562:30 - J one of the repositories okay the
562:33 - repository interfaces so for our case we
562:36 - will extend the jpa Repository
562:39 - so because within jpa repository we have
562:43 - all the methods and as we saw before
562:46 - this jpa repository it's a generic
562:49 - interface that takes two types the first
562:52 - one is T which is the class or the table
562:57 - and the second one is the ID and this is
563:00 - the unique ID or the type of our ID
563:03 - within our entity all right so if here
563:06 - it's integer so we will pass integer if
563:08 - you use string long uh big decimal and
563:12 - so on so forth just pass the type all
563:15 - right so let's finish this one so it's a
563:18 - repository or jpa repository of our
563:21 - object author so this will help uh
563:25 - spring data GPA to determine and
563:27 - correctly write the correct queries okay
563:31 - and of course we we want our ID which is
563:34 - of type integer okay so like this we
563:38 - have our first repository now let's go
563:42 - ahead and play a little bit with this
563:45 - repository and create or insert some
563:48 - data and see how we can use this
563:52 - repository now in order to test this
563:55 - repository right here we need to create
563:57 - a service and then create a controller
564:00 - expose the endpoint and use Postman or
564:02 - like Swagger UI to test this uh
564:05 - repository or test this methods and so
564:08 - and so forth so the process might be a
564:10 - bit long but let me show you a better
564:13 - way how to do it okay so we will use a
564:16 - command line Runner and the command line
564:19 - Runner is uh a bean or is a method that
564:23 - will be executed at the application
564:26 - startup okay so when we first start the
564:29 - application we will run this method and
564:33 - within this method we can inject any
564:35 - Bean which is available within our
564:37 - application context all right so to do
564:40 - so let me close all this go to the jpa
564:45 - application or your main application
564:47 - file the one where you have the spring
564:49 - boot application because this is the
564:52 - startup
564:53 - class and then just create a bean all
564:58 - right so add the bean annotation and
565:01 - here a public beans always should always
565:04 - be public don't forget that and the type
565:07 - is command line run
565:11 - R all right so this interface right here
565:14 - command line Runner give it a name
565:18 - command line Runner and within this
565:21 - command line Runner uh method or Bean
565:24 - you can pass any type you want right
565:27 - here okay so it's like that and now I
565:31 - want to inject my author repository
565:35 - right here okay so I will create an
565:38 - object of type author
565:41 - repository I will call it repository as
565:44 - a simple name so like this automatically
565:47 - this Bean or this auor repository will
565:50 - be injected okay so now to implement
565:54 - this let's use a Lambda
565:57 - expression so let's say
566:01 - return args or something like that and
566:04 - then Arrow function and that's it and
566:09 - inside this method we can implement or
566:13 - we can do whatever we want within this
566:16 - repository okay so let's go back check
566:19 - quickly our author method so here we
566:22 - have the data no arcs Constructor entity
566:24 - and so and so forth I will just add two
566:28 - annotations the first one is all arcs
566:32 - Constructor to have a Constructor with
566:35 - all the arguments and the other one is
566:38 - the Builder annotation so the Builder
566:40 - annotation it's for uh the design
566:43 - pattern Builder which help us create and
566:46 - building objects so I will show it to
566:48 - you right away so now to use this
566:52 - Builder uh annotation or this Builder
566:54 - design pattern I will create a VAR
566:56 - called it author so you can use VAR
566:59 - because we are uh using Java
567:02 - 19 so equals
567:05 - author do builder. build so you see
567:10 - because we have this author because we
567:13 - have this Builder annotation now we can
567:15 - use this build or Builder method so you
567:19 - see already in the icon right here this
567:21 - is the lombok icon and yeah so and then
567:25 - I will just type
567:28 - build all right so uh this Builder help
567:32 - us like we can use the field names as as
567:36 - methods so first name email and so on so
567:39 - forth to create or to instantiate an
567:42 - object all right so uh let's have first
567:47 - name I will call it
567:50 - alibu last name also
567:54 - alibu let me make this one full
567:57 - screen uh age okay I'm going to I'm
568:01 - going to give you my age I'm getting a
568:03 - bit
568:04 - old okay so email here you can find my
568:08 - email if you want to contact me so it's
568:10 - contact at alibu coding.com
568:15 - and that's it so these are the
568:18 - information that we need to create an
568:20 - author object now let's use our
568:24 - repository dot
568:27 - save all right so within the repository
568:30 - let's go ahead and have a quick look on
568:32 - the methods that we have right here so
568:34 - we have save count count delete equals
568:38 - uh delete all delete all by ID so all
568:41 - these methods they come from all the
568:43 - interfaces that we saw together so like
568:47 - we have a pre-built methods that we can
568:50 - use without any need to create uh
568:54 - methods our own like or to type or
568:56 - create queries manually so we can use
568:59 - spring data jpa or the repositories to
569:03 - create a bunch of methods or many
569:05 - methods that uh can make our life so so
569:08 - easy so for now I want just to test the
569:11 - save method so I want to save this
569:14 - author object okay so at the application
569:18 - startup when I run the application this
569:21 - Bean will get executed
569:26 - and and it will insert a data or a line
569:30 - into the database okay so uh let's start
569:34 - the application and test this
569:37 - one
569:39 - all right so the application is running
569:42 - right now and let's first check the logs
569:44 - we see that we have a first log from
569:46 - hybernate which is Select next Val from
569:49 - author seek or like this is the sequence
569:53 - so hibernate will get the sequence or
569:55 - the next value from our author sequence
569:58 - and then we see that we have an insert
570:00 - into author age email and so on so forth
570:03 - and here we have the values so here it's
570:06 - like just uh interrogation mark
570:09 - because uh it will not print out the the
570:12 - execution but here it's logging already
570:15 - that you are inserting something into
570:17 - the database now let's open our database
570:20 - and check that we have our data so I
570:25 - will open this author table uh first Let
570:28 - me refresh because we renamed few
570:31 - staffs yeah now we have our author table
570:36 - go ahead open it and we can see right
570:39 - here that we have this ID we have the
570:42 - age email and so and so forth so here
570:46 - like the the object he got executed this
570:49 - Bean got executed and now we see that we
570:52 - have some data within uh our database so
570:57 - also this might be useful for you if you
570:59 - need to execute something at the
571:01 - application startup you can use this
571:04 - command line Runner so we will be using
571:06 - it uh in the future Maybe to uh to test
571:10 - few things all right so yeah that's it
571:12 - let's move on now and answer one small
571:19 - question at the application startup when
571:22 - we execute this block of code or when we
571:26 - execute any kind of this code in service
571:29 - or in controller or whatever so I mean
571:33 - when we create an object and we try to
571:36 - make a transaction to our database
571:39 - saving it deleting it reading and so and
571:42 - so forth so we call this a transaction
571:45 - but this is not the main um goal of this
571:49 - part but first of all we want to
571:52 - understand what is the life cycle of an
571:55 - entity okay and to understand this let's
571:58 - go ahead and open this diagram right
572:02 - here in order to understand what is a
572:05 - life cycle okay so in in hibernate an
572:09 - entity is an object that is persisted to
572:13 - a database table and the life cycle of
572:16 - an entity refers to the entity to the
572:20 - different states that it can be uring
572:24 - its existing from when it's first
572:26 - created until it's eventually removed
572:30 - from the database all right so let's go
572:34 - and check these four states of a hybern
572:38 - entity
572:40 - okay so the first one here we have the
572:43 - first state which is the the state
572:46 - transient and this is the state of an
572:49 - entity when it has just been
572:52 - instantiated and is not associated with
572:55 - h with a hibernate session an entity in
572:58 - this state is not persisted to be the
573:02 - database and is not managed by hibernate
573:05 - this means what means when we have or we
573:08 - create create a new instance of our
573:10 - author object or we use the Builder for
573:12 - that so we move from the object to a
573:16 - transient object right here so at this
573:20 - level our object is still transient it's
573:23 - not persisted and it's not yet managed
573:26 - by hibernate but once we execute one of
573:30 - the following methods save persist save
573:33 - or update or update so like this we will
573:36 - move from the transition
573:38 - state to the persistent state so the
573:41 - entity or this object will become a
573:44 - hibernate managed object all
573:48 - right all right let's talk about and
573:51 - explain this persistent state so this is
573:54 - the state of an entity When It's
573:57 - associated with a hibernate session and
574:00 - is being managed by hibernate an entity
574:04 - in this state is persisted to the
574:07 - database and any changes made to its
574:10 - properties will be persisted to the
574:12 - database when the transaction is
574:14 - committed so here when we do or when we
574:18 - operate any kind of this operations
574:21 - right here so the state will become
574:24 - persistent and any updates so if we made
574:27 - any if we make any updates to these auor
574:30 - object and we execute one of them so
574:33 - this change it will be affected or
574:36 - applied to the database one once the
574:39 - transaction is committed all right so
574:42 - now after this trans after this
574:44 - persistent State we can move whether to
574:48 - the removed state or to the detached one
574:51 - let's talk about the detached State
574:54 - first so to detach an entity the detach
574:58 - is this state of an entity is when it
575:01 - was previously associated with a
575:04 - hibernate session but is no longer
575:07 - associated with it it all right and an
575:10 - entity in this state is persisted to the
575:13 - database but is not being managed by
575:17 - hibernate any changes made to uh to its
575:20 - property will not be persisted to the
575:22 - database until the entity is reattached
575:26 - to a hibernate session so let's focus on
575:30 - this until the entity is reattached to a
575:33 - hibernate session session so this means
575:35 - what once we execute one of the
575:38 - following methods detach close clear or
575:43 - evict the state of the hibernate entity
575:48 - will pass from persistent to detached
575:51 - okay and here when the entity is
575:54 - detached we have two choices so the
575:57 - first one we can go back to the
575:59 - persistent state or we can just go to
576:03 - the garbage this object will just move
576:06 - to the garbage right here okay but let's
576:09 - first talk about this uh word that we
576:12 - said until the entity is reattached to
576:15 - the hibernate session to reattach the
576:18 - entity to the hibernate
576:20 - session we can use one of the following
576:23 - methods save save or update merge merge
576:26 - or lock so this means what means within
576:29 - one method we can save we can create the
576:33 - object so it moves to the trangent save
576:36 - it so it goes to persistent
576:38 - and after the persistence or after
576:40 - saving the entity we can do some logic
576:43 - and then we call the session the hyet
576:46 - session. detach so it will move to the
576:48 - detached State once it's detached we can
576:52 - also change some properties for example
576:55 - and then we can call back this one of
576:58 - these methods save save or update and so
577:01 - and so forth so it will go back to this
577:03 - persistent state if if not or if we
577:06 - don't execute one of these methods so
577:10 - the entity will just go to the garbage
577:12 - so it will no longer become hibernate
577:15 - managed entity okay so now let's go back
577:20 - to this persistent state so from this
577:23 - persistent State we we can move to this
577:27 - removed State all right so to move from
577:31 - persistent to removed we need to execute
577:34 - a method or a delete Method All right so
577:37 - the removed is the state of an entity
577:40 - when it has been deleted from a database
577:43 - an entity is in the state in this state
577:46 - so in the in the state removed is no
577:49 - longer persisted to the database and is
577:51 - not being managed to by hibernate so
577:55 - once we delete an entity so it passes to
577:58 - the state removed and then automatically
578:01 - to the garbage okay and here let's talk
578:05 - about a little bit and explain this
578:07 - state or moving the object to the
578:10 - garbage as you can see right here if we
578:13 - create an object if so it's in the
578:15 - transient state so from the transient
578:18 - state it will move to the garbage if we
578:20 - do not execute any of these methods okay
578:25 - once we persist an object and then we
578:29 - try to detach it so and then we we do
578:33 - nothing it will also go to the garbage
578:36 - okay again from this persistent State
578:39 - once we perform a delete uh operation it
578:42 - will go to removed state so it will the
578:45 - state will become removed and then it
578:47 - will move to the garbage again now we
578:50 - can go here from this state from this
578:54 - author directly to this persistent state
578:58 - so this means what this means when we
579:00 - try to perform a get operation find all
579:03 - find by ID and so on so forth so we will
579:07 - directly go to this persistent state so
579:10 - because here we we don't need to
579:11 - instantiate any kind of uh data but we
579:16 - just want to call our session management
579:18 - or persistent uh persistence
579:21 - entity or entity manager to get or to
579:24 - fetch data directly from the database so
579:27 - we move from this initial State directly
579:30 - to a persistent State and then we can
579:33 - move to these different other states so
579:36 - we can perform a detach save delete or
579:39 - remove all right so this is the
579:42 - hibernate entity life cycle but here
579:46 - something uh something really important
579:48 - to know about so we with using spring
579:52 - data jpa we no longer need to care about
579:56 - all this life cycle because it's
579:58 - automatically managed first of all
580:01 - second so this save persist detou and so
580:04 - and so forth is being handled in the
580:08 - background so we don't need to
580:10 - automatically uh commit the transaction
580:13 - or detach The Entity and so on and so
580:15 - forth because spring data jpa will do
580:18 - the job for us so now we know and and we
580:22 - understood what is the life cycle of our
580:25 - entities let's move on and explore other
580:28 - important
580:29 - things if you have any questions as
580:33 - always do not hesitate to drop me a
580:35 - message otherwise let's move on
580:38 - previously we've been playing around
580:40 - this author entity now what about if we
580:44 - talk about this whole class diagram and
580:48 - how we can realize it okay but before
580:51 - that we see that we have relationships
580:54 - between the different entities we have
580:57 - the many to many one to many and so and
580:59 - so forth but first of all what is
581:02 - relationship and why we need
581:05 - relationships in in a database
581:08 - relationships between entities can be
581:10 - used to represent the connections and
581:13 - dependencies between different pieces of
581:16 - data and there are several types of
581:20 - relationships that can be created
581:22 - between entities such as one to one one
581:25 - to many and many to many
581:28 - relationships creating relationships
581:31 - between entities allows you to model the
581:34 - real world relationships between
581:36 - different pieces of data more accurately
581:40 - which can help you better understand and
581:43 - analyze your data it can also help you
581:47 - to enforce data integrity and prevent
581:51 - inconsistencies by ensuring that changes
581:54 - to related entities are coordinated and
581:58 - consistent with each other in addition
582:01 - to modeling real world relationships
582:05 - creating relationships between entity
582:07 - can also improve the performance of your
582:11 - database by using relationships you can
582:14 - avoid storing redundant data in multiple
582:18 - tables and instead use foreign keys to
582:21 - reference related data in other tables
582:24 - this can help to reduce the size of your
582:27 - database and improve query performance
582:31 - overall creating relationships between
582:35 - entities uh is an important part of
582:38 - Designing a well structured and
582:41 - efficient database it can help you to
582:44 - model real world relationships more
582:47 - accurately enforce data integrity and
582:50 - improve the performance of your database
582:53 - so when you work with SQL databases
582:57 - always think about adding relationships
583:00 - this is important to improve everything
583:03 - and ensure Integrity or your data inte
583:07 - Integrity now before moving on and start
583:11 - implementing uh this class diagram and
583:15 - um creating relationships between the
583:17 - different entities let's explain one
583:21 - small thing so here we have for example
583:24 - this course entity and this author we
583:27 - see that we have one relationship here
583:30 - it's many to many relationship because
583:33 - we said that an author can create uh
583:35 - multiple courses and one one course can
583:38 - be created by multiple authors so that's
583:41 - why we have the many to many
583:43 - relationship all right so here we have a
583:47 - questions this question is how can this
583:52 - relationship be done and the answer is
583:55 - here we are not talking about
583:57 - annotations we are not talking about
583:59 - anything but the focus or the main focus
584:03 - in here is the type of the relationship
584:07 - so here we can identify two types we
584:11 - have unidirectional relationship this
584:14 - means that one entity has a relationship
584:18 - with another entity but the other entity
584:22 - does not have a corresponding
584:24 - relationship within the first entity
584:27 - this means that the relationship is
584:29 - defined only on one side of the
584:32 - relationship this means what like when
584:35 - we talk a bit uh code right now this
584:38 - means when we create uh for example the
584:41 - course entity and we want to link this
584:44 - course entity as a many to many
584:46 - relationship within the author so we
584:49 - create an attribute or a list of authors
584:52 - uh within the course uh entity and give
584:56 - it The annotation many to many and
584:59 - that's it so this is what we call
585:01 - unidirectional relationship so it's from
585:05 - only one side now now what if we want to
585:09 - make it BD directional so in a b
585:13 - directional relationship both entities
585:17 - have a relationship with each other so
585:20 - this means that the relationship is
585:22 - defined on both sides of the
585:24 - relationship so first of all we created
585:27 - a list of authors right here and it's
585:30 - referencing the author now to make it B
585:33 - directional we need to create a list of
585:36 - courses in the author entity right now
585:40 - right here so like this we will
585:43 - ensure that we have a b directional
585:47 - relationship in general UD
585:50 - unidirectional relationships are simpler
585:53 - and easier to understand but they do not
585:57 - allow you to navigate uh the
585:59 - relationship in both directions means
586:02 - you can you can navigate from course to
586:04 - author but if you implement unique any
586:07 - directional relationship you cannot
586:10 - navigate from author to course so it
586:13 - only ensures one way uh oneway
586:16 - navigation but B directional
586:18 - relationships are more powerful and
586:21 - flexible but they can be a bit more
586:24 - complex and require more care to
586:26 - maintain the Integrity of the
586:28 - relationship that it also ensure a b
586:31 - directional navigation from both sides
586:34 - so from author we can access the courses
586:36 - and vice versa now let's move on and
586:40 - start creating all these classes let's
586:43 - create let's create and Implement
586:45 - everything we have right here let's
586:47 - start now by creating our entities so
586:50 - what we will do is we will create a Java
586:53 - class and give it the entity annotations
586:56 - for each of these classes that we have
586:59 - right here but we will not do any um any
587:02 - mappings any relationships we will just
587:05 - create Java class scores for example
587:08 - with an ID title description and so and
587:10 - so forth so this is what we will be
587:12 - doing right now and then we will move on
587:14 - and Implement and explain in details all
587:18 - these relationships and annotations that
587:20 - we can
587:22 - use so let's go back to our anj I will
587:26 - close all these
587:28 - tabs and within our models
587:32 - package I will right click and create a
587:34 - new class I will call it course
587:37 - so here like as we did with this author
587:41 - we can use the same annotations right
587:45 - here so we need the data no arcs
587:47 - Constructor or all arcs Constructor the
587:50 - Builder and especially the entity
587:52 - annotation because we need it to make
587:55 - the class or the course. Java class an
587:58 - entity but just I will copy paste them
588:02 - to make it uh much much faster all right
588:06 - so this this course right here let's go
588:10 - ahead and create few fields we have an
588:13 - ID we have a private
588:17 - string
588:19 - name and we have also a private string
588:25 - description and that's it so here we
588:27 - have our entity next let's add the ID
588:31 - annotation because we need it and we
588:33 - have also the generated value and just a
588:36 - reminder of always make sure you use the
588:38 - Jakarta persistence if we if you are
588:41 - using the spring 3.0 otherwise it's
588:44 - still Java x. persistence for the
588:47 - previous versions so generated value and
588:50 - we will leave the strategy to hibernate
588:53 - to decide which strategy is better for
588:55 - us next let's
588:58 - create the section entity so I will call
589:03 - this class section paste the same
589:05 - annotations we we used before and now we
589:09 - need to create a private integer
589:13 - ID and
589:15 - private string name the section
589:20 - name and also a private int order so we
589:25 - want to give an order for it for each
589:27 - section all
589:30 - right okay now as always we need this ID
589:35 - annotation and we need this generated
589:38 - value annotation right here okay so
589:41 - that's it within this section uh entity
589:44 - let's move on and create the next one
589:46 - let's now create the lecture entity so
589:50 - right click right here new class and
589:53 - call it
589:54 - lecture as always just paste the
589:58 - annotations that we will need and now
590:00 - let's create an integer ID
590:05 - attribute and then we need also the
590:07 - private string lecture name so that's it
590:11 - we have only an ID and a name within the
590:13 - lecture and now let's add the ID
590:16 - annotation and the generated value so
590:19 - this should be an easy task for you and
590:23 - let's move on and create the next one
590:25 - now we will create this resource entity
590:28 - but for the moment we will not create
590:30 - this uh inheritance video file and text
590:33 - but we will leave it for later when we
590:35 - will explain The Inheritance within
590:39 - hibernate all right but for now let's
590:41 - just stick to this resources entity and
590:44 - create the following
590:48 - attributes so go ahead right click on
590:51 - the models package create uh a new class
590:54 - and just call this one a resource always
590:58 - paste the annotations and we have here a
591:02 - private integer
591:05 - ID private
591:08 - string name resource name and private uh
591:13 - int
591:15 - size and we have finally private string
591:19 - URL so this represents the URL of the
591:23 - resource and do not forget the ID and
591:27 - the generated value
591:29 - annotation so that's it now we have all
591:32 - our entities created let's now move on
591:35 - and start implementing the relationships
591:38 - one by
591:39 - one now let's start establishing and
591:42 - creating relationships between our
591:45 - entities so let's start from here let's
591:48 - create the one many to many relationship
591:51 - between the author and the course and as
591:53 - we explained before an author can create
591:56 - multiple courses and one course can be
591:59 - created in collaboration of multiple
592:02 - authors that's why we have the many to
592:05 - many relationship in here here now let's
592:07 - go back to our entity
592:10 - J and as we mentioned before when we
592:13 - talk about many to many relationships or
592:16 - many relationships the first thing that
592:19 - we need to think about is creating lists
592:22 - okay so let's open our author entity and
592:26 - scroll down here and first of all create
592:30 - a private list the list is always from
592:34 - the Java util package and we want to
592:36 - create a list of course okay and let's
592:40 - call it courses so this is the first
592:42 - step Second Step go also to this courses
592:46 - uh entity and in here create a
592:52 - private list of authors okay uh author
592:57 - and let's call it authors all right so
593:01 - this is the first two steps next we are
593:04 - talking about many to many
593:07 - relationships so let's add many to many
593:10 - right here and many to many also on the
593:14 - course
593:15 - level so now we defined or we have our
593:19 - many to many relationships
593:23 - okay but now we need to define something
593:26 - we need to define the owner of this
593:30 - relationship so because we have the
593:32 - owner and the reverse relationship and
593:35 - in many many relationships in jpa one of
593:39 - the entities is considered the owner of
593:42 - the relationship and is responsible of
593:45 - maintaining the foreign key values in
593:48 - the joint table and the other entity is
593:51 - considered uh the inverse of the
593:54 - relationship and does not have any
593:56 - foreign keys in the join table all right
593:59 - so to do so once you decide which of
594:03 - them should be the owner of the relation
594:06 - ship just go to the other one that you
594:09 - want it to be the inverse relationship
594:12 - and give it uh the map it by attribute
594:16 - like give it the value all
594:18 - right so for our case we want the course
594:22 - to be the the owner of the relationship
594:26 - so the author is the inverse
594:29 - relationship right so within this
594:31 - inverse relationship add this Mapp it by
594:36 - and the mapet by should be or we should
594:38 - provide the name of the attribute we
594:41 - have right here so here it's called
594:43 - authors just go copy and paste it in
594:46 - here be careful about making typos all
594:50 - right so if you make some typos this
594:52 - means that you can also have exceptions
594:56 - at the application startup okay so now
594:59 - let's go back to the owner of this
595:04 - relationship so for for our case the
595:07 - owner is the the course and now to
595:11 - define the the the join table of this
595:15 - relationship we Define it from the owner
595:18 - side so here we will use this join table
595:22 - annotation and here this means or this
595:25 - has a goal uh of creating a new joining
595:29 - table between our author and courses
595:33 - okay so uh for this joint table let's
595:36 - provide some properties first of all is
595:38 - the name the name is will be or will
595:41 - hold the name of the joint table let's
595:44 - call it
595:47 - authors
595:48 - courses means the courses of authors are
595:51 - like you can call it whatever you
595:53 - want
595:55 - next we need to define the join column
595:59 - and here we can we can Define multiple
596:02 - join columns okay so the join columns
596:05 - right here here equals and now we need
596:08 - to pass a list of joint columns I will
596:11 - just make it a new line so it it will be
596:14 - more readable for you and now we will
596:17 - use The annotation join column okay it's
596:20 - always Jakarta
596:23 - package and for this join colum we will
596:26 - we need to provide the
596:27 - name and the name right here let's call
596:30 - it uh so this join colum is the one
596:33 - responsible or the one that will hold
596:36 - the information or the primary key of
596:39 - the owner of the relationship so this
596:41 - one will be the course
596:43 - ID okay next Once We Define the join
596:49 - columns we need to define the inverse
596:51 - join column so when we when we say
596:53 - inverse we are talking about the inverse
596:56 - entity so here inverse join columns
597:00 - right here equals and as the same way
597:04 - here we need also to use at join
597:09 - colum so join colum and let's give it a
597:14 - name and here let's call it author
597:18 - ID so like this or in this way we just
597:22 - defined a many to many
597:24 - relationship between our author and
597:27 - course and to check that let's just
597:30 - restart the application and see the
597:32 - impact in the database and also let's
597:35 - check the
597:40 - box so here we
597:45 - see all right so here we have uh we have
597:49 - one exception and you see right here
597:52 - it's caused because of this syntax error
597:55 - near order because in
597:59 - this lecture the sorry in this uh
598:03 - section the order is a reserved name
598:06 - okay so let's just rename it to section
598:09 - order right or position or something
598:12 - like that let's restart the application
598:14 - again and see what
598:22 - happens all right so let's first check
598:24 - the logs here we have everything is
598:27 - working fine and here we are creating
598:29 - the sequences for each entity you see
598:32 - that for each entity we have or we are
598:34 - creating a sequence and here we have the
598:37 - author we are creating the author and
598:39 - the course and also we are creating the
598:42 - author's courses the The Joint table
598:46 - that we created for this author and
598:48 - course entity we have also the lecture
598:50 - resources and so and so forth and here
598:53 - we are creating all the constraints all
598:55 - right so and also here we are inserting
598:57 - because we still have
599:00 - this Bean right here so if you want to
599:03 - stop it just comment this Bean
599:07 - out comment this out and it will no
599:09 - longer insert insert data so now let's
599:12 - go and check our database so here
599:16 - refresh it and now we should see at
599:20 - least the author author course and
599:23 - courses so here we have our colums so we
599:27 - see that we have this ID age email and
599:30 - so and so forth for from the author and
599:33 - we have from the course we have this
599:36 - three columns that we just defined ID
599:38 - description and title and now from the
599:41 - author courses we see that we have two
599:43 - columns and you see for the primary Keys
599:46 - it's a golden key but for foreign Keys
599:49 - it's blue key so now we see that we have
599:52 - this course ID which is referencing the
599:54 - course and the author ID which is
599:56 - referencing the author entity all right
600:00 - so this is how we can create many to
600:03 - many relationships let's move on and see
600:05 - see how we can Implement relationships
600:08 - between the other entities too if you
600:12 - have any questions don't hesitate to
600:13 - drop me a message otherwise let's move
600:18 - on at this level let's implement the
600:21 - relationship between the course and the
600:24 - section so a course has m zero or many
600:29 - sections so or one or many sections okay
600:33 - and one section if we take one section
600:36 - it belongs to only one course so here we
600:40 - have one course to many sections and we
600:43 - have many sections to one course so how
600:47 - we can also explain this so when we
600:50 - create a course we have the course but
600:53 - every time we create a new section we
600:55 - will have a foreign key course ID that
600:58 - will be Associated within this section
601:01 - class all right so let's see now how we
601:04 - can implement this so at this level we
601:07 - are talking about the course so and we
601:10 - said that one course has many sections
601:15 - so here when we say that we have one
601:19 - course and many sections so list of
601:26 - sections and let's call it sections okay
601:30 - so this is the first
601:31 - step because we have one too many so
601:34 - it's always the the current instance or
601:37 - the current object which is the course
601:39 - has many sections so we create a list of
601:43 - sections right here okay now let's go to
601:47 - the
601:47 - section you can do uh command click or
601:51 - control B for Windows and Linux to
601:54 - navigate to the definition of this so
601:57 - here we said that many sections can
602:00 - figure out or many sections belong to
602:03 - one course all right so here this means
602:06 - that we need to create a private course
602:10 - element right here or um a field of type
602:13 - course right here let's call it course
602:17 - okay now from now to implement the
602:21 - mapping so we go back to this course.
602:24 - Java where we have the list and it's
602:27 - easy like when we have the list always
602:29 - think about one too many so it's just as
602:33 - we explained it it's one core
602:36 - it's one course too many sections so one
602:40 - course too many sections all right and
602:43 - here when we use one too many we need to
602:46 - map it or to tell which mapping that we
602:49 - need to use so here map it
602:51 - by and this MPP it by it should be the
602:55 - exact same attribute name we have right
602:58 - here so just copy paste it and be
603:01 - careful always about typos so here we
603:04 - have this one to many now let's go and
603:06 - navigate to the section entity So within
603:10 - the section right here we said that many
603:14 - courses or many sections so we said that
603:17 - many sections they belong to one course
603:21 - so we have many to one and when we use
603:24 - many to one we need to specify the join
603:28 - column so when we create a course when
603:31 - we create a section right here what
603:33 - should be the joint column name all
603:35 - right so here we need to add or to use
603:38 - The annotation annotation join column
603:41 - and let's give it a name right here and
603:45 - the name let's call it course
603:48 - ID okay so now we just created a mapping
603:52 - or relationship between the course and
603:55 - the section so let's restart the
603:57 - application and see the
603:59 - changes so the application just started
604:02 - right here and we see that we have all
604:06 - these entities now let's go and check
604:08 - our database and now what I'm expecting
604:11 - is to see a foreign key called course ID
604:14 - within this section class so let's do it
604:17 - refresh the table right
604:23 - here and let's check this section So
604:27 - within the section we have four column
604:29 - this is good and we see that we have for
604:31 - one foreign key and this foreign key is
604:35 - this one so we see it's uh FK let me
604:37 - make it a bit bigger so we see that this
604:42 - uh FK stands for foreign key and this is
604:45 - the ID of this foreign key so the I the
604:48 - name or the key of this attribute is
604:51 - course ID and it references to the
604:54 - course okay so it references the course
604:57 - ID that we have within this course table
605:00 - okay let's also check again the columns
605:02 - right here so we see that we have an ID
605:05 - name name section and course ID so like
605:08 - this we are able to create or to make a
605:12 - relationship between two entities using
605:16 - one to many okay let's move on and
605:19 - implement the next and if you have any
605:21 - questions don't hesitate to drop me a
605:27 - message now let's implement this
605:29 - relationship between the section and the
605:31 - lecture and it's also one too many as we
605:34 - did for the course right here so this I
605:38 - think it's an easy task for you and
605:40 - let's go ahead and implement it quickly
605:43 - so from the section level right here we
605:47 - said that the section has a list or list
605:51 - of uh lectures or many lectures so let's
605:54 - go ahead create private
605:57 - list lectures okay and let's call it
606:02 - lectures and now let's move to the
606:05 - lecture and create or reference it
606:08 - within the object that we have so here
606:11 - we have
606:14 - private
606:15 - section
606:18 - section and now let's add the mapping
606:21 - okay so we say that we have one
606:25 - section one section to many lectures and
606:30 - this one is mapped
606:31 - by section okay so it should be just a
606:36 - reminder it should be always the same
606:38 - name that we have here now from the
606:40 - section level as we explained before
606:43 - it's one section to
606:45 - many uh it's one lecture to many
606:49 - sections and here many SE many
606:54 - lectures can belong or they belong to
606:57 - one section okay so here we have many to
607:02 - one and do not forget to add the join
607:04 - column
607:05 - and give it a name and let's call it
607:09 - section
607:10 - ID all right so that's it let's restart
607:13 - our application and check the diagram
607:16 - and check that we have all the foreign
607:19 - key correctly
607:22 - created and here if we go to this
607:25 - lecture I'm expecting to have this
607:27 - foreign key right here which is section
607:30 - ID referencing the section and also for
607:33 - the columns we have the ID name name and
607:35 - the section ID as a foreign key right
607:38 - here so that's it let's move on and
607:41 - implement the one: one relationship
607:44 - between the lecture and the
607:50 - resource now when we talk about a
607:53 - lecture and a resource we talk about
607:55 - onetoone relationship because one
607:58 - lecture has only one resource and when
608:01 - we talk about one resource it belongs
608:04 - only to one lect
608:05 - so that's how or that's from where we
608:08 - got the one toone relationship okay just
608:11 - as a reminder this part we will see
608:13 - later
608:15 - on now let's go back to our code now in
608:18 - order to implement a one toone
608:20 - relationship so first of all Define your
608:24 - uh your entities and in here we have uh
608:27 - our section and also we have our
608:30 - resource so from the section
608:34 - level
608:35 - let's create a private
608:39 - resource let's call it resource okay so
608:43 - when we talk about onetoone
608:45 - relationships we can talk about one uh
608:49 - unidirectional or B directional mapping
608:52 - okay so we can link the lecture to the
608:56 - resource and that's it so we will have
608:59 - uh the owner of this relationship is the
609:01 - lecture and we can access the resource
609:04 - from the lect lecture but when we want
609:07 - to go back uh or access the lecture from
609:10 - the resource we will not be able to do
609:12 - that because we don't have B directional
609:14 - relationship so let's start with
609:17 - unidirectional relationship now in order
609:20 - to Define uh onetoone relationship as I
609:23 - mentioned create an object of the the
609:26 - other entity so in our case it's an
609:29 - object of type resource and here we need
609:32 - to use the one to one relationship okay
609:36 - so here we have the one to one we can
609:39 - also Define the join column name that we
609:42 - want to
609:43 - use and here let's say resource
609:48 - ID all right so this is how we can
609:51 - define a onetoone
609:54 - relationship and then let's restart the
609:57 - application and see the impact of
610:01 - this so now we see that the application
610:04 - started let's let's check the
610:08 - database now if we go to the lecture we
610:12 - see here that now we have two foreign
610:15 - Keys the first one is from the resource
610:18 - the one we just created and the second
610:20 - one is we the one we previously created
610:22 - from the section but here we need to
610:24 - focus or we want to focus on this
610:27 - resource ID from the resource okay also
610:30 - if we open this one we can see that we
610:33 - have a new uh column defined here which
610:36 - is the resource ID
610:39 - okay let's go now and implement the
610:44 - second way or like the B directional one
610:47 - to1 relationship so just to make it
610:50 - faster I would just copy these
610:52 - annotations go to the resource entity
610:55 - and as we did before let's create a
611:01 - private
611:03 - lecture and let's call it lecture right
611:06 - here okay and now let's paste this one
611:10 - to one annotation and join column and
611:13 - this one let's call it lecture
611:17 - ID so here this means when we want to
611:20 - create um when we want to create a new
611:23 - lecture and a new resource we need to
611:25 - link them together in order to have this
611:28 - B directional relationship okay so as we
611:31 - mentioned before like having B
611:33 - directional relationships make it a bit
611:36 - complex to maintain all the foreign Keys
611:38 - all right so let's go back restart the
611:41 - application and check the
611:44 - database so the application is starting
611:47 - right now let's open the database and
611:50 - see refresh
611:53 - it and let's see now from the resource
611:57 - we will see that we have one a new
611:59 - foreign key which is the lecture ID and
612:02 - it's referencing the lecture right right
612:05 - here so like this we just created a
612:08 - onetoone relationship between lecture
612:12 - and resources all right so that's it we
612:15 - just implemented all the relationships
612:18 - between all our entities and classes
612:21 - let's move on and I want to show you how
612:23 - you can check that what you created is
612:27 - the same as your class
612:29 - diagram now for the people having the
612:33 - the ultimate version of an and using
612:36 - this database to check the data and
612:38 - refresh the data and refresh the
612:40 - database and check the tables so there
612:43 - is one thing that we can do so here when
612:47 - you click on this database you can right
612:49 - click on it and here we have in the
612:52 - bottom you have diagrams okay and you
612:55 - can show a visualization or you can show
612:57 - it in a popup let's show show the first
613:00 - one and here it will generate all the
613:05 - tables of our database okay so you can
613:09 - also uh you can also click on this icon
613:12 - to apply the current layout and it will
613:14 - reorganize it and here we see that we
613:18 - have our
613:21 - author right here we have our author
613:24 - table let's just try to organize it a
613:27 - bit and we see right here within this
613:30 - diagram that we have the same one as we
613:34 - already did designed at the beginning of
613:36 - this of this course so we have the
613:38 - course and the author and here we have
613:41 - the the join table between these two one
613:44 - because we have a many to many we also
613:47 - have a relation between our course and
613:49 - section and the same between section and
613:52 - lecture and we see that we have this
613:54 - onetoone relationship between our
613:58 - lecture and resource all right so like
614:01 - this or this tool might help you
614:03 - checking if you have the correct
614:05 - implementation or if you did the correct
614:08 - implementation or not so just go ahead
614:10 - use it and you can also compare it with
614:13 - this diagram that we just created so
614:16 - just double checking we have author
614:18 - courses section lecture and resources
614:21 - and it's the same diagram that we have
614:24 - generated right here so this one it will
614:26 - use the database and all the
614:28 - relationships that we already defined to
614:31 - draw this schema so uh uh that's it
614:35 - about all the relationships now let's
614:37 - move on to a bit more deep and important
614:41 - uh stuff that we need to learn together
614:44 - if you have any questions don't hesitate
614:46 - to drop me a message send me an email or
614:49 - contact me on social media and also you
614:52 - can go and ask your question on Discord
614:56 - I will create a special channel for this
614:59 - course so just go ahead and ask it
615:02 - otherwise let's move on previously we
615:05 - said that we will leave this part right
615:07 - here where we have this resource video
615:10 - file and text entities to uh further
615:14 - part so now it's the time so here as we
615:17 - can see so this is the symbol of
615:20 - inheritance and we have this resource
615:23 - class we have also these three classes
615:27 - video file and text so this means what
615:30 - this means that a resource can be at the
615:33 - same time uh um can be whether a video
615:36 - file or a text so here we have video
615:39 - extends resource uh file also extends
615:43 - resource and same for the
615:46 - text so in Spring data jpa you can use
615:50 - inheritance to define a base class of
615:53 - your entities and then create a subass
615:56 - that inherit from the class or from the
615:59 - base class so this can be useful if you
616:03 - have a number of entities that have some
616:06 - common properties and you want to avoid
616:09 - uh duplication code or duplicating the
616:12 - code
616:13 - okay and when we talk about inheritance
616:16 - in Spring data jpa there are several
616:19 - ways to implement this inheritance so we
616:23 - have the single table strategy also we
616:26 - have the joint table strategy and table
616:29 - per class strategy so we will see all of
616:32 - these strategies in details
616:35 - but here we need to talk before we go
616:38 - and we before we leverage inheritance we
616:41 - need to talk about pros and cons for
616:43 - each one for for this inheritance so the
616:47 - pros or the advantages of uh inheritance
616:50 - is first of all code reuse so because
616:53 - inheritance allows you to reuse common
616:56 - code among multiple
616:59 - entities also simplified queries with
617:03 - inheritance you you can create queries
617:06 - that span multiple entities without
617:09 - having to write separate queries for
617:11 - each entity now let's talk about the
617:14 - cons or the disadvantages of
617:18 - inheritance so first of all is the
617:22 - complexity inheritance can make the
617:24 - database schema more complex especially
617:27 - if you are using a strategy like join
617:31 - table per class or table per concrete
617:33 - class also we can talk about rigidity
617:37 - because inheritance can make it more
617:40 - difficult to change the Bas class or
617:43 - other new sub classes because it can
617:46 - affect the entire inheritance hierarchy
617:49 - so this means every time you need to add
617:52 - a field or you need to add a new
617:54 - attribute within the Base Class you need
617:57 - to really be careful about the sub
618:00 - classes or the derivate classes that
618:03 - extends this Base Class so this is
618:06 - mainly the pros and cons of
618:10 - inheritance before we move on and start
618:13 - implementing The inher Inheritance
618:16 - strategies I want to highlight something
618:19 - which is really
618:20 - important which is composition over
618:24 - inheritance because both inheritance and
618:27 - composition H are ways to achieve code
618:31 - reuse and modularity in objectoriented
618:33 - program in in general it is recommended
618:37 - to favor composition over inheritance as
618:41 - composition is more flexible and easier
618:44 - to CH to change because inheritance
618:47 - evolves creating a sub class that is
618:50 - specialized version of a base class so
618:53 - the sub class inherits the properties
618:56 - and behaviors of the base class and can
618:59 - also have additional properties and
619:02 - behavior of its of its own this can be
619:05 - useful way to share code among multiple
619:09 - classes but it can also make the code
619:12 - more rigid and difficult to change if
619:15 - you need to make a change to the base
619:17 - class it can affect all the sub classes
619:20 - that inherit from it which can be
619:23 - difficult to
619:25 - manage composition evolves creating a
619:28 - class that has reference to one or more
619:32 - subjects and delegate tasks to these
619:35 - subjects this allows you to combine the
619:38 - functionality of multiple classes into a
619:41 - single class without the inheritance
619:43 - hierarchy of a base and
619:47 - subass composition is more flexible than
619:51 - inheritance because you can change the
619:54 - object that a class delegates without
619:57 - affecting the class itself so in summary
620:01 - it is generally recommended to use
620:04 - composition over inheritance because it
620:07 - is more flexible and easier to change
620:11 - however the best approach will depend on
620:13 - the specific needs of your application
620:17 - so this is the comparison between
620:21 - inheritance and composition and as I
620:24 - mentioned it's all it's always
620:26 - recommended or generally recommended to
620:28 - use compositions over inheritance okay
620:32 - now let's go and dive into these
620:35 - inheritance strategies in case you want
620:38 - or in case you need to use inheritance
620:41 - within your application so let me teach
620:43 - you how to use it in the correct
620:46 - way now imagine with me that that we
620:49 - want to add some auditing fields to our
620:53 - entities uh means I want to add some
620:55 - information to track uh the creation and
620:58 - the last modification of each entity or
621:01 - of each line uh of my tables in the
621:04 - database this means for for example this
621:08 - course entity or this course class I
621:10 - want to add four field uh like the
621:13 - created ad last modified ad and also
621:16 - created by and last Modified by same for
621:20 - author section lecture resource and all
621:24 - the tables that I will create within my
621:25 - database okay so in this case uh I will
621:30 - have four Fields including this ID we
621:33 - can five in each entity but this is okay
621:38 - from the database but now when we talk
621:40 - about the code our code I want to avoid
621:44 - this code application and I want to
621:47 - organize it much much better okay here
621:50 - we can use one technique to achieve this
621:54 - one and it's going to be something like
621:57 - that we will have a kind of Base entity
622:00 - or we can call it abstract entity or uh
622:04 - parent entity you can call it whatever
622:05 - you want and in here we will move or we
622:09 - will try to um to collect all the common
622:13 - fields between the entities we have or
622:16 - between the Java classes we have and for
622:19 - example we have this created at last
622:21 - modified at created by and last Modified
622:23 - by and I want all these fields to be
622:26 - part of all the entities I have within
622:29 - my
622:30 - database so for this it's super easy
622:33 - here we will use inheritance we will
622:36 - create a class we will call it base
622:38 - entity and all the classes I have right
622:40 - here they will extend this base entity
622:44 - okay and this base entity needs to be
622:47 - annotated with a special annotation and
622:51 - this annotation is called map super
622:54 - class so this annotation indicates that
622:57 - a class is a super class that is mapped
623:00 - to a database table and this annotation
623:04 - is used to define common
623:07 - properties uh that will be shared by
623:10 - multiple entities without creating a
623:12 - separate table for the super class this
623:15 - means the the only existing or existence
623:19 - of this base entity is within our code
623:23 - but from the database side we will not
623:26 - see any table called base entity so now
623:29 - let me show you how we can do
623:32 - this
623:35 - let's go back to our anj and here within
623:38 - this
623:40 - models uh package let's create this new
623:44 - class okay so let's create a class
623:48 - called it base entity or base class or
623:52 - base table call it whatever you want so
623:55 - this base entity first thing that I need
623:58 - to do is I need to give it a maid super
624:02 - class entity and as as you can see it's
624:04 - always from Jakarta persistence do mapet
624:08 - superclass so this means and this this
624:12 - will indicate that this class is a maid
624:15 - super class and any entity that will
624:19 - extend this one will inherit also all
624:23 - the fields that we have right here okay
624:26 - and for this I will create a private
624:29 - local
624:31 - daytime uh this one for example created
624:35 - ad I want to add a
624:42 - private so this one last modified
624:48 - ad and I want also to create two strings
624:52 - for example this this is this is just an
624:54 - example and you can create or you can
624:58 - move all the common fields that you want
625:00 - into this base entity so here I will
625:03 - will create a string created by so to
625:07 - track who created this entity I mean
625:10 - like the the user who created this
625:12 - entity and we have also last updated by
625:17 - or last Modified by
625:22 - okay all right so here within this maid
625:26 - user class we can use all the all the
625:30 - Jakarta all all the persistence um
625:33 - annotations like colon last Modified by
625:37 - last created by and so and so forth so
625:40 - it's a normal entity but it's just
625:43 - within our Java code base okay now also
625:47 - let's check right
625:49 - here for all the classes or for all the
625:52 - entities that we created right here we
625:54 - have this integer value uh this integer
625:58 - ID which represents the ID of our entity
626:03 - so also if you have always the same name
626:07 - for um for for all the entities what
626:11 - what we can do also we can also move
626:14 - this entity right here to this base
626:17 - entity right we can use this field right
626:21 - here so now we can see that we have this
626:23 - ID generated value and so on so forth I
626:26 - will also just go ahead add some lbook
626:29 - annotations to generate the Getters and
626:31 - Setters and so and so forth all right
626:34 - so I will just copy this one and I will
626:37 - give you a small hint which is super
626:41 - important uh here when we work uh with
626:44 - lombok so here we see we have all the
626:47 - Getters and Setters but here within this
626:50 - one this is going to be the parent
626:52 - entity and we want to use a builder when
626:55 - we use a builder within uh dant class or
626:59 - the the child class we will not be able
627:02 - to access this Fields right here and to
627:06 - do so uh lombok they created uh an
627:10 - annotation called super Builder from the
627:13 - for now it's from the package lombok do
627:16 - experimental and might be moved uh later
627:19 - on but The annotation is called super
627:21 - Builder all right so here what we need
627:25 - to do first is use this super Builder
627:29 - with all the entities that we will that
627:31 - will extend this base entity or in any
627:35 - case if you have inheritance between
627:37 - your classes and you want to use this
627:39 - Builder annotation just go ahead and use
627:42 - this superb Builder instead all right so
627:45 - now let's go back to this author uh this
627:47 - author entity and we see right here this
627:50 - one is in red because we don't have the
627:53 - primary key but once we
627:56 - extend our base entity this error will
628:00 - move on okay so this this is now is this
628:03 - is now gone all right and also when we
628:06 - use inheritance and we use this data
628:08 - annotation we we need also to add the
628:11 - equals and hash code annotation all
628:13 - right and here it needs to call the
628:16 - super so these are some hints for you
628:19 - when you want to use correctly all the
628:23 - annotations from lombok and also from uh
628:26 - from the pist from the jpa or Java
628:29 - persistence API also go ahead and check
628:32 - my C about lbook and the useful
628:35 - annotations that you can use and also
628:37 - how they work all right let's move on
628:40 - right now I will also make these changes
628:44 - to all the entities we have right here
628:47 - and when we restart the application we
628:49 - want to make sure that we have
628:51 - everything as we had before plus I want
628:55 - to see these four Fields right here okay
628:58 - so I will go ahead and do it for all of
629:01 - them so what we need to do or the way we
629:04 - need to implement this so let's first
629:07 - replace this Builder with super super
629:10 - Builder and let's extend the base entity
629:16 - next we need to remove this ID field
629:20 - with this with the
629:21 - annotations and that's it so this is how
629:24 - we can extend or this is how we can
629:26 - inherit from this base entity and keep
629:29 - everything working fine also don't
629:31 - forget to add the equals and hash code
629:34 - annotation let's do the same for
629:38 - lecture and so this one ex
629:42 - stands base entity let's move this ID
629:47 - field you can skip this one like for the
629:49 - rest of the entities if you are familiar
629:51 - with that and here and I will also
629:56 - do add think equals and hash code all
630:00 - right so next one is resource same thing
630:04 - here let's also extend our base entity
630:10 - right here and remove this ID
630:13 - field next one is
630:16 - section and then we will restart the
630:19 - application and see the changes so let
630:21 - me remove
630:22 - this and extend the base entity all
630:28 - right replacing also the Builder with
630:30 - the super Builder and here we also need
630:32 - to add the equals and hash code and then
630:35 - you can optimize the Imports to have
630:38 - your code as clean as possible all right
630:40 - so here what we have or this is what we
630:42 - have right now let's go first and check
630:46 - the database make sure that we have
630:48 - everything as before before restarting
630:50 - the application let's make sure that we
630:53 - have the same structure and the same
630:55 - tables that we have right here
630:58 - okay so now go ahead start the
631:00 - application because I stopped the
631:02 - application that's why we don't have any
631:03 - tables right now because we have the
631:06 - property create drop but let's start the
631:09 - application
631:11 - first so everything is started and we
631:14 - have all the all the entities but we
631:17 - don't see that we have a base entity
631:19 - getting created and this is what we
631:21 - expect now I will refresh the schema
631:24 - right here and we see that we have this
631:27 - six tables all right author and this is
631:29 - the The Joint table and if I open this
631:33 - author I see now I have nine columns
631:36 - including this created ad created by and
631:38 - last modified
631:40 - also I still have the same ID and this
631:45 - ID is inherited from this base entity so
631:49 - this is how you can uh group The Common
631:53 - uh the common fields within one entity
631:56 - and this can make your your code uh a
631:59 - bit cleaner and you can group and if you
632:02 - want for example to change the type from
632:05 - local date time to for example just uh
632:08 - java.sql
632:09 - .d here instead of this local date time
632:12 - you can do this change only in one place
632:15 - instead of doing this change in all the
632:18 - places also for example if you want to
632:21 - link this created by and last Modified
632:23 - by to the real user table in the
632:26 - database you can just update and modify
632:28 - in one place so this is how the the maid
632:32 - super for class
632:35 - works and as I mentioned uh like finally
632:39 - before we end this part using the maid
632:41 - super class annotation can help you
632:44 - avoid duplication of code and make it
632:46 - easier to maintain common properties in
632:49 - large applications however keep in mind
632:53 - that the maet super class does not have
632:56 - its own table so do not forget this one
632:59 - and if you want to use a mapet super
633:01 - class entity so do not expect to have a
633:04 - separate or its own table and it cannot
633:08 - be queried or persisted directly so we
633:11 - cannot query this base entity and we
633:13 - also cannot persist this base entity it
633:17 - can only be used and a base class as a
633:20 - base class for for entities all right so
633:23 - if you have any questions don't forget
633:26 - to drop me a message otherwise let's
633:28 - move
633:31 - on now let's talk about inheritance
633:34 - within this part of our class diagram
633:38 - all right so we have here just a
633:40 - reminder we have our resource video file
633:43 - and text okay so let's first prepare and
633:47 - create these three classes right here I
633:49 - will create class called video file and
633:52 - text and then let's explain and see how
633:57 - we can implement the difference the
633:59 - different uh inheritance strategies okay
634:02 - so let's go back to our
634:04 - inj and here again with this models uh
634:08 - with this models package I will create
634:10 - three uh three classes but first I want
634:13 - to go and open this resources and I will
634:17 - just roll back all these changes I mean
634:20 - I will um I want to use this integer
634:23 - right here why because we cannot extend
634:26 - multiple entities or multiple classes uh
634:30 - using Java all right so this is the only
634:33 - and unique uh reason for that so because
634:37 - our Focus right now is the inheritance
634:40 - uh regarding this resource otherwise I
634:43 - will I can also show you how how we can
634:45 - do or how we can uh Implement multiple
634:49 - inheritance all right okay so uh this is
634:52 - what we have right here and now I will
634:54 - just go ahead and create my first
634:58 - class I will call it video and this
635:02 - video VI it will have also the same uh
635:06 - without the entity I will just copy
635:10 - this the these annotations the lombok
635:12 - annotations but here instead as I
635:15 - mentioned before it will be or it should
635:17 - be super Builder and for this video I
635:21 - will have uh right here a private int
635:27 - length so it's just the length of the
635:29 - video I will
635:31 - create
635:33 - another class like we have right here we
635:36 - have file and text
635:38 - okay now I will
635:40 - create a file class so this file it also
635:45 - will have the same annotations and here
635:48 - I will use the super Builder
635:50 - instead do not forget also to update uh
635:54 - or improve the Imports and here I will
635:57 - have just private private string type so
636:01 - the type is just to say say if it's um
636:04 - for example PDF txt word and so on and
636:07 - so forth all right let's create now the
636:09 - third class which is
636:14 - text also do not forget to paste the The
636:18 - lombo annotation and change this one to
636:20 - a super Builder and within the text we
636:23 - have our private content
636:28 - attribute private
636:30 - string content and that's it now we have
636:34 - the three files or the three classes
636:37 - that we have video file and text and now
636:40 - we can go back and start explaining and
636:43 - implementing the different inheritance
636:46 - strategies using spring data
636:50 - jpa let's first see the single table
636:54 - strategy so this strategy is a way to
636:57 - map an inheritance uh hierarchy to
637:00 - entities to a single database t table
637:03 - this strategy is used in hibernate or uh
637:07 - spring data GPA or mainly when we talk
637:09 - about the Java persistence API so jpa to
637:14 - Define how inheritance is implemented in
637:16 - the
637:18 - database with the single table strategy
637:21 - all subclasses of the inheritance um of
637:25 - The inh Inheritance hierarchy are mapped
637:27 - to the same table and then we talk we or
637:31 - we need to talk about a discriminator
637:33 - colum is used or we need to use it to
637:37 - distinguish between the different sub
637:39 - classes so the discriminator column
637:43 - contains a value that indicates which
637:46 - subass uh a particular Row in the table
637:49 - belongs
637:53 - to and within when the single table
637:57 - strategy is used all of the properties
638:00 - of the of the parent entity class and
638:03 - its sub
638:06 - classes will will be persisted to a
638:09 - single table the discriminator column is
638:12 - used to determine which subass a
638:15 - particular row belongs to now the single
638:18 - table strategy is the simplest way to
638:21 - implement inheritance in the database
638:24 - but it can lead to an efficient queries
638:28 - and a large table size it is best suited
638:31 - for situations where the number of
638:34 - subclasses is small and The Inheritance
638:37 - hierarchy is not deep so this is
638:41 - theoretically uh how single table
638:44 - inheritance works now let's try to
638:46 - implement this first of all to implement
638:49 - the single table single table strategy
638:53 - so we go first of all to the parent
638:56 - class or the base entity or whatever you
638:59 - can call it whatever and in our case
639:01 - this is uh uh this is our base entity or
639:04 - the parent class but first of all here
639:07 - this one needs to be super Builder
639:09 - because if in case you need it later on
639:12 - and now here we need two things we still
639:15 - have this entity annotation which we
639:17 - need and we need also to add this
639:21 - inheritance annotation and and it's the
639:23 - one from always Jakarta persistence all
639:26 - right and within this inheritance uh
639:29 - annotation we can Define we can Define
639:32 - the strategy and here we can see that we
639:37 - have joined single table and table per
639:39 - class all right but as you can see right
639:43 - here by default it's using single table
639:46 - so whether you precise single table or
639:48 - not it will be by default single table
639:52 - okay so you can just use inheritance
639:54 - annotation without the strategy so it
639:57 - will take as a default value the single
640:00 - table all right so this is the first
640:02 - first step now let's go to this video
640:06 - files and file and text and in here
640:10 - optimize the import first let's collap
640:12 - this one and now within this uh this
640:16 - video I will just add the entity
640:20 - annotation
640:21 - okay so the same and here from this
640:25 - video we need to
640:28 - extend our resource because a video is
640:31 - also a resource right and don't forget
640:34 - with this data annotation from lombok
640:37 - when we use inheritance or we extend
640:39 - another class we need also to implement
640:41 - the equals and hash code with the
640:44 - attribute or the property called super
640:46 - equals true this is just a reminder for
640:48 - you let's go ahead and do the same for
640:52 - file so here we need the entity
640:56 - annotation and now we need also to
640:59 - extend our resource entity
641:03 - and then we need to add the equals and
641:06 - hash code annotation let's do the same
641:09 - for
641:10 - text
641:12 - entity let's extend resource right
641:18 - here and finally we add the equals and
641:22 - hash code annotation all right so here
641:25 - we have everything up and ready for us
641:29 - okay now let's restart the application
641:32 - and see what will happen with only this
641:35 - configuration that we wrote right here
641:38 - so click on
641:40 - restart so now the application is up and
641:44 - running and we see that we have no
641:46 - exceptions so everything is good so far
641:51 - let's move this one and here let's go
641:54 - back to our database click here and
641:57 - update or refresh the database so we
642:00 - have the inheritance within the resource
642:02 - Source uh column and we see now that we
642:05 - have nine columns within this class okay
642:10 - so we see here that we have uh ID name
642:14 - and so and so forth but we see here that
642:17 - we have the extra and we see here that
642:20 - we have the size this one the this is
642:22 - the one coming from uh from the from the
642:27 - file or from the video we have also the
642:29 - type we have the content and so so and
642:32 - so forth we have also the length and
642:35 - what happened right here with this basic
642:37 - configuration so hibernate he grouped
642:41 - all the he grouped all the fields within
642:45 - the B the parent uh the parent entity so
642:48 - everything now is within this resource
642:52 - and if we want for example to create a
642:54 - content and so on and so forth if we
642:56 - want to create a new instance of type
642:58 - text we need to fill all the information
643:01 - including other information from the
643:02 - resource including the content okay now
643:07 - let's try
643:09 - to to give some more differentiation
643:13 - between the entities all right so let's
643:16 - see what we can do as extra
643:18 - configuration to make this more clean
643:21 - and More Beautiful to use all right so
643:24 - now let's talk about this discriminator
643:27 - value this discriminator value will give
643:30 - a value that we will SP specify in
643:32 - advance to each type or to each derived
643:36 - class so for example if we give uh the
643:39 - value V for video F for file and T for
643:42 - text we will add uh a column called type
643:46 - right here to the
643:48 - resources and then this resource type
643:51 - every time you create a new instance of
643:53 - video this type will be automatically v
643:56 - f for file and T for text all right so
643:59 - let me show you how we can do that so so
644:02 - here we have our inherit inheritance
644:05 - strategy which is single table now we
644:08 - need to add an another annotation which
644:11 - is discriminator colum and this one it's
644:15 - just to give the discriminator colum
644:17 - name and here for this name by default
644:21 - it's D type if we do not if we do not
644:24 - precise this colum by default it will be
644:27 - D type like we have right here okay so
644:29 - it's the discriminator type
644:32 - but let's give it uh a special name
644:36 - let's call it resource
644:39 - type all right so from the parent uh
644:44 - class or the parent entity we need to
644:46 - add this discriminator column to specify
644:49 - the column that we want to use otherwise
644:51 - you can leave it to the default one
644:53 - which is D type all right now let's go
644:56 - to the different uh different entities
644:59 - now after this entity annotation
645:02 - just go ahead and add a discriminator
645:05 - value so this discriminator value let's
645:09 - for example as we mentioned before let's
645:12 - give it V for video I would just copy
645:16 - this annotation and paste it in
645:19 - different entities f for file and T for
645:24 - text so now if we restart the
645:27 - application we will see that instead of
645:29 - this dtype column we will have our
645:33 - resource type column right here so I
645:36 - will restart the
645:37 - application and here the application is
645:40 - restarted let's open the database and
645:42 - refresh it again so refresh this
645:45 - resource table or all the data uh all
645:48 - the database So within this resource we
645:50 - see that we still have nine column and
645:52 - now our column is called resource type
645:56 - all right and we have this name size and
645:58 - so on so forth those are the attributes
646:01 - that we have from all the children
646:04 - classes all
646:05 - right now if we create a new instance or
646:09 - if we want to persist a new
646:12 - file we will create all uh we will
646:15 - insert all the data including uh for
646:18 - example for the file right here we have
646:21 - the type we will say for example PDF
646:24 - right here and all the information and
646:26 - automatically this resource type will be
646:29 - V so the value of this resource type it
646:32 - will be automatically uh F sorry not V
646:35 - because F is for file so it will be f
646:38 - for file and it will be V for video and
646:41 - so and so forth so you don't need to
646:44 - worry about um to you don't need to
646:47 - worry about filling this resource type
646:50 - because every time you create an
646:51 - instance of the children or the child
646:54 - class it will be automatically filled
646:57 - using this discriminator value all right
646:59 - so this is how it works and in the next
647:03 - step I will show it to you in action I
647:06 - will um we will insert uh for example a
647:10 - new file or a new video into the
647:13 - database and we will see what will
647:15 - happen let's see now in action how we
647:18 - can uh how this is going to look like
647:21 - all right so I will close everything
647:23 - right
647:25 - here and in this repositories package I
647:29 - will create um a sample reposit for this
647:32 - uh entity called video because I we want
647:35 - to check only one of them so here I will
647:38 - create a new class I call it video
647:42 - repository so for you in case you want
647:45 - to use uh inheritance you need to create
647:48 - of course one repository per per entity
647:51 - okay and uh here let's extend jpa
647:58 - repository and let's give it the type
648:00 - video
648:03 - and of course integer for the ID so this
648:07 - is our repository right here it's ready
648:09 - to use now let's open our main uh class
648:14 - or M our jpa application class where we
648:16 - have the spring application
648:19 - repository and I will inject right here
648:22 - our video
648:25 - repository I will call it video
648:28 - repository okay and I will bring back
648:31 - this ban annotation okay so uh this is
648:35 - going to save this author but I will
648:38 - just comment this out because I don't
648:40 - want to insert any other
648:44 - lines so uh now let's use this video
648:48 - repository to insert one data so I will
648:51 - have here our video equals video.
648:56 - builder.
648:57 - build so for this video I will just
649:00 - precise or give some information like um
649:04 - the name for example uh
649:09 - abc dot um
649:12 - length let's check our video right here
649:15 - we have the length and let's say for
649:18 - example it's 6 minutes or 5 minutes it's
649:22 - also okay and let's give it another uh
649:25 - another information which
649:28 - is the I I guess that's it okay so let's
649:32 - give it just the name and the length and
649:34 - here let's use our video
649:39 - repository dot save this video
649:44 - entity okay and now all we need to do is
649:48 - restart the application and see what
649:51 - will be inserted in the video or in the
649:54 - resource table into our database let's
649:56 - restart now so the application is
649:59 - restarted and we see also that that we
650:02 - inserted something into uh the into the
650:05 - resource table and here we see that we
650:07 - have this resource type but we did not
650:10 - precise it just to remind you here we
650:13 - don't have we have only the name and the
650:15 - length Okay let's check this resource
650:18 - table right here I'm going to
650:20 - refresh the database or the table and
650:23 - then double click it to show the
650:26 - content so we see the content right here
650:32 - that we
650:33 - have first of all we have V for the
650:36 - resource type and this is something that
650:37 - we did not precise we have the ID name
650:41 - we have the size which is zero because
650:43 - it's an INT that's why it's zero because
650:45 - int by default equals zero and we have
650:48 - the URL type and so on and so forth also
650:51 - we have the length that we precised so
650:54 - we have the name
650:55 - ABC and the length equals 5 and the
650:59 - resource type is V so if we do this the
651:01 - same for file and text it will be f for
651:04 - file and T for text so this is how
651:08 - single table strategy using
651:10 - discriminator column and discriminator
651:13 - value this is how it works so if you
651:16 - have any question just go ahead drop me
651:19 - a message otherwise let's move on and
651:21 - check the next
651:23 - strategy now let's comment first of all
651:26 - uh this being annotation close this
651:29 - class and now we will talk about about
651:31 - the next strategy which is joined table
651:36 - this
651:37 - strategy each subass in The Inheritance
651:41 - hierarchy is mapped to a separate table
651:44 - with a foreign key pointing to the base
651:47 - table this allows each subass to has uh
651:51 - to have its own table with only the
651:54 - properties that are specified to that
651:57 - subass okay so when the joint strategy
652:00 - is used used each sub class will use or
652:04 - will have its own table with a foreign
652:06 - key pointing to the base table this
652:08 - allows each subass to have only the
652:11 - properties that are specific to that
652:14 - subass which can lead to more efficient
652:17 - queries however it also requires M more
652:21 - tables and foreign Keys which can make
652:24 - the database schema more
652:27 - complex The Joint strategy is a good
652:30 - choice where when you have a large
652:32 - number of sub classes with significant
652:35 - differences in their properties and you
652:38 - want to optimize the performance of your
652:41 - queries however it's not suitable for
652:44 - situations where you need to query the
652:46 - entire inheritance hierarchy at once as
652:50 - as it requires multiple joints to
652:53 - retrieve the data so these are let's say
652:56 - the pros and cons of this strategy now
652:59 - let's see how we can implement
653:02 - this so let's go back here to our
653:06 - resource let's collapse this one and
653:09 - let's go back to our resource entity so
653:12 - now instead of this inheritance first we
653:16 - need to command out this one because we
653:18 - don't need this discriminator column
653:20 - anymore and now for the strategy instead
653:23 - of single table we will use the joined
653:26 - one all right so this is the only
653:29 - required change from the base entity so
653:33 - we have this entity and again The
653:35 - Inheritance with the joined strategy and
653:39 - no discriminator colum is needed so this
653:43 - one I will just type it right
653:46 - here only with single
653:50 - table all right so you don't mix when
653:53 - you when you directly check the code you
653:55 - don't mix with this annotation right
653:57 - here all right so now let's go to the
654:01 - sub classes let's start with this video
654:04 - right here for example and now for this
654:07 - video we don't need these discriminator
654:10 - values so let's go ahead and remove them
654:13 - all because now as we mentioned we will
654:16 - have uh a table per subass okay so
654:21 - that's it this is how the joint table
654:24 - works let's restart the application and
654:26 - check what will
654:28 - happen so now the application is up and
654:31 - running let's open our database and
654:34 - refresh it so refresh it right here so
654:37 - we see now that we have this file we
654:40 - have this text and we have this video
654:43 - table so let's check the columns here we
654:46 - have this content and the ID also we
654:50 - have one foreign key which is this ID
654:54 - which is pointing to the resource all
654:56 - right so this text table contains only
654:59 - this content which is is the attribute
655:02 - that we specified right here let me make
655:06 - it uh in both sides so we have only this
655:10 - content right here and we have this ID
655:13 - which represents the primary and the
655:15 - foreign key at the same time because we
655:17 - see right here that we have these two
655:20 - icons the blue one and the golden
655:23 - one so they point to the same uh to the
655:28 - same thing so it's primary and a foreign
655:30 - key at the same time and we will see the
655:33 - same thing if we open this video right
655:36 - here so we have also the length and
655:39 - ID and now let's try to insert some data
655:45 - we have already something in here within
655:47 - our jpa
655:51 - application let's bring this Bean back
655:55 - let's restart the application and check
655:57 - what will
655:59 - happen so so now the application
656:02 - restarted and we see here that we have
656:06 - uh two insertions instead we just have
656:09 - we just created a query or we just
656:12 - inserted one element into our video
656:16 - table all right so here what we have we
656:18 - have this video. Builder and we have we
656:21 - precise the information of the video but
656:24 - we see right here that we are inserting
656:26 - into resource and we are also inserting
656:29 - into video so let me show you how this
656:32 - is represented as data in the database
656:35 - so first of all I will open the resource
656:37 - let me make this one full screen so here
656:40 - we see that we have the ID we have the
656:43 - name which is ABC the one that we
656:45 - specified and we have
656:47 - this default values for the rest of them
656:50 - if I open the video right here I see
656:53 - that I have this ID column which is as I
656:55 - mentioned which is the primary and the
656:58 - foreign key at the same time and we have
657:00 - the length that we specified so
657:03 - automatically hibernate inserted two
657:06 - elements or two lines into uh two
657:09 - different tables because we have our
657:12 - strategy as joined okay now let me uh
657:17 - show you something you might also want
657:20 - to do in case for example you want to
657:23 - give a special or a custom name for this
657:27 - ID column which represents the foreign
657:30 - key
657:31 - we can use an annotation for that all
657:34 - right so let me make it full screen I
657:36 - will keep the Bean for now and I will
657:38 - just commented out once we are finished
657:41 - with this uh join table strategy all
657:44 - right so within this uh entity or within
657:47 - this entity called video which is a
657:50 - subass here we can use an annotation
657:53 - called
657:55 - primary join column okay so this primary
657:58 - join column we can give it the attribute
658:02 - name and here I will call it um for
658:06 - example video
658:08 - ID all right so now when I insert or I
658:12 - restart the application and we will
658:14 - insert some data we will see that this
658:17 - ID right
658:20 - here this column right here ID it will
658:24 - now be rename to video ID let's restart
658:28 - this so first of all we can see it
658:31 - already in the insertion query so when
658:34 - we insert into video we have length and
658:37 - video ID also if you scroll a bit up and
658:40 - you check the codes of creating the the
658:43 - table video we have length and we have
658:46 - video ID instead of ID so by default it
658:49 - will use the ID name or the ID name
658:52 - field of the parent class so in this
658:55 - case it will use this one but if we want
658:58 - to customize it and have our own name
659:02 - for each entity we can also use this
659:04 - primary key join column so let's open
659:07 - this video and we see right here it's
659:10 - now called video ID all right so uh
659:14 - that's it so this is how join table
659:17 - works again before we finish let's go
659:20 - back to our jpa application and let's
659:23 - command this out and in case we need it
659:25 - we will bring it back again all right so
659:28 - if you have any questions don't hesitate
659:30 - to drop message write me an email
659:32 - contact me on social
659:34 - media otherwise let's move
659:37 - on now let's see the table per class
659:41 - strategy so the table per class
659:44 - strategy uh each Concrete subclass in
659:49 - The Inheritance
659:51 - hierarchy is mapped to a separate table
659:54 - abstract super class are not mapped to a
659:57 - table and their properties are inherited
660:00 - by by their con concrete sub classes so
660:03 - you may ask the question what is the
660:05 - difference between this joined table or
660:09 - uh and also
660:11 - the you might ask the question what is
660:13 - the difference between the the strategy
660:16 - joined and the strategy table per class
660:19 - so it's super easy let's check now we
660:22 - still have the joined table right here
660:25 - so here we have the resource that
660:27 - contains The Columns of the base entity
660:30 - or the parent entity which is name size
660:32 - URL and so on so forth and each sub
660:37 - class contains only its own uh its own
660:40 - attributes with the ID imp plus all
660:43 - right now when we talk about uh table
660:46 - per class this means that we will have a
660:49 - table with a table video for example
660:52 - with all the attributes from the
660:54 - resource table joined into this text
660:58 - table all right so this is the main
661:00 - difference this means that we will
661:02 - create a table for each sub
661:05 - class so when the table per subass
661:09 - strategy is used each concrete subass
661:12 - will have its own table with a copy of
661:14 - all the properties inherited from the
661:18 - base class this allows each subass to
661:21 - have only the properties that are
661:24 - specific to that subass which can lead
661:28 - to the most efficient queries however it
661:31 - also requires the most tables and can
661:34 - make the database schema more complex so
661:37 - in case you have multiple inheritance or
661:40 - many sub classes so your schema might be
661:44 - uh a bit complex than the normal so the
661:47 - table per class strategy is a good
661:49 - choice when you have a small number of
661:52 - sub classes with significant differences
661:55 - in their properties and do you want and
661:59 - you want to optimize the performance of
662:02 - your queries however it's not suitable
662:05 - for situations where you need to query
662:08 - the entire inheritance hierarchy at once
662:11 - as it requires multiple tables to
662:14 - retrieve the data now let's see this in
662:18 - action let's see how we can implement
662:20 - this table per class strategy so the
662:23 - implementation is super easy there is
662:26 - not uh there is not a lot of things that
662:29 - we need to change so first of all let's
662:31 - go back to our basee entity and here
662:34 - instead of inheritance
662:37 - joined let's use table per class all
662:41 - right so this is the first change and I
662:43 - will just go back to the video right
662:46 - here and comment out this primary key
662:49 - join annotation because it works with
662:53 - the joint uh
662:55 - strategy so that's it all we need to do
662:58 - to mention here that we want to to use a
663:00 - table per class now let's see the impact
663:03 - when we start the application and then
663:06 - we will see or let's also comment or
663:09 - bring back this spin annotation and
663:11 - let's see what will happen when we
663:13 - insert a new video within our database
663:16 - so let's see the the schema changes and
663:19 - also the impact when we insert data so
663:22 - first of all we see here that we have
663:24 - only one insert which is inserting into
663:27 - video and we have the lecture name size
663:30 - and so and so forth now let's see how
663:32 - this is represented in the database so
663:36 - now I will go back here and click on
663:39 - refresh and we see right here that we
663:42 - have this for for example this
663:44 - video
663:46 - um this video table right here we have
663:50 - our uh we have our all the attributes
663:53 - and we have the size and so on and so
663:55 - forth so we have all the attributes from
663:57 - this resource table and we also have the
664:01 - attributes from the video all right so
664:04 - if I open this video we see right here
664:06 - that we have the ID name size and so and
664:09 - so forth so we have all the information
664:12 - joined into one table per subass and if
664:15 - we check also for example file or text
664:18 - we will find the same thing so here we
664:20 - have six columns and this is the content
664:23 - or the attribute that we have from the
664:25 - text all right so um now this is how
664:31 - inheritance
664:33 - works with hibernate let's go ahead and
664:37 - check uh few issues that we might face
664:41 - when using inheritance and how to solve
664:44 - them when we work with
664:46 - inheritance we can also query the base
664:50 - entity so we can Define the strategy
664:52 - that suits
664:53 - us and we can also or we want for
664:57 - example to retrieve all the res sources
665:00 - of our database okay it's like uh select
665:04 - star from resource and that's it or like
665:07 - using the find all methods all right but
665:10 - we have one issue is when we query this
665:13 - resource table we won't for example just
665:16 - to get all the informations or just the
665:19 - attributes of this resource entity and
665:22 - we don't want to get any information
665:24 - about file text video and so and so
665:27 - forth I just want the resources not this
665:30 - sub classes of that so this is with this
665:33 - one like in the
665:36 - background so in the background when
665:38 - creating the base class which will
665:41 - return all the sub class records as well
665:44 - by using a union statement in the
665:47 - background and the use of Union can also
665:51 - lead to inferior performance when
665:53 - choosing this strategy another issue is
665:57 - that we can no longer use identity key
666:00 - Generation all right so when we use this
666:04 - kind this type of inheritance we might
666:07 - face the issue of polymorphic queries so
666:11 - as mentioned querying a database class
666:14 - will retrieve all the sub classes uh
666:17 - entities as well now if we don't want uh
666:21 - a subass to be returned by the type of
666:24 - the query we only need to add the a
666:27 - hibernate annotation to to say or like
666:31 - to uh exclude it from the definition so
666:34 - for
666:35 - example if I want to exclude this video
666:40 - right here if I want to exclude this
666:42 - video entity when I want to query the
666:45 - resources I need to add one onot one
666:48 - annotation to exclude it from the parent
666:52 - when I query the parent all right so
666:54 - this annotation is called
666:58 - polymorphism and and here I need to give
667:01 - it a
667:03 - type so polymorphism and the type right
667:07 - here it's polymorphism type. explicit
667:10 - because by default it's implicit means
667:13 - when I query the resource. Java it will
667:16 - automatically query all the sub classes
667:19 - from that one but if I say I want it to
667:22 - be explicit this means that it will
667:25 - query this video only when it's required
667:29 - or only when I ask for it otherwise it
667:32 - will not uh it will not create okay so
667:35 - this is how we can solve the polymorphic
667:39 - queries issues so just go ahead use this
667:43 - annotation and exclude all the sub
667:45 - classes that you don't want to create
667:47 - okay so if you have any
667:50 - questions don't forget to drop me a
667:52 - message otherwise let's move on in this
667:56 - chapter I want to teach you how to work
667:58 - with embedded IDs or embedded entities
668:02 - generally speaking all right first of
668:04 - all let's define what is an in embedded
668:08 - IDs or embedded entities okay so in
668:14 - software we come across many use cases
668:17 - when we need to have a composite primary
668:20 - key to Define an entry in a table a
668:24 - composite primary keys are that use more
668:27 - than one column to identify a row in the
668:30 - table
668:31 - uniquely So within one table we can
668:33 - Define more than one column to be the
668:37 - unique identifier of that column okay so
668:40 - we represent a composite primary key in
668:43 - Spring data jpa by using The embeddable
668:47 - annotation on the class level this key
668:51 - is then embedded in the table
668:53 - corresponding uh entity class as the
668:56 - composite primary key using the embedded
668:59 - ID annotation we will see all that in
669:02 - details but first let me give you a use
669:06 - case for that so here like I have this
669:09 - other table other table one other table
669:11 - two it's just an example to tell you
669:14 - that this is an independent database so
669:17 - now let's take the case or the use case
669:19 - of a microservice and now we will talk
669:22 - about the order microservice all right
669:26 - and here we have for example this order
669:29 - table so this is just uh an illustration
669:32 - example it's not a real life example
669:34 - just for illustration and here let's go
669:37 - back and we take this order table we
669:40 - have right here and we don't want to
669:43 - rely on generated IDs okay I don't want
669:47 - to create a generated ID which is auto
669:50 - incremented to be my unique uh my unique
669:54 - ID of of this table but I want to have
669:58 - my own ID I want want to create my own
670:00 - ID but this ID I want it to be composed
670:05 - why I want it to be composed it's not
670:07 - just a want but it's a need why because
670:11 - in real life one user can order or can
670:16 - um pass or validate many orders in one
670:20 - in um at the same time or in one day for
670:23 - example okay so uh in this table right
670:27 - here we can find the same username
670:30 - multiple times so this means that we
670:32 - cannot rely only on the username okay so
670:37 - we have also we have here Order date and
670:40 - the order date itself we cannot just
670:43 - rely on this order date because at the
670:46 - same time even at the same milliseconds
670:49 - we can find more than one user ordering
670:53 - uh something all right but when we talk
670:57 - about the
670:58 - composition when when we talk about
671:00 - username and Order both of them this is
671:03 - unique so both of this username the
671:07 - combination of the username and the
671:09 - order date it's Unique this means like
671:12 - the unique
671:13 - identifier of one order will be the
671:16 - username for example alibu as a username
671:20 - and the order date let's say the 0101
671:25 - 2023 uh at uh for example let's say
671:28 - midnight okay okay so at this time only
671:31 - we have only one user this alibu user
671:35 - he's the only one passing this entity uh
671:39 - this order sorry not entity but the
671:41 - order but we can also find another
671:44 - combination at the same order time but
671:47 - within another username so like the
671:51 - combination of username and Order date
671:53 - is something unique and we can rely on
671:56 - so this is the use case or one of the
671:59 - use cases when we need to use embedded
672:03 - IDs all right so now let me show you an
672:07 - action let me show you in real life how
672:09 - we can create embedded IDs and how we
672:12 - can use them within our entities in
672:16 - order to demonstrate that let's first
672:18 - create and prepare the ground for that
672:21 - so to use embedded uh entities and using
672:25 - the embedded IDs what I will do I will
672:27 - create a sub Pro sub uh package within
672:30 - this models package and there I will put
672:34 - all the all the entities and all the
672:36 - resources related to this embedded ID
672:40 - example so right click right here on the
672:43 - models and then I will create a new Java
672:46 - class I will call it order
672:50 - ID and this order ID I will created um
672:54 - within the package embedded
672:58 - Okay so so I will just call a pack
673:01 - create a package called embedded and
673:03 - within this package I will create my
673:05 - class called order ID hit enter and now
673:08 - we have our package and also we have our
673:12 - our entity so now in order to to create
673:17 - an embedded ID so first of all you need
673:19 - to define the IDS or the attributes that
673:22 - you want to rely on to use that as an ID
673:27 - and uh as our case demonstrat so we want
673:30 - to have something uh composed of uh
673:34 - username and date on and or we can call
673:37 - it order date so I will first of all
673:40 - create a string
673:42 - username and here I'm just assuming uh
673:46 - that the username is something unique so
673:48 - we don't have two users with the same
673:51 - username then let's create a private
673:54 - local
673:57 - datetime let's go call it order
674:01 - date so this is the username or this is
674:05 - the entity well actually it's an entity
674:08 - but it's not a persistent entity it's
674:10 - something like the map super class the
674:13 - one the example we saw before but it's
674:16 - not a persistent entity it's just a
674:18 - composition where we can compose
674:21 - multiple uh attributes and we can use
674:24 - them as as an embedded ID so first of
674:27 - all we need some
674:30 - annotations I will use the data from
674:33 - lombok all arcs
674:35 - Constructor the no args
674:38 - Constructor and here I will use one
674:42 - annotation which will make this one an
674:45 - embedded embedded entity
674:48 - so here The annotation is called
674:51 - embeddable and this embeddable comes
674:53 - from Jakarta do persistence because we
674:56 - are using spring 3 this is just a
674:59 - reminder so let's use this embeddable
675:03 - annotation using this embeddable
675:05 - annotation we'll tell hibernate and
675:08 - spring data generally speaking that this
675:11 - is an embedded entity now how to use it
675:14 - I will show you just right away so
675:17 - within this embedded package I will
675:20 - create my order class or order entity
675:23 - okay so I will call it
675:27 - order and here here I will just copy
675:30 - this
675:34 - information so these are the annotations
675:36 - that I will need and of course my class
675:39 - is an entity so we need the entity
675:42 - annotation and first of all I will
675:46 - create a
675:50 - string um let's call it order INF for
675:54 - example and a
675:57 - private string
676:00 - another field because our focus is not
676:03 - about the fields but it's just uh to say
676:06 - that we have few information or few
676:08 - Fields within the order entity so now we
676:12 - see the same error that we know here
676:15 - when we create or we map um a class or
676:19 - Java class with the entity annotation so
676:21 - it will claim about an
676:24 - ID so here it says that this persistent
676:27 - entity order should have have a primary
676:29 - key and here it it's asking to add an
676:33 - attribute or an ID attribute for us as
676:36 - we mentioned before we don't want to use
676:39 - an autogenerated or an autoincrement ID
676:43 - but instead we want to use this order ID
676:46 - class we just created so first of all I
676:49 - will create an instance of that or field
676:53 - of type
676:55 - order ID and I will call it I ID all
676:59 - right so for now we have this order ID
677:03 - but it's still not known as an ID for
677:07 - this entity now to make it to make this
677:10 - one an ID we use The annotation embedded
677:14 - ID all right so this embedded ID right
677:19 - here so here we see we also still miss
677:22 - something but first I will I will go
677:24 - back to this in a few seconds first I
677:26 - want to show you and I want to go
677:29 - quickly to the documentation of this
677:31 - embedded ID
677:34 - annotation so here it says apply to a
677:37 - persistent field or property of an
677:39 - entity class or maid super class so here
677:43 - you need to focus it's entity class or a
677:45 - MPP super class to uh denote a composite
677:50 - primary key that is an embeddable class
677:54 - the embeddable class must be annotated
677:56 - as embeddable so this is The annotation
677:58 - we are already
678:00 - used also there there must be only one
678:03 - embedded ID annotation and no ID
678:07 - annotation when the embedded ID
678:09 - annotation is used so this means when we
678:12 - when we want to use the embedded ID
678:14 - annotation we cannot have another ID
678:18 - annotation within this one all right so
678:21 - next it says that the attribute override
678:24 - annotation may be used to override the
678:26 - column mappings and so on and so forth
678:29 - and this one we can also skip you can I
678:32 - I will get you can have the time to to
678:34 - read
678:36 - it and here it says if the entity has a
678:39 - derivate primary key the attribute
678:41 - override annotation may only be used to
678:45 - override these attri those attributes of
678:48 - the embedded ID that do not correspond
678:51 - to the relationship in the parent entity
678:53 - okay and here also you can see an
678:56 - example we have for example this
678:57 - employee primary key with this embedded
679:00 - ID and here we see that we have this
679:04 - dependent ID annotated with The
679:06 - embeddable annotation right here okay
679:11 - so this is a bit uh and quickly The
679:15 - annotation of this embedded ID now let's
679:18 - go back and check this error right here
679:21 - okay so here it says that the class
679:25 - order ID should implement the ser
679:28 - realizable so when you want to use an
679:32 - embedded ID absolutely think about
679:36 - extending and implementing the
679:38 - serializable interface okay so this
679:42 - order ID should Implement
679:46 - serializable so the serializable is the
679:49 - one from java.io
679:53 - package
679:55 - now if I go back to the order now the
679:57 - error is gone and and I have my entity
680:00 - So within this embedded package I will
680:03 - create my order class or order entity
680:06 - okay so I will call it
680:10 - order and here I will just copy this
680:17 - information so these are the annotations
680:20 - that I will need and of course my class
680:23 - is an entity so we need the entity
680:25 - annotation and first of all I will
680:29 - create a
680:33 - string um let's call it order info for
680:38 - example and a
680:40 - private
680:42 - string another field because our focus
680:46 - is not about the fields but it's just uh
680:49 - to say that we have few information or
680:51 - few Fields within the order entity so
680:55 - now we see the same error that we know
680:58 - here when we create or we map um a class
681:02 - or Java class with the entity annotation
681:04 - so it will claim about an
681:07 - ID so here it says that this persistent
681:11 - entity order should have a primary key
681:14 - and here it as it's asking to add an
681:16 - attribute or an ID attribute for us as
681:19 - we mentioned before we don't want to use
681:23 - an autogenerated or an autoincrement ID
681:26 - but instead we want to use the this
681:28 - order ID class we just created so first
681:32 - of all I will create an instance of that
681:36 - or a field of type
681:38 - order ID and I we call it ID all right
681:44 - so for now we have this order ID but
681:46 - it's still not known as an ID for this
681:50 - entity now to make it to make this one
681:53 - an ID we use The annotation embedded ID
681:58 - all right right so this embedded ID
682:01 - right here so here we see we also still
682:05 - miss something but first I will I will
682:07 - go back to this in a few seconds first I
682:10 - want to show you and I want to go
682:12 - quickly to the documentation of this
682:14 - embedded ID
682:17 - annotation so here it says appli to a
682:20 - persistent field or property of an
682:23 - entity class or maid super class so here
682:26 - you need to focus it's entity class or a
682:29 - mapet super class to uh denote a
682:33 - composite primary key that is an
682:35 - embeddable class the embeddable class
682:38 - must be annotated as embeddable so this
682:41 - is The annotation we already
682:43 - used also there there must be only one
682:47 - embedded ID annotation and no ID
682:50 - annotation when the embedded ID
682:52 - annotation is used so this means when we
682:56 - when we want to use the embedded ID
682:58 - annot ation we cannot have another ID
683:01 - annotation within this one all right so
683:05 - next it says that the attribute override
683:07 - annotation may be used to override the
683:09 - column mappings and so on and so forth
683:13 - and this one we can also skip you can I
683:15 - I will get you can have the time to to
683:17 - read
683:19 - it and here it says if the entity has a
683:23 - derivate primary key the attribute
683:25 - override annotation may only be used to
683:28 - override these attri those attributes of
683:31 - the embedded ID that do not correspond
683:34 - to the relationship in the parent entity
683:37 - okay and here also you can see an
683:39 - example we have for example this
683:41 - employee primary key with this embedded
683:44 - ID and here we see that we have this
683:47 - dependent ID annotated with The
683:50 - embeddable annotation right here okay
683:54 - so this is a bit and quickly the
683:58 - annotation of this embedded ID now let's
684:01 - go back and check this error right here
684:04 - okay so here it says that the class
684:09 - order ID should implement the
684:12 - serializable so when you want to use an
684:16 - embedded ID absolutely think about
684:19 - extending and implementing the
684:22 - serializable interface okay so this
684:25 - order ID should implement
684:30 - realizable so the serializable is the
684:32 - one from java.io
684:36 - package
684:38 - now if I go back to the order now the
684:41 - error is gone and I have my entity okay
684:44 - so if I start my application I should
684:46 - see my order class or my order entity
684:50 - created in the database and I should see
684:54 - a composite primary key okay so let's go
684:57 - ahead click Start and check these
685:00 - updates so uh let's check the
685:04 - logs okay here we see an exception so
685:07 - the exception is we have a psql
685:10 - exception and this is because we have a
685:12 - syntax error near order because the
685:16 - order is already a reserved uh keyword
685:19 - so to solve this you already you already
685:21 - know the solution let's use the table
685:24 - annotation okay let's give it a name and
685:28 - let's give it underscore order right so
685:31 - now restart the application and we
685:33 - should see everything working fine right
685:37 - now all right so the application now is
685:39 - running we we check we don't have any
685:42 - exceptions no issues and also we can
685:45 - check the logs and you will see that we
685:47 - have our order table getting created
685:51 - okay so now let's go ahead check our
685:54 - database refresh and
685:57 - see so here we have this order table
686:01 - let's open it and we have already four
686:03 - columns so for these four columns we see
686:06 - that we have this order date and
686:08 - username both of them they contain or
686:11 - they have this golden key icon so this
686:15 - golden key icon is the the primary or is
686:18 - the icon of the primary key so our
686:21 - primary key in this database is the
686:23 - order date and the username both of them
686:26 - concatenated all right so if we check
686:28 - the keys right here so we see that we
686:31 - have this underscore order uncore P key
686:34 - so it's order primary key and it's a
686:37 - composed or composed key and it's
686:40 - composed already of this order date and
686:43 - username so this is how we can create an
686:46 - embedded ID in case you need to create
686:49 - an embedded ID now you have the
686:51 - knowledge to do it so if you have any
686:54 - questions don't hesitate to drop me a
686:56 - message otherwise let's move
687:02 - on so now we saw one example or one
687:05 - usage of this embeddable annotation I
687:08 - want to show you another one let's go
687:12 - back to our diagram right here and for
687:15 - this order for example we want to have
687:18 - or we want to add some information about
687:21 - the delivery address but we want this
687:24 - information to be uh embedded within the
687:28 - same the same entity or the same table
687:30 - right here so I don't want to store the
687:33 - address or the delivery addresses in a
687:36 - different table but I want it to be
687:38 - within the same table order right here
687:41 - you might say this is so easy to
687:43 - do all I need to do is within this order
687:47 - entity right here I just declare the
687:50 - information of the address okay but yeah
687:53 - the answer is yes but imagine we want to
687:56 - use the same address object also to
687:59 - store the address information with our
688:02 - tables within the same database or
688:04 - within the same schema so like this what
688:07 - I need to do is to duplicate the code in
688:11 - each entity which is not good okay we
688:14 - have a better solution okay the second
688:17 - one you might say we I can use the
688:19 - method super class and extract all these
688:22 - entities and just extend my entity with
688:26 - this address entity I say
688:28 - okay this also feasible but if you have
688:31 - multiple inheritance right here if you
688:34 - already for example extend a base a base
688:37 - entity or if you extend another or you
688:39 - have inheritance you with uh within your
688:43 - database so what should be the solution
688:46 - the solution can be using the embeddable
688:49 - entities all right so with this within
688:52 - this package embedded right here right
688:56 - click and create a new Java class and
689:00 - let's call it address
689:02 - okay so this address first of all we
689:06 - will need the same uh lbook or the same
689:09 - basic lbook annotations right here data
689:12 - all our Constructor and no arcs
689:18 - Constructor and now I will just create
689:21 - few dummy
689:23 - Fields so here I will have string Street
689:27 - street
689:28 - name private also another
689:32 - string house number for example uh house
689:36 - number it's a string just in case you
689:38 - have one a 1 b 1
689:41 - C and private string zip code so it's
689:47 - also string it might start with zero and
689:50 - so and so forth so let's not focus so
689:53 - much on on the fields right here but our
689:56 - main focus is to understand how this
689:59 - embeddable works so once we create and
690:04 - once we Define all the attributes of our
690:07 - embedded entity as we did in here within
690:10 - this order we need to use this
690:12 - embeddable annotation okay so let's use
690:16 - this annotation right here and like this
690:20 - we just created our embeddable entity
690:23 - now I will show you how you can use this
690:26 - embeddable entity as an attribute within
690:29 - another entity now let's go back to our
690:32 - order class and within the other fields
690:36 - that you created I want to create a new
690:38 - field of type
690:40 - address so I will create an address and
690:44 - I will call it address all right so now
690:48 - I want to tell that this address is an
690:51 - embeddable entity within my order entity
690:55 - all right so I I already me the solution
690:59 - so let's
691:00 - use the embedded annotation okay so here
691:05 - we have embedded ID and this is embedded
691:08 - and let's check quickly what is this
691:10 - embedded annotation so it specifies a
691:13 - persistent field or property of an
691:15 - entity whose value is an instance
691:17 - instance of an embeddable class so the
691:22 - embeddable class must be annotated as
691:24 - embeddable all right so the attribute
691:28 - override attribute override and so and
691:30 - so for may be used to override mappings
691:34 - declared and default or defaulted by the
691:37 - embeddable class so here you can also
691:39 - override some attributes when you use
691:42 - this embeddable class all right so this
691:45 - is the embedded annotation now let's go
691:49 - ahead start and test it click on restart
691:53 - right here so our application is up and
691:56 - running right now and let's go ahead and
691:58 - check the
692:00 - database so now I will just refresh the
692:03 - database and let's see what will happen
692:06 - right
692:07 - here so within this order table we see
692:10 - right now that we have seven columns and
692:13 - here we see that we have the house
692:15 - number street name zip code and so on so
692:19 - forth so the the fields of the address
692:23 - are now included or embedded within our
692:26 - order table so if you want to do or if
692:29 - you have a need and us it usage like
692:33 - that or use case like this one always
692:36 - think about using embeddable entities
692:39 - all right so embeddable entities will
692:41 - make your code much much easier and uh
692:45 - improve the granularity of your code and
692:48 - your code will be really reusable all
692:51 - right so because this address uh entity
692:54 - or this address uh class right here we
692:57 - might use it in many places so in order
693:00 - to
693:01 - duplicate uh not in order but instead of
693:04 - duplicating the code of uh the fields of
693:08 - this address class just create an
693:10 - embeddable entity and use it or call it
693:14 - whatever you need if you have any
693:17 - questions go ahead drop me a message
693:19 - otherwise let's move on previously we
693:22 - explained the hierarchy of the spring
693:25 - data jpa uh interfaces and how this
693:29 - helps us and provide us with methods and
693:32 - predefined methods to search data and
693:35 - query data from the
693:37 - database so now we cannot talk about
693:41 - spring data jpa and not talk about
693:45 - querying data from the database and
693:48 - querying the data means reading and
693:51 - writing and also deleting and all the
693:53 - interactions and the trans transactions
693:56 - that we can make with our
693:59 - database the spring uh data jpa and the
694:04 - repositories and the jpa repositories
694:06 - they provide us several ways to
694:09 - dynamically generate queries at run time
694:12 - so these are called uh query generation
694:15 - from method names or also known as query
694:19 - derivate query methods okay and these
694:23 - derivate query methods they allow you to
694:26 - Define queries
694:28 - based on the method name and uh of the
694:31 - query method you are calling so for
694:35 - example if you want to find the author
694:40 - right here let's first before going to
694:42 - this method right here let's just recap
694:45 - and remind about what we have so we
694:48 - created before an interface called
694:51 - author repository because we have an
694:53 - entity called author right here and this
694:56 - author Repository interface extends
694:58 - already the jpa repository which is a
695:02 - generic interface that takes two
695:05 - parameters the first one
695:07 - is the entity in question and the second
695:11 - one the ID type that we use within this
695:14 - entity okay so this jpa repository will
695:18 - use the author. Java our entity that we
695:21 - created and just a reminder with the
695:23 - author we have these IDs or this sorry
695:26 - not IDs about these fields we have an ID
695:29 - first name last name email and age okay
695:33 - so here within this author repository
695:36 - interface which extends already the jpa
695:39 - repository as I mentioned before we can
695:42 - create methods okay so it's an interface
695:45 - and you know within an interface all we
695:48 - need to do is the return type whether
695:51 - it's a function or a void and then the
695:54 - method name and the parameters this is
695:56 - how we create me methods with within an
696:00 - interface so as I mentioned spring data
696:03 - jpa provides us uh a way to dynamically
696:07 - generate queries okay and we call it uh
696:11 - derivate queries or derivate methods so
696:14 - this is how we can write it so here as I
696:17 - mentioned it's the return type and then
696:20 - the methods that we want to okay so
696:23 - let's explain this example right here we
696:25 - have this list of author so our method
696:28 - will return a list of authors and here
696:32 - we have find by last name and we have
696:36 - our last name or Ln as you you can call
696:38 - it as you want as a parameter so what
696:42 - will happen in here so this find by last
696:45 - name method generates a query that
696:49 - search uh the users or search the author
696:53 - with a specific last name and this
696:57 - method right here for example this find
697:00 - by first name and last name Will
697:04 - generate a quer that searches um the
697:07 - authors uh or the user by first name and
697:11 - last name okay we can generate other
697:15 - queries like uh like in here for example
697:19 - we can count we don't have only the find
697:22 - by we can also count we can also delete
697:26 - we can also do as many operations as we
697:28 - know in SQL using the derivate query
697:32 - methods okay so for example if I want to
697:34 - count all the authors in my database by
697:38 - age so all I need to do is to write the
697:41 - return type and spring data jpa will
697:44 - take care of the conversion okay so the
697:47 - count all by age within the age it will
697:51 - create a query that counts all the
697:54 - authors in this author table by the H
697:57 - and return this value also if for
698:00 - example uh we have already the delete
698:03 - methods that we can use or the
698:05 - predefined delete methods but if we want
698:08 - for example to delete uh the the list or
698:12 - we want to delete a list of authors by
698:15 - age all we need to do is delete all by
698:19 - and then we have age like bu and here
698:22 - it's followed by the property that we
698:24 - want to use Okay so
698:27 - let's explain a bit more here in order
698:32 - to generate one of the of the methods
698:35 - right here that will create a query
698:37 - behind the scenes at the runtime all we
698:40 - need to do is we have find by and Then
698:44 - followed by the property okay so this is
698:48 - the the simplest way so it's find by and
698:51 - then follow it by the property name and
698:54 - depends on the return type right here uh
698:59 - spring data jpa will determine what to
699:02 - return exactly so here we have find by
699:04 - so it will search everything from the
699:06 - database and return the result set okay
699:09 - but if we have for example here an
699:12 - author or an optional of author so I
699:14 - will explain the difference so an
699:16 - optional is the design pattern uh null
699:19 - pointer so this is a wrapper to wrap
699:22 - this author object within this optional
699:25 - class right here so this find by email
699:28 - spring data jpa will will search the
699:31 - author by email from the database and
699:34 - then return a type of an optional of
699:37 - type author okay so also the same here
699:41 - we have this find by email but in this
699:43 - case we will return the author so spring
699:46 - data GPA will do nothing except creating
699:49 - an object author and just return it okay
699:52 - so here as I mentioned we have the
699:54 - findby followed by the property and then
699:58 - you can create as many methods as you
700:01 - want okay so this is the first one also
700:05 - we can use find all by so they both work
700:09 - in the same way we can use find all by
700:12 - last name find all by first name and so
700:15 - on and so forth okay now we can also
700:18 - combine uh properties combine means what
700:21 - we can use uh operators such as and and
700:25 - or so I can search the list of authors
700:31 - by first name and last name okay so here
700:35 - we see we see that we have find by first
700:38 - name and last name and we need to pass
700:42 - these two parameters okay so FN for
700:45 - first name Ln for last name okay we can
700:49 - also use for example let's go back to
700:52 - this method I want to ignore the case
700:55 - when I want to query all the all the
700:58 - authors all the list of authors from my
701:00 - database so here we can say find by last
701:04 - name and Then followed by ignore case
701:09 - okay we can also use other operators
701:12 - like not like we can um use find by last
701:16 - name like so means this uh contains and
701:20 - so and so forth okay so we will see all
701:23 - this in action we will see how we
701:26 - implement or how we can Implement these
701:28 - methods okay so I hope this part is
701:31 - clear if you have any questions don't
701:34 - hesitate to drop me a message otherwise
701:36 - let's move on now let's see all this in
701:39 - action so first of all I will teach you
701:42 - how you can how you can write these
701:44 - methods so as we explained before first
701:47 - of all we start with the return type so
701:50 - here imagine we want to fetch the list
701:52 - of authors from our database and from
701:56 - this this author table by first name for
701:59 - example okay so when we say that I want
702:02 - the list automatically think about
702:05 - having a list okay so here you can
702:07 - whether work with list array lists
702:09 - Collections and so on and so forth but I
702:12 - always recommend using interfaces don't
702:15 - use classes use interfaces so in order
702:18 - when you want to change the
702:20 - implementation it's easier okay so let's
702:23 - go back so here we have a list and then
702:26 - the type so we want a list of
702:29 - author and then you have this find by so
702:35 - automatically when you type find by and
702:37 - you have the type as
702:39 - list so it will automatically transform
702:43 - it or map it to a list of authors you
702:45 - can also when you when you work with
702:48 - lists you can also use find all bu find
702:52 - all means that you want to search
702:53 - everything okay so they both work in the
702:56 - same way so let's use find
702:59 - all so then here if you have the inell
703:03 - the ultimate version or for the people
703:05 - who are using another IDE which provides
703:08 - autoc completion so here when you do
703:10 - command uh space or control
703:13 - space you will see that your IDE will
703:16 - propose the list of properties or the
703:19 - attributes that you have within the
703:21 - author okay so and here you can have a
703:24 - look on the gener ated uh generated or
703:29 - the autogenerated properties which are
703:31 - automatically detected from this author
703:34 - entity okay so we can see age for
703:36 - example and even within the age we can
703:39 - see that we have a lot of methods okay
703:43 - so imagine we have all these method uh
703:47 - within only the age property for example
703:51 - if I want to search all the authors
703:53 - where the age is null so I only need
703:56 - need to query um find all by age null
703:59 - age not null age not like not in and so
704:02 - and so forth so you can have a look and
704:05 - all and on all these methods and we will
704:08 - explain most of them okay so here for
704:12 - example I want to search all the authors
704:15 - by first name so all I need to do is to
704:17 - type first name okay and within this
704:21 - first first name also I can see that I
704:24 - have a lot of autocomplete so after
704:27 - before between uh by the way not all of
704:30 - them are
704:31 - appliable because when we say uh first
704:34 - name after he mainly we are talking
704:36 - about dates okay before also dates and
704:40 - between and so on so forth so you need
704:42 - to be careful not everything
704:44 - autogenerated here is usable or
704:46 - appliable for this specific property
704:50 - okay but you will learn it by the
704:54 - time so now the this find all by first
704:58 - name is completely sufficient now I need
705:01 - to provide my parameters so here uh you
705:05 - need that you have the same type like in
705:09 - here and then just type any name I will
705:12 - call it f name just to just to mention
705:15 - and to make sure that this works I don't
705:18 - need to pass the same here the same
705:20 - attribute name also one thing worth
705:23 - mentioning and it's really really
705:25 - important so you see this first name
705:28 - right here if I go to my author uh
705:31 - entity you see that we have the first
705:34 - name is written in exactly the same way
705:37 - so we have first and the name with the
705:39 - capital N okay so if you go back here
705:42 - you cannot say like this you cannot call
705:46 - your method like this so it will not be
705:48 - detected it will not be highlighted as
705:51 - an error but within your anj or within
705:54 - your IDE it might be be highlighted as
705:57 - an as a warning but not for all the
706:00 - cases but this worth mentioning so here
706:04 - all the only thing that you need to
706:06 - change is the first letter because you
706:08 - are using camel case so what you what
706:11 - you need to do is just copy the field
706:13 - that you want to use and until you get
706:16 - used to it copy it and then here just
706:20 - paste it and then the you change only
706:24 - the first letter to a capital letter
706:27 - okay so like this you will have the
706:30 - method or the exact method that will
706:32 - work for you and if I change this one to
706:35 - for example a lowercase we see that it's
706:38 - highlighted and here we see that um
706:42 - cannot resolve property first name this
706:45 - means that my anj or my IDE he
706:49 - automatically detected that this first
706:51 - name property is not within this author
706:55 - entity okay so here you need to always
706:59 - be careful about this all right so this
707:02 - is the our first method and this one
707:05 - will search all the lists or of authors
707:09 - from our database by first name now
707:12 - let's try and see how we can improve or
707:15 - how we can extend this this method
707:22 - okay all right so let's try how we can
707:26 - extend and improve a bit this query just
707:30 - as a reminder I want to remind you that
707:33 - this query is the equivalent of this one
707:38 - select star
707:41 - from
707:42 - author
707:44 - where first
707:49 - name uh I will use it as as in the
707:52 - database uh let's say this is a native
707:54 - query equals and and here we have our
707:58 - first name as parameter right here so
708:00 - this is the same exact query
708:04 - now now let's answer the following
708:07 - question what if I want to find all the
708:10 - authors from my author table where first
708:15 - name equals any for example equals this
708:19 - and I have in my database the users are
708:23 - all in capital letters okay are all ABC
708:26 - case but I want to ignore the case I
708:29 - want even if I want even to pass when I
708:32 - pass this Ali as value I want always to
708:36 - query the data So within this method
708:39 - right here and this generated query
708:42 - right here passing this value Ali and
708:45 - having all the first names in the
708:48 - database equals or in uppercase this
708:51 - will not work this will return an empty
708:54 - list okay this will return nothing now
708:57 - let's try to extend this query and make
709:01 - it ignore the case all right so here we
709:04 - have find all by first name and I
709:07 - already gave you the answer we need to
709:09 - add one property which called ignore
709:13 - case okay so when we say ignore case now
709:16 - it will accept this query right here
709:19 - okay and it will return some data all
709:23 - right so this is good now what if I want
709:29 - to get all the data or all the authors
709:32 - from the
709:33 - database where the first name contains
709:37 - this one for example contains a l all
709:42 - right so and also I want it to be also
709:46 - ignore
709:48 - case in order to do so I will duplicate
709:51 - also this method so here we have find
709:54 - all by first name ignore case we can
709:58 - also add
710:01 - containing so we need find all by first
710:06 - name
710:10 - containing and then ignore case so as
710:13 - you can see here we can concatenate and
710:16 - we can use
710:18 - multiple uh use multiple uh filters
710:22 - within the same query method okay so
710:24 - here we have find all by first name so
710:27 - this is the attribute name and then the
710:30 - condition that you want to use or the
710:32 - CLA the work Clause that you want we
710:34 - want to use containing so containing
710:37 - will be the equivalent of this one right
710:40 - here so it will be something like that
710:43 - okay so it's going to be like percent
710:46 - percent so this is the exact same thing
710:49 - and also we want to insist that we want
710:51 - to ignore the case so here be careful
710:54 - it's property or we close and then the
710:58 - refinement if we want to refine our
711:01 - query okay so now I want to so this one
711:06 - I hope it's clear otherwise you can drop
711:09 - me a message and I can explain it a bit
711:11 - more now I want to get all the authors
711:15 - where the first name starts with this
711:19 - and also ignoring the case all right so
711:22 - in order to do that let me just keep
711:24 - this as it is
711:27 - and I will duplicate this method so I
711:30 - will use it always as a base method I
711:33 - will copy or paste uh this query right
711:36 - here so I want as I mentioned to search
711:40 - all the authors from the database where
711:43 - the first name starts with this so here
711:47 - instead of containing I will use starts
711:52 - with so here when we use the start start
711:56 - with the query will be transformed or
711:58 - will be generated exactly like this okay
712:01 - and also here we want to ignore the case
712:04 - now let's take another another
712:07 - case let's play around with these
712:09 - quaries because it's really funny so
712:12 - here instead of starting with I want all
712:16 - the first name that ends with okay that
712:20 - ends with uh sorry sorry I just made a
712:24 - mistake so starts with with it's like
712:26 - that so it's a and then anything because
712:30 - this percent means anything but ends
712:33 - with is the opposite one okay so I'm
712:36 - sorry for that so here I need all the
712:41 - queries or all the authors from the
712:43 - database where the name ends with Al so
712:47 - it starts with anything and ends with a
712:49 - l all right so here I will duplicate the
712:53 - same
712:54 - method and and here instead of starts
712:57 - with I already gave you the answer so I
713:00 - need to use ends
713:03 - with and you can see that this ends with
713:06 - ignore case will transform and will
713:09 - create this exact same query in the
713:12 - background okay so uh we can also we can
713:17 - also add and play with so many
713:20 - attributes and as I mentioned like after
713:23 - the first name or after the property
713:24 - name with within your IDE you can click
713:27 - on control space and you will see so
713:31 - many methods okay so starting with
713:34 - ending with also you can check if the if
713:38 - the author or if an author exists with
713:42 - this first name uh you can also use uh n
713:46 - and so and so forth okay so um for
713:50 - example if you
713:53 - want for example if you want to generate
713:56 - this
713:58 - query so I want the list uh of authors
714:02 - from the database where the first name
714:05 - in for example I want to filter only
714:09 - for for
714:12 - example
714:14 - Ali I want to get all the authors where
714:17 - the name is where the Ali or Buu or
714:20 - coding so here it's super easy as I as
714:24 - we mentioned before let me duplicate
714:26 - this
714:27 - method and
714:30 - here instead of ends with I need to pass
714:34 - in okay so and also here ignore case so
714:39 - I want to find all the names or all the
714:42 - first
714:44 - names uh in from the author table where
714:48 - the first name is in a list but here we
714:53 - we need to pass a list of strings
714:56 - okay so to pass a list of strings so
714:58 - whether we pass a table or we pass a
715:01 - collection
715:03 - okay so here we need to pass a list of
715:06 - string as the first names I will call it
715:11 - first
715:13 - names and this will generate behind the
715:15 - scenes this exact same query all right
715:18 - so you can play with these methods with
715:22 - these filters and you can generate
715:24 - awesome queries out of this now let's
715:26 - move on and try something else now
715:30 - before moving ahead and going deep into
715:32 - this derivate query methods let's play a
715:35 - bit with what we created right here so
715:38 - to do so we will go to this Java
715:41 - application here where we have our
715:43 - command line Runner bean and we need to
715:47 - insert some data into our author table
715:50 - to inable in order to be able to play
715:53 - with these queries but here we Face a
715:57 - small issue which is that if we want to
716:01 - insert multiple data I need to every
716:04 - time to create for example if I want to
716:06 - insert 50 uh authors into my database I
716:10 - need to duplicate this code 50 times and
716:13 - each time I need to change the first
716:14 - name last name age and so and so forth
716:18 - but to do so we can use a dependency
716:23 - which help us to fake data okay so this
716:26 - dependency is called Faker or called
716:29 - Java Faker so it will automatically
716:32 - generate uh data for us including for
716:35 - example first name last name emails and
716:38 - so on so forth also it can generate
716:40 - generate address and so and so forth all
716:43 - right so uh first of all let's go ahead
716:46 - and insert and add this dependency so
716:51 - open the pom.xml file and go down to to
716:55 - the dependencies right here and after
716:59 - the project lumo add the following
717:02 - dependency okay so add the dependency uh
717:06 - tag and within the artifact Rd it's
717:08 - called Java Faker so it's the second one
717:12 - not the fixture but it's the second one
717:14 - Java Faker so select this and then it's
717:18 - from com. GitHub do Java Faker right and
717:23 - the the most recent version at this time
717:25 - is the one2 if you have more or a recent
717:29 - version just go ahead and choose it then
717:32 - click on this load Maven changes and
717:35 - that it you will have the Java Faker
717:38 - within your project okay now let's
717:42 - insert some data first of all don't
717:45 - forget to bring back this bin annotation
717:47 - let me make this full screen and then we
717:51 - need to comment out this one and to
717:53 - comment this out all we all you need to
717:56 - do is Select it and then go to code and
717:59 - here you have this command with block
718:01 - comment okay now let's bring back this
718:04 - code right
718:06 - here and what we will do let's create a
718:09 - loop so I will do for in I equal z
718:15 - i smaller than or less than let's insert
718:20 - 50 and here we have
718:23 - i++ and let's let's move this code
718:27 - inside now instead of this first name
718:30 - and last name I will remove the email or
718:32 - let's let's keep it like that the age we
718:35 - can also keep it uh but here instead of
718:39 - this first name last name what we will
718:41 - do here I will create uh a
718:47 - faker I will call it Faker equals a new
718:51 - Faker okay so this is how we can use our
718:54 - Faker uh uh object and now for the first
718:58 - name I will use Faker dotname we see
719:03 - here that we have this name object which
719:05 - returns a
719:06 - name and from this name we have first
719:09 - name name last name full name and so and
719:12 - so forth so we need the first name last
719:14 - here and also let's use the same one for
719:19 - the last name right here so instead of
719:22 - first name let's use last name okay okay
719:26 - now for the age we can use our
719:29 - Faker do
719:31 - number and here we can generate a number
719:35 - or a random number between two digits
719:37 - for example and the age I want uh my
719:40 - author to be between for example 19 and
719:44 - maximum let's say 50 okay so it will
719:47 - like this it will generate an age or a
719:50 - number between 19 and 50
719:53 - okay all right so so now we can just run
719:56 - our application and make sure that we
719:59 - have all our authors inserted into the
720:01 - database so let's go ahead and do
720:03 - it okay so here we forgot that our email
720:07 - should be unique so to do that I will
720:10 - just do something like
720:14 - this just to fix it quickly and here I
720:17 - will concatenate it with uh with I okay
720:21 - so it will be contact Z1 and so and so
720:24 - forth so like this we don't have the
720:25 - applications I will restart the
720:27 - application and
720:28 - see so now we see that we have the
720:31 - insertion logs let's go ahead refresh
720:33 - our database and check let me move this
720:37 - refresh the
720:39 - data and here we have our tables and now
720:43 - let's go and check our author table okay
720:46 - so we see right
720:49 - here that we have this email and we see
720:53 - that we have this first name last name
720:55 - and so on and so forth and the
720:56 - information that we provided also the
720:58 - age but now let's make uh this insertion
721:03 - permanent and I because here if you as
721:06 - you remember when we start the
721:08 - application and uh we made this ddl Auto
721:12 - right here like just to remind you the
721:15 - configuration the ddl auto we created is
721:19 - create a drop so all we need to do is to
721:22 - make this one to update okay
721:25 - uh so when we make it update every time
721:28 - we will start the application we will
721:30 - not lose the data so this is what we
721:32 - need to do so in order to do that just
721:35 - go ahead make this property to
721:38 - update like this and then we need what
721:42 - we need to do is to restart the
721:44 - application so we can insert the data so
721:47 - just follow me on this restart your
721:50 - application and then we will have the
721:53 - data inserted
721:55 - so here we have in our database let's
721:59 - refresh it we have this data right
722:04 - here and this data will be persisted
722:07 - like always okay and then we go back
722:12 - here in order to make this data always
722:15 - persistent just go back right here and
722:18 - you can just comment out this insertion
722:20 - or you can also keep it but here we want
722:23 - to play with this um with this part
722:27 - right here but let's comment out all
722:29 - this for Loop so let's use a block block
722:33 - comment so we no longer have this code
722:37 - getting executed and to make sure that
722:40 - what you did is correct just go ahead
722:42 - restart again the application and make
722:45 - sure that you still have the data so
722:47 - here we should not see any uh SQL log
722:51 - telling that that we are inserting and
722:54 - as you can see the application is
722:55 - already started and nothing happened so
722:59 - also if I refresh my database if you
723:02 - open the table right here click this
723:04 - refresh button you see that we still
723:07 - have the data okay also let's just to
723:09 - double check let's refresh this open and
723:13 - we see that we have the data right here
723:16 - okay so now we have permanent data
723:18 - within our database and now we can play
723:21 - with it now I want to give you a small
723:24 - EX exercise so here we prepared
723:26 - everything we have all the ground we
723:28 - need to run our tests so now I want you
723:32 - to play Within this repository this
723:35 - author repository and the methods that
723:38 - we already generated right here so
723:41 - within this command line Runner or if
723:43 - you want you can create a service and
723:45 - some end points and you can play with
723:48 - this methods but just go ahead and test
723:51 - this uh find all by methods and see the
723:56 - output okay so I hope you like this
723:59 - exercise if you face an issue drop me a
724:01 - message otherwise let's move on well
724:05 - done after you played with all these me
724:07 - methods that we created together now
724:10 - let's move on and check something else
724:13 - so here we have our author table already
724:15 - inserted with data and we can see here
724:18 - that we have email first name last name
724:20 - and age and uh for this one I just want
724:23 - to highlight one thing because here for
724:26 - this email what I used here I used the
724:28 - faker name. username because I'm sure
724:31 - that this username will give me a unique
724:34 - uh username and then I I made a
724:37 - concatenation with the at alibu
724:39 - coding.com so you can also do the same
724:42 - also for the age you can uh you can use
724:45 - the faker do number and then number
724:47 - between and it will give you a random
724:49 - number between 20 and 80 for example all
724:52 - right let's go back here now we have uh
724:55 - the data inserted now what if I want to
724:59 - update for example the first one which
725:01 - has uh the ID equals 1 I want to change
725:05 - the email first name last name and age
725:08 - okay so in order to do that it's so easy
725:12 - here we will keep uh this one and also I
725:15 - will keep the bean because in the
725:18 - application uh here I have create drop
725:22 - so this means every time I start the
725:24 - application I will get my data inserted
725:27 - okay so after inserting the data what I
725:29 - want to do is I want to create or I want
725:32 - to copy paste this one or I can copy the
725:35 - whole code and here I want to update
725:39 - author with id1 all right so in this
725:43 - case what I will be do uh what what I
725:45 - will be doing is I will create an author
725:48 - object and here I will just change the
725:51 - data and here I will make it first name
725:54 - Ali last name bu Ali and age it will be
725:59 - my age for example and the email I will
726:03 - move it back as it was so contact at
726:07 - alibu coding.com and then of course I
726:10 - will need uh okay I forgot repository.
726:14 - saave here and then I need the same
726:16 - thing here so now this one it will
726:20 - insert this um this author but if I do
726:26 - do ID here one so this means that we
726:31 - will update this author and let me
726:33 - explain how this works so this save
726:36 - method first of all it it will check the
726:39 - ID so if we have uh if we have an ID the
726:43 - first thing that it will do it will try
726:45 - to fetch any object within this ID so it
726:48 - will make uh select all or select star
726:51 - from author where ID equals one
726:55 - if the hibernate can find data what it
726:59 - will be doing it will be merging or
727:01 - updating all these fields okay otherwise
727:05 - if for example I pass an ID equals 1
727:08 - million or 100,000 so it will not find
727:12 - any object within this ID in this author
727:14 - table so it will decide that it will be
727:17 - an insertion or creation of of a new
727:20 - input here you need to really pay
727:23 - attention that when you pass an ID the
727:26 - ID should exist in the table you should
727:29 - already know the ID in order to update
727:31 - something so now let's move on and rerun
727:35 - the application so we will we will have
727:37 - all this information but the element or
727:40 - the first one should be alibu alib Ali
727:44 - and with the email contact albu.com all
727:47 - right so here we see also that we have
727:50 - all these
727:51 - insert and then you you see here that
727:54 - you have a select and then an update so
727:57 - the first select is checking if we have
728:00 - the author with the ID that that you
728:02 - specified in here which is the ID one
728:06 - and then we have update author set age
728:09 - and so and so forth and then where ID
728:12 - equals the the ID that we passed as
728:15 - parameter so now I will just refresh
728:17 - this this one and you will see that if I
728:20 - search for the ID number one which will
728:23 - be at the end we see here that we have
728:25 - the urge 34 uh alibu coding uh.com Ali
728:29 - and B Ali as a last
728:32 - name so this is a way of updating the
728:36 - data now what if I want for example just
728:39 - to update this one or this one or only I
728:42 - want to update age or all the ages of my
728:46 - um of my table so for example what if I
728:50 - made a mistake and and I want to fix all
728:53 - the app updates or I want to update all
728:56 - the ages of all the authors in the
728:58 - author table so in this case I need to
729:01 - write one query which will update
729:04 - everything so I don't have uh a
729:06 - condition right here like I don't have
729:08 - an ID and if I want to use this method I
729:11 - need first of all to find all the
729:13 - authors from the table and then I have
729:16 - to Loop over them and each time I need
729:19 - to set the age and of course I need to
729:21 - pass the ID and then repository. save
729:24 - but there is an easier way and we will
729:26 - see it just right now so what I want to
729:29 - do now is running the following query so
729:33 - I want to create a method or create a
729:35 - mechanism that will allow me to update
729:38 - to run the following query which is
729:40 - update
729:42 - author and then set or let's call it a
729:46 - set
729:48 - a. equals 22 for example and here let's
729:52 - start first of all with
729:55 - where a. ID equals 1 for example so I
730:00 - want to have or I want to execute this
730:02 - query so it's exactly the same thing
730:05 - like here but I want to use the jpa or
730:08 - the my repository right here so here I
730:11 - have the author repository and I will
730:14 - show you how you can use this repository
730:17 - in order to run or to create update
730:20 - queries so first of all go to this
730:23 - author Repository and I can just copy
730:26 - this one and then what I will do I will
730:29 - create a void or let's create an an INT
730:32 - uh method so update
730:35 - author just update author it's it's okay
730:39 - so in order to update the author we need
730:41 - to pass an INT age and then int ID
730:45 - because we want to update the the age of
730:48 - the of the author having the ID one for
730:51 - example and here as we mentioned we want
730:54 - to run this following query so in this
730:57 - in order to do that so we will use the
731:00 - query annotation and then this is our
731:03 - query so it's update author a set A.H
731:06 - equals 22 where ID and now the ID should
731:09 - be like this all right so this ID will
731:12 - refer this one and the age should be
731:15 - also H so this query does not support
731:19 - update uh methods or update instructions
731:22 - but we need now to tell uh spring data
731:26 - jpa that this is an update query and in
731:29 - order to do that all we need to do is to
731:31 - add this modifying annotation so when we
731:35 - have this modifying with this query
731:37 - right here hibernate will understand
731:40 - that this is an update query so now if
731:43 - we go back here and if I comment this
731:47 - out and then if I do repository do
731:53 - update author and I pass for example 22
731:57 - as age and I pass one as an ad and rerun
732:02 - the application we will see that in the
732:05 - author table we will have or we will
732:07 - find that we have an update okay here we
732:10 - see that the application did did not run
732:12 - and we have already one exception so we
732:15 - see that first of all we started to
732:17 - insert everything and then we we got an
732:20 - exception fail to execute command
732:22 - command line Runner and then executing
732:25 - an update or
732:27 - delete uh through through an exception
732:30 - so let me explain to you what is the
732:32 - reason behind that so the reason is that
732:35 - this update method that we have right
732:37 - here was not or is not transactional so
732:41 - so in order to do that or in order to
732:43 - fix that we need to make this modifying
732:46 - query transactional because the
732:48 - modification or the update need to be
732:51 - within the same transaction
732:54 - okay so in order to fix that all you
732:57 - need to do so here you need to put in
732:59 - mind that when you use the query and
733:02 - modifying then you need also The
733:04 - transactional annotation so with these
733:07 - three annotations right here modifying
733:10 - transactional and query with the update
733:12 - query we will be able to update our our
733:16 - author so now let's run again and let's
733:19 - also check the the output so we see here
733:23 - that we have all the inserts that we
733:25 - have but now we have no select as we saw
733:28 - before but it's directly updating so
733:31 - update author set age where ID equals
733:34 - something so let's go back to
733:38 - our and now if I scroll down and they
733:41 - see this one so we see that the ID
733:45 - number one has the age 22 and also if
733:48 - you want to make sure you can just put 1
733:51 - age equals equals one 100 for example
733:55 - since we know that all our authors uh
733:57 - ages are between 20 and 80 so now we can
734:01 - make sure that we updated the correct
734:03 - one and also the update method or the
734:05 - update query is working as expected so
734:08 - now we see that the age of this uh guy
734:11 - right here is 100 so our update query is
734:15 - working now if you want to or now let's
734:19 - try to update all the all the ages or
734:24 - the ages of all the authors that we have
734:26 - so first of all I will create void
734:28 - update all authors for example
734:33 - ages and here I will just pass an INT
734:36 - age and I will also copy this one and
734:40 - all I need to do is removing this work
734:43 - close and now I will duplicate this one
734:46 - update all authors and I will set the
734:49 - age to 99 for example this one we can
734:52 - comment it out and I will rerun the
734:55 - application oh uh we missed something
734:57 - already so here it we need to use the
735:00 - update all authors and age 99 and I will
735:04 - remove the ID so let's start again okay
735:07 - so we see here that update author set
735:10 - age equals to something and if I refresh
735:13 - right here I should see all the ages
735:15 - equals to 99 so this modifying query and
735:20 - this modifying annotation right here is
735:22 - really useful if you want to do a bulk
735:24 - update and you want to update many
735:26 - things at the same time so you don't
735:28 - need to Loop over uh the data and set
735:31 - this said that set this set that so all
735:34 - you need to do is to create an update
735:36 - query and then if you need and also
735:38 - don't forget if you need this workloads
735:40 - you need to add it otherwise you will be
735:43 - updating oral data in this part we will
735:45 - see together the named queries so in
735:48 - Spring data jpa named queries are useful
735:51 - in a variety of scenarios uh for Oran
735:53 - organizing optimizing and maintaining
735:56 - query definitions in your application
735:58 - and some common uh use cases includes uh
736:02 - encapsulation for example of your query
736:04 - logic so named query help you separate
736:07 - query definition for the rest of the
736:09 - application logic also named quer are
736:12 - reusable they also help us optimize the
736:15 - performance of our application because
736:18 - they um the named query are validated
736:21 - and passed and often optimized during
736:24 - application startup so when you have a
736:26 - named query it will be passed validated
736:29 - and optimized on the application startup
736:32 - also named queries uh are are
736:34 - centralized this means named queries
736:37 - allow you to store your query definition
736:39 - in one place either with an entity class
736:42 - or an external XML file this
736:44 - externalization simplifies query
736:46 - management and makes it easier to update
736:49 - and refactor the queries let me give you
736:52 - some specific examples when to use named
736:55 - queries in Spring data jpa application
736:58 - so first of all when you have complex
737:00 - queries that are used in multiple places
737:03 - throughout uh your application when you
737:06 - want to optimize performance for
737:08 - frequently executed queries when you
737:11 - want also to improve code readability
737:14 - and maintainability by separating query
737:17 - definitions from other application logic
737:19 - and finally when you need standard way
737:22 - of organizing and managing queries
737:24 - across your application so these are the
737:28 - use cases or some of the use cases of
737:31 - named queries and the definition also of
737:33 - a named query but you need to keep
737:36 - something important in mind while named
737:40 - queries offer uh several benefits it's
737:43 - it's important to note that they may not
737:46 - always be the best choice for every
737:49 - situation for example they might not be
737:52 - as flexible as Dynamic queries for
737:55 - example when we use Query DSL or
737:57 - criteria API also when it comes to
738:00 - building uh queries based on varying
738:03 - condition or user inputs it's essential
738:06 - to evaluate your specific use case and
738:09 - choose the appropriate approach for your
738:12 - application all right now let's move on
738:15 - and Implement our named query and let me
738:18 - show you how to do that to create a
738:20 - named query first of all you need to go
738:23 - to the entity or to the model where you
738:25 - want to create that query so here we
738:28 - have two options first of all we can use
738:31 - this annotation named
738:33 - query or we can also use named queries
738:37 - so we have two options okay also we have
738:41 - another one which is named native query
738:44 - or named native queries right here so
738:47 - you can also create native queries as
738:51 - named queries so for the this case let's
738:54 - move on and let's go ahead and create
738:57 - jpql named queries so first of all we
739:00 - will use a single one and I will show
739:02 - you how you can use this uh named query
739:06 - and then I will show you the use case or
739:08 - the usage of these named
739:13 - queries so first of all as I mentioned
739:17 - when using named query we need to give
739:20 - it a name and the name always think
739:23 - about having uh The Entity name or your
739:26 - model name dot the name of the named
739:29 - query so I will just say find by named
739:36 - query and then I would provide the query
739:39 - itself so let's say for example for this
739:43 - one I want to do select a from author a
739:47 - this is just the Adas
739:50 - where a. AG is greater than greater than
739:55 - or equal for example to the age I want
739:57 - to pass as a parameter so now I have
740:01 - named query which will fit all the
740:04 - authors by age where the age is greater
740:07 - or equal than a specific parameter so
740:10 - now in order to execute or to use this
740:13 - named
740:14 - query just go to your repository right
740:18 - here and now we want to execute this qu
740:23 - so it will be return a list of
740:25 - authors and then we have find by and as
740:29 - you can see enj is already proposing
740:32 - this one and also you see that the icon
740:35 - is slightly different from the from the
740:38 - Native one or from the predefined ones
740:40 - so here we have find by named query and
740:43 - also as you saw here we have its named
740:46 - query so all we need to do is to pass
740:48 - our
740:50 - parameter using the pram annotation
740:54 - and then
740:55 - age and then of course it's of type int
740:58 - so it's going to be int AG so that's it
741:02 - and here you see already the difference
741:04 - that we have this icon and when you
741:06 - click on it it will navigate as to the
741:08 - named query okay so now in order to use
741:11 - this one or to check it all you need to
741:14 - do is to go here to the jpa application
741:18 - and then after executing and updating
741:21 - and doing all that what I will do I will
741:24 - do list of
741:27 - authors equals repository. find by named
741:32 - query and here let's say for example I
741:35 - want to fetch all the users having or
741:38 - all the authors having an age greater or
741:40 - equal than
741:42 - this yeah so this one should be or
741:45 - should go inside and here it will be
741:49 - finded by named query and then I can can
741:53 - do for example for each
741:59 - system.out.println so I just want to
742:01 - print all the authors that will be here
742:05 - I guess we can also remove this one and
742:07 - now let's execute our application and
742:10 - let's see the output so here we see that
742:12 - we have all the authors and here we just
742:16 - forgot to remove this update because by
742:20 - this we updated all the authors and we
742:22 - set all the ages to 99 so it will
742:24 - retrieve all of them so now let's see
742:27 - and here we have a restricted list and
742:30 - as we can see here we have all the users
742:33 - where the age is 74 71 and so on so
742:36 - forth so for example if I change this
742:39 - one to 70 or 7 s something like that
742:43 - yeah okay and if we run again we will
742:47 - see that we have we will have or we will
742:49 - get a shorter
742:50 - list so you see that you have have only
742:53 - two with the age 71 and 70 all right so
742:57 - this is how we can create uh a named
743:00 - query let's move on and let me show you
743:02 - how we can create a list of named
743:04 - queries and how we can create another
743:06 - type of named
743:09 - queries now let's update data using
743:13 - named query so let's try to recreate the
743:16 - same uh query right here but using the
743:19 - name query so first of all I would just
743:22 - copy this one and then I will go back to
743:24 - the author and I will create another
743:27 - named query right here and then I will
743:30 - give it a name so the name will be
743:33 - author.
743:34 - update by named query and the query will
743:38 - be the one I just copied so here it will
743:41 - be update author set age where ID equals
743:44 - something but here I will just remove
743:48 - this
743:48 - ID and I want to update all the all the
743:52 - author authors so again I need to go
743:55 - back
743:57 - here so it will be a
744:00 - void update by named query and this one
744:04 - of course we need a parameter which is
744:06 - the
744:07 - age and then int
744:10 - H all right so let's double check so
744:13 - here we have a variable H so we need to
744:15 - pass it and this is what we did right
744:18 - here now let's go back after uh
744:21 - displaying all this data Now update with
744:24 - named query so all I need to do is my
744:27 - repository do update with name or by
744:31 - named query and here I will pass for
744:33 - example 12 as an age and I will execute
744:38 - the the application again and check what
744:40 - will happen so it seems that it did not
744:42 - work and now I guess and I'm pretty sure
744:46 - that you know why it did not work and
744:48 - the answer is so let me first show you
744:51 - the the exception failed to execute
744:53 - command Runner and here it says
744:55 - expecting a select query but we got an
744:59 - update so the answer is that is the one
745:02 - you already thinking about we need this
745:04 - modifying and of course we need The
745:07 - transactional annotation so even if it's
745:09 - a named query if it's an update query we
745:13 - need always to use this modifying so
745:15 - let's run again and check and now we see
745:18 - that we have this update and then if I
745:21 - open my table right here and I will see
745:24 - that all the ages now are 12 so that's
745:27 - it also before um before we move on to
745:31 - the next steps here you see or we
745:34 - mentioned already that we can use named
745:36 - query or this annotation named queries
745:40 - the difference between this named query
745:42 - and named queries actually there is no
745:44 - difference because if we go to the
745:46 - source code of this annotation we see
745:49 - that we have or we can pass a list list
745:53 - of named queries so it's just a way to
745:55 - organize our named queries so we can do
745:58 - something like that and we can move
746:01 - these named queries
746:03 - inside and that's it so this this is the
746:06 - only difference between the named
746:08 - queries and the named queries so you can
746:11 - whether have them separately or you can
746:13 - also group them within a list of named
746:16 - queries and nothing will change it will
746:19 - be always the same everything will will
746:21 - will remain the same all we need to do
746:23 - is just group them with named queries
746:26 - spring data jpa specification is a
746:29 - powerful and flexible feature provided
746:31 - by Spring data jpa framework that allows
746:35 - developers to create Dynamic and type
746:37 - safe queries using the jpa criteria API
746:41 - it enables you to build complex queries
746:44 - based on various criteria which can be
746:47 - combined and reused in different
746:49 - scenarios providing flexibility and
746:51 - maintainability in constructing queries
746:55 - and the core of the
746:57 - specification the core concept of spring
747:00 - data specification revolves around the
747:03 - specification interface which which is a
747:06 - functional interface with a single
747:08 - method so here we see in the source code
747:11 - that we have a bunch of static and
747:13 - default methods but the main method or
747:16 - the main uh important method is is this
747:20 - one predicate to predicate here the T
747:23 - represents the entity type on which the
747:25 - query is built and the pr two predicate
747:29 - method receives three arguments first of
747:32 - all we have the root right here which is
747:36 - the object that represents the root
747:38 - entity in the query from which you can
747:40 - navigate to other related entities and
747:43 - attributes and then we have a query
747:47 - which is a criteria query of a type uh
747:50 - interrogation Mark which can be any type
747:53 - which is an object that represents the
747:55 - overall query being built this can be
747:58 - used to modify the query structure and
748:01 - uh or add additional constraints finally
748:04 - we have the criteria Builder which is of
748:07 - type criteria Builder which is an object
748:10 - that acts as a factory for creating
748:12 - various cre elements like predicates
748:15 - extensions and orderings the two
748:18 - predicate method returns a predicate
748:21 - which is a Boolean expression
748:22 - representing the query condition now
748:25 - let's talk about how we can use this
748:28 - specification so to use a spring data
748:30 - specification you need first of all to
748:33 - extend uh your repository with this jpa
748:37 - specification executor interface which
748:40 - provides methods to perform queries
748:42 - using specifications the most common
748:45 - used methods are find all and find one
748:48 - you can also create Uh custom
748:51 - specifications in es by implementing the
748:54 - specification interface or by using
748:57 - Lambda expression so specifications can
749:00 - be combined using the end and the or
749:04 - method as we can see right here we have
749:07 - this end and we have this or also we
749:09 - have where and not these methods uh
749:12 - allow us to build complex queries
749:15 - dynamically in summary and overall
749:17 - spring data jpa specification is a
749:20 - feature that leverages the jpa criteria
749:23 - API to build Dynamic and typees safe
749:25 - queries for your application it provides
749:28 - a flexible and maintainable approach to
749:31 - construct queries based on various
749:34 - criteria which can be combined and
749:36 - reused throughout your application this
749:39 - approach is particularly used when
749:42 - dealing with complex queries that depend
749:45 - on user input or VAR B based on runtime
749:48 - conditions now let's move on to the
749:51 - action and let's implement our first
749:53 - specification query the first step is in
749:56 - implementing
749:57 - specifications is first of all you need
750:00 - to go to your repository where you have
750:02 - or where you extend your jpa uh the jpa
750:05 - repository also we need to extend the
750:09 - jpa specification executor so here we
750:12 - extend already um jpa repository I will
750:16 - also extend jpa specification executor
750:20 - and here we need to give it the same
750:22 - type author in here all right so now we
750:26 - have our repository ready to be used as
750:30 - a specification executor after extending
750:33 - the author repository we need to create
750:36 - a new class so I will create a new
750:39 - package here I will call it
750:42 - specification and then I will call or I
750:45 - will create a new class called it author
750:48 - specification and now within my author
750:51 - specification I will create two
750:54 - specifications or let's call them two
750:57 - predicates uh and these predicates they
751:00 - will filter for example my authors based
751:03 - on the first name and age so let's
751:06 - create the first one public static
751:10 - specification and my specification is of
751:13 - type author of course don't forget that
751:16 - and let's call this one has age for
751:18 - example and this going to be our first
751:21 - filter so in first of all it's going to
751:23 - be int Ag and then we need to return a
751:26 - Lambda expression so you know when the
751:29 - two predicate method that we checked
751:32 - before it takes root of type author
751:35 - let's call it root and then we have the
751:38 - criteria query and this one as we
751:40 - mentioned before it's going to be
751:42 - interrogation mark this is our query and
751:45 - we have our criteria Builder now let me
751:50 - just inline these variables so so you
751:52 - can see everything so here we have this
751:56 - the these are the parameters that we
751:58 - that we need as we explained before so
752:01 - we have our root of type author we have
752:03 - the criteria query and the criteria
752:06 - Builder so here what I want to do or
752:08 - like what we need to filter out is first
752:11 - of all if this age right here so for
752:15 - example this is just a check if uh it's
752:19 - less than zero so I will just return
752:22 - null because we know that we don't have
752:25 - any age or any person having a negative
752:28 - age otherwise I will return my criteria
752:31 - Builder dot equal and then I need to
752:35 - pass the expression so it's the root
752:38 - that holds the information of the entity
752:41 - do get and then I can pass the attribute
752:45 - name that I want to filter on which is
752:47 - age and then the age itself so here I'm
752:52 - ensuring that this method has age right
752:55 - here will add uh a criteria or will add
752:59 - specification that the age of the author
753:03 - right
753:04 - here this this variable or this field
753:07 - right
753:08 - here should be equal the age that we
753:11 - will pass as a
753:13 - parameter so just I need I need to
753:16 - remind you that what we are building
753:18 - right here is not the query itself but
753:20 - it's just or are just the filters that
753:23 - we want to um to use so for example uh I
753:28 - want to filter all the authors by age
753:31 - and the name containing or starts with
753:34 - okay so next one I will build a public
753:40 - static again it's a specification of
753:45 - author and
753:48 - then let's say first name contains or
753:52 - starts
753:55 - with and here I need to pass my first
753:59 - name and I will just copy paste this
754:06 - one so here
754:09 - if my first name is
754:12 - null so I need to return null otherwise
754:16 - here I want to do first
754:19 - name and here of course I need the
754:21 - parameter
754:22 - so as you know in SQL contains is not um
754:27 - we don't have such method called
754:28 - contains but we have a method called
754:31 - like so like I want to have this first
754:34 - name to be like the parameter that I
754:36 - want to pass so now we just built two uh
754:40 - specifications or two predicates the
754:42 - first one is has age and it will check
754:45 - that this author has an age that we will
754:47 - pass as a parameter and again we have
754:50 - this first name contain or let's maybe
754:53 - call it first name like to be more
754:54 - consistent with this method right here
754:57 - and this will check that the first name
754:59 - that we will pass as a parameter
755:01 - contains or is like the first name that
755:03 - we have in the database so now let's
755:06 - move on and let me show you how to use
755:08 - this specification class that we just
755:11 - created now let me show you how to
755:14 - execute a specification but first of all
755:17 - let's prepare a few things I will go to
755:19 - the application yaml and here instead of
755:22 - create drop I will make it just update
755:24 - because I want to have some persistent
755:26 - data and I want to check what we have in
755:28 - the database so this is the first one
755:31 - and then I will just uh keep this one
755:34 - for the first time I will execute the
755:36 - application and I will then just remove
755:40 - all this one so I don't I don't want to
755:42 - update uh the ages I don't want to find
755:45 - anything all I need is just to execute
755:48 - it for one time and make sure that I
755:51 - have some data gets persisted so here we
755:54 - see that we have all the inserts and if
755:56 - I check again my table we have the data
755:59 - inserted and then all I will do is
756:03 - comment this out and now I can stop the
756:05 - application and we can now implement or
756:08 - run our specification so in order to run
756:12 - the specification that we created first
756:15 - of all we need to create an object of
756:17 - type
756:18 - specification having a type author and
756:21 - let's call it spec or specification it's
756:23 - as you like I will use spec as a short
756:26 - name equals
756:28 - specification and then do where so this
756:32 - is our work close so the first filter of
756:36 - our work close is this one this author
756:40 - specification that we created so first
756:43 - of all I want to filter by age and first
756:47 - name okay so I want to get all the
756:50 - authors having the age equals something
756:53 - and first name equals something so here
756:56 - I can use author
756:59 - specification dot has age for example
757:02 - let's say 34 let's just imagine and so
757:07 - here we can use and or and or or or we
757:11 - can even pass another predicate but we
757:13 - can rely on and and or so let's say and
757:18 - also again I want to use my other
757:20 - specification and then first name
757:23 - like so for the first name I will again
757:27 - refresh this list and take for example
757:30 - this one okay so I want to fetch all the
757:34 - authors having the name for example
757:36 - starting with or containing this Mitch
757:39 - okay I will say Mi just Mi okay so then
757:45 - once we are done with creating or
757:47 - declaring our specification I will do my
757:50 - Repository do find all and then within
757:55 - the find all method I can now pass my
757:57 - specification as a parameter because our
758:01 - repository already
758:03 - extends or implements the uh jpa
758:07 - specification executor so here I will
758:10 - just do for each and then
758:14 - system.out do print Ln just to print out
758:17 - our result so let's click and draw the
758:21 - application and see what will happen so
758:24 - we see here first of all we have we have
758:27 - an exception and the first thing that we
758:30 - see in here that could not resolve
758:32 - attribute first name and let me show you
758:34 - why so this first name here we said that
758:37 - I want to have the first name like but
758:40 - let's check our author so the author
758:43 - it's first name with a capital N so this
758:46 - is important to have exactly the same
758:49 - thing all right so now I I will run
758:52 - again and check so here we see that we
758:55 - have the select but we don't have any
758:58 - result and you may wonder why I can tell
759:01 - you so when we use the keyword like when
759:04 - uh in the SQL when we use this keyword
759:07 - like we should always use like and then
759:11 - it should be like this so it should be
759:13 - percent percent and then our filter
759:16 - right here okay so this is what we are
759:18 - missing with the first name so we need
759:21 - to do something like
759:23 - this and then I will add percent in the
759:27 - beginning and percent at the end so we
759:29 - need to surround this first name the
759:32 - variable that we want to pass with a
759:34 - percent percent okay so whether we do it
759:37 - here or you can do it when you pass this
759:40 - parameter like this but it's better to
759:43 - put it in the in the specification
759:46 - because like means that we have
759:48 - something like this okay now let's run
759:51 - again
759:52 - and we still can't see our data let's
759:55 - first check uh the author so we have our
759:59 - Mitch right here and let's go back yeah
760:03 - but Mitch yes that was the the problem
760:05 - but Mitch is 22 years old and we don't
760:08 - have any other Mitch within the same age
760:11 - so now I will just change this one to
760:14 - 22 and run again the
760:17 - application so here we see that we have
760:20 - at least one one result which is this
760:23 - guy called Mitch Mitchell and so on so
760:25 - forth and having the age 22 so now for
760:28 - example I want to first to search only
760:32 - for um I want to search only for the
760:36 - authors that the age is 22 so I just can
760:40 - comment this out and run my application
760:43 - again or execute my query again and this
760:46 - one it will filter all the users that
760:49 - they are 22 years old or also I can do
760:53 - something
760:54 - else so here instead of and I can say or
760:58 - so find all the authors uh that are 22
761:02 - years old or the name is like or
761:05 - contains Mi so let's run again and check
761:09 - the specification return type so here we
761:12 - see also that we have these two elements
761:15 - so this guy is 22 and we have the first
761:17 - one is Mitch and then we have this paita
761:20 - so for example also if I just let's just
761:23 - play a little bit with um with the
761:27 - variables that we pass and here I want
761:30 - to filter all the authors that the first
761:33 - name contains the letter I and as you
761:35 - can see here it's an i it's an i it's an
761:38 - i and so on so forth so this is how you
761:41 - can create Dynamic queries and also the
761:44 - best part of specifications is you can
761:48 - reuse all these methods that we created
761:51 - all these predicates or all these
761:53 - specifications are reusable and you can
761:56 - reuse them to create Dynamic queries
762:00 - okay so for example if you have a search
762:04 - or complicated or complex uh search
762:06 - query you can use specification in order
762:09 - to prepare and in order to create your
762:13 - query in
762:15 - advance

Cleaned transcript:

welcome to this immersive course on springing Boot and spring data jpa two pivotal Technologies in modern Java development spring boot simplifies the process of building Standalone production grade springbased applications with minimal effort while spring data jpa is a powerful tool for simplifying data access operations in Java applications seamlessly integrating with databases Bali Ali designed this course to provide a comprehensive understanding of of both Technologies welcome future spring boot masteress are you ready to embark on an Epic Journey Through the word of spring Boot and spring data jpa join me for an immens of 13hour tutorial where we domestify the complexity and unlock the full potential of these gamechanging Frameworks why spring boot well in today's market it stands tall as one of the most s after Frameworks mastering it can truly be a GameChanger for your career consider this the demand for skilled spring boot developers is soaring and it shows no signs of slowing down top tier companies worldwide are actively seeking professional like you picture Landing that dream job or better yet forging your own path to success armed with spring boot expertise so how do you grab these opportunities it's just straightforward join me on this course now let's take a sneak peek Into The Incredible Journey that you're about to embark on so this course is composed of two main parts first of all spring boot where we will discover and unreal the secrets of spring core spring boot dependency injection spring profiles magic restful apis data persistence dto pattern robust service layer data validation techniques testing Paradigm mokito and much much more then embark on a journey into the heart of spring data jpa where you'll gain a comprehensive understanding of repositories relationships and the Art of playing with inheritance Del into the intricacies of embedded entities ID generation and master the art of querying data with named queries and specifications and of course much much more than that we will dive deep into the magic and learn the ins and outs of spring data jpa and raveling the secrets of repositories relationships and inheritance from embedded entities to Advanced querying with specifications we cover it all get ready to take your data persistence skills to the highest level before we dive in I would like to invite you to join me on my YouTube channel where I publish exciting and engaging content every week join me there and be part of the Great Community we are building right now you can find all the links in the description of this video as well as this is the ID of my YouTube channel finally a big shout out to free code camp for giving me the opportunity to share this awesome content with you guys and I'm really honored that my video will be here to help you improve your skills now with no further Ado let's get started what is spring framework the spring framework is an opensource framework for building Enterprise Java applications spring aims to simplify the complex and cumbersome Enterprise Java application development process by offering in a framework that includes Technologies such as aspect oriented programming dependency injection plain old Java objects and so and so forth even with all these Technologies spring is a lightweight framework that can be used to create scalable secure and robust Enterprise applications at a micro level we can consider this spring framework a collection of subf Frameworks such as spring web flow spring MVC spring orur and so and so forth core features of spring framework the ioc container or the inversion of control cont container ioc container is one of the core features of spring that provides a streamlined way to configure and manage Java objects this container is responsible for managing the life cycle of a defined Java object significantly increasing the configurability of a spring based application ioc use dependency injection or dependency Lookout patterns to provide the object reference during runtime aop aspect oriented programming aop aims to provide more modularity to the Cross cutting concerns which are functions that span across the application such as logging caching transaction management authentication and so and so forth and then data access framework so spring simplifies the database communication process by providing direct support for popular data access framework in Java such as jdbc hibernate Java persistence API also known as jpa additionally it offers features such as Resource Management exception handling and resource wrapping for all the supported data access Frameworks further simplifying the development process finally we have spring MVC so the spring MVC enables developers to create applications using the popular MVC pattern it is a request based framework that allows developers to easily create customized MVC implementations that exactly suits their needs the core components of the spring MVC is the dispatcher seret class which handles user requests and then forward them to the correct controller this allows the controller to Pro process the request create the model and then provide the information for the end user via a specified View Spring beans a spring Bean refers to an object that is managed by the spring framework in a Java application the term Bean is used in the context of the spring framework the spring framework creates these beans manage their life cycle and organizes their dependencies with other beans it takes care of the instantiation configuration and wiring up of objects saving developers from a lot of manual work also the spring beans can be configured using XML Java annotations or Java code life cycle of a spring Bean first let's understand the life cycle of an object so the life cycle of an object means when and how it is born how it behaves Liv throughout its life and when and how it dies similarly the bean life cycle refers to when and how the bean is instantiated what action it performs until it leaves and when and how it is destroyed so the bean life cycle is managed by the spring container when we run the program the first of all the spring container gets started after that the container creates the instance of a bean as for the request and then dependencies are injected and finally the bean is destroyed when the spring container is closed now let's see how we can configure a bean so first we can use the configuration annotation which declares a class as a full configuration class and here you need to note that a class must be nonf final and public also we can use The atban annotation which declares a bean configuration inside of a configuration class and the method must be nonfinal and non private so it can be public protected or package private and here is an example so we see we have the app config class annotated with the ad configuration annotation and inside it we have a payment service which has The atbin annotation so this will return a new payment service implementation and we can pass any other dependency for example in this case we have the account repository as a dependency for the payment service implementation B Also let's see a full example where we can declare multiple beans so again we have the app config class annotated with the ad configuration and inside that we have a payment service Bean we have account repository bean and a data source Bean so the data source will return the data source connection to our database for example or our data source and then we have in the middle the account repository which is also a bean that takes a parameter or as a parameter the data source Bean that we already created and finally from the top we have the bean payment service that takes the account repository as a dependency and spring will manage all that so spring will know that we need to create a data source first and then pass it to the account Repository and then we create the account repository bean and pass it as an injectable Bean to the payment Service Spring component sample so the spring component contains class level annotation that marks a class as a spring component using the add component annotation so the Constructor dependency injection is automatically done using the ad a word by injecting the Constructor parameters so the autowired on Constructor is optional if there is only one Constructor and here we see an example so we have our payment service implementation class which is marked as a component so this means that we want to mark this class as a spring bean and then we have a private final account repository which is refers to another spring bean and we have a Constructor payment service implementation with The annotation Auto and we have or we pass a parameter of type account repository and then we assign the local or the the class instance account repository we assign it to the account repository that we get as a parameter from The Constructor so in this way we are injecting via the Constructor the account repository bin into the variable or the local variable account repository spring components so spring provides component stereotype to classify classes as spring components the subtypes are available as a refinement for the standard components so the component annotation as general component annotation indicating that the class should be initialized configured and managed by the core container also at repository at service and at controller as meta annotation for the components that allows to further refine components own stereotype annotation can and should be defined to support General architecture principles now let's understand the bean naming so here assuming that we have this configuration class that contains the three beans that we explained already before payment service account repository and data source now we see that in the data source Bean we provided a name we call it the S so now let's see how spring is going to name these bein so first when we talk about the first Bean payment service which returns a payment service object so this will give it a name or a bean name payment Service as for the method name the same for the account repository if we don't provide a name for the Bean spring automatically will use the method name as a bean name so the bean of type type account repository will be named account repository finally for the data source when we provide the name so spring will take that one as a name for the Bean so the data source Bean name will be DS so Bean naming is really important in case we want to fetch or to get programmatically any bean from our application context so now we know how spring names the beans beans injection when we talk about beans injection we also mean dependency injection so the spring framework provides four ways to inject beans so the spring can configure dependencies on different injection elements first we have Constructor injection so the Constructor parameter to receive dependencies during Bean construction so the we call this also the Constructor injection then we have field injection and this field definition to receive dependency injected with the reflection axis also called field injection then we have configuration methods with one or many parameters receiving dependencies through method parameters also called method injection and finally we have Setter injection or Setter method injection so so the Java Setter method are specialized configuration method with only one parameter and a defined name scheme called also Setter injection so the injection Target can be referred using two different modes type injection injects an object of matching type or name injection injects any object by name Constructor injection so here let's first see the example of uh the case of a service so we have here a class uh called default payment service that contains uh a final account reposit itory and then we have the Constructor default payment service so in the default payment service Constructor we are declaring also an object or we passing a parameter of type account repository and like that spring will be automatically injecting this account repository being then we have for example in case we have a repository so we see that we have a jdbc account repository implements account repository so then we have a final or private final data source and then we have the Constructor gdbc account repository and we pass also a parameter which is the data source and then spring will automatically inject that using the Constructor also for injecting beans we can specify or we can tell spring which Bean to inject and for this one we can use the The annotation called qualifier and here let's see an example so here we have a class called application config annotated with a configuration and inside that we have two beans of the same type so two beans are of type account repository and we have a primary and a secondary so this means that we will create two beans the first one will be called primary and the second one will be called secondary but these two beans are referred by type which is the account repository so here we can give a qualifier for each Bean so the first one we will call it or we give it a qualifier primary and the second one we will give it a qualifier secondary and when we want to inject one of these beans we can also on the class level or for example the service level let's say we have the default payment service and we want to autowire or to inject a bean of type account uh repository and here we want to choose or we can choose which Bean to inject so we can use again the qualifier annotation on the ser service or the object level and as we can see in the default payment service Constructor we are telling spring that we want to inject the bean that has the name or the qualifier called primary so this is how we can use the qualifier annotation to inject the bean also if we want to to define a bean as primary we can use the primary annotation to Define which Bean should be primary or should be prior or prioritized for springing to be injected so in this case we don't we don't need the qualifier annotation so assuming again that we have the application config uh class uh configuration class and then we have the same two uh beans but now instead of giving a qualifier annotation we can choose which is the primary so for example we have the the account repository primary and then we give it the primary annotation and then when we want to inject a bean of type account repository all we need to do is just to inject it using the Constructor or the field and so on so forth and spring will know automatically that the account repository Bean which is called primary is prioritized Bean so it will inject that one unless we want to change for example we can give a qualifier and then when we use the qualifier so spring will use that one over the primary field injection so field injection allows direct injection into field declaration without Constructor or method delegation but here you need to note that this type of injection is discouraged because it makes testing of component in isolation more complex therefore should only be used in test classes and here is an example we have the default payment service which is a class annotated with ad service annotation and then we have a variable or a field of type account repository and then when using The autowired annotation this means that we want to inject this account repository using field injection method injection so the method injection allows setting one or many dependencies by one method so it also allows for initializing work if needed while receiving dependencies and here we see an example we have our default payment service annotated with a service annotation and then we have a method called configure class which is of type void void and then we have two variables or two feeds which is account repository and fee calculator for example and assuming these two um these two classes or these two objects are beans and then all we need to do is to set The autowire annotation on the method level and then spring will understand automatically Al that we need to inject these two beans so this is what we called method injection Setter injection so the setter injection follows Java bin naming convention to inject dependencies and here we see an example so assuming again that we have a class called default payment service annotated with the ad service annotation and then all we need to do is to declare our field and then use the setter method to inject this Bean so here we see that we have a public void set account repository and then it takes as a parameter account repository and then it's just a classic set method annotated with at Auto wir annotation so spring will understand that this is a Setter injection and it will inject the field using the setter method now let's see the official recommendation for Constructor based or Setter based dependency injection so I copied this from the spring Cod documentation and you can see the link down here so here since you can mix Constructor based and Setter based dependency injection it's good rule to them to use Constructor for mandatory dependencies and Setter for method or configuration method for optional dependencies and here like you can read it uh your on your own and then here the spring team generally Advocates Constructor injection so it's always recommended and it's always better to use Constructor injection to inject your beans into a class Bean scoping so first let's understand what is a beans scope so beans scope in Spring framework refers to the life cycle of a spring bean and its availability in the context of the application so when a bean is instantiated or looked up its Scopes determines its life cycle and which other beans can in can interact with it so the spring provides multiple Scopes to register and configure beans and scoping has an impact on State Management of the components also the default scope model is Singleton means one instance per application context shared instance will be accessed by other components therefore components must be thread safe so now let's see what are the bin Scopes provided by Spring so first of all we have the Singleton and as we mentioned it's the default so this is the default Bean scope in Spring container only one instance of The Bean Is created and all requests of that bean will receive the same instance this is useful for bean that do not do not hold state or where the same state is to be shared by all users or threads then the second one is prototype so this means a new instance is created each time a bean is requested from the container this is useful for beans to carry state that is specific to the uh to other user or thread and thus can't be shared the third type is request so this scope is only valid in the context of web over spring application context for a single HTTP request a new Bean is created for each HTTP request then we have session so the scope is also valid only on the context of webware spring application context of an HTTP session so it's it's different from the request so the HTTP request or the request scope is available for the HTTP request and the session is for HTTP session so this means a new Bean is created for each HTTP session by the container then we have application so this scope is also valid only in the context of webware spring application context for the life cycle of a serlet context so this ban is scoped at the application Level and finally we have web socket so this scope is valid only in the context of webware spring application context for the life cycle of a websocket The Bean Is scoped at the web socket level so Bean scoping is really important if you want to correctly manage your beIN and as I mentioned before by default the bin scope is Singleton now let's see how we can define a scope for specific mean so whether we can specify it by name so for example let's say we have B one annotated with a ban annotation and then we can give it the scope annotation and then we just provide the name of the scope also we can use The annotation to provide the scope annotation for example let's say session annotation so we have a specific annotation for that personally I recommend using The annotation to specify the scope just to avoid mistakes or to avoid typos now let's talk a little bit about some special spring beans so first of all we have the bean environment so the bean environment is an environment abstra abstraction so spring provides an environment AB abstraction to the couple application code from the environment with a support for bean definition profiles that allow different sets of beans depending on the environment for example we have local environment Dev environment Cloud prod and so on so forth also it helps resolving properties for external s sources for example database settings from the configuration file or reading cred credentials from uh CLI arguments and so and so forth environment can also be injected into the code if needed and now let's see an example so here we have the application config class annotated with ad configuration and then we can inject the environment Bean so all we need to do is to create or to declare a field of type environment and then autowired and as you can see we can get for example uh we have uh in this payment service method which is a bean we have a profile so we can read or create a profiles of type cloud and then we can say this. environment. accepts profile and we can pass the cloud profile as an environment and then for example we can also read some property so all we need to do is this. environment. getet property and then the property name so this is how we can use this predefined Bean then we have the bean profiles so a profile in Spring is a named logical grouping that may be activated programmatically or set as active through configuration so this feature is particularly useful when you have beans that should be active or registered and used in certain environments or conditions for instance you may have different configuration for development testing and production environment and you want to make sure that certain beans are only used in one of these environments this is how we can use this profile Bean or the profile annotation we can use it in three different ways first of all on a spring component so here we have the first one is the default payment service class and I want this service to be only available for the profile Cloud then we can use it on the configuration level so I want this configuration to be scanned and and applied by Spring only for the cloud profile also also we can declare the profile on the ban configuration so this means that a specific Bean is only available for the cloud profile also a bean can be active or activated programmatically for example let's see this code right here so first of all we create a variable of type annotation config application context so this is our application context so it it's equals new annotation config application context and then we have the application context and we have a method called get environment and then we can set the active profiles and then all we need to do is just to provide the profile name then we need for example if we have a different package to scan so we said also application context. scan and then we can provide the base package and then of course don't forget to refresh so spring will refresh its own context and then for example we can get the bean which is available for this Cloud profile so we can get for example the payment service equals application context. gbin and then we pass the service class so also we have another different way to define the active profile so using the properties file so for example we can use the yaml representation and it will be spring profiles active and then the profile name or using the application properties which is also spring. profiles. active equals Cloud so in Spring framework the value annotation is used at the field level or method or Constructor parameter level for expression driven dependency injection this annotation is commonly used for injecting values into variable in a class whether they are Primitives strings or complex types these values can come from properties files system properties or they can be hardcoded and here is an example how we can inject values using the value annotations so assuming that we have an application config class annotated with configuration and then we have for example we want to create a data source bean and for that we need the the URL the username and password of our database and assuming that these properties are stored in in a file called database. properties under our resource folder so first of all we need to inject or to tell spring from where we want to read these property sources and for that we use the property Source annotation and then we provide the class path so the class path will refer to the the resource folder and then we provide the file name so it's it's it's called database. properties for example and then if I want to inject the URL variable or the URL property which is called in my properties file jdbc URL I use The annotation at Value and then dollar and then curly brackets and between the curly brackets is the property name also the value annotation can also resolve Dynamic expression to access other beans or wellknown beans like for example system properties so if I want to get a property from my system properties Bean all I need to do is to use the value annotation and then I use the D uh symbol and then between the curly brackets I can use the system properties and then I read the property called user. region for example to inject the default loc or to look up the default loc from the system properties let's see now some best practices for the spring framework so first of all split configuration so configuration class can be split into several classes first of all to avoid large configuration classes and also to allow splitting classes based on architecture or other drivers so the class can classes can import each other or application context can be constructed with multiple classes and here is an example so for example we have a first configuration class called server uh service config and this one it will configure a beIN of type payment service we have then repository config and this one it it will contain a bin of type account repository and then we have a class which is also a configuration class called app config and then for this app configuration we need the service config and the repository config and for that we can use the import annotation to import the two previous configuration classes so like that we are applying the best practices and we are splitting our configuration into multiple configuration classes and then we can import only what we need so like that we will have a more maintainable code spring initializer provides a simple web UI to configure the project to generate uh an endpoint that you can use via plane HTTP all you need to do is to go to start. spring. AO website and you will have this user interface so the service allows you to customize the project to generate the build system and using for example groovy Maven or or Gradle also you can choose the language whether you want to use Java cotlin or groovy and then you can choose the spring boot version that you want to use so here like at the time of recording this course the most recent version the stable one is 3.1.0 and then we have a set of metadata where we can provide and give the information about the group ID the artifact ID the application name and description and then the base package name then we provide the packaging whether we want to package our application as a jar file or War file and the recommended one is always to use jar file with spring Boot and finally we have the Java version that we want to use for example for spring 3 the minimum required version is Java 17 and if you want for example to use uh to use spring 2.7 something you can use Java 11 or Java 8 so the the project generated by the spring initializer contains a spring boot application and we will have a demo application. Java and then if you run the main method of this demo application you will see an empty spring boot application starting at local host and then the port 8080 which is we need for that case the web dependency at least to be able to run the spring boot application as a web environment spring boot is an approach to develop spring based applications with very less or no configuration it leverage existing spring boot projects as well as third party projects to develop production ready applications it provides a set of starters pal or Gradle buil file which can use to add required dependencies and facilitate Auto configuration also spring boot comes with a lot of Auto configuration so depending on the libraries on its class path spring boot is able to automatically configure the required classes now let's see why we need to use spring boot first of all it comes with Standalone applications and also it comes with embedded servers such as Tomcat or Jetty so there is no need anymore to deploy War files also it it provides opiated starters pal or Gradle depending on your project configuration to simplify the maven or the project configuration generally speaking spring boot automatically configure the spring framework whenever possible also it provides production ready features such as metrics health check and externalized configurations and finally there is no more requirements for XML configuration or any other type of configuration it only needs configuration whenever it's required first of all let's start with creating a new spring Bo project so as we explained before all we need to do is to go to the start. spring. website and you will have this nice looking UI where you can create a new spring boot project so first of all let's choose our uh dependency manager so in this case we'll be using Maven because personally I prefer Maven because I'm so familiar familar with the maven structure and also the XML structure then we have the language so we will be using Java as a programming language for our course and then let's choose or let's select a spring boot version so here as you can see at the time of recording this video the most recent stable version is the spring 3.1.0 but we will be using the 3.0 something so make sure you use the version 3.0 because as for now like the spring 3.1 comes with with some deprecations and even for for the future I assume that companies they will not migrate yet to the spring version 3 even or even the spring 3.1.0 I will make a video explaining why you need to skipe the 3.1.0 all right so let's select the version here and then let's provide the metadata of our project so first first this is the group ID so the group ID refers to the company if we may say so for example let's take meta or like the old Facebook company now it's called meta so for example for the group ID it it will be com. meta so this is the company name and then the artifact refers to the project or to the sub company for example here let's say Facebook or Instagram or WhatsApp and so and so forth so here The com. Meta or like the group ID refers to the company and the artifact refers to the project itself so here I will say com do com. alibu let's use alibu as a group ID and here let's say example okay so here it will automatically use the artifact ID as the project name so let's also keep it example and here you can also provide a description for your project so here it's a demo project for spring boot application so this is also fine with us and also the package name is the concatenation of the group and artifact ID and of course you can update or you can modify the package name and this will be the base package of our application and then we have the packaging what is the the format or the package format of our final application whether we want to use jar files which is Java archive or War file which is War web archive and then we need to specify the Java version okay so the Java version right here if we use the spring 3.0 something or spring 3.1 the minimum required version of java is Java 17 all right so now after specifying this we can move on and add dependencies so as explained before spring boot comes with a set of starters and the starter is already a spring boot application which comes with a lot of autoconfiguration which will simplify our life of coding so here we need to click on ADD dependency and then we can filter or we can search for the dependency that we want to use for example if we want to create a web application or restful application we can filter or like we can search for web and here you will see that we have the spring web starter and as the description says build web including restful application using spring MVC use Apache Tomcat as the default embedded container so for now let's say that we want to use web so I will select this dependency and also we can click and add more dependencies so for example if you need jpa or if we if we want to implement a persistent layer on our application we can choose spring data jpa or for example if we want to use post degrees SQL we can also search for postgress SQL or for example even for my SQL and so and so forth okay so for now let's start with this simple dependency which is spring web and then we will we will see how we can even add manually a new dependency so here you can whether click on this explore button and here you will see the project structure or like the future project that will be generated and as you can see here we have the pom.xml selected and I will explain this in the coming video so now you can close this one and click on generate and this will download a zip file containing the project that we already created so now I will just place this one in my workspace so it will be here and then source code and I will just save it here so now I have my zip file downloaded now let's move on and open this file using anell now start your anell and then click on open so if you have already opened project you will see a button right here called open or all you can do is just go to file and then open all right so this will open a prompt right here and then navigate to the location of your source code and then select the pom.xml so here I have the example dotzip file which is which is I already unzipped and as as you can see here we have this list of files and this SRC folder so all you need to do is to select the pom.xml file and then click on open and then say open as a project and of course trust this one and then start so this will open a window like this containing the project structure that we see right here and as you can see we have this this structure right here so in the next video I will explain everything think but before that I want to show you something so before we start exploring our project and checking the project structure first of all I want to highlight something because so many of you have been requesting and asking the same question about the theme or the UI of my anti J so as you can see here for example if I select this file right here you'll see that it's really nice looking and we have all these icons and so and so forth so this is is part of the newest version of anj and you need to go and activate this UI so what you need to do go to anj and then settings or file settings for Windows users and then go to appearance and behavior and here you will see that you have a menu called new UI and it's in the beta version for now so here you can click on enable new UI and then you have this compact mode that you see in my screen right now so like like this you will have the same UI as me as me and this might be also helpful for you to have a better and a nice looking anj or Nic looking IDE and also it will be easier for you to follow what I'm doing right now so I'm going to click on cancel and now let's go back and and explore our project now before we move on let me show you few things that you might need to set up also your working environment and in order to use enj in a in a in a good way so first let's click on file and then select project structure and in here you will see in the project so here you see the SDK so here you will have a list of sdks that you can use within your project so if you don't have for example the Java 17 all you need to do is to click for example no SDK or you can click on ADD SDK and then you can click on download jdk so so this will provide you a list of the the available jdks for example if you want for example let's say Java 19 and then you can select the vendor or the provider so it's whether Amazon coretto and so on and so forth so you can select that one and here you can keep the location by default so anj will store it in its location like the location that anj will choose and then all you need to do is to click on download and then you will have it in the list right here so like this you won't be prompted or like blocked if you don't have already the SDK or the jdk installed all right so this is an important step for you before we start coding or before we start diving into our code so then click on apply once you download the SDK or or change the version just click on okay or apply and then you will have your SDK ready to use all right now we can start to check out our project structure so here when you create a new spring boot project you will find this IDE idea or uh yeah it's called idea folder which is uh automatically created by anj so we can just ignore that because it depends on your IDE you will have this folder right here and then we have this mvn folder that contains a wrapper and then we have this Maven wrapper. jar and Maven wrapper. properties so this means means that you really don't need to download manually and install manually Maven because when you create a new spring boot project with uh using the using Maven so it it will create or it will download automatically a maven wrapper. Jr file and you can use this one in your command line to run some commands and we will see that later on how we can use this Maven wrapper because for example for my machine I did not install Maven or my machine so I always use the maven wrapper provided by the spring boot project and I would say this is a good approach because like that you are not depending on a specific version which is installed on your machine but you depend on the version which is provided by the spring initializer so then we have this Source folder which contains two main subfolders we have this Main and we have the test so first of all let's check the main folder the main folder contains also two subfolders we have first of all this Java folder where we will have all the Java files of our applications all the classes and object of our application will go into this Java folder and then we have the resources folder so the resources folder contains two subfolders static and templates so the static is for example if we want to put some static files like HTML files or we want to build for example a UI for our rest API that we will be building so we can move or put all the files in here but I really don't recommend that because we need to think rest okay so we need to have a rest API and then if we need we can create a front end using any front end framework and then we have this application. properties files so by default it has the the file extension Properties or we can also use yaml representation so the difference between properties and yaml files is just the representation and the way we write things and the application properties will hold all the properties that are needed by Spring boot or even custom properties that we want to read from our application okay so now let's go back to this com. alibu example and as you remember this is the base package or the concatenation of the group ID and artifact ID so here we see that we have this example application which is a simple class with just a static void Main and it contains a spring boot application annotation so this will be the main class for our application so if you want to start the application all you need to do is to run this file by right clicking and then run example application or just clicking on here or also clicking on this button right here so you have multiple ways to run the application from your ID then we can move to the test F test folder so this test folder this is where we have all the test files that we will create so all the unit tests all the integration test all the end to end test that we want to create for our rest API they go to this test folder so next let's have a look on the pom.xml file so the pom.xml file looks exactly like this I'm going to make it full screen so if we start from the beginning so here is just providing or specifying the XML version and here like we we provide also the project and the XML name space which is Maven Apache org and so and so forth so this is some information that you need and also the schema location and so on so forth and also this is the model version of our project and then we see here that we have a parent tag so the parent tag contains also group ID artifact ID version and roll path so this parent means that this Maven project extends from this parent okay so this means that this spring boot application extends already the spring boot starter parent having the version 3.0.7 which we already specified and selected in our spring initializer and then we have the group ID that we specified which is com. alibu and the artifact which is example and then we have a default version which is 0.0.1 Das snapshot snapshot means it's still under uh under progress or like in progress and then we have the name which is we mentioned before it takes by default the artifact ID you can also change it and then we have the description all right and then it comes uh a tag called properties and here we can provide a set of properties for our application so here for example we have this java. version and you are specifying that you are using the Java version 17 after that comes the the most important part which is the dependencies so we see that we have a tag dependencies and this is a list of dependency so here we see that we have this dependency uh tag so also here we provide the group ID and the artifact ID so for example here it's or. springf framework. Boot and the artifact is the spring boot starter web which is the dependency that we added when we created our project and also by default when you create a new spring boot project you will have always provided dependency which is the spring boot starter test and the scope of this dependency is test so this dependency will be available only when we run the tests also there is something which is really important in here when we use spring boot so spring boot really makes it easy to manage versions so here we don't need to provide any version because here if we check we we have already a property called version and we can provide any version that we want but when we use spring boot we don't need to provide the version because it will automatically extend the parent version so this in case of an upgrade or a downgrade of the spring version you don't need really to worry about the spring boot starter starters dependencies all we need to do is to update this one refresh the project and then we will have our project totally and fully migrated to the newest to the new version that we provided all right so this is the application so now let's start our application and see and try to analyze a little bit what we have so first just click on this button right here or this play button right here and run example application or right click on this file and then run example application or select the file from here right right click and then run this application so it it's up to you to choose the way that suits you the best so here let's analyze a little bit what we have so here we see that we have this Banner right here and I will show you in a few seconds how we can also change that then we see that we have a bunch of logs so here we have a list of info logs and as we can see here starting application using Java 17 with process ID sign something and here also we see that we have no active profile set so then we later on we will see how we can work with profiles so here falling back to one default profile which is called default and even if you don't Prof provide this profile name it will be selected by default then we see Tomcat initialized with port 8080 starting service and then we see that we have started example application in 0.5 seconds and then the application or the Tomcat already started on the port 8080 with a context path which is empty all right so now this is not the most important part first I want to show you how we can change this Banner right here and to make our service or our application looks really nicer first let's go to our browser and here this is uh a cool website that I really like or even you can just Google text Banner generator I will leave you this this link in the in the description of this video and then for example if you type something let's say alibu and then we can choose the font so here I will choose uh this one so I prefer this one this an regular or you can use Al also an regular with Shadow and you can use like you can play with it you can change the character width you can change the spacing and so and so forth okay so here for example if change it to full fitted you will see that it will change and it will be different from one one the other so once you generate a banner just click on select and copy so this will copy this text to the clipboard now let's go back to our application and also I will stop the application right now and reduce this and now in the resources so spring will automatically scan and look for a file called banner. txt so I will create a new file right here and I will call it banner. txt and I will just paste the content here okay so now if I restart my application we will see this Banner showing up instead of the old one so here maybe I will CH change a little bit so let's say spring boot 3.0.7 just something like that and here maybe let's say all right let's just adjust a little bit the spacings and now let's start our application so now instead of the Old Spring boot Banner we see that we have a new Banner which is alibu and we generally use the Banners To Give the the service name so when we start the application we know which service or what is the service that we are starting right here so as you can see we have this alibu and we have the alibu and then the Springwood version for example and so and so forth also we have the same logs as we had before and the application again started on the port 8080 bar which is the default one and we have also the application started the example application Java file in few seconds so let's create our first ban class so here in the the package com. al.ex example right click and then new and then Java class and let's call it my first class for example or my first component or my first service just you can call it whatever you want so in this my first class I will just create a public string it's a method that will just say hello so this method will return hello from the first class or from my first class for example just to know where the message is coming from so now in order to use this first class and call this method called say hello what we need to do for example let's go to our main method and here let's say first or my first class let's call it my first class equals new my first class so all we need to do is to create an instance and then I will use system.out.println just to print out the message so I will use my first class instance object and then I will call the method say hello so now if I run the application we will see that here we have the message hello from my first class but this is not really recommended when we use the spring framework because we are not using the power or the the the core feature of the spring framework which is dependency injection so to do that let me show you how we can and transform this my first class or this simple class to a spring Bean so now going back to our example application class file and here I will create a bean so this is a ban annotation and then I will do public my first class and I will call it for example my first class okay and then when I need a bean of type my first class I need to return a new instance or new my first class instance all right so I will just keep this line right here now let's see how we can if I remove this one so if I remove the instance or the manual creation of the my first class and delegate that to spring so spring will be able to inject and create a bean of type my first class okay so now first of all let's see what this run method is able to return so this run method method will return a a class or an object of type configurable application context so I will just assign this one to a variable and I will call it context so CTX just as a short name so when we run our application it will return a context which is the context of our application so here my first class now I want to get the my first class from the context or from the application context of my spring container so here I will just go equals and then context. get bean so I have a method called get bean so actually we have uh three or four uh four or five methods of type uh called get bean and the first one for example it takes a class then we can pass a name and the required types also also we can pass the required types and object or just a string or just a string name and object arguments and the arguments for example if I say or if for example I need a string for or to instantiate my class and so on and so forth so it's any parameter or any field required in order to create an instance of my object but in this case we can use whether the first one which is just passing the class or we can use the second one which is passing the name and the required type so it will transform it automatically or we can use also the get bean with a parameter string name but after that we need to cast the object to the required class so here since I already know the return type of the type of my bean I will use the first one and then it will be just my first class do class as a parameter all right so here as you can see I did not do anything or I did not create a manual instance for my first class object I just created a bean or transformed this class to a bean so it will be fully managed by the spring framework so now all I need to do is just to restart the application and see if it still Returns the same output or not so as we can see here we have always hello from my first class so now this is the first way or like this is how we can create a bean now let me show you a different way how we can also tell spring that this is a bean so now if I remove this Bean annotation or even if I comment out or totally remove this method right here and try to run the application let's see what will happen so first we have an exception and the exception is saying no such Bean definition exception so this means there is no qualifying Bean of type my first class available in the application context so we are not able to get or to look up a bean of type my first class so why because we just commented out this Bean annotation so when the application starts spring will not be able to find or to instantiate a bean of type my first class so we said or I mentioned before that I will show you a different way or a second way how to use or how to declare a bean in spring so now I will just stop the application for now and then to Mark a class as a spring Bean all I need to do is to add an annotation so this annotation I can use the component annotation that we already spoke about before so when I use components automatically spring will consider this class so when the application starts up and spring starts scanning all the packages and all the classes each time it will see this annotation it will consider the class as a spring Bean so now all I need to do is to restart my application so here if I restart my application we will see that we no longer have the exception and we see the hello from my first class all right so now let me also show you the other annotations that we can use we can use The annotation service and The annotation repositories which as which are uh uh refinement of the component annotation as we mentioned before so we using for example service and if I restart again so we see also that the message is showing up and the application starts with no issues and also if I go to the definition of this service and then click on download source to download the source code of of this class so we see right here the first thing this is like the public interface service and then this annotation or this interface class is already annotated with ad component so in in a different way the service annotation already extends the component so both of them are the same thing so here as also mentioned in the documentation you can also see component and repository so it's the same way if I use also a repository and I go to the documentation I will see also that it's a component all right so whether using service or a component or a repository these are a markdown annotations to mark an object or a class as a spring Bean so I will bring it back to service if I start again the application so I will have my bean and I will also be able to dis display the message that I already return in here in this say hello method as mentioned before splitting the configuration is one of the best practices so first let's start with a cleanup so I will remove this service annotation and I will optimize the import to to remove the unused one so also if I use a shortcut you can use a popup right here telling you what was the shortcut I used to do tou action so now I will go back to my example application right here and then I will open the project and I will create a new application config class so I will call it application config and then I will just take this Bean declaration and move it to the application config so now I will bring back this Bean annotation and of course import it and then don't for forget to add the configuration annotation to your class so spring will scan this class at the startup so now the application configuration is ready to use and again if I start my application I will see that everything is still working as expected so we see here that we have the hello from the first class so now I will also optimize the Imports right here so whether you move it manually or you use the shortcut Control Alt o for uh Linux and windows or option control o for Mac users now let's understand the bean naming in Spring application context so here as we mentioned before to get a bean we can use the class or the object class or we also can use another method which takes the the bin name and the required type so for example here to get this my first class and just to to remind you that in the application config we created a bean we gave it the name my first class so if I copy this name and I go back here and pass this the bin name as parameter and I run the application so spring will also understand that we are looking for this Bean so for example if I change this one to wrong Bean name and I restart the ation it will tell me that there is no such Bean okay so no such Bean definition exception and it says that that we don't have any Bean named wrong be name because by default spring will use the method name or the the method that we created here and we annotated as a bean as the bean name okay so now let me bring this back or let's see a different way how we can name a bean so here we have a bean and for example let's call it my bean and now spring when it scans and and declares this class as a bean it will automatically give this spring Bean or this string bean name as the B name so I will copy this one and now I will use it instead okay so if I rerun the application we see that the application is running and now we are using or we are showing the message coming from the say hello method of my first class Bean okay so now this is how the bean naming Works in springbot also if I go back again and just remove this parameter right here and for example I changed the name to my first my first Bean so I can use here my first Bean as a be name and I can just run the application and it will show the message that we already have in our say hello Method All right so now let's move on and see more things and more features about how to manipulate and work with spring beans now let's extend a little bit my first class Bean so here first I will create a private variable it will be a string and let's call it my VAR for example okay and now I will add a Constructor parameter so I'm just using shortcuts again so so you can see it in here so here I will select the option add Constructor parameter and then it will propose what will be the variable and say do refactor and as you can see here it will we have a Constructor having a string myar and then this myar equals VAR and just I will adjust the say hello so it will be hello from the first class and then let's for example display the myar so it will be myar equals and then just my VAR okay so now we see that we have already one problem so what we need to do we need to go back to the application config and pass this myar as a parameter so here let's say first been and now if I run the application the application will be running correctly and it will display here the variable or the the value of the myar that we passed to this my first ban Bean okay so it says hello from the from my first Bean class or my first class and my VAR equals first Bean now let's move on and dig more and explore more how we can work with beans to better understand dependency injection let's start by preparing the groundup for for it so first I will create a new class and I we call it my first service so my first service as a class and and this one I will mark it as a service and then for this my service I will just create uh a method so I will do public string and then say message or tell story for example so this tell a story it will just use one of the existing services or the existing beans that we have which is the my first class in here to just display the message or like to to make a call to the say hello Method All right so here I will just first need to inject a bean so so all I need to do is to create a private my first class and I will call it my first class so I will make this one full screen and then I will just return so the bean is saying or like let's say the dependency is saying and then I will just concatenate the my first class do say hello method okay so when I run this class and I run this tell a story I expect to have an output in my console telling that the dependency is saying and then we have the hello method or the say hello method that we have right here so now let's move on and understand in deep the dependency injection and the different types of dependency injection now if we go back to our example application class and here let's do some changes instead of my first class I will just try to inject my first service and I will just rename this one to my first service as a variable name and then I will tell spring to get bean I can also remove the name and instead of my first class I will just change it to my first service and here I will just call the tell story okay I will just rename this one so it's service and now if I run the application let's see what will happen so here we have a null pointer exception in the my first class. say hello okay so if I click to check the trace so the my first class is null okay so now I will rerun again in the buug mode so I will just add a breakpoint right here and I will make the later on a special video how we can debug in details so now just click on this debug example application and then when the example application here so first we start by running the application and then we look up or we try to load the my first service Bean which is already a service right here so that's why we are able to load the bean and then we try to call the my first service tell the story and this is when the break point hits okay so we are trying to concatenate this string with the string coming from the say hello method so as we can see here in inj we have already a n pointer exception because the my first class is null why it is null because it's not yet injected by spring because we did not tell spring how to inject this class okay so that's why we have our null pointer except so let's resume the program and now if I go back to the console we see again we have this n pointer exception so now let's see how we can inject a dependency using the Constructor so all I need to do here I will use the auto completion and uh or the code generation and I will ask anj to create a Constructor using this my first class so here I just asked it and now it also anj is is recommending to make my first class Final so we will also add this final keyword so now all I need to do is to add the keyword autowired and this annotation needs to be on the Constructor level so like that when I start the application spring we know that we need to fetch a bean of type my first class the one that we declared right here and it will be assigned to this my first class so since here in our application config we have a bean of type my first class spring will know that this is a bean and then the my first service needs this Bean to be injected so it will automatically injected so now let's just restart the application and now I will just restart it not with debug mode and here we have the magic so here the dependency is saying hello from my first class and my VAR equals first been as we specify it in our application configuration right here so now I guess you are able to link things so this is how Constructor injection works now let me show you a little bit of enhancement that was introduced by the spring framework so now if I go back to my first service I can also remove this breakpoint here with spring boot if we have or if we want to use Constructor injection we no longer need the autowire keyword I will also optimize the Imports so we no longer need the autowired keyword or annotation because spring it will try to inject all anything that is injectable so when the application starts and spring start creating this my first service Bean or uh or service it will first see that in the Constructor we need an object of type my first class okay so it will look up in its context if it finds a bean of type my first class if yes it will inject it so now after removing The annotation I will rerun again the application and make sure that everything is working fine so here as you can see we no longer need The autowired annotation so this is how Constructor injection works now I will go to my application config and create a second Bean of type my first class so I will duplicate this one and I will call it my second Bean so this my second bean I will pass a parameter I will call it second Bean okay so now I have two beans of type my first class now if I rerun the application and try to fetch or to display the message in here I expect things not to work and even ndj is able to highlight this so if I highlight this one it says could not Auto to wire there is more than one bean of my first class type and this is what will happen or what will be displayed in our console so I will run the application and here we see that we have application failed to start and it says parameter zero of Constructor my first service required a single Bean but two were found okay and here it give H it gives us more details so we have first my first Bean defined in my by Method so defined by Method my first Bean in class application config and we have the same for my second Bean so also it gives us some actions so consider marking one of the beans as primary or use qualifier so this is this introduces us to the qualifier topic so now what I will do I can just come here and add a qualified fire annotation and for example I will say Bean one I will copy this and here I will say Bean two so I have the first Bean called Bean one and the second Bean has a qualifier called Bean two so this qualifier doesn't mean that the bean will be called Bean one and bean two no the bean will stay my first bean and my second Bean of type my first class but as an extra information we will give it a qualifi fire called bin one and Bin 2 now if I go back to my first service I can just come here and add a qualifier information to this Bean so for this Bean here I will just tell it to use the qualifier for example Bean one or Bean 2 Okay so let's use Bean two because before we used the bean one and here let's just make sure that we have second Bean as a variable all right so now spring will be able to locate or to load or to inject the correct Bean using its qualifier okay so now if I run the application again so we see that we have the message and now the variable my VAR has a value second Bean which is this Bean right here okay so this is how we can use qualifier to inject a a specific Bean if we have m multiple beans of the same type so as this example right here we have two beans of type my first class so now we just give it a qualifier for the first Bean and the qualifier for the second one and then spring will be able to locate and decide which one to inject also when working with beans we can tell spring which one to inject first so instead of using qualifier so I'm going to remove this qualifier from here and then I will go back back to my application config and I will also remove these two qualifier annotations so for example let's say that I have a third bin right here so I just duplicate the code and I will say this is my third bin and then I want spring for example to inject this third bin so I will just change also the text here so all I need to do is to use the primary annotation so this primary annotation will give a higher priority to this Bean called my third Bean now if I go back to my first service we see that the Highlight from uh from anj is already gone because spring will know that there is a higher Bean of these three beans which are of the same type so when this service my first service needs a bean of type my first class it will look up all the beans and it will choose the this primary Bean as a higher priority bean and it will inject that one so now when I start the application I'm expecting to have this third Bean printed as an output so as we can see here we have this dependency is saying and the bar now is saying third bin so this comes from this primary annotation so like this we can define a priority or higher priority to our beans now let's see dependency injection using field injection so I will keep my configuration as it is I will keep my third Bean as a primary and I will go back to my service now I'm going to remove the Constructor so I don't need the Constructor because I will use field injection so to inject uh a dependency using the field all I need to do is to add the autowired keyword or the autowire annotation to the the property or to the bean that I want to inject also already you can see right here that it's already also highlighted and field injection is not recommended as I explained before it's always recommended to use Constructor injection or Setter injection over field injection so also the the spring Advocates they always recommend using Constructor injection so now if I start the application I will get the same output telling third bin so as we can see right here so now it's telling third bin also we can mix this in the field injection we can mix with with the qualifier so here I will just uh comment out the primary and now I will show you how to use qualifier even without having the qualifier um name or the qualifier annotation on the bean declaration so here we see that we have three beans and now I will use the qualifier keyword or the qualifier annotation and all I need to do is to provide the bean name so the qualifier will use or will try to look up the bean by its name or by its qualifier name if we provide it so for example if I want to use my second bean I will just copy the method name because as I mentioned before when we don't we don't provide a bean name it will take the method as a bin name so now I will go back to my first service and give it my second Bean as a qualifier so if I restart the application I'm expecting to see this second Bean so this is what we see already in here so the field injection also works with qualifiers and also qualifiers we don't need to provide them on the bean level all we need to do is to use whether the method name or the bean name if we provide it so for example if I give a name to this Bean so let's call it for example Bean one and then for I will copy this name and I use it as a qualifier and I restart the application so here we see that we have first Bean instead of Bean 2 because the qualifier will be also using the bean name the next type of dependency injection is Method injection so I will go back to my service right here and I will remove these two I will just do command X to keep them in my uh clipboard and I will create a public void method and I will call it init or inject beans for example inject beans or inject dependencies so this inject dependencies it will take as parameter my first class so here my first class and I will call it my first class and then all I need to do is this do my first class equals my first class so now all I need to do is to add The autowired annotation and here of course because we have three uh beans of type my first class so I need the qualifier keyword right here so I will just remove this one and for example let's say I want to use the qualifier bin one and now when I start the application this method will inject the needed or the required dependencies so let's start let's try it out so here as you can see we have the the message and here we have first been and for example if I switch to the second one and I use this qualifier with the my second bean bean and restart the application we will see that it will print out second bean and it will be the same if also I change the other one so here what happens is spring when each time it sees that we have this Auto annotation it will try to use that that one whether it's a a simple method a Setter or Constructor in order to inject uh the the necessary beans that are required for this class the final type of dependency injection is called the setter injection so all we need to do is to create a set method for uh for our dependency that we want to inject if we have multiple we need to create a Setter for each so here for example if I say set my first class and also I need to provide the auto method and of course here we need the qualifier because we have three beans of type my first class and like this it will be using the setter method to use or to inject this my first class Bean so now if I restart the application I will see that I have the correct output that I'm expecting also if I switch to B one for example it will print out first Bean instead of second Bean so this is what we see if we restart the application and here we have first Bean so this is the final one and this is called Setter injection also as I as I mentioned before always use Constructor injection because this is the best way and the recommended way by the spring Advocates to inject beans or dependencies into a class as explained before spring also provides some special beans so for example we have the environment Bean which is a bean that help us to read some environment properties some environment uh system and also access the application properties and read the properties from there even reading the command line arguments so let me show you how we can read the environment or the system properties using this environment Bean so first I will create a private environment and I will call it environment for that I need of course to create a set and a Setter and add the auto keyword so here I will add Auto so this to inject the environment Bean into my first first service class and then I will just create a method I will just duplicate this one and I will call it for example get Java version so I want to return the Java version used for this project okay so I will remove this one and then all I need to do is environment. getet property and then I know that in the system properties I have a property called java. verion and now all I need to do is to go to my example application when where where I have the main method and I will duplicate this one and here I will just get Java version so now if I run the application we will see that the application will print the Java version okay so here we see that the Java version that I'm using is 17.0.2 for example if I create another method let's call it get Os or get OS name so I want to return the operating system name so it will be os. name so this is the property to return the operating system name and then I will also just display it right here so I will use or call the method getos name and then I will restart the application and I'm expecting to see the operating system name which is for my case the Mac OS X the environment Bean is also capable of reading any property defined in our application properties file so for example here if I go to application properties and I will create a random property or or a custom property so it will be my custom. property and I will give it a value hello alibu students for example okay so now this environment Bean will allow me or can help me read the property from the yaml file okay so here all I need to do I will create um a new method so I will call it read property or read prop just to say uh property and here I will just copy this property name and I will paste it here instead okay so now I will go back to my example application. Java and I will applicate this one and I will just call the read prop method that I just created so here if I start the application let's see if spring is able to read it or not so it's the case so here we have hello alibu students so this means that this environment being we'll try to read the all the properties whether from the system or even if we provide an application or a property declared in our application properties so it will understand and scan also these application properties and like that we can read this custom property before we move on let's clean up a little bit what we created so here I will remove the environment since we already uh saw how it works so I will remove all this code and then I will just move this to the bottom or I will create or inject it in a Constructor so I will add the final keyword here and then I will say add Constructor parameter and here I will also provide the qualifier uh name so for my bean so it will be qualifier and then for example let's say Bean one so this is one of the beans that we have so this is my Constructor and I have now tell story so I will go back here I I will just remove all this so now I will go back also I guess we need to optimize import but yeah I guess we I already did it so now we have our code cleaned up and now we can move on and see what comes next now let's assume that we have another application. properties file where we are storing some custom properties for example I will create a new file right here and I will call it custom do properties so in this properties file I will create for example my prop okay equals alibu let's say okay just just an example now I want to inject this my prop into my first service so normally now you get it if you want to do that all I need to do is here so here I will here I will say my custom property y from another file and then I will use the value annotation and for the value an annotation I just need to use this my. propop as a property name okay so here I'll just paste this one and now let's create a getter method for this one and now let's go to our example application and try to read this one okay so from another file if I start the application so here we see that we have an exception saying that could not resolve placeholder my. propop okay so we are not able to resolve the property or the placeholder called myprop because it's not in our application. properties file because spring is able to scan only the only a file called application do Properties or yaml so now how to provide or how to tell spring that I want to read properties from a different file okay so all I need to do I go I need to go to the class level right here and here I need to use an annotation called property source so here we see that we have property source and property sources so I will use the first one and here I need to provide the class path so I'm going to make it full screen again so it's class path and then custom because we called we call the file custom do properties okay so now if I run the application let's see what will happen so we see right here that we have this message from the previous implementation and then we have hello alibu students because the hello alibu students is coming from the application properties and also we have this int which is is 1 to three and now spring is able to read the custom property from this customproperties file because here in this class we told spring also to load the properties coming from this file right here so if we provide a wrong file name of course we will get an exception so now let's duplicate this one so let's say custom file to for for example and here let's say my prop do2 and here let's say hello alibu okay so now I can inject multiple files so here instead of using property Source I need to use another annotation so it's just property sources and this property Source it takes a table of type property sources so here I will provide the the table so it will be a property Source this one and then the same again but here I will call it custom file das2 okay so here I will duplicate this one I will call it uh read property from another file to just an example and here I will just move the value and make prop do2 because this is the value or the property that we want to read and then all I need to do now just to test this one I will create a getter for this method so now if I go back to my main class and duplicate this one and use the two now if I restart the application let's see what will happen so here we have alibu coming from the customproperties and we have hello alibu coming from the custom file to so in this way we can inject multiple property sources and we can tell spring to use that one to load the properties that we need what we will see now is how we can inject a property from our application properties into our Java class so for example let's say here I have a private string custom property and I will just create a getter for this custom property okay so here create a getter for custom property and I will use this get custom property just to display this custom property in my main class so here I will just use get custom property if I run the application right now so by this custom property I want to read this one okay so what we see right here we have a null value because we did not tell spring how to read or that we want to read this custom property so I close this one now I will go back to here and then what we can do to in order to inject a value from our application. properties file into a variable whether it can be string or an integer or something like that so we can use the value annotation okay and the value annotation it takes as a parameter a string which is the value so the value should be in this in this way dollar and then curly brackets and inside the curly brackets so I can use my custom property so like this when the application starts up and spring starts initializing the beans and the the components anytime it sees that we have a value annotation it will try to read this property from the application. property or the application.yml file so now if I restart the application I'm expecting to see uh the message coming from here so it's hello alibu students for example let's go and let me show you that we can inject also other values so here I will just duplicate my custom properties my custom property and then I will say it's an INT and here for example let's say 1 2 3 okay so now if I go back here and I will just duplicate this one and I make it as an INT and here I will say it's an integer okay so I'm going to make this full screen and then I will also use the same uh value annotation and here instead of property I will say do int because this is what we created in here and now I will create a get method for this one so create getter for custom property int and here I have the get customer property int so here again I would just applicate this one and call this int so this is just to show you that spring is able to convert types so if I restart the application we see that we have alibu students and one to three and for example if I do one to three and with the string and reside the application let's see what spring will do so here we see that we have a number format exception so here spring was not able to cast this string to an INT okay okay so you need to be really careful with that so if you uh it depends on the property that you want to inject you need to have the correct or the exact exact type spring profiles provide a way to segregate parts of your application configuration and make it available only in certain environments they can be used to apply certain Bean definitions conditionally for example different beans might be registered in development environment versus is a production environment so each profile corresponds to a set of configuration that Define how the application should run in a specific environment so an environment might be a development test staging production or another similar concept the beans that are part of a profile can be registered in the spring application context only when the profile is active this capability can be particularly benefical in several scenarios for example in environment specific configuration you might have certain be that should only be active in development environment and different ones that should be active in a production environment for example in a development environment you might want to use a bean that clears and recreates your database with this data every time you start your application in a production environment you would certainly not want this Bean to be active also uh profiles can be used for component switching you can use profiles to switch out entire entire component or services for example you may have a quick in memory database for development while in production you would use a fullblown database server also profiles can be used for toggling features profiles can be used to enable or disable features if you're developing a new feature that's not quite ready to be deployed in production you can put this in its own profile until it's ready and in the next part we will see how we can work in action with profiles let's see now how we can work with profiles on the level of the application properties so for example here we have our application. properties containing two property my custom property and my custom property int so now in order to create a profile specific application property all we need to do is to create another file called application profil name. properties so what I will be doing I will copy this one and then paste it so here let's say for example I will call it Dev so this application Dash Dev properties will be available or will hold all the information for the profile Dev so here in this application dev. properties I will change a little bit the the values so here hello alibu students in Dev environment okay so here let's skip this one or like let's make it 3 to1 so in order to see the changes now let me show you how to run or how to set a specific environment while running the application from your IDE so here click on this uh Arrow just to have the list here and then click on edit configuration and then you see this is the configuration of your main class and then we see here that we have active profiles so here we can we can set multiple profiles to be active at the same time okay so now I want to set my profile or my active profile to Dev and then click okay so here spring when the application starts it will see that we have an application properties so first of all it will be loading all the information in the application properties and then it will set the active profiles to the dev okay and then what spring will be doing it will be overriding all the properties which are similar in the application Properties or and the application dev. properties so here let me explain it so at the application startup spring will load all these properties in its context and then it will see that it has an uh an active profile and it will check that this property already EX exists in here so it will override the value using this one okay so now let's go back to our main application and we know that we have already something to display this property so all I need to do is to Simply run the application and here we see that we have hello alibu students in Dev environment and also we have the value 3 to 1 so again if I stop the application and remove the active profile from this configuration right here click okay and then if I run again the application it will be displaying hello alibu students as you can see right here also we can change the profiles using the application properties itself so here in the main application. properties so also I want to highlight something it is always recommended to have an application. properties that holds all the common properties of your application and then you can change and override all the properties depending on the environment so here in the application. properties we can also tell spring which profile we want to be active so here all we need to do let's put it in the first line so here we have a property called spring. profiles. active and here this spring. profiles. active accepts a list of profiles with comma separation but in our case we want to set the dev environment as our active environment and that's all now if I run the application we will see that spring will or the our application will be displaying this message instead of this one so let's try it out so if I click on start the application and then we see that we are displaying this also let me show you how it's how it will be displayed in the logs so here we see that spring is detecting that that we have one profile active so it says the following one profile is active which is Dev for example if I said if I set another profile or let's say test for example and custom all right and if I restart the application even if we don't have these environments or these application properties specific for the environments it doesn't matter so spring will not block the application spring will not throw any exception if it doesn't find any properties for that environment because the environment is the developer responsibility so when you set an environment here or if you set an active environment make sure that you have the properties or like the necessary properties and configuration for that environment so here in the logs we see that the following three profiles are active Dev test and custom so here let me show you also something which is really important now I will just duplicate this Dev properties and I will make it test so since we already set an active profile test so here I will just save for the test in test environment so I just want to show you if the order matters or not so now all I need to do is to restart my application and here we want to focus on the output of this one okay so let's restart the application so here we see that test environment okay we are displaying the properties from the test environment and here here here how it works so let me show you in a different way so I will set test first and then Dev and then I will remove test from here and I will restart my application and let's see what will happen so here we see it's displaying in Dev environment so here spring first of all it will start loading the properties from the application. properties and then it will check the first profile and then it will override all the properties that can be overridden and then it will check the next one and again it will override the properties and so and so forth so you need to really be careful about the order for the profiles and also this information can be useful for you in case for example you set some active profiles and you see that a property is not correctly overwritten or is not correctly said so you may want to check the order of your properties the active profile can also be set programmatically so let's do this I will comment out this property so it will not override our configuration and I will close all this and then I will go back to my example application in our main method and here I will externalize a little bit so here I will create a variable app equals new applic new spring application and for this spring application I will just pass the example application. class which is our main class and then all I need to do here is switching up. run and we need to remove this so here after set or after getting the application or the spring application what we can do we can say up do set default properties and for this property we need to pass a map of type string and object so we can use collections do Singleton map and here we can pass the key and the value so the key is the property spring. profiles. active and the value is for example let's say Dev now if I run the application we will see that it will display alibu students in Dev environment and again if I switch it to test since we have also our application test. properties and then if I rerun again I will see student in in test environment so this is how we can programmatically set the active profile in our spring application next we will see how we can also have beans which are available only for a specific profile now let's see how we can make a Bean available only for specific environment so let's go back to our application config I'm going to make this one full screen and now in order for example to make this bin one available only for Dev environment and this being available for test environment all I need to do is to add an annotation called profile and in here all I need to do is to provide the profile name so let's say this one is uh sorry it's profile not primary and let's say this Bean my first Bean should be a available only for Dev environment and again I'm going to duplicate this one and make the second Bean available for the test environment okay so now if I go back to my first service and here I'm using my second bin so if I use for example this bin one in here so now I want to inject bin one in the my first service and then if I go back to the example application and try to run the application and here remember that we have our active profile which is Dev and again just to remind you before we start we are injecting the bean having the ID Bean one so it is this one which is available for the dev environment so now if I run the application we see that we have hello alipo students in Dev environment now if I switch to test environment I'm expecting the application not work because this Bean will not be registered for the test environment so spring will only register the Bean for the profile environment so now let's restart the application and let's see so here as I mentioned before we have an we have an issue so here it says that the injection Point has the following annotation we want to inject a bean qualifier but these following candidates were found so we have my second bean and my third Bean because in the application config we have my second Bean available for the test environment and also my third Bean available for all the environments but the bean one is no longer and is not registered for the test environment or sorry for the test profile which is the active one so we can say environment or profile it's also correct so in this way we understand that spring or if we set a bean or even a configuration available for specific profile it will not be registered for the other profiles so also let's try it out with a configuration in here so also we can set the profile annotation on the class level and here let's say these all these configuration should be available only for Dev so I can remove all the uh all the profile annotations from here and this means that I want to inject this profile or this application configuration only for the dev profile so here if I go back to example application I'm expecting again to have or to get the same issue but now we should not also see this one okay so let's try it out and see what will happen so here we see that again we have the same issue or like the same explanation that injection point this means that spring is looking for a bean with a qualifier Bean one but here it says that we did not find any other Bean of the same type okay so it's already mentioning consider defining a bean of type com. alibu my first class in your configuration so here if I go back again and change the active profile to Dev in here and rerun the application so the application will be up and running correctly so here you need to be careful how you how to define your profiles so now you understand that when you define a profile or you set the annotation profile on the class level this means that the whole class will not be registered if you set it on a method level this means that the specific method will not be registered when the application starts up rest stands for representational State transfer it's a software architecture style that defines a set of constraint to be used for creating web services these web services are often called restful apis or restful application programming interfaces if they adhere these constraints rest was first defined by Roy fien in his 2000 doctoral dissertation the main idea behind rest is to treat networked resources as object that can be accessed us using standard HTTP methods such as get post put delete Etc and here are some of the fundamental elements of the rest architecture first client server architecture this principle establishes that the client and the server should act independently they can interact with each other but each side can be developed and updated independently stateless each HTTP request that happens from a client to a server should contain all the necessary information to understand and respond to the request in other words the server should not store any data between requests which keeps each request isolated and independent then cachable restful architecture allows client to cach responses responses must implicitly or explicitly Define themselves as cachable or not prevent clients from reusing outdated or appropriate data in response to further request then layered system the architecture allows for layers within the system architecture a client cannot ordinarily tell whether it is connected directly to to an end server or to an intermediary along the way which can include load balancing security measures and so and so forth then code on demand this this is the only optional constraint it allows the server to extend functionality of a client by transferring executable code and finally uniform interface this is a fundamental to the design of any restful system it simplifies and decouples the architecture which enables each part to evolve independently the four guiding principles of the uniform interface are first identification of resources then manipulation of resources through these representations and then selfdescriptive messages and finally the hyper media as the engine of application state or also known as haos so restful API have become a very popular in modern web application development due to their Simplicity scalability State statelessness and compatibility with the web they are often used to create interactive applications mobile applications and web services however they are not suitable for all type of applications and other architectures or protocols such as graphql or grpc might be used to to depending on the specific needs of the application to resume the rest is the web architecture principles unique identification of resources or also known as URI different resources representation hyper Media Link or link of resources stateless communication and finally standard methods such as get post put delete and responses such as 200 404 and so and so forth when designing a restful API there are some standards that we need to follow first the resource should be always plural nouns in the API endpoint and if one instance resource should be retrieved pass the ID in the URL for example we can have have get/ accounts or if we want one single account it should be a get method SL accounts slash the ID or for example for deleting one single element it's delete SL accounts SL2 which is or which represents the ID of the resource that we want to delete in case of nested resources which means resource under a resource the resources should be accessible as follows for example if we want to get the payment from the accounts it will be accounts SL1 which is the account id/ payment and then the payment ID so use the HTTP methods to specify what to do with this resource with the method get post put uh patch delete you can provide crude functionalities the crude stands for create read update and delete use HTTP methods also as known as verbs to specify what to do with this resource with the method get postp delete you can provide crude functionalities and here this is an explanation how we can design our resources for example here if we want to get the if we have slash accounts and this means when we have a get method with slash accounts this means that we want to get all the accounts post this means we want to create a new account put a bulk update all accounts this means we want to update all the accounts and delete this means we want to delete all the accounts now let's see when we have a single resource so when we have account slash the account ID then it's get account with ID one so for the post this should be an error because we should not allow that we post a resource with an with an ID then for the put this means that we want to update an account with ID one one and for the delete it's deleting an account with the ID one then for for the resource for example for the nested resources the SL account accounts SL1 SL payments this means when we have a get verb this means get all the payments for the account ID one post this means that you want to create a new payment for the account ID 1 and then for the boot this is a bulk update all payments for account ID one and the same for the delete this means that we want to delete all the payments with the account ID one when designing restful apis we need to use HTTP methods all also known as verbs so here we have the following verbs that we can use to design our restful API first we have the get method or the get verb this method is used to retrieve data from a server it is a readon operation meaning it does not not affect the state of the resource and then we have the post post this method is used to send data to the server to create a new resource the data is included in the body of the request then we have the put so this method is used to update an existing resource or create it if it does not exist the update or new data is included in the body of the request then we have delete so this method is used to delete a resource specified by a URL then we have patch patch this method is used to apply partial modification to a resource as opposed to the put method which is useful for full updates like post and put this data for the update is included in the body of the request then we have options so this method is used to return the HTTP methods that the server supports for the specified URL it can be used to check the functionality of a web server then and finally we have head so this method is similar to get but only Returns the header of the response not the actual data for example the body so this is useful when you want to check if a resource exists before trying to download it or check if it has been modified when implementing restful apis we cannot skip talking about status codes so the response status code R HTTP status codes are threedigit codes returned by the server as part of the HTTP response indicating the outcome of the request made by the client the first digit of the status code defines the class of response while the last two digit do not have any categorization role the there are five classes ranging from 1xx which is informational responses to 5X x x which is server error response so the first one is informational the second one which is 2xx means success the 3 XX means redirection and the 4xx means client error and then finally as mentioned before we have the 5xx which means that we have a server error now let's move on and check each one of them the first category is the success category which is represented by the code two 2xx so this 2xx has some some codes first of all we have for example the 200 with which means okay so this is the standard response for the successful HTTP requests when you make a get request for example and the server successfully processes the request and provides the requested resources in the response it will return a 200 status code this status code simply means that everything went as planned and and the result data if any exists is included in the response then we have two one created so this 21 status code in indicates that the request was successful and a new resource was created as a result this is typically the response sent after a post request or something or sometimes put if you're creating a resource with that method where a new resource is created and the server based on the data set to the request then we have also a 2004 which means no content the 2004 status code means the server successfully processed the request and there is no additional content to send in the response payload body this is often the response to the delete request put or post request when there is no particular information to send back in the HTTP response body but header is useful in other words it's a way to for the server to say I did what you asked where and we're done so you don't need to go anywhere else this response may also be used when the server doesn't want to return any information like as a result of a delete request confirming the deletion is successful the redirection category also represented by the 3 XX response codes so the HTTP status code for this category will we will mainly focus on one which is the most important and the most used in in restful apis which is the 304 not modified so the HTTP status code 304 not modified is a special type of response that is used for caching purposes when a client sends a request to the server it can include a header such as if modified sense or if non match these headers are used to ask the server to validate if the client's cached version of the of the resource is still up to date if modified since uh use a timestamp to determine if the resource has been updated since the last time the client requested also we have the if non match it also works with e tags or entity tags which is a token associated with a specific version of the resource so if the resource has not been modified since the given date time in the case of for example if modified sense or the entity tag still matches so in this case if non match so the server will respond with a 30 or4 not modified status and not send the body for the response because the client cash is still valid by utilizing a 304 response you can save bandwidth and make your web application Faster by not unnecessary resending resources that the client has already cached so these leverages one of the main principles of HTTP which is the idea of being stateless but still allowing for optimizing through caching client error category are represented also with 4xx so here we will check the most used responses and first we will start with the 400 bad request this status code means the server was unable to understand the request due to invalid syntax this could be malformed request or a request with invalid arguments the client should modify the request before repeating it then we have a 401 unauthorized so this status code means the request requires us user authentication if the user already included authentication credentials then the forward the for 4001 response indicates that the authorization has been refused for for these credentials this could be due to a wrong username password or the user does not have the necessary privileges this status is similar to to the 403 Forbidden but specifically for cases where authentication is expected but has failed or not yet been provided then we have the 403 Forbidden so this status code means the client does not have the necessary permission for the request resource in contrast to the 401 unauthorized response authenticating will make no difference this status code can also be used when the server does not want to reveal exactly why the request has been refused or when no other responses is appliable so for all these status code are part of the 4xx class of HTTP status code which indicates that server was likely an error in the request sent by the client that prevented the server from processing it as a best practice the client should after its request or authenticate and authenticate appropriately based on these responses now let's see an example how a r API looks like when we implement it use using spring boot so here for example we have a payment rest controller and this is the class where we will expose the sources for a payment object for example and in order to make this class a controller or exposed as a rest resource we need to add The annotation rest controller and then as you can see here we have a method so this method will will return a response entity of type payment information so the payment information will be the response body of this method called initiate payments and here as you can see we have a post mapping which is the verb or the HTTP method that will be used to uh in to invoke this endpoint and then it has a value SL payment as explained before the way that we need to name our endpoints then we see that we have a body coming within this request and it's annotated with annotation request body and then we have our business code and then we want to return like the result location which is for example SL payment slid which is the ID that was returned after persisting or saving the payment into our database and then we return a response entity dot created so the dot created this F this method right here will return an H status code for the created representation which is the 2011 and then the body we because we can also return a body within the within the RIS response of this method which is the confirmation that we created before also in addition to that we can specify the response code to this method and this is how it looks like so here we have a response status annotation that we can use so to specify the response stat status of a controller method annotate the method with the response status and then we can give it the status code that we want to return so spring only uses the response status when the marked method completes successfully without throwing any exception in the coming parts we will see in action all what we discussed before server error category so for this class we will see the 500 internal server error so this is a generic error message given when an unexpected condition was encountered by the server and no more specific message is suitable in other words it means that something has gone wrong on the server itself it doesn't provide a clear reason because thereor could be for a variety of reasons such as server misconfiguration or ancot exception on the server side code or a server resource issue like memory depletion then we have the 503 which is service and available this status code indicates that the server is currently unavailable to hand the request because it's temporarily overloading or down for for maintenance generally this is a temporary state it may include an optional retry after header indicating how long to wait before making a new request so both of these status codes are part of the 5xx class of HTTP status codes which indicates situations where the server is aware that it has encountered an error or or is otherwise incapable of Performing the request these types of error are often outside of the client's control and may require attention from the servers operators that's good you made it this far so now before we move we move on to the spring rest let's first clean up our code so what I will be doing is I will remove all the unnecessary classes and I will just leave this example application which is our main applic ation and afterwards we will start implementing our first rest API so what I will be doing I will remove this classes so just select them and then click on delete and then just click okay so you click delete anyway just also okay and then we will clean up the code that we have right here so I will just copy this one and make this Spring Run and then let's remove this and also let's remove all this code and then we need and then we need to pass the example. class as a parameter so now we have our application back as it was and now I will optimize the Imports and also I will remove these properties because we no longer need them we will see them afterwards if we want to work with profiles so now we have our application back as it was now just to make sure that everything is working fine just try to run the application and always we need to check is that the application is up and running as we can see here so the application started on the port 8080 and started example application in some time like it depends on your machine so now we are up and ready to continue with our rist API now let's create our first controller so here I would just right click here and then new and then Java class so here I will call it first controller and then this is the class that will represent our first controller so here in order to make the first controller as a controller that will be scanned by the spring boot all we need to do is to add the rest controller annotation and in order to have this rest controller annotation just make sure that you have the spring boot starter web dependency in your pom.xml or Gradle do properties so now let me first make this one full screen in order to create an endpoint first we need to Define what is the verb or the HTTP method for this point for this end point so let's assume that we want to perform a get method so here we have an annotation called get mapping if we use this get mapping annotation so this means that inside this rest controller we have a get mapping or a get method method so here let's say for example a public string this method will return string and let's say or let's call it say hello and then all I need to do is to return hello from my first controller for example and then of course don't forget to give the your endpoint a path okay so here we can even work without a path so let's let's try it like that and then let's see how we can enhance this so I will run my application so here we also see that the application is up and running now I will go to the browser and as you saw in the logs the application started on the port 880 so to access any get end points using the browser all we need to do is to access the local host and then the port number which is 8080 in our case and then just hit enter so here we have a 404 because we don't have any end point defined on this URL so if I add the slash right here it's also the same so that's why we need to define a mapping for our endpoint so let's go back to our anj and here in this get mapping so I will add slash hello for example okay so this is not respecting the the naming conventions of course but we will see that in details later on so now I will restart my application again the application is up and running on the port 8080 with a context path empty I will explain to you what is this context path later on so now let's go back to the browser and all we need to do is to refresh and here of course we need the slash hello so when I hit or when I try to reach the/ hello endpoint spring will go and we'll know that we have an end point Point called /hello available after or under the default context path that we have and this is the message that we provided with within our endpoint so let's go back to anti J again so here if for example I duplicate this one and I create another endpoint so let's say hello2 and here let's say for example hello to and here say hello to from my first controller and then if I add a response status we will see the difference but before adding the response status let's go to the browser again and inspect a little bit more and see what happens so here if you click on F12 or right click and then inspect so you will have you will have uh this interface and then you can go to network now if I refresh we see and then you need to click on all we see that we have this endpoint hello and here this one let me make it let me Zoom it in so here we see that we have a banch of information so we have the request URL here it's it it goes to the Local Host 8/ hello and the method is a get because we in in our endpoint we defined it as a get mapping and then we have a status qu 200 and also we have the remote address and the bench of other information we also have some response headers which are the default response headers even if we don't specify them also we have a request headers which are included by the browser itself okay so now let's go back to anj and here for example if I do response status and here this response status let me show you how like the implementation or the code of this one what we can pass as a parameter which is the value right here it's an object of type type HTTP status so this HTTP status class it's aam actually contains a bench of methods okay or variables so for example continue is 100 and here for example let's go back and here for example if I search for the 200 2001 you will see that the 2001 is created okay or okay is 200 so the default one is 200 if everything goes fine so now let's play a little bit with with this so let's say that I want to use accepted as a response status for my second endpoint so here all I need to do is to provide an HTTP status. accepted so it will automatically go to this one and return to O2 okay so now let's resp let's restart the application and see the changes so again in the browser if I access the hello 2 and point we see here that we have a status 202 which is the one that we specified before so here it's a get method again and we have a 202 as our status code which is the one that we already specified as an annotation in here so like this we can specify a response status for each method or we can leave it to the default one which is 200 but it's always recommended to specify the Response Code or the response St status as the verb or as the method or as the requirement of our application okay that's good so now you understand how we can create an endpoint and also how we can specify the response status so now I will just clean up this one also I will optimize the Imports and let's create our first post mapping endpoint so for the Post mapping it's always the verb and then mapping so the annotations with spring boot are always like verb and then mapping so post mapping get mapping put mapping and so and so forth so here let's say post mapping and let's give it for example SL poost and then I will just perform a public string post for example and here I will just return request accepted for example or saved or like you can say whatever you want so here for this post mapping we need and as we mentioned before when we perform a post mapping this means that we want to post some data or to send some data from the client to the server so the client in this case is our browser or any other tool that we want to use to perform rest requests so here we need to provide a body for example so the body in here I want for example let's say string and let's say message okay so here I I will just update this a little little bit request accepted and message is and then just message we will just display the message that we get as a parameter okay so now if I if I start my application and I go to the browser and try to hit this post and Point Let's see what will happen so again let's check the server is up and running now if I go back to my browser let me reduce this one and let's try to access SL poost and hit enter so here we see that we have an error message so this application has no explicit uh mapping for error and so on so forth and here we see that we have this post 40 405 and this is because the browser does not support post requests so it does not support post request this means that the browser address bar right here typically sends get request when you enter your URL and press enter so this part of the design and specification of web browser a get request is meant to retrieve a resource which is exactly what you're doing when you enter a URL you're asking to to retrieve and view the web page so the post request on the other hand are designed to send data to server to create or update a resource so post data is sent in the body of the HTTP request not in the URL this is the part of the HTTP specification so now since we are not able to use the browser address bar to send post requests let's see what is the alternative for that now let's see what is the alternative for using or as a HTTP client to send request to our backand server so for this if you are already familiar with Postman you can skip this video and move on to the next part but before that let's first see or let's see or Define what is Postman so Postman is a popular API client that helps developer for build test and debug HTTP requests it's used for API development and testing and it simplifies each step for the API life cycle including design mocking testing documentation and monitoring so first let's see how we can install Postman so it's so simple just go to the browser go to Google and then just search for download Postman you will find the first link which is posting or like which is referring to the Post man.com website and then click on download Postman and get started for free so here as you can see we have or like we can download the app and this is how Postman looks like so also you can change the the theme you can make dark theme or light theme and here depending on your uh on your operating system you will see the download button right here so here for example for my case I have an apple chip or if you have an Intel one or if you have Windows or Linux and so on so forth you can just click and download Postman and then install it so the installation is quite easy and straightforward so now let's go back to postman and start exploring Postman and its different features so this this is how the post manual looks like so first let's start by defining the theme so how you can manage and how you can Define the theme so here you see this Cog right here then click on settings and then you have themes so for the theme you for the theme you can whether choose the system default so it will be depending on the system uh layout and and look and feel also you can make it uh a light version or also you can use the dark one which is the developers preferred theme so I will keep it dark for the sake of this course then what we can see in here we have this plus button this is when and where we can perform HTTP calls to any backend so here what we see we have the URL or we have the URL that we can that we want or the URL of the endpoint that we want to invoke and here we have the list of the supported HTTP operations and as we can see here here we have get post put patch delete head and options so these are the HTTP methods that we already explained and spoke about before and here all we need to do is to perform or like or to paste or type the URL of our API so here we also see that the the history of my uh previous uh URLs that I used in here and so for example if I use one of these and since our API is also available on the Local Host 880 and if I try to reach the hello end point and click on send so we see here that we have the response that we also saw on the browser so also here this is a get mapping and here let's explore what we have in here okay so for depending on the depending on the method or the verb that we want to do we we have a list of uh few things here that we can do for example here we can pass request params and here for example if I have for example I want to pass a parameter as like first name equals Ali for example you see here that it's immediately changing and like doing a binding between this request param or query param and the one right here so for example if I add a second one last name you see that it's also changing in the in the URL or in the in the uh URL address bar right here so here for example if I say bu Ali as a last name you see that it's also reflecting in here so here where where we can pass query params then we have the authorization tab so here if we have a secure back end or secure API here where we can specify the type of the security we have and we can pass the values for it for example if my API is secured with an API key so all all I need to do is to select API key and then I paste like give the key name the key value and where I want to include this one as a header or as a query param depending on how you implemented on your backend then we have the headers tab so the headers tab by default we have few few headers which are hidden these headers are automatically injected and included by Postman or even the browser itself as we saw before so here for example we have the postman token we have the host user agent and so on so forth also if I want to specify a special header that I need for my back end I can also call it for example here my header and then value for example and then we can also specify description so this is where we can where and how we can pass extra headers to our back end and then we have the body so this body tab is mainly for all the requests like of type post put patch and and that's it for the delete I we we don't need to pass any uh any bodies so for example if I have a post request and here I can H or I have different types of uh of bodies so the body can be know this means that I don't have a body for this request which is also valid for some uh for some apis or for some endpoints so I will just clean up the URL and then we have also form data so the form data it's just a key value and for example we can pass a text or for a file in case I want to upload a file all I need to do is to select file in here and then select the file from from my system uh then we have also another type of body which is the URL encoded which is a key value map then we have row which is the part that we will see and we will use later on or we can also pass a binary so we can also select the file and and send it and even also if we have a graphql we can pass the query and the query variables and so on so forth so now let's go back to to this row and here so the the body can be whether a text or JavaScript or Json or HTML or XML and those are the supported body types then we have another tab right here which is the prequest script so Postman also supports scripting so we can before sending the request we can perform a script for example I can perform a script or I can write a script to grab grab some data or to grab a token from somewhere and inject it or save it to an environment variable that that I can use for example in my authorization or even in the header and so and so forth also we have the test tabs so when I run or when I want to test some um to test my endpoint and if everything is working fine I can perform test scripts here so that the scripts are JavaScript based and here like you can see for example that you have some some code Snippets so for example here if you want to test that the status code is 200 all you need to click on that and you will have the code ready to use so also you can refer to the official documentation of Postman and you will understand and you will get everything you want to get started with testing with Postman so here I will just go back to the authorization and move it back to non because we don't have any uh security also I will just remove this test and finally we have some settings this for example if you have some specific requirements for uh for your application or for your backend so this is where you can specify these settings but for now it's not something that which is really important for us and relevant so we will skip this part also with Postman we have a bunch of other features so here we can create Collections and this is the part that we will cover later on when we when we implement the the test part so we have here collections we can create a set of collections which is a set or like a group of the the request that we want to perform and we can have them for example this is one one of the requests of a previous boot camp that I already animated so here for example we can specify the order and the flow that we want to uh that we want to execute within a single collection and also this is this can be part of the endtoend tests later on also we have API here so we can switch to workspace or like to like we need to set up a workspace and here for example we can collaborate with other teams and so on so forth also we can Define environments so environments it's something similar to what we explained before we can work with environments on Postman too so for example let's say I have this uh this URL right here and I can run it on for example on a Dev environment on preproduction on production staging and so on and so forth so I don't need to change or to switch every time the URL from one environment to to another all I need to do is to set up my environment and just click or select or set that environment to the active one also with Postman we can use mock servers so users can create mock servers to simulate API responses which is useful in the early stages of development when the back end is not fully built so here you can you can say for example when you access this endpoint return this and this is what we call mock or mock server and also mocking this is a part that we will be covering in this course later on also we have some monitorings and here we see also the history of all the requests that you perform on Postman so this is a global overview for uh for Postman and now we let's move on and try to test our post method now we can use postm to perform this post request so let's open Postman and let's click on this plus icon and then all I need to do is to specify my EUR my URL so I will use just an old one and then I will clean up so my endpoint is localhost 880 slost as we have it in our back end so here it's a post request so I need to select the verb or the method which is a post and all I need to do is to click click on send so here let's check ah okay so we did not start our backend so let's start it and now let's go back to postman and here because we saw this message uh could not send request so this means that the that the server is not up and running so that's why I had to run it so now let's click on send again and here we see that the response or the answer from our post method saying that request accepted and message is null so the message is null because we did not pass anybody because my post end point is expecting a string message as a body so I need to pass that so as I explained before to pass a body click on the body and then we have the type Pro because all we need to do is to pass a text or a Json uh body or XML it depends on on the body type that we want to expect but in this case it's just a message message so it's just uh a classic test or or a normal test body so here let's say alibu for example and I will click on send again but even if I have my body right here the value of the message variable is always null even I have a 200 okay coming back from my back end so maybe let's change this one to Json and click on send it's still always null let's try with XML or HTML it's always null as a response so let's go ahead and check why this is null let's quickly restart our application in debug mode and let's add breakpoint to the line 19 and then let's send the request again and see maybe there is we receive correctly the value for this message variable and maybe we have something wrong with our implementation so let's jump back to postman and let's click on send again so here we see that we have our breakpoint and don't worry about that about debagging because I will make a full video just to cover how to debug with anj but as you can see here the value of our message is null so this means that we don't have any issue with our implementation this means that we well no no issue so far because maybe we missed something but for this case we are receiving null so this means that we are not able to map or to transform the message or the value of the message we received from Postman or or uh our rest client and we are not able to map it to this variable now let me show you and let me explain why when we work with spring framework we need always to tell spring and to indicate for each step what is the request body what is the response body what is this what is that because spring is smart enough is a complete framework but it will not do the job for us so in this case we need to indicate that this parameter we have right here is a request body or should represent the body of our request or of our method we have right here so in order to fix that what we need to do we need to add one annotation which is a request body so this means this is the body of our request and the request body annotation is used in the spring MVC to bind the HTTP request body with the method parameter it's part of the Spring's approach to build restful web services and is used in the controller layer where the HTTP request is handled so as you can see here we have our request body in our method right here which is already part of our rest controller so now let's restart the application in a normal mode and let's test again and see what will happen so again in Postman if I click on send now we see that we have alibu so here let me explain a little bit what happened so here when we send alibu as a message or as a body for our request then here in anj using this annotation so when we annotate the method parameter with request body spring will use the HTTP message converter to convert the HTT CP request body into the specified Java object so here for example it can convert Json data to the request body into the Java object or if it's for example here uh the case of a string of a simple string it was able to convert anything coming from the from the re the body uh of our request to this string message so here let me show you something else here we see that the type of the body or the type of this row uh object is text now if I transform it to Json and here so here this is how we map or rematch the Json representation so our parameter is called message and then let's give it a value alibu then let's click on send and see what is the output so as you can see so the request accepted and the message it just returned back this object so for us it's a Json because we selected Json as a type in here and we passed an ad Json object but here in our implementation the object is of type string so it it's just transforms this Json representation which is also a string to just string message but if I have a complex object or a Java object in here it will also be able to transform this to the Java object we will see this in details later on now let's assume that I want to PST post an object that should hold the information or the data of an order object this means I want to post the customer name the product name and a quantity to save it or to do whatever logic we need behind so let's go ahead and create such class so here on our base package right click and then new and then Java class and let's call it order dto or let's just call it order for now so click enter and here let's define some Fields so I will have private string customer name and then let's say we have also a private string product ID or or product name it also works and then let's have finally public in quantity and this is the representation of our object that we want to post right now because in the previous example we just so uh we just saw how to send a simple string as object now let's let's see how we can send a complex object to our controller now if we go back to our first controller class and let me make this one full screen and I will duplicate this method and or for the mapping I will call it post order and here instead of having a string message I will request or ask to have the order object which is part of com. al. example the class that we just created and let's call it order okay so here let's say the request accepted and order is and let's simply say our object order dot to string so this is going to be the default to string method let's see what will be the output but first of all let's start our application and go to our Postman and test this one so first I'm going to start the application so we will get this new endpoint ready to use so as you can see the application is up and ready now if I go to postman and here here I will duplicate this tab so just right click on it and here you have duplicate tab so here I will just change the url to post order and then I will change the body so here we have the type it's Json and to represent the object that we created in our backend to ad Json type all we need to do is the is the following so here in the this order object all we need to do is to take these names right here the f names copy them and then go back to postman and here I will remove all this and just paste this so here the name should be exactly the same so no type was in in there and then I will show you how we can perform the types so here for string it should be also in double column so let's say alibu for the customer name and then for the product name let's see let's say for example iPhone and for the quantity since it's an integer so it will be just one and then don't forget to add a comma after each field so now let me format this and now we have this is the Json representation of our Java object so the names should match and then I will show you how we can also if we want change the Json uh property names so we can also do that so now let's go ahead and click on send and see what will happen so here we have this com. alibu example so this is the object now I will restart my application in debug mode and let's add a breakpoint and see what's happening exactly going back to our first controller I would remove this breakpoint and move it to line 27 since here we receive the order object and then I will restart my application in debug mode and then I will go back to postman and click on send again so here we have our order object so let's check what we have we see here that we have customer name is null product name is null and quantity is null okay so I will resume this also I will just go back to my order class and generate the two string method so here just use the autoc completion and here we see that we have this two string method and I want this two string method to include all the fields that I have and then I will click okay so here this will be the string representation of my order class so if I restart again just to make sure that we uh we see exactly uh these two string method or what we expected let's go back to postman click on Sand and then I will resume since I have my breakpoint activated and then let's go back so here as you can see we have null null null but we already sent an object in here okay so we sent values alibu iPhone and one but we see that we have null values so let me explain to you why we have this when when we sent our request containing this request body right here with the following values alibu iPhone and one we saw that the response was containing null values so as we saw customer name was null product name was null and the quantity was there was Zero which are the default values of the types that we chose and this is because we didn't create any accessors for our order class so coming back to this order. Java class we see that we has created private Fields customer name product name and quantity and this is without any accessors so the accessors are Getters and and Setters also known as accessors are mutator methods they play a crucial role in the serialization and deserialization process in the context of a Frameworks like spring and libraries like Jackson which are commonly used for serializing and deserializing data and and uh from formats such as Json so these methods have specific uses so for example the Getters when an instance of an object is serialized into a format like Json the getter methods are called to access the current state of the object the values returned by these methods are then written into the serialized format now for the Setters during this realization Setters are used to populate the field of a newly created object with the data from the serialized format so now to fix the issue all we need to do is to generate Getters and Setters so I will click on generate and here we see that have we have Getters and Setters and also as I mentioned before each time I use a shortcut you will see the green popup right here to to see or to learn which uh shortcut I used so now I will generate Getters and Setters for all the fields that I have right right here so it will be for customer name product name and quantity and then I will click on okay so now we have the accessors so now if I restart my application I can also leave this breakpoint I will restart the application and then I will go back to postman and send again the request so here I will click on send and now let's evaluate this order so we see that the customer name is alibu iPhone and we have also the quantity if I resume the program and go back to postman we see that we have the object that we already sent so now I guess you understand the importance of having accessors while you use object to transfer data from a client or rest client which is in our case Postman or it can be any other application like a front end framework like angular or react or even native JavaScript and you need accessors to serialize and deserialize the object so so now as a Next Step let's see how for example I can customize the name of this Json field so for example I want to have a different name for my Json representation and another different name in my Java object now to specify a different property name and this case can happen for example in case I want to consume or I want to send data to a third party API and the names are not the same as my Java object for example we can have a casee of uh a customer name it might be C name p name for product name and Q for example just for quantity and I want to create a decent and comprehensive comprehensive Java object with customer name product name and quantity and also I want to uh I want Java or my spring framework and Jackson to correctly map these objects so all I need to do is to use an annotation called Json property and this Json property comes from the from the package com. faster xml. jackson. annotation which is the Jackson Library which is used by the spring framework for the serialization and deserialization process so here let's say that this customer name I wanted to have a c name for example to reference or to say that this is the customer name but before going forward let's quickly check the Json property annotation and here in the official documentation of this annotation it says that it marker annotation that can be used to define nonstatic methods as a Setter or getter for logical property depending on its signature and so on so forth so here this is the most important part the default value is empty as you can see in here indicates that the field name is used as the pro as the property name without any modification but it can be specified to nonempty Value to specify different names so here this is what we are doing right now and now let's just duplicate this and specify it also for the second property and I will call this one p name and let's say for example I want to call this as just Q or let's let's leave this one to quantity for example okay now if I restart my application in thebug mode and go back to postman and try to perform the the request let's see what will happen if I leave the properties like this so I'm going to click on send so I can also here uh leave the breakpoint and as you can see we see we have the customer name is null the product name is null but the quantity was correctly mapped so the quantity was mapped because we have this J this Json property right here and it's it has the same name as the Java property of the Java field okay but for the customer name and product name the names are different because we specified this Json property right here so all we need to do I'm going to resume the program right here and I will go back to uh Postman and all I need to do is to change this property to C name and then product name or p name and here also I left on purpose this name right here with a capital N also to see if if it's case sens positive or not so let's try this out also we see that we have customer name and product name as null so yes the answer is yes it's uh case sensitive so you need to be really careful about that so here we have C name with uh small letter or small n or like a lowercase n so I will change this one and send again and we will see that we have correctly the mapping to the correct values that we sent from our rest client so here I'm going to resume the program and also I will show you that we have the correct output right here so now we understand how we can map properties with different names than the Java objects so now let's move on and see more interesting Parts since Java version 14 a new type of objects was introduced which is Java records we can also use records to represent our objects so like we did with this order here it's just a class we can create records to represent our uh request bodies so let's go ahead and try this one so here I will create a new Java class and then select record in here and let's call it order record and within this order record all I need to do is to create or to declare the same properties that we have in here so I'm going to just copy paste them so here here I will use a shortcut to uh to select all the properties just copy and then I will close this one and paste this in here so and then I need of course commas and now I have my record object created so here I have order uh order record and all I need to do is between these parentheses all I need to do is to declare my fields and I don't need any type of accessories like private public okay so now we have our order record ready let's move on and now and create an endpoint that should accept the order or the record as a request body and now if I go back to my first controller and I will again I will duplicate this method let me make it full screen and here I will call it uh post order record just to uh to make the difference and here I will call the method post record and here in this order uh or request body it will be order record Okay so so then I will also use the order. two string method so all I need to do is just to run my application again and check what will be the output of this endpoint so I'm restarting the application and as you can see the app is up and running now if I go back to postman and all I need to do is to change this endpoint to order record and then I will click on send so here we still we see that we have null null null because we don't have the same property names also the Json property works with records so whether we can fix it on the Java side or we just rename this one so what I will be doing I will duplicate this tab and then in the body I will just use for example customer name and also I will just rename this one to product name so like this I don't need to change my Java object so I will click on send again and we see that we have here request accepted and the object is correctly displayed okay so now in this case we saw that we didn't need to create any Getters any Setters we didn't need to do anything for our record okay so here you see that we created three fields and then we created we we had to generate Getters and Setters because we need those ones also we saw that we have we had to override the two string method but for the order record we didn't need to do that let me explain to you in the next part what is the difference between uh poos or plain old Java objects like the older object right here and Records when it comes to data transfer objects whether to use poos or plain old Java objects or records for data transfer objects in Java depends on the use case and the Java version you are using Java records introduced as a preview feature in Java 14 and finalized in Java 16 so there are new kind of type declaration in the Java language a record class is shallowly IM mutable transparent carrier to for fixed set of values values which can be accessed with accessors method that that have the same names as the fields records reduce the verbosity of java and make it make it more suitable for data Centric applications poos have been used for many years in Java for such tasks they are versatile and work with all Java versions but require more code to write you have to declare fields and then you have to write or generate Constructors Getters Setters equals hash code and two string method if you are using Java 16 or later and your dto are simple carriers of data without any additional logic records may be a better choice they provide a concise and convenient syntax and automatic implementation of equals hash code and two string as we saw in the examples previously also you need to note that records are final by default and all their fields are final so they can't be used with libraries uh that require mutable beans such as uh some older versions of hibernate or jpa if you are using a Java version earlier than Java 16 or if you need mutable objects or if your dto need to include logic Beyond uh just storing data pojos may be a better choice so as always the right choice depends on your specific needs and constraints now let's see how we can pass parameter to a method so let's go back to our first controller and let's see how I can pass a parameter to a specific method so here I will just create or copy this get mapping method right here and I will put it in the bottom so this works for any type of uh of methods whether get post put delete and so on and so forth so it's it's appliable and correct for all of them so here let's say for example um path variable this means that I want want to pass my parameter or my variable in the path so to pass it in the path here let's say for example my value equals and then let's concatenate this with the result so then the first thing that we need to do is in this get mapping right here so let's say that we have um a method called hello let's keep it as hello and now I want to pass my variable in the path so this means I want to have something like this so HTTP and then colon SL slash and then Local Host and then the port number slash for example hello SL alibu let's say so this is or I want this one a variable so it can be alibu it can be Ali it can be Buu it can be any variable that I want to pass so here in this case first all I need to do is to have my my variable so it's of type string for example and let's say usern name just an example and now I need to tell spring that this username will come in the path right here or I will receive it in the path of my request so to do that just go here whether you have for example SL hello or you have nothing all all you need to do is Slash and then curly brackets and then for example let's say use user Dash name so like this spring will know that this user name is a path variable now all we need to do is to link this one to this one so here we have two cases so the first one whether I pass the path variable exactly within the same name like the same naming as my variable right here so it will be just like that okay so spring will automatically refer this usern name here to this username right here so here here I will just concatenate my username or the best case which I recommend is to use username for example and here all you need to do is to say that this is a path variable okay and this path variable as I mentioned before whether we use it like this so the path variable is always needed you need always to specify or to add this path variable annotation to the field that you want to map because like this we will mention to Spring that this username right here this variable or parameter that we want to receive right here is the same that we have it here and first we can mention the same name so the same variable name or for example if I have a different one so to use it like this user name here this path variable also accepts a parameter it's called Val so by default it's empty and by default it will take the variable name as the variable of as the variable of the default value so here let's specify it like that and let's say user Dash name so the value we put in here should be exactly the same in here so what I recommend also try to have like correct namings so user name is more readable than for example username like this uh or for example example if you have long complex names always separating them with a dash is much much easier to read so now if I restart my application and go and test this one we will see that we have my value equals the value that we will pass in the parameter so I will just restart in debug mode and then I will go to my Postman and in here I will just duplicate one of these and here I have for example hello slash and then let's say alibu and of course it's a get mapping so let's click on the get so we don't have anybody so we can click on none and now all I need to do is to click Send so here we see that I have my value equals alibu and if I say for example hello or even with spaces as you want it also able to map the value so here this is how we can pass a variable in the path we call it also path variable now let's see how we can pass request parameters now let's see how we can pass a variable as a request param so here I will just duplicate this method just to keep the code and then I will just here rename it to param variable and I will just command this out to keep the same URL so here I will just remove this one so it will be just /hello and here the URL or the final URL will be hello and then like this and then it will be param and _ name or like this is this will be the Pam name equals and then the value so here param value and if I have a second parameter it will be end and param name two for example equals value two just an example okay so now let's transform this username to a Pam or or request param so here all I need to do instead of using path variable it will be a request param and this request param whether we can keep the request param as the this parameter or this field right here or uh sorry it's param not part and or here in the same way as we did before so let's say for example user name okay so if I have another parameter all I need is to do is to duplicate it or to add another request param so for examp example username and here let's say last name and here let's say for example last name and here all I need to do is just to display this plus user last name and this is how it will look like now all I need to do is restart my application and go back to postman and send this request again so when we started the application we have an exception and this is actually is going to introduce us to the next topic that I will explain just later on but for the moment I will just comment out this get mapping right here and I will explain that later on so let's restart the application again and make sure that everything is up and running so here the application started and let's go back to postman and all we need to do is just change this one and as I mentioned before we have user Dash name also you can remark that here we everything every time we Type A parameter and the value it will be reflected automatically in the query params so here let's say alibu and for example a end and then for example we have user last name and then equals for example bu Ali so this is my last name and then let's click on send so here we see that we have alibu and then bu Ali as a last name exactly as we mentioned in our code right here okay so this is how you can and pass request params now let's move on to the next part which is how we should name or how we can name our methods and URLs and how spring is already interpreting that and how requests are dispatched from our rest client to the back end so now let's understand the difference between path variables and request params so in Spring boot path variables and request params are annotation used for extracting values from the URL of an HTTP request they are used in the spring MVC Handler methods and here how they differ so first when we start with the path variable right here so this annotation is used to extract values from the URI path so it's typically used in restful web services where the URL contains a value representing some sort of resources identifier so the annotated parameter in the method declaration is bound to the path variable of the same name so as we mentioned before so here if you have weather Spring is capable of referencing the name that you pass right here as a path variable with the parameter name or the field name or when you use path variable also like you need to use path path variable and you can also pass the name right here to match the name that you have in your url from the other hand when we use request Pam so this annotation is used to extract query parameters from the URL so query parameters are typically used to carry context information for the request and are separated from the URI using the exclamation mark symbol and are chained with the end symbol so in summary path variable is used when a value you want is actually part of the URI while request peram is is used when the value is passed as a query parameter in a spring MVC or spring boot application the framework uses annotations to Define which method should handle which HTTP request so we have the controller or the rest controller annotations are used at the class level to indicate that an annotated class is a controller so Springs component scanning mechanism detects these classes and and create pins of them in the application context so then we have the request mapping annotation or as a shortcut we have the get mapping post mapping put mapping Etc so this one is used as the method level Within These controller classes so this annotation tells spring that the annotated method should handle an HTTP request of a certain type and for example a post get put and so and so forth and when when the application starts up Spring creates a mapping between the URLs HTTP methods and the corresponding controller methods so this is done by a class called request mapping Handler mapping which scans the controller classes and builds up a registry of such mappings so when an HTTP request comes in the dispatcher seret which is the front controller in Spring MVC consults these mappings to determine which method should handle the request so then the appropriate method is then invocated and its return value is used to generate the HTTP response next we will see in the diagram how this is working so now let's understand in action and even a little bit in details how this works so in a springut application or in the rest API application we have some kind of rest clients and it can be a mobile application another rest API or the internet or even Postman as a rest client and then the first step is is sending a request so we call this an incoming request and the first thing or the first object that will receive this request is the front controller which is the dispatcher serlet then the dispatcher serlet will forward the the request to the Handler mapping class the hander mapping object and this hander mapping will consult the mapping registry and it it will tries to find a mapped controller and this mapping registry as I explained before so it will map or it has a registry of the method plus the path plus the path variables and types and it will refers to a specific method of the controller then when it finds match it will return the controller and the meth method that needs to be invocated and then the fifth step it will forward this request to the to the required controller and then we of course have all the business logic goes uh goes along like uh service validation database registration Consulting another API and so on so forth and after that we have the response so the response will go back to the controller and the controller will send back the response to the dispatcher surve and then it will go back to the customer or to the client of this request and this is how it exactly works now let's have a quick look on this so for example if we have a get method with the following path SL s path SL string and then an integer as path variable and for example we have a get s/ ali1 so this is correct then if we have the same path but with a different uh verb or different method in this case for example a post so we have post SL something/ A1 so this is also correct because we have two different verbs so that's why I mentioned here that the concatenation of of the URL should be unique so the concatenation or like the composition of the URL is Method plus path plus path variables and here I mention type because we need to have different types so for example here if in case I have sth SL string SL aner and then even if I pass a different value spring will say that we have uh we have an ambiguity and it it's not able to determine which one to use so you you really need to be careful about that and we will see in action how this works so this is globally how request dispatching Works in Spring boot so now coming back to our first controller class and let's bring this back so here we have a get mapping and then it it has a mapping SLO and in the bottom if you remember we have a get mapping so also it has the same URL so it's /hello and here we see that request perams they did they do not interfere or they do not make a a method unique so now if I start the application I will get an exception telling me that spring is not able to determine or to know which is what so here the error that we have so we have application run failed and the exception here it says that error creating being with name request mapping Handler mapping so this is the class that we spoke about defined in the class path blah blah blah and so on so forth and here it's mentioning that so here in the end of this exception we see that we have ambiguous mapping so cannot map first controller method and the method is com. alibu do example. first controller which is our class and then the method called Pam variable so this is the method that we are talking about and then this method it contains two string uh parameters to a get/ hello because there is already a first controller Bean method com. alibo example and the method is called say hello which is already mapped so in this case we see that this method even the method name is different but spring doesn't refer uh the method names but first the ID or the Unicity is about the parameter and the path so you you really need to be careful about that and even if you get such an example or such an exception you now are able to understand where this comes from before moving forward let's first clean up our code so first I will remove this order record I will create one later on if we if we need to and then I will keep um I can keep this order we might use it but also let's just clean clean up everything and let's restart everything from scratch and for this controller I will just leave the first get method just to have our controller up and working so here I will just leave this get mapping and this post mapping and now let me also optimize the Imports and that's it so now we have our project again clean and we can start from scratch to introduce and to dig deep and deep in this part first of all we need to install all the required softwares to in order to correctly and easily communicate and interact to the database for this course we will be using post SQL as a database management system so for you you can whether uh install postgress SQL on premises this means you download and install the the software or you can use Docker so first let me show you how you can install go to Google and all you need to do is to Type download postgress SQL and then you just select because you will have two or more links like uh the sponsor uh sponsored links but then you need to go to the official website which is 3w postgressql dorg and then go to the downloads page so here you will have the download page for the different operating systems like Linux Mac OS windows and so on so forth and all you need to do is to follow the installation instructions for example for Mac OS here you can download the installer certified by the EDB and so on so forth also for example if you want to use the postgress do app or home brew or and so and so forth the same for Windows just click on the Windows link and then you have download the installer also you can see the versions and what are what versions are available and so and so forth so this is how you can install postgress SQL on premises for your operating system now in the next part let's see in case you want to use Docker let me show you how to install postgress SQL as a Docker image or Docker container running on your Docker machine now if you want to use post agress SQL on Docker all you need to do is to go to hub. do.com so this is the dockerhub website and all you need to do is to search for post address okay so here we see that we have the first image and always try to look or to search for the docker official image so then in order to install it so let's say we want to use the latest version so here we have all the the information we need and here we see that we have this Command right here so all we need to do is to copy this command and here we see that we have this environment variable which is important and which is mandatory in order to make post agress SQL running correctly on Docker so here we have post agress password and you need to provide the password for your P post agress SQL and the user will be postag just like this by default so then I will show you how we can use this in order to connect to our database and display all the data we need so all you need to do just copy this one and run it on your terminal and also make sure you to have a Docker desktop installed on your machine and then you're good to go so I assume if you have Docker and a little bit familiar with Docker so it will not be an a complex task to set up and install a Docker container on your machine now let's see how we can explore our database so here if you have an DJ with the ultimate version all you need to do is to select and click on this database otherwise you can go to view and then you will have tool window and then you will have database right here so just click on it and it will display this bar right here so then in this plus so let me make it full screen so then on this plus just click on you to select a new data source so when you highlight this new data source you will have this popup right here and then all you need to do is to search for the database that you are using so in our case let's search for post digress and then when you click on okay you will have this popup right here so here all you need to do is like to provide the name so also you can for example let's say test just an example so this will be the name of of your data source and then so if you if it's the first time that you are using this tool you will have a link right here telling to download the driver so just go ahead and click click on it but for my case since it's already downloaded so I don't have it anymore then the next step is here we need to provide the information about the host and the port so the host it's always Local Host whether you are running your postgress SQL on premises or on a Docker container so it's always Local Host and the port if you did not change it it's by default 5432 then we need to provide the authentication so these are the username and password that you provided when you installed postag SQL so for my case it's alibu and then alibu as a username and password and now all I need to do is to click on test connection for the database just leave the datab as a database by default which is the postgress so you don't need to changes to change it or if you have different ones all you need is just to select database that you want to connect to so here we see that we have this URL right here and we will need this one later on so I will show you again how we can also retrieve it again so now all we need to do is to click on test connection to make sure that we are correctly or we can correctly connect to our database so make sure you have this succeeded message otherwise you need to check the information or the inputs that you provided in here so now all I need to do is to click apply and then okay so here let's explore together this UI so here this this is the the data source that we call test and here we see that we have a postgress SQL it's one of three and then we have the public schema so here also we can select all the databases that we have or that we will create in this okay so now for the moment we don't have any database selected later on when we create our first database we will be able to select it and display it in here okay so that's it now I will show you if you don't have the anj ultimate version what is the alternative to connect and to explore the database for the students that they don't have the ultimate version of anti J and you want to have a different tool that will help you exploring any database you want so I recommend using a tool called Deaver so this Deaver is an open source and free crossplatform database for developers database administrators and so and so forth so all you need to do is to whether to Google D Beaver or just go to D beaver. and when you click on the link you will have this interface and then you can click on the download link but before going to the download all you need to do like let's first uh explore the the UI so it looks a little bit similar to the UI that we are using on anj so here you have the databases that you can select or the data sources also like U even to connect to a database like you can change the theme from light to dark also uh you can see the diagrams you can see almost everything and even to connect to the database it's pretty much similar as the steps that we follow together this is uh something that I recommend for people that they don't have the ultimate version of antj but for me personally I prefer having everything in one place and in one UI so that's why I I will be using anj for the database but for you it should be the same exactly the same way even if you don't have the ultimate version to work with spring data J jpa and data persistency in Spring boot project all we need to do first of all is to add the required dependency so to add a new dependency we need to go to our pom.xml and then let's make this one full screen and let's add a new dependency in here so after the spring boot starter web here open um a new tag and then you will have the autoc completion dependency so I will click on it otherwise the dependency look looks exactly like this so it's a dependency tag and it contains a bunch of information so we have first of all the group ID and the artifact ID so the group ID for for most of the spring boot starters it's always or. spring boot framework. boot sorry it's or springf framework. boot so then I will paste this one in here and then the artifact is the starter name and all the starters or or the all the spring boot starters they always start with spring Das Boot Das starter and then the starter name and here as you can see in this list we already see that we have data jpa so this is the dependency that we need for our project so let's select this one and then of course it will suggest the the group ID since it's the same one we can also double click it or even ignore that and also don't forget to right click on this uh on this pom.xml and here we have you have Maven and then reload project so this will allow and will tell Maven to download all the dependencies and as you can see here so now anj is downloading all the required dependencies including this spring boot starter data jpa so now if we uh integrate and add the spring boot starter data jpa we can now run the project and see what will happen so let's also explore the logs together and see what will happened so the first thing the application is not running because we have an issue and the issue is fail to configure a data source or a URL attribute is not specified and no embedded data source could be configured so I will explain this in the next video so now we added the dependency and now we can start configuring our database as we mentioned before spring boot starters they leverage Auto configuration whenever it's possible and after adding the dependency for the spring boot data uh starter data jpa we saw that when we started the application we had a failing so here the mention on of the description says failed to configure data source and the attribute URL is not specified this means that we need at least to give some configur uration and some details to this starter in order to autoconfigure the connection to the database and this is what we will be doing in this phase and first of all let's go to our application properties file and here as I mentioned before so let me first clean it up and as I mentioned before and in this course I will be using the yaml representation so to do so you have two options whether to remove this application. properties file and create another one with the yaml extension or all we can do is just rename it using this shortcut and change the properties to yaml so you can use whether yaml or yml okay so here I will click on refractor so now my application file is using the yaml representation so now let's start configuring the connection to our database and to start the configuration first of all we start with providing the data source configuration so with the data source configuration is uh located under spring and then colum and then here you need to be careful so this is a tab it's not a space or it's not three spaces or two spaces but you need to use the tab okay so here for example if I remove it I need to use the tabulation as you can see in the shortcut here and then data source and you see here that we have this autoc completion already so it's spring. data source and then we need to specify the URL as mentioned in the exception that we have so here also we will type URL and we see here already in the description it's jdbc URL of the database so it's not Hikari it's not DBC cp2 and so on so forth so you need to be sure and to be careful choosing the right property so here I will choose URL and then where can I where can I get this URL from so here we can go back to the database and then rightclick on this data source that we uh created before and then click on properties and here we will see that we have this tab again and this window to configure the connection and then the URL is exactly this one so let's copy it close this one and we can also close this and then paste this this one here now let me explain to you what is or like how this URL is composed so here is the connection type so we want to have a jtbc connection which is Java database connectivity and then this is the the database type which is in our case is postgress SQL because we want to use postgress SQL for example if you are using MySQL or Oracle or something like that it will be the exactly that one and then we we need the the host name of our database and in our case since we are using locally uh our database it's not a remote one so it's local host or even you can provide the machine or like the remote machine uh address or IP address and then the port by default it's this one and if you have a different one you can also use it and finally this is the database name and for the database name I will create a database later on and I will call it demo underscore DB and this is will be our database so in the next next phase we will create this database so first of all let's continue with the configuration and then of course within the data source we need to provide other information which is the username and password which are the credentials for uh our database or for spring data jpa to be able to connect to the database and it will be exactly the same as we provided here when we try to connect the first time to our database which is in our case uh in my case sorry it's alibu as a username and alibu as a password so here I will also provide this information so use uh choose username and again be careful it's not Hikari it should be ex directly data source. username and in this case it will be alibu and then password and also choose the second one not hiar okay and it will be also alibu and then we need to tell uh spring data GPA which driver to use in order to connect to the database because as you know to connect to any database we need a driver so here if I choose also driver class name it is under spring. datasource driver class name and here I need to provide the class name for our postgress SQL and in this one we just need another dependency to add to our configuration so let's let's go ahead and add it to add the postgress SQL driver we need to go again to our pom.xml file and then we need to add another dependency so here I will click and add dependency and then the dependency it has an artifact ID which is called postgress SQL or postgre SQL and then the group ID is org. postgre SQL also we can add a scope which is in our case it should be runtime so here this is the scope of this uh of this dependency so it's available on the runtime and then I click on this popup right here or as I mentioned before just right click and then Maven and then reload project to reload and download all the necessary dependencies so now we have our postag gr SQL driver available let's go back and continue with our database configuration so now if you go back to our application. yaml and in this driver class name name if I just type command uh space and here we will see that automatically anj will propose driver coming from org. postre SQL package as a driver class name otherwise you can just manually type orpos SQL do driver and then you will have the driver and in case you don't include or you forgot to include the driver it will be highlighted as uh as a nonf found or a class notfound exception or error right here so don't worry about that in case you forgot to add it uh anj will highlight it automatically so now the first part is ready and now I can start the application and see what will happen so here let's start the application and check if spring will be able to locate and start the application so yes the first part is done so let's check right here and here only thing that we have the database demod DB does not exist so it was able ble to locate the database using the the username and password but it didn't find any database called demoore DB also I want to show you something for example if I change the username and the password or just username or password to provide wrong credentials and restart the application we will see a different exception so here it will say that enable to authenticate so here it says password authentication failed for user alibu DDD so even if I fix the username and provide a wrong password we will see again the same exception uh fatal authentication as you can see right here but this time it will say that password authentication failed for the user alibu so here like we know now we understand that spring is able to connect to the database now let's move on and create our database and restart the application so in this step let's let's go ahead and create our database so in here click on database and on your data source that we created we called it test right click and then we have new and then so let me just make it wider right here so again right click and then new and you see here database so select database and then let's provide the database name as we mentioned before demo andore DB and even you will see the SQL uh query command that it will be executed which is create database and then the database name so click click okay so here we see that we have this demod DB but it says here that no schema selected so all we need to do is to click on zero of three right here and select the public schema which will hold our database later on and the list of the tables that we have so in here we have empty schema for now and we don't have any tables so let's move on and check that so now let's create our first first Java class which will represent a table in our database so I will explain everything later on but first let's start with creating a new class and let's call it student for example and in this case so here the student will hold the information of our student so let's say first our student has a private integer ID so this will be the identifier or the unique identifier of our student also it has a string first name and then a private string last name so let me make this one uh full screen and string last name and then let's say also our student has a private string email and finally a private string H uh sorry the AG should be an INT so here this is the representation of our student so again let's go ahead and generate create some Getters and Setters because as we mentioned before we need Getters and Setters let's click okay and then we need for for example a Constructor if you want to so let's create a Constructor and for this Constructor you let's use all the parameters except the ID so this is how we can construct a student uh using all the fields that we have right here also you can just uh ignore that and we can use Setters later on to create our user so now we have our object student or student class ready let's move on and let's see how we can transform this student class to an entity which will be persistent entity into our database before transforming our class to an entity let's first Define what is an entity so in Spring data jpa the term entity refers to a Java object that is meant to be persisted in a relational database using using the jpa or AKA Java persistence API so any entity represents a table in a database and each instance of an entity represents a row in a table so the entity Fields represent the column of the table and the state of an entity represents the data in a row so to map an object to a database with the jpa we need to annotate with enti and the class must have a no arcs Constructor which can be public or protect protected also it should contain an identifier ID and it's a best practice also to include the table annotation to specify the table name if the table is not specified so the table name default to the class name so spring data jpa uses these entity classes to generate SQL queries and to convert the results of those queries back into objects that you can use in your Java code so the actual database interaction is performed by the underlying jpa implementation such hibernate in our case so in the next next phase let's move on and transform our student Java class to an entity so as mentioned in the previous video we need within uh spring data GPA and if you want to transform a Java class to uh to an entity first of all we need to have an empty Constructor or a default Constructor with no arcs so let's go ahead and generate that one so here let's generate a Constructor and to generate a an empty Constructor just click or select the class name right here and then click okay so now we have our default Constructor let's move on and transform this student class or student Java class to an entity so as we mentioned and explained before all we need to do is first of all to have the entity annotation on the top or on the class level and here be careful the entity is coming or comes from the Jakarta persistence if you are using the spring uh version three also if you are using uh a lower version it will be Java x. persistence so here let's select this one and here directly we see that anj is highlighting the class name and if I highlight and check what is the error so it see it says that the persistent entities to student should have a primary key so we need to specify a primary key every time you create an entity and to provide a primary key it's so easy just go ahead and choose what is the primary key of your class or of your entity and add the ID annotation it's all also coming from the jackart persistence package and now we have our student entity so now let's go ahead and see if we are able to uh generate or to manipulate or to start the application Within These small changes so if I click here to start the application we see that the application is up and running and also let's see if we have any um any logs that we can use uh also we see here like starting the application and we also see that we have some uh some annotations or some logs from hibernate so here it's hibernate version uh 6.1.7 and also it's using the dialect post SQL dialect and the JTA platform implementation which is the no JTA platform and so and so forth so here the application is up and running and if I go to my database and I try to refresh this one and check the public schema also if I refreshed again I don't see anything spring and jpa and the the hibernate implementation of jpa they provide a tool and config configuration to autocreate and to autogenerate the tables within the database so in the next part let's go ahead and see how we can tell spring and tell spring data at jpa to be specific to generate or to autogenerate our database so now to to define the extra properties first I will stop the application and then I will go back to our application. yaml let me make it full screen and then we need to provide few properties so here within the properties we see here that we have spring. dat Source now at the same level of data source it will be spring and then jpa and then we can specify some information so here within jpa we have hibernate and then within hibernate we have this information or this property which is called ddl Auto so this ddl AO or like this mode it stands like the DL stands for data definition language and this is the behavior or like what we want exactly hibernate to do when we start the application so here we have uh five options first we have create this means that it will create the schema and Destroy previous data so you need to be careful when choosing this option this means that every time you start the application hibernate will create a new schema and destroy the previous data so you it's okay on on the development phase or like on the early phases of uh your application development since you don't have the schema fully implemented you can keep it as create otherwise I would say you keep it to uh validate or to update so the next option is create drop so create a drop it will create this schema and then at the end of the session it will destroy the schema so it will remove the whole database so it's like you don't have any database at all so we have also none so this mean that we want to disable this ddl Auto and this is valid uh for example in production mode if we want to use um a database migration tool like Flyway uh or liquid base to manage our database we have update so it will update the schema if necessary so if we don't have a schema it will create it and every time we make changes it will try to update the schema if there is CH changes and the final one is validate so it will validate the schema and it will make no changes to the database so assuming that we are managing our database using a database migration tool like Flyway for example and this option validate it will try to compare the existing database to the representation or to the Java representation in our code and it will validate this one so here let's go ahead and choose create since we still in development mode also we have other properties under jpa so for example we can also show the SQL queries so here when I choose jpa do show sqlquery uh show SQL here we see that by default it's false and then we can change it to true so this means when we run uh the application and we try to execute any query or any method that will interact with the database we will see the we will see the query displayed in the console then under jpa we have also properties and within these properties we have hibernate and format SQL so if we have an SQL query if we don't add this uh format option it will be displayed as a full line otherwise we can format this SQL query and it will be nicely displayed so the property for this one is uh spring jpa properties and then hibernate and then we have format SQL so this format SQL all we need to do is to set it to True also we we have another property which is available again under jpa so it's spring. jpa and here we have database so it's the second option so here this is the target database to operate on so it it's autodetected by default if you want to so hibernate will try or jpa will try to autod detect what is the database that we are using and also we can see it here in the logs so as mentioned here before so here as we can see using the dialect hibernate dialect and then post agress SQL direct so I will also copy this one and then we can even provide provide it manually so we can tell uh jpa that we are using this database to be more specific and more precise also we have another option which is called database platform so the database platform uh it's also so this property specifies the hibernate dialect for the Target database so the dialect defines the specific SQL syntax and features supported by the database in this case we will use this one just the one I just copied from uh from the console and to set it to indicate that the postgress SQL dialect should be used so now we have everything and all the properties that we need for jpa now let's go back again and restart our application and see what will happened so just click on start again and let's check what will happen within our table so first of all if we check the log right here so we see that since we used this show SQL true we see that we have the SQL query right here so this is the SQL query for creating the student table also we have this format SQL true so we have a formatted query all right so now if I go back and check my database in here so select public or the schema or even the database right here and click on refresh and here if we expand we see that we have one table right here so we have a table student and the table student contains all the information or all the properties that we provided ID first name last name email and age so the age is of type integer same for the ID and we have email first name last name of type varar which is the the SQL representation for the string type so now let's move on and see how we can again play more and more with the hibernate on the or the annotations for our entity what if we want to change the table name so by default this entity annotation it will use the class name as a table name but what if we want to have a different one so let's say for example I want to call my table students not just student so in this case we can use the table annotation and it always comes from the Jakarta persistence package and and here we can specify the property equals name and let's have a look on this annotation so here it says that specifies the primary T table of annotated entity so we need to have the entity annotation so additional tables may be specified using secondary table and so on so forth so here if no table annotation is specified for an entity class the default value applies so here for example we have entity and we have the name cast for example for cast customer and the schema we can also specify the schema so by default if we don't add this table annotation it will take or the entity annotation will use the entity name or the class name as a table name so here let's say for example T and score student just to T to say table student and if I rerun the application we will see that the database will change and the table will be again changed so here we see that create table even in this SQL query create table T underscore student so here if I refresh my tables we see that we have a table now it's named the student and also we have the same columns ID age email and so and so forth so this is the use case of this table annotation we also can have extra control on the different fields so for example if I want to change a column name there is an annotation called column and this colon annotation has a bunch of properties so we have name and here the name of the colum so defaults is the property of the field name we have unique notable insertable updatable colum definition table length and so and so forth so here we can specify many properties for the specified colum so for example let's start by changing the name so for example for this first name I wanted to have ccore F name just C to say colon and then F name again like we can use the same annotation for the other fields but let's just try on on only one so here if I restart my application and check again the database here even in the SQL query we see that we have again CF name so if I refresh my table right here we see that we have the first name is now called ccore f name as we mentioned in here so now we have our first name named to ccore F name also we have other properties that we can specify so in case for example I want to have extra or like I want to have some Precision or size so I can also use the length so as you can see here by default so let me make it full screen and as you can see the length of uh of a string by default is 225 so h I bernate will detect that automatically but I can specify for example the length of my first name should be exactly 20 characters and if I restart my application just to recreate everything from scratch we see that here the CF name or the column first name it's a type varar and now the the length is 20 instead of 225 you can increase it or you can even decrease it to have for example if you have some specific cases where you need for some spe specific field or colum to have uh a specific length so you you can use this property length to specify or to provide more Precision to that so here if I if I refresh my table and in the columns and again if I go to C name we see that the CF name is of type varar and the length of this varar is 20 characters so now let's say let's see if we want to have a unique uh um entry for specific column so for example for this email we know that emails should be unique per user or per student or per person so again I can use the colum annotation in here at this level and here there is a property called unique and the unique is by default equals false this means that we can have duplications for this specific colum but if we if we uh change it to Unique true and if I restart the application and let's first check the logs we see that we have here the email is of type varar 225 and after that we see that we have alter table if exists T student and add constraint this is the constraint name it's UK and this is generated uh value and we have this unique constraint for the column email and again if I refresh my table right here let's see what are the changes that we have so we see that we have an email right here and then we have the keys so first we have the T student P key p means primary and key it's uh for key and then we have the unique constraint applied on the email column right here so this is what exactly the result of this SQL query we can also add some extra uh some extra properties and constru brains let's say for example I have right here private string uh let's say just some colum just like that and now I will use the colum annotation and I can specify if this some colon is insertable or updatable let's say for example let's make it updatable true so by default any column is updatable true by default and then I can make it updatable false and we we have a specific or we might have a specific use case for uh a field that should not be updatable which is for example the creation date so we can have a creation date for any field or for uh for our entry in the database and we want we don't want this creation date field to be updatable every time so we can just make it updatable to false and also we have another property which is insertable and by default it's true we can make this insertable false so this means that we cannot create or we cannot insert value for this specific field so now let's stick with this updatable and here let's again restart the application and we will see that we might have another constraint so here if I refresh my table and for the T student we see that we have Sam column which is a varar and then we don't have any keys but hibernate will manage this automatically and will at and it will make this field called Sam colon not updatable in this part we will see how we can play a bit more with the IDS so when it comes to the identifiers of tables and especially when we use uh the type or the the the digit uh digits type which is integer uh float double um also long and so on so forth we can tell spring and hibernate to automatically generate the ID for us and to do that we can use an annotation annotation called generated value and this generated value again it's from Jakarta persistence API and let's have a look on this annotation so if I go to the definition of this generated value and have a look on the on the documentation for it so it says provides for the specification of generation strategies for the values of primary keys so the condition here it works only with primary keys so the gener ated value annotation may be applied to a primary key property or field of an entity of maid super class in conjunction with the ID annotation so we we need to have the generated value always within the ID annotation so the use of the generated value annotation is only required to be supported for the simple primary Keys use of the generated value annotation is not supported for D derived primary keys so we cannot use um the generated value annotation on derived primary keys for example like strings or composed keys so here also there is an important property which is the generation type so the generation type as you can see it's optional and it has a default value which is Auto and then the primary key generation strategy that the persistence provider must use to generate the annotated entity primary key and then let's have a look on the different types of the generation type so here if we go to the to the enam generation type we see that first we have table so the table indicates that the persistence provider must assign primary keys for the entity using an underlying databased table to ensure uniqueness so this means that hibernate will create a table within our schema and it will use that table to store the the IDS of the entities that we want to use again we have another property which is sequence so this indicates indicates that the persistence provider must assign primary keys for the entity using database sequence so database sequence it's something related to a database and it's like somehow like a table where we have a sequence of values then we have the identity so this means that indicates that the persistence provider must assign primary keys for an entity using data database identity column so the database or like the provider will use a database identity column to autogenerate the IDS also we have another property which is called uu ID and The UU ID is for Unique uh Universal unique identifier and this indicates that the persistent provider must assign primary keys for the entity by generating an RFC of type 4122 which is a unique Universal unique identifier and finally we have this one this AO which is always uh recommended and this indicates that the persistence provider should pick an appropriate strategy for the particular database so this means that when we when we set it to AO which is the default one hibernate will check within the within the database provider or the persistence provider and in our case for example it's postgress SQL and it will choose the appropriate and the best uh generation strategy for our database and here there is something which is really important so the autogeneration strategy may expect a database resource to exist or it may attempt to create one so it will attempt to create the resource for example let's say it uses a sequence so the auto uh the auto strategy will try or will attempt to create this resource if possible if not it will raise an exception telling that it's not able to create this one and for example I can give you an example from my my previous experience so Oracle databases they work with sequences and you need to manually create the sequence in order to use it as a generation type so now let's go back to our code and let's restart the application and see if we have any changes so first let's check the logs and as you can see first we have this hibernate uh query that was executed which is create sequence T student sequence starts with one and increment by 50 so here hibernate created a sequence called it tore student uncore sequence or seek to uh and it starts from one and the incrementation is done by 50 and then we have the table and we have the unique constraints that we that we added so now if I refresh again my tables we see that we have the student and now we have one sequence packet or a folder that was created if I expand it we see that we have a t student sequence which is of type big int and this is just a sequence as as you can see in the icon right here so now let's hit with this with the annotations that we can use within our entities now let's move on and see how we can persist data into the database and how we can perform uh queries like inserting reading updating deleting and so and so forth so when it comes to data persistence and to persist data in uh in a database spring provides us with a list of interfaces that we can use to simplify the life of developers so spring provides an interface called repository and this interface is extended by multiple other interfaces and we have here for example we have this repository and we have the crude repository and list crude repository and also on the left hand side we have the paging and sorting repository and list paging and sorting repository and all of them like the the basic one or like the first one is jpa repository which extends all these interfaces so if you extend or if you use the jpa interface or the jpa repository interface you have access to all these interfaces right here and all we need to do in order to to access or to have a data access layer in our application is to create an interface and extend one of these five interfaces that we see right here which is whether jpa repository list crude list paging and sorting crude repository or paging and sorting repository so each one of them comes with a list of methods predefined methods that we can use to operate or to to execute some SQL queries so the jpa Repository uh is designed to simplify the development of access layer code by abstracting away the common data persistent operations so it provides methods such as save find one find all delete and more allowing you to interact with underlying database without writing explicit SQL queries so this is the important thing and the important part of using jpa repositories or using the repositories from the spring data jpa and the jpa repository interface comes with some features first we have the crow operations Crow stands for create read update and delete which inherit inherits from the basic crud operations from these interfaces we see right here enabling you to perform standard database operations like saving entities retrieving entities by ID deleting and finding all entities and so and so forth also so we have query methods so jpa repository supports the creation of query methods based on method names by following name and Convention you can Define method signature that automatically generate the appropriate SQL queries for example if we want to have a method F find uh by first name and we provide the string first name as a parameter or find all by age uh greater than in age and so and so forth both so this can be implemented without writing explicit queries and we will see later on by example how we can implement this also we have the derivate query methods so along with query method based on method names jpa repository supports the creation of more complex queries using derivate query methods so this method derive the query based on the structure of the method signature and the names of the parameters so this allows you to Define queries with conditions and join multiple entities together we can also have a custom query definition so in addition to the query method the jpa repository allows you to Define custom queries using the at query annotation or the query annotation and you can write J jpql which is the Java persistence query language or native SQL queries and map the query result to The Entity or a custom dto that you want to return so by utilizing this the features provided by the jpa repository you can significantly reduce the amount of boilerplate code required for data access operations and Leverage The Power of query derivation and handle p pagination and sorting with ease in your spring data jpa based application so now let's move on and see in action how we can create uh repositories and how we can generate methods and how we can even persist data to create a repository all we need to do is to create a new interface so select new and then Java class and select interface right here and let's call our interface student repository so in this way we are creating a new interface and to transform this student repository interface to jpa repository all we need to do is to extend the jpa repository and the J APA repository is a generic uh interface and let's see here click always on download source to see everything and all the source code and here we see that we have a t and ID so the T represents the entity and the ID represents the identifier of our entity so let's go back here and provide these types so here this is a jpa repository for our student entity okay so this is like from the name but here like our goal is to create a repository for our student object so select the student here and then comma and the type of the ID so in our case the type of our unique ID of this student table is integer as you as you can see here so we have Inger ID annotated with the ID annotation so this is how you can identify or you can check the ID and that's it that's pretty much it and here even you don't need to add any repository or any component annotation because spring data jpa will automatically understand that this is a repository and it will transform this uh this interface to to a managed be or to a component or to a repository all these names are valid for the jpa repository so now let's move on and use this jpa repository and try to persist some data now in order to use this student Repository all we need to do is to inject it somewhere in some class or in another spring bean and let's inject it in this first controller so I will make it full screen and here I can also even clean up this one and here I will create a private final student repository and let's call it repository or even student repository and then we need to generate of course a Constructor parameter and here we see that we will use the Constructor injection so as I mentioned before we no longer need to use The autowired annotation so here we have our repository available and now we can just use it so here in in this post method so let's say slash students and like to follow the namings so now we have our first controller and I want to use the post for the Post mapping SL student and here as a request body let's change this one to type student okay so here we have the student and I will just rename this one to student so then it will not return a string but I wanted to return the student object instead so here it will return the student so I we will go back to this later on and here all we need to do after receiving the student object all we need to do is to call the repository instance that we created and then we have a method called save save so the save it takes an S of type entity so here if I pass student so this means that the student will be persisted and as you can see this method it will it takes the entity as parameter and it will return the same entity of the saved one so all I all I need to do is to just return repository Dove and now let's start the application and go to postman and start this and test this method so this is our Postman interface again let's change the url to students and then we have a body and for the body it will be exactly the same way as the student object right here so we need the first name last name email and age so first name last name email and age and I will copy these ones and then I will just create an object of type student so let me remove this and then adding The Columns everywhere so here and also for the AG and here for the first name let's say Ali and for the last name let's say bu Ali and for the email so this is my email if you want to get in touch with me so it's contact at alibu coding.com and age let's say I'm 34 years old I'm getting old but it's totally fine so here we have our Json representation for the student object now if I click on send let's see what will happen so first we see that we have this 200 okay and we persisted our object and now we have the ID equals 1 so if I go back to my database click on here let's refresh the tables and if I open this student we see that we have an object that that got persisted in the database so here we still have the is uh some colum colum that we added but we can ignore it for the moment and here we see that we have the object or the user or the student that we just inserted so let's go ahead and insert another one and see the changes so here let's say John John do and here for example let's say John at alibu coding.com and let's leave the age as it was and hit enter so so here we see that we have a different ID and we return the saved object so if I go back to my database and refresh so here you have the icon to refresh or to to reload the page and now we see that we have this user again inserted so here let's just check again um our entity and we see that the email is unique okay so now if I go back to postman and try to insert the same object click on send and we see that we have a 500 internal server error so if I go back to anj and inspect this one let's see the type of the exception so here we see that we have an error duplicate key value violates unique constraint for this constraint that we created before so just to remind you this is the constraint that we created for the Unicity of the email so it's this one and now we see the except that we have a violation and even we have more details it says that the key email like the field called email and the value John alibu coding.com already exists so hibernate is performing all the checks and checking that the email should be unique within our database so this is how we can persist an entity now let's see how we can update an entity and how we can delete fetch all and the operations that we can use now let's Implement another method that will return a student by its ID so here we have student and then I will pass as a path variable and let's say student ID and here it will return just a single student so let's change the type and here find student by ID so this will be the method name and of course we need our path variable and here let's call it student ID and then tiger ID so here we have our method ready and now all we need to do is to use the method find by ID and here this find by ID it will return an optional of type student so here let's pass first the ID and then let's say or else for example null okay so if we don't find the student with a specified ID it will return a null object or let's say even some new student okay like an empty student object so let's restart the application and let's go to our Postman and try to test this endpoint so first let's insert uh an object or like few a few elements so this one and this one and we have three elements so here if I test again the/ student we see that we are returning three elements with the specified uh object and values that we provided and now if I say SL students SL1 so it should return this first object and if I click on send so we see that we have only one object and here before it was a list so just to make sure and as you cane can see it's a list in here and it's a list of objects so now SL students SL1 and if I try to find an object that does not exist so for example a student with the ID number 10 which which we don't have in the database we see that we have an empty object with n values and this because when we retrieved the the student we say or else new student or we can just say or else null or whatever you want so this is how we can retrieve and this is the the method find by ID that we can use to retrieve an object by its ID so now in the next part let's see how we can create a custom query and for example find a student by the first name now let's see how we can retrieve the list of students that are persisted in the database so I will duplicate first of all this method and instead of post I will just use get so here it will be get mapping and I will use the same URL students and here like I will say find all students and here instead of returning a single student I need to return a list of students so here I will use list as a return type and then I will just give it the type student so here list of students and here we don't have any request body since it's a get and we don't have any parameters and now instead of saving we have a method called find all so this find all method will return all the students that we have in the database so let's restart the application and go to our Postman and test this one so opening Postman first I need to persist few data so this is the first one second one and let's say this is the third one and again I will duplicate this tab and here I will change this one to get and I don't have a body and all I need to do is to click on send so here we see that we have this 200 okay and we see that we are fetching and displaying all the students or all the objects that we have persisted in the in the database so it's Ali B Ali and we see that the email is changing and this is contact one and contact 31 the one that we just inserted so this is how we can retrieve data from the database and as you can see here I did not create any SQL query for that but all these methods they come from the spring data jpa or from the jpa repository that we extended right here so if I open this one we see that we have a bunch of method right here and even this find all it comes from other uh from other interfaces so here we have the save all we have this find all method that we just used so click on download source and this is all the methods that are available so let's see more and more methods and try to perform the crow operation so then so here we have the create and you have the read here so let's check the delete op operation and the update operation so again let's duplicate this method right here and here it will be SL student SL search for example and then let's say student name okay so here it will return also a list of students so I'll just copy this one and replace it in here so here we will say find students by first name or by name it's also okay and here we need to stent name instead of student ID and the type should be of type string but here as we can see we don't have any method that will return uh student by name or by first name so what we need to do we need to go to our student repository right here and let me show you how we can create a method that can filter or behind that hibernate will generate the query for for us so what we want to do is searching for the list of students so first we need to provide the type which is list and the object which is our entity or a d or any other object that hibernate can be able to map it so we have list of student and then our method should start find all by and find all because we want to have a list if for example we just we want to return only a single student we can use find by instead okay but in this case we want to use find all by and then after the find all by all I need to do is to specify the colon name like the Java colon name like from the class that I want to use it as a filter so for example here I want to use first name so you don't use the ccore F name but you use the Java field of the Java class okay so I want to use the first name as my filter so all you need to do is to use a capital letter for the first uh for the field name so as you can see here already anate so this this uh is part of the ultimate version this Auto completion and as you can see hibernate uh sorry anj is already suggesting first name as a filter okay so now I say first name and also I can add like Okay so this means that the first name so contains this value or I can say containing so containing this means any string I pass it should be part of the first name so for example if I have a first name Ali if I pass just L it should return and filter all the students containing this L letter so here all I need to do is to pass my string P so here I P me uh means parameter so I'm um on on purpose I mentioned P because I don't you don't need to specify first name for example so because the type what really matter so the type of the first name here should match the type of the parameter that you are passing right here okay so now we have our method let's go back to our controller and call this method to return the list of students so here we have find all by and here we have first name containing and then when we start the application and when we execute the query we will see what is the output of this query so here instead of this string ID let me just change it to name and here pass name as a parameter now if I restart the application and let's go back to postman so here I can clean the console so we can see the query that will get executed I will go back to postman first I need to insert some data so this is the first one and let's call the second one John and let's let's call uh C for example and now let's go back in here and now instead of passing this um this ID I can pass for example SL Ali okay and if I click on send we see that first we have a bad request let's check why we have that so we have a bad request because in enj here when we created this method we added SL search and with within the ad and the object or the value Ali so spring is trying to map the Ali to an integer and as we can see here let's check the exception and it will say that it was not able to map or to convert the value Ali to an integer ID so now let's go back to uh to our enj and also I need to insert some other uh data and here let's click on send and then also John for example and let's change this and click on send again because I guess I uh it was it was not inserted before so now if I go back to/ students SL search and now if I pass Ali as a parameter and click on send so we see that we have a list containing this object which is Ali B Ali and so on and so forth now let's go back to the console and see the query that was generated so here we have select and we have the fields from from student where the CF name so hibernate was automatically capable of transforming this first name to use the colon called ccore f name and here we have like and then so this is the value because it's an interrogation Mark and then escape the the back slashes so this for example in case we pass a back slash as a value so this is the query that was generated behind and all this came from just this method that we created right here so we just told spring data jpa to search the list of students by first name containing so any first name or like the first name contains the a portion of the string that we pass right here all right so now you understand how we can create queries now let's move on and see how we can delete objects for example now let's create another method to delete student so here I will use a delete mapping and then for the delete for the delete mapping it will be/ students slash and then I will need the student ID so it will be student ID and then I will have a public void and then I will call it delete so here of course we need a path variable and then let's call it student ID as you mentioned before and then I will need the tiger ID and all we need to do is to call our repository. delete and then we have a method to delete whether to pass the whole student entity or just delete by ID so the delete by ID we can just pass the ID and here we can also use as explained before the response status annotation and here for example let's say accepted or or just Okay so for example let's say HTTP status and of course we need to import the HTTP status so now let's restart the application and let's go ahead and try deleting student by the ID so now the application is up and running again so let's go back to postman and of course I need to insert some students and I will insert another one so here we have two students Also let's check in the database so let's open the student table and we see here that we have two students created and now if I try to delete the second one or the student with the ID number two let's see what will happen so now let's duplicate this tab so duplicate Tab and then instead of post I want to send a delete and then SL student slash2 and all I need is to do is to click Send and we see that we have 200 okay and also let's go back and check in the database so if refresh we see that the student with the ID number two was successfully deleted all right so we performed all the crud operations we saw how to filter we saw how to create um a custom method using the jpa repository and now let's see how we can perform and add relationships to our entity so here we have our student entity and let's try to create other entities which will have some relation and mapping between them so in order to uh create mappings and relationships with different entities first we need to create the entities that we want to uh to create the mapping for so here let's assume that a student is part of a school or studies in a school and a student has a profile so first let's start with creating uh The Entity school so I will create an entity called school and then of course we need the entity annotation so we don't need the table because we can leave it just to school and then we need the ID so this is will be the identifier and then generated value and let's say private integer ID so this will be the ID of the school and simply let's say this school has a string school name or just a name okay so this is our school entity and of course we need to generate Getters and Setters so let's select both of them and generate Getters and setters for the ID and the name and also let's generate a Constructor and this Constructor we can say a Constructor using just the name and Another Empty Constructor because if you remember we need that so here we have our school entity ready now let's move on and create the profile entity and then we will start implementing relationships now let's create the other entity which is will be the student profile so the student profile again we need the entity annotation and we need also the ID so this will be the identifier and it will be a generated value managed by hibernate and then we will need a private aner ID and then let's say the the student has a private string bio so this will be like just a bio or description for the student we can also add many other fields for the profile but for now let's just keep it simple and let's generate now Getters and Setters so let's select both of them and then again let's generate a Constructor let's generate an empty one and let's also generate a Constructor using the bio so we can just create or in instantiate user uh student profile just using the bio so now we have our student profile and stent School ready to use let's move on and understand the class diagram that we need to implement and the relationships between these three entities this is how our class diagram looks like so as mentioned before we have one student and a student has a student profile so the student has only one profile so that's why we see a onetoone relationship between the student and the student profile and then a student studies in one school so here that's that's why we have a relation from the student to the school which is mapped with the one right here and then the school has many students so one school has zero or many students so this means that we can have a school but without any students yet but what if we have a student the student should be assigned to one school so this is how our class diagram looks like now let's start implementing the relationship between these three entities and we will start with student and student profile which will be one to one relationship now let's create the first mapping one to one between the student and the student profile so I will move this to the right so I'm going to split it and move it to the right to have both classes open at the same time so first what we need to do so let me first remove this column because we don't need it anymore and first thing we need to do is to create an object or a field of type student profile inside this student stent class so let's go ahead private student profile and let's call it student profile okay now in the from the other side we need also to create an object or a field of type student in the student profile but we will come back to this just in a few moments so now to declare and to tell hibernate that this is a onetoone uh relationship between the student and the student profile or we need to do is to add the one to one annotation and this one one annotation comes with some properties first we need the property mapped by and this mapped by should reference to the field of type student in the student profile so let's say here student and then I will explain later on and that's it so here we have one one and also we can add the cascad type A cascad type. all so this means this cascading type this this means if I perform or if I delete a student this means automatically I will remove the student profile at the same time without even performing a delete operation on the student profile itself now from the other hand on the student profile I need to create a field of type student so here let's call it student and here be careful this student should be exactly the same as the object mapped by because the mapped by will look for an object of type student called student so for example just an example if I say St and I start the application so the application will fail because here in the student profile we don't have any attribute or field called student so you need to be careful about this one and then we need to add one to one annotation also from this side and now let's define where to add the join column so this means because you know in class diagrams where when we have a relationship we need to have a foreign key in one of the tables so here our primary entity is student and then we have the student profile so we can create a student but we can Skip and update the student profile later on so this means that the student is the primary entity and the student profile is the secondary one so in this case we need to add the join colum annotation so here we have a join colum so this means that we want to declare a join column let's give it a name for example student andore ID so this means that when we start the application we will have an extra field in the student profile class or table having the name student ID so let's start the application and check that all right so the application is up and running let's check the logs first of all so here we have first we are creating the school the table school so this we will come back to this one later on and then we have a student profile and after that we have the table called the student so here for the student we have the primary key which is the ID and in here we have the student profile and the student profile we see that hibernate created a new field called student ID and it chose an integer as the type so the integer it chose it from the ID or the ID type of our student class so now let's go back let's go ahead and check the tables right here so if I refresh we see that we have three tables so here if I open the student profile we see that we have one foreign key and if I expand this one we see that we have this foreign key with these constraints so FK for foreign key and this is the key or the ID for this foreign key and this one it's the field student uncore ID which is the field that we defined already and it refers the table called tore student with the ID or the field or the primary key called ID so in this way we performed or recreated our first relationship one to one between student and student profile so now let's go ahead and create the mapping between the student and the school all right now let's move on and create the relationship between the school and the student so we said that the relationship between the school and the student student is one too many this means that the school has many students and students can study in one school so let's start from the school side here we need to create first of all a list of students so because here we have one school can figure out many times in one in multiple students so this means like this the school has multiple students so I will create a list of students let's call it students and then we need to add The annotation one to many so this means one school can figure out or can be uh or can exist in many students lines or many students Row in the students table that's how or that's why that's how we can determine what is the type or which annotation to use so then within the one to many we need an the attribute Mapp it by and the Mapp by should be exactly the same like the one to1 should be for example in this case school and the school should be an attribute of type School in the student. Java class or the student entity so the first thing is to create a list of students when we have one to many so here from the school side just as I mentioned before we have a list of students and then this list of students so any time or every time you have a list here just go ahead and don't think twice and use the one too many annotation and also use the ma by attribute to map this list of students to the school from the other side and of course let's not forget to generate Getters and Setters so let's generate Getters and Setters for the for the students let's click okay and now we have students Getters and Setters so let me just move them to the bottom and now we have our student list so this is how we can create a one too many mapping so now let's move on and create the many to one mapping from the other side so now let's perform the the link and the mapping from the student side so here let's create a private school field let's call it school as exactly the name right here so then soic colon and here so this means that we have many students to one school so many students can study in one school and every time you have the Min to one annotation always think about adding the join column so here let's give it a name so here let's say school ID school uncore ID so now if I restart the application we will see all the changes that we will have within our database and of course let's not forget generating getter and Setters so I will generate the Getters and Setter and also the student profile which I guess we forgot the last time so let's click okay and also let me move them to the bottom and now let's restart our application and see the changes so here first we can also check the check the logs so here we have alter table student profile if not exist and then we have alter table to student and we are adding all the references and the links and the relationships so here let's open this again and let's refresh the tables so we see that we still have three tables but let's let's check now the school uh sorry the student table we see that we have two foreign keys so here we have the t uh two keys for sorry and then we have one foreign key which is this one which is called school ID and it's referencing the school and the ID from the school it and here from the school we have again the ID and the name and we don't have any other foreign keys because the foreign key belongs to the student table and the same here for the student profile we have again our student ID which is reference the T student ID so like this we are able and this is how we can perform and create mappings between the different entities using annotations from the jpa and Hyper Nate and using spring data jpa now let's move on and see how we can insert Data before we move on to implement the controllers let me first show you a way how you can check that you implemented correctly the mappings between the different entities so here open the database and let me make it a bit full screen and then on the on the schema that you have or the database that you created right click and then you have this diagram menu and then you can click on show show diagram so here it will show maybe two options maybe not for you but click on database schema if it shows the diagram type so then let me close this one we see here that we have two the three tables that we already created we have the student we have the school and we have the student profile so let me just organize a little bit and here let's move this one and then also you have this um this link right here and then when we make when you make for example like when when you move entities and so on so forth and to organize these lines right here all you need to do is to click on apply current layout and it will adjust itself in a smooth way so here we have our student table which also named tore student and also if you highlight it you will see also the the script or the SQL script script for it and then we have here the student profile and we see that we have the student ID as a foreign key so the the primary key will be with um with this golden key and the foreign key it will be with blue one and the same here for the student and we see also that we have the school so now let's move on and start creating the controllers for the the school and let's Implement few methods to insert some school and then insert students and assign them to school school and see how we can do that now let's create our school controller so right click and then new Java class and let's call it school controller and then of course we need our rest controller annotation and now let's create our first post mapping and then it will be slash schools and then it we have a public school and it will be create or save for example and here we have our request body and then we need the school object so request body it will be object of type school and then let's name it school so after that we need of course to inject our repository so it will be private final School repository which we don't have for for the moment but we will create it in just a few seconds and let's call it school Repository and now even if you don't have it so here just highlight it and use the autoc completion and it will suggest you to create a class cor repository or an interface or enam and so on so forth so in our case we want to create an interface School repository and we want to create it in the same package so let's just hit enter and here we just made a typo so let's rename this one so let's call it school repository and then of course we need to extend the the jpa repository and we need to pass this schol as an object and integer for the ID then let's go back to our controller and here we need of course to add a Constructor so let me make this one full screen and now we have our school repository and now we can use it so here in this method all we need to do is just return School repository Dove school not save all just save and then this schol that we get as a parameter so then I will just duplicate this one and instead of Opp post mapping I will create a get mapping so now you are familiar how we create controllers how we return objects and so on so forth so we don't have anybody and we need to return a list of schools so here we have a list and then let's import this list and then let's say find all and here instead of save let's say find all all all right now let's start the application and insert some schools and since we also have our student controller which is already named uh first controller so let's go ahead and just rename it and call it student controller to be consistent so now let's start the application and go to postman and start our new API and see how we can insert schools and assign students to schools so our application is up and running now let's move to postman and test the the school controller and try to insert some schools and then let's go and insert also some students now let's duplicate this tab and then instead of students it will be schools and in the body we will need only one attribute which is the name so let's just change this one and let's call it alibu school and here all I need to do is to click on send and here we see that we have a 200 okay so this means that the school was inserted and we see that we have the ID and the student for now it's not because we don't have any students assigned to this school yet also let's go to the database and check that so here if I refresh my database and open the school table we see that we have the school that we just inserted called alibu school now if if I want to insert a student so let's see the structure we have right here we have the first name last name email and age and also we have an object called school so let's go to postman and structure and create an object of type student to insert the student and assign it to the school that we just created so here let's go back to the first tab where we have the school the students to insert and here I all I need to do is to add another attribute mute of type school and this one is an object so here and all I need to provide is the ID because spring data jpa uses the ID to insert an object as you can see the school that we inserted has the ID equals 1 so this is all we need to provide so here we have the school and the ID you can also provide the name and so on so forth but it will not affect anything because hibernate and spring data jpa only needs the ID so now let's let's click on send and we see now this is the result so first we have a 200 okay and here we have the ID with the first name last name and the student profile for now it's null and we see that we have the school which is ID equals 1 name student and the name and the student is null so this is also is not a problem now if I go back and duplicate the school request and change it to a get and of course for the body we don't have anything and I click on send and here we see that we don't have a response yet and this is because here we have let's let's understand the structure let's go back to the code and let me open the student and the school so here we have the school object and the school object it has a list of students okay and then it will try to get the school and the students list and then from the student it will try also to load the the school information and then it will go back to the school and it will try to load the list of students and so on so forth so we have here an infinite Loop and this is because hibernate will try to load all the information Al together so let me show you how we can fix that before fixing the problem let's have a look on the exception so here I will use this uh soft trap just to have everything wrapped and here we see that we have this main exception and failure trying to resolve exception from this uh spring framework and call send error after this response and this means that we encount encountered uh an infinite recursion with with the Json mapping so here when Jackson tries to map the the object so when it tries to map or to transform or to create adjacent response for the school it has a list of student and then as I explained before it will go to the student and then the student has also an object of type school so it will try also to um to serialize the school and back again so we have an infinite recursion Loop so or an infinite Loop and let me show you how we can fix that using the Jackson annotations so for this one we will be using two annotations one on the parent level and the second one on the CH on the child level so the the parent level is where we have the list so the school is the parent of the student students I'm going to make this one full screen and here on the list level we we need to use an annotation called Json managed reference and this Json managed reference so this tells Jackson that the parent is in charge of serializing the child and it prevents the child from trying to serialize the parent now so we need the Json managed reference on the parent level and then we need to go to the child level which is the student right here and we need to go to the field of type school and here we need an annotation called Json back reference so this is the back reference or this will tell that this entity the student entity or the student object doesn't need to serialize the parent which is in in our case the school so now let's restart the application again and let's go back to postman and try to insert the data once again so here the application is up and running so also let me keep it like this I will clean up the console so here again we need to insert this school and insert the student and assign it to the school and now if I try to fetch all schools and I click on send we see that we have a response and we have the status 200 okay and here we see that we have the ID and the school name and then we have the list of the students so for example if I insert a new student so here let's say uh contact to and within the same school ID and here let's say Ali B Ali and I will click on send so the school the student is correctly inserted and now if I fetch again the list of schools we see that we have the school with the ID number one and we have the list of students we have this id2 it's the student we just inserted and we have the first one which is John Bali and with this email address so now we have our application functioning but there is one thing which is a little bit uh not okay with all that is because we are exposing almost everything and even when we want to insert a student we have or we need to provide the full School object and imagine that we have other relationships within the school within the student like for example the student profile and imagine we have subjects and so on so forth so this will make our object or our student object more and more complex and it will prevent us and it will add more complexity when we want to save or to interact with the student entity so this is introducing us to a really important topic we will see just in few moments so let's move on and explore the next topic of our course dto stands for data transfer object which is a pattern often used inof Ware design the main purpose of a dto is to encapsulate and structure data that needs to be transferred between different parts of a system or different systems entirely a dto typically includes only simple data fields or also called attributes and lacks the behavior of the model or entity it represents so here if we take the example of our application we have a student and we have a school we have also a student profile which will hold some sensitive information about the student like the address like phone number date of birth and so and so forth and mainly we don't need to expose this information to the outside word and also even for example if you want to ret the retrieve the information of the school we only need to expose the school information and since these information are represented by entities and stored into a database system which which is secured system so we need to expose only what the user or the end user is expecting and no more extra information so for example as I mentioned for the user we for the student we don't need to expose uh sensitive information such as address date of birth phone number even if if the if the student has a password so we don't need to expose that so then what we need to do we need to include a a mechanism in the middle in between between the entity itself and the outside word so we need to to add a mapper and this mapper is just a simple mechanism you can use many implementation or many tools and libraries to map objects and then if we use a mapper we can have multiple representations for the same object for example for the student we can have a representation one only to expose first name last name and we can have another representation to expose or to receive data from the outside world in order to create a new student and for example we need only first name last name and email and so and so forth so this is one of the advantages is we can have multiple representations for only one object or only one entity and this also appliable for school student or the student profile in our case and generally speaking it's appliable to any kind of ENT entity and the rest API should communicate with the client through these representations and we can have one representation for the read and other representation for the write for example to create a student we can have one representation which holds the information or like the minimum required information to create a student and for the read represent representation we can have a different one or a different object that will be responsible for exposing only the necessary and nonsensitive information to the outside board so when building a restful API dto play a crucial role and now let's give you some reasons why they are important first of all we have data separation so the data transfer object pattern helps to separate the internal domain model from what is exposed exposed through the API this way you can change your internal model without affecting the external representation it also helps in not exposing exposing sensitive or unnecessary data to the API customers then abstraction dto provide an abstraction layer they give you a clear structure of what your API will provide to the client abstracting the complexity of the domain model then performance improvements instead of sending entire entity over the network you can instead send a dto which include only the necessary information these can significantly improve the performance of your API as you can control the size of your response payload then we have flexibility since dto are separate from your domain model they allow you to tailor your API response to exactly what your client need even if that does not exactly match your domain model and here we are talking about multiple representations for the same object and finally versioning so dto make it easier to maintain different versions of your API by using different sets of dto you can support multiple versions of an API simultaneously and then in the next part we will see how we can use this dto pattern in our application now let's go ahead and create a new object that will represent a student request for example so let's start with a student and here we have in our student controller we have the bunch of methods that we created to persist a student to fetch a student and so and so forth now let's see what are the changes that we need to apply after creating our student dto object so I will close everything and here right click and then new and then Java class and for this example and for the dto we will be using records as I explained before what is the difference between records and normal poos so let's say student dto for example and here for this student dto it will be a similar representation to The Entity itself so here to create a student we need the first name we need the last name and we need let's say just the email and the age is not mandatory to create create a new student so I will copy these fields right here I will copy them and then let's paste them in the student dto so here I will just paste these fields and I will add the comma and now we have our record ready to use so also since we have a relationship within the school so a student is linked to a school all we need to do is to pass a school ID instead of the whole object so let's imagine that the information we have within the school is uh address uh location and like a bench a bench of information about the school but for hibernate and for persisting the data all we need to do is the ID of the entity so here within the student dto after the email I will add also an integer school ID so I will create an object and then we call it school ID like this so now we have our student record or student object ready to use now let's move on and create an object for uh for school Al also and let me show you how we can use these dto to persist data and to send back information so now if I close all these classes right here and if I go back to the student controller let me make it full screen and here in the post mapping or when we want to create a student so here we are requesting an object of type student which is our entity but let's change this and instead of requesting the student uh entity let's request student D object so now we are asking the the the rest client to send a student dto which is represented by the first name last name and and an field called school ID which represents the identifier of our school so then we see that the repository. save is now not working because here it's expecting a type student and we are passing a student dto so here as you can see in this error method so infer Type S of type parameter s is not within its bound so it should extend com. al. example. student so we need to pass an object of type student so now let's see how we can use this dto to save an object so as we explained before here we need to transform this student D object to a student object so here let me just let me create a private student method and let's call it two student okay and this two student method will receive exactly this object so let's call it dto right here just for clarity and here what I will do I will create a VAR student equals new student so here I just have a new student so I can use also this Constructor that we that we created before or we can use the Getters and Setters so it's actually up to you to choose which way you want but let's go ahead with with sets and Getters so here let's say student. set first name and then the first name is the one coming from the dto doget or do first name and then we have student. last name so here it's a set instead of a get and then we need the dto do last last name and then we have student. set email and then again from the dto doget email so here it's not a get like within records we don't have gets but we have methods representing like with the field name so now we have all the three fields that you specified for this student D first name last name email and now we need to set an object of type school and Link it to this student object so here I will create a VAR School equals new school and then for this school I can just use D dto and just set the ID so here just school and then dto so here I need to set the ID sorry so it will be my dto do school ID so here I have or I prepared my school object now I need to assign the school object to the student so here I will say student do set school and then the school object I just created right now so now we have our two student method so again let's just return the student object so here we have our two student method so all I need to do here is just replacing this method code right here so we will create a variable and here I will just rename this one to dto or student dto you can name it as you want and here I will create VAR student equals to student from my dto Okay and like this I will be able to persist the data okay so let's go ahead and try this so now the application is up and running also I will just do a small change here in the application. yaml instead of using Create drop I will use just update so because I don't want to lose the data each time I restart the application and now I will just restart again and let's go ahead to postman and try to create a new student so here in Postman first we need to create a school so let's just send this one and we have the ID number one and here we have the the method that will allow me to create a new student okay so it's a post and then student so here we said that we no longer need the age since it's just a requirement from us and here instead of passing the school object all I need to do is to pass a school ID right here and this school ID I will give it the name one uh sorry value not name and then let's click on send and see what will happen so here we have 200 okay so this means that the student was persisted and it was linked to the school that we recently created so let's go back to the to our database and check if we have everything persisted and working as before so here let let's go to the database let's refresh and then here we have our school and if I open the student we see that I have the student that I just created with the name Ali B Ali and we have also the school ID equals one so like this we saw that we using the dto we are no longer requiring all the information or all the fields from all from the entity but it's just a representation that suits our need but we still have one small issue we are returning again the student object so we are returning or exposing the student entity and here as you can see in Postman and the response we have the age which we don't want uh to expose and also have this object uh student profile which is null and so on so forth also we have the ID and maybe we don't want to expose that so now let's see how which dto we need to create in order to return a proper uh a proper object and a proper response to the user so now let's create another record and it with this one we will call it so it's a record and we will call it Student Response or student representation dto so let's say Student Response dto and exactly as we did right here so we need the first name last name and email for example so these are the information that we want to expose to the end user or to the to our client uh to our RIS client so let me stop the application and here all I need to do I need to go back to my controller and then instead of returning a student I will return a Student Response dto okay but here again we see that this repository. saave is returning a student object and I need to return another type so again we need another meth method right here so we need a private student response dto and let's say to to Student Response dto and this to Student Response dto should receive student object as a parameter okay and then all I need to do is return New Student Response dto and then I need to pass all the information that I need so it will be student. get first name and then so let me inline this one so it will be student. getet first name and then student. last name and finally student. getet email and like this we have our Student Response dto and here semicolon and now we have our representation ready so here I will say just VAR saved student equals this one or like the result of saving the student and and then all I need to do is to return to Student Response from the saved student and like this I have again a new object or a new representation of the response that I want to expose to the customer or to my rest client so let's go ahead start the application and let's try this out so now if I go back to postman and let me duplicate this tab and let's use a get in here and let's search student by its ID so let's say for example student SL1 or or let's save another student again and we will come back to that method later on so here for example if I say Ali or like John do and here let's say it's John do alibu coding.com and now if I click on send we see that we have the response or a different response from our back end and we do not expose extra information so here the response is really encapsulated and an abstract response without any further information that we should not Expos to the outside word so here we are exposing only the necessary information even if you see for example that this email is a sensitive information all you need to do is just remove it from the dto and adjust the mapping now for our school object let's create a dto for that so again just new and then record let's say school dto and here in this record all we need to do is a string name so or string school name you can name it as you want so now we have our school dto record or School dto object and we can use this one now in the school controller in order to save and expose information about our schools so again let's move go ahead and Implement that let's now introduce all the necessary changes to our school controller in order to receive a school dto and expose also a school cool dto so here let's check back again here if I go back to postman and let me start the application I will explain to you what I mean so now if I go back to postman and here if this is the the school or like to retrieve the school with all the students we see how we see here that we have the information of the school and we have the list of the students so now it's it's okay to have it like this because in this case and so far we have only students assigned to this uh to this school but imagine the case we have hundreds and even thousands of students assigned to the same school when you request the information or like you need just a light information about the school we will be loading the school and all the students and imagine also we have other relationships for the students and like the response will be really really heavy and it will take time until it gets from the back end to the rest client so what we need to do again we need to just use dto and expose only the information that we need and I will then show you how we can expose or like fetch the students for a specific school so now let's go back to our code and let's adjust our controller to only Expose and receive all the ne only the necessary information for the school object so here for the Post mapping or to create a school first I need to return a school dto again I just want to remind you that the school dto takes only as a parameter the school name and then here we also need to get a school dto as an input or as a request body so here all I need to do is just to have VAR school so here let's call this one dto and school equals to school for example because I need a method that should do or make uh or perform the mapping and the object transformation from school dto to an object school so here we don't have yet this method so let's create a method School in school controller so here it should return school and that's it so now all I need to do is just return a new school and for this new school it will be d.name since our school contains only one attribute which is this one and we don't really need to pass any students then we need to perform saving or like we need to save the school and all I need to do so in this case I can whether return or like have for example saved School equals school. repository and then I will do VAR and then I need another method to transform this school dto uh this school object to a school dto but here as you can see it's just for this case the school object is the same as as the for the input as the output so all I can do is return dto again so this also valid and this will allow me to have or to save some time on the execution level so here we have our our method right here it's a post mapping and we receive the school dto and then we save this the school and return the object back so let's go ahead let's restart and let's try out this so if you go back to postman and here this is the tab for posting a school so let's say alibu School 2 and then if I click on save so we see that the the school was persisted and here I have the response that I already get from my back end now if I go back and check the database and here let's open our school table we see that we have alibu school and alibu school to sorry not do which is was persisted into our table now for fetching the list of schools that we have in the database we don't need to expose the school but we need to return a school dto object so here I will just change this return type to school dto and then we need to perform also a mapping so we need to do a transformation for each element of the list to a school dto object so here let's create private and then school dto and let's call it to school dto and these two school dto will receive a parameter of type school and then all I need to do is to return a new school dto and then it's will it will be School dot get name now we have our method and this method it will transform like it will take a school object as a parameter and then it will return a school dto out of it so here what we need to do so first let's have a stream and then let's perform a mapping so then stream so it will this will return a stream of schools and then a map so we can do this and then we can use the method reference and then we can call this method to school dto and then of course we need to collect and return a list so here now we have a transformation so after finding all the students which will return a list of schools then we open a stream so this will transform our list to a stream of schools and then we will do a mapping so we will do a transformation of object so this means for each element of this list of schools or of this stream of schools we can or we will perform a transformation and then it will we will call the two School dto method which will return later on a stream of school dto object and then we call a reduce meth method which is collect and then we want to collect all of this as list so now let's go ahead and try this one and see the output so let's open again Postman and here we have the method or like the request to call or to get the list of schools if I click on it we see that we have now an object name alibu school and then name alibu School 2 so we don't expose anym the list of students or any extra object or any extra information that we don't want to expose it to the outside world or to our rest customer all right so now we have everything uh we need so let's move on and and talk about a really interesting topic so see you in the next lecture as the application and the business requirement grows we see that the code that we are producing in here in this controller student controller and also in the school controller has grown significantly and for that we need to introduce another layer in order to make our code more you more reusable and we we need to create a separation of concerns so for that we need to create another layer which is called the service layer so the service layer in rest API plays a crucial role in separating the concerns of handling business logic and application specific operations from the presentation layer which is the controller and the data access layer which is the repository so it serves as an intermediary between the controller and the repository encapsulating the business logic and providing a reusable modular and testable code base and here are some key reasons why the service layer is important in RIS apis first we have business Logic on capsulation so the service layer is responsible for implementing the business logic and Performing complex operations required by the API it encapsulates the logic that goes beyond simple data retrieval or modification such as validation calculation transformation or coordination of multiple operations so by centralizing the business logic in the service layer you promote code reusability maintainability and readability also the service layer provides a separation of concerns so the service layer helps to maintain a clear separation of concerns within the API architecture controllers are responsible for handling incoming HTTP requests and providing appropriate responses while repositories handle the data persistence and retrieval the service layer sits in between ensuring that the business logic and application specific operations are decoupled from the other layers so this separation improves code organization makes the code easier to understand and allows for independent changes and testing of each layer and finally testing and maintainability so the service layer provides a boundary of unit testing as you can test the business logic independently for the of the controllers and repositories by mocking or stabbing the dependencies you can for Focus solely on testing the logic within the service methods so this makes it easier to write comprehensive and targeted tested enhancing test coverage and ensuring the correctness of business logic Additionally the separation of concerns achieved by the service layer improves the maintainability of the code base as changes to the business logic and can be isolated to the service layer without affecting the other layers so in the next part let's go ahead and create the service layers that we need for our application so now let's start with refactoring the student controller and create and extract the code for each layer so here let's first start with this two methods the method that can convert and map an object student dto to an object student and also we have another method which converts a student to a student response dto so for that let's go ahead and create a new class and let's call it student mapper so this class or this service is responsible for mapping or creating mapping for our students so first to make this class service all we need to do is to add the service annotation on this level right here and then let's go back to our student controller and let's copy or let's cut this two methods right here so I'm going to use command X to cut these two methods and then we go back to the student mapper and then just paste the code right here and don't forget to make these methods public and again here let's make the second method public so now we have these two methods available in this student mapper service so now in order to use the student mapper and the student controller all we need to do is to inject our student mapper so let's go ahead and do it so here we have private final student mapper and then let's call it student mapper and here of course we need to include that or to add this to our Constructor so let's go ahead and do it and now we have our student mapper injected I'm going to make this one full screen and now let's fix the test so here instead of calling directly the two student we need to call student mapper do to student and here we see that the code still works and we don't have any compile issues and the same here so for the other method to Student Response dto so here we started or we extracted our first service and we have our student mapper service which can handle the mapping and the objects transformation so now let's move on and create another service for this student controller in order to make our code more and more reusable and make our code maintainable and uncapsulated so now we extracted the code and we make we made our code less complex on the student controller but we still see that we have more logic which is happening around here so here we have like mapping saving and then returning the mapped object so the idea is always to make the student or the controller layer responsible only for receiving the requests and sending back the responses and all the logic and all the business logic needs to go to to a separate service so for that let's go ahead and create a a new class and let's call it student service so here student service class and again to make the student service a service we need to give it The annotation service so here we can use whether the annotation service or just a component but since we decided that this is a service layer so we can annotate it with a service annotation so then we see here that we are using repository and mapper so we need to move these two dependencies to the service layer so I'm going to close this one and then I will just cut this student uh these two dependencies and I will paste them here and again let me make it full screen and now I need to create or to add a Constructor with these two objects or two dependencies in order to you inject them using Constructor injection and here let's go back to uh to this one and now instead of injecting the repository and the mapper all we need to do is to inject the service that we just created and we will come back to this in a few seconds so here we see that we have this post method so first I'm going to uh change this one and make it save student so I will just re rename the method and here in the student service I need to create also a method that will perform these three operations this means transforming a student dto to a student and then saving the student and then finally mapping the student to a student response dto so I'm going to cut this one and here I will go back to my student service and I will create a public method so I will call it or like it should return a student response dto so let's call it also save student if you want to and this save student needs to take as a parameter the same object that we have right here so let's pass our student dto as an input and then let's open this and just paste the code that we we copied from the controller so now if I go back to my student controller and then I will just remove this constru Constructor and again I will inject my private final student service the one that we just created and let's call it student service and of course we need to create or inject it through the Constructor and here we have our student service so here in this save student method let's just do this do student service do saave student and then we pass this the dto as an object so for this method we see that we have only one line and of course we need the return keyword and how here we have only one line which is calling the student service in order to perform all the business logic that we need so here let's go ahead and also migrate and move all the logic for the other methods also to the student service so now before we move on I want to give you a small exercise and I'm pretty confident that you will handle it your own so here I want you to migrate and to move all the logic in this controller to the student service so this means you need to create a method find all student in the student service and the same for find student by ID and find student by name and the same for deleting a student so go ahead and do it and I will give you the solution just afterwards that's good so now let's correct this exercise so first of all let's create a method in our service and let's call it find all students so we can just copy this one and then move it to the student service so here I will have my method so find all students and now if I go back here instead of repository and I will call this the service so here I have student service do find all students and now we migrated the find all students to the student service so in case we need to perform any other operations on the student on the find all students we can just do it on the service layer and we no longer need to update or to change anything on the Ser on the controller layer so again let's do or let's migrate this one and then of course I will give you another exercise just to transform or to return the Student Response dto instead of the student for this controller so let's go ahead and let's do this so here we have we need the integer ID and then all we need to do is just to return this one so let's copy this code from here and then paste it here and now instead of calling the repository so it will be the student service doind student by ID and then we need to pass the ID as a parameter so we Mig ated also the fine student by ID and now let's go ahead and migrate this method to so let's copy it and then let's go to the service and here we need the string name as a parameter and then also we can just go back and copy this line of code and paste it in here so again let's go back to the controller and here instead of returning the repository so it will be student service do find all by name or find students by name so here find students by name and then we need the string name so now also we migrated this method and finally we need to migrate this delete method so let's make it also a void so let's go back to student controller and let's spacee this one and we need our integer ID and then we need just this line of code so let's just copy it and then paste it in here so then we know we go back to the student controller and instead of calling the repository let's just call student service and then just the method called delete so now we migrated all the code to the service and as you can see here in the controller methods we see that we just making a call to the student service so we have no logic in here so that's good now we migrated everything and The Next Step let's see what we need to do again now I want to give you another exercise so as I mentioned before here we see or we need to return always the dto or the dto representation and we want to do the same for all the other methods so here instead of returning the student object I want you to return the Student Response did you object instead so now I will leave it to you and just go ahead fix this and change the return type and I will see you in the solution for this exercise that's good you made it this far so now let's correct together this exercise so here instead of returning a student we need to return a Student Response Toto so let's first change the type of this list and here in this find all method let's start an open a stream and then let's make a map and then we need our mapper so so student mapper and then we can make a method reference to Student Response dto and finally we need to collect our objects so here we have collect and then collectors as list and of course we see that we have still one related problem which is the student controller or the return type of the student controller so we need also to change that so now we have our Student Response dto for the find all student methods so next next let's go ahead and also migrate and change the the return type for the find student by ID so let's go back to our student service and here in the find student by ID let's just paste this one so we change the return type and here this find by ID as you can see it returns an optional of student So within the optional we have also the map method so we can also perform a transformation and return turn the transformed object so for the transformation we need also the student mapper and then to Student Response D otherwise here we need to return a new student or we can just return null for the moment and then I will show you in the in the future sections how or how to deal with this kind of objects in case we don't find any student with the specified ID so now let's go back to the controller and also change the return type for this method so here it should be Student Response dto and now let's move on and also change the return type for the find students by name so again let's go back to the service and here instead of student we need to return Student Response dto and here also we know that this find all by first name returns a list of student so it will be exactly the same thing as in here so we can just copy this code to make it faster and just paste it in here so we have the find all and then stream and then we perform the mapping and then we collect the response and of course don't forget to change the return type in the controller so here I will just use the content to paste so here I want or I need my Student Response dto and we have the issue fixed once and for all so now we have everything fixed in the student controller and we migrated and moved all the business logic to the student service so here as you can see if we need to perform any operation or to apply any business logic we just do it on the student service and also for example if we need anything or a new method on the M for the mapping or if we want to return another type or another representation of the student all we need to do is to perform and do this transformation on the student mapper level so now we have our student controller clean let's go ahead and also migrate the business Logic for this school controller to a school service that's good you made it this far now I want to give you another exercise so now let's move to the student controller and I want you to extract all the logic that we have in here to separate services so just to give you a hint just I want to remind you that we have mapping methods right here and we also we have some logic in here and also we have some logic in here so just go ahead and do this and extract all this code to separate services and I will see you in the solution for this exercise good you made it this far and I'm pretty sure that you correctly implemented the services and extracted the services for the school controller so now let's fix that together first we need to create a new class so let's call it school mapper so this school mapper of course we need the service annotation to make it a service and to make it injectable and first let's move these two methods right here so I'm just going to cut them so let me make it full screen and then let's paste these two so here also we need to make these two methods public in order to be able to use them from outside this class and now also let's create another class and let's call it school service so here we have school service class and again we need the required or the sorry the service annotation and again we need to create two methods since we have just two methods right here so I'm going to just copy this one or like I'm going to copy the whole method and I will paste it in here so here we don't need this request body and we can also make the code a bit cleaner and I'm going to make it full screen screen and here of course we need to inject our mapper so private final school mapper and then let's call it school mapper and of course we need our Constructor for that so add a Constructor and here instead of using to school I'm going to use my school mapper do to school and the same in here so here we need also the school repository so let's go ahead and inject it so we have private School repository and let's call it school repository and also let's make it final and inject it and add it as a parameter into our Constructor so here we extracted the create method so let's go back to the controller and instead of calling this we need to return the call from the school service so here I will just change this one to school service and also I will rename this one to school service so let me just remove the controller and inject it again so here let's call it school service and let's create a new controller with a school service so here I will just remove everything and instead of REM just returning the dto I will just return my school service. create and then I need to pass the dto as a parameter so now we just successfully migrated and extracted the code for the create let's do the same within the school or the find all method so I will copy this one so or I can just copy everything and here I will go to my school service and I will paste this method right here so here instead of this for the mapping part instead of this I need to call my school mapper and then the method to school dto and of course let's not forget to change or make the changes in the school controller so here let's call our school service do findall method so again we ALS also need to optimize the import and now we have our code migrated and extracted to separate services so here we see that the code is more and more readable and maintainable so if we need to again to perform any business logic we only have one place to perform it and we don't need to make everything in one place or in the controller and this will make our life easier later on when we move to the to the unit tests part you will see the impact and the advantages of extracting the code to service layers as our application grows we see that each time we need new classes new interfaces and new objects to create and this is too much and makes our code really not easy to Target and for example if you search a specific class or specific object to update or to perform any operation on it it's really Prett a bit hard to to to find it and here it's just a simple example imagine if you are working on on a bigger application and let's say for example an ecommerce application within the same codebase so this makes our life a bit complicated to find and identify the correct class and the correct object to update so for this I want to introduce you to a topic which is the best way to organize your code within your application and for for this one we have several approaches and I will walk you through each one of them and explain how to organize this the code using each of these approaches and then we will choose together the best approach or I will give you my recommendation for the best approach to organize the code but you are always free to choose the best approach that suits you so now let's first start explaining the approach the first first approach is called by feature in this approach the code is organized around the business capabilities of features of the applications for instance if you're developing an ecommerce application you might have packages like product order customer and payment and each of these packages would then contain all classes related to that particular feature such as controller Services repositories and models so this organization style is is benefical for large teams and project because it's easy to locate code related to specific feature the second approach is the layer approach so in this approach the code is organized around its architectural layers common layers might include controllers Services repositories models and utils for example so these Styles is benifical when the focus is more on technical roades classes rather than they their business roles so however one downside is that change to a single feature could affect multiple packages and the next approach is by domain so in a domain driven design or also called DDD approach the focus is on the business domain packages so packages are formed around different bounded context of subdomains within the large domain so for instance in a Health Care system for example there might be packages like patient management billing scheduling and medical records and finally and the Final Approach is by component so in a more modularized approach you may have top level packages for each highlevel component or of your system within each of these packages you can further organize code by feature layer for example if we have a user component we can have Sub sub packages like controllers Services models and so on so forth same for product component we can have controllers Services models utils and so and so forth and personally I prefer the layer approach so here we can have packages for product order customer and payment and inside of each package we will have all the related classes to the product so in this in our case we will have a package for school a package for student another package for user profile and so and so for forth and if we need a common package like for example let's say validators or exception handlings or like custom exceptions and so on so forth we can create a specific package for that so now let's move on and organize our code together so now in order to move all these classes to the appropriate packages there are several ways and let me show you how you can use your IDE to do that here in the first line of each class you will see a line called package and it refers to the package that holds the this class so here for example if I want to move the school class to a package that I want to call school all I need to do is to add dot school and then anj will say that we don't have a package for that and if I open this one this small popup right here we see that we have set package name to com. alibu example since entj is is considering this as a typo or it will propose also to move to package. al. example. school so let's go ahead and choose this option and here if you uncheck this button right here you see that inside this example package it will ask to create a school package so let's go ahead and click on okay and see that here we have this school package okay but this will come with some related issues because we need to import now the appropriate classes but first let's move all the school related uh classes to the school package so here we can just perform a drag and drop so let's just drop this one here and ask an to refactor same for school dto and then refactor and also school mapper so here and finally we need the school repository and the school service so it's easy to do it within the within the ID so here let's check if we have another school object so we don't here if I go back to the school I need again just to import the student but let's do it for later and then what I can do also like a different way I can just create a package like new and then package and then let's say for example student so here this package will hold all the information about the student and now I can select multiple classes so student student controller student dto student student repository and then Student Response dto and student service and finally student mapper and then I all I need to do is just to drag and drop them to the student package and then click on refactor and let entj take care of the rest and finally we see that we have the student profile so let's also create a new package for that so let's call it student profile and finally we need to move the student profile to this student profile package and then let's go back to here and let's check everything so here we see that the school we need just to import this one and if you just type or uh open the auto uh code completion it will propose that to import the school from this package so just select this one and now we have our school object ready to use so then if I go to the school and also open let's import our student object here and now we have everything fixed and if I go back to the school we see that our application is compiling successfully and also to make sure that everything is compiling just go to build and then build project and let's see if our project is successfully built so we still see that we have one issue is with the student mapper so let's click on this one and again we need to import this school from here so now let's check back again and we see that we have in this school mapper and the student mapper sorry not the school mapper because we are using the school object in here so we need to import it from the appropriate package since they are now in different packages so again let's check if our application is building and then click build on and build project so now the project is is successfully built and everything looks bit nicer and pretty much nicer not just a bit so here we have our code organized if I need something school related all I need to do is to go to the school package and here we have all the classes related to the school the same for the student so now let's move on and check what comes next now after all this refactoring and the code organization let's go ahead and check if our application is still working so let me close all this and then let's start the application and go to postman and make sure that the application is still working so here we see that we have the application is up and running and everything is totally okay so let's go to our Postman and make sure that everything is working fine so here in Postman so for example if I go to schools and try to retrieve the list of schools we see that we have the response and we have 200 okay and now for example in case I want to insert uh a new student let's say alibu and I will just provide the first name and the school ID and let's click on send we see that we have our student persisted and we receive a 200 okay but here we see that we have the last name and the email are null and also let's go check in the database and see the changes so here I'm going to make this full screen and now let's open the student class or the student table we see here that this is the the latest student that we inserted and we inserted it with the first name alibu but we see that the email and the last name and even the age are null so the age is zero because it's of type in so by default the int is zero but we see also that we have the email and the last name they are null and this is not really appropriate when it comes to database and for the data we want to persist there we can accept null values uh for some Fields but for other fields we cannot accept null values for example when we talk about the email or the student so the email can be also a unique identifier and important and sensitive information for student so we need always to have the email and the last name for the student so this also introduces us to the next section of this course so let's go ahead and introduce that and let me explain to you the issue and how we can fix that data validation is crucial in RIS API for several reasons First Data Integrity data validation ensures that the data being received and processed by API meets certain rules and restrictions this helps maintain the the consistency and real reliability of your data for instance validating an email address format ensure that you won't have invalid email addresses in your database preventing attacks and validated data can expose your API to security vulnerabilities malicious users can send harmful input to your API in an attempt to perform SQL injection crosssite scripting also known as xss and other types of attacks proper data validation can significantly reduce these risks error preventing by validating Data before it's processed you can prevent errors that might occur during string processing if you receive a number where you expect a string it can cause errors in your code data validation helps detect these issues early user experience validating input on the server side and providing clear ER message can greatly improve user experience it lets users know what they did wrong and how to correct it rather than leaving them guessing performance receiving large amount amount of incorrect or poorly formatted data can affect your API performance validation can serve as a first line of defense against unnecessary processing such data and finally business logic compliance often business rules determine the acceptable values or formats for certain data fields validation ensures that the data your API receives and processes complies with these business rules now now let's see in action how we can implement this in a spring boot application the first thing that we need to do is to add the required and the needed dependency for validation and spring boot provides already a starter for validating objects so let's go to our pom.xml file and here after spring data jpa for example I'm going to make this one full screen let's add a new dependency so here we need the dependency called Spring boot starter validation and it comes from the same group ID which is org. springframework dop put and then all you need to do is to click on this button to load the maven project or the maven changes or right click and then reload project and like this Maven will download this new dependency and now we are ready and able to use this dependency within our project so the next step let me show you how you how we can validate objects just using some annotations and use the power of spring wot starters to delegate almost everything now the question that you need to ask is where to add the validation so we mentioned before that validation within spring boot starter validation it's just a bunch of annotations that we need to add to some fields and then spring will do the rest for us of course it will not do it by itself self but we need to tell spring that we want to validate this object that contains the validation annotations so the answer is we need to add the validation on the first entry point object that we use to interact with our rest API so now I guess you get what I what I mean and this is on the on the dto level so for example here if we go to our student controller and go to the Post mapping the method that helps us to create or to save a new student we request a student dto object so the validation needs to be done on this level all right so let me show you how we can validate this object so first as I mentioned we need to add some annotations telling spring boot stter validation what are the validations or what are the controls that we want to add on each field of our object and these annotations are valid whether you work with records or if you work with only simple classes or simple poos let's first start by validating for example our first name and let's say that we want to make sure that the first name should not be empty okay so here we have an annotation called not empty and here to make sure that this is the right and the correct annotation it comes from Jakarta validation. constraints or if you are using spring 2.7 something or like a pror version before the spring 3 it will be Java x.v validation. constraints so now let's use this not empty annotation on the first name so I'm going to make this one full screen so this not empty annotation let's go and check the documentation and the code of this annotation always don't forget to download the source code so you have everything think clear and and complete so here it says that the annotated element must not be null or empty okay so if we add um the not empty annotation to a field of type string or here we can see the lists or the support types for this annotation so here the supported types are so here we have char sequence so this means the length of character sequence is evaluated or a collection so the collection size is evaluated a map the map size is evaluated or an array this means that the array L length is evaluated so here it will make sure so this annotation will make sure and ensure that the first name is not null and is not empty this means that the length should be greater than zero so also I will add this not empty annotation to the last name just to make sure that the first name and the last name are not empty when we try to create a new student so now let's move on and let me show you how we can make or how we can tell spring to validate the student dto when we receive a request body from the user or from the rest client sending us an object and we want to transform it to student dto so let's see how we can validate that so this student dto is used to interact with the student controller so as we can see here we have in the post mapping for the method save student we have a request body of type student dto so we need to tell spring that this object should be validated so now how to do that all we need to do is to add an annotation called valid and this annotation valid comes from Jakarta do validation so it's the same package as the the not empty so here this one is Jakarta Dov validation. constraints so these are the constraints that we can use and here is is the valid comes from the Jakarta validation package so you need to be careful about that because if you import the wrong annotation the application might not work so now let's start our application and test these changes so let's start the application and then let's go to postman and send an student dto object but with the first name and the last name with n values so here this is our post request and here we see that we have only first name and the school ID so here we don't have the last name so I'm expecting to have an exception or an error or validation error raised by Spring if we don't pass the last name so let's go ahead and click on it so here let's say Katherine as a student name and let's click on send so here we see that we have a bad request so our back end raised automatically a bad request response so let's go and check what we have as exceptions or what we have as logs so now let's check this and here we see that we have nothing like but we see just one warning so here we have a Warn and we have a default exception Handler resolver and it says here resolved an exception of type method argument not valid exception and here validation failed for argument zero in public Student Response dto and so on so forth so save student controller and here we say that field last name rejected value null all right so here we have an exception raised and rest client received a 400 response 400 means bad request as we can see right here so it's a bad request but with no further information about what happened exactly and here we are missing one something important that we explained before which is the user experience so the so the user that doesn't know what happened or what he missed exactly so he needs to in this case he needs to recheck the everything and then try to send a new request so let's see how we can catch this type of exception and how we can handle and return a proper response to the to the end user as we can see here in the logs spring validation through an exception of type method argument not valid exception so I'm going to copy this one and now what we need to do is to handle this exception inside this student controller so what I will be implementing right now I will explain it in details really in deep details just in the next lecture so now I just want to show you how we can handle an exception inside the controller and then we raise a proper and clear message for our end user so now I would just scroll down and here I will create a public method so a public and then response entity and then this response entity will be of any type and then so here I will say handle and then the method argument not valid exception and here as a parameter I'm expecting an exception of type method argument not valid exception so we need to import this one so let's import it and then let's write the logic for this one and of course to make this method a Handler method or an exception Handler method we need to add an annotation called exception Handler and this exception Handler takes a list of classes or a single class as value so here we want in like within this method we want to handle the exception of type method argument not valid exception so each time we receive or this controller the student controller throws an exception of type method argument not valid exception this exception will be handed inside this method so as I mentioned don't worry about that I will explain all this in details in the next lecture so for now let me create a uh a map let's call it errors equals new hashmap and this hashmap will be of type string and string so the first string will hold the field name and the second one will hold the message name okay and then what I need to do I need to get the exception or the validation exception from this method argument not valid exception and then transform them and send back a map of Key value and the key is the field name and the value is the message that was raised by the validation so here all I need to do is exp like or my exception and then that do get binding result and then we have a method called get all errors and as you can see it will return a list of object error so let's do that and then I will do for each so for each element or for each error which is returned by the get all errors here so like the these errors that we have are coming from the annotations that we used in here so for example if we use multiple annotations even on the same level name here so we will get all the errors then so now what need to do is I need that my object which is let's call it error and then I will use the Lambda expression and for each element what I will be do doing is I want to extract the field name and the error message so I will have here a VAR field name equals and then I need my error and then I need to get the field but I need to cast this error object to another type so it should be casted to a type of type field error so then it will be field error and then I have a method called get field so this will return the field name and then I need another variable which is the error message so I will call it error message equals again we need to we need to go to error. get default message so this will return the default error message that will be thrown by the exception and also get we get this error message from this annotation right here so now once we get the field name and the error message all I need to do is to store this in the errors map and then put and the key is the field name and the value is the error message and like this we gathered or like we captured all the error messages and we formed a proper object that we can expose to our customer and now of course we need to return a new response entity and then for this response entity we will pass the errors object and then a bad request so it will be HTTP status do bad request so now every time a method argument not valid exception will be raised inside the student controller this method will intercept this exception and try to extract and transform the error message messages that are coming from the validation process and transform them to a proper response that we can send to the user so now let's restart the application and see what happens all right our application is up and running let's go back to post none and let's just click on send so here we see that we have a proper response so here we see that last name must not be empty and even if I remove for example the first name we will see that we have two error messages because for now we have two annotations one is on the first name level and the last one is on the last name level so now let's let's move on and explore more annotations and how we can validate and give proper validation and proper control on the fields that we have for each object all right before we move on and explore more annotations first let's see something or a property which is really important and let's see here we have first name and then we have a message must not be empty so this message is the default message coming from the spring boot starter validator and then what we need to do or what we can do we can customize this message so instead of having first name must not be empty we can set our proper or our custom error message so let me show you how we can do that so here on the student dto level where we have the not empty annotation here we have a property called message and as you can see here by default it's just carta. validation. constraints. empty. message but we can provide our own proper message and here for example let's say first name should not be empty and this should not be empty and this message will be returned to the user also I can copy that and add this message to the last name and here I will say instead of first name I will just say last name so now let's restart the application and see the impact or how this is going to be displayed on our postm now all I need to do is to click on send again and here we see we have first name should not be empty and last name should not be empty and in this case we can even enhance a bit a little bit the code that we created so we no longer need to expose the field name that we have in our back end all right so let's go ahead maybe UND do this or we can just for now leave it as it is because I will show you a better way how to validate objects so now we can move on and explore the rest of the annotations that we can use to validate the different type of objects and the its different boundaries so in the project if you go to external libraries and then scroll down it's almost in the middle and you will see a dependency called Jakarta validation so this is the dependency that we added already in the pom.xml file and then if you if you expand this one you will see a package called Jakarta validation and then you have a sub package called constraints and here we we see the list of all the annotations that we can use to validate fields in a class and now let's walk through these annotations and see what are the use cases for each one so for example here we have the first one assert fals and and from the documentation the annotated element must be false and the same for us or true this means that the annotated element must be true for example if you have a Boolean field and you want to add the validation that this Boolean field should be true or false you can use The annotation assert true or assert false now we let's move on to the decimal Max and this one this annotated element must be a number whose value must be lower or equal to the specified maximum so if you want for example that a field or a value should not pass the value equals 100 for example you can use the decimal Max and give it the value 100 and then the validation will take care of the rest and make sure that the value we that the value we receive should not go beyond 100 and the same for the decimal Min so this will check and validate if this decimal or if the value should not be under that value we specified and here also you need to check the supporter types so here we have so for the B decimal Max and decimal mins so we have it applies to Big decimal big integers Char sequence bite short in long and their perspective wrappers so wrappers means the integer class and the long with with uh an uppercase or a capital L and so and so forth the next one we have digits so this annotation the annotated element must be number within accepted range so here we have a message group and we have fraction and we have a list of properties that we can specify when we use this annotation and the next one is email so as the name mention so this one it will make sure that an email address or string email address should be well formed and here we have by default or we have a default rejects for the email so this is the one provided already by the Jakarta validation but if you want to provide your own email formatting rejects just use the the property called rejects p and you will be able to format or to give the rejects for your email then we have the future annotation so this annotation is a appliable to all the date types as you can see here so here this annotated element must be an instant date or time in the future so when for example when you have a field date let's say for example uh event or event date or something like that and we want to make sure that this event date should be in the future we can annotate this field with the future annotation and then of course the spring boot starter validator will take care of the rest so also if we want the DAT to be future or present we can use this future or present annotation to validate that then we have the Max and Min so the Max and Min so this annotated element must be a number whose value must be lower or equal to the specified maximum and the same for the minimum and here we see also the list of the supported types then if we want a value to be negative or you need to do is to an annotate the field with the negative annotation so this annotated the annotated element must be a strictly negative number for example zero is considered as an valid value so it will should be or the value should be lower than or strictly lower than zero and then we have if we want to accept zero values for example we have The annotation negative or zero and it will do the same except that that this annotation accepts the zero value then we have the not blank annotation so this annotated element must be not null and must contain at least one nonwhite space character so this is important so for example if I pass a white space and I use the not blank annotation to validate the field so this will throw a validation exception as we saw before so here we have the not empty and the not empty we already used and we saw in action so this will just ensure that the element must not be null or empty but it accepts white spaces and then we have the not null so for the not null it just checks that if the value or if the element must not be null and then we also of course have the null so since we have the not null we have also the null so this checks or um specify uh that the annotated element must be a null Val value and here it says accepts any type so we can use this null or not null on any type so then we have we go back again to the to the date annotations so here it's exactly the same as future and uh and future or present we have also past or past or present so for example past we can apply it to date of births to uh a date that we wanted to be in the past also we have the past or present where we can use this annotation to make sure that the date should be in the past or we also accept a present date so present date means today's date then we have the pattern annotation so this pattern annotation is appliable on annotated uh or a field of type chge sequence must be a match for the specified regular expression so here we have like 100% freedom to specify the regular expression that we want to to to use it to validate the this field and then we have positive so this ensures that the the annotated element must be a strictly positive number so zero is Al also considered as an invalid value so here you need to know exactly the difference between for example positive and positive or zero so pos positive or zero just the difference that it accepts zero and finally we have the size annotation so the annotated element size must be between the specified boundaries and for example here if I have a string and I want the size or the length of that string to be between a minimum and a maximum value all I need to do is to use the size and then specify the minan and the max values so these are the the all the annotations or all the validation annotations that we can use also we can create custom annotations but this we might cover in the future lesson for now let's move on and let me show you how to validate or like how like it's a proper way to validate objects all right so now we implemented or we are almost done with the implementation of our rest API we also organized the code we added the validation we are the mapping our code is well organized and each part and each domain is in uh is in its own package and everything is all right also we test the application and the application is working fine but the question is are we done with this implementation so let me give you the answer so the answer is no because we are missing really a crucial part and a critical part of the application which is testing yep exact it's all about testing because why we need test because for example if I do a small change in one of the domains that we have what are my guarantees to say that this change won't impact anything else so software testing is a crucial process in the realm of software development designed to identify and rectify defects errors and inconsistencies with a software application it serves as a quality assurance mechanism ensuring that the software performs as intended and meets the requirements and expectations of both developers and and users through a systematic and a structured approach software testing evaluates various aspects of programs functionality usability security and performance so then in the next part first we will see what is the importance and how spring is going to help us for testing and after that we will try and we will do testing and we will see software testing in action so we will implement the three parts of Tes testing so unit testing integration testing and endtoend testing so stick with me and I'm really happy you reach this part and let's go ahead implementing tests for a spring boot application is important for several reasons first we talk about quality assurance so tests help ensure that your application functions as a expected they identify bugs error and expected Behavior early in the development process allowing you to fix issues before they reach production and then regression testing as you make changes or add new features to your application tests act as a safety net to the catch regressions they ensure that existing functionality continues to work as intended even after code changes also test serves as documentation for your code base they provide examples of how your code should be used and demonstrate its expected Behavior this is especially helpful for other developers who may join the project later on also a well written tests encourage good coding practices and modular design they often lead to the more modular Lo L coupled code that is easier to maintain and refactor when you want to refactor or optimize your code tests provide a safety net they allow you to make changes with the confidence that you'll immediately know if something breaks also the test facilitate collaboration among developers when multiple team members are working on the same codebase tests ensure that changes made by one developer don't negatively impact the work of others also in a cicd pipeline or like continuous integration continuous deployment pipeline tests are run automatically whenever new code is pushed this helps catch issues early in the development process and prevents faulty code from reaching production also wrting tests can take more time up front but it can significantly reduce the time spent on debugging later in the development process it's much easier to identify the root cause of a failure when you have a well defined tests as your application grows the complexity also increases tests provide a safety net that allows you to confidently make changes and add features without introducing unexpected issues and finally of course tests certain types of tests like security and vulnerability tests help identify potential security weaknesses in your application this is crucial for protecting sensitive data and ensuring the overall security of your application so generally speaking in a Springwood application you can Implement various types of tests including unit tests integration tests and even endtoend tests so each type of test focuses on a specific aspect of your application's functionality and provides a comprehensive safety net to ensure its reliability and correctness now let's see how spring can help us in implementing the test and what spring provides exactly so first spring provides utilities and annotations for testing applications so the test support is provided by two modules the spring boot test contains core items and the spring boot test Auto configure supports Auto configuration for testing and then we have also the spr spring boot starter test which Imports the following modules first of all we have the spring boot test module we have also junit assertj hum Crest and number of other useful libraries so a springbot application is a spring application context and this I will explain it more in details when we go to the practice part so the spring boot provides a spring boot test annotation when you need spring boot features during test so for example if you want to load the application context in your tests all you need to do is to annotate your class with the spring boot test annotation and then in case you are using junit 4 you need to add the The annotation run with spring runner. class to your test otherwise The annotation will be ignored other than that if you are using junit 5 there is no need to add the equivalent extend with spring extension as the spring boot test annotation and the other annotations will be already annotated within the at Spring boot test so now we mentioned that spring comes with a spring uh spring test Auto configuration module so the spring boots Auto configuration system works well for applications but can sometime be a little too much for tests so it often helps to load only the parts of the configuration that are required to test a slice of your application so the spring boot test autoconfigure module includes a number of annotations that can be used to automatically configure such slices and finally each slice restricts component scan to appropriate component and loads a very restricted set of autoconfiguration classes now we are done with the theoretic part this might be a little bit too much or like too much talking now we will move to the practice part and you will be able to understand and start implementing tests your own so let's move on and let's go ahead and do it all right now let's dive into the implementation of tests for our different classes so here this is the diagram or the composition or the class diagram of our small application and I'm focusing only on the student domain so here we see from the bottom to the top we have the student composed of the student service this means that the student controller uses the student service and the student service use both uh of student repository and student mapper and the student mapper will use both object student and Student Response dto so now I want to tell you and explain to you what you need to implement test for so what do you need to test which classes and which objects you need to implement tests for so here we see that the Student Response D and the student object they are just classes so there is no logic inside it so it's just a class holding some information about the student and this class or this record is only holding some information about the Student Response dto now if we go a level down we see that we have the student mapper and then we have the student repository so the student repository we can also Implement test for that but it doesn't make sense or it's not really required to implement tests for repository so we will skip this one now let's start with the student mapper so the student mapper right here so if we go to the navigation or if we navigate to the student mapper right here to this class class we see that we have two methods all right so now I want you to change a little bit your mindset and suppose that you don't know the code before so you just have a mission or you're asked just to implement tests for these classes so here we have two methods to student and to Student Response dto so the first one will return student object and the second one will return a student response dto so normally from the name of the method we can understand what is its functionality otherwise we can go ahead and read the code so we don't need that because we already implemented this our own and now what we need to do is to create a test class for this student mapper so to create a student mapper test class let's start with the recommendation so here we see that we have the Java and this is the base package that we have which is com. al. example and then we have school and student and student profile and so and so forth forth here if we check the test we have also Java and then com. alibu example and here we have also example application test which is the same or like the same loader class or the class that will load the application context for our test so for now we will just ignore this one and I will explain it in the coming sections all right now the first recommendation is when you create a test class for one of the for one of the services or the CL classes that you want to test be sure and make sure that you keep the same package naming so you you need to keep the same hierarchy of of packages and folders just to make it easy to find so you can just create it anywhere or like even without creating packages but the recommendation to make your test classes clean and clear and easy to understand and easy to point you just need to keep the same hierarchy or like the same package hierarchy and we are lucky because our IDE whether you are using anj Eclipse net beIN and so on so forth you always have some shortcuts and you have the instruction and menu to generate test classes for the class that you want to test so here if I open back my test student or like my student mapper class and I want to generate a test class for it so if I do like um right click and then let's click on generate right here so here we see that we have many options and among these options we have test so if I click on test you will see that it will be it will be generating a student mapper and then it will have or it will give it a suffix called test all right and here you see the destination package it will be com. al. example. student you can select a different one or you can change the name and so on so forth but as I mentioned before I recommend you keep the same the same hierarchy and then you also can generate methods for setup tear down or also showing the inherited methods and even you can generate two methods or like two test methods for the two student and two Student Response dto but for now we won't do that we will do it one by one and step by step so I will cancel then we have a different option so here just um focus on this area you will have this green popup to show you which uh command or which shortcut or keyboard shortcut that I will be using in order to navigate to the test so here if you do uh command shift t or Control Plus shift plus T if you are using Windows or Mac anj will try automatically to navigate you to the test class of this student mapper all right but if it can't find any test class it will suggest you to create a new one so it will also open and display the same window that we use before or that we saw together before and here for the testing Library since we are using Java like recent version of java and also like a recent version of spring boot so we we can keep or we can use the junit 5 also if you have another project uh using junit 4 for example I already explained that before that you need to add few annotations or like one annotation in order to make it work so now all we need to do is to click on okay button and here you see see that automatically a new package was created and it contains a new student mapper class test all right so now we have everything ready let's go ahead and start implementing or let's start writing the first test method that we have for our student mapper class all right so first of all let's generate a first test method to create a test method all you need to do is to create a public void so this is this signature and it should be always public void and then the method name so let's call it test method one so this this will be the first test method and the test method is a method without any parameters so here to make this test method as a test method so all we need to do is to add The annotation test so the test it comes from org. gun. jupiter. API so here once we are this test you see automatically that now we have this button to run this single method or you have this button right here to to run all the test methods inside this class so let's first of all just add a system.out do print Ln and here my first test method and now let's run this test class using this play button to run only this method since we have only one or if we want we can run the whole test so let's run student mapper test class and then you will see that it will open the test View and here we have the system.out.println the message that we printed my first test method and the test was green since we have nothing to assert yet we will come to this in few moments but before that we need to understand what are the properties and what are the things that we can do within a test class so the first thing that we need to know is that we have a setup method or we can create a setup method so if you click on generate here you will see that you have a setup method you can generate it automatically or you can even write it your own so let's generate it and see what it what is this method so it's just a void called setup and it contains an annotation called before each so this means that this before each method or this setup method will be executed before each test that we have and we mainly use this setup in order to initialize few things or few parameters or anything that we want to initialize before running any test method that we have so I will just copy this message right here and here I will just write inside before each method and now if I run again my class let's see what will be the output so here we have have if I click in here we have inside the before each method and then my first test class so now I will just duplicate this method right here and I will call it my test method two and here I will say my second test Method All right so I will rerun again the class and here we see that this one we have inside the before each method my first test and here we have also inside the before each method and then my second test so as I mentioned this before each will be executed before each test class so in case as I mentioned before in case we want to initialize anything before running the test Method All right so also as before each we have other methods and let's go ahead and explore them one by one in order to understand the structure of a test class and what are the usages and the benefits of using this methods all right also if we want to execute any script for example to reset the values of variables or classes or services or whatever we also have a method we call it tear down so the tear down is after each execution of test method so here let's use the generate again and here we see that we have the tear down method so let's generate it and here you see after each so let's copy this same message and here inside the after each method when we run the test class we will see inside before each method and then my first test method and finally inside after each method so let's go ahead and execute it and see the output of this execution so now I'm going to select the first method and as I mentioned we see inside before each my first test and then inside after each so as I mentioned before in case you want to reinitialize or for example to change the value of a specific attribute or for example if you are running your test against database so you can just initialize and insert some data in the before each and after each you can delete them or reupdate the data in order to be able to use them in in the next Method All right so now let's move on and let's see what are the other methods other than the before each and after each all right now the question is what if I want to execute a setup or to initialize a few attributes and variables only before the execution of the the whole class so I don't want to run this method before each method but I just want want it to be executed only once so in this case we have also another method so let's click on generate and here we see we have a before class so when I use a before class so it's called a before all again I will copy this message and here I will say inside the before all method so now when I run my test so you can whether run it from here or again click on this play button or just run one of the tests so let's go ahead and run and rerun the whole class and see what we have so for example let's select this one so here we have first when we select the method we see only this three output messages which is the before each the method and then the after all but when I select the class we see that we we are inside the before all methods and then inside the before each method and the after each method and we have it again for the second method so now just I want to make this output clear so I will be running only one method so like that you will see it in a better way so now we see that we are inside the before all method and then inside the before each my first method and then inside the after all method so this is the case if I want to initialize something a service for example or to create a new instance of an instance or an array list uh or something like that but I just want it to I want to do it only one time I don't want to do it each time so in this case we need or we use the before all method so now in the same way we have another method called after all so let's go ahead and try this one and then let's move to the real implementation of the real test cases of our student mapper class all right in the same way let's generate an after class or an after all method and again I will just copy paste and here inside the after all method so if I run one of the test classes or the test methods that we have and here let's go ahead and check the output so here we have inside the before all and then inside the after all and in between we have the before each the the test method and the after each so the use case of the after all and the before all is for example I want to initialize or insert some data into my database in case we are using for example an inmemory database so I want to insert some data and then once I'm done I want to remove them for example or even if I'm working against my Dev environment uh database or something like that so in this in this way we can initialize data work with them and once we are done we can remove all the data that we already inserted so in this in this way we are safe from polluting and inserting wrong data into our database all right so now you know the structure of a test class what are the methods that we can use within a test class so now let's go ahead and start and implementing few test cases for our student mapper class all right now let's start implementing our tests first of all let's start by cleaning up all this code so let's remove it and also let's reoptimize the Imports and now let's implement the first method so here just to remind you we have our student mapper class that performs a mapping so it transforms a student dto to a student object object and then we have to Student Response and it transforms a student to a student response dto so now coming back to our student mapper test so here the first thing that you need to do is to declare the service that you want to test so here we want to test our student mapper so let's create an object of type student mapper and then let's call it mapper for example and then the first method or like the first use case or the test case that we want to implement is that we want to make sure that these two student mapper performs a correct mapping from student dto to the student object so here let's create our first method public void and let's call it should map student dto to student class all right so this is our first method and to make it a test method we need to add always the test annotation so the then you see that this student mapper right here is not yet instantiated so we don't have an instance or an object of type student MPP so it's just the variable or the field so now we have two options whether to initialize it in here so we can do new student mapper or we can use one of the test of of the setup methods so here we can add a before each and then we can move this part right here to this setup method so we can make it this way or the other way around so let's go ahead with the before each so now we have our mapper object initialized and now let's start creating and implementing our first test method so here the first thing that we need to do we need to create an object of type student dto since this is the input of our two student method so now let's go ahead and do it so here we have an object of type student dto let's call it dto equals new student dto and for this let's call it John and then for the last name let's call it do and we have an email so John mail.com for example and then we have an INT the school ID so in this way so I'm going to just inline this one so in this way we have our student object so after that all we need to do is to call the to student method so here let's create an object of type student and let's call it student equals our mapper DOT to student and then we pass the student dto and then we will start asserting that the output of this mapping method is what we expect so here let's go back to this two student method and we know that we when we call this student method we just set these fields and then we have an object of type school so again we can test so what we want to focus on is that we have also a mapping for this school object and that we have all the fields not changed so now let's first start by asserting and in order to assert so here we have assert equals and this assert equals so it comes from assertions so the assertions is from the package org. gun. jupiter. api. assert equals and here for the assert equals we have multiple implementation so we can assert equals shorts bytes uh strings integers and so and so forth so here let's do assert equals and then what we want to test we want to make sure that our dto doget first name to be equals our student object. getet first name so here we want to make sure that that this first name is the same for the class student all right so now also we can import statically this assert equals and we can do that by add static import for the unit uh Jupiter API assertions do assert equals so when we do that and when we go up so you will see right here that we have a static import for that method so the next time you see assert equals or any static usage of a method so you know that it's statically imported in here all right so now let's continue the assertion and here we have the first name let's also test the last name and here get last name and after that we have the email and also here get email and finally we want to make sure that this the school is not null so here for example we have the assert not null so as you can see here so I want to assert not null that my student student. getet school is not null all right so then we can also make sure that the school ID was correctly set so what I can do we can assert equals so our dto do school ID is the same as student. getet school.get ID so at this level we are safe because we have an assertion that the school is not null but if if we change the order we might encounter a null pointer exception in case this school is not correctly mapped so now let's just go ahead and run this test method and let me show you what is the impact and the execution of this method so here we see that the method was green but now you might ask the question I'm just making sure that this object that I created manually is the same as I called this method so now let's go to our student and for example Le let's say that I forgot to set the school to the student object and now if I go back and rerun again the test let's see what will happen so here we have a test failed so here we see that expected not null but the object was null at this point so here you see that assert not null of the school so this means that the school was null and I'm expecting the school to be not null so now step by step you see the importance of having unit tests within our application so let's go back to the mapper and let's bring this back and then for example let's say when I transform the first name or the last name I just I just do to uppercase all right so I transform the first name to an uppercase if I rerun the test again you will see that the test will fail and here we see this message so here we have assertion failed error and the expected was John which is the object right here that we initialized with with our dto and the output was drawn with an uppercase so this is also another or a different assertion level or an assertion test that we make sure that the input should be exactly the same as the expected output all right so now let's go back to our mapper and let's just remove this one and in case for example you have changed the implementation of these two student method you need also to update the test okay so in this case you make sure that everything works fine so let's run the test one more time and make sure that everything works fine so our test is green now we can move on and Implement other tests all right so now since you know and you understood how to implement tests so I want to give you a small exercise I want you to implement the test method for for testing these two Student Response dto and it should take a student object and then return a student response dto so you can also Inspire and follow the same example we did right here I want you to create another method and you call it should map student to Student Response dto so I will let you do it and I will provide you the correction in the next lecture that's good I was sure that you will implement it correctly so let's do it together all right so first of all we need to create a public void method and then let's call it should map a student or student to Student Response dto all right and then parentheses and then the brackets and don't forget the test annotation all right so the first thing as we did before we need to create an object of type student all right so here go student student calls new student and then let's initialize our student object so here let's say Jane as a first name and then Smith as a last name and then let's provide an email so Jan mail.com and then we need an age let's say for example it's 20 and let me inline this all right so now we have our student then all we need to do is to create an object of Student Response dto and let's call it response equals our mapper and then to Student Response T and we need to pass our student all right now comes the assertion part so the first thing we need to do is to assert first name last name and email and make sure that the result is the same since within our Student Response dto we only have three attributes all right so now let's say assert equals and then I want my response. first name to be the same as my student. getet first name the same for last name so here last name and then get last name the same for the age I want the age to be the same as the student. get H uh sorry we don't have an H for the response dto but it's email and here it should be the same as get email all right so now let me add a few comments so here how how we can read the test so here we have given a student object and then when we map the student to a Student Response dto then I want or I expect this result so now let's go ahead and run the test and make sure that everything works fine and we did not forget anything so the test is green Also let's go ahead and run the whole class and here we have all the tests are green and passing okay so that's it let's move on and let me talk to you about something really really important when you implement an application and mainly you can detect that with the tests all right now let me talk to you about something else so here I will just start by creating a new test method and after this method I will just create a method called public void and then this is also a different way of writing the the method name so we can write it in this way should map student dto to student object all right but this new method I want to add if or let's make it when student dto is null so this means I want the mapping to be or to perform correctly or in an expected way even if the student dto that I'm passing right here here is null so what I will be doing I will just copy this part right here and then paste it in this method and instead of passing the dto I will pass a null object so here what I will be doing let's say for example so we will change this later on but let's start expecting this so here let's say an empty string and here empty string all right now if I run this test method let's make it a test and if I run this test method let's see what will happen so here we have a null pointer exception cannot invoke the student dto do first name because dto is null all right and the exception happened inside the mapper itself so if I click here we see that the the problem is exactly in here because we are trying to get the first name from a null object and here we mainly talk about code coverage so we need to cover all the use cases that our method and our service class and our class generally speaking should handle so here you see and you noticed that we did not handle the case when we pass null dto object so in this case what we need to do we need to go back to our student mapper and then we need to add a test or a check or do whatever just to make sure that when we receive null object we want to do something whether raise an exception or just printing a message or even for example initializing an empty student object with for example let's say empty values so the implementation always depends on the requirements of of your story or of the application that you are implementing so now let's go ahead and start doing this so in this case or in this use case we will see many things so the first thing let's go back to to to student and here I want to do if my dto is null for example I want to throw a n pointer exception all right so here we need the new keyword so a new n pointer exception and here the student for example as a message the student dto is null all right so now we add we added a coverage to our method so now let's go back to the test and make sure to to readjust the test right here in order to make sure that this student method should throw a null pointer exception when we get a n dto student so we don't need this one since we don't have any assertions and now let's just rename this method to make it more relevant and here instead of should map so let's say should throw and then a null pointer exception when student dto is null so now we have this mapper do to student and then we are assigning it to a student so we can also remove this assignment since we know that it will throw an exception and it will return nothing so now how can how can I expect or make sure that these two student is going to throw a null pointer exception so in order to do that all I need to do I need to assert that this method is going to throw a null pointer exception so I'm just going to remove it and now I'm going to use assert throws so here this throws method first of all it gets the expected type so in our case it's a null pointer exception. class and then it's a Lambda expression so here when we call the mapper do2 student I'm expecting to have null pointer exception. class thrown so let's run this method and make sure that it passes green right now so now this method is throwing this exception so now what if I want to check the message that the message should be the student dto is null or should not be null so here let's just rename it should not be null and I'm going to copy this message and now I will go back here so in order to do that all I need to do let's create a VAR message equals this so as you can see this a assert throws it will return the exception itself all right so now if I do MSG Dot and here here I have access to the method get message from the NP pointer exception or from the exception generally speaking so now I want to do assert equals I want this error message to be equal to my message or exception. getet message so let's just rename this one to exp to say it's an exception so exp for exception and now if I run again let we need to be sure that the the method through this exactly the correct error message so here for example if I add a DOT and run again the method should fail and as you can see now the method failed and the assertion failure is we are expecting this but we got this one so in this case we gained two things the first one is that we add a coverage to our two student method and then we also covered this with within the test so for example in case I want to change from null pointer exception to a different exception it will be automatically detected by this test method again if I change for example the exception message it will be also automatically detected so now let me run it again and make it green and now we added a new coverage to our method so this is how you can test exceptions and this is how you can catch exceptions and make sure or you can do whatever you want even if you work with custom exceptions that you create your own you can also capture that and do whatever you need to assert everything is as expected all right so now let's move on to the next part all right so we finished the implementation of the student mapper and we saw how we can create a test class how we can create test methods also we saw how we can or how how much we need to cover our code like we need to cover all all the use cases now let's move and start testing or writing tests for our student service so we know that this student service is a spring component and it has a strong dependency with student mapper and the student repository and especially when we talk about student repository we talk about communicating with database so when it comes to testing how can we test and how can we tell spring or this student service that we have a student repository and this one needs to communicate with the database and what happens in case we don't have a real database for testing because testing it does not necessar necessarily need to have a database for testing so that's why we will talk about test isolation so test isolation means that we want to run and to write tests for this student service in isolation of its dependencies in a different way I want to execute and write test for this student service but I don't necessarily need to have the real instance and the real object of my student repository the same for my student mapper so what do I need to do I need to mock these two objects so to do that we have there is a framework called mokito so mokito is a popular Java test in framework that helps you create mock objects and stab behaviors when writing unit tests so it's especially useful when you want to isolate a specific component of your code and test it in isolation from its dependencies so now we know what we need to do we need to isolate and we need to mock so you need to remember this term we need to mock our objects we need to mock the student repository and the student mapper to be a able to run the student service test in an isolated way so let's go ahead and let me show you how we can isolate and how we can marck the objects and the methods for each service that we have right here so now as always the next step is we need to go and create a test class for our student service so all I need to do navigate here and then command shift T and create a new test so here we don't need any of these we just maybe need or use the setup method so I will just check it out and then click on okay so here we have our before each and we have our student service test class so as we did for the student mapper what we need to do here first of all which service that we we want to test so in this case we want to test our student service so I will create an object of student service and I will call it student service and then when it comes to objects that have dependencies let's check in here so we see that our student service has two dependencies that we need to inject all right so our Constructor is a Constructor with parameter and it requires an object of type repository and an object of type student mapper so let's just go ahead and do that I'm just going to copy this one and and in here declare the dependencies all right I'm going to paste this and then I will just fix the code all right so now I have my service and I have the dependencies so what I need to do so we said that in order to run the student service in an isolated way what we need to do we need to marck this student repository and the student mapper so what we need to do there is an annotation called mock so this mock annotation comes from or. mokito it's not the one coming from the or. spring framework we want to use the mock from org. mokito so let's select it one and the same we need to add it to our student mapper so in this in this way we are telling our test class and the mokito framework that we want to create mock for this repository and a mock for this student mapper all right now how can we tell this mocking framework that we want to inject these two properties and these two dependencies into this service right here so the answer is kind of straightforward because I just mentioned injecting so we have an annotation called inject MOX so inject MOX always is coming from the or. moku package and like this our mocking framework will try to find any dependencies annotated with the mock annotation that is compatible with the dependencies that are required from our student service so this means when we try to create an instance or to initialize this student service the mocking framework will look for two object annotated with the mock annotation and that are of type one of them is of type repository and the second one is of type student maper all right so now we prepared everything we still need to do one more step so then what we need to do we need to tell the moito framework that we want to open the mock or like we want to start the mock for this current class so this means that in the before each here what we need to do we need to use the moito annotations class doop Mox and this open MOX takes an object which is the test class as you can see right here so let's give it this because we want to open the mock for the current class all right so may you might see this warning right here this is because the open mock methods return and autoc closable so and this the anj or your IDE will recommend to you that you might need to you might want to use a try with resource but we can ignore that for the moment it's not something really important or really really uh going to break our test all right so now we set up our test class now let's move on and implement the first test method that will allow us to save a student so the first one it will be this save student that's good now let's analyze our save student so we have here first of all we are doing a mapping and then saving the repository and then again we are doing a second mapping P so this is what we need to test in our test method so let's go back to our student service test and here I will create a public void and then should successfully save a student all right so this is our test method let's not forget the test annotation and now here let's remember the given when and then so here given what so here in our save method we have a student D so let's first of all all create a student dto object so let's go back here and here I have first of all my student dto object also this class is going to need an object of type student which is this one so let's also go ahead and prepare our student so it will be almost the same so just copy the signature right here and here I will create an object of type student let's call it student equals and then new student all right here let's remove this one all right here we have also our student object and our student dto so what we want to do or like how this is going to work this means is when we call our student service do saave student we are expecting an object of type Student Response dto all right so here I will create an object of type Student Response dto I will call it response dto equals our student service do save student and then we have a dto so this is the dto that we will pass as a parameter and then what we need to do is to start asserting so let's say assert equals and then we have our dto object. getet first name should be equal our response dto do get first name all right let's do the same also for the last name and also the email so we can stick just to these few fields we don't need to test everything so this is what we want to test so now if I run the test what should happen so let's go ahead and check together so I will run this test method and let's see what will be the output here we see that we have a null pointer exception saying that we cannot invoke Student Response do get first name because the response is null and this this is happening in here so this means what I'm going to just add a break point right here and I will run again this test in debug mode so here let's see our student service so we have an object since it's already mocked the same for our repository so we as you can see we have a moito Interceptor and so and so forth so now if I evaluate this expression and then evaluate expression and then evaluate we see that the result is null okay so let me explain to you why we have this null result so this null result is because the student service is trying to call the student mapper and then we have the student repository is also going to call the save method but remember here we have a mock so we don't have the real instance or the real service running for our test because we decided to run our student service in isolation mode so to do that what we need to do here we need to mock the calls so which calls that we need to mock we need to mock every call that uses another service or another dependency in our student service and in this case we have the student mapper and we have the repository do saave so let me show you now how we can mock these calls so the first thing that we need to mock is the as you can see here the first thing that we that we do is the mapping so let's mock the mapping all right so now in order to mock the calls so the first thing that we need to mock is our two student so student mapper do two student method so this comes from moito we have a static method called when so this means when we call a method so we have as a parameter the method to call so here we have student mapper do to student so when we call these two students with our dto object so make sure that the mock will work only if we pass this object right here so then what we want to do then we have so many options so we can return we can return with a student we can also a student and a list of other students we can return an answer or we can even throw an exception so in our case we want to return an object which is our student right here so let's return the student and now we are done with the first mock of our student mapper do to student method so here when we say when we are mocking a method all right so this when we call the student mapper do2 student dto then we need to return the student object so this means that our student service will run in isolation mode and it does not 100% depend on the real implementation or the uh not the real implementation but the real instance of the student mapper so also let's import this in statically so when student mapper then return all right so let's do the same for our repository so when our repository dot save and then student then return our student itself all right because we know that when we save a student we return another student or if you want to be more consistent or if you want to have like more uh details you can even create another student object you can call it like saved student and set the ID and set everything and also you can return that one so let's just do it it's it's totally fine so I will call it saved student and then I will just do saved student. set ID and let's give it the ID number one and in here I will return our saved student all right so now we have three objects so first we have the dto and then the student that will come from the mapping and now this is the student that should be saved in the database so now again we mocked the second call which is our repository so if we go back in here we still need to return another call so here we need to mock also the student mapper do to Student Response dto so in order to do that just in the same way so here we have when we call our student mapper do to response dto of our student object which one which is the saved student all right so here we have then return let's now just return a new student response dto and all we need to do is to pass the first name last name and email so this is the first name last name and email so let's let's just copy them from here so we have our John do I'm also going to inline this so you can see the full code and the email is just John email.com all right so now we have our test set and ready so let's go ahead and run the test right now and see the output so I'm just going to click and run this one and let's see what will happen so now our test is green so we have all the expectations and everything was running in a successful way because we have here we mocked everything and in case for example I just change anything or you forget to uh to mock a step your test will fail that's good now we created our first test method and we saw how we can mock objects and also do some assertions so this is the classic assertions but now what if we ask the question how can I check that my application is performing well so here for example in this save student I want to make sure that I only save one time the student into the database this means for example I don't want to have some error or like someone typing two or three times this repository. saave because this will save the student many times and in case for example you have a un constraint it might throw an exception and this will break the application so let me show you how we can prevent this from happening so if I go back to my student service right here we can do this in the same place since we have our code already set up all right so here we are mocking and now what I want to do I want to make sure that this student mapper2 student was called only one time same for the repository and the same for this one all right so to do that mokito also provides us with a method called verify as you can see here so we want to verify and then we need to to type the mock object so our mock object is the class or the instance itself and then we can pass a parameter so it's a verification mode so here we have okito do times also we have out we have so many other options I can for example check that a method call should take only just just as an example should take only 2 seconds maximum to be executed if it goes beyond 2 seconds the test will fail and like that I can also make sure that I have performance issues with my application all right so now let's continue with this times so I want to be sure that this student mapper dot to student and then the object student dto or the dto object that we created it has been called only one time all right so let's do the same for repository and then times one and then the save method when we pass the student object again I will do I will duplicate this one and here student mapper and then to response dto or to Student Response dto and here just to make sure that we passed the saved student as an object all right so here we need to say saved student all right I'm just going to align these methods right here just so you can see everything so here verify that this method or these three methods of the different Services were called only one time so let's go ahead and run the method again so run this and then the test passed so now let's suppose for example that one of the developers or me for example as also as a developer of this application I accidentally forgot to remove this extra line all right so now if I rerun the test again let's see what will happen so the test will fail and we will see here that wanted one time so this means that we wanted to have our call only one time but it was called two times and here so as you can see here you have student service. save student that was called two times all right and it was pointing to here and then to here so here we see that even the test will point us directly where the issue has happened all right so that's good now let's move on and let me give you a small exercise and I'm pretty sure sure that you will be implementing it really easy without any issues now let me give you an exercise I want you to implement the test for these find all students so it needs to cover and to make sure that when you make a call to this repository. find all it should return the exact same list that you already expect and in the next lecture I will show you how to fix this one all right that's good I'm sure that you correctly implemented the test for this find all students but also let's go ahead and do it together so I will create as usual a public void and then I will call it should return all students and then we have the given so for the given the first thing that we need to do is to create a list so let's create a list of students so this is the object that will be be returned so let's call it students equals new array list and then let's add one student so student. add and we can even copy the student from the previous method right here so I'm just going to copy this one and I will insert this student here all right so now we have one element in in our student list and then we need need to mock the calls so the first call that we need to marck is when we call our student repository or the repository object do findind all then I need to return the students list that we created all right and then what we need to do we need to marck the call for the mapping all right so here we have when mapper or student student mapper dot to Student Response dto and here since we might add or pass any student so we can use the power of moku and here we have argument matchers do any and here when we say any we can also specify the class so when we receive any class of type student do class then I want to return for example a new like a new object of type response Student Response dto something like that so I'm just going to inline this so when we call the student mapper to Student Response passing any object of type student we want to return this object we can also make it more Dynamic but for the sake of a simple um test case it's also easy and it's also okay to make it like this and here we just forgot the test annotation so we need to add it and now all we need to do is to have a list of type Student Response dto and then let's call it response dto equals our student service do find all all right and here so this is given and now it's when when we call this one so then so here for here we do assert equals that our students list do size to be equal to our students dto do size or response dto do size all right so this is the implementation let's go ahead and run this method and make sure that everything is fine all right also should return all students is green we can also add an extra test and make sure that for example this repository. find all was called only once so let's go ahead and test it just to make sure always that we have our application performing really well so here we have our repository and then times one and then dot find all to be called only one time let's rerun again all right so the the test is still green so now let's move on and let me tell you what we will be doing next all right now I want to give you another exercise and I want you to implement the test for this fine student by ID I'm pretty sure you're going to do it in a correct way and I will see you in the correction all right so as usual let's go back to our student service test. Java class and the first thing that we need to do is adding this test annotation and then creating a public void and let's call the method should find student by ID or should return student by ID all right so here always the given and here we have an INT student ID or an integer let's make it an integer student ID equals 1 and then let's create a student object we can also take it from here so let's call it student so here we have student student equals new students and then we have when so here we need to mock so here we have when we call our repository. find by ID and then we pass our student ID and then I want to return an optional do off my student all right and you might ask the question why I used optional because this finded by ID is going to return an optional the second mock that we need to do we need to marck the two Student Response D from this from the student mapper class and to return that one so from that we can can just copy this one and then let's paste it in here so here we have when we make a call to our student mapper we are going to map this one and again we can just go up and copy this assertions so here I will create an object of type Student Response dto I will call it dto equals my student service Dot find by ID and then I will pass the student ID that I created and now we have the then so here we start the assertions so here we have our the dto do first name should be exactly the same one as the student. getet first name so here I will just copy the student from here and I will just replace it in here so now we can select all and here we have get and then let's make this one uppercase and now that's it also we can add another check we want to verify that our repository has been called one time for the method find by ID so passing also the student ID as an object as a uh as a parameter and now let's go ahead and run this new test Method All right so we might miss something okay so here expected John example.com but the actual was john. mail.com so maybe let's fix it so here we have mail let's change this one also to mail and let's rerun again and the test is green and fine all right so that was it for this method let's move on and implement the next one that's good you really made a really good progress and I'm really proud of you so the next method that we need to implement the test for is find student by name and just I want to give you a quick hint you can Inspire from the previously implemented methods in order to implement it in a correct way so take your time and I will see you in the next lecture to provide you the solution for this exercise all right you did a good job now let's correct this exercise together and you might learn learn something new so as always we need to add the test annotation and then we have a public void and let's call the method should find student by name all right so then what we need to do the first thing we can also copy things from what we have before so I'm going to explain it one by one so we can copy this part right here we can also copy this one right here so here we copi it so also let's copy it with a given so here the initialization of the students list and then we have the mock for the find all this one we will change later on and also we need to copy the mapping so let's go back here and now so when we call the find student by first name containing and here I just need also to declare a string student name let's call it John all right so here containing student name then return the students list and then when we call the student mapper do to Student Response dto of any student object I want also to return this mapped object or the Student Response dto now when I call so here let's use VAR just to make it shorter I I will call it response dto equals our service do find all by name and here I need to pass the student name so then I need to do some assertions so I want to do assert equals that the students do size is equals to our response dto do size so this is what we need to do or what we need to check also we can add a verify that our repository has been called one time for the method find all by first name containing our student name so I'm going to break the line for this one and now let's run the test and check the result all right so the test is green and our method is correctly implemented all right that's good so now we still have only one method in our student service so let's go ahead and create an exercise for that and also we will see the solution together congratulations on mastering the intricate Dance of the spring framework you've built a solid foundation but guess what there's a whole universe waiting to be explored the enigmatic realm of spring data jpa ever wondered how the Pros handle data persistence in style we're about to reveal the secrets that will transform you from a spring Enthusiast to a data wizard back up for a thrilling right through repositories relationships and the Art of querying with finest you've tasted the sweetness of spring boot access now let's add the spice of spring data jpa to your coding Journey get ready to play play with embedded entities Master the Nuance of ID generation and harness the power of named queries and specifications before we dive into the nitt gritty don't forget to subscribe to my YouTube channel and join our Vibrant Community elevate your coding skills with Fresh weekly content delivered straight to your virtual doorstep all the links are conveniently waiting for you in the video description don't miss out the coding Adventure your seat is already reserved now that you're locked loaded and subscribed let's get back to business spring boot was just the beginning spring data jpa is the next Frontier ready to unravel the Mysteries grab your coding gear hit play and let's embark on the Epic coding journey together let's get started first of all we will start by setting up our database management system and and for the purpose of this uh course I will be using Docker and I will show you how you can install post degree SQL or my SQL uh database so you have multiple choice also if you have them already installed on your machine you can skip this part so this part is only about installing and setting up the database management system on your machine so uh first of all make sure that you have Docker desktop running uh installed and running and here like when you open the docker uh dashboard you will see this green uh part like here or this green icon so this means that the engine is running so if it's an orange uh color means that the engine is whether is starting or it's not started so you need to make sure that this is green and this is all you need to do okay now let's let's move and uh and St the docker image for post degree SQL the command that we need to run is the following so here we need to use the command Docker run and then Min D to be to say we want it to be running uh in detached mode so we don't want to wait for it and now we want uh our Docker image to be persistent or to have a persistent volume within our system because as you know every time you start a Docker image it will it will start like uh from scratch and it will consider that nothing uh is persistent so if you want to have a persistent Docker volume you need to add this option minus V it's for volume and now for the volume first of all you need to specify the path where you want to store the the data of uh postdegree SQL and for example in my case so it will be in here so I just called it this way it's my personal project data slpg uh for post degree and data for data and then just column here and slash VAR so here we are trying to map the volume from our local machine to the volume that postre SQL will be using okay so uh it will be /var slash lib slash postre SQL SL data so this is the path that postgre SQL uses to store the data okay so now we mapped already the the volume now we can also pass some environment variable uh and these environment variables we need them for uh the username and the password okay so to pass an environment variable it's like following it's minus E and then we have post post agree underscore username this are predefined uh environment variable that postgre SQL will look for and here I will call it just post agress or post degree and then Min E I want to pass a second uh environment variable and this one it will be a postre password okay it's a post degree _ password and here I will call it alibu coding the for the password okay and now we need to map the port so this means on which Port we want to run our application so let's keep it the default one which is 4 5432 colum 5432 okay so we will be using or we will be connecting to uh our post degree SQL on the port 5432 okay so now all all we need to do now is to precise or to specify the image name which is in our case like we said we want to use post agress so it's going to be postgress now let's hit the enter button and see how it will it will do so here it says that uh unable to find the image post postig latest locally so it will be pulling it from uh Library SLP scale so means it will download the the image and now we see that we have the status downloaded image or new image from post degree uh latest and here we have the hash of the image also you can you can go to Docker dashboard and you will see here that we have this image and if you go to Containers you will see the container which is running okay so and here you can see that we have this container which is up and and running okay so to install my SQL uh using Docker we will follow the same steps so it will be Docker run Min d as uh D for detached and now we want our database or we want our image to be persistent or to have a persistent volume so we can also precise the Min V which stands for volume and I want my volume or my persistent volume to be in this uh in this path so it's up to you to choose where you want to have your persistent volumes and then colum slash VAR SL uh lib SL MySQL SL dat so this is what my SQL uses uh for for data and now we need also to precise some environment variables uh and in this case or for my SQL if we do not precise uh for example the username it will take the root uh as default username so I will I will keep it just uh just root so I will only precise my SQL or this or this environment variable which is the root password okay so it's my SQL andore uh rotor password uh equals and I will keep it empty or you can leave it empty so I want to have an empty password for my SQL uh next we need to we need to precise the port so it will be 3306 mapped also to 3306 okay and then of course the image it's my SQL or my SQL okay now let's hit enter button and it will download or pull the image so now it's it's extracting and in just few seconds it will be done and we will be able to see the hash so this is this is the digest or the Sha of um of the pulled image and this is the ID of the image and also to make sure that everything was fine and okay you can go to image refresh in here and you can see we have the MySQL running and it's already in new so if you click on this one you will see it here that it's up and running okay to create new spring boot project the the recommended way and also the way that I really recommend is to go to the spring initializer website which is at this address start. spring.io and here you have uh a graphic user interface or website where that you can use to create a spring boot project okay so let's go ahead step by step and create our spring boot project so first of all you can choose which um which project um first of all you can use which dependency manager want to use so if you want a maven or Gradle project or here you have also the option for gradel cotlin for people that wants to use cotlin instead of java and here you can also uh specify the language Java cotlin or groovy so for us we will go for the standards which is Maven and Java uh for the this tutorial or for this course because spring 3 is already out so we will be from now on we will be using the spring 3 version okay now let's specify or precise the project metadata so here the group ID it will be um let's call it com. alibu coding and the artifact let's call it because this is a spring data jpa course I will call it just jpa so this is spring uh and the description you can leave it or you can put whatever you want so let's just leave it and this will be our base package or the package name so we want a jar packaging and of course we will use the Java 17 for our project okay now let's add uh some dependencies that we will need within our project so first of all we need spring data jpa and for the people that would be using post degree SQL just choose post degree SQL driver for the people that they want to use the MySQL just go ahead with the MySQL driver okay uh next we need lombok so lombok it's as you know it's an annotation which helps us to reduce the boilerplate code and I will be explaining uh all the annotations that we will use within our project and also I will add uh spring web just in case um we need for example to if you want to need to expose some uh controllers or something like that you can you can use the spring web okay so now once everything is set up you have all the dependencies you have uh all the metadata and you configured everything so we can first go and explore the project before downloading it it and as you can see here we have all the information so is the parent is a spring boot start parent with the version three and here we have the group ID and the artifact that we precised by default the version is 001 snapshot and the name is jpa okay also we have the properties Java 17 and so on so forth and here we have all the dependencies that we want to use and in the end we have this build plugin which is the default one from the spring boot framework and yeah okay so now let's just go ahead and click on download and open our project using inj or your preferred IDE to connect to our database there are so many ways to do it my perfect way I want to have everything in one place so I always go with a database option within anj so by the way this is the new interface so you can download the latest version and enable the beta UI and you will you will have the same uh the same view as me uh okay so let's go back to our database so in order to connect uh you have this um menu right here which called database but if you don't see it um you can go to view and then you have tool window and then you can see here database so if you click on database it will it will open up this this window right here all right so now let's create or connect to our data source let's start with uh post degree SQL so just click on this plus icon let me make it a bit bigger like that so uh when you click on data source you have here a list of um of databases or uh databases um management system so here for example you can also filter type post agree uh to filter for post agree SQL and then click on it okay so this window will show and here we will have a default name which is uh post address Local Host and here you can you can add some comments uh you can also see the connection type which is default and the driver which is post degree SQL driver so this is not the driver that we included to our pom.xml but it's the driver needed by anj or the the database view system that you want to use uh to to be able to connect to the database so um here uh you have postre SQL but for the first time it will it might require you to download the driver so just go ahead and click on download the driver it will be in the bottom here next to test connection and now let's go and configure our database so as you remember from the previous um part we when we set up our postgre SQL we chose the default Port which is 5432 and then we chose uh username and password so for the username we said it's suppos to Gray and for the for the password we chose alibu coding as a password okay now just go and click on test connection once you provide all the correct information so so if you used a different port in here just precise it same for the local host and so on so forth so when you click on test connection so you need to expect this succeeded otherwise you have something wrong whether the password or something like that so let's do apply okay and let's check what we have in here so here we see that we have our post degree SQL and here you have uh one of three schemas or one of three databases so these also are my old databases or the one that I'm using for uh other projects so now the first thing let's go ahead and create our database okay so right click and then new and then you choose database to create the new schema uh let's call it um let's call it data jpa okay okay dataor jpa because this is the purpose of uh of this course now just click okay it's updating or creating the database and then all you need to do click on this uh zero of three icon and then just select the public so you have you will have the public schema by default okay and then every u in the in the future or when we create a new table it will appear under this public right here okay so now we have our post degree SQL set up and running within our application so let's move to the next for the students or for the users that prefer using MySQL instead of post degree SQL so in the same way you have this icon right here that represents the database when you click on it it will open a window like that but if you can see it just go to view menu and then tool windows and then you will see database just click on it and you will have this view available for you all right now let's click on this plus icon to add a new data source and here like I have it uh already in the recent used but also you can filter by typing MySQL and it will pop up okay so uh then you need to preise the same information that you gave when when creating the docker image so the local host or the host it's always Local Host and the port if you follow my exact uh same configuration it should be also 3306 and for the user it's root and the password will precise so just go ahead and click on test connection okay so when you just provide the username and password if you have username and password but if you didn't uh provide a password so just leave it empty and when you click you will see this succeeded means that you are able to connect to your database also one hint be careful and make sure that you have your container running so otherwise you will not be able to connect to the database okay so I will click on okay and now we see that we have our Local Host for my SQL let's configure our project to be able to connect to our database and we will start with uh connecting to post degree SQL but this is important because it's the same configuration and only few changes would be um would be different from MySQL or uh postre SQL so the first thing just go to resources in here and and here we have our application properties files so I like or I prefer using yaml representation so it's the same thing the the only or the main difference is just the way we write the properties so I will use uh yamama representation if you want to use properties it's also okay so just go ahead first of all rename the application properties to application. yaml okay next now we will start providing information or providing properties to our application or to Spring container to be able to connect to the database so first of all our the first property would be spring dot data source and then we need to provide the URL okay so uh to be able to connect to a database we need to provide few information because we have the spring data jpa starter within our uh dependencies so uh we need to provide the minimum required of information okay so for that case we need the URL I will just come back to it uh later we need username so in our uh no not Hikari just just username so for our case for postre scl we say we said that it's post gr and for the password we why this car and for the password we said we want to use alibu coding as password uh and then we need to provide also the driver class name and the driver class name you see here that we have already two or three suggest we have three suggestions so the so the first one or the the first one is for my SQL or my SQL the second one is for post degree s because anj is smart enough to detect that we have these dependencies in our pom.xml so it will suggested okay so now what we need to what we need to do the first one we want to configurate for post degree SQL so just choose the second option or the or the first I don't know the order that it will uh pop up for you and yeah that's it now let's add some other configuration okay here I will add jpa and here I want to tell or to give some extra properties to Spring configuration or to the spring data jpa on how to connect or how to manage or how or how to uh work with my database okay and the first property is part of hibernate and it's called ddl Auto this means what do we want to do when the application starts Okay so we have many options the first one is create drop this means that we'll create and destroy the schema at the end of the execution or the life cycle of our application so when the application starts we will create the the schema and the tables and when we stop the application we will uh we will drop or we will remove everything so be careful when choosing this one the second option is create so when when the application starts it will destroy all the previous data and recreate the schema from scratch so this is also you need to be careful about it we have also the non options mean that we want to disable the ddl handling that that this means that we don't want to do anything when the application starts uh last but not least the update option means that we want to update the schema if necessary so this means what this means that hibernate will compare the the Java representation or the entities it will compare them to the table or the database schema that we have and it will try to to make it uh even but here you need to put in mind something which is really important the update option it will not remove attributes so for example if you have an entity and you create uh and you want to to remove um an attribute and replace it or like create other ones it will create the new attributes but it will not remove the existing ones okay so also you need to know that and you need to be careful about this the last option is validate this means what means validate this it will do it will not do any changes but it will just validate the schema comparing to the Java representation or the entity representation so we have for example um user entity and we have a user table so the validate will check if we have the same table same table name same attributes same attribute names same types and so on so forth so it will just validate that what we have as code is the same as what we have within our database so for our configuration let's say create drop because this is um learning uh course so we don't need to purchase data forever so create drop should be fine for us so let's go with create drop and now we can also precise the database this like will help uh spring or will help also hibernate to know which database we are dealing with so it will just enforce the way that we will uh the way that we will uh update and manage our database okay so here we have also the option uh show SQL let's set it to true because we want to see um we want to see SQL queries okay so now this is the main configuration or this is the configuration that we need to do now uh we will need to go back to this URL and the difference between for example configuring my SQL and configuring postdegree SQL is just providing the URL the correct driver class name and here this option right here you can also change it to say it's my SQL okay so now going back to this URL so it's jdbc it's always like that jdbc do postre SQL colum SL slash and then you need to provide the local host or like um well whether it can be Local Host it's if it's locally or it can be an IP address or it can be a URL and so on so forth so now we need to provide the port which is 5432 and then the database name as a reminder the database name we created here we called it dataor jpa so here let's just provide it so now our application will be able to connect to this one so how to test it what we can do we can just go ahead and start the application and see if we are able to connect to the database now I will enable annotation processing because we have lbook within our application and as you can see here so the application already started in 2.9 seconds and without any issues so everything is up and because we don't have any tables so we don't have any any further uh information but if something is wrong we would see that we have exceptions in here and I will just show it to you so for example if I provide the wrong Port name uh number sorry not name so if we provide the wrong port number uh and we try to connect to the database we will see that we have a connection issue and it will say that enable to connect to this Local Host uh 5431 so connection refused and so on so forth so this just to ensure you that when you have the correct configuration you will have no issues when connecting or when starting the application okay so now our application is ready to use let's move on we will add now the properties to connect to my SQL database and to do that I highly recommmend that if you skipped the the first part to connect or to configure uh post degree SQL I would really recommend that you go back because we explained all these parts so it's really really important that you that you go back and check that uh now I would show you how to configure or how to connect to my SQL the first thing let's go ahead and duplicate this application. yam just copy and paste just command C command V also just as a reminder you every time I use a shortcut you can see the green uh popup uh down here so yeah you can always follow what I'm doing so now I will just say my SQL or just uh the new file I will call it application MySQL so this we can use it as a profile as a spring profile and I will show you how you can run the application whether for my SQL or my SQL or post degree SQL so uh how you can configure until J to run with a specific profile we will see it just in the end of this video okay just go ahead and click okay and let's start do the changes that we need okay let's put this in full screen or even I guess it's also like that is readable so uh the first thing we need to of course change change the username and password so for my SQL it's root root and we will see if it works or not let's go ahead and change the driver and now we want to use the my SQL driver okay and for the database we want also to use my my SQL or my SQL now we need to change or we need to update this URL and connect to the database so uh the good good thing is within my SQL you can ask him to create the database automatically if it doesn't exist or if the database does not exist so my SQL will create it sorry yeah so my SQL will create it automatically for you the URL is here instead of uh let's remove it let's write it from scratch so it's jdbc and here my SQL and then column SL slash now we need to provide uh the URL of the database so it's Local Host uh column 3306 this is the port that we want to use and then we want to use also the same database or the same database name here so just we just for to be uh convenient so I will call it also data jpa okay and also you remember that that we did not create manually the database because as I I mentioned uh my SQL has the the option or has the capability to automatically create a database if not exists so to do so just add interrogation Mark and add this uh parameter which called create database if not exists equals true and that's it so like that it automatically um my SQL will try to create or will create a database called Data jpa if not exists okay now to run the application using this configuration first before clicking on this play button right here to the to run the application just click on jpa application and you will see edit configurations here and here you see that we have active profiles so spring now if I precise it as my SQL spring what will do when starting the application he will try to find an application properties file or properties uh file have uh having the suffix my SQL as precised in the configuration in here okay so here we said that the active profile we want it to be my esql we can we by the way we can provide many active profiles uh uh as you can see here it's profiles not profile so we can U provide many but in our case we want to connect to application mySQL yl file so spring will automatically try to scan and read this file if exists okay I will click the run and let's see if the application is going to start correctly or not yes um all right so uh we see here here something that I didn't know uh so here we see that loading class this one but it's deprecated and the new driver is the one that we saw in the options okay so we will just update it later on now I want to go and check the schema let's refresh this one and here we see that we have now five schemas and we see our database data jpa so we don't have nothing yet but this one once we create the table the tables and the entities we will have all the tables in here so uh let's do the final update and let's replace this with a new driver using this package and that's it for this course we will implement the following database class diagram so uh this database class diagram is about uh elearning platform and what it's about exactly so it talks about um how we can for example if you go to uh alibu coding and check the courses that I have there so what you see this is what we have behind the scenes so we have courses sections lectures and for each lecture we have uh a resource and the course has an author and so on so forth so this is what we will see but first let me explain to you uh in depth this class diagram so uh we have a course so for example this one that you are following right now which is mastering uh spring data jpa uh step by step so we have a course and this course has an author okay but a course can be done by many authors right and the same author can create many courses so for example me I can create so many courses and one course can be created uh within a collaboration of multiple or many uh authors okay so that's why here we have this many to many relationship but uh here create an author having an author within our database doesn't mean uh that this author should already have a course within the database but if we have a course we should have at least one author assigned to that because when we want to create a course we need to assign it to at least one one author okay so that's why you see it this you see this symbol right here and you see this one right here means that the author is optional to have courses but a course is is mandatory to be assigned or to be done or to be created by an author then uh you know that a course has one or many sections okay so um here when we create a course we need to create at least one section but we can have multiple sections for for one course and here just uh put few uh few attribute attributes just simple ones uh like title description uh name and order for the section and so on so forth um okay so uh as I mentioned a course has one or many sections but one section if we take one section it belongs to one uh one course and within the course we can have many sections that belong to that to that course okay all right next one when we talk about sections we have uh many lectures okay we have so many one or many lectures and one lecture one lecture if we take one lecture it belongs to one section so this means that we cannot have one lecture that belongs or can figure out with in different sections okay so if we take the section A that has uh lecture one and lecture two so this lecture one it belongs only to this section A it can we cannot find it as part of uh section c or section D for example okay now after that a lecture um has a type or has a resource okay so a lecture has one resource and this resource belongs only to this one lecture so that's why here we have this onetoone relationship between the lecture and the resource and for the resource we have of course the ID name size and URL and the resource can be of different types so I just created a simple uh simple types here for example video file or text so this represents a resource okay so here what we have we have um inheritance between this resource class or resource table and this video file and text objects okay so for the video we have the length for example for example how many minutes um this video for the file we have the type for example whether if it's uh PDF MP3 and so on so forth and we have the te for the text we have the content and all of them all these three types or three uh types of resources they are already uh resource and they can be assigned to lecture okay so this is our class diagram and this is what we will Implement during this course so we will go uh through all this one by one and each time or every time we need to explain something we will go ahead and create and see how we do that and also we will see how to create advanced search queries how to work with transactions and so on so forth so you already saw the plan of the of the course and this is what we will be implementing before we go further let's first understand and explain the difference between hibernate and spring data jpa so first spring data jpa is just an abstraction layer on top of jpa to reduce the amount of boilerplate code required to implement data access objects or what we call Da or D Dao but jpa what is jpa jpa is just a specification that facilitates object relation mapping to manage relational data in Java applications this means what we can consider jpa as uh a Java inter pH where we have or where we Define the methods that we want to be that we want them to be implemented by any class that wants to use or implement this interface and why is that because we have so many implementations like for example we have hibernate we have Eclipse link we have ibus and so on so forth that all of them they should implement the jpa specification and the reason behind that is we want to make uh coders or developers life much much easier so for example if you want to move from hibernate to Eclipse link all you need to do is to do a minimum configuration or minimal changes like uh CH changing the the dependency or maybe or maybe some basic configurations but for example if you have a save method it's the same it's exact the same method for hibernate uh and Eclipse link for example this this is what jpa exactly as as I mentioned jpa is just the specification okay now if we go to the hibernate level so hibernate is a jpa implementation and also hibernate generates uh SQL query and executes us using jdbc so hibernate is the omm the object relational mapping that will use jdbc to handle all the database side mean like saving uh reading deleting and so on so forth okay so this is the main difference between hibernate and spring data jpa so let me also re explain this part so instead of doing all the implementation and defining the S the session management and so the transaction management also and so on so forth that uh hibernate provides so spring data jpa will do all this job for us because as you know when using the spring data jpa starter it will autoconfigure almost everything for us so yeah this is the power of the spring data jpa let's see see first how we can transform a table or database table to a Java class and to be able to manipulate it uh within our application so let me explain this diagram right here so we have this author. Java that we will take as a first example and we want to process this object into our database and we want it to be stored directly into the author table okay so uh we have our author. Java that contains a set of attributes uh ID first name last name email and age and then what we will see next is which annotations that we need to use in order to make uh spring data jpa understand that this is a table or this is an entity and needs to be persisted and so and so forth okay so uh let's go to our anti J now let's create within our base package com. alibu coding. jpa let's create a new class or um yeah let's create a new class A Java class in here but if you want for example if you don't have the right package uh ready to use just uh when you want to create the class you can precise the package uh the package name for example if if you want to call to call them models or if you want to call them entity or entities it's up to you so you just um call uh give the the package name for example let's say models in here and then you can precise the class the class name so for us it we want to create the author Java class and we want it to be within the models package so when you hit enter so this is what we see in here and we have author created under the package models okay so now as we mentioned before let's just create our attributes so here just a reminder we want to create ID of type integer first name last name and email of type string and we have an age of type int here I have a private entity ID and they have a string first name and they have also a last name private string email and finally I have a private int H so this is my Java class now what we need to do or like normally or usually what needs to be done when you create uh a Java class or when you create especially when we talk about entities and so on so forth so always think about generating Getters and Setters so make all the fields private and generate Getters and Setters so to do so there is a shortcut uh in here like as you can see like you can generate uh using this shortcut and here we have getter and Setter here you can select all the fields that you want to generate Getters and Setters for and then just click okay and you will see that we have all these methods ready to use but if you remember we I will just roll back this so if you remember we already added lombok to our uh project or to our pom.xml so let's use lbook for that okay so the Lum book annotations we have many annotations many useful annotations we have the getter annotation and as you can see it's always from the package lbook so this will generate uh Getters for this class and also we want Setters so this will generate this annotation will will help us generate Setters or Setter methods for all the attributes in this class if you want also for example a no arcs Constructor means a Constructor with no parameters you have the no arcs Constructor annotation also if you need uh all Arc Constructor you can also add it using this annotation also all arcs Constructor but we have another annotation it's called Data always from uh from lombok and if we go and read the documentation always try to download uh sources to be more readable for you and to get all the information that you need so here this data annotation it generates Getters for all Fields uh useful to string method hash code uh hash code and equals implementation and so on so forth so this dat annotation it's the equivalent to getter Setter required AR Constructor to string and equals and hash code annotation so always to reduce the amount of boiler plate code we can remove this and we can remove this too so we can just work with two annotations data and no arcs Constructor and also if you need other annotations is also easy to use so we have now our uh our class or our Java object ready to use let's move on and try to make this an entity or to make it a table now let's try to answer one question is having a Java class containing all the attributes that we need for our table is it enough to tell spring that this is an entity so spring or spring data jpa how he will know that this is an entity and needs to be managed so the answer first of all the answer this is not enough having just a Java class is not enough and we need to tell spring that this is an entity so we need to provide and some annotations or some some information in order for spring to be able to scan and pick up this object so I already told you the answer so we need to give an annotation and this annotation is entity okay so this entity just let me show it to you first so now we are using spring boot 3.0 and as you know one of the uh breaking changes or like the biggest changes is using Jakarta E9 and when we use Jakarta e so we the package is no longer Java x.p persistence so all the Java X not all of them 100% but all the Java X packages that uh belongs to the Jakarta e now they they have been renamed to Jakarta okay and from now on we need to use Jakarta do persistence for all these annotations okay uh all right so here uh using this annotation and when we run the application automatically hibernate spring and spring data jpa like all of them are working together so they will be able to pick and tell this is an entity so we we need to use it okay and I want to show you also the documentation and it says that this specifies that the class is an entity so it specifies that the class that has this annotation is an entity okay and also this is so important this annotation is applied to the entity class so here it's um it's a type type level or type targets so like this we covered this part this entity part and we have here the same package as we already saw together so now spring will be able to know or to recognize this author. Java class as an entity let's move on and see what we need to provide as minimum information in order to have this entity created in our database after annotating this Java class this author Java class with the entity so this means that spring data jpa will recognize this class as an entity and it will create the table for example based on the configuration we specified in the ddl auto when we first configured the application so it will automatically create this table otherwise it will consider it as a table all right but here we see that we still have an issue even by having this entity annotation we still see that we have some error right here and let's go ahead and check it together so here it says that the persistent entity author so we see that now our class is a persistent entity should have a primary key so you may ask the question I already have a key field right here but yes this is a key for us we are human being and we understand and we can read that this field is ID and even Our intention is to have it as an ID for our entity but spring data jpa doesn't understand this spring dat data jpa is just a program it's just uh zero and one is a binary so it understands only annotations okay so to make this field an ID or any other field an ID we need to add an annotation and this annotation is as the name says so it's The annotation ID and here while we are using the spring 3.0 always make sure that you are using The annotation from the correct package okay so the package is always Jakarta dop persistence all right I will insert this one and we see that the error now is gone but first let me explain to you what is this idea so in Spring data jpa the ID annotation is used to Mark a field as the primary key of an entity it is used to specify the identifier property of an entity which is used to unique identify an instance of the entity in the database okay so when the entity is persisted to the database the value of this field will be used as a primary key of the corresponding database table so this means the value of this integer ID is unique within our table and also it might be unique within our database depends on the generation type or the strategy that we will use to generate this ID all right so here I want also to answer one small question you might ask so why we are using integer here instead of instead of int okay so the answer is as follow so the int value by default is zero but the integer value by default is null and this is super important because spring data jpa and when we talk and we talk mainly here about hibernate because we are using the hibernate implementation so uh hibernate each time when we try to save or to persist a new row or new line into our table hibernate will check the value of this ID or the field annotated with the ID if the value is null hibernate will understand that we want to create or to persist a new element into into the database otherwise if the value is different from null or is not null he will try to fetch the element within the table that has this value okay so if we use the int if we use the Primitive type so the default value will be zero so hibernate will try to find an element or a row with a value zero and it will never find it okay so that's why it's always recommended to use wrappers over primitive types okay so um I hope this is clear if you have any questions just go ahead reach out to me otherwise let's move on we already explained that this ID is the unique identifier of of our table and we mentioned that we want to use or we need to use the wrapper classes or the classes like objects in here because the integer is the wrapper class of the Primitive type in because when hibernate sees that uh this ID has a null value it will automatically uh generate a new ID and insert a new line into our table but how hibernate will generate this ID so here we talk about gener generation types or generated values for our IDs and here let's explain or let's see which annotation or which mechanism can help us generate this ID all right so the answer is easy and here we have an annotation called generated value and just a reminder always from Jakarta persistence and once we mention or once we annotate a field with this generated value here let's check the documentation what is written in here so it it says that it provides for the specification of generation strategies of for the values of primary keys so here this is a keyword means that we work with primary keys so this generated value works with primary keys so the generated value annotation may be applied to a primary key property or field of an entity or mapet super class in conjunction with ID annotation so this property of this annotation might work with primary key uh property of a field or an entity or mapped super class we will see all these uh terms together and always in conjunction with ID annotation the use of the generated value annotation is only required to be supported for simple primary keys so we cannot use this generated value with complex uh Keys means complex Keys means we can have for example uh an ID composed of two Fields let's say for example an integer and a date so this we can create a composed key and and we will see that also uh somewhere like after in the in this course okay so uh use the generated use of the generated value annotation is not supported for derivate primary Keys okay so um here we have this annotation generated value and we know that it will generate uh it will generate an ID or autogenerate a value for us let's check what we have in here or what which properties we have within this annotation so we have a strategy which is of generation type and also we have a generator so this strategy is the primary key so it's optional but it's the primary key generation strategy that the persistence provider must use to generate the annotated entity primary key so here it we we can Define or we need to Define what which strategy we want to use so the persistence provider and the persistence provider here means the database provider or the database management system we are using must use to generate the annotated entity primary key so here we have a default value for this and we will check what are the types we have right here the second one it's also optional we don't need to specify this property and this is the name of the primary key generator to use and specifies the sequence sequence generator or the table generator annotation defaults to the ID generator supplied by persistence provider so here based on the on the generation type that we want to use we can also create our own generator so this means what let's go ahead first and check this generation types so for this generation types we will go and understand them one by one we have table sequence identity and we have this UI ID and this Auto okay all right so we will understand this in a few seconds and now I want to go back to this generated value annotation and talk about this generator so we saw that within this generation type we saw that we have one value called table and one value called sequence so this sequence generator and table generator they are responsible if we want to create manually our sequence generator or table generator so we will understand that in the SEC in the next lecture so now let's understand the different types of this generation strategies so as we mentioned the default value of this generated value the strategy default value of it is the auto and we also have the sequence table and identity so first let's understand what this strategy equals Auto means so this means that hibern will try to connect to the database or to the persistence provider and try to determine which is the best strategy to use so to understand this more in practice so just a reminder here we see that you have within this this uh generated value annotation we have the default strategy is Auto and now in order to understand that all we need to do is to start our application so by default our application is connected to post degree SQL and we will see that within post degree SQL it will choose one strategy but when we choose uh MySQL or we start with the MySQL uh profile it will choose a different one okay so let's go ahead and start our application so our application has started and we let's check the log first and then we will check the database so here it's just a normal log and a classic one but we see here we have some hibernate logs so now what we have we have create sequence author sequence start with one increment by 50 okay and then we create a table author with the following uh attributes integer ID not null and so and so forth and we have here or we are defining here a primary key ID okay so this is good let me reduce this and here within this uh data jpa or our database let's refresh it and here if you see Zero of three you need to select the public schema okay now let's open this one within the public we see that we have one table which is our author table right here with the fields or the columns that we defined which is uh ID age email first name and last name and also we see that we have one sequence which is the author sequence so by default hibernate determined that the best strategy to generate IDs for this uh database for the Post degree SQL database is US using sequence so it created a sequence and it named it author sequence by default like it takes the concatenation of of the table name within a suffix _ sequence and then it using it will use this sequence to generate values so if we have multiple tables or like more than one entity the sequence name will be hibernate sequence okay but for now we have on one single table so it will take the table name with this sequence suffix all right now let's restart our application but using the MySQL profile and let's see what will happen within this MySQL okay so let's do it and in order to profile uh in order to define the different profile so all we need to do here with an entity J you see this uh little card right here just click on it and then open edit configurations select your application right here so you might have multiple ones but select the one jpa application it's the our application name and here specify the profile name and the profile name how you can find it let me close this one first and you open here and you see for um here for our application it it's called application MySQL so this MySQL is the profile name so now let's go ahead edit the configuration and in the active profiles right here I will just provide my SQL so like that when we start up the application spring we'll pick up this configuration file so now the application is running and we see that uh we have drop table if exist drop table if exist and here what do we have here we are creating first create table author with the with the attributes or the IDS that we precised and we see here instead of creating a sequence we have have create table author sequence so it contains a next value attribute of type big in okay so here MySQL and hibernate determined that the best strategy for my SQL is uh using table okay using strategy table and this might not be the best strategy but maybe MySQL or any other database management system does not support one or another strategy for example my SQL does not support sequences so it will fall back to the second option maybe I don't know the exact order but I'm just trying to explain it like that so it will fall to the next strategy which is author uh which is table strategy okay so let's check our tables right now click here refresh and now we see that we have two tables the one is our author with the five columns that we already precised and the author sequence is only one column which is the next value so if I open this table you see that for now it contains only one line and the value is one and if I insert any data it will automatically increase it by one and use it for the next value all right so this is the auto strategy and now let's move on and talk about the next one so here we saw together how hibernate is able to detect which strategy is the best for our persistence provider now let's talk a bit more into in details about this sequence generation okay so by default hibernate will create a sequence if possible of course but let's assume that we are using postre SQL and the best strategy is sequence so hibernate will automatically create a sequence but what if we don't have the right to create sequences what if we have a database admin that creates everything for us so we need or we need to specify which sequence we have already or like we need to point hibernate to that sequence and the name might be different one might be a different sequence so we need to point hibernate to that so this is one use case the Second Use case I want to create my own the sequence and I want also to autogenerate or to Auto configure manually the allocation size so we saw in the previous uh lecture that hibernate will use the value 50 as an incrementation or as a step value so we want for example to be one all right so let's see how we can do this so now in order to do that first of all we need to specify the strategy right here and the strategy if you hit control space we see the the options that we have and let's choose sequence okay now I just want to remind you that within this generated value annotation we have the strategy and the generator and the generator here it's the name of the primary key generator all right so let's give it right here I would just put it into new lines and here I will precise the generator and my generator is a string like we should we need to give it uh a string name and I will call it author generator or sequence author sequence okay I would call it author sequence or SE like let's call it sequence to to see the difference between the one we generated before or that was automatically generated I'm talking about this one so our name would be author sequence all right okay so now we have author sequence but when we start the application hibernate will will not find this author sequence so it will claim or it will raise an exception telling that we don't find this exception all right so what we need to do is we need to create or to manually create this sequence okay and to do that it's really easy peasy we have an annotation called sequence generator and this annotation sequence generator it takes a name as a parameter so this is uh the name and the name should be the same like as this one all right so I'm just going to copy paste it to avoid uh typos and let me align it so after providing the name we need also to specify the sequence name the sequence name is the sequence that all also we want to use as a name all right so sequence Name by default it's empty but let's also use this author sequence as a name next we talked about uh allocation size means the step of increasing or incrementing this sequence and it's called allocation size and as you can see here the default value of this one is 50 and this is what we saw before in the that's this is where this allocation size or 50 is coming from all right so for us we want an allocation size of one and now that's it we have our sequence generator and we have our generated value for this ID let's go ahead start the application and see what will happen so here we see that we have this log right here uh create sequence author sequence so now it's called author sequence start with one increment by one so it starts from the position number one and it's incremented by one and this start by one so it's from the initial value so you can also change it if you want to start your sequence from specific value all right next we are creating the table and now let's go and check the database and make sure that we have everything in order so I will just refresh this one and we see that we have our table and now our sequence is called author sequence so in case you want to create a uh specific sequence or um yeah a specific sequence for each entity this is the way how to do it all right so now this is how sequences works and then you don't need to do anything hibernate will automatically use this author sequence to generate the ID all right so that's it if you have any questions just reach out to me on contact alibu coding.com or you know all my contacts on social media otherwise let's move on now what if we want to choose different strategy of generation what if we want to use table instead of sequence and we want to create our SE or table generator instead of sequence generator so let me show you how to do that first of all I will just comment out this sequence generator I will let it I will leave it here in the code so you can use it then we need to change this generation type from sequence to table and I will call or rename this generation or generator instead of author sequence I will call it uh author ID generation generator okay so ID gen I would call it like that okay now uh instead of using this sequence generator we have a similar annotation which is table generator okay this table generator it takes a name as parameter so the name I don't need to mention it again but it should be the same name as in here after precising the name I want to precise Also the table right so the table right here let's call it ID generator for example all right next we need to precise the primary colum name comma here PK colon name and this is going to hold the column name of our primary key let's call it um ID name for example just to make it uh easy for you I will call it ID name and the value and the value colum name is the value for this colum so I will call it ID value just to be consistent with that and make it easy for you and of course we can Define the allocation size as you can see here it's always default 50 and I want to make it one all right so I will keep the same profile the the postre SQL profile so we can see the difference or we can see what will happen when I restart the application so I'm going to stop it right now and restart it so here let's first check what we have as information so we have here create table author so this is our main table and then we are creating a table called IG ID generator and the ID name is type of V chart 255 255 and ID value and so and so forth so here what we are doing and insert into ID generator and we are inserting the first value which is the author and the and the value is zero all right so let's check what we have in here I'm going to refresh this one let me so here we no longer see this sequence generator right here we no longer have the sequence but instead we have this generator table and this generator table it contains only uh already one line which is the author which is our entity name and the ID value is zero so when we use this table generator the one that we created manually it will create one line for each entity and it will initialize the ID value for it so if we want to insert another entity it will come here query it by the name and as you can see the name is is an ID so it should be unique and it will increment the the value for that one so this is how we can also use tables as uh generators but here before we finish this part I want just to bring everything as it was before so I will also comment this out just to leave it in the code like that and also I will change or just remove this okay so I will just leave it as generation type Auto and like that I don't need to care about uh which strategy to use all right so that's it if you have any questions don't forget to reach out to me otherwise let's go ahead and continue in the background I restarted the application so we have the previous state so now we have our table and we are using the sequence as a generator so what we what I want to show you in this part is as you can see here we have this ID age email first name last name and so on and so forth but the question is what if I want to have more control over these columns okay so for example this first name I want to have a different name and I want to have a different name for this last name I want something which is different from the field that I have right here so this is the first thing the second I want to have uh you unique or I want to make sure that my email is unique so uh this will prevent me from having duplications uh when we talk about email because we know that an email is unique per per user all right so to do so we have an annotation that can help us um Reach This goal so let me make this one full screen and first of all let's talk about this annotation so The annotation is colon and first let's check what this column is what this annotation so it specifies the mapped column of a persistence property or field if no colon this is so important if no colon annotation is specified the value of the default value apply so default value means what means the default values of this annotation of this column annotation and let's quickly check the attributes that we have right here here so as you can see all of them are optional here so the first one we have this name so this is the name of the column otherwise it will take the property or the field name so if we don't precise anything in here so the default name will be first name and here as you can see that uh when we write it in camel case it will be transformed automatically into snake case all right now let's go back to this colon annotation we have a unique attribute so this specifies whether the colon is unique or not uh also if it's nullable if we accept null values by default it's true but if we accept null values or not and here we have this insertable uh property so this means what this means that if we accept the that we can insert new value for this colum you may ask the question why I should prevent inserting and the answer is when we talk about for example dates and we have an update date or the last modified date of this column so here we want we don't want it to be insertable but we want it to be only updatable okay so here we have insertable true updatable true and the same the same for this updatable property so for creation date or like the the date of creation of a new line or when we insert a new row into a table we want to track the creation date so the creation date should be only insertable and we need to insert it only when we when we create a new line but when we update the same line we don't want to update it so this field should not be updatable okay and here we have a table we have length and also length for example for Strings we can specify or we can say for example that um username or a login name or uh AO name uh should be only maximum or have the length of eight uh eight characters maximum okay and when it comes also to uh numeric numbers or decimals we can talk also about precisions and scale so okay now we we talked enough let's go and see this in action all right so the for the first name I want to have uh my name or the name of this field to be like that for example F name all right and why we have or why we we need to change this so like um for projects from scratch it's it's okay because we will Define everything but imagine you want to work on on a project where the database already exists and for example let's take the financial um domain and the database already exists but believe me you don't want to know how they call the fields or the columns so it's totally totally different because they are using really technical names uh Financial technical names so we want to have a more understandable for our Java application we need to have a more understandable names so we need to stick to the same names to the datab base but we want to have our own all right so when we manipulate objects within our uh Java Java project we want to use first name instead of this F name or it can be F1 2 3 4 so we don't want to name our field F1 2 3 4 we want to name it first name and then we can reference it or we can give it a name that will be used within our database okay so this is the first one now I will move on to this email so for the email for example it's okay it's fine for me to keep the name as it is but for this email I want for example to I want it to be unique so as you can see and also as I showed you before this unique attribute has a default value false so by default the field or the colum is not unique but let's make it unique so when we use this property this means that the email will become unique so we can cannot insert a duplicate values for this email all right also I can make it non nullable because also nullable by default is false but I want to specify or like make the user uh pass a value for this email so the email I want I don't want to see any emails into my database with null values okay also if you want to I I know this is um this is not okay but let's go back and do it in here I was going to talk about the length if I want to have a specific length so the default is 255 and let's say for example I want to have uh 35 as max length for this first name so this is the property to use all right so here if we talk for example as we mentioned before I will create a local date time field right here uh created at so this is the creation date and I will give it also the colon annotation all right and for this colon annotation I want this to be not updatable all right so as you can see it's by default true but I don't want this field or this colum to be updated so I want it only to be insertable so I don't need to specify the insert because by default it's true but I don't want this one to be updatable and this one cannot be null all right so this also nullable false now I will create another column and I will call it last updated at or last updated or last modified let's call it like that so for this last modified I will also use the colum annotation and within this colum annotation I want this one to not to be insertable so I don't want to insert this last modified when I first created when I first create a new line or when I first insert a new line I want this last modify to be null so because if I insert it it might be confusing because for example I want to query all the data where the all the data that were not modified okay so I don't want to insert it all right uh I want it also to be updatable and it will be nullable so I just keep the default value because nullable is by default true so using this column annotation we can have more control over our columns within the within our entity and on the database level so we can precise the name we can precise the length we can also um check the Unicity and the nullability of of our field also we can decide if it's updatable or not and if it's insertable or or not so this annotation gives us more more and more control over our uh our columns okay so I'm going to restart the application and let's see the impact of these uh of these annotations right here so let's see what what was the impact of this so um here so it's here it's just updating the constraint so here we see that first of all we are we are adding a con new constraint to our email with this unique so now it's Unique and here for example for the age uh it's an integer not null and we have this created at it's not null the Emil mail is also this the same and we see that the first name is now called f name and and is no longer called first name all right so we see also that the last modified is a timestamp but we don't have any control over it like uh not null and so and so forth same for the last name and here we are defining the primary key as our ID colum let's see the changes directly visually I will refresh this and now we have our seven columns so we see here that we have this ID the age created at email and we see this small circle right here so this means that these objects are not null or so they should not be null okay also we see that we have two keys so we have the author primary key and we have a second one which is referencing the email because we don't want this email to be null and we want it to be unique so here you see this UK is unique stands for Unique key PK stands for primary key all right so I hope this was clear for you otherwise drop me a message and let's move on now let's take the following example what if we want our table to be named author and _ TBL as a table name in the database and we have our Java class called author so in this case how we can map or how we can tell this entity or the Java class or we mainly talking about spring data jpa and hibernate how we can tell hibernate to name this entity and give it the name author underscore TBL in the database so the answer is in here we see this annotation this the table annotation is the one that can help us do this so let's see the power of this annotation so let's go back to the code right here and now I will use this table annotation right here so first of all let's check what are the properties of of this annotation so first of all uh it says that it specifies the primary table of of uh for the annotated entity additional tables may be specified using secondary table and secondary tables so here if no table annotation is specified for an entity class so the default values apply so if we don't use this annotation we will apply this default Valu so the name will be empty catalog and so on so forth so let's now discover quickly these these fields or these properties so name this is the name of the table so we already have the answer how we can change or how we can give a specific table name here we can also specify a catalog and the same for the schema so for example if my table is located in a different schema so I can provide it in here so I can give this information so for example if I have a schema 1 schema 2 and schema 3 within the same uh within the same database so uh I can spe specify or I can precise which schema for each entity or each table also if I have unique constraints like the one we did before we want uh for example our email to be unique we want we want to add a new indexes and so and so forth so we can add a list or a table of unique constraints okay the same for indexes all right let's go back here so for our case we only want want or we only need to give uh to give a name to our table because the we have only one schema so if you have a different one you can give also the schema name so here I will call it author TBL and I will restart the application and let's see the changes so click on restart right here and let's check again what we have so we have this sequence this AU auth tlore sequence and we have our table now is called author TBL okay so just for record uh databases are not case sensitive just in case you don't know this information so that's why we see here that the table is written is lower case and here it's already in uppercase so we see we see now that the table or the table name has changed and now it's called author TBL all right so yeah that's it I will just clean up the code make comment out this annotation and I will leave the rest for you so thank you so much um drop me a message if you have any questions otherwise let's move on so far we learned how to manipulate date tables how to create entities which are the annotations that we need to use which properties of these annotations we can use like for example when we talk about uh generated values how and the strategies how they work how we can also customize them and create our own uh and private sequence and table uh table generator and so and so forth but now we didn't reach yet the point where we need to discuss or where we need to manipulate and interact directly with a database interact means for example crude operations like read uh create read update and delete and this we will see right here for example we have as always our author table in the database so this author table has its own representation in our Java code as an author. Java and we need to persist this object to this database so the link between the author and the database right here because the DAT a table already belongs to a database but when we talk about Java program and programs and also when we talk about spring boot framework we talk about uh entities all right so um what we need to do to in order to better interact with this database so here comes the power of spring data jpa so spring data jpa uh made it so easy for us because he proposed something really really nice which is a repository and and the repository is an abstraction to reduce the amount of boiler plate code needed to implement the Dow layer or the data access object to interact with the data stores okay so let's go a bit deeper within this definition so in Spring data jpa a repository is a Java interface that is used to abstract the data access layer from the business logic it is used to perform crude oper ations crude just a reminder stands for create read update and delete as well as other common database operations such as pagination and sorting repositories are typically defined as interfaces and uh that extend one of the spring data jpa repository interfaces such as uh jpa repositories crude repository paging and sorting repository so these are the three main uh repositories or jpa repositories that we can extend like we create an interface and extend this interface to to have our own repository okay so because these interfaces provide a number of predefined methods that can be used to perform common database operations such as uh saving deleting entities finding entities by their primary Keys finding entities based on various criteria and this is what we will see in details later on okay but first let's understand and see this hierarchy of repositories so far we learned how to create a Java class out of a database table and this Java class is the representation of the table in our database now we have another question is what can we do do or how can we do when it comes to database manipulation and interacting with the database means if I want to persist a new object into or a new row into this author table so how can I do this so the answer is using jpa repositories all right so but first let's understand and give a quick definition of this repository so a repository is an abstraction to reduce use the amount of boilerplate code needed to implement the Dow layer or the data access object to interact with the data stores in theep in Spring data jpa a repository is a Java interface that is used to abstract the data access layer from the business logic it is used to perform crude operations such as create read update and delete so this is what crude stands for uh like and then as well as other common database operations such as paging and sorting so repositories are typically defined as interfaces that extend one of the spring data jpa repository interfaces such as crude repository paging and sorting repository or jpa repository so this has been a bit changed since uh spring 3.0 and I will show you the difference right now so these interfaces provide a number of predefined methods that can used to perform common database operations such as saving and deleting entities finding entities by their primary Keys finding entities based on various criteria and so and so forth and we will see in deep how we can create data or can create queries using the spring data jpa repositories so but first let's understand or see the hierarchy of the spring data jpa repositories so as we can see here that's why I told you before that it was slightly uh changed about when we talk about paging and sorting repositories because now the new architecture looks like that so we start as we mentioned by creating an interface so for our for our example we want to create an author repository and then we need to extend one of these five repositories that we see right here all right but let's start start and see the uh inheritance from the lower level from the lowest level to the from the highest level to the lowest one actually it's the the other way around so we first can start by EX standing jpa repository right here and this jpa interface uh repository it also extends two other interfaces at the same time so it extends the list paging and sorting repository and list crude repository so this list crude and list paging so both of them they contain methods like that's that this is where comes the difference because there have been a small refactoring in this interfaces so now we have all the methods that returns list they are within this list paging and sorting repository so this in order also to to reduce more the the boilerplate code because for example if I want only to perform crude operations with I don't need list so I can only extend this crude repository same for paging and sorting but if I want everything all I need to do is extending this jpa repository so let's continue so here we see or we said that uh the jpa repository extends at the same time list crude repository and list paging and sorting repository and the list crude repository already extends crude repository and this crude repository also extends the basic uh interface which called repository the same way when we when we take the left hand side uh part so when we talk about jpa extending list paging and sorting repository this interface itself it also extends the paging and sorting repository so now let's go ahead and see the code or the Implement well not the implementation but the interface which was created by Spring data jpa so go back to your inj hit command shift o or control shift plus n for Windows and Linux users and just type jpa repository and you will see that we can open the Java class or the repository if you already downloaded the code and we can open it and it's the one spring data jpa the version 3.0.0 so if you are using a previous version of spring boot this might be slightly different okay but our course is fully focusing on Spring 3.0 because we want to see the new changes and we want to use also the most recent versions all right let's go back in here so we see that we have here our jpa repository interface which is extending at the same time list cud repository and list paging and sorting repository so this query by example executor so this is something else we will see uh later on so that's why I didn't mention it in the in in this uh in the diagram so let's go back and and focus on this so here we have this list crude repository if we open it we see that this list crude repository is already extending the crude repository and list crude repository contains all the listing methods so save all find all find all by ID and then when we open this crude repository we see that it also extends the repository interface and this screw repository contains uh these methods like the crude method save save all find find by ID and so and so forth all right and the same way if we want to go to list paging and sorting so here we have this find all within this list paging and sorting repository the same when we go to the paging and sorting repository interface we see that we have this find all find all and so and so forth and this one like we see when we talk because when we talk about p paging and sorting we mainly talk about lists so we have here the first parameter for the find all is sort and the second one it's a pageable and the pageable also contains the Sorting so we can when we if we want we want to use this one so it already covers this all right but make sure that the return type of this one is iterable and this one is page so this is just to mention and as we said both of them they extend the repository interface all right so if you have any questions don't hesitate to drop me a message otherwise let's move on and continue first of all we will create a repository for this author model or this author entity but first of all Don't Panic if you see that I removed the code and don't worry you will not be losing the code because here it's just a cleanup and you can find all the code when you go to git right here and then you click on the logs you will see that after each chapter I will commit or have a full commit right here so if you double click on this author you will see all that you all you need so here you have the entity you have all the annotations the strategies and so and so forth so you will see all the changes that we will do in each chapter so don't panic don't worry about about that so it's just for me to have a clean code for each step all right so now in order to create a repository it's so easy so here I will create a new package or I can create a class and a package at at the same time so here create a package called it repositories and then Dot and the class name or the repository name and don't forget to select interface because we mentioned that a repository is an interface that extends another interface one of the jpa repository interfaces so uh let's call it author repository hit enter so here we see that we have a public interface author repository and in order to transform or to tell spring that this is a jpa repository we need to extend one of the J one of the repositories okay the repository interfaces so for our case we will extend the jpa Repository so because within jpa repository we have all the methods and as we saw before this jpa repository it's a generic interface that takes two types the first one is T which is the class or the table and the second one is the ID and this is the unique ID or the type of our ID within our entity all right so if here it's integer so we will pass integer if you use string long uh big decimal and so on so forth just pass the type all right so let's finish this one so it's a repository or jpa repository of our object author so this will help uh spring data GPA to determine and correctly write the correct queries okay and of course we we want our ID which is of type integer okay so like this we have our first repository now let's go ahead and play a little bit with this repository and create or insert some data and see how we can use this repository now in order to test this repository right here we need to create a service and then create a controller expose the endpoint and use Postman or like Swagger UI to test this uh repository or test this methods and so and so forth so the process might be a bit long but let me show you a better way how to do it okay so we will use a command line Runner and the command line Runner is uh a bean or is a method that will be executed at the application startup okay so when we first start the application we will run this method and within this method we can inject any Bean which is available within our application context all right so to do so let me close all this go to the jpa application or your main application file the one where you have the spring boot application because this is the startup class and then just create a bean all right so add the bean annotation and here a public beans always should always be public don't forget that and the type is command line run R all right so this interface right here command line Runner give it a name command line Runner and within this command line Runner uh method or Bean you can pass any type you want right here okay so it's like that and now I want to inject my author repository right here okay so I will create an object of type author repository I will call it repository as a simple name so like this automatically this Bean or this auor repository will be injected okay so now to implement this let's use a Lambda expression so let's say return args or something like that and then Arrow function and that's it and inside this method we can implement or we can do whatever we want within this repository okay so let's go back check quickly our author method so here we have the data no arcs Constructor entity and so and so forth I will just add two annotations the first one is all arcs Constructor to have a Constructor with all the arguments and the other one is the Builder annotation so the Builder annotation it's for uh the design pattern Builder which help us create and building objects so I will show it to you right away so now to use this Builder uh annotation or this Builder design pattern I will create a VAR called it author so you can use VAR because we are uh using Java 19 so equals author do builder. build so you see because we have this author because we have this Builder annotation now we can use this build or Builder method so you see already in the icon right here this is the lombok icon and yeah so and then I will just type build all right so uh this Builder help us like we can use the field names as as methods so first name email and so on so forth to create or to instantiate an object all right so uh let's have first name I will call it alibu last name also alibu let me make this one full screen uh age okay I'm going to I'm going to give you my age I'm getting a bit old okay so email here you can find my email if you want to contact me so it's contact at alibu coding.com and that's it so these are the information that we need to create an author object now let's use our repository dot save all right so within the repository let's go ahead and have a quick look on the methods that we have right here so we have save count count delete equals uh delete all delete all by ID so all these methods they come from all the interfaces that we saw together so like we have a prebuilt methods that we can use without any need to create uh methods our own like or to type or create queries manually so we can use spring data jpa or the repositories to create a bunch of methods or many methods that uh can make our life so so easy so for now I want just to test the save method so I want to save this author object okay so at the application startup when I run the application this Bean will get executed and and it will insert a data or a line into the database okay so uh let's start the application and test this one all right so the application is running right now and let's first check the logs we see that we have a first log from hybernate which is Select next Val from author seek or like this is the sequence so hibernate will get the sequence or the next value from our author sequence and then we see that we have an insert into author age email and so on so forth and here we have the values so here it's like just uh interrogation mark because uh it will not print out the the execution but here it's logging already that you are inserting something into the database now let's open our database and check that we have our data so I will open this author table uh first Let me refresh because we renamed few staffs yeah now we have our author table go ahead open it and we can see right here that we have this ID we have the age email and so and so forth so here like the the object he got executed this Bean got executed and now we see that we have some data within uh our database so also this might be useful for you if you need to execute something at the application startup you can use this command line Runner so we will be using it uh in the future Maybe to uh to test few things all right so yeah that's it let's move on now and answer one small question at the application startup when we execute this block of code or when we execute any kind of this code in service or in controller or whatever so I mean when we create an object and we try to make a transaction to our database saving it deleting it reading and so and so forth so we call this a transaction but this is not the main um goal of this part but first of all we want to understand what is the life cycle of an entity okay and to understand this let's go ahead and open this diagram right here in order to understand what is a life cycle okay so in in hibernate an entity is an object that is persisted to a database table and the life cycle of an entity refers to the entity to the different states that it can be uring its existing from when it's first created until it's eventually removed from the database all right so let's go and check these four states of a hybern entity okay so the first one here we have the first state which is the the state transient and this is the state of an entity when it has just been instantiated and is not associated with h with a hibernate session an entity in this state is not persisted to be the database and is not managed by hibernate this means what means when we have or we create create a new instance of our author object or we use the Builder for that so we move from the object to a transient object right here so at this level our object is still transient it's not persisted and it's not yet managed by hibernate but once we execute one of the following methods save persist save or update or update so like this we will move from the transition state to the persistent state so the entity or this object will become a hibernate managed object all right all right let's talk about and explain this persistent state so this is the state of an entity When It's associated with a hibernate session and is being managed by hibernate an entity in this state is persisted to the database and any changes made to its properties will be persisted to the database when the transaction is committed so here when we do or when we operate any kind of this operations right here so the state will become persistent and any updates so if we made any if we make any updates to these auor object and we execute one of them so this change it will be affected or applied to the database one once the transaction is committed all right so now after this trans after this persistent State we can move whether to the removed state or to the detached one let's talk about the detached State first so to detach an entity the detach is this state of an entity is when it was previously associated with a hibernate session but is no longer associated with it it all right and an entity in this state is persisted to the database but is not being managed by hibernate any changes made to uh to its property will not be persisted to the database until the entity is reattached to a hibernate session so let's focus on this until the entity is reattached to a hibernate session session so this means what once we execute one of the following methods detach close clear or evict the state of the hibernate entity will pass from persistent to detached okay and here when the entity is detached we have two choices so the first one we can go back to the persistent state or we can just go to the garbage this object will just move to the garbage right here okay but let's first talk about this uh word that we said until the entity is reattached to the hibernate session to reattach the entity to the hibernate session we can use one of the following methods save save or update merge merge or lock so this means what means within one method we can save we can create the object so it moves to the trangent save it so it goes to persistent and after the persistence or after saving the entity we can do some logic and then we call the session the hyet session. detach so it will move to the detached State once it's detached we can also change some properties for example and then we can call back this one of these methods save save or update and so and so forth so it will go back to this persistent state if if not or if we don't execute one of these methods so the entity will just go to the garbage so it will no longer become hibernate managed entity okay so now let's go back to this persistent state so from this persistent State we we can move to this removed State all right so to move from persistent to removed we need to execute a method or a delete Method All right so the removed is the state of an entity when it has been deleted from a database an entity is in the state in this state so in the in the state removed is no longer persisted to the database and is not being managed to by hibernate so once we delete an entity so it passes to the state removed and then automatically to the garbage okay and here let's talk about a little bit and explain this state or moving the object to the garbage as you can see right here if we create an object if so it's in the transient state so from the transient state it will move to the garbage if we do not execute any of these methods okay once we persist an object and then we try to detach it so and then we we do nothing it will also go to the garbage okay again from this persistent State once we perform a delete uh operation it will go to removed state so it will the state will become removed and then it will move to the garbage again now we can go here from this state from this author directly to this persistent state so this means what this means when we try to perform a get operation find all find by ID and so on so forth so we will directly go to this persistent state so because here we we don't need to instantiate any kind of uh data but we just want to call our session management or persistent uh persistence entity or entity manager to get or to fetch data directly from the database so we move from this initial State directly to a persistent State and then we can move to these different other states so we can perform a detach save delete or remove all right so this is the hibernate entity life cycle but here something uh something really important to know about so we with using spring data jpa we no longer need to care about all this life cycle because it's automatically managed first of all second so this save persist detou and so and so forth is being handled in the background so we don't need to automatically uh commit the transaction or detach The Entity and so on and so forth because spring data jpa will do the job for us so now we know and and we understood what is the life cycle of our entities let's move on and explore other important things if you have any questions as always do not hesitate to drop me a message otherwise let's move on previously we've been playing around this author entity now what about if we talk about this whole class diagram and how we can realize it okay but before that we see that we have relationships between the different entities we have the many to many one to many and so and so forth but first of all what is relationship and why we need relationships in in a database relationships between entities can be used to represent the connections and dependencies between different pieces of data and there are several types of relationships that can be created between entities such as one to one one to many and many to many relationships creating relationships between entities allows you to model the real world relationships between different pieces of data more accurately which can help you better understand and analyze your data it can also help you to enforce data integrity and prevent inconsistencies by ensuring that changes to related entities are coordinated and consistent with each other in addition to modeling real world relationships creating relationships between entity can also improve the performance of your database by using relationships you can avoid storing redundant data in multiple tables and instead use foreign keys to reference related data in other tables this can help to reduce the size of your database and improve query performance overall creating relationships between entities uh is an important part of Designing a well structured and efficient database it can help you to model real world relationships more accurately enforce data integrity and improve the performance of your database so when you work with SQL databases always think about adding relationships this is important to improve everything and ensure Integrity or your data inte Integrity now before moving on and start implementing uh this class diagram and um creating relationships between the different entities let's explain one small thing so here we have for example this course entity and this author we see that we have one relationship here it's many to many relationship because we said that an author can create uh multiple courses and one one course can be created by multiple authors so that's why we have the many to many relationship all right so here we have a questions this question is how can this relationship be done and the answer is here we are not talking about annotations we are not talking about anything but the focus or the main focus in here is the type of the relationship so here we can identify two types we have unidirectional relationship this means that one entity has a relationship with another entity but the other entity does not have a corresponding relationship within the first entity this means that the relationship is defined only on one side of the relationship this means what like when we talk a bit uh code right now this means when we create uh for example the course entity and we want to link this course entity as a many to many relationship within the author so we create an attribute or a list of authors uh within the course uh entity and give it The annotation many to many and that's it so this is what we call unidirectional relationship so it's from only one side now now what if we want to make it BD directional so in a b directional relationship both entities have a relationship with each other so this means that the relationship is defined on both sides of the relationship so first of all we created a list of authors right here and it's referencing the author now to make it B directional we need to create a list of courses in the author entity right now right here so like this we will ensure that we have a b directional relationship in general UD unidirectional relationships are simpler and easier to understand but they do not allow you to navigate uh the relationship in both directions means you can you can navigate from course to author but if you implement unique any directional relationship you cannot navigate from author to course so it only ensures one way uh oneway navigation but B directional relationships are more powerful and flexible but they can be a bit more complex and require more care to maintain the Integrity of the relationship that it also ensure a b directional navigation from both sides so from author we can access the courses and vice versa now let's move on and start creating all these classes let's create let's create and Implement everything we have right here let's start now by creating our entities so what we will do is we will create a Java class and give it the entity annotations for each of these classes that we have right here but we will not do any um any mappings any relationships we will just create Java class scores for example with an ID title description and so and so forth so this is what we will be doing right now and then we will move on and Implement and explain in details all these relationships and annotations that we can use so let's go back to our anj I will close all these tabs and within our models package I will right click and create a new class I will call it course so here like as we did with this author we can use the same annotations right here so we need the data no arcs Constructor or all arcs Constructor the Builder and especially the entity annotation because we need it to make the class or the course. Java class an entity but just I will copy paste them to make it uh much much faster all right so this this course right here let's go ahead and create few fields we have an ID we have a private string name and we have also a private string description and that's it so here we have our entity next let's add the ID annotation because we need it and we have also the generated value and just a reminder of always make sure you use the Jakarta persistence if we if you are using the spring 3.0 otherwise it's still Java x. persistence for the previous versions so generated value and we will leave the strategy to hibernate to decide which strategy is better for us next let's create the section entity so I will call this class section paste the same annotations we we used before and now we need to create a private integer ID and private string name the section name and also a private int order so we want to give an order for it for each section all right okay now as always we need this ID annotation and we need this generated value annotation right here okay so that's it within this section uh entity let's move on and create the next one let's now create the lecture entity so right click right here new class and call it lecture as always just paste the annotations that we will need and now let's create an integer ID attribute and then we need also the private string lecture name so that's it we have only an ID and a name within the lecture and now let's add the ID annotation and the generated value so this should be an easy task for you and let's move on and create the next one now we will create this resource entity but for the moment we will not create this uh inheritance video file and text but we will leave it for later when we will explain The Inheritance within hibernate all right but for now let's just stick to this resources entity and create the following attributes so go ahead right click on the models package create uh a new class and just call this one a resource always paste the annotations and we have here a private integer ID private string name resource name and private uh int size and we have finally private string URL so this represents the URL of the resource and do not forget the ID and the generated value annotation so that's it now we have all our entities created let's now move on and start implementing the relationships one by one now let's start establishing and creating relationships between our entities so let's start from here let's create the one many to many relationship between the author and the course and as we explained before an author can create multiple courses and one course can be created in collaboration of multiple authors that's why we have the many to many relationship in here here now let's go back to our entity J and as we mentioned before when we talk about many to many relationships or many relationships the first thing that we need to think about is creating lists okay so let's open our author entity and scroll down here and first of all create a private list the list is always from the Java util package and we want to create a list of course okay and let's call it courses so this is the first step Second Step go also to this courses uh entity and in here create a private list of authors okay uh author and let's call it authors all right so this is the first two steps next we are talking about many to many relationships so let's add many to many right here and many to many also on the course level so now we defined or we have our many to many relationships okay but now we need to define something we need to define the owner of this relationship so because we have the owner and the reverse relationship and in many many relationships in jpa one of the entities is considered the owner of the relationship and is responsible of maintaining the foreign key values in the joint table and the other entity is considered uh the inverse of the relationship and does not have any foreign keys in the join table all right so to do so once you decide which of them should be the owner of the relation ship just go to the other one that you want it to be the inverse relationship and give it uh the map it by attribute like give it the value all right so for our case we want the course to be the the owner of the relationship so the author is the inverse relationship right so within this inverse relationship add this Mapp it by and the mapet by should be or we should provide the name of the attribute we have right here so here it's called authors just go copy and paste it in here be careful about making typos all right so if you make some typos this means that you can also have exceptions at the application startup okay so now let's go back to the owner of this relationship so for for our case the owner is the the course and now to define the the the join table of this relationship we Define it from the owner side so here we will use this join table annotation and here this means or this has a goal uh of creating a new joining table between our author and courses okay so uh for this joint table let's provide some properties first of all is the name the name is will be or will hold the name of the joint table let's call it authors courses means the courses of authors are like you can call it whatever you want next we need to define the join column and here we can we can Define multiple join columns okay so the join columns right here here equals and now we need to pass a list of joint columns I will just make it a new line so it it will be more readable for you and now we will use The annotation join column okay it's always Jakarta package and for this join colum we will we need to provide the name and the name right here let's call it uh so this join colum is the one responsible or the one that will hold the information or the primary key of the owner of the relationship so this one will be the course ID okay next Once We Define the join columns we need to define the inverse join column so when we when we say inverse we are talking about the inverse entity so here inverse join columns right here equals and as the same way here we need also to use at join colum so join colum and let's give it a name and here let's call it author ID so like this or in this way we just defined a many to many relationship between our author and course and to check that let's just restart the application and see the impact in the database and also let's check the box so here we see all right so here we have uh we have one exception and you see right here it's caused because of this syntax error near order because in this lecture the sorry in this uh section the order is a reserved name okay so let's just rename it to section order right or position or something like that let's restart the application again and see what happens all right so let's first check the logs here we have everything is working fine and here we are creating the sequences for each entity you see that for each entity we have or we are creating a sequence and here we have the author we are creating the author and the course and also we are creating the author's courses the The Joint table that we created for this author and course entity we have also the lecture resources and so and so forth and here we are creating all the constraints all right so and also here we are inserting because we still have this Bean right here so if you want to stop it just comment this Bean out comment this out and it will no longer insert insert data so now let's go and check our database so here refresh it and now we should see at least the author author course and courses so here we have our colums so we see that we have this ID age email and so and so forth for from the author and we have from the course we have this three columns that we just defined ID description and title and now from the author courses we see that we have two columns and you see for the primary Keys it's a golden key but for foreign Keys it's blue key so now we see that we have this course ID which is referencing the course and the author ID which is referencing the author entity all right so this is how we can create many to many relationships let's move on and see see how we can Implement relationships between the other entities too if you have any questions don't hesitate to drop me a message otherwise let's move on at this level let's implement the relationship between the course and the section so a course has m zero or many sections so or one or many sections okay and one section if we take one section it belongs to only one course so here we have one course to many sections and we have many sections to one course so how we can also explain this so when we create a course we have the course but every time we create a new section we will have a foreign key course ID that will be Associated within this section class all right so let's see now how we can implement this so at this level we are talking about the course so and we said that one course has many sections so here when we say that we have one course and many sections so list of sections and let's call it sections okay so this is the first step because we have one too many so it's always the the current instance or the current object which is the course has many sections so we create a list of sections right here okay now let's go to the section you can do uh command click or control B for Windows and Linux to navigate to the definition of this so here we said that many sections can figure out or many sections belong to one course all right so here this means that we need to create a private course element right here or um a field of type course right here let's call it course okay now from now to implement the mapping so we go back to this course. Java where we have the list and it's easy like when we have the list always think about one too many so it's just as we explained it it's one core it's one course too many sections so one course too many sections all right and here when we use one too many we need to map it or to tell which mapping that we need to use so here map it by and this MPP it by it should be the exact same attribute name we have right here so just copy paste it and be careful always about typos so here we have this one to many now let's go and navigate to the section entity So within the section right here we said that many courses or many sections so we said that many sections they belong to one course so we have many to one and when we use many to one we need to specify the join column so when we create a course when we create a section right here what should be the joint column name all right so here we need to add or to use The annotation annotation join column and let's give it a name right here and the name let's call it course ID okay so now we just created a mapping or relationship between the course and the section so let's restart the application and see the changes so the application just started right here and we see that we have all these entities now let's go and check our database and now what I'm expecting is to see a foreign key called course ID within this section class so let's do it refresh the table right here and let's check this section So within the section we have four column this is good and we see that we have for one foreign key and this foreign key is this one so we see it's uh FK let me make it a bit bigger so we see that this uh FK stands for foreign key and this is the ID of this foreign key so the I the name or the key of this attribute is course ID and it references to the course okay so it references the course ID that we have within this course table okay let's also check again the columns right here so we see that we have an ID name name section and course ID so like this we are able to create or to make a relationship between two entities using one to many okay let's move on and implement the next and if you have any questions don't hesitate to drop me a message now let's implement this relationship between the section and the lecture and it's also one too many as we did for the course right here so this I think it's an easy task for you and let's go ahead and implement it quickly so from the section level right here we said that the section has a list or list of uh lectures or many lectures so let's go ahead create private list lectures okay and let's call it lectures and now let's move to the lecture and create or reference it within the object that we have so here we have private section section and now let's add the mapping okay so we say that we have one section one section to many lectures and this one is mapped by section okay so it should be just a reminder it should be always the same name that we have here now from the section level as we explained before it's one section to many uh it's one lecture to many sections and here many SE many lectures can belong or they belong to one section okay so here we have many to one and do not forget to add the join column and give it a name and let's call it section ID all right so that's it let's restart our application and check the diagram and check that we have all the foreign key correctly created and here if we go to this lecture I'm expecting to have this foreign key right here which is section ID referencing the section and also for the columns we have the ID name name and the section ID as a foreign key right here so that's it let's move on and implement the one one relationship between the lecture and the resource now when we talk about a lecture and a resource we talk about onetoone relationship because one lecture has only one resource and when we talk about one resource it belongs only to one lect so that's how or that's from where we got the one toone relationship okay just as a reminder this part we will see later on now let's go back to our code now in order to implement a one toone relationship so first of all Define your uh your entities and in here we have uh our section and also we have our resource so from the section level let's create a private resource let's call it resource okay so when we talk about onetoone relationships we can talk about one uh unidirectional or B directional mapping okay so we can link the lecture to the resource and that's it so we will have uh the owner of this relationship is the lecture and we can access the resource from the lect lecture but when we want to go back uh or access the lecture from the resource we will not be able to do that because we don't have B directional relationship so let's start with unidirectional relationship now in order to Define uh onetoone relationship as I mentioned create an object of the the other entity so in our case it's an object of type resource and here we need to use the one to one relationship okay so here we have the one to one we can also Define the join column name that we want to use and here let's say resource ID all right so this is how we can define a onetoone relationship and then let's restart the application and see the impact of this so now we see that the application started let's let's check the database now if we go to the lecture we see here that now we have two foreign Keys the first one is from the resource the one we just created and the second one is we the one we previously created from the section but here we need to focus or we want to focus on this resource ID from the resource okay also if we open this one we can see that we have a new uh column defined here which is the resource ID okay let's go now and implement the second way or like the B directional one to1 relationship so just to make it faster I would just copy these annotations go to the resource entity and as we did before let's create a private lecture and let's call it lecture right here okay and now let's paste this one to one annotation and join column and this one let's call it lecture ID so here this means when we want to create um when we want to create a new lecture and a new resource we need to link them together in order to have this B directional relationship okay so as we mentioned before like having B directional relationships make it a bit complex to maintain all the foreign Keys all right so let's go back restart the application and check the database so the application is starting right now let's open the database and see refresh it and let's see now from the resource we will see that we have one a new foreign key which is the lecture ID and it's referencing the lecture right right here so like this we just created a onetoone relationship between lecture and resources all right so that's it we just implemented all the relationships between all our entities and classes let's move on and I want to show you how you can check that what you created is the same as your class diagram now for the people having the the ultimate version of an and using this database to check the data and refresh the data and refresh the database and check the tables so there is one thing that we can do so here when you click on this database you can right click on it and here we have in the bottom you have diagrams okay and you can show a visualization or you can show it in a popup let's show show the first one and here it will generate all the tables of our database okay so you can also uh you can also click on this icon to apply the current layout and it will reorganize it and here we see that we have our author right here we have our author table let's just try to organize it a bit and we see right here within this diagram that we have the same one as we already did designed at the beginning of this of this course so we have the course and the author and here we have the the join table between these two one because we have a many to many we also have a relation between our course and section and the same between section and lecture and we see that we have this onetoone relationship between our lecture and resource all right so like this or this tool might help you checking if you have the correct implementation or if you did the correct implementation or not so just go ahead use it and you can also compare it with this diagram that we just created so just double checking we have author courses section lecture and resources and it's the same diagram that we have generated right here so this one it will use the database and all the relationships that we already defined to draw this schema so uh uh that's it about all the relationships now let's move on to a bit more deep and important uh stuff that we need to learn together if you have any questions don't hesitate to drop me a message send me an email or contact me on social media and also you can go and ask your question on Discord I will create a special channel for this course so just go ahead and ask it otherwise let's move on previously we said that we will leave this part right here where we have this resource video file and text entities to uh further part so now it's the time so here as we can see so this is the symbol of inheritance and we have this resource class we have also these three classes video file and text so this means what this means that a resource can be at the same time uh um can be whether a video file or a text so here we have video extends resource uh file also extends resource and same for the text so in Spring data jpa you can use inheritance to define a base class of your entities and then create a subass that inherit from the class or from the base class so this can be useful if you have a number of entities that have some common properties and you want to avoid uh duplication code or duplicating the code okay and when we talk about inheritance in Spring data jpa there are several ways to implement this inheritance so we have the single table strategy also we have the joint table strategy and table per class strategy so we will see all of these strategies in details but here we need to talk before we go and we before we leverage inheritance we need to talk about pros and cons for each one for for this inheritance so the pros or the advantages of uh inheritance is first of all code reuse so because inheritance allows you to reuse common code among multiple entities also simplified queries with inheritance you you can create queries that span multiple entities without having to write separate queries for each entity now let's talk about the cons or the disadvantages of inheritance so first of all is the complexity inheritance can make the database schema more complex especially if you are using a strategy like join table per class or table per concrete class also we can talk about rigidity because inheritance can make it more difficult to change the Bas class or other new sub classes because it can affect the entire inheritance hierarchy so this means every time you need to add a field or you need to add a new attribute within the Base Class you need to really be careful about the sub classes or the derivate classes that extends this Base Class so this is mainly the pros and cons of inheritance before we move on and start implementing The inher Inheritance strategies I want to highlight something which is really important which is composition over inheritance because both inheritance and composition H are ways to achieve code reuse and modularity in objectoriented program in in general it is recommended to favor composition over inheritance as composition is more flexible and easier to CH to change because inheritance evolves creating a sub class that is specialized version of a base class so the sub class inherits the properties and behaviors of the base class and can also have additional properties and behavior of its of its own this can be useful way to share code among multiple classes but it can also make the code more rigid and difficult to change if you need to make a change to the base class it can affect all the sub classes that inherit from it which can be difficult to manage composition evolves creating a class that has reference to one or more subjects and delegate tasks to these subjects this allows you to combine the functionality of multiple classes into a single class without the inheritance hierarchy of a base and subass composition is more flexible than inheritance because you can change the object that a class delegates without affecting the class itself so in summary it is generally recommended to use composition over inheritance because it is more flexible and easier to change however the best approach will depend on the specific needs of your application so this is the comparison between inheritance and composition and as I mentioned it's all it's always recommended or generally recommended to use compositions over inheritance okay now let's go and dive into these inheritance strategies in case you want or in case you need to use inheritance within your application so let me teach you how to use it in the correct way now imagine with me that that we want to add some auditing fields to our entities uh means I want to add some information to track uh the creation and the last modification of each entity or of each line uh of my tables in the database this means for for example this course entity or this course class I want to add four field uh like the created ad last modified ad and also created by and last Modified by same for author section lecture resource and all the tables that I will create within my database okay so in this case uh I will have four Fields including this ID we can five in each entity but this is okay from the database but now when we talk about the code our code I want to avoid this code application and I want to organize it much much better okay here we can use one technique to achieve this one and it's going to be something like that we will have a kind of Base entity or we can call it abstract entity or uh parent entity you can call it whatever you want and in here we will move or we will try to um to collect all the common fields between the entities we have or between the Java classes we have and for example we have this created at last modified at created by and last Modified by and I want all these fields to be part of all the entities I have within my database so for this it's super easy here we will use inheritance we will create a class we will call it base entity and all the classes I have right here they will extend this base entity okay and this base entity needs to be annotated with a special annotation and this annotation is called map super class so this annotation indicates that a class is a super class that is mapped to a database table and this annotation is used to define common properties uh that will be shared by multiple entities without creating a separate table for the super class this means the the only existing or existence of this base entity is within our code but from the database side we will not see any table called base entity so now let me show you how we can do this let's go back to our anj and here within this models uh package let's create this new class okay so let's create a class called it base entity or base class or base table call it whatever you want so this base entity first thing that I need to do is I need to give it a maid super class entity and as as you can see it's always from Jakarta persistence do mapet superclass so this means and this this will indicate that this class is a maid super class and any entity that will extend this one will inherit also all the fields that we have right here okay and for this I will create a private local daytime uh this one for example created ad I want to add a private so this one last modified ad and I want also to create two strings for example this this is this is just an example and you can create or you can move all the common fields that you want into this base entity so here I will will create a string created by so to track who created this entity I mean like the the user who created this entity and we have also last updated by or last Modified by okay all right so here within this maid user class we can use all the all the Jakarta all all the persistence um annotations like colon last Modified by last created by and so and so forth so it's a normal entity but it's just within our Java code base okay now also let's check right here for all the classes or for all the entities that we created right here we have this integer value uh this integer ID which represents the ID of our entity so also if you have always the same name for um for for all the entities what what we can do also we can also move this entity right here to this base entity right we can use this field right here so now we can see that we have this ID generated value and so on so forth I will also just go ahead add some lbook annotations to generate the Getters and Setters and so and so forth all right so I will just copy this one and I will give you a small hint which is super important uh here when we work uh with lombok so here we see we have all the Getters and Setters but here within this one this is going to be the parent entity and we want to use a builder when we use a builder within uh dant class or the the child class we will not be able to access this Fields right here and to do so uh lombok they created uh an annotation called super Builder from the for now it's from the package lombok do experimental and might be moved uh later on but The annotation is called super Builder all right so here what we need to do first is use this super Builder with all the entities that we will that will extend this base entity or in any case if you have inheritance between your classes and you want to use this Builder annotation just go ahead and use this superb Builder instead all right so now let's go back to this author uh this author entity and we see right here this one is in red because we don't have the primary key but once we extend our base entity this error will move on okay so this this is now is this is now gone all right and also when we use inheritance and we use this data annotation we we need also to add the equals and hash code annotation all right and here it needs to call the super so these are some hints for you when you want to use correctly all the annotations from lombok and also from uh from the pist from the jpa or Java persistence API also go ahead and check my C about lbook and the useful annotations that you can use and also how they work all right let's move on right now I will also make these changes to all the entities we have right here and when we restart the application we want to make sure that we have everything as we had before plus I want to see these four Fields right here okay so I will go ahead and do it for all of them so what we need to do or the way we need to implement this so let's first replace this Builder with super super Builder and let's extend the base entity next we need to remove this ID field with this with the annotations and that's it so this is how we can extend or this is how we can inherit from this base entity and keep everything working fine also don't forget to add the equals and hash code annotation let's do the same for lecture and so this one ex stands base entity let's move this ID field you can skip this one like for the rest of the entities if you are familiar with that and here and I will also do add think equals and hash code all right so next one is resource same thing here let's also extend our base entity right here and remove this ID field next one is section and then we will restart the application and see the changes so let me remove this and extend the base entity all right replacing also the Builder with the super Builder and here we also need to add the equals and hash code and then you can optimize the Imports to have your code as clean as possible all right so here what we have or this is what we have right now let's go first and check the database make sure that we have everything as before before restarting the application let's make sure that we have the same structure and the same tables that we have right here okay so now go ahead start the application because I stopped the application that's why we don't have any tables right now because we have the property create drop but let's start the application first so everything is started and we have all the all the entities but we don't see that we have a base entity getting created and this is what we expect now I will refresh the schema right here and we see that we have this six tables all right author and this is the The Joint table and if I open this author I see now I have nine columns including this created ad created by and last modified also I still have the same ID and this ID is inherited from this base entity so this is how you can uh group The Common uh the common fields within one entity and this can make your your code uh a bit cleaner and you can group and if you want for example to change the type from local date time to for example just uh java.sql .d here instead of this local date time you can do this change only in one place instead of doing this change in all the places also for example if you want to link this created by and last Modified by to the real user table in the database you can just update and modify in one place so this is how the the maid super for class works and as I mentioned uh like finally before we end this part using the maid super class annotation can help you avoid duplication of code and make it easier to maintain common properties in large applications however keep in mind that the maet super class does not have its own table so do not forget this one and if you want to use a mapet super class entity so do not expect to have a separate or its own table and it cannot be queried or persisted directly so we cannot query this base entity and we also cannot persist this base entity it can only be used and a base class as a base class for for entities all right so if you have any questions don't forget to drop me a message otherwise let's move on now let's talk about inheritance within this part of our class diagram all right so we have here just a reminder we have our resource video file and text okay so let's first prepare and create these three classes right here I will create class called video file and text and then let's explain and see how we can implement the difference the different uh inheritance strategies okay so let's go back to our inj and here again with this models uh with this models package I will create three uh three classes but first I want to go and open this resources and I will just roll back all these changes I mean I will um I want to use this integer right here why because we cannot extend multiple entities or multiple classes uh using Java all right so this is the only and unique uh reason for that so because our Focus right now is the inheritance uh regarding this resource otherwise I will I can also show you how how we can do or how we can uh Implement multiple inheritance all right okay so uh this is what we have right here and now I will just go ahead and create my first class I will call it video and this video VI it will have also the same uh without the entity I will just copy this the these annotations the lombok annotations but here instead as I mentioned before it will be or it should be super Builder and for this video I will have uh right here a private int length so it's just the length of the video I will create another class like we have right here we have file and text okay now I will create a file class so this file it also will have the same annotations and here I will use the super Builder instead do not forget also to update uh or improve the Imports and here I will have just private private string type so the type is just to say say if it's um for example PDF txt word and so on and so forth all right let's create now the third class which is text also do not forget to paste the The lombo annotation and change this one to a super Builder and within the text we have our private content attribute private string content and that's it now we have the three files or the three classes that we have video file and text and now we can go back and start explaining and implementing the different inheritance strategies using spring data jpa let's first see the single table strategy so this strategy is a way to map an inheritance uh hierarchy to entities to a single database t table this strategy is used in hibernate or uh spring data GPA or mainly when we talk about the Java persistence API so jpa to Define how inheritance is implemented in the database with the single table strategy all subclasses of the inheritance um of The inh Inheritance hierarchy are mapped to the same table and then we talk we or we need to talk about a discriminator colum is used or we need to use it to distinguish between the different sub classes so the discriminator column contains a value that indicates which subass uh a particular Row in the table belongs to and within when the single table strategy is used all of the properties of the of the parent entity class and its sub classes will will be persisted to a single table the discriminator column is used to determine which subass a particular row belongs to now the single table strategy is the simplest way to implement inheritance in the database but it can lead to an efficient queries and a large table size it is best suited for situations where the number of subclasses is small and The Inheritance hierarchy is not deep so this is theoretically uh how single table inheritance works now let's try to implement this first of all to implement the single table single table strategy so we go first of all to the parent class or the base entity or whatever you can call it whatever and in our case this is uh uh this is our base entity or the parent class but first of all here this one needs to be super Builder because if in case you need it later on and now here we need two things we still have this entity annotation which we need and we need also to add this inheritance annotation and and it's the one from always Jakarta persistence all right and within this inheritance uh annotation we can Define we can Define the strategy and here we can see that we have joined single table and table per class all right but as you can see right here by default it's using single table so whether you precise single table or not it will be by default single table okay so you can just use inheritance annotation without the strategy so it will take as a default value the single table all right so this is the first first step now let's go to this video files and file and text and in here optimize the import first let's collap this one and now within this uh this video I will just add the entity annotation okay so the same and here from this video we need to extend our resource because a video is also a resource right and don't forget with this data annotation from lombok when we use inheritance or we extend another class we need also to implement the equals and hash code with the attribute or the property called super equals true this is just a reminder for you let's go ahead and do the same for file so here we need the entity annotation and now we need also to extend our resource entity and then we need to add the equals and hash code annotation let's do the same for text entity let's extend resource right here and finally we add the equals and hash code annotation all right so here we have everything up and ready for us okay now let's restart the application and see what will happen with only this configuration that we wrote right here so click on restart so now the application is up and running and we see that we have no exceptions so everything is good so far let's move this one and here let's go back to our database click here and update or refresh the database so we have the inheritance within the resource Source uh column and we see now that we have nine columns within this class okay so we see here that we have uh ID name and so and so forth but we see here that we have the extra and we see here that we have the size this one the this is the one coming from uh from the from the file or from the video we have also the type we have the content and so so and so forth we have also the length and what happened right here with this basic configuration so hibernate he grouped all the he grouped all the fields within the B the parent uh the parent entity so everything now is within this resource and if we want for example to create a content and so on and so forth if we want to create a new instance of type text we need to fill all the information including other information from the resource including the content okay now let's try to to give some more differentiation between the entities all right so let's see what we can do as extra configuration to make this more clean and More Beautiful to use all right so now let's talk about this discriminator value this discriminator value will give a value that we will SP specify in advance to each type or to each derived class so for example if we give uh the value V for video F for file and T for text we will add uh a column called type right here to the resources and then this resource type every time you create a new instance of video this type will be automatically v f for file and T for text all right so let me show you how we can do that so so here we have our inherit inheritance strategy which is single table now we need to add an another annotation which is discriminator colum and this one it's just to give the discriminator colum name and here for this name by default it's D type if we do not if we do not precise this colum by default it will be D type like we have right here okay so it's the discriminator type but let's give it uh a special name let's call it resource type all right so from the parent uh class or the parent entity we need to add this discriminator column to specify the column that we want to use otherwise you can leave it to the default one which is D type all right now let's go to the different uh different entities now after this entity annotation just go ahead and add a discriminator value so this discriminator value let's for example as we mentioned before let's give it V for video I would just copy this annotation and paste it in different entities f for file and T for text so now if we restart the application we will see that instead of this dtype column we will have our resource type column right here so I will restart the application and here the application is restarted let's open the database and refresh it again so refresh this resource table or all the data uh all the database So within this resource we see that we still have nine column and now our column is called resource type all right and we have this name size and so on so forth those are the attributes that we have from all the children classes all right now if we create a new instance or if we want to persist a new file we will create all uh we will insert all the data including uh for example for the file right here we have the type we will say for example PDF right here and all the information and automatically this resource type will be V so the value of this resource type it will be automatically uh F sorry not V because F is for file so it will be f for file and it will be V for video and so and so forth so you don't need to worry about um to you don't need to worry about filling this resource type because every time you create an instance of the children or the child class it will be automatically filled using this discriminator value all right so this is how it works and in the next step I will show it to you in action I will um we will insert uh for example a new file or a new video into the database and we will see what will happen let's see now in action how we can uh how this is going to look like all right so I will close everything right here and in this repositories package I will create um a sample reposit for this uh entity called video because I we want to check only one of them so here I will create a new class I call it video repository so for you in case you want to use uh inheritance you need to create of course one repository per per entity okay and uh here let's extend jpa repository and let's give it the type video and of course integer for the ID so this is our repository right here it's ready to use now let's open our main uh class or M our jpa application class where we have the spring application repository and I will inject right here our video repository I will call it video repository okay and I will bring back this ban annotation okay so uh this is going to save this author but I will just comment this out because I don't want to insert any other lines so uh now let's use this video repository to insert one data so I will have here our video equals video. builder. build so for this video I will just precise or give some information like um the name for example uh abc dot um length let's check our video right here we have the length and let's say for example it's 6 minutes or 5 minutes it's also okay and let's give it another uh another information which is the I I guess that's it okay so let's give it just the name and the length and here let's use our video repository dot save this video entity okay and now all we need to do is restart the application and see what will be inserted in the video or in the resource table into our database let's restart now so the application is restarted and we see also that that we inserted something into uh the into the resource table and here we see that we have this resource type but we did not precise it just to remind you here we don't have we have only the name and the length Okay let's check this resource table right here I'm going to refresh the database or the table and then double click it to show the content so we see the content right here that we have first of all we have V for the resource type and this is something that we did not precise we have the ID name we have the size which is zero because it's an INT that's why it's zero because int by default equals zero and we have the URL type and so on and so forth also we have the length that we precised so we have the name ABC and the length equals 5 and the resource type is V so if we do this the same for file and text it will be f for file and T for text so this is how single table strategy using discriminator column and discriminator value this is how it works so if you have any question just go ahead drop me a message otherwise let's move on and check the next strategy now let's comment first of all uh this being annotation close this class and now we will talk about about the next strategy which is joined table this strategy each subass in The Inheritance hierarchy is mapped to a separate table with a foreign key pointing to the base table this allows each subass to has uh to have its own table with only the properties that are specified to that subass okay so when the joint strategy is used used each sub class will use or will have its own table with a foreign key pointing to the base table this allows each subass to have only the properties that are specific to that subass which can lead to more efficient queries however it also requires M more tables and foreign Keys which can make the database schema more complex The Joint strategy is a good choice where when you have a large number of sub classes with significant differences in their properties and you want to optimize the performance of your queries however it's not suitable for situations where you need to query the entire inheritance hierarchy at once as as it requires multiple joints to retrieve the data so these are let's say the pros and cons of this strategy now let's see how we can implement this so let's go back here to our resource let's collapse this one and let's go back to our resource entity so now instead of this inheritance first we need to command out this one because we don't need this discriminator column anymore and now for the strategy instead of single table we will use the joined one all right so this is the only required change from the base entity so we have this entity and again The Inheritance with the joined strategy and no discriminator colum is needed so this one I will just type it right here only with single table all right so you don't mix when you when you directly check the code you don't mix with this annotation right here all right so now let's go to the sub classes let's start with this video right here for example and now for this video we don't need these discriminator values so let's go ahead and remove them all because now as we mentioned we will have uh a table per subass okay so that's it this is how the joint table works let's restart the application and check what will happen so now the application is up and running let's open our database and refresh it so refresh it right here so we see now that we have this file we have this text and we have this video table so let's check the columns here we have this content and the ID also we have one foreign key which is this ID which is pointing to the resource all right so this text table contains only this content which is is the attribute that we specified right here let me make it uh in both sides so we have only this content right here and we have this ID which represents the primary and the foreign key at the same time because we see right here that we have these two icons the blue one and the golden one so they point to the same uh to the same thing so it's primary and a foreign key at the same time and we will see the same thing if we open this video right here so we have also the length and ID and now let's try to insert some data we have already something in here within our jpa application let's bring this Bean back let's restart the application and check what will happen so so now the application restarted and we see here that we have uh two insertions instead we just have we just created a query or we just inserted one element into our video table all right so here what we have we have this video. Builder and we have we precise the information of the video but we see right here that we are inserting into resource and we are also inserting into video so let me show you how this is represented as data in the database so first of all I will open the resource let me make this one full screen so here we see that we have the ID we have the name which is ABC the one that we specified and we have this default values for the rest of them if I open the video right here I see that I have this ID column which is as I mentioned which is the primary and the foreign key at the same time and we have the length that we specified so automatically hibernate inserted two elements or two lines into uh two different tables because we have our strategy as joined okay now let me uh show you something you might also want to do in case for example you want to give a special or a custom name for this ID column which represents the foreign key we can use an annotation for that all right so let me make it full screen I will keep the Bean for now and I will just commented out once we are finished with this uh join table strategy all right so within this uh entity or within this entity called video which is a subass here we can use an annotation called primary join column okay so this primary join column we can give it the attribute name and here I will call it um for example video ID all right so now when I insert or I restart the application and we will insert some data we will see that this ID right here this column right here ID it will now be rename to video ID let's restart this so first of all we can see it already in the insertion query so when we insert into video we have length and video ID also if you scroll a bit up and you check the codes of creating the the table video we have length and we have video ID instead of ID so by default it will use the ID name or the ID name field of the parent class so in this case it will use this one but if we want to customize it and have our own name for each entity we can also use this primary key join column so let's open this video and we see right here it's now called video ID all right so uh that's it so this is how join table works again before we finish let's go back to our jpa application and let's command this out and in case we need it we will bring it back again all right so if you have any questions don't hesitate to drop message write me an email contact me on social media otherwise let's move on now let's see the table per class strategy so the table per class strategy uh each Concrete subclass in The Inheritance hierarchy is mapped to a separate table abstract super class are not mapped to a table and their properties are inherited by by their con concrete sub classes so you may ask the question what is the difference between this joined table or uh and also the you might ask the question what is the difference between the the strategy joined and the strategy table per class so it's super easy let's check now we still have the joined table right here so here we have the resource that contains The Columns of the base entity or the parent entity which is name size URL and so on so forth and each sub class contains only its own uh its own attributes with the ID imp plus all right now when we talk about uh table per class this means that we will have a table with a table video for example with all the attributes from the resource table joined into this text table all right so this is the main difference this means that we will create a table for each sub class so when the table per subass strategy is used each concrete subass will have its own table with a copy of all the properties inherited from the base class this allows each subass to have only the properties that are specific to that subass which can lead to the most efficient queries however it also requires the most tables and can make the database schema more complex so in case you have multiple inheritance or many sub classes so your schema might be uh a bit complex than the normal so the table per class strategy is a good choice when you have a small number of sub classes with significant differences in their properties and do you want and you want to optimize the performance of your queries however it's not suitable for situations where you need to query the entire inheritance hierarchy at once as it requires multiple tables to retrieve the data now let's see this in action let's see how we can implement this table per class strategy so the implementation is super easy there is not uh there is not a lot of things that we need to change so first of all let's go back to our basee entity and here instead of inheritance joined let's use table per class all right so this is the first change and I will just go back to the video right here and comment out this primary key join annotation because it works with the joint uh strategy so that's it all we need to do to mention here that we want to to use a table per class now let's see the impact when we start the application and then we will see or let's also comment or bring back this spin annotation and let's see what will happen when we insert a new video within our database so let's see the the schema changes and also the impact when we insert data so first of all we see here that we have only one insert which is inserting into video and we have the lecture name size and so and so forth now let's see how this is represented in the database so now I will go back here and click on refresh and we see right here that we have this for for example this video um this video table right here we have our uh we have our all the attributes and we have the size and so on and so forth so we have all the attributes from this resource table and we also have the attributes from the video all right so if I open this video we see right here that we have the ID name size and so and so forth so we have all the information joined into one table per subass and if we check also for example file or text we will find the same thing so here we have six columns and this is the content or the attribute that we have from the text all right so um now this is how inheritance works with hibernate let's go ahead and check uh few issues that we might face when using inheritance and how to solve them when we work with inheritance we can also query the base entity so we can Define the strategy that suits us and we can also or we want for example to retrieve all the res sources of our database okay it's like uh select star from resource and that's it or like using the find all methods all right but we have one issue is when we query this resource table we won't for example just to get all the informations or just the attributes of this resource entity and we don't want to get any information about file text video and so and so forth I just want the resources not this sub classes of that so this is with this one like in the background so in the background when creating the base class which will return all the sub class records as well by using a union statement in the background and the use of Union can also lead to inferior performance when choosing this strategy another issue is that we can no longer use identity key Generation all right so when we use this kind this type of inheritance we might face the issue of polymorphic queries so as mentioned querying a database class will retrieve all the sub classes uh entities as well now if we don't want uh a subass to be returned by the type of the query we only need to add the a hibernate annotation to to say or like to uh exclude it from the definition so for example if I want to exclude this video right here if I want to exclude this video entity when I want to query the resources I need to add one onot one annotation to exclude it from the parent when I query the parent all right so this annotation is called polymorphism and and here I need to give it a type so polymorphism and the type right here it's polymorphism type. explicit because by default it's implicit means when I query the resource. Java it will automatically query all the sub classes from that one but if I say I want it to be explicit this means that it will query this video only when it's required or only when I ask for it otherwise it will not uh it will not create okay so this is how we can solve the polymorphic queries issues so just go ahead use this annotation and exclude all the sub classes that you don't want to create okay so if you have any questions don't forget to drop me a message otherwise let's move on in this chapter I want to teach you how to work with embedded IDs or embedded entities generally speaking all right first of all let's define what is an in embedded IDs or embedded entities okay so in software we come across many use cases when we need to have a composite primary key to Define an entry in a table a composite primary keys are that use more than one column to identify a row in the table uniquely So within one table we can Define more than one column to be the unique identifier of that column okay so we represent a composite primary key in Spring data jpa by using The embeddable annotation on the class level this key is then embedded in the table corresponding uh entity class as the composite primary key using the embedded ID annotation we will see all that in details but first let me give you a use case for that so here like I have this other table other table one other table two it's just an example to tell you that this is an independent database so now let's take the case or the use case of a microservice and now we will talk about the order microservice all right and here we have for example this order table so this is just uh an illustration example it's not a real life example just for illustration and here let's go back and we take this order table we have right here and we don't want to rely on generated IDs okay I don't want to create a generated ID which is auto incremented to be my unique uh my unique ID of of this table but I want to have my own ID I want want to create my own ID but this ID I want it to be composed why I want it to be composed it's not just a want but it's a need why because in real life one user can order or can um pass or validate many orders in one in um at the same time or in one day for example okay so uh in this table right here we can find the same username multiple times so this means that we cannot rely only on the username okay so we have also we have here Order date and the order date itself we cannot just rely on this order date because at the same time even at the same milliseconds we can find more than one user ordering uh something all right but when we talk about the composition when when we talk about username and Order both of them this is unique so both of this username the combination of the username and the order date it's Unique this means like the unique identifier of one order will be the username for example alibu as a username and the order date let's say the 0101 2023 uh at uh for example let's say midnight okay okay so at this time only we have only one user this alibu user he's the only one passing this entity uh this order sorry not entity but the order but we can also find another combination at the same order time but within another username so like the combination of username and Order date is something unique and we can rely on so this is the use case or one of the use cases when we need to use embedded IDs all right so now let me show you an action let me show you in real life how we can create embedded IDs and how we can use them within our entities in order to demonstrate that let's first create and prepare the ground for that so to use embedded uh entities and using the embedded IDs what I will do I will create a sub Pro sub uh package within this models package and there I will put all the all the entities and all the resources related to this embedded ID example so right click right here on the models and then I will create a new Java class I will call it order ID and this order ID I will created um within the package embedded Okay so so I will just call a pack create a package called embedded and within this package I will create my class called order ID hit enter and now we have our package and also we have our our entity so now in order to to create an embedded ID so first of all you need to define the IDS or the attributes that you want to rely on to use that as an ID and uh as our case demonstrat so we want to have something uh composed of uh username and date on and or we can call it order date so I will first of all create a string username and here I'm just assuming uh that the username is something unique so we don't have two users with the same username then let's create a private local datetime let's go call it order date so this is the username or this is the entity well actually it's an entity but it's not a persistent entity it's something like the map super class the one the example we saw before but it's not a persistent entity it's just a composition where we can compose multiple uh attributes and we can use them as as an embedded ID so first of all we need some annotations I will use the data from lombok all arcs Constructor the no args Constructor and here I will use one annotation which will make this one an embedded embedded entity so here The annotation is called embeddable and this embeddable comes from Jakarta do persistence because we are using spring 3 this is just a reminder so let's use this embeddable annotation using this embeddable annotation we'll tell hibernate and spring data generally speaking that this is an embedded entity now how to use it I will show you just right away so within this embedded package I will create my order class or order entity okay so I will call it order and here here I will just copy this information so these are the annotations that I will need and of course my class is an entity so we need the entity annotation and first of all I will create a string um let's call it order INF for example and a private string another field because our focus is not about the fields but it's just uh to say that we have few information or few Fields within the order entity so now we see the same error that we know here when we create or we map um a class or Java class with the entity annotation so it will claim about an ID so here it says that this persistent entity order should have have a primary key and here it it's asking to add an attribute or an ID attribute for us as we mentioned before we don't want to use an autogenerated or an autoincrement ID but instead we want to use this order ID class we just created so first of all I will create an instance of that or field of type order ID and I will call it I ID all right so for now we have this order ID but it's still not known as an ID for this entity now to make it to make this one an ID we use The annotation embedded ID all right so this embedded ID right here so here we see we also still miss something but first I will I will go back to this in a few seconds first I want to show you and I want to go quickly to the documentation of this embedded ID annotation so here it says apply to a persistent field or property of an entity class or maid super class so here you need to focus it's entity class or a MPP super class to uh denote a composite primary key that is an embeddable class the embeddable class must be annotated as embeddable so this is The annotation we are already used also there there must be only one embedded ID annotation and no ID annotation when the embedded ID annotation is used so this means when we when we want to use the embedded ID annotation we cannot have another ID annotation within this one all right so next it says that the attribute override annotation may be used to override the column mappings and so on and so forth and this one we can also skip you can I I will get you can have the time to to read it and here it says if the entity has a derivate primary key the attribute override annotation may only be used to override these attri those attributes of the embedded ID that do not correspond to the relationship in the parent entity okay and here also you can see an example we have for example this employee primary key with this embedded ID and here we see that we have this dependent ID annotated with The embeddable annotation right here okay so this is a bit uh and quickly The annotation of this embedded ID now let's go back and check this error right here okay so here it says that the class order ID should implement the ser realizable so when you want to use an embedded ID absolutely think about extending and implementing the serializable interface okay so this order ID should Implement serializable so the serializable is the one from java.io package now if I go back to the order now the error is gone and and I have my entity So within this embedded package I will create my order class or order entity okay so I will call it order and here I will just copy this information so these are the annotations that I will need and of course my class is an entity so we need the entity annotation and first of all I will create a string um let's call it order info for example and a private string another field because our focus is not about the fields but it's just uh to say that we have few information or few Fields within the order entity so now we see the same error that we know here when we create or we map um a class or Java class with the entity annotation so it will claim about an ID so here it says that this persistent entity order should have a primary key and here it as it's asking to add an attribute or an ID attribute for us as we mentioned before we don't want to use an autogenerated or an autoincrement ID but instead we want to use the this order ID class we just created so first of all I will create an instance of that or a field of type order ID and I we call it ID all right so for now we have this order ID but it's still not known as an ID for this entity now to make it to make this one an ID we use The annotation embedded ID all right right so this embedded ID right here so here we see we also still miss something but first I will I will go back to this in a few seconds first I want to show you and I want to go quickly to the documentation of this embedded ID annotation so here it says appli to a persistent field or property of an entity class or maid super class so here you need to focus it's entity class or a mapet super class to uh denote a composite primary key that is an embeddable class the embeddable class must be annotated as embeddable so this is The annotation we already used also there there must be only one embedded ID annotation and no ID annotation when the embedded ID annotation is used so this means when we when we want to use the embedded ID annot ation we cannot have another ID annotation within this one all right so next it says that the attribute override annotation may be used to override the column mappings and so on and so forth and this one we can also skip you can I I will get you can have the time to to read it and here it says if the entity has a derivate primary key the attribute override annotation may only be used to override these attri those attributes of the embedded ID that do not correspond to the relationship in the parent entity okay and here also you can see an example we have for example this employee primary key with this embedded ID and here we see that we have this dependent ID annotated with The embeddable annotation right here okay so this is a bit and quickly the annotation of this embedded ID now let's go back and check this error right here okay so here it says that the class order ID should implement the serializable so when you want to use an embedded ID absolutely think about extending and implementing the serializable interface okay so this order ID should implement realizable so the serializable is the one from java.io package now if I go back to the order now the error is gone and I have my entity okay so if I start my application I should see my order class or my order entity created in the database and I should see a composite primary key okay so let's go ahead click Start and check these updates so uh let's check the logs okay here we see an exception so the exception is we have a psql exception and this is because we have a syntax error near order because the order is already a reserved uh keyword so to solve this you already you already know the solution let's use the table annotation okay let's give it a name and let's give it underscore order right so now restart the application and we should see everything working fine right now all right so the application now is running we we check we don't have any exceptions no issues and also we can check the logs and you will see that we have our order table getting created okay so now let's go ahead check our database refresh and see so here we have this order table let's open it and we have already four columns so for these four columns we see that we have this order date and username both of them they contain or they have this golden key icon so this golden key icon is the the primary or is the icon of the primary key so our primary key in this database is the order date and the username both of them concatenated all right so if we check the keys right here so we see that we have this underscore order uncore P key so it's order primary key and it's a composed or composed key and it's composed already of this order date and username so this is how we can create an embedded ID in case you need to create an embedded ID now you have the knowledge to do it so if you have any questions don't hesitate to drop me a message otherwise let's move on so now we saw one example or one usage of this embeddable annotation I want to show you another one let's go back to our diagram right here and for this order for example we want to have or we want to add some information about the delivery address but we want this information to be uh embedded within the same the same entity or the same table right here so I don't want to store the address or the delivery addresses in a different table but I want it to be within the same table order right here you might say this is so easy to do all I need to do is within this order entity right here I just declare the information of the address okay but yeah the answer is yes but imagine we want to use the same address object also to store the address information with our tables within the same database or within the same schema so like this what I need to do is to duplicate the code in each entity which is not good okay we have a better solution okay the second one you might say we I can use the method super class and extract all these entities and just extend my entity with this address entity I say okay this also feasible but if you have multiple inheritance right here if you already for example extend a base a base entity or if you extend another or you have inheritance you with uh within your database so what should be the solution the solution can be using the embeddable entities all right so with this within this package embedded right here right click and create a new Java class and let's call it address okay so this address first of all we will need the same uh lbook or the same basic lbook annotations right here data all our Constructor and no arcs Constructor and now I will just create few dummy Fields so here I will have string Street street name private also another string house number for example uh house number it's a string just in case you have one a 1 b 1 C and private string zip code so it's also string it might start with zero and so and so forth so let's not focus so much on on the fields right here but our main focus is to understand how this embeddable works so once we create and once we Define all the attributes of our embedded entity as we did in here within this order we need to use this embeddable annotation okay so let's use this annotation right here and like this we just created our embeddable entity now I will show you how you can use this embeddable entity as an attribute within another entity now let's go back to our order class and within the other fields that you created I want to create a new field of type address so I will create an address and I will call it address all right so now I want to tell that this address is an embeddable entity within my order entity all right so I I already me the solution so let's use the embedded annotation okay so here we have embedded ID and this is embedded and let's check quickly what is this embedded annotation so it specifies a persistent field or property of an entity whose value is an instance instance of an embeddable class so the embeddable class must be annotated as embeddable all right so the attribute override attribute override and so and so for may be used to override mappings declared and default or defaulted by the embeddable class so here you can also override some attributes when you use this embeddable class all right so this is the embedded annotation now let's go ahead start and test it click on restart right here so our application is up and running right now and let's go ahead and check the database so now I will just refresh the database and let's see what will happen right here so within this order table we see right now that we have seven columns and here we see that we have the house number street name zip code and so on so forth so the the fields of the address are now included or embedded within our order table so if you want to do or if you have a need and us it usage like that or use case like this one always think about using embeddable entities all right so embeddable entities will make your code much much easier and uh improve the granularity of your code and your code will be really reusable all right so because this address uh entity or this address uh class right here we might use it in many places so in order to duplicate uh not in order but instead of duplicating the code of uh the fields of this address class just create an embeddable entity and use it or call it whatever you need if you have any questions go ahead drop me a message otherwise let's move on previously we explained the hierarchy of the spring data jpa uh interfaces and how this helps us and provide us with methods and predefined methods to search data and query data from the database so now we cannot talk about spring data jpa and not talk about querying data from the database and querying the data means reading and writing and also deleting and all the interactions and the trans transactions that we can make with our database the spring uh data jpa and the repositories and the jpa repositories they provide us several ways to dynamically generate queries at run time so these are called uh query generation from method names or also known as query derivate query methods okay and these derivate query methods they allow you to Define queries based on the method name and uh of the query method you are calling so for example if you want to find the author right here let's first before going to this method right here let's just recap and remind about what we have so we created before an interface called author repository because we have an entity called author right here and this author Repository interface extends already the jpa repository which is a generic interface that takes two parameters the first one is the entity in question and the second one the ID type that we use within this entity okay so this jpa repository will use the author. Java our entity that we created and just a reminder with the author we have these IDs or this sorry not IDs about these fields we have an ID first name last name email and age okay so here within this author repository interface which extends already the jpa repository as I mentioned before we can create methods okay so it's an interface and you know within an interface all we need to do is the return type whether it's a function or a void and then the method name and the parameters this is how we create me methods with within an interface so as I mentioned spring data jpa provides us uh a way to dynamically generate queries okay and we call it uh derivate queries or derivate methods so this is how we can write it so here as I mentioned it's the return type and then the methods that we want to okay so let's explain this example right here we have this list of author so our method will return a list of authors and here we have find by last name and we have our last name or Ln as you you can call it as you want as a parameter so what will happen in here so this find by last name method generates a query that search uh the users or search the author with a specific last name and this method right here for example this find by first name and last name Will generate a quer that searches um the authors uh or the user by first name and last name okay we can generate other queries like uh like in here for example we can count we don't have only the find by we can also count we can also delete we can also do as many operations as we know in SQL using the derivate query methods okay so for example if I want to count all the authors in my database by age so all I need to do is to write the return type and spring data jpa will take care of the conversion okay so the count all by age within the age it will create a query that counts all the authors in this author table by the H and return this value also if for example uh we have already the delete methods that we can use or the predefined delete methods but if we want for example to delete uh the the list or we want to delete a list of authors by age all we need to do is delete all by and then we have age like bu and here it's followed by the property that we want to use Okay so let's explain a bit more here in order to generate one of the of the methods right here that will create a query behind the scenes at the runtime all we need to do is we have find by and Then followed by the property okay so this is the the simplest way so it's find by and then follow it by the property name and depends on the return type right here uh spring data jpa will determine what to return exactly so here we have find by so it will search everything from the database and return the result set okay but if we have for example here an author or an optional of author so I will explain the difference so an optional is the design pattern uh null pointer so this is a wrapper to wrap this author object within this optional class right here so this find by email spring data jpa will will search the author by email from the database and then return a type of an optional of type author okay so also the same here we have this find by email but in this case we will return the author so spring data GPA will do nothing except creating an object author and just return it okay so here as I mentioned we have the findby followed by the property and then you can create as many methods as you want okay so this is the first one also we can use find all by so they both work in the same way we can use find all by last name find all by first name and so on and so forth okay now we can also combine uh properties combine means what we can use uh operators such as and and or so I can search the list of authors by first name and last name okay so here we see we see that we have find by first name and last name and we need to pass these two parameters okay so FN for first name Ln for last name okay we can also use for example let's go back to this method I want to ignore the case when I want to query all the all the authors all the list of authors from my database so here we can say find by last name and Then followed by ignore case okay we can also use other operators like not like we can um use find by last name like so means this uh contains and so and so forth okay so we will see all this in action we will see how we implement or how we can Implement these methods okay so I hope this part is clear if you have any questions don't hesitate to drop me a message otherwise let's move on now let's see all this in action so first of all I will teach you how you can how you can write these methods so as we explained before first of all we start with the return type so here imagine we want to fetch the list of authors from our database and from this this author table by first name for example okay so when we say that I want the list automatically think about having a list okay so here you can whether work with list array lists Collections and so on and so forth but I always recommend using interfaces don't use classes use interfaces so in order when you want to change the implementation it's easier okay so let's go back so here we have a list and then the type so we want a list of author and then you have this find by so automatically when you type find by and you have the type as list so it will automatically transform it or map it to a list of authors you can also when you when you work with lists you can also use find all bu find all means that you want to search everything okay so they both work in the same way so let's use find all so then here if you have the inell the ultimate version or for the people who are using another IDE which provides autoc completion so here when you do command uh space or control space you will see that your IDE will propose the list of properties or the attributes that you have within the author okay so and here you can have a look on the gener ated uh generated or the autogenerated properties which are automatically detected from this author entity okay so we can see age for example and even within the age we can see that we have a lot of methods okay so imagine we have all these method uh within only the age property for example if I want to search all the authors where the age is null so I only need need to query um find all by age null age not null age not like not in and so and so forth so you can have a look and all and on all these methods and we will explain most of them okay so here for example I want to search all the authors by first name so all I need to do is to type first name okay and within this first first name also I can see that I have a lot of autocomplete so after before between uh by the way not all of them are appliable because when we say uh first name after he mainly we are talking about dates okay before also dates and between and so on so forth so you need to be careful not everything autogenerated here is usable or appliable for this specific property okay but you will learn it by the time so now the this find all by first name is completely sufficient now I need to provide my parameters so here uh you need that you have the same type like in here and then just type any name I will call it f name just to just to mention and to make sure that this works I don't need to pass the same here the same attribute name also one thing worth mentioning and it's really really important so you see this first name right here if I go to my author uh entity you see that we have the first name is written in exactly the same way so we have first and the name with the capital N okay so if you go back here you cannot say like this you cannot call your method like this so it will not be detected it will not be highlighted as an error but within your anj or within your IDE it might be be highlighted as an as a warning but not for all the cases but this worth mentioning so here all the only thing that you need to change is the first letter because you are using camel case so what you what you need to do is just copy the field that you want to use and until you get used to it copy it and then here just paste it and then the you change only the first letter to a capital letter okay so like this you will have the method or the exact method that will work for you and if I change this one to for example a lowercase we see that it's highlighted and here we see that um cannot resolve property first name this means that my anj or my IDE he automatically detected that this first name property is not within this author entity okay so here you need to always be careful about this all right so this is the our first method and this one will search all the lists or of authors from our database by first name now let's try and see how we can improve or how we can extend this this method okay all right so let's try how we can extend and improve a bit this query just as a reminder I want to remind you that this query is the equivalent of this one select star from author where first name uh I will use it as as in the database uh let's say this is a native query equals and and here we have our first name as parameter right here so this is the same exact query now now let's answer the following question what if I want to find all the authors from my author table where first name equals any for example equals this and I have in my database the users are all in capital letters okay are all ABC case but I want to ignore the case I want even if I want even to pass when I pass this Ali as value I want always to query the data So within this method right here and this generated query right here passing this value Ali and having all the first names in the database equals or in uppercase this will not work this will return an empty list okay this will return nothing now let's try to extend this query and make it ignore the case all right so here we have find all by first name and I already gave you the answer we need to add one property which called ignore case okay so when we say ignore case now it will accept this query right here okay and it will return some data all right so this is good now what if I want to get all the data or all the authors from the database where the first name contains this one for example contains a l all right so and also I want it to be also ignore case in order to do so I will duplicate also this method so here we have find all by first name ignore case we can also add containing so we need find all by first name containing and then ignore case so as you can see here we can concatenate and we can use multiple uh use multiple uh filters within the same query method okay so here we have find all by first name so this is the attribute name and then the condition that you want to use or the CLA the work Clause that you want we want to use containing so containing will be the equivalent of this one right here so it will be something like that okay so it's going to be like percent percent so this is the exact same thing and also we want to insist that we want to ignore the case so here be careful it's property or we close and then the refinement if we want to refine our query okay so now I want to so this one I hope it's clear otherwise you can drop me a message and I can explain it a bit more now I want to get all the authors where the first name starts with this and also ignoring the case all right so in order to do that let me just keep this as it is and I will duplicate this method so I will use it always as a base method I will copy or paste uh this query right here so I want as I mentioned to search all the authors from the database where the first name starts with this so here instead of containing I will use starts with so here when we use the start start with the query will be transformed or will be generated exactly like this okay and also here we want to ignore the case now let's take another another case let's play around with these quaries because it's really funny so here instead of starting with I want all the first name that ends with okay that ends with uh sorry sorry I just made a mistake so starts with with it's like that so it's a and then anything because this percent means anything but ends with is the opposite one okay so I'm sorry for that so here I need all the queries or all the authors from the database where the name ends with Al so it starts with anything and ends with a l all right so here I will duplicate the same method and and here instead of starts with I already gave you the answer so I need to use ends with and you can see that this ends with ignore case will transform and will create this exact same query in the background okay so uh we can also we can also add and play with so many attributes and as I mentioned like after the first name or after the property name with within your IDE you can click on control space and you will see so many methods okay so starting with ending with also you can check if the if the author or if an author exists with this first name uh you can also use uh n and so and so forth okay so um for example if you want for example if you want to generate this query so I want the list uh of authors from the database where the first name in for example I want to filter only for for example Ali I want to get all the authors where the name is where the Ali or Buu or coding so here it's super easy as I as we mentioned before let me duplicate this method and here instead of ends with I need to pass in okay so and also here ignore case so I want to find all the names or all the first names uh in from the author table where the first name is in a list but here we we need to pass a list of strings okay so to pass a list of strings so whether we pass a table or we pass a collection okay so here we need to pass a list of string as the first names I will call it first names and this will generate behind the scenes this exact same query all right so you can play with these methods with these filters and you can generate awesome queries out of this now let's move on and try something else now before moving ahead and going deep into this derivate query methods let's play a bit with what we created right here so to do so we will go to this Java application here where we have our command line Runner bean and we need to insert some data into our author table to inable in order to be able to play with these queries but here we Face a small issue which is that if we want to insert multiple data I need to every time to create for example if I want to insert 50 uh authors into my database I need to duplicate this code 50 times and each time I need to change the first name last name age and so and so forth but to do so we can use a dependency which help us to fake data okay so this dependency is called Faker or called Java Faker so it will automatically generate uh data for us including for example first name last name emails and so on so forth also it can generate generate address and so and so forth all right so uh first of all let's go ahead and insert and add this dependency so open the pom.xml file and go down to to the dependencies right here and after the project lumo add the following dependency okay so add the dependency uh tag and within the artifact Rd it's called Java Faker so it's the second one not the fixture but it's the second one Java Faker so select this and then it's from com. GitHub do Java Faker right and the the most recent version at this time is the one2 if you have more or a recent version just go ahead and choose it then click on this load Maven changes and that it you will have the Java Faker within your project okay now let's insert some data first of all don't forget to bring back this bin annotation let me make this full screen and then we need to comment out this one and to comment this out all we all you need to do is Select it and then go to code and here you have this command with block comment okay now let's bring back this code right here and what we will do let's create a loop so I will do for in I equal z i smaller than or less than let's insert 50 and here we have i++ and let's let's move this code inside now instead of this first name and last name I will remove the email or let's let's keep it like that the age we can also keep it uh but here instead of this first name last name what we will do here I will create uh a faker I will call it Faker equals a new Faker okay so this is how we can use our Faker uh uh object and now for the first name I will use Faker dotname we see here that we have this name object which returns a name and from this name we have first name name last name full name and so and so forth so we need the first name last here and also let's use the same one for the last name right here so instead of first name let's use last name okay okay now for the age we can use our Faker do number and here we can generate a number or a random number between two digits for example and the age I want uh my author to be between for example 19 and maximum let's say 50 okay so it will like this it will generate an age or a number between 19 and 50 okay all right so so now we can just run our application and make sure that we have all our authors inserted into the database so let's go ahead and do it okay so here we forgot that our email should be unique so to do that I will just do something like this just to fix it quickly and here I will concatenate it with uh with I okay so it will be contact Z1 and so and so forth so like this we don't have the applications I will restart the application and see so now we see that we have the insertion logs let's go ahead refresh our database and check let me move this refresh the data and here we have our tables and now let's go and check our author table okay so we see right here that we have this email and we see that we have this first name last name and so on and so forth and the information that we provided also the age but now let's make uh this insertion permanent and I because here if you as you remember when we start the application and uh we made this ddl Auto right here like just to remind you the configuration the ddl auto we created is create a drop so all we need to do is to make this one to update okay uh so when we make it update every time we will start the application we will not lose the data so this is what we need to do so in order to do that just go ahead make this property to update like this and then we need what we need to do is to restart the application so we can insert the data so just follow me on this restart your application and then we will have the data inserted so here we have in our database let's refresh it we have this data right here and this data will be persisted like always okay and then we go back here in order to make this data always persistent just go back right here and you can just comment out this insertion or you can also keep it but here we want to play with this um with this part right here but let's comment out all this for Loop so let's use a block block comment so we no longer have this code getting executed and to make sure that what you did is correct just go ahead restart again the application and make sure that you still have the data so here we should not see any uh SQL log telling that that we are inserting and as you can see the application is already started and nothing happened so also if I refresh my database if you open the table right here click this refresh button you see that we still have the data okay also let's just to double check let's refresh this open and we see that we have the data right here okay so now we have permanent data within our database and now we can play with it now I want to give you a small EX exercise so here we prepared everything we have all the ground we need to run our tests so now I want you to play Within this repository this author repository and the methods that we already generated right here so within this command line Runner or if you want you can create a service and some end points and you can play with this methods but just go ahead and test this uh find all by methods and see the output okay so I hope you like this exercise if you face an issue drop me a message otherwise let's move on well done after you played with all these me methods that we created together now let's move on and check something else so here we have our author table already inserted with data and we can see here that we have email first name last name and age and uh for this one I just want to highlight one thing because here for this email what I used here I used the faker name. username because I'm sure that this username will give me a unique uh username and then I I made a concatenation with the at alibu coding.com so you can also do the same also for the age you can uh you can use the faker do number and then number between and it will give you a random number between 20 and 80 for example all right let's go back here now we have uh the data inserted now what if I want to update for example the first one which has uh the ID equals 1 I want to change the email first name last name and age okay so in order to do that it's so easy here we will keep uh this one and also I will keep the bean because in the application uh here I have create drop so this means every time I start the application I will get my data inserted okay so after inserting the data what I want to do is I want to create or I want to copy paste this one or I can copy the whole code and here I want to update author with id1 all right so in this case what I will be do uh what what I will be doing is I will create an author object and here I will just change the data and here I will make it first name Ali last name bu Ali and age it will be my age for example and the email I will move it back as it was so contact at alibu coding.com and then of course I will need uh okay I forgot repository. saave here and then I need the same thing here so now this one it will insert this um this author but if I do do ID here one so this means that we will update this author and let me explain how this works so this save method first of all it it will check the ID so if we have uh if we have an ID the first thing that it will do it will try to fetch any object within this ID so it will make uh select all or select star from author where ID equals one if the hibernate can find data what it will be doing it will be merging or updating all these fields okay otherwise if for example I pass an ID equals 1 million or 100,000 so it will not find any object within this ID in this author table so it will decide that it will be an insertion or creation of of a new input here you need to really pay attention that when you pass an ID the ID should exist in the table you should already know the ID in order to update something so now let's move on and rerun the application so we will we will have all this information but the element or the first one should be alibu alib Ali and with the email contact albu.com all right so here we see also that we have all these insert and then you you see here that you have a select and then an update so the first select is checking if we have the author with the ID that that you specified in here which is the ID one and then we have update author set age and so and so forth and then where ID equals the the ID that we passed as parameter so now I will just refresh this this one and you will see that if I search for the ID number one which will be at the end we see here that we have the urge 34 uh alibu coding uh.com Ali and B Ali as a last name so this is a way of updating the data now what if I want for example just to update this one or this one or only I want to update age or all the ages of my um of my table so for example what if I made a mistake and and I want to fix all the app updates or I want to update all the ages of all the authors in the author table so in this case I need to write one query which will update everything so I don't have uh a condition right here like I don't have an ID and if I want to use this method I need first of all to find all the authors from the table and then I have to Loop over them and each time I need to set the age and of course I need to pass the ID and then repository. save but there is an easier way and we will see it just right now so what I want to do now is running the following query so I want to create a method or create a mechanism that will allow me to update to run the following query which is update author and then set or let's call it a set a. equals 22 for example and here let's start first of all with where a. ID equals 1 for example so I want to have or I want to execute this query so it's exactly the same thing like here but I want to use the jpa or the my repository right here so here I have the author repository and I will show you how you can use this repository in order to run or to create update queries so first of all go to this author Repository and I can just copy this one and then what I will do I will create a void or let's create an an INT uh method so update author just update author it's it's okay so in order to update the author we need to pass an INT age and then int ID because we want to update the the age of the of the author having the ID one for example and here as we mentioned we want to run this following query so in this in order to do that so we will use the query annotation and then this is our query so it's update author a set A.H equals 22 where ID and now the ID should be like this all right so this ID will refer this one and the age should be also H so this query does not support update uh methods or update instructions but we need now to tell uh spring data jpa that this is an update query and in order to do that all we need to do is to add this modifying annotation so when we have this modifying with this query right here hibernate will understand that this is an update query so now if we go back here and if I comment this out and then if I do repository do update author and I pass for example 22 as age and I pass one as an ad and rerun the application we will see that in the author table we will have or we will find that we have an update okay here we see that the application did did not run and we have already one exception so we see that first of all we started to insert everything and then we we got an exception fail to execute command command line Runner and then executing an update or delete uh through through an exception so let me explain to you what is the reason behind that so the reason is that this update method that we have right here was not or is not transactional so so in order to do that or in order to fix that we need to make this modifying query transactional because the modification or the update need to be within the same transaction okay so in order to fix that all you need to do so here you need to put in mind that when you use the query and modifying then you need also The transactional annotation so with these three annotations right here modifying transactional and query with the update query we will be able to update our our author so now let's run again and let's also check the the output so we see here that we have all the inserts that we have but now we have no select as we saw before but it's directly updating so update author set age where ID equals something so let's go back to our and now if I scroll down and they see this one so we see that the ID number one has the age 22 and also if you want to make sure you can just put 1 age equals equals one 100 for example since we know that all our authors uh ages are between 20 and 80 so now we can make sure that we updated the correct one and also the update method or the update query is working as expected so now we see that the age of this uh guy right here is 100 so our update query is working now if you want to or now let's try to update all the all the ages or the ages of all the authors that we have so first of all I will create void update all authors for example ages and here I will just pass an INT age and I will also copy this one and all I need to do is removing this work close and now I will duplicate this one update all authors and I will set the age to 99 for example this one we can comment it out and I will rerun the application oh uh we missed something already so here it we need to use the update all authors and age 99 and I will remove the ID so let's start again okay so we see here that update author set age equals to something and if I refresh right here I should see all the ages equals to 99 so this modifying query and this modifying annotation right here is really useful if you want to do a bulk update and you want to update many things at the same time so you don't need to Loop over uh the data and set this said that set this set that so all you need to do is to create an update query and then if you need and also don't forget if you need this workloads you need to add it otherwise you will be updating oral data in this part we will see together the named queries so in Spring data jpa named queries are useful in a variety of scenarios uh for Oran organizing optimizing and maintaining query definitions in your application and some common uh use cases includes uh encapsulation for example of your query logic so named query help you separate query definition for the rest of the application logic also named quer are reusable they also help us optimize the performance of our application because they um the named query are validated and passed and often optimized during application startup so when you have a named query it will be passed validated and optimized on the application startup also named queries uh are are centralized this means named queries allow you to store your query definition in one place either with an entity class or an external XML file this externalization simplifies query management and makes it easier to update and refactor the queries let me give you some specific examples when to use named queries in Spring data jpa application so first of all when you have complex queries that are used in multiple places throughout uh your application when you want to optimize performance for frequently executed queries when you want also to improve code readability and maintainability by separating query definitions from other application logic and finally when you need standard way of organizing and managing queries across your application so these are the use cases or some of the use cases of named queries and the definition also of a named query but you need to keep something important in mind while named queries offer uh several benefits it's it's important to note that they may not always be the best choice for every situation for example they might not be as flexible as Dynamic queries for example when we use Query DSL or criteria API also when it comes to building uh queries based on varying condition or user inputs it's essential to evaluate your specific use case and choose the appropriate approach for your application all right now let's move on and Implement our named query and let me show you how to do that to create a named query first of all you need to go to the entity or to the model where you want to create that query so here we have two options first of all we can use this annotation named query or we can also use named queries so we have two options okay also we have another one which is named native query or named native queries right here so you can also create native queries as named queries so for the this case let's move on and let's go ahead and create jpql named queries so first of all we will use a single one and I will show you how you can use this uh named query and then I will show you the use case or the usage of these named queries so first of all as I mentioned when using named query we need to give it a name and the name always think about having uh The Entity name or your model name dot the name of the named query so I will just say find by named query and then I would provide the query itself so let's say for example for this one I want to do select a from author a this is just the Adas where a. AG is greater than greater than or equal for example to the age I want to pass as a parameter so now I have named query which will fit all the authors by age where the age is greater or equal than a specific parameter so now in order to execute or to use this named query just go to your repository right here and now we want to execute this qu so it will be return a list of authors and then we have find by and as you can see enj is already proposing this one and also you see that the icon is slightly different from the from the Native one or from the predefined ones so here we have find by named query and also as you saw here we have its named query so all we need to do is to pass our parameter using the pram annotation and then age and then of course it's of type int so it's going to be int AG so that's it and here you see already the difference that we have this icon and when you click on it it will navigate as to the named query okay so now in order to use this one or to check it all you need to do is to go here to the jpa application and then after executing and updating and doing all that what I will do I will do list of authors equals repository. find by named query and here let's say for example I want to fetch all the users having or all the authors having an age greater or equal than this yeah so this one should be or should go inside and here it will be finded by named query and then I can can do for example for each system.out.println so I just want to print all the authors that will be here I guess we can also remove this one and now let's execute our application and let's see the output so here we see that we have all the authors and here we just forgot to remove this update because by this we updated all the authors and we set all the ages to 99 so it will retrieve all of them so now let's see and here we have a restricted list and as we can see here we have all the users where the age is 74 71 and so on so forth so for example if I change this one to 70 or 7 s something like that yeah okay and if we run again we will see that we have we will have or we will get a shorter list so you see that you have have only two with the age 71 and 70 all right so this is how we can create uh a named query let's move on and let me show you how we can create a list of named queries and how we can create another type of named queries now let's update data using named query so let's try to recreate the same uh query right here but using the name query so first of all I would just copy this one and then I will go back to the author and I will create another named query right here and then I will give it a name so the name will be author. update by named query and the query will be the one I just copied so here it will be update author set age where ID equals something but here I will just remove this ID and I want to update all the all the author authors so again I need to go back here so it will be a void update by named query and this one of course we need a parameter which is the age and then int H all right so let's double check so here we have a variable H so we need to pass it and this is what we did right here now let's go back after uh displaying all this data Now update with named query so all I need to do is my repository do update with name or by named query and here I will pass for example 12 as an age and I will execute the the application again and check what will happen so it seems that it did not work and now I guess and I'm pretty sure that you know why it did not work and the answer is so let me first show you the the exception failed to execute command Runner and here it says expecting a select query but we got an update so the answer is that is the one you already thinking about we need this modifying and of course we need The transactional annotation so even if it's a named query if it's an update query we need always to use this modifying so let's run again and check and now we see that we have this update and then if I open my table right here and I will see that all the ages now are 12 so that's it also before um before we move on to the next steps here you see or we mentioned already that we can use named query or this annotation named queries the difference between this named query and named queries actually there is no difference because if we go to the source code of this annotation we see that we have or we can pass a list list of named queries so it's just a way to organize our named queries so we can do something like that and we can move these named queries inside and that's it so this this is the only difference between the named queries and the named queries so you can whether have them separately or you can also group them within a list of named queries and nothing will change it will be always the same everything will will will remain the same all we need to do is just group them with named queries spring data jpa specification is a powerful and flexible feature provided by Spring data jpa framework that allows developers to create Dynamic and type safe queries using the jpa criteria API it enables you to build complex queries based on various criteria which can be combined and reused in different scenarios providing flexibility and maintainability in constructing queries and the core of the specification the core concept of spring data specification revolves around the specification interface which which is a functional interface with a single method so here we see in the source code that we have a bunch of static and default methods but the main method or the main uh important method is is this one predicate to predicate here the T represents the entity type on which the query is built and the pr two predicate method receives three arguments first of all we have the root right here which is the object that represents the root entity in the query from which you can navigate to other related entities and attributes and then we have a query which is a criteria query of a type uh interrogation Mark which can be any type which is an object that represents the overall query being built this can be used to modify the query structure and uh or add additional constraints finally we have the criteria Builder which is of type criteria Builder which is an object that acts as a factory for creating various cre elements like predicates extensions and orderings the two predicate method returns a predicate which is a Boolean expression representing the query condition now let's talk about how we can use this specification so to use a spring data specification you need first of all to extend uh your repository with this jpa specification executor interface which provides methods to perform queries using specifications the most common used methods are find all and find one you can also create Uh custom specifications in es by implementing the specification interface or by using Lambda expression so specifications can be combined using the end and the or method as we can see right here we have this end and we have this or also we have where and not these methods uh allow us to build complex queries dynamically in summary and overall spring data jpa specification is a feature that leverages the jpa criteria API to build Dynamic and typees safe queries for your application it provides a flexible and maintainable approach to construct queries based on various criteria which can be combined and reused throughout your application this approach is particularly used when dealing with complex queries that depend on user input or VAR B based on runtime conditions now let's move on to the action and let's implement our first specification query the first step is in implementing specifications is first of all you need to go to your repository where you have or where you extend your jpa uh the jpa repository also we need to extend the jpa specification executor so here we extend already um jpa repository I will also extend jpa specification executor and here we need to give it the same type author in here all right so now we have our repository ready to be used as a specification executor after extending the author repository we need to create a new class so I will create a new package here I will call it specification and then I will call or I will create a new class called it author specification and now within my author specification I will create two specifications or let's call them two predicates uh and these predicates they will filter for example my authors based on the first name and age so let's create the first one public static specification and my specification is of type author of course don't forget that and let's call this one has age for example and this going to be our first filter so in first of all it's going to be int Ag and then we need to return a Lambda expression so you know when the two predicate method that we checked before it takes root of type author let's call it root and then we have the criteria query and this one as we mentioned before it's going to be interrogation mark this is our query and we have our criteria Builder now let me just inline these variables so so you can see everything so here we have this the these are the parameters that we that we need as we explained before so we have our root of type author we have the criteria query and the criteria Builder so here what I want to do or like what we need to filter out is first of all if this age right here so for example this is just a check if uh it's less than zero so I will just return null because we know that we don't have any age or any person having a negative age otherwise I will return my criteria Builder dot equal and then I need to pass the expression so it's the root that holds the information of the entity do get and then I can pass the attribute name that I want to filter on which is age and then the age itself so here I'm ensuring that this method has age right here will add uh a criteria or will add specification that the age of the author right here this this variable or this field right here should be equal the age that we will pass as a parameter so just I need I need to remind you that what we are building right here is not the query itself but it's just or are just the filters that we want to um to use so for example uh I want to filter all the authors by age and the name containing or starts with okay so next one I will build a public static again it's a specification of author and then let's say first name contains or starts with and here I need to pass my first name and I will just copy paste this one so here if my first name is null so I need to return null otherwise here I want to do first name and here of course I need the parameter so as you know in SQL contains is not um we don't have such method called contains but we have a method called like so like I want to have this first name to be like the parameter that I want to pass so now we just built two uh specifications or two predicates the first one is has age and it will check that this author has an age that we will pass as a parameter and again we have this first name contain or let's maybe call it first name like to be more consistent with this method right here and this will check that the first name that we will pass as a parameter contains or is like the first name that we have in the database so now let's move on and let me show you how to use this specification class that we just created now let me show you how to execute a specification but first of all let's prepare a few things I will go to the application yaml and here instead of create drop I will make it just update because I want to have some persistent data and I want to check what we have in the database so this is the first one and then I will just uh keep this one for the first time I will execute the application and I will then just remove all this one so I don't I don't want to update uh the ages I don't want to find anything all I need is just to execute it for one time and make sure that I have some data gets persisted so here we see that we have all the inserts and if I check again my table we have the data inserted and then all I will do is comment this out and now I can stop the application and we can now implement or run our specification so in order to run the specification that we created first of all we need to create an object of type specification having a type author and let's call it spec or specification it's as you like I will use spec as a short name equals specification and then do where so this is our work close so the first filter of our work close is this one this author specification that we created so first of all I want to filter by age and first name okay so I want to get all the authors having the age equals something and first name equals something so here I can use author specification dot has age for example let's say 34 let's just imagine and so here we can use and or and or or or we can even pass another predicate but we can rely on and and or so let's say and also again I want to use my other specification and then first name like so for the first name I will again refresh this list and take for example this one okay so I want to fetch all the authors having the name for example starting with or containing this Mitch okay I will say Mi just Mi okay so then once we are done with creating or declaring our specification I will do my Repository do find all and then within the find all method I can now pass my specification as a parameter because our repository already extends or implements the uh jpa specification executor so here I will just do for each and then system.out do print Ln just to print out our result so let's click and draw the application and see what will happen so we see here first of all we have we have an exception and the first thing that we see in here that could not resolve attribute first name and let me show you why so this first name here we said that I want to have the first name like but let's check our author so the author it's first name with a capital N so this is important to have exactly the same thing all right so now I I will run again and check so here we see that we have the select but we don't have any result and you may wonder why I can tell you so when we use the keyword like when uh in the SQL when we use this keyword like we should always use like and then it should be like this so it should be percent percent and then our filter right here okay so this is what we are missing with the first name so we need to do something like this and then I will add percent in the beginning and percent at the end so we need to surround this first name the variable that we want to pass with a percent percent okay so whether we do it here or you can do it when you pass this parameter like this but it's better to put it in the in the specification because like means that we have something like this okay now let's run again and we still can't see our data let's first check uh the author so we have our Mitch right here and let's go back yeah but Mitch yes that was the the problem but Mitch is 22 years old and we don't have any other Mitch within the same age so now I will just change this one to 22 and run again the application so here we see that we have at least one one result which is this guy called Mitch Mitchell and so on so forth and having the age 22 so now for example I want to first to search only for um I want to search only for the authors that the age is 22 so I just can comment this out and run my application again or execute my query again and this one it will filter all the users that they are 22 years old or also I can do something else so here instead of and I can say or so find all the authors uh that are 22 years old or the name is like or contains Mi so let's run again and check the specification return type so here we see also that we have these two elements so this guy is 22 and we have the first one is Mitch and then we have this paita so for example also if I just let's just play a little bit with um with the variables that we pass and here I want to filter all the authors that the first name contains the letter I and as you can see here it's an i it's an i it's an i and so on so forth so this is how you can create Dynamic queries and also the best part of specifications is you can reuse all these methods that we created all these predicates or all these specifications are reusable and you can reuse them to create Dynamic queries okay so for example if you have a search or complicated or complex uh search query you can use specification in order to prepare and in order to create your query in advance
