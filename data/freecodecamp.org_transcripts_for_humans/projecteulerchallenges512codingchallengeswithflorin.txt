With timestamps:

00:41 - hello hello everyone and welcome to
00:44 - another live stream in which we're going
00:46 - to solve project Euler challenges using
00:51 - javascript for those of you who didn't
00:54 - join the first live stream we had I
00:56 - think two weeks ago we solve the first
00:59 - four problems using the free code camp
01:02 - platform and in this dream we're going
01:05 - to solve a couple more we'll see how it
01:08 - goes and how many we can solve if you
01:12 - join the live stream I can see close to
01:16 - 100 people being like say hi in the chat
01:18 - and yeah keep in mind that yeah I didn't
01:23 - prepare for this problem so well I don't
01:26 - have the solution I looked over to see
01:29 - how it looks and well how it works how
01:33 - it should work like a main idea but I
01:36 - didn't solve them and that's because I
01:38 - want to show you how how you can even
01:45 - fail when you start doing something you
01:47 - start coding on something and that's
01:50 - perfectly normal so yeah we're going to
01:54 - try and solve this on the first go and
01:58 - see how it goes for those of you who
02:01 - don't know me my name is Larry Popp I'm
02:03 - a developer from Romania I have a
02:05 - YouTube channel where you can find me
02:09 - live coding almost daily and I also
02:13 - upload different videos or you can
02:15 - follow me on Twitter if you want alright
02:19 - I see Quincy hello Quincy get so yeah I
02:25 - think you can hear me let me know in the
02:27 - chat and we can start with the problem
02:31 - number five the smallest multiple
02:35 - let's see what it requires smallest
02:40 - multiple 2520 is the smallest number
02:44 - that can be divided by each of the
02:47 - numbers from 1 to 10 without any
02:50 - reminder what is the smallest positive
02:52 - number that is evenly divisible by all
02:56 - of the numbers from 1 to n all right so
03:00 - we're having to deal with the divisible
03:05 - numbers
03:09 - okay
03:12 - yeah also as Quincy met Christmas and
03:16 - the chat for now is for members only if
03:21 - you want to enjoy the chat I haven't be
03:23 - able to chat with me and engage consider
03:27 - becoming a member you also support this
03:30 - awesome
03:31 - platform and help other developers learn
03:35 - how to code for free
03:37 - alright so let's see we need to figure
03:43 - out how well probably this one of the
03:50 - problems I wanted to solve today is the
03:53 - hardest and that's because well we could
04:01 - go so we need to get all the numbers
04:04 - from one to add and then we need to find
04:07 - the smallest number which can be divided
04:12 - by each of these numbers right now this
04:16 - could be trickier we could just start
04:19 - and multiply 1 + 1 with 2 + 3 + 4 up to
04:23 - n but then we'll get a very high number
04:26 - and that's not the smallest number
04:29 - possible I know that there is a function
04:34 - but I knew about it but I kind of forgot
04:38 - in which you could check for you could
04:45 - have two numbers and check which is the
04:47 - lowest column multiplier let's let's go
04:50 - the latency lowest common divisor
04:59 - ya think ya LCD I think for not
05:05 - denominator let's see
05:08 - to do to do
05:13 - or so this could be one approach to use
05:18 - this function although it can see it now
05:19 - or we can go the brute-force and start
05:24 - with a number well actually let's do
05:26 - that we're going to have one number to
05:29 - start with and we're going to increase
05:32 - this number and check for every number
05:36 - if it's divisible by all the numbers
05:38 - from 1 to n and I guess the starting
05:40 - number could be n hey kattiline welcome
05:43 - to the live stream how are you okay and
05:48 - now we kind of need another function to
05:52 - check Thank You kattiline to check if
05:57 - the number we're going to give it is
05:59 - divisible by all the numbers so let's
06:02 - write check the Visser's and we'll get
06:06 - the number and the desserts oh this is
06:12 - kind of interesting it as well these
06:15 - divisors will be also number we're going
06:17 - to loop or alright let's go with this
06:22 - and then we can slowly improve the
06:24 - function so here we're going to go from
06:28 - let I be dessert well it should be I 1
06:35 - then it will go less than pickles to the
06:39 - number the divisor Haitian thank you for
06:47 - the super chat well thank you on behalf
06:51 - of Rico camp obviously alright so let's
06:54 - see here I don't like the names here so
07:01 - maybe number two check and number all
07:07 - right so let's do this and here we can
07:12 - check if kattiline thank you for the
07:16 - super chat ok so if our number well i
07:24 - modulus number two check
07:28 - [Music]
07:30 - so if this is different than zero so
07:38 - that means it's not divisible then we
07:41 - want return false right so think about
07:44 - this we're going to start with a number
07:47 - which will be the biggest number here
07:51 - well yeah okay let's let's Candide
07:58 - itself we're going to take for example a
08:02 - let's write examples here will be easier
08:05 - to explain so we have the numbers from 1
08:08 - to 10 right and we need to find lowest
08:11 - well the smallest multiply for
08:17 - but well the smallest number that can be
08:19 - divided by all these numbers right which
08:22 - we know that is 2520 and what time we're
08:28 - going to do here is we're going to start
08:30 - with them start with 10 and then we're
08:34 - slowing slowly going to go up 10 11 12
08:38 - 13 14 and we're going to check all of
08:40 - these numbers if they are divisible by
08:42 - all the numbers from 1 to 10
08:44 - hopefully that makes sense let me know
08:46 - it'll chat if it does or if it does it
08:49 - all right so that's what we're going to
08:51 - do here we're going to have a while look
08:59 - not sorry for the wire loop should be
09:01 - the best way to go we might get an
09:03 - infinite loop but well let's let's try
09:05 - for now yeah say they say that an
09:10 - infinite loop but actually we could have
09:14 - a boolean found be false and while not
09:19 - found
09:22 - we can Oh also we need to work we're
09:26 - going to use a start so while not found
09:30 - we're going to check the results we're
09:35 - going to pax the number two chapel which
09:37 - will be the start or what them start
09:40 - again not a good name
09:42 - so that's right number to check alright
09:49 - so we're going to check the number to
09:50 - check and we're going to pass in the app
09:54 - which will be our number then here
09:57 - infinite loop hype if this returns true
10:07 - then we want to well found be true so
10:11 - we're setting found to be true well
10:14 - again it says that we have an infinite
10:17 - loop like don't know if this is the best
10:21 - approach that well let's see how it is
10:24 - as a set this is proud of the hardness
10:28 - of the ones forget to do today so let's
10:31 - see again we have the number to check
10:33 - starting with the highest one all right
10:38 - then we're going to pass in the number
10:41 - to check oh and here we wanted the
10:44 - number to check plus plus right we want
10:47 - to increase the number and at the end
10:49 - we're going to return this
10:52 - okay so we're capping the number we're
10:56 - checking for divisors
10:58 - if it's divisible by all of these
11:01 - numbers well here we need to return true
11:05 - if it doesn't find a number which is not
11:08 - visible then should be true
11:11 - okay and
11:15 - yet this should probably work although
11:19 - let's check
11:22 - it might run my timeout yeah so
11:28 - something is not okay
11:33 - yes
11:38 - yes if you're in the live chat if you
11:41 - have an 80 feel free to suggest okay
11:47 - let's think again
11:49 - well this check divisor work so
11:54 - we have I 1 I less the number I plus
11:56 - plus okay so we get the numbers from 1
11:58 - to 10 for example if we have the number
12:01 - 10 okay well you know what
12:05 - [Music]
12:11 - let me see so we need to check all the
12:12 - numbers okay number to check
12:22 - oh my bass the number to check has to be
12:25 - divisible by I right yeah kinda messed
12:31 - it up there
12:33 - okay let's also cancel that vlog Ness to
12:38 - see what we get okay number two check 30
12:42 - which is yet so we're passing 20 we need
12:45 - to check out numbers from 1 to 20 all
12:47 - right and here we're saving it to the
12:50 - number to check now let's see if the
12:52 - while look while loop works
12:58 - okay so we get this number
13:01 - which is not what we wanted
13:08 - what is that isn't it
13:14 - check modulus I do different and Sarah
13:18 - so it's not
13:28 - okay what we get for five
13:35 - 60 we get 61 alright good good good good
13:39 - good so we're kind of closer here we get
13:45 - 61 because we increment here once again
13:48 - so we kind of want to do it here
13:56 - all right yet so now we know at least
13:58 - one test will work if we don't have well
14:03 - that's nice I didn't expect this to be
14:08 - honest
14:09 - so apparently all of them work now yes
14:14 - this is the life of a programmer it
14:18 - works and you don't always know why but
14:20 - yeah you have a nice goal there
14:26 - kattiline okay so could we improve this
14:31 - should we try to improve this or we
14:34 - should just leave it yeah so we're kind
14:41 - of checking all the numbers which is not
14:45 - powers oh yeah I think that number to
14:48 - check which we did there good thing
14:51 - number to check should be here although
14:55 - now if we have a number like 2
15:03 - save for and that's not good right
15:07 - because we're starting with this number
15:09 - but then we increment in the wire loop
15:11 - so I kind of want to do n minus so one
15:15 - okay so now we get to sorry so yeah what
15:23 - about three three won't work for for for
15:28 - we should get let's see not six not
15:33 - eight probably twelve oh look at that
15:36 - yeah stuff so yeah this works now my
15:40 - trophy all right so let's run this let's
15:44 - submit and go to the next one which
15:45 - hopefully will be easier we did it the
15:50 - brute force way which is not well always
15:53 - the best solution but if you don't have
15:55 - another solution it should work
15:57 - all right problem six sum square
16:00 - difference the sum of the squares of the
16:02 - first ten natural number is three
16:05 - hundred and eighty five the square of
16:08 - the sum of the first 10 utter number is
16:11 - three thousand twenty-five hence the
16:16 - difference between the sum of the
16:17 - squares of the first ten at your number
16:19 - and the seventh and the square of the
16:22 - sum is that number all right find the
16:27 - difference between the sum of the
16:28 - squares for the first and natural
16:30 - numbers and the sum of and the square of
16:32 - the sum that's interesting there yet so
16:36 - yeah basically again we need to take all
16:40 - the numbers from one to ten or well one
16:43 - to n we need to add them up and then
16:47 - raise them to the power of two or we
16:50 - need to raise them individual to the
16:52 - power of two and then add them up and
16:53 - the result of these two well we need to
16:56 - subtract so yeah this shouldn't be that
17:00 - hard now
17:04 - okay let me see
17:07 - I could oh yeah that's better
17:14 - so let's create two functions one will
17:17 - create the square of the sum and when we
17:20 - create the sum of the squares so
17:23 - function square square of sums sum K and
17:34 - function sum of squares okay get and
17:41 - both of them receive and
17:47 - we could create an array and use map and
17:51 - the reducer yeah I'm kind of complicated
17:54 - over complicated now let me also add
17:56 - console clock here so we can see what we
17:59 - get
18:00 - all right so we need the sum of the so
18:06 - the square of the sum minus the sum of
18:09 - the squares let's go hear some once more
18:18 - so square of some square of sum of n
18:23 - minus sum of squares of that
18:27 - alright not a number yet now here well
18:31 - for one we need left I equals zero
18:35 - well I equals 1 I less than equals and I
18:38 - plus plus and square of some yeah we're
18:44 - going to have a sum which will be 0 and
18:47 - then sound plus equals I so we're
18:50 - getting all the numbers there and then
18:52 - we're returning some for now in this
18:55 - square of sum so we can do
18:59 - either met that power some until let me
19:05 - return here one so we can see something
19:07 - in the console or we can do I think this
19:11 - is a newer thing never used well it
19:14 - didn't really use it we can do this
19:16 - which is pretty much the same thing but
19:18 - yeah this is more obvious that we're
19:20 - raising the Sam ^ - good now for the
19:25 - next one well we're having pretty much
19:28 - the same thing but instead of adding so
19:34 - let's remember the sum instead of adding
19:37 - I here we're going to add map that POW i
19:42 - ^ - so we're squaring the numbers and
19:47 - yeah this should yeah it looks like it
19:51 - works for 100 this should work it's
19:56 - brute force I'm not sure if you can do
19:58 - it
19:59 - other way
20:03 - I know there is a formula for adding the
20:07 - numbers I've learned that in high school
20:09 - song time for adding the numbers from 1
20:12 - to N it was something like let's see if
20:17 - I remember so n times n plus 1 divided
20:24 - by 2 so this should be the total and
20:32 - here we can do whoa wait wait wait not
20:36 - here this will work here because we're
20:38 - having the sum
20:43 - yeah oh not n times n plus one like this
20:49 - see so this works basically I remember
20:53 - that for the numbers from 1 to 10 it was
20:55 - like 55 so yeah this is the formula and
21:00 - well we don't have to do the loop which
21:04 - is good we saved some time here we can
21:07 - also put this
21:10 - here well let's leave it there we can
21:15 - use cops because we're not reeling yet
21:18 - now about days let's search a square sum
21:28 - of square formula sum of squares formula
21:33 - why not let's learn something new today
21:38 - k n n plus 1 and 2 n plus 1/6 all right
21:48 - thank you google so this is the formula
21:55 - let's use this so we kind of don't have
22:00 - taste here and this will be two times
22:06 - and all right let's return this
22:13 - and here this
22:17 - and is not oh oh sorry so and it's not
22:21 - the function we need to multiply there
22:24 - and here also alright so yeah this is I
22:29 - think this is now the more cleaner way
22:35 - it should say I was doing this we're
22:38 - using formulas instead of looping over
22:40 - which is pretty good it's way way faster
22:46 - this way because we're just multiplying
22:48 - instead of looping because if we had a
22:51 - big big big number
22:53 - well then would have some problems there
22:56 - all right
22:57 - so yeah let's submit this and go to the
23:00 - next one
23:05 - seven ten thousand one 10,000 first
23:09 - Prime I think by listing the first six
23:14 - prime numbers 2 3 5 7 11 and 13 we can
23:18 - see that the sixth prime is 13 again
23:22 - what is the nth prime nice
23:28 - prime numbers
23:30 - [Music]
23:35 - okay let's see so first what we could do
23:40 - again the brute force method
23:46 - and go over all the numbers from 1 to X
23:51 - well this case is M but we want the end
23:54 - pride we don't want to go up to end like
23:57 - we had before so we can start again and
24:03 - check all the primes get the primes and
24:06 - store them inside an array and when we
24:11 - get to an array of length of n we're
24:16 - going to output the last one
24:20 - this is the first idea I had let's see
24:24 - if that works although this is again the
24:27 - brute force but maybe we could improve
24:30 - it afterwards now let's see so we're
24:35 - going to need left number which will
24:40 - start from let's so two is the first
24:43 - prime number good
24:45 - and let Prime's will be an array and I'm
24:51 - going to put a number inside because
24:53 - while two is already a prime all right
24:57 - while this could be a Const because
24:58 - we're pushing to it okay
25:03 - let's see and here what we can already
25:06 - do Prime's
25:07 - that pop because pop sounds nice and
25:10 - well it will return the last one and
25:12 - this is what we want what's the end
25:14 - prime okay and we can do a while loop
25:18 - while Prime's that length is less than n
25:24 - so while we don't have the primes we
25:27 - want to well push to the primes so
25:29 - Prime's that push on the next prime
25:33 - number
25:35 - mm-hmm okay let's think here
25:40 - Oh
25:42 - we get Prime so we could loop
25:46 - and find primes
25:52 - mmm
25:55 - let's do that so we're going to well we
25:59 - have the number there right the starting
26:01 - number
26:04 - and here we can do a check of it if it's
26:07 - a prime if is prime the number then we
26:11 - want to push the primes array okay I
26:15 - guess then we can remove it from here
26:20 - because automatic it automatically two
26:23 - will be added at the end here we're
26:25 - going to do number plus plus
26:28 - and we kind of just need a prime is
26:31 - prime functional so how do we check if
26:34 - the number is prime well a function
26:40 - yeah there is a thing I'm I'm thinking
26:43 - now we could do to improve because only
26:47 - 2 is 2 is the only prime number which is
26:52 - an even number all the rest are odd
26:56 - numbers yeah
26:58 - English samples so we killed two numbers
27:04 - plus equal to
27:10 - just so we can save half after loops
27:14 - loops count so let's do that we're going
27:17 - to push to here and we're going to start
27:20 - from three so now we don't check for all
27:23 - the numbers we just check for the odd
27:25 - ones okay good so that's an improvement
27:29 - it will also probably not work for well
27:35 - it will probably timeout you know it
27:38 - depends on how long it will take yet so
27:40 - is prime let's write another function
27:43 - which you're taking a number and it will
27:45 - return if it's pride so return through
27:48 - here by default we're going to assume
27:51 - it's prime and here we're going to do a
27:54 - check so we need to start
27:58 - from two
28:02 - let's go up to the number I plus plus
28:08 - and here we want to check
28:15 - mm-hm so let's see we're going to start
28:18 - with three it will check the division so
28:21 - if number modulus I will be 0 then
28:27 - return false
28:30 - because the number one number is prime
28:32 - if only is divisible by 1 and itself
28:35 - right so we don't want to go up to the
28:38 - number very well inclusive the number
28:41 - okay and we check so we go here and we
28:44 - check is it divisible by 2 with 0
28:47 - reminder if it is then well it's not a
28:50 - prime then we go up one more if it's
28:53 - divisible by 3 and so on and so forth
28:57 - okay we again have a potential infinite
29:01 - loop
29:03 - but this should work now so we're
29:05 - checking if it's a prime if it is well
29:09 - we push it here in the primes array and
29:13 - when the primes rate length is equal to
29:17 - n we we get the end right let's see what
29:21 - we get
29:23 - let me console that love this okay so
29:30 - for that we get that number which is not
29:32 - correct
29:37 - let's see what we have in the primes
29:39 - array
29:43 - okay so two three five seven eleven
29:46 - thirteen seventeen okay this looks it
29:49 - looks like we have the prime numbers
29:53 - well let me use it for six
29:59 - kay
30:02 - so if you do pop here what happened we
30:05 - have 30
30:06 - which is good let's see for 10 we get 29
30:12 - the last yes for 100 we get 541
30:21 - thousand
30:24 - let's dip up here again
30:29 - okay
30:30 - so somewhere around there it fails let's
30:35 - learn the test and see what we get
30:40 - now that's weird
30:47 - why did you get that
30:53 - you know what it did it
30:58 - let's see again for 2001 we should get
31:02 - that number but we get this that's
31:07 - interesting
31:08 - might be something here
31:13 - yeah so it kind of stops in a in this
31:19 - terminal or whatever it is but it works
31:23 - murder while we're running the test okay
31:30 - [Music]
31:34 - there are a couple of things well a
31:36 - couple I have one idea which we could
31:39 - improve you can see here that we're also
31:41 - going again over all the numbers which
31:45 - is not a key we also need to do
31:48 - something like we did here
31:49 - to skip well at least we could to skip
31:55 - every two numbers so we could do here if
31:58 - number modules 2 is 0 then return false
32:04 - this is for the base condition that 2
32:07 - and then here we could start with 3 and
32:10 - [Music]
32:14 - oh wait
32:16 - no no I'm wrong here so yeah we need to
32:19 - go over our lumbers because we could get
32:22 - a number and CV
32:27 - happen here
32:30 - we won't check for even numbers right so
32:34 - there's no way in trying to
32:38 - to check with another even number okay
32:41 - so yeah that should work well let's see
32:44 - so this is what I wanted to save more
32:49 - more loops here let's this
32:56 - okay
32:59 - yeah although it took more time which is
33:03 - odd
33:05 - but at least here you can see here we
33:07 - now got the number so it's it's faster
33:12 - okay and I think we also don't need to
33:16 - go up to the number we can go up to the
33:18 - square root we did it the last time
33:25 - but I forgot again so let's see ya know
33:29 - again up to the square root
33:32 - yeah so that works also we don't go up
33:36 - to the number but up to the square root
33:37 - so we save even more more loops all
33:41 - right so I think that's it for this one
33:48 - let's go to the next one
33:52 - can we stay
33:54 - we have 1% complete
34:03 - that's my later place okay problem eight
34:06 - largest product in a series the four
34:11 - adjacent digits in the 1000 digits
34:14 - number that we have the greatest product
34:18 - are nine times nine times eight times
34:20 - nine
34:22 - large production series okay so we have
34:25 - this big number and we need to find the
34:31 - and adjacent digits in the 1000 digits
34:35 - number that have the greatest product
34:38 - what is the value of this product
34:41 - all right so yeah we're getting a number
34:45 - and we need to find a number
34:51 - when
34:52 - to find a number which is n digits and
34:55 - it digits is the highest product Thank
35:02 - You Quincey I think for supporting the
35:06 - organization yeah she'd done it well I
35:11 - am a member on YouTube so see I think I
35:15 - have
35:20 - they had the emoji but I don't have it I
35:23 - don't see no never works okay so what we
35:29 - need to do we have this array which they
35:33 - provided for us thank you
35:36 - which is good because it's already an
35:38 - array so we can work with the numbers
35:40 - and if we have a number of lengths
35:44 - well if then and here is for window
35:47 - check this for store the product then
35:52 - check this for check the product is
35:56 - bigger than the previous product and so
35:58 - on and so forth up to
36:04 - Yeah right
36:06 - okay we need to get those ohms if we
36:10 - have five numbers we need to check like
36:12 - five numbers every times so we can do
36:18 - that using well we again need to go over
36:21 - all these numbers right so all these
36:24 - numbers and get the pair of four five or
36:27 - six numbers or how many they are we can
36:31 - do that using the slice method we can
36:35 - start from the index and get
36:40 - yes the slice or the splice method but
36:42 - the splice will change this array so let
36:46 - me first move this from here I'm going
36:50 - to create it here comes tiles and digits
36:54 - okay so we have we have a room here next
36:58 - up we want to create a loop which will
37:01 - go over basically all these digits right
37:05 - don't worry kattiline I know it's a joke
37:08 - okay so it goes over all the digits it
37:11 - will get the pair's and check the next
37:14 - one and so on and so forth so well
37:16 - what's the data for let is 0 I less than
37:19 - and for now but we're going to change
37:23 - this and I plus plus get and here take
37:30 - the pair it's not a pair how they call
37:34 - ends multiple take the series sirree
37:37 - ever and check the product here we're
37:44 - going to store the maximum product so
37:47 - max product will be the lowest number
37:52 - possible so yeah let's put 0 we're going
37:55 - to check if
38:00 - [Music]
38:03 - series product
38:07 - is great
38:09 - than Max product then we want to do max
38:12 - product be equal to serious product okay
38:18 - this is the function we are going to
38:19 - create okay good now because we're
38:23 - calling it twice well let's move it out
38:26 - in a variable so comest product will be
38:29 - series product and here we're going to
38:32 - test in an array with all the numbers we
38:35 - want
38:39 - okay get and at the end we're going to
38:43 - return the max product let's console.log
38:46 - it again all right now the only thing
38:51 - it's left oh we are left to do is to
38:54 - create this array so we want to get n
38:57 - numbers at a time so starting with the
39:01 - index we can do that by let's see so
39:05 - have this array let's write it here
39:09 - array will be this
39:11 - that's slice slice needs the index on
39:15 - which you want to start so it will be I
39:16 - and the second index the second argument
39:22 - will be our parameter will be
39:28 - you want to end but not inclusive so we
39:32 - want to do i+ n so let's see if we start
39:36 - this will be zero we if we do I plus and
39:39 - which is five we're going to up to five
39:44 - but not inclusive so we want we
39:46 - basically want to get all these right
39:48 - seven three one six seven and slice will
39:53 - give us this four because it goes up to
39:57 - so we can do I plus and plus one and now
40:02 - it will take all the five in the next
40:05 - loop it will start from this one and
40:06 - take all the five and then this one is
40:09 - so on and so forth we're going to pass
40:11 - this to our cities product yeah
40:16 - let's write it here like another
40:18 - function but then afterwards we'd like
40:22 - to write it in line so function series
40:25 - product will get an array and we want to
40:29 - do the product of all the numbers we can
40:32 - do that using reduce so hooray that
40:35 - reduce which gets an accumulator we're
40:38 - going to store the product in this
40:39 - accumulator and we have the number and
40:43 - we want to return here accumulator x
40:47 - equals to the number and the initial
40:50 - value should be what okay
40:56 - thousand digits oh yeah it's a Const it
41:01 - doesn't see now this because it's a
41:04 - constant it's down there all right all
41:07 - right let's put it up
41:11 - you
41:18 - all right good
41:26 - now Casey the X product arrey arrey
41:28 - juice accumulator commit x number this
41:32 - should work we create a new array now
41:38 - again the last thing wanted to check so
41:42 - basically now we're going up to M so
41:45 - this one but after this we don't have
41:48 - five five numbers so we could go up to n
41:52 - minus o this
41:56 - up to am sorry not up to end my bad my
41:59 - bad we need to go up to thousand digits
42:03 - not length the length of this and we can
42:09 - subtract the head so not the last ones
42:13 - let's see this works like that
42:17 - all right yes so definitely networks now
42:20 - let's see for for what we get so he had
42:24 - that number
42:27 - now the bad part is that we can't really
42:30 - really debug this it's the long list so
42:37 - let's see we have this array we have the
42:41 - Max product start with zero we return
42:43 - the max product that's fine
42:45 - here we're going over all the numbers
42:50 - sorry we're going over yeah the digits
42:54 - and we're slicing the digits we need
43:01 - thank you can see yeah I hope people
43:04 - enjoy so we're slicing from i to i plus
43:11 - n plus one so the length plus one
43:13 - because it doesn't go to the end good
43:16 - now here something happened
43:21 - [Music]
43:23 - we're going to the length up to the
43:25 - length minus n minus 5 well basically we
43:30 - want to check the the fort well if we
43:34 - check the last 5
43:37 - we want to go up to this number right so
43:41 - it's minus n this is n plus 1 oh we need
43:46 - to check this and with the with his
43:49 - friends so plus 1 ok but we still don't
43:54 - get a correct number or do we know you
43:57 - know yet next we have this product which
44:01 - is a radius let's
44:08 - and thinking how can we test this
44:16 - because if well if we
44:17 - here comes something I counted a lot
44:20 - product just so we can see we get a lot
44:22 - of hammers
44:25 - well I guess
44:31 - we try deleting these or you know what
44:36 - let's comment this out and let's write
44:40 - again just with a couple of number so we
44:43 - can check what happens all right so we
44:46 - have one two three four five six numbers
44:49 - and we want to check let's see the pair
44:53 - of three now let's let's leave it for so
44:57 - basically these four or these four or
45:01 - these four are the largest now we kind
45:07 - of need to see what we get the product
45:09 - so consume the lock product and let's
45:14 - also the product let's also see the
45:17 - array
45:20 - okay so we see that we already have some
45:23 - issue here
45:29 - we get five numbers and we only need
45:31 - four
45:35 - so +5 oh yeah so my bad here we don't
45:43 - have +1
45:47 - logic was correct but the implementation
45:48 - was wrong so if we start here this is I
45:55 - + 1 + 5 so 1 2 3 4 5 but then we added
46:02 - one more yeah so this already goes up to
46:06 - the number we want plus 1 all right
46:10 - my bad good so this should work now
46:14 - hopefully
46:16 - well yeah let's see so we get these
46:19 - numbers and we get it the maximum to be
46:22 - 126 and also you can see how nicely we
46:26 - get all the pairs here if we add in one
46:29 - more number here like nine we always get
46:32 - an array of four numbers which is
46:34 - perfect alright let's come and this out
46:38 - let's remove this and look at that we
46:43 - have the number 5832 let's run this and
46:48 - yeah and we got to 2% awesome now what
46:56 - could we improve if we could improve
46:58 - something one thing would be well I
47:01 - created this function but we kind of
47:04 - hailer and how are you welcome we kind
47:12 - of kept well we could do this here right
47:14 - it's just a function calling reduce so
47:18 - we can do that there all right but other
47:21 - than that I don't really see how we
47:27 - could improve it
47:32 - the well we're working with this the way
47:36 - should think about how to improve it is
47:38 - when you have a loop right you want to
47:41 - see if you could somehow not have a loop
47:44 - or have less iterations
47:52 - but I think for this one should be fine
47:55 - you wish you could cope with it okay I
47:59 - think you can't cut yeah so we kinda
48:06 - need to go over all the numbers I don't
48:08 - think we can cheat somehow I don't
48:11 - really think
48:13 - oh yeah I think this is the proach maybe
48:17 - someone can find something even better
48:19 - but I can't for now all right let's run
48:24 - this and submit and there we go vii
48:28 - done twelve eight really when did we
48:32 - start to date all right let's go to the
48:36 - ninth then all right let's drink some
48:40 - water
48:41 - we need to be a bit of a break
48:52 - good ix problem special Pythagorean
48:57 - triplet hopefully I pronounced that
49:00 - right a Pythagorean triplet is a set of
49:05 - three natural numbers sorry a less than
49:11 - B less than C for which a squared plus B
49:14 - squared equals C squared yeah yeah this
49:19 - is another math heavy problem so for
49:24 - example 3 squared plus 4 squared is 9
49:28 - plus 16 which is 25 which is 5 squared
49:32 - so this is a Pythagorean well 3 4 & 5
49:36 - it's called the Pythagorean Pythagorean
49:40 - triplet there exists exactly one
49:46 - Pythagorean triplets for which a plus B
49:49 - plus C equals 1000 find the product a B
49:54 - C such that a plus B plus C equals 10
50:01 - okay
50:04 - uh what
50:12 - we need three numbers which are
50:16 - Pythagorean triplets well part of my
50:20 - Tiger paper Pythagorean triple I'm going
50:23 - to mess this up row saying by Pythagoras
50:30 - and when we find them we need to check
50:34 - if there's some equals two
50:44 - and then we need to multiply them
50:48 - I'm not sure did I understood this
50:51 - correctly
50:55 - [Music]
50:58 - so there exists exactly one triplet for
51:02 - which a plus B plus equals a thousand
51:05 - okay
51:06 - find the product a B C such that oh yes
51:10 - so the product a B C this is a product
51:12 - okay such that a B C equals that
51:18 - ABC equals 24 the product should be 480
51:30 - oh okay so ABC
51:33 - here we have a square B Square C square
51:34 - oh okay yeah
51:38 - couple things to check
51:43 - mmm
51:48 - here we have a plus B plus C will be
51:51 - let's see 3 plus 4 plus 5 9 12 okay what
51:56 - would be 424
52:01 - now I think the way we could do this is
52:04 - to I have three loops in mind like two
52:10 - inner loops one going from for a one for
52:14 - B 1 for C and then for C going up to a
52:17 - number yeah Thank You kattiline have a
52:26 - good day now
52:30 - yeah I'm not but thanks
52:38 - let's see so I'm going to write
52:41 - something just so we have a starting
52:43 - point for left I not I a equals one a
52:52 - less then
52:56 - something ABM what I said eh but I wrote
53:03 - I ate nah I plus plus all right and here
53:09 - well let's go for B and C
53:13 - B and C now B has to we have hit this
53:19 - condition here so B has to be one bigger
53:22 - than a at least and see one bigger than
53:26 - B at least so we can do here B equals a
53:34 - plus one and C equals B plus one all
53:39 - right now we need to check if there are
53:41 - Pythagorean triplets of if is triplet
53:47 - ABC if it is
53:53 - we need to check its SAP and if we find
53:56 - the sum we can return there
53:59 - [Music]
54:03 - find the sum to be close to this number
54:05 - then we can return the product so let's
54:08 - see if it's a triplet and
54:16 - a plus B plus C equals M
54:23 - right
54:26 - but this year then we want to return a
54:29 - times B times e okay this is not
54:36 - some of ABC yeah that's provided add it
54:39 - there and we don't need this so we kind
54:44 - of do everything in these slopes
54:45 - although I don't know if it's the best
54:48 - way but yeah so we go up to the number
54:52 - now again we go up to the number but we
54:54 - probably shouldn't because well the
54:56 - number in this case will be 24 but we
54:59 - kind of need the sum to be 24 so it's
55:05 - obviously that three numbers which are
55:09 - greater than each other
55:13 - they can't add up we can't all go to 24
55:17 - so yeah but that's not just one we can
55:22 - fix later now let's create this is
55:25 - triplet functions function is triplet we
55:30 - get ABC and let's see so we need to
55:33 - check if a squared plus B squared equals
55:35 - C squared
55:36 - the third a squared plus B squared
55:42 - equals C squared
55:49 - look
55:53 - yeah it shouldn't be if it looked not
55:55 - sure why they said that
56:02 - we are not reassigning see so yeah
56:06 - should be good let's see castle that
56:08 - love this although this is not undefined
56:13 - okay
56:17 - so a list and
56:22 - if is triplet and if the the some damn
56:27 - otherwise let's retired one here just
56:33 - okay let's check for 24
56:39 - what
56:40 - and compute see out of a and B
56:44 - what to mean
56:46 - okay so for 24 we get the number
56:51 - she's good now for 120
56:58 - we get this number and 4,000
57:07 - hello pression welcome welcome to
57:13 - support a roll
57:20 - so you saw that it works for 24 and 120
57:24 - although they say this or this or this
57:26 - but now for a thousand yeah test timeout
57:32 - because well
57:35 - uhh
57:40 - you can compute the out of a and B
57:45 - I feel like you have something there so
57:49 - we don't need to go another loop and I
57:51 - kind of have an idea of what you're
57:53 - trying to say let's see so definitely
57:57 - this doesn't work because we have a loop
57:59 - of 1000 and 1000 and 1000 so that's a
58:03 - lot of thousands but as you said
58:10 - can compare to see out of AMV
58:15 - yeah yeah yes yes yeah so C will be a
58:24 - and minus B minus a right that's what
58:30 - you mean
58:32 - so then we don't need this look so then
58:35 - we're pretty fast and look at that that
58:38 - solved it
58:39 - thank you aren't I well I couldn't have
58:44 - done it without you yes so we don't need
58:49 - to look for see because we can find out
58:51 - what si si is by doing the subtraction
58:56 - right because we know a we know B we
58:59 - know ed yeah thanks that's really good
59:04 - please stay around I need your help
59:08 - all right it's pretty good and I think
59:11 - now they're passing the test Oh such a
59:13 - good feeling but yeah let's think I
59:19 - don't like the fact that we're going up
59:22 - to n right because well definitely don't
59:25 - need to check for a to B and at anytime
59:32 - it could go up to at most and - - right
59:38 - so see could be now no definitely not
59:44 - but how so if we have a sum of three
59:48 - numbers b24
59:52 - what's the lowest take well the highest
59:55 - a can go it can be something like
60:02 - yeah I couldn't eat out you gave me this
60:07 - idea it was very good
60:12 - so if you have three numbers adding up
60:14 - to a number
60:16 - how can we check what's the maximum
60:20 - value to that so it could be for 24 so
60:25 - we have ABC equals 24
60:27 - it could be 23 but then B and C well it
60:33 - couldn't be 23 or 22 because C B and C
60:39 - needs to be higher so definitely the sum
60:42 - couldn't be 24 then it could be half no
60:48 - way because if it's half then B is
60:51 - bigger than the half and C is even
60:55 - bigger so again we don't need to go up
60:57 - to n if not even up to half of it this
61:02 - will still work also be doesn't go
61:05 - doesn't need to go up to half of n again
61:09 - of the same principle right so have
61:12 - three numbers there's some is 24 yeah I
61:16 - think here we already saved a lot of
61:18 - loops but I still need to see could we
61:21 - find out how much they can go I think
61:29 - twenty four three numbers so definitely
61:32 - well if we divide by three because we
61:35 - have three numbers then yeah that's
61:39 - that's an idea so yeah and talking too
61:44 - much now let's write something so we
61:46 - have 24 this could be something like
61:49 - seven plus eight plus nine the most
61:52 - right because 24 divided 24 divided by
61:59 - three blah blah blah and here we get
62:03 - this so a could go up two and divide it
62:08 - by three minus one
62:13 - and this could go and divide by three
62:15 - like that
62:19 - up to okay so up to
62:25 - we broke
62:33 - why this could be a divided by 3 minus 1
62:39 - K B and C could be at most third part
62:44 - plus 1
62:49 - we broke it somewhere let's see for 24
62:53 - still works yeah for 120 okay so here
63:00 - doesn't oh this is the correct answer
63:05 - I taught it's forty nine thousand nine
63:08 - hundred and twenty
63:13 - or its dalda the tree yeah I'm kind of
63:16 - spending a lot of time on this one but I
63:18 - want to see if we could find the best
63:22 - approach
63:27 - it is the square root
63:32 - I don't follow that buddy don't follow
63:40 - only have a problem we turn a thousand
63:42 - which gives us one so it doesn't find a
63:46 - triplet
63:51 - so we broke it once we set here divided
63:55 - by three
64:06 - trying some random numbers not to say
64:08 - yeah so apparently it's not divided by
64:11 - three
64:15 - well you know what be good
64:20 - could be pretty big
64:25 - I made a mistake so this is for a it
64:28 - could be at most seven but then B could
64:32 - be something like
64:36 - square root Oh
64:45 - and that
64:48 - or a triplet check right so this is 4a
64:51 - and 4b we need to see the maximum so we
64:56 - kinda could do a b1
65:00 - I equal 1 then be equal to and that
65:05 - leaves us two Oh No
65:09 - so B could be
65:17 - that's Tess so half 11 I think and then
65:22 - C could be tough right
65:28 - they need to be they always need to be
65:30 - bigger than it well see bigger than baby
65:31 - bigger than a so it could go up to 11
65:37 - which is half yeah that was my my
65:43 - mistake
65:44 - so a can go bigger than seven which is
65:47 - 1/3 well one less than the third and B
65:52 - can go up with more than half I'll also
65:57 - have minus one here Anna I think if you
66:04 - put two here it will it will still work
66:06 - in this case but might break in other
66:08 - cases let's see yeah so what I wanted to
66:13 - do is here is to find to improve this to
66:17 - make it as fast as possible who knows
66:21 - maybe there are even better ways to
66:23 - check it to do it so we are here
66:27 - undefined
66:28 - well which is by default so we can even
66:31 - remove these
66:33 - all right good let's go to the next one
66:37 - we spent way more time to this problem
66:42 - ten summation of primes primes again all
66:47 - right
66:47 - the sum of the primes below 10 is 17
66:52 - find the sum of all the primes below and
66:56 - okay this doesn't seem that we'll look
67:01 - at this it is a big number we definitely
67:06 - need
67:09 - we need to improve this might be a
67:12 - timeout if you do the brute-force but
67:14 - let's start with the brute force so
67:16 - again we need to have a function which
67:18 - will check if it's Prime let me write it
67:23 - down fast so let
67:27 - I beat to I less than equal a less than
67:31 - man that square root of n we did this in
67:37 - the previous the previous child so I'm
67:40 - not going over it again well I guess he
67:43 - couldn't we could thread yeah we could
67:46 - test here and module still equals to
67:49 - zero then third false and here we could
67:53 - the three and plus equals 2 so we
67:57 - improve it even more if and modulus I is
68:02 - 0 then we won't return false let me push
68:09 - this also like this just to make it
68:11 - pretty and otherwise if you don't have
68:13 - these we have a prime number so to get
68:17 - so we have a prime checker in to do to
68:22 - do okay yeah this looks good now
68:29 - wait a second there we go
68:33 - it should go for - okay good and now
68:37 - let's go
68:40 - overall the numbers up to
68:46 - and
68:48 - and find the primes and then add them up
68:51 - so cost primes will be well too and here
69:00 - let's have let current or what number be
69:07 - three while number is less than and we
69:12 - want number plus plus and here we want
69:14 - to check if is prime number then want to
69:18 - add it in the primes ray so this way we
69:22 - add all the primes let's see
69:25 - Prime's here
69:30 - council that love here and let sees a
69:34 - smaller number get so yeah
69:41 - below 17 we have taste so find the sum
69:46 - of all the primes below n okay so not
69:48 - inclusive yeah yeah and that we kind of
69:52 - need to add to add them up so we could
69:54 - use videos accumulator number
70:00 - accumulator plus equals number started
70:02 - zero and Paula ring not voila
70:07 - does it work why is that
70:13 - let's check for ten you get twenty six
70:20 - which is not good let's see what we have
70:22 - in the primes two three five
70:27 - seven and nine oopsie
70:34 - why do we have nine as a prime
70:39 - whoops up to so I less than equals to
70:44 - square root of n up well inclusive all
70:47 - right they should fix it so excited yeah
70:53 - so we get 17 good
70:58 - fingers crossed yeah it works okay so we
71:01 - have a function we check the primes then
71:04 - we get all the price we put it in a
71:05 - primes array
71:08 - or you know what we can even don't do
71:11 - this and just have a total total b2 and
71:16 - every time we find we just do a total
71:18 - plus equals number why do we do a reduce
71:21 - here not sure all right
71:25 - nom todo
71:29 - total is read-only yeah obviously we
71:33 - need something like this alright so yeah
71:40 - is there a better way to test this we
71:45 - kinda did optimization here so we don't
71:48 - go up to the number if it would go up to
71:51 - the number let's see what would happen
71:54 - here
71:59 - so we go up
72:02 - it's not even check for two so I just
72:04 - want to show you that the brute force
72:06 - might not work so we go over all the
72:10 - numbers right
72:13 - if anarchy falls first good so let's see
72:17 - yeah it doesn't work because I did
72:20 - something
72:23 - okay yeah so we need to check for 2.41
72:27 - so yeah this is the brute force
72:29 - well the longest and you can see that it
72:34 - will timeout
72:35 - I think yeah so this is why we need to
72:40 - improve it by adding these small tricks
72:44 - all right
72:46 - hope that made sense so here basically
72:53 - we would go up to a number like what's
72:56 - here to Melia
73:00 - [Music]
73:01 - but by doing this first we remove half
73:06 - of the checks by doing plus equals two
73:09 - right second we move
73:14 - I'm not sure what's the square root of
73:15 - two million but well let's check console
73:20 - Dethklok man that square root of
73:27 - million
73:29 - yeah so we don't go up to two million we
73:32 - go up to four thousand so that's a lot
73:37 - of millions worth of loops right so you
73:42 - can see how fast it is now is it two
73:46 - million
73:46 - yeah hit it oh okay so I I added here 20
73:52 - million so it goes only up to 1414 and
73:59 - also it skips every other number so it
74:02 - kinda does only 700 loops and the brute
74:06 - force did 2 million so you can see how's
74:09 - that good
74:10 - also you can could get this question in
74:13 - an interview so it's good to know
74:15 - something like this I think all right
74:18 - let's run this and go to the next one
74:22 - Thank You Laurent please be please stick
74:26 - around oh boy
74:27 - now this will be complicated
74:35 - should we do this or go take a nap
74:41 - all right largest product in a great
74:49 - okay we did something similar but it
74:53 - wasn't in a grade it was in a row so
74:57 - let's see in a 20 by 20 grid below four
75:00 - numbers along the diagonal diagonal line
75:03 - have been marked in red why the product
75:09 - of this number is big number what is the
75:14 - greatest product of for adjacent numbers
75:16 - in the same direction
75:18 - up-down left-right or diagonally in a
75:22 - given array
75:25 - I don't know all right so now this is
75:31 - interesting
75:36 - you
75:39 - [Music]
75:44 - okay I see here we have an array of
75:46 - arrays
75:53 - yeah be pretty pretty tricky so we kind
75:58 - of let's go back to the challenge
76:01 - resolved
76:07 - there was this
76:09 - [Music]
76:10 - largest product in a series this one
76:13 - here we only had to go one way but in
76:18 - this we need to go in a lot of ways so
76:22 - we need to go to the right
76:26 - to the left up down and diagonally this
76:32 - is fun yeah to watch it's very fun to
76:37 - watch
76:39 - okay so we have an array of arrays which
76:44 - gets the inner race gets the rose okay
76:48 - we could
76:50 - you
76:52 - let's think good start by going like
76:58 - this and well do the same thing we did
77:00 - here
77:02 - do we have no we don't have the code
77:03 - anymore oops we could have used that so
77:08 - we could go line by line and check what
77:11 - we did previously right that will be
77:13 - going to the right and laugh right
77:17 - because well it's the same thing up and
77:20 - down is the same thing that's one
77:23 - approach
77:24 - well one we kind of need to do three
77:27 - things to the right down and diagonal
77:34 - to the right and to the left yeah that's
77:36 - three
77:40 - this will probably take up the remaining
77:42 - time all right so first we go like this
77:46 - then we go like this and then we need to
77:52 - go like this and well when we're here we
77:56 - need to go like this and check all of
77:59 - them
78:01 - and store the biggest product
78:07 - okay let's stop complaining and start
78:12 - doing something good too bad I didn't
78:17 - save that I'm not sure why why why I
78:19 - didn't save it we could have used that
78:25 - so we need to think basically where we
78:29 - have a look that I call zero I less than
78:31 - a Raider flanked I plus plus this will
78:34 - go
78:37 - this will go on a collar and then left I
78:40 - J equals zero J less than or a that
78:43 - length J + + this will go from left to
78:48 - right right
78:49 - alright yeah so here we can go to right
78:54 - by checking what we had
78:59 - wait what's the four numbers okay so the
79:02 - number left lengths or I don't know and
79:07 - be for no man and don't like him
79:10 - we need to sew the length to to check
79:16 - it's a bit too long but that's what we
79:20 - need to do so here if you check to the
79:22 - right well
79:27 - you
79:29 - okay so
79:34 - we can check like with it right so we
79:37 - get an array which will be but we have
79:42 - array already here so
79:48 - is the great Catholic a KKK KKK let's
79:52 - write this somewhere else oh great we
79:58 - have Greek here
80:03 - metrics yeah that sounds better
80:07 - so have them metrics that's her that's
80:11 - the right thing but alright and here we
80:14 - need a sub array which will be by the
80:22 - way here we need to go metrics of I not
80:25 - like because it's the inner ray the sub
80:29 - sub array here will be matrix of I
80:34 - that's slice from J up to J plus lengths
80:40 - to check yeah so this is what we did
80:44 - previously and here well let's start up
80:48 - let max product be 0 and here we need to
80:53 - do if cost product will be sub array
81:00 - that reduce accumulator number
81:04 - accumulator x equals number and we start
81:08 - with one and if product is greater than
81:11 - max product then max product will be
81:16 - product right we solved one to the right
81:22 - which will basically head in the
81:24 - previous challenge this is why I went a
81:26 - bit a bit faster over it good but now we
81:31 - need to go down so how we did that two
81:39 - down let's have another
81:46 - Oh
81:47 - [Music]
81:49 - now the only issue here is that we're
81:56 - not if you remember in the previous one
81:59 - in the problem aid we kind of go we went
82:03 - up to this number and we checked to the
82:05 - last four but now we go up to this
82:07 - number which won't have so the slice
82:09 - will only return this
82:11 - but then the product will be it will be
82:15 - just this number so it shouldn't worry
82:17 - us but if we go like this if we end up
82:22 - here
82:23 - well sorry here we need to check one two
82:25 - and nothing so that could be let's see
82:30 - could you see that yeah okay so yeah
82:33 - here we don't have anything
82:37 - uh and we need to check for that and
82:40 - then we have two diagonals which will be
82:43 - okay
82:47 - good so two down two down well
82:53 - let's do the brute force and then we can
82:56 - see so basically when we're here we need
82:59 - this this and this oops
83:02 - this this and this when we're here we
83:05 - need D this this and this and so on and
83:08 - so forth so let's write this right for a
83:17 - okay and right product right product and
83:24 - we do this for the right and then to
83:25 - down
83:26 - we need a down array which will be an
83:31 - array with metrics of
83:40 - ethics of I and J this will be the
83:44 - current title so this one now we need
83:48 - this one which is I plus 1 and J so
83:53 - matrix of I plus 1 and J then matrix of
83:59 - well let me put this here so see we go
84:03 - down on the row the reason why I'm doing
84:07 - everything here is because I don't want
84:09 - to go multiple times over the entire
84:13 - grade ok I plus 2 and J and matrix well
84:22 - do you know what it's not that hard
84:24 - actually it's just what type I was
84:27 - worried for nothing so yeah now we have
84:30 - two down array but this while this won't
84:33 - exist
84:37 - well it it could not exist so I applaud
84:41 - if we're here I plus two is nothing so
84:44 - we don't have a jailer so we kind of
84:46 - need to check for death too so if we
84:52 - have matrix of I plus one
84:57 - we want to get that
85:02 - do we have it or it could be zero
85:06 - okay so how do we check he's different
85:10 - than undefined we get that and otherwise
85:15 - we get well what write the number
85:20 - multiple well in the product if you have
85:22 - one and multiply with anything it will
85:24 - be still the same number all right so I
85:26 - think this is what we need to do for all
85:28 - of this and if you don't have it we just
85:31 - say one
85:35 - okay Kanna tree property sale of
85:38 - undefined
85:43 - why so if Matty's side oh sorry to entry
85:50 - that could get so yeah now we kind of
85:53 - checked for those test cases and yeah
85:56 - let's do
86:02 - here can strike product
86:07 - I kind of want to move this in a
86:10 - separate functional so down product will
86:13 - be down array and all that so whoops
86:23 - you could create a downer with a loop
86:25 - four times incrementing the row I'd
86:28 - check yeah but that's another loop so I
86:31 - kind of did it manually here all right
86:35 - let me write a function get product and
86:40 - this will get an array and we're going
86:42 - to do this thing here
86:46 - we third array reduce blah blah blah all
86:50 - that so now we get the product of down
86:53 - array and here we get the product of
86:56 - right array loops
87:00 - look see
87:04 - get product of right all right
87:11 - okay so now we're left to check for
87:15 - diagonal 1 and diagonal too so it's just
87:19 - a lot of type typing to do and more than
87:23 - its art so diagonal to check
87:34 - direct check
87:39 - the bottom that's right if to the down
87:42 - is something check diagonal one and
87:47 - check diagonal two
87:53 - let's think so we need to go from this
87:55 - and go like this and so on and so forth
87:59 - we always need to check if we get to the
88:02 - indexes
88:04 - [Music]
88:08 - yeah
88:11 - okay so here we have kind of a bit of a
88:15 - problem
88:17 - Oh No yeah it should be good so we go
88:20 - like this from top to bottom right and
88:24 - then from top to bottom left from
88:28 - diagonal - I was thinking that when
88:31 - we're here we need to check this - but
88:32 - we already have it if we go down that
88:35 - way let's see so here we need to curl
88:38 - down and we get here we don't need to go
88:41 - all right so yeah
88:47 - you
88:49 - today
88:51 - it's something like this here and here
88:54 - this will be diagonal one array this
89:00 - will be diagonal one product this will
89:05 - be diagonal one ray this will be product
89:08 - and product so many copy and pasting can
89:11 - don't truly
89:13 - yeah all right
89:19 - we have actually you know what let me
89:22 - delete this and I'm going to copy this
89:25 - and change it once to tools too
89:30 - to
89:32 - - - all right good now what's that when
89:37 - we are here this element is I plus 1 J
89:41 - plus 1 right so I plus 1 J plus 1
89:48 - we also need to check if we have that
89:50 - right because when we are here we don't
89:52 - have I plus one there now the second one
89:55 - is I plus 1 J plus 2 I plus 1 J plus 3
90:01 - now the issue is that we might not have
90:03 - this
90:07 - and then we get undefined
90:12 - [Music]
90:18 - I don't really want to do another
90:23 - ternary operator
90:25 - although yeah this won't look very good
90:30 - but let me do this just for now so we're
90:34 - going to check if this a constant find
90:38 - well not equal it's different than
90:39 - undefined if it does then while we're
90:46 - going to add it otherwise we add one
90:52 - so we're checking there
90:53 - we're checking the dead
91:00 - happened
91:02 - and expected comma
91:07 - okay so this one No
91:13 - oh yeah another comma here yeah this is
91:18 - a bit silly so we're checking if we have
91:21 - the first we have the I here if we don't
91:27 - have it then we want to put an one in
91:32 - the array then we're checking if we have
91:35 - this if you don't have it we put a none
91:36 - one in your a and if we have them both
91:39 - then we put that number
91:43 - uhh
91:47 - yeah I'm going to think about a way to
91:49 - improve this so this could kind of work
91:52 - let me put it two more times
91:56 - and we're going to change you could go
92:01 - only with the metrics length minus 4 for
92:04 - ing
92:10 - yeah but I still need to check hey sorry
92:17 - I don't get it that well now so let me
92:22 - do that brute force so we're going to
92:25 - set that with tree and this weed well
92:27 - that with two and this with three KKK so
92:32 - yeah that's not good carry property
92:36 - three of undefined
92:40 - you
92:45 - oh okay I see
92:53 - oh no it should be good so if this is
92:57 - undefined it goes here
93:00 - check this one
93:04 - if this is not on the final it goes here
93:08 - otherwise one one so why we get three is
93:11 - undefined
93:12 - probably a messed up something
93:21 - yes this will be diagonal one and the
93:24 - agonal two will be let's let them put it
93:28 - here kind of silly but yeah so we're
93:33 - here we want to go this way so minus 1
93:36 - minus 1 minus 2 minus 2 minus 2 minus 3
93:39 - all the pluses here all day
93:44 - all the pluses here will be minuses
93:54 - cannot treat property - still undefined
94:00 - oops
94:06 - why do I get on the fan I don't see it
94:08 - and you're here well with this Everett
94:12 - well everything works we should have the
94:14 - max product here but it doesn't also
94:20 - at 20 by 20 okay so it's square square
94:27 - grid
94:30 - you
94:33 - canary property - so here doesn't look
94:37 - right
94:39 - oh okay I see so I forgot to change the
94:44 - first part here the first check
94:49 - okay so I think we have it now although
94:53 - these checks of looking awful but let's
95:00 - where it is
95:02 - let's cancel the plug this
95:12 - we don't get a good number there is no
95:17 - way oh we could test on the test
95:20 - great although yeah again
95:27 - right so what's happening there
95:33 - I'm going to rewrite the test grade
95:38 - just so that's just we can test so we're
95:45 - going to have nine nine nine one one one
95:50 - copy dates three times it will have 99
95:54 - it will have nine and nine so we only
95:57 - have nine and I don't diagonals
95:59 - other than that we'll have one of
96:01 - everywhere and we should get oh sorry
96:05 - so let's put two instead
96:11 - at 16 which works what happens if we add
96:15 - one more
96:21 - we should still get 16 okay
96:30 - yeah we should get a
96:34 - a times 324 we get 24 so
96:42 - then what's wrong what about if we got
96:48 - the other diagonal
96:54 - oops one one oh boy this is so badly
97:01 - formatted don't like but nevertheless
97:04 - two two two two
97:09 - okay so you can see now that it doesn't
97:12 - all let me format this because I don't
97:14 - like it yeah so it doesn't pick up this
97:22 - yet we know where is the issue he is
97:25 - here
97:30 - oh yeah my bad so it goes - one - one -
97:36 - it goes up top up top yeah the pop up
97:42 - and left and we don't want that we want
97:45 - down and left so down plus one down
97:54 - and well this plus one again probably
97:59 - you're yelling at your screens now but
98:01 - oh well see this is what why it's good
98:05 - to debug and write this dumbest code
98:09 - example alright look at this so
98:12 - basically if you're looking at this
98:14 - number we went this way so we went from
98:19 - five to forty seven thirty one and zero
98:21 - and we needed to go from five to sixty
98:24 - nine ninety nine sixty two
98:26 - okay that sound let's see test
98:32 - okay so I think that doesn't work
98:34 - because I change it change the test grid
98:37 - yeah bro
98:40 - yeah look at that oh boy this was a
98:46 - tough one
98:48 - well tough because we had to write a lot
98:52 - of code
98:54 - do I want to improve this yeah I guess I
98:57 - could remove the space here but that's
98:59 - all
99:07 - banking
99:10 - we have a lot of kind of copy and
99:12 - pasting and changing the values and I
99:16 - this check is you know not very very
99:19 - clear
99:21 - [Music]
99:23 - one thing it could do
99:31 - yeah I have an idea let's try that so
99:34 - instead of doing the ternary operator we
99:37 - could do and end here so it's going to
99:43 - check the sec well we need that instead
99:48 - of this actually and we're going to do
99:52 - the shirt secret method and we could
99:55 - avoid no death so if this is
100:02 - [Music]
100:05 - go here if it is false it will put false
100:08 - inside array that's what we want to
100:11 - avoid now well we need to check here
100:14 - when you do the product but yeah that's
100:17 - that's another thing we'll need to worry
100:20 - about now the good thing with this
100:23 - approach is that
100:30 - to fight a lot but let's see here
100:33 - instead of doing this third triple
100:36 - ternary we could do matrix I plus one
100:39 - and matrix I plus 1 and J plus 1
100:51 - again so different then
100:55 - don't think why I'm checking
101:01 - could be couldn't be zero so it'll be
101:03 - just undefined so let's try this so it's
101:10 - going to check for this if it's an array
101:13 - it will be true
101:17 - if it's not well told be undefined if
101:21 - it's undefined it will be false so it
101:24 - will well beyond the finally side array
101:27 - which is good so I think now we could do
101:31 - this everywhere but just for simplicity
101:37 - sake let's comment it out and
101:45 - do the simple version first here so plus
101:48 - two plus three and this was plus wait
101:55 - wait we're plus two plus three plus two
101:59 - plus three and we get the same number
102:03 - whoa
102:07 - okay okay I think I know why so our
102:10 - product method here so this number could
102:14 - be let
102:17 - I can only want to show you one so how
102:20 - can they do that
102:26 - so if we do here console that log array
102:30 - hopefully don't break my yeah won't
102:34 - break my
102:35 - [Music]
102:37 - my browser but you can see that
102:38 - sometimes we get undefined
102:42 - and apparently two x undefined it will
102:46 - probably convert this to 0 and that's
102:49 - good we get is the total of 0 let me
102:53 - check with clay here so if we get
102:56 - console that flog 2 times undefined
103:00 - should be easier not a number
103:07 - all right
103:08 - not a number but then we do this
103:11 - diagonal to which is a number is it
103:16 - greater I think that's why so we need
103:19 - did she see why why Java scripts the way
103:22 - it does so we need to check if 3 is
103:24 - greater than this and it's false
103:28 - so it's not greater so it won't add it
103:30 - all right works for me
103:32 - although the best thing to do would be
103:38 - a to check if this number is actually is
103:41 - not a number and convert it to to a
103:44 - number or up to zero if it's undefined
103:47 - but the trick works so let's not worry
103:50 - about that now
103:51 - good so the last thing we'll do here
103:56 - I'm going to copy this again if I mess
104:00 - it up just to have a backup and we need
104:05 - to do this at
104:09 - yeah look at how much code was safe with
104:12 - that pretty crazy face the scene plus 2
104:17 - Plus 3 plus 2 plus 3 minus 2 minus 3 all
104:26 - right
104:29 - yeah
104:32 - remove the test grade here use this get
104:36 - eventually that number okay and I'm of
104:40 - taste so yeah this looks much much
104:43 - cleaner now
104:46 - I like it
104:49 - goody-goody how we say it in our stream
104:53 - yeah let's submit and it works now if
105:01 - the good thing is that we only go over
105:03 - the matrix once and we check everything
105:05 - aside here the only thing we could kind
105:09 - of well we could think of let's see what
105:12 - Lauren says so I was thinking if you
105:14 - look at the number 40 in the bottom
105:17 - right
105:19 - or tin the button okay this one
105:23 - then you see you do not need to go
105:25 - further than I equals 16
105:29 - and J equals 16
105:34 - oh yeah you're right so we could do I
105:36 - think - length - check
105:42 - though they're not really know because
105:46 - we need to go here and check this
105:48 - diagonal so we kind of need to go up
105:50 - until here
105:58 - hey Quincy I'm glad you're still around
106:04 - yeah
106:07 - goody-goody yeah you wrote it wrong
106:10 - though it's goody-goody yeah that's our
106:20 - saying okay so
106:25 - we can
106:26 - to go up to 36 well we don't need yeah
106:31 - we don't need to go on this road though
106:33 - so that could be that could save us a
106:36 - couple of check so length to check right
106:45 - No
106:51 - like to check plus one yeah
106:56 - so yeah you were right yeah you're right
107:00 - torrid yeah nice clever clever guy I
107:03 - like I like I like the way you're
107:07 - thinking get so yeah we could just go up
107:11 - to this row because it will go
107:15 - oh but you know what
107:20 - then it won't check to the right here
107:23 - and it
107:27 - now
107:29 - what if the number is on this row
107:33 - we won't get it
107:38 - hmm
107:40 - so yeah you know what let's leave it
107:43 - like this we kind of need to check even
107:47 - this one right now
107:49 - and that one and yeah this one here is
107:54 - diagonal so we need to go to this number
107:57 - we need to go to this number
108:02 - yeah so this isn't
108:05 - we can't really cheat so we do that and
108:08 - we're using the undefined in JavaScript
108:12 - just to play around it can i if I do
108:15 - come and save yeah look at that it
108:18 - sailed into browser local storage good
108:21 - if we need it all right let's see what's
108:27 - the next one if it is too hard well if
108:30 - it's more complicated than
108:33 - oh well I almost didn't submit all right
108:43 - every direction has a prefer to limit
108:46 - not sure what to mean by that
108:47 - sorry I am I might just be tired okay
108:53 - let's see what's this about and it fits
108:55 - till I guess we could try it highly
109:00 - divisible triangular number
109:03 - again the sequence of triangle numbers
109:10 - is generated by adding the natural
109:11 - numbers so the seventh triangle number
109:14 - will be one plus two plus blah blah blah
109:18 - the first 10 terms will be 1 3 6 10 15
109:21 - 21 and so on let us list the factors of
109:25 - the first seven triangles triangle
109:28 - number sorry ok we can see the 28th is
109:34 - the first triangle number to have over
109:37 - five divisors
109:40 - what is the value of the first triangle
109:42 - number to have over ten divisors
109:48 - yeah
109:50 - you know what let's let's leave this for
109:54 - the next week Street I think I will have
109:59 - a fresh mind yes so basically we need to
110:06 - get all these numbers
110:12 - and then check the divisors
110:20 - [Music]
110:24 - once the first value was developed first
110:27 - triangle number two have over nd
110:29 - resource
110:32 - yeah
110:35 - and you know what let's they know that
110:39 - kind of dictate now okay so we're going
110:41 - to loop over all the numbers eyes ear oh
110:45 - I is 1 I less than what we don't know so
110:50 - we need the for a while loop while
110:56 - while to don't like that it will
111:01 - complain but while too
111:06 - we need to let is one we get here
111:16 - need to do them all in one go yeah I
111:18 - know but at least do as many as we can
111:21 - so we improve this while we get I plus
111:25 - one at the end
111:30 - and here while we need to check cast
111:34 - length the d'azyr's
111:36 - or I know the Visser's baby's arse
111:44 - hmm
111:46 - you
111:48 - again reserves
111:50 - prime numbers and all that
111:55 - they'll be an array and we need to check
111:58 - here if TVs source dot length so let's
112:05 - see what is the value of the first
112:08 - triangle number to have over and the
112:11 - whizzers so if it's greater than n we
112:15 - want to return the number which we don't
112:18 - have now so
112:23 - to get the number constant number I
112:25 - think this will be trying little number
112:29 - triangle number would be get
112:36 - get get get get
112:42 - get triangle value and we're going to
112:47 - paste in I this is the number right
112:55 - okay and let's write that function get
112:59 - triangle value I didn't wrote it right
113:03 - here four in number and here we need to
113:10 - go up to that number can add all the
113:12 - numbers so one way we could cheat kind
113:17 - of well let's do a for loop let's sum
113:23 - equals zero for let I equals 1 I less
113:29 - than equals to number I plus plus sound
113:35 - plus equals I and retired sup alright so
113:39 - we get we kind of get these numbers
113:41 - right so for 1 we have 1 foot the number
113:46 - 2 we have a triangle number of 3 1 plus
113:48 - 2 4 6 we have 1 plus 2 Plus 3 I kind of
113:52 - see a pattern here
113:54 - over way we don't need to do this but
113:58 - well we'll get that in a moment because
114:00 - we basically have the sum already we
114:06 - just need to add a number than another
114:08 - number so we don't need to do this loop
114:09 - over and over all right so we get that
114:14 - triangle number and then we need to get
114:17 - deep fizzers let me put this here and
114:21 - write the function get the deserts of
114:25 - triangle number function get the V
114:31 - source do yeah one cut off number and
114:37 - here
114:39 - yeah I wanted to read this you know me
114:43 - so well
114:45 - so we need constant divisors array we
114:50 - want to look loop over all of them I
114:52 - Swan I less than equal to man that
114:55 - square root of number I
115:05 - I plus plus
115:11 - now I kind of see something we could
115:13 - improve here nevertheless
115:17 - oh we need to go up to the number or we
115:19 - could just add it yeah oh okay so no
115:25 - square root
115:26 - my let's go up to the number and because
115:32 - basically number here when you check if
115:35 - number modulus
115:40 - I is zero right if it is then resource
115:44 - push you don't deal with primes
115:47 - I had Prime's might push PI and here we
115:52 - want to return the divisors
115:58 - goody goody
116:02 - want to check for five though good and
116:06 - triangle number I want to cancel the
116:09 - flock let's see what we get
116:14 - well we got it look at that
116:23 - well it work for all of them turned out
116:26 - probably but we have a we have an ace we
116:31 - can use have an ace in our sleeves not
116:35 - sure if that's used in English but we
116:38 - know meaning we have that thing good so
116:42 - the issue we well one thing
116:49 - [Music]
116:55 - not Kay so I kind of see a pattern here
117:00 - the girls up to the number the half of
117:04 - it
117:04 - so up to half of the number this is one
117:09 - improvement
117:18 - oh yeah so we kind of have one by
117:23 - default we need to hear
117:28 - and the bazaars that push we need to
117:32 - pull the number at the end because we're
117:33 - going captain up the half so then we
117:36 - don't have the number itself
117:41 - although if we have one with the only
117:43 - one one that's a special case so if
117:48 - number is one return
117:52 - but an array of one this is special case
117:56 - for one
117:59 - all right so then we Canada taste which
118:03 - is good
118:04 - we saved half of the iterations although
118:08 - I think it still turned out because not
118:10 - we don't have a problem here that we
118:13 - don't have a big problem here we have a
118:15 - problem here
118:19 - okay so the triangle number
118:24 - uhh
118:24 - [Music]
118:30 - triangle number they're recreating
118:32 - always the Sun but we don't have to the
118:36 - triangle number should be here I
118:42 - now let's make it zero and here we're
118:46 - going to the triangle number will be
118:50 - plus equals I
118:55 - okay so not cost so here we're just
118:59 - adding and we don't need this function
119:01 - because well by default we have zero
119:03 - then it goes here it will be 1 because
119:07 - well for one we have one but when we
119:10 - have two the number two we have one
119:13 - already and we add two when I have 3 we
119:16 - have 1 plus 2 which is 3 and we're three
119:20 - so that's good
119:23 - increment well no comment
119:27 - I don't have a mind of a comment I plus
119:34 - plus
119:37 - I guess we could do at first was here
119:41 - yeah well let's leave it like this just
119:45 - to make it be better
119:54 - okay so yeah this is it
119:59 - don't like this while through a loop but
120:03 - how many times do we need to loop
120:08 - we could move these dividers outside
120:13 - let's do that constantly deserts will be
120:17 - rent array and we're going to check this
120:20 - well the visitors that length is less
120:24 - than or equal to n we're going to do
120:27 - this now we save a couple of wealth it
120:30 - basically to loop the same amount of
120:32 - times but at least we don't have a while
120:34 - true and here well we could pre read you
120:39 - read only okay left yeah
120:50 - although I kind of like the wild through
120:52 - there but ya know it's not the best
120:56 - sometimes push number
121:02 - something like let's see that number or
121:09 - wait
121:10 - the Wizards that
121:16 - got a method
121:18 - concat number yes and they'll do the
121:23 - push there so we start with one
121:27 - oh you know what let's do something else
121:30 - here it we're going to do the check here
121:33 - if number is one we want to return the
121:36 - whizzers
121:41 - nukkie otherwise we're going to do this
121:44 - yet let's it still works
121:54 - timed out well I didn't check
122:00 - while - well true - we had it working
122:06 - right did I broke break something
122:16 - what happened
122:19 - you
122:20 - I totally forgot if I had it working or
122:29 - not
122:31 - you
122:34 - and cats shouldn't matter that much
122:38 - though
122:40 - let's see 23 works 167 potentially fatal
122:47 - OOP undefined
122:53 - okay not good so we still
123:08 - do you remember if we had it working I
123:11 - can't forget
123:18 - and yeah probably not so we still have
123:22 - an infinite well a timeout
123:31 - we too
123:37 - [Music]
123:41 - you
123:46 - the only thing we could improve is here
123:51 - this loop
123:55 - we get it deserves
123:59 - the length returned a triangle
124:04 - Oh
124:11 - you
124:13 - is there a way to get the Visser's by
124:16 - not doing a loop
124:21 - can we improve the loop
124:28 - you
124:31 - you
124:35 - yeah fine so it is working but it stand
124:38 - out so it's not fast enough
124:45 - you
124:52 - you
125:00 - ah
125:02 - yeah we kind of don't need
125:05 - need a length of the divisors
125:13 - get Wizards liked
125:17 - so we don't store it in an array you
125:20 - just get linked
125:26 - and here we check if the length is
125:29 - greater than and here the length that
125:34 - length be zero
125:40 - well true let's make it well to again so
125:45 - while two we check the length and here
125:47 - instead of doing this we're going to
125:51 - return the d'azyr's what that length
125:57 - last one well
126:02 - again we don't need to push the array
126:06 - okay so if number is one we want to
126:08 - return one a else let's
126:17 - first length oldest one and here we just
126:24 - increase the length length plus plus so
126:27 - I think all these pushing and getting
126:29 - from the Ray was hurting us get a
126:34 - visitor's light so this is a way with a
126:38 - length is read only Kiki what
126:44 - undefined so get visuals length they
126:48 - have triangle number we go over the
126:49 - numbers if it's divisible then we
126:53 - improve the length and really turn
126:57 - seems legit
127:01 - and well we don't need a special case I
127:03 - think length will be one and here
127:10 - yeah it won't go inside the loop now
127:14 - let's check for five again
127:17 - thirty-six okay so something is not
127:20 - working right
127:25 - 3636
127:26 - oh I see we forgot here if you remember
127:32 - we added the divisions pause we added
127:36 - the last number because we go up to the
127:38 - half of it so we need to do the length
127:40 - plus one all right but then here blank
127:45 - should be zero
127:52 - should be zero and I should be
127:55 - one and should be yeah yeah okay good so
127:59 - length zero and our stuff we start with
128:01 - 2 pi 1 and then we add one at the end
128:06 - there is something about the divisors
128:10 - what
128:12 - let's see now we changed to an array
128:16 - well from an array so we're not working
128:18 - with an array but still it might
128:21 - probably too much
128:26 - well we have the right answer there do
128:29 - we have 4:23 we have do we have for 167
128:34 - we have undefined
128:38 - because it's an infinite loop and a well
128:41 - it will just break out of it so I think
128:47 - we need a way to get and all the
128:51 - divisors of a number so go bail please
128:54 - help us get all the visas over number
129:04 - let's see do we have some kind of
129:06 - formula wicked years
129:11 - says meantime
129:18 - just say formula
129:25 - if it's a loop to adorn you're not
129:27 - interested if I look at 28 let's see
129:30 - what what Lawrence's if you look at 28 I
129:33 - see the first two divisions are
129:35 - important one two and four dollars
129:38 - calculated by yeah but what about
129:43 - Oh
129:43 - [Music]
129:47 - the next one which will be a 36
129:51 - but what's 36 divisors 36 will be one
129:57 - two three four six
130:04 - 10 now at 12
130:09 - 18
130:13 - right these should be right revisers
130:17 - five is not seven eight is not oh nine
130:21 - we have nine ninety five by four twelve
130:27 - eighteen
130:30 - they're always couples
130:35 - okay I see what you mean here we have
130:38 - two four six eight but
130:43 - how do we know
130:48 - what's the let's see let's go to 45 we
130:54 - have 1 3 5
131:02 - fifteen
131:06 - and for five I miss something right
131:13 - No
131:18 - you say and / I
131:25 - my eyes hurt wait wait so 40-45 here
131:42 - 1:20 approximately 2.14
131:47 - and / hi
131:54 - okay my head hurts now
132:01 - techno so yeah you see here we don't
132:04 - have like you said pairs
132:07 - right
132:10 - we have nine so we have pairs and / I
132:23 - and which will be 40 now
132:31 - but what's the N
132:34 - we received you say
132:43 - you
132:47 - Oh
132:51 - so here if I is a divisor
132:57 - ad
133:01 - /
133:04 - yeah oh I think I see what you mean so
133:07 - here we don't need to get so
133:16 - like only over three
133:21 - so the square root was the square root
133:23 - of yeah we get seven so I see if we have
133:28 - one we have n divided by 128 if we have
133:32 - to we have n divided 14 if we have four
133:36 - we have n divided seven but what's the
133:41 - condition we go up to what square root
133:46 - the square root of twenty twelve the
133:49 - square root of ten eight mad at square
133:55 - root 20
133:58 - fine whoa yay we candidate
134:05 - so here we can go
134:08 - up - let's check that square root of
134:16 - number and we can do plus equals two
134:25 - so here what was the function this and
134:31 - we need to pass in what five
134:39 - okay so it kind of works and now we're
134:43 - dropping a lot
134:49 - is is very nice why did they think that
134:54 - the square root of 28 is 9
134:58 - it's five so all it goes up to half of
135:02 - them square root of 21 is
135:06 - I'll get this four in a bit yeah
135:13 - so I think this solves it
135:17 - yeah now you can't say now that I
135:22 - couldn't done this without you well I
135:27 - would have done well yeah I wouldn't
135:31 - want to look over some code so
135:37 - I didn't want to cheat
135:38 - / co' they wanted to cheat looking over
135:41 - math but yeah that's a very good point
135:45 - we dropped from going up to the half of
135:48 - the number up to the square root which
135:52 - is huge
135:57 - and yeah we kind of need to do the same
135:59 - thing but here we just have to not sure
136:02 - why we need to do this but oh well yeah
136:07 - let's let's run this see it works submit
136:11 - and they done with it
136:16 - if numbers modules is zero and I am the
136:21 - number yeah we don't have the divisions
136:23 - or error anymore we change it to so we
136:30 - wanted to do something you we lost
136:32 - everything
136:37 - yeah Freaker camp you should store my
136:41 - solution oh wait maybe I go here
136:48 - portfolio
136:53 - uhh
136:55 - yes yeah oops
137:00 - [Laughter]
137:02 - yeah we don't have it anymore
137:05 - well yeah it was pretty fun
137:11 - although hard sometimes
137:15 - all right thank y'all for watching this
137:18 - or listening I really hope you enjoyed
137:20 - it if you enjoyed it give this video a
137:23 - like and don't forget we're doing life
137:28 - every Wednesday so come back in next
137:31 - Wednesday
137:32 - where we're going to attempt to do more
137:34 - of this and when we're going to get
137:36 - stuck sometimes which hopefully it won't
137:41 - happen we want to get to 100 but I
137:45 - honestly don't think I can do it up to
137:48 - 100 maybe only with your help
137:53 - but yeah come back in every Wednesday
137:58 - and we're going to continue also let's
138:02 - see there is a button saying don't blow
138:05 - to run the tests
138:09 - wait to work
138:12 - well
138:14 - you
138:19 - matt serwe to me all right so the
138:22 - download button
138:30 - yeah I don't see all right okay
138:36 - thanks all for watching if you want to
138:40 - check out my channel free free I have a
138:42 - link in the description of this video we
138:44 - are doing all kind of stuff they're
138:48 - coding JavaScript CSS react and all that
138:50 - and yeah I'll see you next week here on
138:54 - the freakin camp YouTube channel where
138:56 - we're going to continue this series I
138:59 - have a great great day and I'll see you
139:03 - next time bye

Cleaned transcript:

hello hello everyone and welcome to another live stream in which we're going to solve project Euler challenges using javascript for those of you who didn't join the first live stream we had I think two weeks ago we solve the first four problems using the free code camp platform and in this dream we're going to solve a couple more we'll see how it goes and how many we can solve if you join the live stream I can see close to 100 people being like say hi in the chat and yeah keep in mind that yeah I didn't prepare for this problem so well I don't have the solution I looked over to see how it looks and well how it works how it should work like a main idea but I didn't solve them and that's because I want to show you how how you can even fail when you start doing something you start coding on something and that's perfectly normal so yeah we're going to try and solve this on the first go and see how it goes for those of you who don't know me my name is Larry Popp I'm a developer from Romania I have a YouTube channel where you can find me live coding almost daily and I also upload different videos or you can follow me on Twitter if you want alright I see Quincy hello Quincy get so yeah I think you can hear me let me know in the chat and we can start with the problem number five the smallest multiple let's see what it requires smallest multiple 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any reminder what is the smallest positive number that is evenly divisible by all of the numbers from 1 to n all right so we're having to deal with the divisible numbers okay yeah also as Quincy met Christmas and the chat for now is for members only if you want to enjoy the chat I haven't be able to chat with me and engage consider becoming a member you also support this awesome platform and help other developers learn how to code for free alright so let's see we need to figure out how well probably this one of the problems I wanted to solve today is the hardest and that's because well we could go so we need to get all the numbers from one to add and then we need to find the smallest number which can be divided by each of these numbers right now this could be trickier we could just start and multiply 1 + 1 with 2 + 3 + 4 up to n but then we'll get a very high number and that's not the smallest number possible I know that there is a function but I knew about it but I kind of forgot in which you could check for you could have two numbers and check which is the lowest column multiplier let's let's go the latency lowest common divisor ya think ya LCD I think for not denominator let's see to do to do or so this could be one approach to use this function although it can see it now or we can go the bruteforce and start with a number well actually let's do that we're going to have one number to start with and we're going to increase this number and check for every number if it's divisible by all the numbers from 1 to n and I guess the starting number could be n hey kattiline welcome to the live stream how are you okay and now we kind of need another function to check Thank You kattiline to check if the number we're going to give it is divisible by all the numbers so let's write check the Visser's and we'll get the number and the desserts oh this is kind of interesting it as well these divisors will be also number we're going to loop or alright let's go with this and then we can slowly improve the function so here we're going to go from let I be dessert well it should be I 1 then it will go less than pickles to the number the divisor Haitian thank you for the super chat well thank you on behalf of Rico camp obviously alright so let's see here I don't like the names here so maybe number two check and number all right so let's do this and here we can check if kattiline thank you for the super chat ok so if our number well i modulus number two check so if this is different than zero so that means it's not divisible then we want return false right so think about this we're going to start with a number which will be the biggest number here well yeah okay let's let's Candide itself we're going to take for example a let's write examples here will be easier to explain so we have the numbers from 1 to 10 right and we need to find lowest well the smallest multiply for but well the smallest number that can be divided by all these numbers right which we know that is 2520 and what time we're going to do here is we're going to start with them start with 10 and then we're slowing slowly going to go up 10 11 12 13 14 and we're going to check all of these numbers if they are divisible by all the numbers from 1 to 10 hopefully that makes sense let me know it'll chat if it does or if it does it all right so that's what we're going to do here we're going to have a while look not sorry for the wire loop should be the best way to go we might get an infinite loop but well let's let's try for now yeah say they say that an infinite loop but actually we could have a boolean found be false and while not found we can Oh also we need to work we're going to use a start so while not found we're going to check the results we're going to pax the number two chapel which will be the start or what them start again not a good name so that's right number to check alright so we're going to check the number to check and we're going to pass in the app which will be our number then here infinite loop hype if this returns true then we want to well found be true so we're setting found to be true well again it says that we have an infinite loop like don't know if this is the best approach that well let's see how it is as a set this is proud of the hardness of the ones forget to do today so let's see again we have the number to check starting with the highest one all right then we're going to pass in the number to check oh and here we wanted the number to check plus plus right we want to increase the number and at the end we're going to return this okay so we're capping the number we're checking for divisors if it's divisible by all of these numbers well here we need to return true if it doesn't find a number which is not visible then should be true okay and yet this should probably work although let's check it might run my timeout yeah so something is not okay yes yes if you're in the live chat if you have an 80 feel free to suggest okay let's think again well this check divisor work so we have I 1 I less the number I plus plus okay so we get the numbers from 1 to 10 for example if we have the number 10 okay well you know what let me see so we need to check all the numbers okay number to check oh my bass the number to check has to be divisible by I right yeah kinda messed it up there okay let's also cancel that vlog Ness to see what we get okay number two check 30 which is yet so we're passing 20 we need to check out numbers from 1 to 20 all right and here we're saving it to the number to check now let's see if the while look while loop works okay so we get this number which is not what we wanted what is that isn't it check modulus I do different and Sarah so it's not okay what we get for five 60 we get 61 alright good good good good good so we're kind of closer here we get 61 because we increment here once again so we kind of want to do it here all right yet so now we know at least one test will work if we don't have well that's nice I didn't expect this to be honest so apparently all of them work now yes this is the life of a programmer it works and you don't always know why but yeah you have a nice goal there kattiline okay so could we improve this should we try to improve this or we should just leave it yeah so we're kind of checking all the numbers which is not powers oh yeah I think that number to check which we did there good thing number to check should be here although now if we have a number like 2 save for and that's not good right because we're starting with this number but then we increment in the wire loop so I kind of want to do n minus so one okay so now we get to sorry so yeah what about three three won't work for for for we should get let's see not six not eight probably twelve oh look at that yeah stuff so yeah this works now my trophy all right so let's run this let's submit and go to the next one which hopefully will be easier we did it the brute force way which is not well always the best solution but if you don't have another solution it should work all right problem six sum square difference the sum of the squares of the first ten natural number is three hundred and eighty five the square of the sum of the first 10 utter number is three thousand twentyfive hence the difference between the sum of the squares of the first ten at your number and the seventh and the square of the sum is that number all right find the difference between the sum of the squares for the first and natural numbers and the sum of and the square of the sum that's interesting there yet so yeah basically again we need to take all the numbers from one to ten or well one to n we need to add them up and then raise them to the power of two or we need to raise them individual to the power of two and then add them up and the result of these two well we need to subtract so yeah this shouldn't be that hard now okay let me see I could oh yeah that's better so let's create two functions one will create the square of the sum and when we create the sum of the squares so function square square of sums sum K and function sum of squares okay get and both of them receive and we could create an array and use map and the reducer yeah I'm kind of complicated over complicated now let me also add console clock here so we can see what we get all right so we need the sum of the so the square of the sum minus the sum of the squares let's go hear some once more so square of some square of sum of n minus sum of squares of that alright not a number yet now here well for one we need left I equals zero well I equals 1 I less than equals and I plus plus and square of some yeah we're going to have a sum which will be 0 and then sound plus equals I so we're getting all the numbers there and then we're returning some for now in this square of sum so we can do either met that power some until let me return here one so we can see something in the console or we can do I think this is a newer thing never used well it didn't really use it we can do this which is pretty much the same thing but yeah this is more obvious that we're raising the Sam ^ good now for the next one well we're having pretty much the same thing but instead of adding so let's remember the sum instead of adding I here we're going to add map that POW i ^ so we're squaring the numbers and yeah this should yeah it looks like it works for 100 this should work it's brute force I'm not sure if you can do it other way I know there is a formula for adding the numbers I've learned that in high school song time for adding the numbers from 1 to N it was something like let's see if I remember so n times n plus 1 divided by 2 so this should be the total and here we can do whoa wait wait wait not here this will work here because we're having the sum yeah oh not n times n plus one like this see so this works basically I remember that for the numbers from 1 to 10 it was like 55 so yeah this is the formula and well we don't have to do the loop which is good we saved some time here we can also put this here well let's leave it there we can use cops because we're not reeling yet now about days let's search a square sum of square formula sum of squares formula why not let's learn something new today k n n plus 1 and 2 n plus 1/6 all right thank you google so this is the formula let's use this so we kind of don't have taste here and this will be two times and all right let's return this and here this and is not oh oh sorry so and it's not the function we need to multiply there and here also alright so yeah this is I think this is now the more cleaner way it should say I was doing this we're using formulas instead of looping over which is pretty good it's way way faster this way because we're just multiplying instead of looping because if we had a big big big number well then would have some problems there all right so yeah let's submit this and go to the next one seven ten thousand one 10,000 first Prime I think by listing the first six prime numbers 2 3 5 7 11 and 13 we can see that the sixth prime is 13 again what is the nth prime nice prime numbers okay let's see so first what we could do again the brute force method and go over all the numbers from 1 to X well this case is M but we want the end pride we don't want to go up to end like we had before so we can start again and check all the primes get the primes and store them inside an array and when we get to an array of length of n we're going to output the last one this is the first idea I had let's see if that works although this is again the brute force but maybe we could improve it afterwards now let's see so we're going to need left number which will start from let's so two is the first prime number good and let Prime's will be an array and I'm going to put a number inside because while two is already a prime all right while this could be a Const because we're pushing to it okay let's see and here what we can already do Prime's that pop because pop sounds nice and well it will return the last one and this is what we want what's the end prime okay and we can do a while loop while Prime's that length is less than n so while we don't have the primes we want to well push to the primes so Prime's that push on the next prime number mmhmm okay let's think here Oh we get Prime so we could loop and find primes mmm let's do that so we're going to well we have the number there right the starting number and here we can do a check of it if it's a prime if is prime the number then we want to push the primes array okay I guess then we can remove it from here because automatic it automatically two will be added at the end here we're going to do number plus plus and we kind of just need a prime is prime functional so how do we check if the number is prime well a function yeah there is a thing I'm I'm thinking now we could do to improve because only 2 is 2 is the only prime number which is an even number all the rest are odd numbers yeah English samples so we killed two numbers plus equal to just so we can save half after loops loops count so let's do that we're going to push to here and we're going to start from three so now we don't check for all the numbers we just check for the odd ones okay good so that's an improvement it will also probably not work for well it will probably timeout you know it depends on how long it will take yet so is prime let's write another function which you're taking a number and it will return if it's pride so return through here by default we're going to assume it's prime and here we're going to do a check so we need to start from two let's go up to the number I plus plus and here we want to check mmhm so let's see we're going to start with three it will check the division so if number modulus I will be 0 then return false because the number one number is prime if only is divisible by 1 and itself right so we don't want to go up to the number very well inclusive the number okay and we check so we go here and we check is it divisible by 2 with 0 reminder if it is then well it's not a prime then we go up one more if it's divisible by 3 and so on and so forth okay we again have a potential infinite loop but this should work now so we're checking if it's a prime if it is well we push it here in the primes array and when the primes rate length is equal to n we we get the end right let's see what we get let me console that love this okay so for that we get that number which is not correct let's see what we have in the primes array okay so two three five seven eleven thirteen seventeen okay this looks it looks like we have the prime numbers well let me use it for six kay so if you do pop here what happened we have 30 which is good let's see for 10 we get 29 the last yes for 100 we get 541 thousand let's dip up here again okay so somewhere around there it fails let's learn the test and see what we get now that's weird why did you get that you know what it did it let's see again for 2001 we should get that number but we get this that's interesting might be something here yeah so it kind of stops in a in this terminal or whatever it is but it works murder while we're running the test okay there are a couple of things well a couple I have one idea which we could improve you can see here that we're also going again over all the numbers which is not a key we also need to do something like we did here to skip well at least we could to skip every two numbers so we could do here if number modules 2 is 0 then return false this is for the base condition that 2 and then here we could start with 3 and oh wait no no I'm wrong here so yeah we need to go over our lumbers because we could get a number and CV happen here we won't check for even numbers right so there's no way in trying to to check with another even number okay so yeah that should work well let's see so this is what I wanted to save more more loops here let's this okay yeah although it took more time which is odd but at least here you can see here we now got the number so it's it's faster okay and I think we also don't need to go up to the number we can go up to the square root we did it the last time but I forgot again so let's see ya know again up to the square root yeah so that works also we don't go up to the number but up to the square root so we save even more more loops all right so I think that's it for this one let's go to the next one can we stay we have 1% complete that's my later place okay problem eight largest product in a series the four adjacent digits in the 1000 digits number that we have the greatest product are nine times nine times eight times nine large production series okay so we have this big number and we need to find the and adjacent digits in the 1000 digits number that have the greatest product what is the value of this product all right so yeah we're getting a number and we need to find a number when to find a number which is n digits and it digits is the highest product Thank You Quincey I think for supporting the organization yeah she'd done it well I am a member on YouTube so see I think I have they had the emoji but I don't have it I don't see no never works okay so what we need to do we have this array which they provided for us thank you which is good because it's already an array so we can work with the numbers and if we have a number of lengths well if then and here is for window check this for store the product then check this for check the product is bigger than the previous product and so on and so forth up to Yeah right okay we need to get those ohms if we have five numbers we need to check like five numbers every times so we can do that using well we again need to go over all these numbers right so all these numbers and get the pair of four five or six numbers or how many they are we can do that using the slice method we can start from the index and get yes the slice or the splice method but the splice will change this array so let me first move this from here I'm going to create it here comes tiles and digits okay so we have we have a room here next up we want to create a loop which will go over basically all these digits right don't worry kattiline I know it's a joke okay so it goes over all the digits it will get the pair's and check the next one and so on and so forth so well what's the data for let is 0 I less than and for now but we're going to change this and I plus plus get and here take the pair it's not a pair how they call ends multiple take the series sirree ever and check the product here we're going to store the maximum product so max product will be the lowest number possible so yeah let's put 0 we're going to check if series product is great than Max product then we want to do max product be equal to serious product okay this is the function we are going to create okay good now because we're calling it twice well let's move it out in a variable so comest product will be series product and here we're going to test in an array with all the numbers we want okay get and at the end we're going to return the max product let's console.log it again all right now the only thing it's left oh we are left to do is to create this array so we want to get n numbers at a time so starting with the index we can do that by let's see so have this array let's write it here array will be this that's slice slice needs the index on which you want to start so it will be I and the second index the second argument will be our parameter will be you want to end but not inclusive so we want to do i+ n so let's see if we start this will be zero we if we do I plus and which is five we're going to up to five but not inclusive so we want we basically want to get all these right seven three one six seven and slice will give us this four because it goes up to so we can do I plus and plus one and now it will take all the five in the next loop it will start from this one and take all the five and then this one is so on and so forth we're going to pass this to our cities product yeah let's write it here like another function but then afterwards we'd like to write it in line so function series product will get an array and we want to do the product of all the numbers we can do that using reduce so hooray that reduce which gets an accumulator we're going to store the product in this accumulator and we have the number and we want to return here accumulator x equals to the number and the initial value should be what okay thousand digits oh yeah it's a Const it doesn't see now this because it's a constant it's down there all right all right let's put it up you all right good now Casey the X product arrey arrey juice accumulator commit x number this should work we create a new array now again the last thing wanted to check so basically now we're going up to M so this one but after this we don't have five five numbers so we could go up to n minus o this up to am sorry not up to end my bad my bad we need to go up to thousand digits not length the length of this and we can subtract the head so not the last ones let's see this works like that all right yes so definitely networks now let's see for for what we get so he had that number now the bad part is that we can't really really debug this it's the long list so let's see we have this array we have the Max product start with zero we return the max product that's fine here we're going over all the numbers sorry we're going over yeah the digits and we're slicing the digits we need thank you can see yeah I hope people enjoy so we're slicing from i to i plus n plus one so the length plus one because it doesn't go to the end good now here something happened we're going to the length up to the length minus n minus 5 well basically we want to check the the fort well if we check the last 5 we want to go up to this number right so it's minus n this is n plus 1 oh we need to check this and with the with his friends so plus 1 ok but we still don't get a correct number or do we know you know yet next we have this product which is a radius let's and thinking how can we test this because if well if we here comes something I counted a lot product just so we can see we get a lot of hammers well I guess we try deleting these or you know what let's comment this out and let's write again just with a couple of number so we can check what happens all right so we have one two three four five six numbers and we want to check let's see the pair of three now let's let's leave it for so basically these four or these four or these four are the largest now we kind of need to see what we get the product so consume the lock product and let's also the product let's also see the array okay so we see that we already have some issue here we get five numbers and we only need four so +5 oh yeah so my bad here we don't have +1 logic was correct but the implementation was wrong so if we start here this is I + 1 + 5 so 1 2 3 4 5 but then we added one more yeah so this already goes up to the number we want plus 1 all right my bad good so this should work now hopefully well yeah let's see so we get these numbers and we get it the maximum to be 126 and also you can see how nicely we get all the pairs here if we add in one more number here like nine we always get an array of four numbers which is perfect alright let's come and this out let's remove this and look at that we have the number 5832 let's run this and yeah and we got to 2% awesome now what could we improve if we could improve something one thing would be well I created this function but we kind of hailer and how are you welcome we kind of kept well we could do this here right it's just a function calling reduce so we can do that there all right but other than that I don't really see how we could improve it the well we're working with this the way should think about how to improve it is when you have a loop right you want to see if you could somehow not have a loop or have less iterations but I think for this one should be fine you wish you could cope with it okay I think you can't cut yeah so we kinda need to go over all the numbers I don't think we can cheat somehow I don't really think oh yeah I think this is the proach maybe someone can find something even better but I can't for now all right let's run this and submit and there we go vii done twelve eight really when did we start to date all right let's go to the ninth then all right let's drink some water we need to be a bit of a break good ix problem special Pythagorean triplet hopefully I pronounced that right a Pythagorean triplet is a set of three natural numbers sorry a less than B less than C for which a squared plus B squared equals C squared yeah yeah this is another math heavy problem so for example 3 squared plus 4 squared is 9 plus 16 which is 25 which is 5 squared so this is a Pythagorean well 3 4 & 5 it's called the Pythagorean Pythagorean triplet there exists exactly one Pythagorean triplets for which a plus B plus C equals 1000 find the product a B C such that a plus B plus C equals 10 okay uh what we need three numbers which are Pythagorean triplets well part of my Tiger paper Pythagorean triple I'm going to mess this up row saying by Pythagoras and when we find them we need to check if there's some equals two and then we need to multiply them I'm not sure did I understood this correctly so there exists exactly one triplet for which a plus B plus equals a thousand okay find the product a B C such that oh yes so the product a B C this is a product okay such that a B C equals that ABC equals 24 the product should be 480 oh okay so ABC here we have a square B Square C square oh okay yeah couple things to check mmm here we have a plus B plus C will be let's see 3 plus 4 plus 5 9 12 okay what would be 424 now I think the way we could do this is to I have three loops in mind like two inner loops one going from for a one for B 1 for C and then for C going up to a number yeah Thank You kattiline have a good day now yeah I'm not but thanks let's see so I'm going to write something just so we have a starting point for left I not I a equals one a less then something ABM what I said eh but I wrote I ate nah I plus plus all right and here well let's go for B and C B and C now B has to we have hit this condition here so B has to be one bigger than a at least and see one bigger than B at least so we can do here B equals a plus one and C equals B plus one all right now we need to check if there are Pythagorean triplets of if is triplet ABC if it is we need to check its SAP and if we find the sum we can return there find the sum to be close to this number then we can return the product so let's see if it's a triplet and a plus B plus C equals M right but this year then we want to return a times B times e okay this is not some of ABC yeah that's provided add it there and we don't need this so we kind of do everything in these slopes although I don't know if it's the best way but yeah so we go up to the number now again we go up to the number but we probably shouldn't because well the number in this case will be 24 but we kind of need the sum to be 24 so it's obviously that three numbers which are greater than each other they can't add up we can't all go to 24 so yeah but that's not just one we can fix later now let's create this is triplet functions function is triplet we get ABC and let's see so we need to check if a squared plus B squared equals C squared the third a squared plus B squared equals C squared look yeah it shouldn't be if it looked not sure why they said that we are not reassigning see so yeah should be good let's see castle that love this although this is not undefined okay so a list and if is triplet and if the the some damn otherwise let's retired one here just okay let's check for 24 what and compute see out of a and B what to mean okay so for 24 we get the number she's good now for 120 we get this number and 4,000 hello pression welcome welcome to support a roll so you saw that it works for 24 and 120 although they say this or this or this but now for a thousand yeah test timeout because well uhh you can compute the out of a and B I feel like you have something there so we don't need to go another loop and I kind of have an idea of what you're trying to say let's see so definitely this doesn't work because we have a loop of 1000 and 1000 and 1000 so that's a lot of thousands but as you said can compare to see out of AMV yeah yeah yes yes yeah so C will be a and minus B minus a right that's what you mean so then we don't need this look so then we're pretty fast and look at that that solved it thank you aren't I well I couldn't have done it without you yes so we don't need to look for see because we can find out what si si is by doing the subtraction right because we know a we know B we know ed yeah thanks that's really good please stay around I need your help all right it's pretty good and I think now they're passing the test Oh such a good feeling but yeah let's think I don't like the fact that we're going up to n right because well definitely don't need to check for a to B and at anytime it could go up to at most and right so see could be now no definitely not but how so if we have a sum of three numbers b24 what's the lowest take well the highest a can go it can be something like yeah I couldn't eat out you gave me this idea it was very good so if you have three numbers adding up to a number how can we check what's the maximum value to that so it could be for 24 so we have ABC equals 24 it could be 23 but then B and C well it couldn't be 23 or 22 because C B and C needs to be higher so definitely the sum couldn't be 24 then it could be half no way because if it's half then B is bigger than the half and C is even bigger so again we don't need to go up to n if not even up to half of it this will still work also be doesn't go doesn't need to go up to half of n again of the same principle right so have three numbers there's some is 24 yeah I think here we already saved a lot of loops but I still need to see could we find out how much they can go I think twenty four three numbers so definitely well if we divide by three because we have three numbers then yeah that's that's an idea so yeah and talking too much now let's write something so we have 24 this could be something like seven plus eight plus nine the most right because 24 divided 24 divided by three blah blah blah and here we get this so a could go up two and divide it by three minus one and this could go and divide by three like that up to okay so up to we broke why this could be a divided by 3 minus 1 K B and C could be at most third part plus 1 we broke it somewhere let's see for 24 still works yeah for 120 okay so here doesn't oh this is the correct answer I taught it's forty nine thousand nine hundred and twenty or its dalda the tree yeah I'm kind of spending a lot of time on this one but I want to see if we could find the best approach it is the square root I don't follow that buddy don't follow only have a problem we turn a thousand which gives us one so it doesn't find a triplet so we broke it once we set here divided by three trying some random numbers not to say yeah so apparently it's not divided by three well you know what be good could be pretty big I made a mistake so this is for a it could be at most seven but then B could be something like square root Oh and that or a triplet check right so this is 4a and 4b we need to see the maximum so we kinda could do a b1 I equal 1 then be equal to and that leaves us two Oh No so B could be that's Tess so half 11 I think and then C could be tough right they need to be they always need to be bigger than it well see bigger than baby bigger than a so it could go up to 11 which is half yeah that was my my mistake so a can go bigger than seven which is 1/3 well one less than the third and B can go up with more than half I'll also have minus one here Anna I think if you put two here it will it will still work in this case but might break in other cases let's see yeah so what I wanted to do is here is to find to improve this to make it as fast as possible who knows maybe there are even better ways to check it to do it so we are here undefined well which is by default so we can even remove these all right good let's go to the next one we spent way more time to this problem ten summation of primes primes again all right the sum of the primes below 10 is 17 find the sum of all the primes below and okay this doesn't seem that we'll look at this it is a big number we definitely need we need to improve this might be a timeout if you do the bruteforce but let's start with the brute force so again we need to have a function which will check if it's Prime let me write it down fast so let I beat to I less than equal a less than man that square root of n we did this in the previous the previous child so I'm not going over it again well I guess he couldn't we could thread yeah we could test here and module still equals to zero then third false and here we could the three and plus equals 2 so we improve it even more if and modulus I is 0 then we won't return false let me push this also like this just to make it pretty and otherwise if you don't have these we have a prime number so to get so we have a prime checker in to do to do okay yeah this looks good now wait a second there we go it should go for okay good and now let's go overall the numbers up to and and find the primes and then add them up so cost primes will be well too and here let's have let current or what number be three while number is less than and we want number plus plus and here we want to check if is prime number then want to add it in the primes ray so this way we add all the primes let's see Prime's here council that love here and let sees a smaller number get so yeah below 17 we have taste so find the sum of all the primes below n okay so not inclusive yeah yeah and that we kind of need to add to add them up so we could use videos accumulator number accumulator plus equals number started zero and Paula ring not voila does it work why is that let's check for ten you get twenty six which is not good let's see what we have in the primes two three five seven and nine oopsie why do we have nine as a prime whoops up to so I less than equals to square root of n up well inclusive all right they should fix it so excited yeah so we get 17 good fingers crossed yeah it works okay so we have a function we check the primes then we get all the price we put it in a primes array or you know what we can even don't do this and just have a total total b2 and every time we find we just do a total plus equals number why do we do a reduce here not sure all right nom todo total is readonly yeah obviously we need something like this alright so yeah is there a better way to test this we kinda did optimization here so we don't go up to the number if it would go up to the number let's see what would happen here so we go up it's not even check for two so I just want to show you that the brute force might not work so we go over all the numbers right if anarchy falls first good so let's see yeah it doesn't work because I did something okay yeah so we need to check for 2.41 so yeah this is the brute force well the longest and you can see that it will timeout I think yeah so this is why we need to improve it by adding these small tricks all right hope that made sense so here basically we would go up to a number like what's here to Melia but by doing this first we remove half of the checks by doing plus equals two right second we move I'm not sure what's the square root of two million but well let's check console Dethklok man that square root of million yeah so we don't go up to two million we go up to four thousand so that's a lot of millions worth of loops right so you can see how fast it is now is it two million yeah hit it oh okay so I I added here 20 million so it goes only up to 1414 and also it skips every other number so it kinda does only 700 loops and the brute force did 2 million so you can see how's that good also you can could get this question in an interview so it's good to know something like this I think all right let's run this and go to the next one Thank You Laurent please be please stick around oh boy now this will be complicated should we do this or go take a nap all right largest product in a great okay we did something similar but it wasn't in a grade it was in a row so let's see in a 20 by 20 grid below four numbers along the diagonal diagonal line have been marked in red why the product of this number is big number what is the greatest product of for adjacent numbers in the same direction updown leftright or diagonally in a given array I don't know all right so now this is interesting you okay I see here we have an array of arrays yeah be pretty pretty tricky so we kind of let's go back to the challenge resolved there was this largest product in a series this one here we only had to go one way but in this we need to go in a lot of ways so we need to go to the right to the left up down and diagonally this is fun yeah to watch it's very fun to watch okay so we have an array of arrays which gets the inner race gets the rose okay we could you let's think good start by going like this and well do the same thing we did here do we have no we don't have the code anymore oops we could have used that so we could go line by line and check what we did previously right that will be going to the right and laugh right because well it's the same thing up and down is the same thing that's one approach well one we kind of need to do three things to the right down and diagonal to the right and to the left yeah that's three this will probably take up the remaining time all right so first we go like this then we go like this and then we need to go like this and well when we're here we need to go like this and check all of them and store the biggest product okay let's stop complaining and start doing something good too bad I didn't save that I'm not sure why why why I didn't save it we could have used that so we need to think basically where we have a look that I call zero I less than a Raider flanked I plus plus this will go this will go on a collar and then left I J equals zero J less than or a that length J + + this will go from left to right right alright yeah so here we can go to right by checking what we had wait what's the four numbers okay so the number left lengths or I don't know and be for no man and don't like him we need to sew the length to to check it's a bit too long but that's what we need to do so here if you check to the right well you okay so we can check like with it right so we get an array which will be but we have array already here so is the great Catholic a KKK KKK let's write this somewhere else oh great we have Greek here metrics yeah that sounds better so have them metrics that's her that's the right thing but alright and here we need a sub array which will be by the way here we need to go metrics of I not like because it's the inner ray the sub sub array here will be matrix of I that's slice from J up to J plus lengths to check yeah so this is what we did previously and here well let's start up let max product be 0 and here we need to do if cost product will be sub array that reduce accumulator number accumulator x equals number and we start with one and if product is greater than max product then max product will be product right we solved one to the right which will basically head in the previous challenge this is why I went a bit a bit faster over it good but now we need to go down so how we did that two down let's have another Oh now the only issue here is that we're not if you remember in the previous one in the problem aid we kind of go we went up to this number and we checked to the last four but now we go up to this number which won't have so the slice will only return this but then the product will be it will be just this number so it shouldn't worry us but if we go like this if we end up here well sorry here we need to check one two and nothing so that could be let's see could you see that yeah okay so yeah here we don't have anything uh and we need to check for that and then we have two diagonals which will be okay good so two down two down well let's do the brute force and then we can see so basically when we're here we need this this and this oops this this and this when we're here we need D this this and this and so on and so forth so let's write this right for a okay and right product right product and we do this for the right and then to down we need a down array which will be an array with metrics of ethics of I and J this will be the current title so this one now we need this one which is I plus 1 and J so matrix of I plus 1 and J then matrix of well let me put this here so see we go down on the row the reason why I'm doing everything here is because I don't want to go multiple times over the entire grade ok I plus 2 and J and matrix well do you know what it's not that hard actually it's just what type I was worried for nothing so yeah now we have two down array but this while this won't exist well it it could not exist so I applaud if we're here I plus two is nothing so we don't have a jailer so we kind of need to check for death too so if we have matrix of I plus one we want to get that do we have it or it could be zero okay so how do we check he's different than undefined we get that and otherwise we get well what write the number multiple well in the product if you have one and multiply with anything it will be still the same number all right so I think this is what we need to do for all of this and if you don't have it we just say one okay Kanna tree property sale of undefined why so if Matty's side oh sorry to entry that could get so yeah now we kind of checked for those test cases and yeah let's do here can strike product I kind of want to move this in a separate functional so down product will be down array and all that so whoops you could create a downer with a loop four times incrementing the row I'd check yeah but that's another loop so I kind of did it manually here all right let me write a function get product and this will get an array and we're going to do this thing here we third array reduce blah blah blah all that so now we get the product of down array and here we get the product of right array loops look see get product of right all right okay so now we're left to check for diagonal 1 and diagonal too so it's just a lot of type typing to do and more than its art so diagonal to check direct check the bottom that's right if to the down is something check diagonal one and check diagonal two let's think so we need to go from this and go like this and so on and so forth we always need to check if we get to the indexes yeah okay so here we have kind of a bit of a problem Oh No yeah it should be good so we go like this from top to bottom right and then from top to bottom left from diagonal I was thinking that when we're here we need to check this but we already have it if we go down that way let's see so here we need to curl down and we get here we don't need to go all right so yeah you today it's something like this here and here this will be diagonal one array this will be diagonal one product this will be diagonal one ray this will be product and product so many copy and pasting can don't truly yeah all right we have actually you know what let me delete this and I'm going to copy this and change it once to tools too to all right good now what's that when we are here this element is I plus 1 J plus 1 right so I plus 1 J plus 1 we also need to check if we have that right because when we are here we don't have I plus one there now the second one is I plus 1 J plus 2 I plus 1 J plus 3 now the issue is that we might not have this and then we get undefined I don't really want to do another ternary operator although yeah this won't look very good but let me do this just for now so we're going to check if this a constant find well not equal it's different than undefined if it does then while we're going to add it otherwise we add one so we're checking there we're checking the dead happened and expected comma okay so this one No oh yeah another comma here yeah this is a bit silly so we're checking if we have the first we have the I here if we don't have it then we want to put an one in the array then we're checking if we have this if you don't have it we put a none one in your a and if we have them both then we put that number uhh yeah I'm going to think about a way to improve this so this could kind of work let me put it two more times and we're going to change you could go only with the metrics length minus 4 for ing yeah but I still need to check hey sorry I don't get it that well now so let me do that brute force so we're going to set that with tree and this weed well that with two and this with three KKK so yeah that's not good carry property three of undefined you oh okay I see oh no it should be good so if this is undefined it goes here check this one if this is not on the final it goes here otherwise one one so why we get three is undefined probably a messed up something yes this will be diagonal one and the agonal two will be let's let them put it here kind of silly but yeah so we're here we want to go this way so minus 1 minus 1 minus 2 minus 2 minus 2 minus 3 all the pluses here all day all the pluses here will be minuses cannot treat property still undefined oops why do I get on the fan I don't see it and you're here well with this Everett well everything works we should have the max product here but it doesn't also at 20 by 20 okay so it's square square grid you canary property so here doesn't look right oh okay I see so I forgot to change the first part here the first check okay so I think we have it now although these checks of looking awful but let's where it is let's cancel the plug this we don't get a good number there is no way oh we could test on the test great although yeah again right so what's happening there I'm going to rewrite the test grade just so that's just we can test so we're going to have nine nine nine one one one copy dates three times it will have 99 it will have nine and nine so we only have nine and I don't diagonals other than that we'll have one of everywhere and we should get oh sorry so let's put two instead at 16 which works what happens if we add one more we should still get 16 okay yeah we should get a a times 324 we get 24 so then what's wrong what about if we got the other diagonal oops one one oh boy this is so badly formatted don't like but nevertheless two two two two okay so you can see now that it doesn't all let me format this because I don't like it yeah so it doesn't pick up this yet we know where is the issue he is here oh yeah my bad so it goes one one it goes up top up top yeah the pop up and left and we don't want that we want down and left so down plus one down and well this plus one again probably you're yelling at your screens now but oh well see this is what why it's good to debug and write this dumbest code example alright look at this so basically if you're looking at this number we went this way so we went from five to forty seven thirty one and zero and we needed to go from five to sixty nine ninety nine sixty two okay that sound let's see test okay so I think that doesn't work because I change it change the test grid yeah bro yeah look at that oh boy this was a tough one well tough because we had to write a lot of code do I want to improve this yeah I guess I could remove the space here but that's all banking we have a lot of kind of copy and pasting and changing the values and I this check is you know not very very clear one thing it could do yeah I have an idea let's try that so instead of doing the ternary operator we could do and end here so it's going to check the sec well we need that instead of this actually and we're going to do the shirt secret method and we could avoid no death so if this is go here if it is false it will put false inside array that's what we want to avoid now well we need to check here when you do the product but yeah that's that's another thing we'll need to worry about now the good thing with this approach is that to fight a lot but let's see here instead of doing this third triple ternary we could do matrix I plus one and matrix I plus 1 and J plus 1 again so different then don't think why I'm checking could be couldn't be zero so it'll be just undefined so let's try this so it's going to check for this if it's an array it will be true if it's not well told be undefined if it's undefined it will be false so it will well beyond the finally side array which is good so I think now we could do this everywhere but just for simplicity sake let's comment it out and do the simple version first here so plus two plus three and this was plus wait wait we're plus two plus three plus two plus three and we get the same number whoa okay okay I think I know why so our product method here so this number could be let I can only want to show you one so how can they do that so if we do here console that log array hopefully don't break my yeah won't break my my browser but you can see that sometimes we get undefined and apparently two x undefined it will probably convert this to 0 and that's good we get is the total of 0 let me check with clay here so if we get console that flog 2 times undefined should be easier not a number all right not a number but then we do this diagonal to which is a number is it greater I think that's why so we need did she see why why Java scripts the way it does so we need to check if 3 is greater than this and it's false so it's not greater so it won't add it all right works for me although the best thing to do would be a to check if this number is actually is not a number and convert it to to a number or up to zero if it's undefined but the trick works so let's not worry about that now good so the last thing we'll do here I'm going to copy this again if I mess it up just to have a backup and we need to do this at yeah look at how much code was safe with that pretty crazy face the scene plus 2 Plus 3 plus 2 plus 3 minus 2 minus 3 all right yeah remove the test grade here use this get eventually that number okay and I'm of taste so yeah this looks much much cleaner now I like it goodygoody how we say it in our stream yeah let's submit and it works now if the good thing is that we only go over the matrix once and we check everything aside here the only thing we could kind of well we could think of let's see what Lauren says so I was thinking if you look at the number 40 in the bottom right or tin the button okay this one then you see you do not need to go further than I equals 16 and J equals 16 oh yeah you're right so we could do I think length check though they're not really know because we need to go here and check this diagonal so we kind of need to go up until here hey Quincy I'm glad you're still around yeah goodygoody yeah you wrote it wrong though it's goodygoody yeah that's our saying okay so we can to go up to 36 well we don't need yeah we don't need to go on this road though so that could be that could save us a couple of check so length to check right No like to check plus one yeah so yeah you were right yeah you're right torrid yeah nice clever clever guy I like I like I like the way you're thinking get so yeah we could just go up to this row because it will go oh but you know what then it won't check to the right here and it now what if the number is on this row we won't get it hmm so yeah you know what let's leave it like this we kind of need to check even this one right now and that one and yeah this one here is diagonal so we need to go to this number we need to go to this number yeah so this isn't we can't really cheat so we do that and we're using the undefined in JavaScript just to play around it can i if I do come and save yeah look at that it sailed into browser local storage good if we need it all right let's see what's the next one if it is too hard well if it's more complicated than oh well I almost didn't submit all right every direction has a prefer to limit not sure what to mean by that sorry I am I might just be tired okay let's see what's this about and it fits till I guess we could try it highly divisible triangular number again the sequence of triangle numbers is generated by adding the natural numbers so the seventh triangle number will be one plus two plus blah blah blah the first 10 terms will be 1 3 6 10 15 21 and so on let us list the factors of the first seven triangles triangle number sorry ok we can see the 28th is the first triangle number to have over five divisors what is the value of the first triangle number to have over ten divisors yeah you know what let's let's leave this for the next week Street I think I will have a fresh mind yes so basically we need to get all these numbers and then check the divisors once the first value was developed first triangle number two have over nd resource yeah and you know what let's they know that kind of dictate now okay so we're going to loop over all the numbers eyes ear oh I is 1 I less than what we don't know so we need the for a while loop while while to don't like that it will complain but while too we need to let is one we get here need to do them all in one go yeah I know but at least do as many as we can so we improve this while we get I plus one at the end and here while we need to check cast length the d'azyr's or I know the Visser's baby's arse hmm you again reserves prime numbers and all that they'll be an array and we need to check here if TVs source dot length so let's see what is the value of the first triangle number to have over and the whizzers so if it's greater than n we want to return the number which we don't have now so to get the number constant number I think this will be trying little number triangle number would be get get get get get get triangle value and we're going to paste in I this is the number right okay and let's write that function get triangle value I didn't wrote it right here four in number and here we need to go up to that number can add all the numbers so one way we could cheat kind of well let's do a for loop let's sum equals zero for let I equals 1 I less than equals to number I plus plus sound plus equals I and retired sup alright so we get we kind of get these numbers right so for 1 we have 1 foot the number 2 we have a triangle number of 3 1 plus 2 4 6 we have 1 plus 2 Plus 3 I kind of see a pattern here over way we don't need to do this but well we'll get that in a moment because we basically have the sum already we just need to add a number than another number so we don't need to do this loop over and over all right so we get that triangle number and then we need to get deep fizzers let me put this here and write the function get the deserts of triangle number function get the V source do yeah one cut off number and here yeah I wanted to read this you know me so well so we need constant divisors array we want to look loop over all of them I Swan I less than equal to man that square root of number I I plus plus now I kind of see something we could improve here nevertheless oh we need to go up to the number or we could just add it yeah oh okay so no square root my let's go up to the number and because basically number here when you check if number modulus I is zero right if it is then resource push you don't deal with primes I had Prime's might push PI and here we want to return the divisors goody goody want to check for five though good and triangle number I want to cancel the flock let's see what we get well we got it look at that well it work for all of them turned out probably but we have a we have an ace we can use have an ace in our sleeves not sure if that's used in English but we know meaning we have that thing good so the issue we well one thing not Kay so I kind of see a pattern here the girls up to the number the half of it so up to half of the number this is one improvement oh yeah so we kind of have one by default we need to hear and the bazaars that push we need to pull the number at the end because we're going captain up the half so then we don't have the number itself although if we have one with the only one one that's a special case so if number is one return but an array of one this is special case for one all right so then we Canada taste which is good we saved half of the iterations although I think it still turned out because not we don't have a problem here that we don't have a big problem here we have a problem here okay so the triangle number uhh triangle number they're recreating always the Sun but we don't have to the triangle number should be here I now let's make it zero and here we're going to the triangle number will be plus equals I okay so not cost so here we're just adding and we don't need this function because well by default we have zero then it goes here it will be 1 because well for one we have one but when we have two the number two we have one already and we add two when I have 3 we have 1 plus 2 which is 3 and we're three so that's good increment well no comment I don't have a mind of a comment I plus plus I guess we could do at first was here yeah well let's leave it like this just to make it be better okay so yeah this is it don't like this while through a loop but how many times do we need to loop we could move these dividers outside let's do that constantly deserts will be rent array and we're going to check this well the visitors that length is less than or equal to n we're going to do this now we save a couple of wealth it basically to loop the same amount of times but at least we don't have a while true and here well we could pre read you read only okay left yeah although I kind of like the wild through there but ya know it's not the best sometimes push number something like let's see that number or wait the Wizards that got a method concat number yes and they'll do the push there so we start with one oh you know what let's do something else here it we're going to do the check here if number is one we want to return the whizzers nukkie otherwise we're going to do this yet let's it still works timed out well I didn't check while well true we had it working right did I broke break something what happened you I totally forgot if I had it working or not you and cats shouldn't matter that much though let's see 23 works 167 potentially fatal OOP undefined okay not good so we still do you remember if we had it working I can't forget and yeah probably not so we still have an infinite well a timeout we too you the only thing we could improve is here this loop we get it deserves the length returned a triangle Oh you is there a way to get the Visser's by not doing a loop can we improve the loop you you yeah fine so it is working but it stand out so it's not fast enough you you ah yeah we kind of don't need need a length of the divisors get Wizards liked so we don't store it in an array you just get linked and here we check if the length is greater than and here the length that length be zero well true let's make it well to again so while two we check the length and here instead of doing this we're going to return the d'azyr's what that length last one well again we don't need to push the array okay so if number is one we want to return one a else let's first length oldest one and here we just increase the length length plus plus so I think all these pushing and getting from the Ray was hurting us get a visitor's light so this is a way with a length is read only Kiki what undefined so get visuals length they have triangle number we go over the numbers if it's divisible then we improve the length and really turn seems legit and well we don't need a special case I think length will be one and here yeah it won't go inside the loop now let's check for five again thirtysix okay so something is not working right 3636 oh I see we forgot here if you remember we added the divisions pause we added the last number because we go up to the half of it so we need to do the length plus one all right but then here blank should be zero should be zero and I should be one and should be yeah yeah okay good so length zero and our stuff we start with 2 pi 1 and then we add one at the end there is something about the divisors what let's see now we changed to an array well from an array so we're not working with an array but still it might probably too much well we have the right answer there do we have 423 we have do we have for 167 we have undefined because it's an infinite loop and a well it will just break out of it so I think we need a way to get and all the divisors of a number so go bail please help us get all the visas over number let's see do we have some kind of formula wicked years says meantime just say formula if it's a loop to adorn you're not interested if I look at 28 let's see what what Lawrence's if you look at 28 I see the first two divisions are important one two and four dollars calculated by yeah but what about Oh the next one which will be a 36 but what's 36 divisors 36 will be one two three four six 10 now at 12 18 right these should be right revisers five is not seven eight is not oh nine we have nine ninety five by four twelve eighteen they're always couples okay I see what you mean here we have two four six eight but how do we know what's the let's see let's go to 45 we have 1 3 5 fifteen and for five I miss something right No you say and / I my eyes hurt wait wait so 4045 here 120 approximately 2.14 and / hi okay my head hurts now techno so yeah you see here we don't have like you said pairs right we have nine so we have pairs and / I and which will be 40 now but what's the N we received you say you Oh so here if I is a divisor ad / yeah oh I think I see what you mean so here we don't need to get so like only over three so the square root was the square root of yeah we get seven so I see if we have one we have n divided by 128 if we have to we have n divided 14 if we have four we have n divided seven but what's the condition we go up to what square root the square root of twenty twelve the square root of ten eight mad at square root 20 fine whoa yay we candidate so here we can go up let's check that square root of number and we can do plus equals two so here what was the function this and we need to pass in what five okay so it kind of works and now we're dropping a lot is is very nice why did they think that the square root of 28 is 9 it's five so all it goes up to half of them square root of 21 is I'll get this four in a bit yeah so I think this solves it yeah now you can't say now that I couldn't done this without you well I would have done well yeah I wouldn't want to look over some code so I didn't want to cheat / co' they wanted to cheat looking over math but yeah that's a very good point we dropped from going up to the half of the number up to the square root which is huge and yeah we kind of need to do the same thing but here we just have to not sure why we need to do this but oh well yeah let's let's run this see it works submit and they done with it if numbers modules is zero and I am the number yeah we don't have the divisions or error anymore we change it to so we wanted to do something you we lost everything yeah Freaker camp you should store my solution oh wait maybe I go here portfolio uhh yes yeah oops [Laughter] yeah we don't have it anymore well yeah it was pretty fun although hard sometimes all right thank y'all for watching this or listening I really hope you enjoyed it if you enjoyed it give this video a like and don't forget we're doing life every Wednesday so come back in next Wednesday where we're going to attempt to do more of this and when we're going to get stuck sometimes which hopefully it won't happen we want to get to 100 but I honestly don't think I can do it up to 100 maybe only with your help but yeah come back in every Wednesday and we're going to continue also let's see there is a button saying don't blow to run the tests wait to work well you matt serwe to me all right so the download button yeah I don't see all right okay thanks all for watching if you want to check out my channel free free I have a link in the description of this video we are doing all kind of stuff they're coding JavaScript CSS react and all that and yeah I'll see you next week here on the freakin camp YouTube channel where we're going to continue this series I have a great great day and I'll see you next time bye
