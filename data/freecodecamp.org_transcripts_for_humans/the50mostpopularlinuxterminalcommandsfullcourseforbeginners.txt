With timestamps:

00:00 - learn the 50 most popular linux commands
00:03 - from colt steel
00:04 - all these commands work on linux mac os
00:07 - and any other place you have a unix
00:08 - environment colt is an extremely popular
00:11 - instructor and for good reason he has a
00:13 - knack for teaching complex topics in a
00:16 - way that beginners can understand hey
00:18 - everyone my name is colt steele and
00:20 - today we are going to learn a ton about
00:22 - the command line and different linux
00:24 - commands i'm a developer well honestly
00:27 - more of a teacher who happens to write
00:29 - code
00:30 - i teach in-person web development i've
00:32 - run boot camps in san francisco i now do
00:34 - a lot of online teaching and i have a
00:36 - boot camp i created with springboard if
00:38 - you want to learn more you can find a
00:39 - link in the description and this
00:42 - is a picture of one of my cats i
00:43 - actually have to take her to the vet
00:45 - like in five minutes really her tail is
00:47 - just drooping down for no reason i was
00:49 - gonna take her sooner but you know i had
00:51 - to make this for you
00:53 - let's hope she survives before i say
00:55 - anything else i want to give a big
00:57 - thanks to flavio copez i think i
01:00 - actually only know him as flavio maybe
01:03 - it's pronounced copes but i'm pretty
01:04 - sure it's not anyway uh he generously
01:07 - allowed me to use his linux commands
01:10 - handbook there's a link in the
01:11 - description of course very detailed and
01:14 - thorough handbook
01:15 - if you're not familiar with his work he
01:16 - puts out handbooks and tutorials on all
01:18 - sorts of topics so this is just one of
01:21 - many different handbooks
01:23 - anyway he is allowing me to use his
01:24 - handbook along with some of the
01:26 - materials i've created to create this
01:28 - mutant super course on youtube
01:31 - so we are going to cover 50 actually i
01:33 - think it's a little more than 50
01:34 - commands
01:35 - that are useful obviously to varying
01:38 - degrees some of them you'll use every
01:39 - single day
01:40 - as a developer for example
01:43 - and then some of them
01:44 - you may never use except in an emergency
01:46 - situation once a year but i'm going to
01:48 - cover a bunch of them they're not really
01:50 - in a particular order especially towards
01:52 - the end of the course but at the
01:54 - beginning i ended up deciding that
01:56 - instead of just 50 random commands in
01:58 - any order i wanted to make something for
02:01 - uh anybody so if you're a beginner you
02:03 - can start at the beginning and we'll go
02:04 - through the basics navigation working
02:07 - with the basic commands and options and
02:09 - making folders and files and so on but
02:12 - then after about this point
02:14 - things really open up and you can jump
02:17 - around to whatever commands you'd like
02:19 - and of course if you're someone who
02:20 - already has some terminal experience
02:21 - some of these commands are familiar to
02:23 - you just hop around take a look at the
02:26 - description there are time stamps and
02:28 - just click on whatever command you're
02:30 - not really comfortable with or you've
02:32 - never heard of
02:33 - there's probably something here for you
02:35 - but if you're a beginner i definitely
02:36 - would recommend starting at the
02:37 - beginning so aside from these commands
02:40 - which there's a lot here and this is a
02:42 - pretty long video i also cover some
02:44 - concepts that are pretty important so
02:46 - the very basics things like why even
02:48 - learn this stuff if you're not a linux
02:50 - user you're on a mac you're on windows
02:52 - why do you need to know linux commands
02:55 - do you need to know them the answer is
02:57 - probably yes if you're trying to break
02:58 - into web development programming coding
03:01 - engineering any sort of techie industry
03:04 - then we'll talk about things like unix
03:06 - and gnu and linux and unix-like and true
03:09 - unix what is all that uh what is a shell
03:12 - what is bash z-shell
03:14 - kernel terminology stuff so that's all
03:17 - coming up of course there's time stamps
03:18 - if you want to skip around if you don't
03:20 - care about that stuff and then
03:21 - installation so if you're on a mac you
03:24 - don't really have to do anything if you
03:26 - already have linux installed you don't
03:27 - really have to do anything either
03:29 - and if you're on windows well we have to
03:31 - jump through some hoops the good news is
03:33 - fewer hoops than we had to jump through
03:35 - a couple months or years ago so i'm
03:37 - going to show you how to install
03:38 - something called windows subsystem for
03:40 - linux
03:41 - then we'll also talk about concepts like
03:43 - command structure and arguments and
03:45 - options working with man pages folder
03:48 - structure of linux redirecting standard
03:50 - output appending standard outputs tilde
03:52 - expansion history expansion path name
03:54 - expansion curly brace expansion
03:57 - and permissions so we're going to end
03:58 - with permission is a pretty big chunk
04:00 - honestly at the end of this course it's
04:02 - devoted to just these two commands and
04:04 - understanding how to read and manipulate
04:06 - permissions on linux so there's a lot
04:08 - here there's some introductory
04:10 - conceptual stuff in terminology
04:12 - installation and then we start from the
04:14 - basics so you could know nothing about
04:16 - the terminal never have entered a
04:17 - command in your life start at the
04:19 - beginning and don't skip around or if
04:21 - you feel confident or you know some of
04:23 - this stuff jump around use the time
04:25 - stamps they are there for you all right
04:27 - so let's start with a quick discussion
04:28 - around why this matters why should you
04:30 - learn these commands uh yes at times it
04:33 - might seem like you're you know doing
04:35 - stuff straight out of a 1980s hacker
04:37 - movie um and we're
04:39 - far more advanced and things have
04:41 - improved so much why do we still have to
04:42 - use text commands well there's a bunch
04:45 - of reasons including the fact that
04:48 - you can just do a lot more from the
04:49 - terminal using these commands we're
04:51 - going to learn you'll have more control
04:53 - greater access you can do things you
04:55 - just cannot do otherwise there's just no
04:57 - way around that if you want to start a
04:59 - server manage different processes
05:02 - interact with databases all sorts of
05:04 - things alter permissions you need to
05:06 - know terminal commands to do that
05:08 - another reason it's faster at least once
05:11 - you get past the basic hurdles you learn
05:13 - the commands you get used to them you
05:15 - can do things way faster we can make
05:18 - 10 000 files in a single line i can make
05:21 - 10 000 empty files all with different
05:22 - names doing that graphically with my
05:24 - mouse or file new save file new save
05:28 - would take hours now that's just a sort
05:30 - of far-fetched example but in general we
05:32 - can do things much faster the one
05:35 - problem is that when you're learning
05:36 - it's going to be much slower i kind of
05:38 - already hinted at this one but we can
05:40 - actually automate things we can speed up
05:42 - repetitive processes we can save
05:44 - ourselves a lot of time
05:46 - another reason it's available everywhere
05:48 - so if you learn these commands
05:51 - you'll be able to work on any linux
05:53 - distribution you'll be able to then
05:55 - switch over to a mac if needed and use
05:57 - the commands on a mac now on windows yes
05:59 - it's a little bit different so it's not
06:01 - technically available everywhere but
06:03 - these commands we're going to learn are
06:04 - pretty standard across any sort of
06:06 - developer software engineer career which
06:09 - leads me to the next point it's
06:11 - essentially a requirement if you want to
06:13 - be a web developer data scientist devops
06:15 - engineer sys admin security admin
06:17 - machine learning engineer ai engineer
06:19 - whatever
06:20 - any type of coding related career you
06:23 - are probably going to need to use the
06:24 - command line you will have tools that
06:27 - only exist on the command line that
06:29 - you'll need to be able to use so for a
06:31 - lot of people that's the only reason
06:33 - that really matters you just need it if
06:35 - you want to get a job it's just part of
06:37 - the expected skill set also a lot of
06:39 - cloud computing programs or services
06:42 - don't even have a graphical user
06:43 - interface you just have to do things via
06:45 - a command line and again high-paying
06:48 - jobs lots of careers lots of roles that
06:51 - you'll need to at least know the basics
06:53 - of working with terminal commands so the
06:55 - next topic i'd like to quickly discuss
06:57 - is a little bit of context around
06:59 - operating systems and why these commands
07:02 - will work on linux and on mac by default
07:05 - but they're not going to work on a
07:07 - windows machine at least not out of the
07:09 - box so uh there's quite a lot of
07:12 - complicated history uh and
07:14 - and uh drama
07:16 - around different operating systems
07:18 - things being open source versus closed
07:20 - source and competition
07:23 - and copying each other
07:24 - it's quite dramatic but the general gist
07:28 - that you need to understand is that over
07:30 - the years since the very early days of
07:32 - computing well maybe not the super
07:35 - earliest days but we're going back to
07:36 - the 70s here this is a timeline that
07:38 - shows
07:40 - a very detailed timeline that shows
07:42 - operating systems and how they're
07:43 - connected
07:44 - anyway in the 1970s there was something
07:46 - called unix you can see it here
07:49 - and just take a look at all of these
07:51 - lines this whole family of operating
07:53 - systems that it spawned
07:56 - so there's lots and lots of them
07:57 - everything in red here is considered in
07:59 - some way related uh or indebted to
08:03 - unix
08:05 - so that includes things like linux
08:08 - so in this course i'll be using ubuntu
08:10 - which you can see here it is a
08:11 - distribution of linux but there's many
08:13 - many others things like android chrome
08:16 - os but also other uh more common linux
08:19 - distributions like fedora or red hats
08:23 - anyway all this linux stuff is
08:26 - descendant from unix all the way back
08:29 - here in the 70s now we also will see
08:32 - somewhere in here all the different mac
08:34 - operating systems here we are
08:36 - so mac os x we've got ios the apple tv
08:40 - os audio os
08:42 - watch os all these different apple
08:44 - products all the apple operating systems
08:47 - also related to unix
08:50 - but then our good friend windows
08:52 - somewhere down here it's not an it's not
08:54 - even in the same red color
08:56 - just to show how it is completely
08:58 - different it is in green this world of
09:01 - windows so windows windows vista windows
09:04 - xp
09:05 - windows mobile windows phone
09:07 - xbox os all that stuff is over here it's
09:11 - just kind of on its own
09:13 - it is not related it's not
09:15 - you know a descendant of that original
09:17 - unix operating system from way back in
09:19 - the 70s now the reason this matters
09:22 - is that
09:23 - all of these guys in red up here
09:25 - they tend to share the same commands
09:28 - unix was this operating system developed
09:30 - in the mid 60s at bell labs really cool
09:32 - time lots of innovation going on
09:34 - uh but what matters to us today 50 plus
09:36 - years later is that lots of those
09:39 - innovations lots of those new ideas and
09:41 - the specific commands the actual
09:43 - interfaces the way a file system was
09:45 - structured all of that carries over
09:47 - today yes it's changed it's been
09:49 - expanded
09:51 - but it is present in all of those red
09:53 - descendants of unix unfortunately for
09:56 - our windows users those commands
09:59 - don't exist natively on windows
10:02 - windows has its own set of commands its
10:04 - own default shell its own way of doing
10:07 - things so i'm going to talk about how we
10:08 - can get these unix commands to work
10:11 - on windows but just so you understand
10:13 - why this is a problem in the first place
10:15 - it just has to do with the history there
10:17 - are so many of these os's over the years
10:19 - inspired by
10:20 - and descended from the original unix os
10:23 - including linux and mac os
10:25 - but not windows
10:28 - lonely windows over here alright so now
10:30 - we have a basic understanding of the
10:31 - fact that
10:32 - of today's operating systems there's
10:34 - really those two groups everything
10:35 - descended from microsoft and then kind
10:37 - of everything else that is in some form
10:39 - some way related to unix now that's a
10:42 - vast simplification
10:43 - but again we're just talking about
10:45 - popular operating systems so you know
10:47 - linux chrome mac os all these things
10:49 - come from unix
10:51 - now let's talk about linux and unix and
10:54 - all that stuff in a little bit more
10:55 - detail so that you understand what
10:57 - exactly linux is why it exists so this
11:00 - is a diagram from wikipedia
11:03 - that shows the history going back to
11:05 - 1969 early unix versions
11:08 - and how it spawned all the you know
11:10 - other
11:10 - operating systems that are connected to
11:12 - it
11:13 - now what you'll see
11:14 - is that there are three colors red is
11:17 - closed source or pink
11:19 - and that means the code is completely
11:20 - closed off you can't edit it you can't
11:23 - view it you're not allowed to even try
11:24 - to tweak it
11:26 - then we have open source which you may
11:28 - be familiar with that term the code is
11:30 - openly
11:32 - viewable you can change it tweak it make
11:34 - your own versions try things out
11:36 - and then there's in yellow this mixed
11:39 - shared source type of
11:41 - operating systems so what you'll see
11:43 - here is that early on unix and a lot of
11:46 - other operating systems in the early
11:48 - days were mixed or shared source but
11:50 - then there was a plethora of closed
11:52 - source operating systems uh that were
11:56 - very walled off and you were not allowed
11:58 - to do anything with that code you were
12:00 - not allowed to view edit tweak and so on
12:03 - and that led to the rise of something
12:04 - called the free software movement free
12:07 - in this context does not mean no money
12:10 - free
12:11 - beer it instead means free in the
12:13 - context of freedom free speech
12:16 - so this software movement was all about
12:19 - uh the the idea that you should be able
12:21 - to collaborate you should be able to
12:24 - edit code view source code run copy
12:27 - distribute study change and improve
12:28 - software should not be walled off
12:31 - and the leader of this movement was this
12:33 - guy named richard stallman so he began
12:35 - work on something that ended up being
12:37 - called gnu gnu
12:39 - that was his own free software
12:41 - alternative to unix so he wanted to make
12:44 - a full operating system that had
12:46 - everything that normally came with unix
12:48 - but it was going to be completely free
12:50 - again free meaning you could tweak it
12:52 - and edit it do whatever you want to it
12:54 - and see the source code now that's a
12:56 - huge undertaking creating an operating
12:58 - system
12:59 - and at the same time this other
13:01 - developer named linus torvalds or linus
13:04 - torvalds
13:05 - was working on something called a kernel
13:07 - and we'll talk about what that is in a
13:09 - moment
13:10 - but this kernel he was working on he
13:12 - called it linux and a kernel is a very
13:14 - complicated and critical part of an
13:16 - operating system it is the thing that
13:18 - basically sits between the hardware and
13:21 - the software and it facilitates the
13:22 - interactions between different pieces of
13:24 - software and then the actual the
13:26 - physical hardware of the computer
13:29 - so
13:30 - what happened is that richard stallman
13:32 - was working on the gnu project trying to
13:34 - build a full operating system well he
13:35 - didn't have a kernel but at the same
13:37 - time linus torvalds was working on a
13:39 - kernel and torvalds ended up merging his
13:42 - kernel with the existing
13:44 - new components from richard stallman to
13:46 - create this whole operating system just
13:48 - a quick note so i don't get any negative
13:50 - comments here
13:51 - there is a bit of controversy over the
13:53 - name of the resulting operating system a
13:56 - lot of people
13:57 - most people have heard of linux
14:00 - fewer people have heard of gnu the term
14:02 - linux
14:03 - often people use it to refer to the
14:05 - entire resulting system when in reality
14:08 - uh the linux kernel was just one piece
14:10 - that was added on to some existing
14:12 - components but what matters for us here
14:14 - if we go way back to this slide
14:18 - over here
14:19 - is that what we see is a bunch of closed
14:22 - source mix source
14:24 - operating systems all over here and then
14:27 - this thing called linux pops up right
14:29 - there around 1991 in green it's open
14:31 - source now there's not a direct line as
14:33 - you can see going back to any of these
14:36 - what are called true unix operating
14:38 - systems and the reason for that uh is
14:41 - yet another piece of history there is a
14:45 - global consortium called the open group
14:47 - they own the trademark for unix
14:49 - in order for you to call your operating
14:51 - system unix if you make an os and you
14:53 - want it to be certified you have to pay
14:55 - a lot of money you have to go through a
14:56 - bunch of testing you have to comply with
14:59 - a bunch of regulations and standards and
15:01 - it's a complicated process and there's
15:02 - money involved it's not very
15:05 - free free software so we have another
15:07 - term there's true unix you've been
15:10 - certified as a true unix operating
15:11 - system
15:12 - and then we have unix-like operating
15:14 - systems which are compatible with the
15:16 - unix standards they implement things
15:18 - correctly but they haven't been
15:19 - certified as actually true unix
15:22 - and this is often because of financial
15:24 - considerations or ethical objections to
15:26 - the existence of the idea of true unix
15:29 - so what we see on this slide here is
15:31 - linux enters the picture it is not
15:33 - considered true unix but rather it's
15:35 - considered unix-like
15:37 - remember that linux itself is just a
15:40 - kernel which is very very important it's
15:43 - again that piece of the operating system
15:45 - that connects the hardware to the
15:46 - software so that's what linux is really
15:48 - it's the kernel but when we talk about
15:50 - things like ubuntu what ubuntu is is a
15:53 - linux distribution it is one of many
15:56 - many distributions out there there's
15:58 - nearly a thousand last time i checked uh
16:00 - you may have heard of fedora slackware
16:02 - ubuntu that's what i'll be using
16:04 - and what each distribution is it's it's
16:06 - the linux kernel it's some gnu tools
16:09 - documentation a package manager a
16:11 - desktop environment a window management
16:12 - system a whole bunch of other things
16:14 - combined together to form a full
16:16 - operating system
16:18 - so to recap all of that
16:20 - there are tons and tons of operating
16:22 - systems on this chart you can see some
16:24 - are open source some are closed source
16:25 - some are mixed source uh some of them
16:27 - are considered true unix they've paid
16:29 - they've been certified by this
16:30 - foundation or this consortium to be true
16:33 - unix but then over here we have linux
16:36 - linux is fully open source and whether
16:38 - you call it linux or linux gnu or gnu
16:40 - linux
16:41 - it is a
16:43 - unix-like operating system that conforms
16:45 - to all these standards these operating
16:46 - systems do we can use the same commands
16:49 - things are structured the same way there
16:50 - are subtle differences but it doesn't
16:52 - really matter everything on this chart
16:55 - here they're all part of this greater
16:56 - unix family or unix inspired family now
16:59 - we have one last piece of terminology
17:01 - and history and all that stuff to get
17:03 - out of the way before we move on to
17:04 - actually running commands we need to
17:06 - talk about the term shell so you may
17:08 - have heard of this before
17:10 - if you're on windows you may have heard
17:11 - of powershell or you may have heard of
17:14 - bash or z shell or you maybe never have
17:17 - heard of them but there's this concept
17:19 - of something called a shell
17:21 - what the shell is is a very very
17:23 - important piece of software that is
17:25 - going to expose the operating system
17:27 - itself to human users or to other
17:29 - programs so it is the thing that takes
17:31 - our commands and hands them over to the
17:33 - operating system to actually perform and
17:35 - the term shell comes from the fact that
17:37 - it's the outer layer around the
17:39 - operating system like the shell around
17:41 - an oyster so there's this other term
17:43 - terminal way back in the day a terminal
17:45 - used to be an actual piece of hardware
17:47 - it would have a screen and it was a
17:49 - physical device with a keyboard you'd go
17:51 - over and you'd enter your commands into
17:52 - the terminal
17:54 - today terminal is just a piece of
17:56 - software it's an application there's
17:58 - many different terminal applications
18:00 - it's the place we go to type our
18:01 - commands when we hit enter there's some
18:03 - shell that we are using in that terminal
18:05 - window uh by default on ubuntu and most
18:09 - linux distributions that shell is called
18:11 - bash on macs these days the shell is
18:13 - called z shell zsh another very popular
18:17 - shell is fish there are many other
18:19 - shells out there though
18:21 - and again their job is to take commands
18:24 - that we provide
18:26 - or other applications humans or
18:27 - applications provide and then give them
18:29 - over to the operating system and make
18:30 - sense of it all so again i'll be using
18:33 - bash that's the default shell that comes
18:34 - with the boom 2 but if you're on a mac
18:37 - i'll talk about installation and you'll
18:38 - see that fortunately z shell is very
18:41 - very similar and the commands are still
18:42 - going to work so it's not a big deal at
18:44 - all but it's good to know that there are
18:46 - different shells
18:47 - and then the job of that shell is to
18:49 - take those commands and pass them over
18:51 - to the operating system and as i
18:52 - mentioned bash is the most popular shell
18:55 - out there uh especially on linux based
18:57 - systems uh it is the most common default
19:00 - shell
19:00 - and the name if you're wondering it
19:02 - comes from born again shell
19:05 - and it really doesn't matter but it's
19:07 - this reference to this guy steven bourne
19:09 - who created a different shell called sh
19:11 - a direct ancestor of bash so there's sh
19:14 - and then born again sh
19:17 - and again bash will run on pretty much
19:19 - every version of unix or unix-like
19:21 - systems so it does run on macs it runs
19:23 - on you know any linux distribution any
19:26 - of the unix operating systems that you
19:28 - can see on that massive chart next up
19:30 - let's talk about setup and installing
19:32 - things if needed so that you can run
19:33 - these commands
19:35 - so right now we're looking at a linux
19:37 - distribution this is ubuntu this is the
19:40 - linux distribution i'll be using
19:42 - throughout the course
19:43 - if you already have linux if you have
19:45 - some version of it some distribution
19:47 - just use that it's going to be very very
19:49 - similar all that you need to know is
19:51 - there's a
19:52 - built-in terminal application if i just
19:55 - search for terminal
19:57 - i'm going to be running my commands in
19:58 - here probably change the color
20:00 - and this is where i'll type my commands
20:02 - so if you are on a mac you do not need
20:05 - to go and install ubuntu and a virtual
20:08 - machine that's actually how i'm running
20:10 - this i'm still on my mac here but i'm
20:12 - running it in a virtual machine you can
20:14 - do that but
20:16 - unless you have a really good reason to
20:18 - i would just stick with what you know
20:19 - because the commands that i'm going to
20:21 - show you will work on a mac
20:23 - all right so this is just for users who
20:25 - already have ubuntu here's the terminal
20:27 - app you just search for it and we'll run
20:28 - our commands there
20:30 - now if you are a mac user
20:32 - remember it's part of this unix family
20:34 - unix-like
20:35 - operating systems all the commands i'm
20:37 - going to show you will work on the mac
20:39 - all you need to do is search for
20:40 - terminal
20:41 - and it will probably look a bit
20:43 - different than this but you will have a
20:45 - terminal where you can run the same
20:47 - commands i show you so over here on
20:49 - ubuntu when i show the psax ww command
20:54 - it works you don't need to run this by
20:56 - the way but over here on my mac same
20:58 - thing p s a x w w
21:01 - it also works and it will actually learn
21:04 - what this is but it gives me a bunch of
21:05 - stuff all right windows users it's your
21:08 - turn let's talk about installation and
21:10 - the steps we need to go through in order
21:11 - to run linux
21:13 - so remember the problem here is that on
21:15 - windows
21:16 - we just don't have access to the same
21:18 - commands they're implemented differently
21:20 - windows is not part of this unix family
21:22 - this unix like family of operating
21:25 - systems so this means that a lot of the
21:28 - commands you'll learn
21:29 - in this video and that developers use
21:31 - every single day
21:33 - are not going to work on windows or
21:34 - they'll work differently or they'll
21:36 - partially work now windows has its own
21:38 - set of commands and as you could live in
21:41 - that world exclusively it's just a
21:44 - different world so if you want to use a
21:47 - lot of the common developer tools and
21:48 - you know you're watching this video you
21:50 - probably already know what you want to
21:51 - do
21:52 - we need to get some way of running linux
21:54 - commands on windows the way that we do
21:57 - this is really two options there used to
21:59 - only be one
22:00 - we used to have to have a virtual
22:01 - machine it's a pain to install uh it's
22:04 - totally isolated from your actual
22:06 - windows
22:07 - operating system
22:08 - and it can be slow can have a lot of
22:10 - overhead
22:12 - now instead we have a really cool fancy
22:15 - option called wsl windows subsystem for
22:18 - linux this is actually put out by
22:20 - microsoft
22:21 - and it allows us to run a linux
22:23 - environment directly on windows or
22:26 - inside of windows so it's not isolated
22:28 - it's not a virtual machine it actually
22:30 - works directly inside of windows
22:32 - it's just a command line version of of
22:35 - linux to be clear so we're not going to
22:36 - have a separate desktop you're not going
22:38 - to have you know all the apps and stuff
22:40 - that i have on ubuntu but that's kind of
22:42 - the point you can still be a windows
22:44 - user and have linux commands from the
22:47 - command line
22:48 - so it's really really cool it's updated
22:51 - pretty frequently it's still under
22:52 - active development and the really good
22:55 - news is that it's a lot easier to
22:56 - install these days than it used to be
22:58 - you do need to make sure you have
23:00 - windows 10 version 2004 with build
23:02 - number 19041 or higher or windows 11 in
23:07 - order to use the simplified installation
23:09 - instructions otherwise uh you can follow
23:12 - i would recommend going to this webpage
23:14 - anyway
23:15 - docs.microsoft.com look for wsl
23:18 - because this does change but if you have
23:20 - an older version you can still install
23:22 - wsl you just have different instructions
23:24 - but if you have
23:26 - the appropriate build number or higher
23:28 - all we need to do is from the app called
23:30 - powershell which i have open right now
23:32 - you can just search powershell
23:35 - okay this opens up this terminal where i
23:37 - can you can see ps by the way i'm using
23:39 - powershell
23:41 - i can type commands in here and it tells
23:43 - me in that case i don't know what the
23:44 - heck you're talking about
23:46 - but the command we want to run is wsl
23:48 - dash dash install so let's try it wsl
23:53 - dash dash
23:54 - install
23:56 - the requested operation requires
23:58 - elevation so what this is telling me is
24:00 - that i need to have admin privileges or
24:03 - permissions to do that so why is that
24:05 - happening well i need to run powershell
24:08 - as an administrator so i'm going to
24:10 - search again for powershell powershell
24:13 - but i'm going to click on run as
24:14 - administrator here
24:17 - all right and that opens me up a new
24:18 - window it says administrator windows
24:20 - powershell and we try again wsl dash
24:23 - dash install
24:25 - whoops
24:28 - and it might take a little while
24:30 - so i'll be back when hopefully this
24:32 - finishes successfully
24:34 - and if not i guess he'll watch me debug
24:36 - it
24:40 - oh check it out already we can see it's
24:42 - downloading ubuntu so that's the default
24:45 - linux distribution it uses when i first
24:48 - installed wsl a year or two ago for a
24:51 - different course uh you actually had to
24:53 - go and download your linux distribution
24:55 - separately you had to go download wsl
24:58 - separately you had to then connect the
24:59 - two and point it to the particular
25:01 - installation and it was just a huge pain
25:03 - but now
25:04 - hopefully super easy take a look it says
25:07 - the requested operation is successful
25:08 - that's always good changes won't be
25:10 - effective until the system is rebooted
25:12 - so let's reboot
25:14 - okay so once that finishes up i
25:16 - restarted uh i now have actually when i
25:19 - restarted it automatically opened up
25:21 - ubuntu which is now installed it wasn't
25:23 - even a thing before
25:24 - now i have an app i can run called
25:26 - ubuntu it opens up right now at least
25:29 - this
25:30 - terminal that i can see here and it
25:32 - tells me you know i had to install for a
25:33 - few minutes
25:35 - and then it wants me to set up a default
25:37 - user account and this username that i
25:39 - set up does not have to match my windows
25:41 - username but whatever you do you know
25:43 - you want to remember what you put in
25:45 - here so this is going to be for our
25:47 - ubuntu part of this machine i'm going to
25:50 - make my username colt
25:52 - and then a password
25:53 - and you'll want to remember that
25:55 - password you're not going to see what
25:56 - you're typing i'll hit enter and then
25:58 - retype it again
26:01 - you can change that password later i'll
26:02 - actually show you a command you can use
26:04 - to change that password
26:05 - and there we are i now have linux i'm
26:08 - running ubuntu on my windows machine so
26:11 - the commands will learn things like pwd
26:14 - and who am i
26:16 - just to show a couple simple ones or
26:18 - p-s-a-x-w-w
26:20 - there are lots and lots of commands
26:22 - we're going to cover and they now will
26:24 - work these commands are running on
26:26 - windows now there is some additional
26:28 - setup you can go through
26:30 - if you go to the installation
26:31 - documentation they recommend on windows
26:35 - that you whoops this is the wrong page
26:36 - here they recommend that after you set
26:38 - up your linux user info which we just
26:40 - did
26:41 - that you can also install an app called
26:43 - windows terminal
26:45 - and windows terminal is uh remember a
26:47 - terminal is just an application that can
26:49 - run different shelves and
26:50 - it can sort of be a jack of all trades
26:52 - we can use windows terminal as our
26:54 - terminal it's just a more sort of fancy
26:57 - better features more customizable
26:59 - terminal application so you do not need
27:01 - to do this but if you want to
27:03 - you can install the windows terminal app
27:05 - and you can make it look all nice and
27:07 - pretty
27:08 - and run ubuntu from inside windows
27:10 - terminal rather than the default
27:13 - terminal that comes with ubuntu so one
27:15 - more time perfectly serviceable just to
27:17 - use this terminal but if you want to get
27:19 - windows terminal if you're serious about
27:21 - you know mastering all this stuff and
27:23 - working
27:24 - as a developer or some other you know
27:27 - you want to use the terminal day in and
27:28 - day out windows terminal is just the
27:31 - better option it has more features so
27:33 - i'm going to install it i'm going to
27:34 - download it just from windows website or
27:37 - microsoft's website now that it finished
27:40 - i'll click launch
27:41 - and remember a terminal is just
27:44 - like a piece of software that can
27:46 - connect or interact with different
27:48 - shells so right now it opened up with
27:50 - powershell which is not what we want to
27:52 - use in this course
27:54 - first of all let's see if i can just
27:55 - make this
27:56 - larger font for you there we go okay
27:59 - it's a little bit larger now so as you
28:01 - can see it's using powershell but i can
28:03 - click this little drop down arrow here
28:05 - and switch over to instead use ubuntu
28:08 - so now i'm in ubuntu you can see my
28:10 - prompt changes here it has my username
28:12 - in there
28:13 - you can customize the appearance and all
28:15 - of that so if we go to settings
28:18 - you know you can go down to ubuntu you
28:20 - can set up a different appearance font
28:22 - size
28:23 - but what you can also do is set the
28:25 - default profile to be ubuntu and if we
28:28 - save that
28:29 - it now means when i make a new window if
28:32 - i just do plus
28:33 - it is ubuntu you can see my little linux
28:35 - penguin that's the logo there and we're
28:38 - now up and running with windows terminal
28:39 - there's a lot you can do to customize it
28:41 - but that's not really the point of this
28:43 - course so now you have it run your
28:44 - commands here when you see me run them
28:46 - in ubuntu uh run them here okie dokie
28:49 - that should hopefully wrap up
28:50 - installation whether you are actually
28:52 - running linux like
28:54 - like i am right now ubuntu this is the
28:56 - desktop version i have the terminal open
28:58 - i will be running my commands right here
29:01 - but if you're not maybe you're using a
29:03 - mac
29:04 - so here's my mac i've got my terminal
29:06 - open right here i'll run commands inside
29:08 - the terminal application here they'll
29:09 - work just the same
29:11 - and then finally if you're on windows
29:13 - hopefully you installed wsl so here we
29:16 - are i'm running this is windows terminal
29:18 - i make sure i'm running ubuntu here
29:21 - i run my commands right here so
29:23 - whichever one you're on just make sure
29:24 - you know where you're going to be
29:25 - running those commands if you're on
29:27 - windows make sure it's not powershell
29:30 - because you'll run into problems we want
29:32 - to make sure we are running ubuntu so
29:34 - that our unix commands will work
29:36 - otherwise they won't
29:37 - yes by the way all three of these are on
29:39 - one computer right now i've got linux
29:41 - windows and my mac
29:44 - okay let's get started okay so now that
29:46 - we hopefully have everything installed
29:48 - correctly we can go ahead and get
29:49 - started now before we do the first thing
29:52 - i just want to make clear is that for
29:53 - the most part there's no order to the
29:55 - commands in this video it's a bunch of
29:57 - commands and they're useful and most of
29:59 - them don't really have to do with one
30:01 - another or depend on each other but
30:03 - early on right now i'm going to go
30:05 - through some of the very basic commands
30:07 - and there is a logical order to how i'm
30:09 - going to teach them all that is to say
30:11 - if you're a complete beginner stay right
30:13 - here and we'll go through the basics in
30:15 - order but if you have experience if you
30:16 - know the basics of ls and
30:19 - man and cd and pwd you may want to skip
30:22 - ahead so check out the time stamps in
30:24 - the description below and click on
30:26 - whatever command looks interesting or
30:28 - you'd like to learn more about but if
30:29 - you are new stick with me let's go ahead
30:31 - and get started all right so before we
30:34 - talk about commands let's talk about not
30:36 - commands in my prompt
30:38 - if i start typing really anything and i
30:41 - hit enter
30:42 - the shell is going to try and process
30:43 - that and figure out what command i'm
30:45 - referring to but i'm not referring to
30:47 - any valid command so i get a message
30:50 - that says command not found
30:52 - same thing on a mac
30:53 - type gibberish we get command not found
30:56 - same thing over here on my windows
30:58 - machine although i'm running linux on
31:00 - windows
31:01 - and i get command not found okay
31:04 - hopefully not that surprising
31:06 - so what we want to do is type commands
31:07 - that actually make sense that the
31:09 - computer can figure out what we're
31:11 - referring to and then run some
31:12 - corresponding program for us and the
31:14 - first really simple one i'm going to
31:16 - show you is maybe not that useful but
31:18 - it's just a good demonstration of a
31:20 - simple command it is who am i all one
31:23 - word no spaces
31:25 - who am i all lowercase it's going to
31:27 - print the username of the currently
31:29 - logged in user so maybe not something
31:31 - you need to do all the time
31:33 - you probably know who you're logged in
31:34 - as though there are uses for this
31:36 - especially in scripting
31:38 - if you write scripts later on but anyway
31:39 - if i just run it here who am i
31:43 - over here on my ubuntu installation i am
31:46 - logged in as colt that is the username i
31:49 - have
31:50 - here's my mac here on who am i my
31:52 - username is slightly different it's my
31:54 - full name called steel
31:56 - and i think on windows it's just
31:59 - cult as well
32:00 - all right so that's our first official
32:02 - command really really simple hopefully
32:04 - nice and straightforward right there's a
32:06 - difference between just typing gibberish
32:08 - and typing a command that is recognized
32:10 - but it is important to note you know who
32:12 - am i like this
32:15 - is not the same thing at all
32:17 - uh there's no
32:19 - real auto complete or spell check or
32:21 - anything like that uh the terminal is
32:23 - just gonna take what you what you give
32:25 - it and try and find that program so it
32:27 - can't find this program
32:29 - who am
32:30 - it only knows who am i
32:32 - okay so the next command we'll look at
32:34 - is called man
32:36 - the man command m-a-n is short for
32:39 - manual
32:40 - and that's exactly what it is it is a
32:42 - command that doesn't do anything to our
32:44 - system it's purely informative it tells
32:46 - us information or manual pages for
32:49 - commands
32:51 - as well as some other things not just
32:52 - commands but we're going to focus on the
32:54 - command side of things so anytime we
32:56 - have some new command like we just
32:58 - learned who am i we can actually run
33:01 - man
33:02 - followed by that command name to get a
33:04 - manual page entry for that command so if
33:07 - we need to learn more about who am i or
33:10 - any other command most likely you won't
33:12 - need to learn more about who am i
33:13 - because it's so simple
33:15 - but we can do just that we can run man
33:18 - followed by a command like who am i
33:21 - hit enter
33:22 - and our screen changes pretty
33:24 - drastically that prompt goes away i
33:26 - can't type commands anymore
33:28 - what we see here is a man page it tells
33:31 - us the name of the command prints the
33:33 - effective user id
33:35 - something called a synopsis will come
33:36 - back to this when we learn some other
33:38 - commands and then a description
33:40 - print the username associated with the
33:42 - current effective user id
33:44 - pretty straightforward there's not a
33:45 - whole lot here we can see who wrote the
33:47 - command
33:49 - and we can find a place to report bugs
33:51 - this is a very simple man page some
33:53 - commands have very long pages
33:56 - dozens and dozens of pages you would
33:57 - actually need to scroll through
33:59 - now important to note first of all to
34:01 - get out of here
34:03 - we need to type the letter q if you
34:04 - forget that you can find it down here
34:06 - but remember i am not at my prompt right
34:08 - now i can't type commands so i can't
34:10 - type who am i if i type things i start
34:13 - to see a whole bunch of other texts
34:15 - appear i'm actually looking at some help
34:18 - that tells me more about how this
34:21 - program works so it tells me you know
34:23 - you can exit by typing q or uppercase q
34:26 - or
34:26 - zz
34:28 - you can type h to display the help page
34:30 - that i'm looking at right now
34:32 - so that's what happened i typed who am i
34:34 - hit h but anyway i'm going to type q to
34:36 - get out of there uh now i'm back to the
34:38 - man page for who am i and i'll type q
34:40 - again so just one more time if i type
34:43 - man followed by some command
34:45 - if i want to get out of here type q and
34:48 - now i can type commands again
34:50 - so if i try and run man on its own
34:53 - it's going to tell me what manual page
34:54 - do you want this is a manual command i
34:56 - need to know what you want a manual for
34:59 - so we can actually do man man
35:01 - and that gives us the
35:03 - man page for the man command it's an
35:06 - interface to the system reference
35:07 - manuals there's a bunch here
35:10 - one thing i'll just point out quickly is
35:11 - that we can scroll by using the mouse
35:14 - that is one option but it's a lot easier
35:17 - to scroll one page at a time by hitting
35:19 - space
35:21 - there's a lot of text here and i can
35:22 - scroll down by hitting space
35:25 - rather than having i can also use the
35:26 - arrow keys by the way to go one line at
35:28 - a time up and down which is what i'm
35:30 - doing right now
35:31 - space to go down a page at a time q to
35:34 - get out of here all right so that's the
35:36 - man command
35:37 - nice and simple hopefully
35:39 - very useful especially when we have more
35:41 - complicated commands the next command is
35:43 - also nice and straightforward it is
35:45 - called clear
35:46 - c-l-e-a-r
35:48 - and this command will clear your
35:50 - terminal screen
35:52 - it is useful although i'll also show you
35:54 - a shortcut that you can use in place
35:56 - that's actually much shorter
35:58 - so c-l-e-a-r will clear the mess on your
36:01 - screen if you have a bunch of stuff here
36:03 - like i do uh c-l-e-a-r enter and it's
36:07 - gone
36:08 - so i'll just show another example of
36:10 - that over here
36:11 - this is on my mac let's do some more
36:14 - commands how about man clear let's just
36:16 - take a look at that
36:18 - here is the manual page for the clear
36:20 - command it clears the terminal screen so
36:23 - i'm going to hit q to get out of here so
36:26 - i have a bunch more stuff
36:28 - let's just pretend that's all valid
36:30 - commands i want to get rid of it clear
36:33 - all right nice and easy now let's take a
36:35 - look again at the man page for clear
36:38 - this is on ubuntu
36:41 - and i want to talk about this right here
36:43 - the synopsis
36:44 - so we see the name it's clear here's a
36:47 - little description it clears the
36:48 - terminal screen nice and easy
36:50 - now the synopsis is actually showing us
36:52 - the syntax the accepted options and
36:55 - values we can pass to the clear command
36:58 - so clear is a command that accepts an
37:00 - option we can see
37:02 - if you see anything in square brackets
37:04 - here it means it's optional
37:06 - so you can pass this in you can pass
37:08 - this
37:08 - uppercase v lowercase x now what does
37:11 - that mean
37:12 - well commands accept options that alter
37:14 - their behavior you can change how a
37:17 - command functions so if we scroll
37:19 - further down
37:20 - we can see under options a description
37:23 - of what these different options do
37:26 - now the one i want to talk about is dash
37:28 - x now i don't use this frequently but
37:30 - it's just a good intro to options here
37:32 - it says that it does not attempt to
37:34 - clear the terminals terminal's
37:35 - scrollback buffer
37:37 - using the extended e3 capability i have
37:39 - no idea what that part means but what
37:41 - this means overall is that when we clear
37:44 - with the dash x option
37:46 - it is not going to clear our scroll
37:48 - history so i'm going to get out of here
37:50 - and demonstrate this so i'm going to hit
37:51 - q
37:53 - and let's make some history in here
37:55 - hello there
37:57 - i
37:58 - love you okay none of those are valid
38:00 - commands
38:02 - i can scroll back and you know see those
38:04 - commands and if i type regular clear
38:08 - it's gone i can't scroll back that
38:10 - history is gone now if i recreate some
38:13 - of that hello there i
38:15 - love you a lot if i use clear but this
38:20 - time i provide dash x and that's our
38:23 - first example of an option uh there will
38:25 - be tons of commands we see that accept
38:27 - options and they drastically they can
38:29 - drastically change the behavior of a
38:30 - command i'm going to hit enter
38:33 - and it clears
38:34 - but i can scroll
38:36 - so i don't use that often honestly
38:39 - i'm not showing it to you because it's
38:40 - something you need to know i'm showing
38:42 - it to you because it's an intro to
38:44 - options
38:45 - now one more thing i mentioned there's a
38:46 - shortcut and i don't really type the
38:48 - clear command anyway
38:49 - the shortcut is ctrl l so if i have a
38:52 - bunch of stuff again i want to get rid
38:53 - of it
38:54 - ctrl l and it's gone so that's
38:57 - definitely easier than typing clear
38:59 - it also works over here on my mac it
39:01 - works on wsl just control l
39:05 - okay so that's the clear command nice
39:07 - and easy the next command is also nice
39:09 - and easy it is pwd
39:12 - it stands for print working directory
39:15 - and this is a command that just tells us
39:17 - our current location in a given terminal
39:19 - window
39:20 - so let's start with man pwd
39:23 - and it tells us pwd prints the name of
39:25 - your current slash working directory so
39:28 - just like when we have i'll open up my
39:30 - file explorer here with my graphical
39:32 - user interface using my mouse
39:35 - i have a current directory that i'm
39:37 - inside of i'm viewing right now my
39:39 - desktop as you can see it's selected
39:40 - there
39:41 - or i can view documents
39:44 - or i can view my home folder
39:46 - this would be my current working
39:48 - directory home
39:49 - in this window right here but in a
39:51 - terminal it's a little bit different let
39:53 - me get out of this man page here hit q
39:56 - if i type pwd
39:58 - it tells me in text where my location is
40:02 - so in this window i am on the desktop
40:04 - which is located in the cult folder
40:06 - instead of slash home
40:08 - over here this is a different terminal
40:11 - window it has a different location just
40:13 - like i can have multiple file picker
40:15 - windows here's another one this one's in
40:17 - my home directory and this one's in
40:19 - desktop same idea so i can have in this
40:23 - case pwd a terminal window that is in
40:26 - slash home slash cold slash bin and
40:28 - here's one more different window
40:31 - a much longer path this is the full path
40:33 - to get to my location
40:35 - now i haven't shown you how to move so
40:38 - you probably don't
40:39 - have something like this set up with
40:41 - these different windows
40:42 - by default you can actually configure
40:44 - the default location of a new terminal
40:46 - window for me when i make a new terminal
40:48 - window just click that button there you
40:50 - can also use a shortcut it defaults to
40:52 - the desktop at least on ubuntu over here
40:54 - on my mac when i make a new window it
40:56 - defaults to what is called my home
40:58 - directory slash users slash my username
41:01 - you can configure all of this but it
41:03 - doesn't really matter where you are at
41:04 - the moment all that matters that you can
41:06 - find it by typing pwd
41:09 - alright so the next command we're going
41:10 - to cover is called ls the ls command is
41:13 - short for list and we use it to do just
41:16 - that it will list the contents of a
41:18 - folder so we can see
41:20 - what is inside of a directory
41:22 - you know normally if you're using a
41:24 - graphical user interface you don't need
41:26 - a command you just can see the contents
41:28 - of a folder but in a terminal window
41:31 - that is not how things work at all we
41:33 - have to ask for a list of the contents
41:36 - so here i'm on my desktop
41:38 - as we can see i ran pwd it says slash
41:41 - desktop you can also see my prompt is
41:43 - displaying desktop there as well
41:46 - that is also something you can configure
41:48 - by default though on ubuntu it does show
41:50 - you your current location
41:52 - anyway if i actually look at my desktop
41:54 - i can see a bunch of stuff there
41:57 - and i can list it out using the ls
42:00 - command
42:01 - so if i run ls with nothing else just ls
42:04 - it's going to list the contents of
42:05 - whatever current directory i'm inside of
42:08 - in this window it's the desktop and here
42:10 - we go we get a bunch of text so we see
42:13 - things like you know my folders uh some
42:15 - of them are quite odd here i've got
42:17 - wildlife i've got uh i've got files like
42:20 - greatgatsby.txt
42:21 - so there's some different colors and
42:23 - folders for me our bolded
42:25 - files are not bolded and they're just
42:27 - showing up white but that's all
42:29 - configurable as well
42:31 - but this is showing me all the contents
42:32 - of my desktop if i try it somewhere else
42:35 - here i'm in this slash bin directory
42:37 - i'll type ls i see different contents
42:40 - uh here that's my desktop desktop
42:44 - all right well let's try it on my mac
42:45 - here this is my home directory
42:48 - um i see a bunch of other stuff right
42:50 - this is different i see folders for my
42:52 - courses i make my desktop my documents
42:56 - labs some random things that you need to
42:58 - get rid of like hello.js and
43:00 - orange.python
43:02 - those are my files and folders
43:04 - now we also can provide a folder that we
43:07 - want to look inside of we can provide a
43:09 - path to ls so instead of just looking at
43:12 - our current location i could peak
43:14 - somewhere else
43:15 - so for example
43:17 - right here
43:18 - let's see i'm on my desktop
43:20 - and we saw that there is a wildlife
43:23 - folder
43:24 - on my desktop i could ask what is inside
43:27 - of there by running ls
43:29 - wildlife and i can tab complete so i
43:31 - don't have to type the whole thing
43:33 - and hit enter
43:35 - and i have no idea why i have a wildlife
43:37 - folder that contains three
43:40 - text files called angela one and nico
43:42 - survey it doesn't sound like wildlife to
43:44 - me but okay i've got a meal diary folder
43:48 - let's take a look in there
43:51 - and it has nested folders inside
43:54 - so now we can even burrow further in if
43:57 - we wanted to from my current location on
43:59 - the desktop i could look and set a meal
44:02 - diary and look inside of friday
44:05 - by doing this
44:08 - ls meal diary slash
44:11 - fry
44:12 - and i'm using tab complete so i'm giving
44:14 - it a path a path that is beyond it's not
44:17 - just one folder name it's now two
44:20 - that i want it to peak inside of so peek
44:21 - inside of this
44:23 - and we have breakfast dinner and lunch
44:25 - so i can actually run this again and
44:28 - let's see what's inside of breakfast i
44:29 - don't know if there's anything in there
44:31 - i'm gonna recall the previous line by
44:33 - hitting the up arrow and then just add a
44:35 - b and hit tab
44:37 - yeah there's nothing in there no it's a
44:38 - bit of a letdown
44:40 - so that's one example of using ls where
44:42 - we provide a file or rather a folder
44:44 - path but we can provide a full what's
44:47 - called an absolute path to any location
44:50 - on our machine
44:51 - so this file breakfast or this folder is
44:54 - inside of friday is inside of meal diary
44:57 - which is nested in the desktop which is
44:59 - where i currently am
45:00 - right pwd i'm on the desktop but maybe i
45:04 - want to see what's inside of my
45:05 - documents folder and documents is not on
45:08 - my desktop
45:09 - well one option is to do this ls
45:12 - and then the full path to my documents
45:15 - which is slash home slash colt slash
45:18 - i think it's uppercase
45:20 - documents so i'm using tab completion
45:22 - again so i don't type that myself
45:24 - i don't know if there's much in there
45:26 - nope just a single file but we can see
45:29 - kenneth.txt
45:31 - now i could get there right by just
45:33 - opening the file picker going to
45:34 - documents yes i see it
45:37 - but there are some special things that
45:39 - we can do with the ls command in the
45:41 - terminal as well but just to recap what
45:43 - i showed there we can provide what's
45:45 - called a relative path so relative to
45:47 - our current location i could just say
45:49 - show me list the contents of meal diary
45:52 - but that only works if i'm on the
45:53 - desktop
45:54 - if i'm somewhere else i can't just
45:57 - reference meal diary i need to reference
45:59 - the full path
46:00 - and that's exactly what i did down here
46:02 - to get to documents the documents folder
46:04 - is not in my desktop so i can't do ls
46:07 - documents
46:08 - it's going to tell me i don't know what
46:09 - you're talking about that doesn't exist
46:10 - here on the desktop
46:12 - but if i provide the full path this is
46:15 - the unique location the absolute
46:17 - location of documents i can see it's not
46:20 - exciting but i can see there's one file
46:22 - all right so now let's talk about some
46:24 - of the options ls accepts so let's use
46:26 - that clear command or use ctrl l
46:29 - and then let's run man ls
46:32 - it tells us it does list directory
46:34 - contents
46:35 - and then it says that there's a bunch of
46:37 - different options and i'm going to
46:38 - scroll through them these are all the
46:40 - options
46:42 - a lot of them
46:43 - most of them i don't use
46:45 - doesn't mean they're not useful they're
46:47 - just there's a lot
46:49 - i want to highlight two that are very
46:50 - useful the first one is dash l
46:54 - so let's find it here
46:56 - dash l come on h i j k l
47:00 - doesn't tell us much but it says it will
47:02 - use a long listing format so this means
47:05 - i can take a look around with ls
47:08 - and rather than just getting the file or
47:10 - folder name i can instead add dash l
47:14 - and get a whole bunch of other
47:15 - information
47:17 - so there's a lot we're not going to go
47:18 - over here but there's file permissions
47:20 - there's the owner of the file
47:22 - there's the group owner there's file
47:24 - size information
47:26 - modification date the file name so a lot
47:29 - of stuff here
47:31 - for each individual file
47:33 - so that is dash l
47:35 - now another thing we'll take a look at
47:36 - another option i'm going to go back to
47:39 - man ls
47:40 - is dash a
47:42 - now dash a you can also do the longer
47:45 - form dash dash all
47:47 - all it says is that it does not ignore
47:49 - entries starting with a dot when i just
47:52 - type ls i don't see any files or folders
47:54 - that start with a dot
47:56 - ls dash a
47:58 - i now see quite a few
48:01 - dot bash a bunch of stuff
48:03 - dot profile dot less something dot
48:06 - pseudo something there's probably some
48:08 - different ones on your machine i'll just
48:09 - try another example here ls-a
48:11 - on my mac lots and lots of files that
48:14 - start with dot
48:15 - they don't show up if i do a regular ls
48:18 - which you can see right there
48:20 - nothing starts with a dot
48:22 - now we can combine options as well
48:24 - so if i want to and clear this screen i
48:27 - can do ls dash a
48:29 - to see all files including ones that are
48:31 - hidden dash l i want the long format
48:34 - that is one way of doing it but the much
48:36 - shorter and more common way is actually
48:38 - just using a single dash and put your
48:40 - options together so dash a l or dash l a
48:44 - i see the long format
48:46 - all the information for regular files
48:49 - and files and folders that start with a
48:51 - dot so we're getting both of those
48:53 - options uh taking effect at the same
48:55 - time
48:56 - so that's an intro to the ls command so
48:58 - we've seen how to find our current
49:01 - working directory where we are and list
49:03 - the contents of that directory now how
49:06 - do we move around how do we do the
49:08 - equivalent of what i'm doing right here
49:10 - in the file explorer
49:12 - double clicking on
49:14 - you know desktop and then going into
49:16 - this folder or going back how do i move
49:20 - around like i am right here
49:22 - well in the terminal the way that we do
49:24 - that is by using the cd command cd is
49:27 - short for change directory now the first
49:30 - thing you'll notice if you try and read
49:32 - the man page for cd
49:34 - it does not exist
49:36 - it just isn't there when i try it on my
49:38 - mac
49:39 - i see something but it is not a man page
49:42 - 4 cd if we look up here it's a man page
49:46 - for
49:47 - a bunch of commands tons and tons of
49:49 - commands including cd well what's going
49:52 - on here is that the cd command is
49:54 - actually implemented by the shell we
49:56 - don't need to dive into the specifics
49:57 - really at all just i want you to know
49:59 - that you're not going to find a super
50:01 - helpful man page for cd it's one of the
50:03 - few commands that we'll cover that does
50:05 - not have a man page however you can run
50:07 - help it's a different command
50:09 - it's like the shell's version of man
50:11 - help space cd
50:14 - and it's kind of annoying it just prints
50:16 - out text
50:17 - you don't enter that program where you
50:18 - can scroll nicely it just takes up a
50:21 - whole bunch of text but it does tell us
50:23 - it changes the shell working directory
50:26 - change the current directory
50:28 - there are some options we're not really
50:30 - going to use those however
50:32 - let's just see how it works so i'm going
50:34 - to clear my screen first of all remind
50:36 - you where i am in this window i am in my
50:39 - home
50:40 - cult folder
50:41 - if i type ls
50:43 - i see a bunch of other folders so let's
50:45 - say i want to move into one of those
50:47 - folders how about my desktop
50:50 - well the way that i do that is by
50:51 - writing cd
50:52 - and then specifying that path
50:55 - so i'm just going to do d e tab
50:58 - hit enter
50:59 - and you'll see my prompt changes
51:02 - if i type pwd you can see my location
51:04 - has changed to be home slash cult slash
51:07 - desktop
51:08 - before it was just home slash colt
51:10 - so i just jumped i just double clicked
51:13 - into that folder but i didn't click
51:15 - anything it was all done via the
51:16 - terminal
51:17 - so i type ls i'm on the desktop now
51:20 - let's go into the meal diary folder cd
51:23 - into meal diary
51:26 - all right and we're now in here
51:29 - i can cd into how about friday
51:34 - type ls or pwd you can see
51:37 - i'm now at this pretty long path
51:40 - if i type ls let's cd into
51:44 - breakfast
51:45 - so that's a really common thing ls and
51:47 - then immediately after cd you you use ls
51:50 - to look around and then cd
51:52 - to change directories into something
51:53 - that you just found
51:55 - so now i'm in this folder breakfast and
51:57 - i've hit a dead end there's no more
51:58 - folders to cd into
52:00 - uh how would i back out right normally
52:05 - if i did the exact same thing so on my
52:07 - desktop with the graphical user
52:08 - interface it was
52:10 - meal diary is that right
52:13 - if i can find that
52:14 - i double click friday breakfast
52:17 - okay how do i go somewhere else well i
52:20 - have a bunch of options i can hit the
52:21 - back button i can use these buttons up
52:24 - top to jump around
52:25 - but here
52:27 - how do i go back with the cd command
52:29 - well the answer is to use cd followed by
52:33 - dot dot
52:34 - so two dots is a special path that
52:36 - indicates or it refers to the parent
52:38 - directory
52:39 - so it's how i can back up one folder
52:42 - right now i'm in breakfast
52:45 - if i cd
52:46 - dot dot
52:49 - now i've gone back one level into friday
52:53 - pwd you can see i'm in friday type ls
52:56 - this is the contents of the friday
52:58 - directory
52:59 - so that's how i can go back one level i
53:01 - can go back further
53:04 - and repeat it
53:06 - and now i'm back on my desktop
53:08 - now i can also instead of just cding
53:11 - into one folder at a time one level at a
53:14 - time i can jump to any location on my
53:17 - machine as long as i have the full
53:19 - correct path
53:21 - so if i wanted to go back to
53:24 - where we just were which was this
53:26 - location here right desktop meal diary
53:29 - friday slash breakfast i could do that
53:31 - in one step cd
53:34 - and then meal diary slash friday i'm
53:37 - using tab slash breakfast
53:39 - so i don't have to do three separate cds
53:42 - i can jump as many levels as i want and
53:45 - the same actually goes for moving
53:46 - backwards
53:48 - i don't have to do cd dot dots enter cd
53:50 - dot dot enter uh if i want to move back
53:53 - multiple levels i can chain it together
53:56 - i can do this this is one option
53:58 - so it's a little clunky to do it this
54:00 - way but it does work
54:02 - so this is going to take me back one
54:04 - parent folder and then its parent folder
54:06 - and its parent folder
54:08 - and now i type pwd i'm back on the
54:11 - desktop
54:12 - i can also pass in absolute path to cd
54:15 - so everything we've done has been
54:17 - relative to our current location but if
54:19 - i want to go to my documents folder well
54:22 - it's not here it's not in the desktop i
54:24 - can't do cd documents if i try
54:27 - it doesn't know what documents folder
54:29 - i'm talking about it's only looking in
54:31 - my current location and there's nothing
54:33 - called documents on the desktop my
54:35 - documents folder is located at this path
54:38 - it is slash home slash cult slash
54:42 - documents
54:44 - and i can jump right there it doesn't
54:46 - matter where i am i can run that command
54:48 - anywhere
54:49 - and i'll be able to get to documents i'm
54:51 - now in documents
54:53 - one other note around cd and path names
54:56 - you'll see this tilde that refers it's a
54:59 - shorthand
55:00 - that is eventually expanded into your
55:02 - home directory now it's kind of
55:04 - confusing because this is called home
55:06 - but the home directory for each user is
55:09 - a directory with their username so for
55:12 - me it's colt
55:13 - so if i cd to tilde
55:16 - and i do pwd it takes me to slash home
55:18 - slash colt if you cd to tilde it will
55:21 - take you to whatever your usernames
55:23 - folder is and this folder is a very
55:25 - important place it has the desktop it
55:28 - has documents downloads a whole bunch of
55:30 - stuff you can put your own things in
55:31 - here too but even just if you do nothing
55:33 - it contains a lot of important folders
55:35 - and documents
55:36 - uh so that's kind of the basics of cd
55:39 - you can cd into a location that's
55:41 - relative to where you are like
55:43 - desktop
55:45 - i can do multiple levels at once i can
55:47 - back out with cd.dot
55:49 - we combine it often with ls take a look
55:52 - around where do i want to go let's go
55:54 - into
55:55 - wildlife cd wildlife
55:58 - okay i got some stuff in here
56:00 - and
56:01 - i'm not gonna do anything with it let's
56:03 - back out and i can also pass an absolute
56:06 - path at any point uh which is again a
56:08 - full path name not relative to our
56:11 - current location
56:12 - so that is the cd command so next up i
56:15 - want to talk a little bit more about
56:16 - folder structure
56:18 - and how things are organized if you
56:20 - noticed when i talked about absolute
56:21 - paths all absolute paths started with a
56:25 - forward slash and the reason for this is
56:27 - that the very very highest level
56:30 - directory on our machine is the slash
56:34 - directory also known as the root
56:36 - directory which is really confusing
56:39 - people call this root but there's also a
56:42 - directory called root r-o-o-t
56:45 - definitely confusing uh in the same way
56:47 - that people refer to uh you know my home
56:50 - directory
56:52 - colt if that's my username that would be
56:54 - colt's home directory but there's also a
56:56 - directory called home
56:58 - it's uh yeah it's not the most
56:59 - straightforward thing so the top level
57:01 - directory is slash we can actually go
57:04 - there if we wanted to
57:06 - from anywhere on my machine i can do cd
57:08 - slash
57:09 - and if i take a look around
57:10 - we've got a bunch of stuff that we
57:12 - normally don't mess with at least not as
57:14 - a typical day-to-day user
57:16 - if you start writing scripts if you
57:18 - start doing admin stuff absolutely there
57:21 - are changes you can make here but we can
57:23 - look around there's a bunch of different
57:24 - files or folders and things called uh
57:27 - sim links that we'll learn more about
57:29 - later on in this video
57:31 - um and that's kind of all i'm going to
57:33 - show in this directory because there's
57:35 - just so much here
57:37 - uh but what i want to mention is that
57:39 - your desktop your documents your music
57:42 - your whatever files and folders you make
57:45 - typically are going to live inside of
57:48 - the home directory
57:50 - inside of your particular username
57:53 - so for me my username is colt we can
57:55 - always find that out if i need to it's
57:57 - also just right here in my prompt cult
58:00 - so i can go into the home directory
58:04 - i'll cd into that
58:06 - if i take a look around every user on my
58:08 - machine has their own unique home folder
58:12 - so carrots cult elvis and kitty
58:15 - let's take a look at kitty's directory
58:18 - whoops not kits
58:20 - kitty
58:21 - and you can see we've got desktop
58:23 - download documents pictures and all the
58:25 - stuff that we would expect i'll back out
58:27 - again
58:28 - and then i'll go into
58:30 - colt and this is where we've been
58:32 - working
58:33 - now
58:34 - i just wanted to reiterate how this all
58:36 - works slash is the root it's the top
58:39 - level directory on our machine we cannot
58:41 - go higher than that if i try and go to
58:44 - slash and then
58:45 - back out
58:47 - i'm not going anywhere i'm just staying
58:49 - right there at slash
58:51 - now as i said every absolute path starts
58:54 - with a slash because an absolute path is
58:56 - the full location
58:58 - the unique full location to reference a
59:01 - particular file or folder so it always
59:04 - starts with a slash
59:05 - now another character that we've talked
59:07 - about briefly is the tilde here which
59:09 - refers to your individual home directory
59:13 - so if i cd to tilde
59:15 - i'm logged in as colt that will take me
59:18 - to
59:19 - slash home slash colt as you can see
59:23 - right here
59:24 - okay
59:25 - and that's all i really wanted to
59:27 - mention around folder structure of
59:28 - course there's a lot more there's all
59:30 - these folders there's dozens of folders
59:32 - here that we're not going to discuss
59:34 - everything we're doing lives inside of
59:36 - our particular username home folder so
59:39 - slash home slash lily slash home slash
59:42 - colt
59:43 - and then remember this difference
59:44 - between relative and absolute paths if i
59:47 - wanted to go
59:48 - let's see where am i right now
59:50 - i am in my home directory if i want to
59:52 - go on to my desktop from here i can just
59:55 - cd into desktop that is relative to my
59:58 - current location but as we talked about
60:01 - that only works if i am in a place where
60:04 - i can view the desktop it's it is in my
60:06 - current folder so basically the only
60:09 - place this would work is from my home
60:11 - directory right here
60:13 - but if i go to slash i'm not going to be
60:16 - able to just cd into desktop
60:19 - i can't auto complete there is no
60:21 - desktop right here
60:23 - so i need to use an absolute path and i
60:25 - could do the full long name cd slash
60:28 - home slash cold
60:30 - slash
60:31 - desktop like that
60:33 - or i can do the slightly shorter version
60:36 - use that tilde character which refers to
60:38 - my home directory slash desktop
60:41 - okay
60:42 - moving on the next command we'll cover
60:44 - has to do with making directories or
60:46 - making folders it is mkdir or make deer
60:51 - mcdurr
60:52 - however you want to pronounce it
60:54 - it is short for make directory
60:56 - and that's exactly what it does it's the
60:58 - command we use to make folders
61:00 - so the basic way we run it is make
61:02 - directory or make deer space and then
61:05 - some folder that we want it to create
61:06 - for us and it will create that folder so
61:10 - let's try it i'm going to cd just onto
61:12 - my desktop
61:15 - i'm going to clear control l
61:17 - and i'm going to make a new folder here
61:19 - i'm going to make a folder called
61:21 - greenhouse i have a new greenhouse
61:23 - actually and
61:25 - i need to manage the crops that i'm
61:28 - growing and starting seeds and bills and
61:31 - maintenance and time sheets for
61:33 - employees i don't know that's just
61:34 - that's the story i'm going with
61:36 - i'm going to make a folder called
61:37 - greenhouse on my desktop so i'm on the
61:39 - desktop right pwd there's no folder
61:42 - called greenhouse you can see it's
61:44 - alphabetical there's it goes from great
61:46 - gatsby grep exercise keys
61:48 - so if i run make directory
61:51 - and then greenhouse
61:53 - if that's the name of the folder i want
61:55 - it to make me i'll hit enter
61:57 - we don't see anything happen
61:58 - but if i type ls again
62:01 - we now have a folder called greenhouse
62:03 - and if i just move this out of the way
62:06 - you'll see on my desktop there's
62:08 - greenhouse it's totally empty it's an
62:10 - empty directory
62:11 - so i can cd into that folder
62:14 - and that's exactly what i'll do cd into
62:16 - greenhouse oops i hit enter too early
62:19 - green house there we go i use tab
62:22 - complete again
62:23 - and now i'm in here
62:25 - so we can also make multiple folders at
62:26 - once you just separate their names by
62:28 - spaces
62:30 - so i'm going to make
62:31 - a winter and summer directory inside of
62:34 - greenhouse make directory winter
62:37 - and summer
62:38 - so i can have you know different
62:39 - schedules for what i'm growing in summer
62:41 - and winter
62:43 - i'll type ls and we see those two
62:45 - folders were just created for me in my
62:47 - current location right that's all i
62:49 - specified was summer and winter i didn't
62:52 - say any fancy path
62:54 - but what i can do
62:55 - is actually provide
62:57 - if i wanted to make inside of summer i
62:59 - wanted to make a folder called
63:02 - how about you know seeds
63:04 - i could do make directory
63:07 - summer
63:08 - slash
63:09 - seeds
63:11 - so i'm inside of greenhouse but i'm not
63:13 - inside of summer
63:14 - so in other words i'm right here in this
63:17 - folder
63:18 - i'm not going to go into summer and then
63:20 - make a folder in two separate steps i'm
63:22 - doing it in one step i just provide a
63:24 - path
63:25 - make the seeds directory instead of
63:26 - summer i'll hit enter
63:29 - okay
63:30 - type ls i don't see it
63:32 - but if i do ls summer
63:35 - there we are i'm looking inside that
63:37 - summer directory
63:39 - there's my seeds folder
63:41 - okay
63:42 - now one last thing i'll show you there's
63:45 - an option that's pretty common which is
63:47 - dash p
63:48 - which allows us to make nested folders
63:51 - so why don't we just take a look at the
63:53 - man page man for make directory
63:56 - and we'll scroll down
63:58 - here's p
63:59 - or the long form dash dash parents
64:02 - it says no error if existing make parent
64:04 - directories as needed
64:06 - so let me show you what it means when it
64:08 - says no error
64:09 - so inside of the winter folder which
64:12 - i'll just point out here
64:14 - graphically i want to make a seeds
64:16 - folder and instead of seeds i want to
64:18 - make a
64:19 - lettuce folder
64:21 - so if i try and do that all at once i'm
64:23 - inside of greenhouse if i do make
64:25 - directory winter slash seeds let me just
64:28 - expand this window a bit here
64:32 - winter seeds slash
64:34 - did i say spinach no i said lettuce
64:36 - if i hit enter here
64:38 - i get an error it says can't create such
64:41 - directory it runs into a problem because
64:43 - it expects that winter slash seeds
64:47 - already exists and it thinks it just
64:49 - wants us or we just want it to make
64:50 - lettuce that's not the case i want it to
64:52 - make seeds and lettuce
64:54 - but seeds doesn't exist it freaks out
64:57 - but that's where the dash p option comes
64:59 - in so make directory dash p
65:02 - winter
65:03 - seeds
65:04 - slash lettuce we're now telling it make
65:07 - any of the needed parent directories
65:08 - along the way to make this lettuce
65:10 - directory
65:12 - we don't get an error and if i type ls
65:14 - here we don't see anything but if i do a
65:17 - lswinter
65:19 - we see seeds if i do ls winter seeds we
65:23 - see lettuce so it successfully made that
65:25 - nested
65:26 - directory and any necessary directories
65:29 - along the way
65:30 - so here's we go back winter
65:33 - it made me seeds and inside of that it
65:35 - made the lettuce so that's the dash p
65:38 - option and that's really all there is to
65:40 - make directory so mkdir followed by
65:43 - whatever directory you want it to make
65:44 - and some location for that directory
65:47 - often it's just your current location
65:49 - but you can provide a path a destination
65:52 - as well so if i wanted to make something
65:53 - all the way back in my home directory
65:56 - which again i can use tilde as a
65:59 - shortcut i could say make directory
66:01 - tilde slash
66:03 - blah blah i'm going to delete this once
66:05 - i learn how to delete folders
66:07 - i won't see anything here
66:09 - but if i go all the way back to my home
66:11 - directory
66:12 - there it is
66:13 - right there
66:14 - so we can provide a relative path an
66:16 - absolute path we just give it some
66:18 - destination to make a folder and it
66:20 - makes it for us that's make directory
66:22 - the next command we'll cover is touch so
66:24 - touch unlike most of the other commands
66:26 - doesn't really tell you a lot about what
66:28 - it does or its name doesn't indicate its
66:31 - most common use make directory makes a
66:33 - directory uh you know change directory
66:35 - changes directory touch is used most of
66:38 - the time at least to create files
66:41 - so there's no create file or make file
66:44 - it's just touch so uh we'll talk about
66:47 - where that name comes from in a moment
66:49 - but let's just try using it if we run
66:51 - touch and we provide it with a file name
66:53 - that doesn't yet exist it will make that
66:56 - file for us so let me go to my desktop i
66:59 - made a greenhouse folder
67:01 - deny and then summer and winter let's cd
67:03 - into summer
67:05 - cd into seeds and let's make some files
67:08 - here
67:09 - so let me clear my screen i'm going to
67:11 - make a file in here there's nothing at
67:13 - the moment i'm going to make a file
67:14 - called
67:15 - how about squash
67:17 - so squash i'm going to have a file full
67:19 - of different types of squash seeds i
67:21 - guess so if i just run squash as is
67:24 - that's totally fine
67:26 - squash if i type ls it made that file
67:29 - for me i'll just show it to you also
67:31 - visually if i go to my desktop
67:34 - i'll go to greenhouse if i can find it
67:37 - summer seeds here's my empty squash file
67:40 - i can open it it's completely empty
67:44 - okay so that's one option
67:46 - i can also provide
67:48 - an extension as i'm making a file so if
67:50 - i want to make a txt file i can do dot
67:52 - txt so let's make another one how about
67:56 - berries how about just melon
67:59 - another summer fruit
68:00 - dot txt
68:03 - and i now have a txt file called
68:05 - melon.txt
68:07 - now it's important to note that the
68:09 - extension you provide it does depend on
68:11 - the exact operating system you're
68:13 - running but the extension does not
68:14 - indicate
68:16 - it doesn't it's not what's used to
68:17 - determine the actual file type
68:20 - of a brand new file so these are all
68:22 - empty files i could make a pdf file if i
68:24 - wanted to touch
68:27 - apple.pdf
68:29 - it's not really summer but
68:31 - if i type ls we've got an apple.pdf
68:34 - but they're all just completely empty at
68:36 - this point if i look at any of these
68:38 - files they are just plain old empty
68:41 - files at the moment
68:42 - of course i can put stuff in them i can
68:44 - change that extension there's all sorts
68:45 - of things we can do so let's try another
68:48 - example i'm on my mac here
68:50 - i'm going to touch multiple files so in
68:53 - this directory it's called colors i have
68:55 - a colors.txt file i'm going to make a
68:58 - couple of new files let's go with red
69:01 - dots pdf
69:03 - and then a space orange dots
69:07 - let's see how about png and then yellow
69:10 - we'll do a different extension here how
69:12 - about
69:13 - an excel xls
69:15 - i type ls
69:16 - those files were created they're all
69:18 - completely empty
69:20 - now here is i'm on my mac this is finder
69:23 - the graphical
69:25 - user interface i've got red.pdf
69:28 - orange.png
69:29 - if i try and open one of these just with
69:31 - my mouse
69:33 - on a mac it does try and use preview it
69:36 - does think that it's a pdf and it says
69:38 - it's empty i don't know what to do with
69:39 - that
69:41 - if i try and do a pdf
69:43 - it does use a pdf reader or pdf viewer
69:47 - but again this is just on my mac if i go
69:49 - back to ubuntu here and i open up a pdf
69:53 - it just opens in a text editor if i open
69:56 - up if i make a png file touch what's
69:59 - another fruit how about barry.png
70:04 - if i try and open that
70:06 - oh it uses the text editor as well okay
70:09 - so it does vary from one system to the
70:10 - next
70:11 - but the point is we just make empty
70:13 - files with touch now let's talk about
70:16 - when we provide a name of a file that
70:17 - already exists
70:19 - so if i run touch barry again i can do
70:23 - that i can just hit the up arrow
70:25 - it's
70:26 - not going to seem like it does much it
70:28 - doesn't make me a second file with the
70:30 - same name that would be a problem what
70:32 - it does instead is that it actually is
70:34 - going to update the timestamp of the
70:37 - file
70:38 - so it touches it if we run man
70:42 - touch
70:43 - always a fun command to type out man
70:45 - touch
70:46 - uh it actually says its main purpose is
70:49 - change file timestamps update the access
70:52 - and modification time of each file that
70:53 - we provide
70:55 - so it says here secondarily a file
70:58 - argument that does not exist is created
71:00 - empty
71:01 - so that's why it's called touch rather
71:03 - than make full make file or create file
71:06 - or something its main purpose at least
71:08 - historically is to change the access and
71:10 - modification times of a file
71:12 - and then oh also if that file doesn't
71:14 - exist it will make it as an empty file
71:18 - so how do we know or how can we view the
71:20 - access and modification times if we
71:23 - remember ls-l that flag if we take a
71:26 - look at
71:27 - barry.png here
71:29 - right there
71:30 - october 15 1348 is the modification time
71:35 - that's ls dash l is the long listing
71:37 - format so 1348 let's see it's now 13.50
71:42 - so if i try and touch barry.png again
71:45 - and i do ls-l
71:47 - we now see it's showing october 15th
71:50 - 1350.
71:52 - so it does in fact update that
71:53 - modification time
71:55 - but most of the time 99 of the time that
71:57 - i use touch it's to make files uh and i
72:00 - can make a bunch of them at once as we
72:01 - saw just provide a bunch of file names
72:03 - separated by spaces and it will make
72:05 - them for you
72:06 - okay so we saw how to make files and
72:08 - make folders let's talk about destroying
72:11 - things so to delete a folder we can use
72:13 - the rmdir remove directory command rmdir
72:17 - followed by the name of a folder or a
72:19 - path to a folder that we want to delete
72:21 - or multiple separated by spaces however
72:24 - this will only work if the folder is
72:26 - empty
72:27 - so over here
72:29 - uh i've got
72:31 - i don't have any folders let's make a
72:32 - folder make directory uh delete me in
72:36 - all caps
72:37 - there it is to delete it one option is
72:39 - rmdir
72:41 - delete me i type ls and it's gone
72:45 - but if i back out
72:46 - and i try and delete
72:48 - the seeds folder which is not empty
72:51 - rmdir seeds
72:54 - we get an error failed to remove seeds
72:56 - directory is not empty
72:58 - and that's really all there is to rm
72:59 - deer it removes empty directories only
73:02 - empty directories we'll see another
73:04 - command we can use to remove directories
73:06 - that have stuff inside of them so next
73:08 - up we're going to talk about the rm
73:10 - command rm for remove let's take a look
73:14 - at the man page it says we can use it to
73:16 - remove files or directories
73:19 - so we saw how to use rm deer it only
73:22 - works to remove an empty directory i've
73:24 - got this seeds directory rmd or seeds
73:27 - no luck it's not empty alright
73:30 - so this is where the rm command comes in
73:32 - i'm going to show you how to use it to
73:34 - delete directories in just a moment but
73:36 - we're going to start by deleting files
73:38 - so i'm just going to make a couple files
73:39 - with touch
73:41 - uh how about cat dog carrot
73:44 - um blue
73:46 - all right so i have these four files now
73:49 - i can delete them using rm followed by
73:52 - let's do blue to start uh the name of a
73:55 - file
73:56 - and that's it it is gone now it's very
74:00 - important to note uh there is no
74:02 - intermediate recycling can or trash can
74:04 - or something some sort of bin we can go
74:06 - find all these files we've deleted they
74:09 - are just completely gone they're just
74:11 - vanished from our entire uh system
74:14 - so that can be uh a bit of a scary thing
74:17 - if you're not careful with what you're
74:19 - deleting so you definitely want to make
74:21 - sure you're only ramming things that you
74:23 - mean to rm but the flip side of that is
74:26 - that it's very
74:27 - fast powerful quick and easy to delete
74:29 - things uh just as long as it's not too
74:32 - easy and you slip up
74:34 - so we can delete multiple things
74:35 - multiple files if we just separate them
74:37 - with spaces of course like that carrot
74:40 - cat and dog are all gone
74:42 - so that's the basic use of rm
74:46 - i'll show you one more there's a couple
74:47 - of flags i want to talk about the first
74:49 - flag is dash v
74:51 - this is actually a trend there are many
74:53 - commands that support a dash
74:55 - v for verbose that option in the case of
74:59 - ram will give us some verbose output
75:01 - that that basically explains what it did
75:03 - if you notice here we run it we deleted
75:06 - three things but there's no feedback
75:08 - it's just silently deleting them
75:10 - we had to look to see are they gone well
75:13 - if we use dash v i'm just gonna remake
75:15 - my uh
75:17 - four files again
75:18 - if i use dash v so rm carrot cat dog
75:22 - dash v for verbose
75:24 - now it just tells me what it does each
75:26 - step of the way removed carrot removed
75:28 - cat removed dog
75:30 - pretty straightforward hopefully
75:32 - but the end result is exactly the same
75:34 - you do not need to have that of course
75:36 - it's just something you may want to use
75:38 - some people like to use it
75:40 - and like i said there are other commands
75:41 - like when we see copy cp and move mv
75:45 - we can use dash v for verbose output and
75:48 - it will tell us just copied this file i
75:51 - you know moved this file renamed this
75:54 - file removed okay
75:56 - so
75:57 - that's one flag dash v the next thing i
76:00 - want to talk about is using rm to delete
76:02 - a directory
76:04 - so we talked about rmd or does not work
76:06 - on seeds or any folder that is not empty
76:10 - so that must mean rm will work right
76:12 - let's rm seeds
76:14 - oh no cannot remove seeds is a directory
76:18 - but i thought the whole point was you
76:19 - know rm could delete a folder that has
76:21 - stuff in it
76:22 - yes that is the point uh but we have to
76:25 - use a flag
76:26 - and the flag we need to use is the r
76:29 - flag for recursive so if i do man rm
76:32 - again
76:33 - i'll scroll down
76:35 - a little bit further
76:36 - r so we can do lowercase r uppercase r
76:39 - or dash dash recursive if you really
76:41 - have a lot of time to spend
76:44 - and what this will do is it tells the rm
76:45 - command to remove directories and their
76:48 - contents so that could be other
76:50 - directories and further nested
76:51 - directories there could be hundreds of
76:53 - levels of directories nested down
76:55 - remove them all
76:57 - so here's how we would use it if i want
76:59 - to remove the seeds directory this is
77:01 - what it has inside remember
77:04 - it has four files
77:06 - and i want to remove that entire
77:08 - directory it's just
77:09 - rm-r seeds
77:13 - and once again there's no feedback i
77:15 - could have added dash v and it would
77:16 - tell us more but now it is completely
77:19 - gone
77:20 - that's it
77:21 - so i'm going to make a directory again
77:23 - we'll call this
77:24 - zoo
77:25 - let's cd into zoo i'm just going to
77:27 - touch some random let's see animals cat
77:30 - dog
77:31 - snake
77:33 - i don't know jaguar
77:35 - okay
77:36 - so uh i have that zoo directory now i'm
77:39 - going to back out again
77:41 - this time i'm going to delete it with
77:43 - rm-r
77:45 - but i'm also going to show you a new
77:46 - flag dash i
77:48 - for interactive and interactive
77:51 - is going to prompt us and ask us if we
77:54 - want to delete each file or not so if we
77:56 - do dash i here
77:58 - and then the folder which in this case
78:00 - is zoo
78:02 - now it's asking me do you want to
78:03 - descend into this directory zoo so do we
78:05 - want to go inside and see what's there
78:07 - i'm going to say y for yes or if i said
78:09 - no then we kind of end it all but i'll
78:11 - do y
78:12 - do i want to remove regular empty file
78:15 - snake
78:16 - yes
78:17 - cat y for yes
78:19 - let's keep jaguars i'm going to say no
78:22 - dog
78:23 - yes
78:24 - and now it's asking me do you want to
78:26 - remove the directory zoo uh i'm going to
78:29 - keep it
78:31 - so that interactive mode allows me to
78:33 - make decisions uh if you're deleting you
78:35 - know 10 000 files maybe not the best
78:37 - option but
78:38 - that is a flag we can use dash i to
78:41 - interactively decide what to delete and
78:43 - what to keep
78:44 - so now if i look at zoo
78:47 - it only has the jaguar file inside
78:51 - one more quick demo i want to show you
78:53 - i have a
78:54 - let's see where did i put that my
78:56 - desktop a directory called meals
78:59 - and inside of meals i made 52 folders
79:04 - one for each week of the year and inside
79:06 - of each week if i just pick one like
79:08 - week 35
79:10 - there is a folder for each day of the
79:12 - week and for each one of those days
79:15 - there are three files breakfast lunch
79:17 - and dinner dot txt so we've got three
79:20 - files for each day of the week for 52
79:23 - weeks of the year it's a lot of
79:24 - files and folders nested i'll show it to
79:27 - you here so this is the meals
79:30 - directory
79:31 - all these different weeks
79:33 - pick one
79:34 - pick another day all those files so
79:36 - there's a lot of stuff going on here and
79:38 - i just wanted to show you that i can
79:39 - delete the entire thing very easily and
79:42 - very quickly all those nested folders
79:44 - and files using rm so i'm going to cd
79:46 - back a couple levels
79:49 - one more and one more
79:52 - just to reiterate you know i don't need
79:54 - to do cd dot dot cd dot cd dot dot to go
79:57 - back three levels i could have done
80:01 - that right there
80:02 - or i could have just said take me to the
80:05 - desktop specifically
80:07 - so this would work from anywhere
80:10 - this cd dot dot cd dot dot cd dot dot
80:13 - only works if i'm three levels away you
80:15 - know three levels burrowed down from the
80:17 - desktop if that makes sense this will
80:20 - work from anywhere
80:21 - anyway
80:22 - i have this meals directory i'm going to
80:24 - remove it i need to do a dash r
80:26 - and i'm going to make it verbose so you
80:28 - can see exactly how many things it
80:31 - removes in a single go so this is just
80:33 - one command remember no recycling bin no
80:35 - trash can these files are gone so you
80:38 - obviously want to be careful but here we
80:39 - go rm dash r for recursive so we can
80:42 - delete a directory that has stuff in it
80:44 - and dash v for verbose
80:47 - and
80:48 - if i scroll up i'm going to be scrolling
80:50 - for a long time
80:51 - lots and lots of files and folders
80:53 - deleted in a split second so that's the
80:56 - rm command it also does work to remove
80:59 - empty directories
81:00 - so um in that sense you kind of never
81:03 - have to use rm deer i just show it as a
81:07 - quick you know command that you may
81:08 - encounter some people like it
81:11 - because
81:12 - you know that you're not going to be
81:14 - accidentally deleting stuff that has a
81:15 - bunch of contents inside of it but you
81:18 - could just use the rm command in general
81:20 - to delete files delete empty folders or
81:23 - delete folders full of a bunch of stuff
81:25 - as long as you use the dash r option all
81:28 - right so that is rm the next command
81:31 - i'll show you is one i use all the time
81:32 - on my mac it's called open
81:35 - and it will open a folder open a file
81:39 - outside of the terminal in the the sort
81:41 - of graphical world of our machine so if
81:44 - i make a bunch of files
81:47 - like uh
81:48 - i don't know how about purple i'll just
81:50 - make one dot txt if i now want to
81:53 - do something with that file i don't know
81:55 - i want to view it in finder well i could
81:58 - navigate to it and figure out where this
81:59 - is or i can do open
82:02 - i could do open dots that will open the
82:04 - current directory and here we go a
82:06 - finder window with that directory but i
82:09 - could also say open that particular file
82:12 - and it opens it up in the default
82:14 - application which is just a text editor
82:16 - on my mac
82:17 - but if i had some other file you know i
82:19 - can find an example here
82:21 - if i go to my desktop which i edited out
82:24 - i've navigated here i've got a file uh
82:26 - let's see
82:27 - i've got a pdf file if i open that
82:32 - it opens it up in my case using a pdf
82:34 - editor the
82:36 - default you know what it would open with
82:38 - if i double clicked anyway so that's the
82:40 - open
82:41 - command but it is mac specific so again
82:44 - i can do things like open dot to open
82:45 - the current directory i can see all my
82:47 - files and you know work with them here
82:49 - if i need to
82:50 - i can open a particular file and it's
82:53 - pretty smart
82:55 - but if i try this on ubuntu here
82:59 - i've got two directories here if i try
83:01 - and open that it's going to complain to
83:03 - me it can't do it it doesn't know that
83:05 - command
83:06 - now there is an alternative which is x d
83:08 - g dash open
83:11 - and uh there we go it opens up you know
83:13 - in this case this folder for me
83:15 - if i have a file just call it touch
83:18 - tomato.js
83:20 - if i do xdg dash it's a bit of a
83:23 - annoying one to type but
83:25 - open tomato
83:27 - it opens up the text editor and i can
83:30 - start working on this file
83:32 - now you may need to install it just to
83:34 - be clear i think if on wsl here if i try
83:37 - xdg open dot
83:39 - well i need a dash there
83:42 - it complains and it tells me i need to
83:44 - install it using this command so you can
83:47 - install that if you want
83:49 - but this is one of the main differences
83:50 - here open is a mac only command it might
83:53 - be one of the i think it's the only one
83:54 - we cover in this video that is different
83:57 - between mac and ubuntu or linux the next
83:59 - command we'll look at is mv for move
84:02 - this is how we can move files around
84:05 - it's also how we can rename files and
84:07 - that's going to be the first use case
84:09 - i'll show you if we run mv
84:11 - followed by an existing file and then a
84:14 - space and then a new file name
84:16 - what this will do is
84:18 - move pair
84:20 - turn it into new pair it will rename it
84:23 - so let's try an example here
84:25 - uh oh got a lot going on here why don't
84:27 - i make a new directory in here i'll just
84:29 - call this um commands
84:32 - i'll cd into there okay
84:34 - i'm gonna make a file in here and i'm
84:36 - gonna call this my journal
84:39 - but i spell it wrong like that
84:41 - and i wanna rename it i can use move let
84:45 - me just show you there it is i can use
84:47 - move and then the incorrect name
84:49 - journal.txt
84:51 - and then the new one
84:53 - just like that
84:54 - and again you may not get this verbose
84:56 - output that's just a setting i have but
84:59 - if we type ls we see journal.txt
85:03 - now if you do want that verbose output
85:05 - just for any of these commands
85:08 - like
85:09 - rm if i do m
85:11 - v i get the man page for mv
85:13 - there's an option in here
85:15 - further down
85:17 - dash v which explains what is being done
85:19 - so if you want to know exactly what's
85:21 - going on let's say i want to rename
85:24 - journal
85:26 - the correct version i want it to now be
85:28 - an uppercase j i don't know why
85:31 - if you add dash v
85:33 - which mine have by default you'll get
85:35 - that verbose output honestly i only put
85:37 - that in there when i'm teaching so
85:38 - people can see what's going on i don't
85:40 - really care to get that confirmation it
85:43 - yeah it's gonna work either way and we
85:45 - can see it's been renamed
85:47 - now we can also use move to change the
85:50 - location uh not just rename you know in
85:52 - the same directory but to move a file
85:55 - back a directory or into a completely
85:57 - different directory
85:58 - so let's find an example of that let's
86:00 - just make a directory here i'll call
86:02 - this one
86:05 - i don't know
86:06 - stuff and i realized shoot i really
86:09 - should have made that journal file
86:11 - inside of stuff
86:12 - well i can move it in there it's pretty
86:14 - easy i can just do move
86:17 - the thing i want to move and then
86:20 - the move command is smart enough to know
86:22 - that if the last parameter the last
86:24 - argument is a folder
86:26 - it will be the destination folder so i
86:28 - can move
86:29 - journal into stuff
86:32 - and if i type ls i don't see journal
86:34 - anymore if i look inside of stuff
86:37 - it's inside our journal is inside of
86:39 - stuff
86:41 - i can also do that to multiple files at
86:42 - once
86:43 - so if i touch
86:45 - i don't know about pi and
86:49 - cake and cookie
86:51 - sure i have these three files if i want
86:53 - to move them into stuff i can do mv cake
86:57 - cookie pie and then as long as stuff
87:00 - comes last it will be the destination
87:02 - folder
87:04 - and there we go they are moved into
87:07 - stuff
87:08 - now there's more you can do with move
87:10 - you can move folders around you can
87:12 - rename folders so if i want to rename
87:14 - stuff instead to be stuff in all caps
87:18 - move stuff to be stuff
87:22 - there we go i just renamed it
87:24 - um so yeah that's probably all i'll show
87:26 - you for move it's pretty powerful i use
87:28 - it all the time to move things around
87:30 - you know i could move this entire stuff
87:31 - directory onto the desktop if i wanted
87:34 - to
87:35 - i could do
87:36 - move
87:37 - stuff
87:38 - and then just have it go back
87:40 - one directory right now i'm on this
87:42 - commands folder i want it to go onto
87:43 - desktop
87:45 - it's not here anymore i'll cd back
87:48 - and here it is on my desktop somewhere
87:51 - there it is this is the one the
87:52 - uppercase stuff all right so let's move
87:55 - the next command i'll cover is cp which
87:57 - is for copy we can use this to copy a
88:00 - file or even copy folders
88:02 - so if i make some file
88:04 - i'm on my desktop here there's just too
88:06 - much stuff going on
88:08 - let's go back to my stuff directory
88:11 - okay so i've got this journal file
88:14 - if i want to make a new copy of it let's
88:16 - say for today's journal sure i'm going
88:19 - to copy it i can do cp
88:22 - the thing i'm copying which is journal
88:24 - and then the destination for the copy so
88:27 - if i wanted to be in the same folder
88:29 - then i don't need to do anything just
88:30 - provide a name so how about
88:32 - today's
88:34 - today journal or something like that
88:37 - and that makes me a copy
88:39 - so i have journal and i have
88:41 - todayjournal.txt
88:43 - now these are all empty
88:45 - so it's not that useful to show but
88:48 - if they had content inside of them
88:50 - like i'm on my mac here i have this
88:53 - linuxcommandhandbook.pdf
88:55 - if i want to make a copy of that cp
88:58 - linuxcommandshanbook.pdf
89:00 - and just give it a new name how about
89:04 - handbook
89:05 - dot pdf
89:07 - just like that
89:09 - if i type ls well there's gonna be a lot
89:10 - of stuff on here but there is a
89:13 - handbook.pdf file
89:15 - and if i open it up
89:17 - or just yeah i'll open it sure
89:20 - you'll see that it is a full copy so
89:23 - it's the entire linux handbook here all
89:25 - these commands we've been covering so it
89:27 - doesn't just copy empty files that's
89:29 - very important we can also copy entire
89:31 - directories so let's go back to ubuntu
89:34 - where are you here we are
89:36 - i've got this stuff directory why don't
89:39 - we copy the entire stuff directory
89:41 - so uh cp
89:43 - stuff
89:44 - and then i want to make a directory
89:46 - called stuff
89:47 - copy
89:48 - well if i try that
89:50 - we have a problem it says dash r not
89:53 - specified omitting directory stuff it's
89:55 - not going to copy this
89:57 - well if we take a look at the man page
89:59 - for cp
90:00 - it tells us if i scroll down there is a
90:03 - dash r option
90:05 - which just like with remove rm stands
90:07 - for recursive so if we want to copy the
90:10 - contents of a directory and any nested
90:12 - directories and their contents and so on
90:15 - we need dash r
90:17 - so let's replace this let's rerun it one
90:19 - more time cp dash r
90:22 - stuff
90:23 - stuff copy i have that dash v verbose on
90:27 - by default again you can turn that on if
90:30 - you want or you can just run it with
90:32 - dash v if you really want this output
90:34 - but here we can see it made a copy of
90:36 - the stuff folder
90:38 - and all of its contents so if we take a
90:40 - look here's my stuff copy
90:45 - and inside of it
90:47 - we have all of these files that have
90:48 - been copied as well
90:50 - so we can make copies like that i can
90:52 - also move as i'm creating a copy so if i
90:55 - want a copy of i don't know song of
90:57 - myself
90:58 - and i want it to go inside of
91:00 - stuff copy
91:02 - or instead of stop whatever let's go to
91:04 - my desktop
91:06 - i could do copy song is it capitalized
91:09 - yes it is song of myself long poem and
91:12 - uh let's actually put it
91:14 - uh sure let's put it inside of stuff so
91:16 - stuff slash and then i'm gonna call it s
91:19 - o song of my self sure psalms dot dxd
91:24 - all right so i'm gonna copy it but i'm
91:27 - also moving it at the same time because
91:29 - where i'm copying it to is a different
91:31 - destination
91:32 - i won't see psalms in here if i look in
91:35 - stuff
91:36 - cd into stuff
91:39 - nope where did i put it
91:41 - well wow i'm an idiot i put it inside of
91:44 - stuff with lowercase how confusing it's
91:47 - not in here it's going to be in this one
91:49 - so if i cd into lowercase stuff
91:53 - there it is
91:54 - soms.txt all right so it is there
91:57 - and that is a copy of that file so that
92:00 - is the cp command the next command we'll
92:02 - take a look at is called head so let's
92:04 - look at the man page for head it says
92:07 - that it outputs the first part of files
92:09 - head and tail
92:11 - are often used to refer in programming
92:13 - to
92:14 - two different ends of a structure in
92:16 - this case a file the head of a file is
92:18 - the beginning the tail would be the end
92:21 - so it's a really simple command it just
92:23 - prints out
92:24 - by default i think it is the first the
92:26 - first 10 lines of a file
92:29 - but we can actually specify an exact
92:31 - number using the dash n option but let
92:34 - me just show you uh so i've got this
92:36 - very long file
92:38 - in here which is song of myself.txt it's
92:41 - like hundreds of lines of long poem uh
92:44 - if i run head
92:46 - song of myself.txt
92:48 - it just outputs the first 10 lines
92:52 - now as we saw i can provide the dash n
92:54 - option followed by a number like 100
92:58 - and it prints the first 100 lines
93:01 - from the beginning of the file
93:03 - so there we go 100 lines and that's kind
93:05 - of all that there is to head
93:07 - now there's also a command called tail
93:10 - let's look at man tail
93:13 - and it unsurprisingly probably outputs
93:15 - the end of a file so by default it's the
93:18 - last 10 lines
93:20 - but we can also provide an exact number
93:22 - using dash n
93:24 - uh and there are some other options here
93:26 - as well but let's just start with that
93:28 - so i'm going to do
93:31 - tail
93:32 - song of myself.txt here are the last 10
93:36 - lines of song of myself
93:38 - but i can also say i want the last 20
93:40 - lines
93:41 - and there we are i get the last 20. now
93:44 - with tail i'm on my mac now
93:47 - there's one option that we don't have
93:48 - with head which is dash f where are you
93:52 - here we are
93:53 - dash f it says it causes tail to not
93:56 - stop when the end of file is reached but
93:58 - rather to wait for additional data to be
94:00 - appended to the input
94:02 - basically it's going to read the end of
94:05 - a file and print it out but then also
94:08 - keep printing out any new additions to
94:10 - the end of that file this can be useful
94:12 - for log files output files error logs
94:15 - things that are changing and you want to
94:16 - monitor them if i just do tail
94:19 - this is a on a mac at least this
94:21 - system.log file it doesn't matter
94:24 - really but it's a file that contains a
94:26 - bunch of stuff i honestly don't know
94:28 - what half of it is
94:29 - and if i don't have that dash f option
94:32 - it just stops this is the last thing
94:34 - printed out but if i add that dash f in
94:37 - there
94:38 - whoops i need to make sure i put dash f
94:40 - in there first
94:41 - now
94:42 - my prompt does not come back
94:44 - this file is being printed out the end
94:46 - of it is being printed out and if i do
94:49 - something that would add to that log
94:50 - file if i i may i make a new window like
94:53 - i just did i'll do it again
94:55 - you can see that that log file is
94:58 - changing content is being appended to it
95:00 - so i'm getting a live and as i close as
95:02 - well you can see things are changing i'm
95:04 - getting a live update as i make a new
95:06 - process or i kill a process
95:09 - from this system.log file
95:12 - whereas if i had just i can get out of
95:13 - here by the way ctrl c
95:15 - but if i had just done tail without dash
95:18 - f
95:20 - it's not live it just stops it shows me
95:22 - exactly what's at the end of that file
95:24 - right now but with dash f it keeps
95:26 - listening and keeps updating the output
95:29 - so that's tail so the next command i'm
95:31 - going to show you is one that i don't
95:33 - really use very much
95:34 - i'm showing it to you actually because
95:36 - it helps illustrate some other concept
95:38 - so the command i'm going to show you is
95:40 - called date it's really straightforward
95:42 - d-a-t-e
95:43 - and it just prints out the current date
95:46 - and time
95:47 - let's see i'm sure there's some other
95:49 - options and different things we can do
95:51 - we can specify how it should
95:54 - display the dates
95:56 - honestly we're not going to go into it
95:57 - because as i mentioned i don't use very
95:59 - much it can be useful though if you're
96:01 - writing a script
96:02 - and you need to get access to the
96:04 - current time or the current date day of
96:06 - the week that sort of thing
96:07 - anyway the reason i'm showing it to you
96:09 - is because i'm using it to illustrate
96:11 - something that is not a standalone
96:13 - command we're going to talk about
96:14 - something called redirection
96:16 - so this greater than sign right here
96:19 - we can use to perform something called
96:22 - redirecting standard output
96:24 - so the date command or really any of the
96:26 - commands we've seen if i do ls
96:29 - not la
96:30 - ls
96:31 - or i do date or pwd
96:35 - all of these
96:36 - generate output and that output by
96:38 - default shows up in our terminal right
96:40 - it's printed out as text here
96:43 - but we can actually redirect where that
96:45 - information goes uh by sending it to a
96:48 - file if we wanted to
96:50 - so i can take the current date
96:52 - and store the result instead of printing
96:55 - it out store it in a file and to do that
96:57 - i use the greater than sign again what
96:59 - we're doing here is redirecting standard
97:02 - output
97:03 - okay
97:04 - so let's make a file i'll show you we
97:07 - don't actually have to make a file first
97:08 - but i'm going to make an empty file i'll
97:10 - call it
97:11 - today.txt
97:12 - uh there it is today.txt all right so
97:16 - what i'm going to do next is redirect
97:18 - date
97:19 - so again the date command
97:21 - greater than sign
97:23 - today.txt and this tells the terminal
97:26 - run this command first but whatever
97:28 - output we get don't just print it out
97:30 - instead we're redirecting the output
97:32 - to this file
97:34 - okay
97:35 - and we don't see any output nothing is
97:38 - printed out
97:39 - if i type ls there we are we see today
97:41 - is still there
97:42 - now in a moment i'm going to show you a
97:44 - command we could use to read this file
97:46 - very easily but we do know head we've
97:48 - already seen that so i could do head
97:50 - today.txt
97:51 - and take a look we see that it contains
97:54 - that text
97:55 - so what do you think will happen if i
97:57 - recall this line
97:59 - and i run it again
98:01 - so take the current date whatever that
98:03 - is that output and send it over to this
98:05 - file
98:06 - the file looks like this right now
98:08 - right
98:09 - if i run it again we'll get a different
98:11 - time it's still friday the 15th of
98:13 - october
98:14 - but it's now for what 27. so this should
98:18 - change
98:19 - um but what you'll notice is that it
98:21 - actually ends up replacing the contents
98:24 - of that file so it's not added as a
98:27 - separate line right we don't have two
98:29 - dates in there now
98:30 - it ended up replacing the entire
98:32 - contents of the file so this is very
98:34 - important if i had a lot of stuff in
98:37 - there
98:37 - for example
98:39 - if i navigate back
98:41 - i have this uh let's see
98:44 - stuff directory lowercase stuff
98:47 - i have this song of myself.txt
98:50 - you do not need to follow along with
98:51 - this but this file contains a lot of
98:54 - text if i just look at the
98:56 - first 10 lines it's the entire text of
98:59 - that poem song of myself
99:00 - now if i try and redirect something in
99:02 - there i can take the output of pwd for
99:05 - example
99:06 - and redirect that
99:08 - into song of myself.txt
99:11 - now that is the only thing in that file
99:15 - the output of pwd
99:17 - so we have another option
99:19 - which is to use a different operation
99:22 - very similar we use two greater than
99:24 - signs and this allows us to redirect
99:26 - standard output while also appending to
99:29 - a file instead of overwriting the file
99:32 - entirely
99:33 - so if i just ran you know pwd
99:37 - and then two greater than signs
99:39 - into this file this is let's do it a
99:42 - couple times this is silly to do but if
99:44 - i take a look at that file
99:46 - it now contains what five different
99:49 - lines let's take the date and redirect
99:51 - it into there
99:53 - let's take uh who am i
99:56 - and redirect it into there
99:59 - okay now let's take a look at that file
100:01 - again
100:02 - and you'll see it contains the output of
100:04 - pwd five times the date and then who am
100:07 - i which in this case is colt let's do
100:10 - date one more time or a couple more
100:11 - times let's run head
100:14 - and you can see
100:15 - it did not overwrite the entire file it
100:17 - just appends onto the end
100:19 - so
100:20 - you know date i don't use very much at
100:22 - all redirection though both with a
100:25 - single greater than sign which
100:26 - overwrites a file and two greater than
100:29 - signs is really really common uh the
100:31 - last thing i'll mention is that you can
100:33 - do something like this date redirect
100:36 - into today.txt that file does not exist
100:39 - in this folder if i take a look there is
100:41 - no today
100:42 - but if i do
100:44 - date
100:45 - redirect into today.txt
100:47 - we now have a today file it made it for
100:51 - us so the file does not have to exist in
100:54 - order to uh you know redirect output to
100:56 - it uh it will make that file for us if
100:58 - it needs to
100:59 - all right so we can do it with the date
101:01 - command we can do it with really any
101:02 - command that generates output as we saw
101:05 - i mean i could do if i wanted to
101:07 - ls
101:09 - or ls-l that gives me a lot of text
101:12 - i could take that and then redirect that
101:14 - to a new file called you know
101:17 - contents how about that
101:20 - and
101:21 - if we take a look at contents we'll just
101:23 - use head for now this is what the first
101:25 - 10 lines are now there may be yeah i
101:27 - think there's some more that's missing
101:29 - but we're just doing the first 10
101:31 - and we can see what is inside that file
101:34 - so that's the basic concept of
101:35 - redirecting and then of course if we use
101:38 - 2
101:39 - greater than signs we are redirecting
101:42 - by appending to a file the output is
101:45 - appended to contents and now
101:47 - if we do head we'll probably need to
101:49 - specify you know i want
101:51 - how about just 40 lines of that file
101:54 - we can see all of this is in there
101:56 - all right so next up we have another
101:58 - command called cat c-a-t
102:01 - and let's start by just taking a look at
102:03 - the man page for cat
102:05 - the name cats comes from the fact that
102:07 - it concatenates files
102:09 - cat
102:11 - but the first use i'm going to show you
102:12 - is something slightly different on its
102:15 - own if we just run cat i'm just going to
102:17 - clear here
102:18 - cat and then a file name like i have
102:20 - this uh
102:21 - song of myself i actually don't think
102:22 - there's we we overwrote that didn't we
102:25 - but if i do cat and then a file name it
102:27 - just prints the contents of that file
102:29 - in this case to my standard output to
102:32 - the terminal
102:33 - if i have and we had that contents file
102:37 - that we just made cat
102:39 - contents
102:40 - it gives me the entire file so it
102:42 - doesn't like head gives us the first 10
102:44 - by default we can specify the first 20
102:47 - lines the first 30 lines tail gives us
102:49 - the last 10 the last 20. cat gives us
102:52 - the entire file
102:53 - so i've got this song of myself file
102:55 - very long if i cat
102:57 - song of myself it prints out the entire
103:00 - thing
103:01 - there's a lot here you know i'm
103:02 - scrolling for a very very long time
103:05 - all right so that is something we can do
103:08 - but that's yeah sometimes i'll use that
103:10 - if i want to just check on you know
103:11 - what's in that file i don't remember
103:12 - what's it look like we can do that
103:15 - but there's a lot more we can do with
103:17 - cat as well remember the name cat comes
103:19 - from concatenate
103:21 - so we can actually provide more than one
103:23 - file name and it will print the contents
103:26 - of both of those or three or four
103:28 - however many files it will print all
103:30 - their contents together so on my desktop
103:33 - i have
103:34 - quite a few messy files here i've got
103:35 - one called letters so i'm just going to
103:37 - cat letters
103:39 - all right it just contains letters and
103:41 - then i have this one called words i'm
103:43 - going to cat words
103:46 - and there we are okay so i can cut them
103:48 - individually or i can cut them together
103:51 - just by separating them with a space and
103:53 - now we end up with one output again not
103:56 - very exciting
103:57 - but two different files for red and then
104:00 - concatenated together in this output
104:03 - smushed together
104:05 - so that doesn't seem that useful but
104:06 - where it gets more exciting if
104:09 - exciting to stretch but where it gets
104:10 - more sometimes useful is that we can
104:12 - then redirect that output to another
104:15 - file so i could make one file that is a
104:17 - combination of two or three or four
104:19 - other files or it doesn't have to stop
104:21 - at four i just don't want to keep saying
104:23 - numbers
104:24 - but we can take multiple files
104:25 - concatenate them together and take that
104:27 - output and save it into another file so
104:31 - here's an example of that i have three
104:33 - different shopping lists one for the
104:36 - butcher we can just take a look at that
104:39 - i need ground pork ground beef sausage
104:41 - skirt steak i've got one for the feed
104:43 - store for my animals i need to get
104:45 - chicken scratch chicken feed oyster
104:47 - shells i've got one for groceries milk
104:49 - eggs butter onions tomatoes
104:51 - all right so i want a master list
104:54 - still contrived but you know i want one
104:56 - list that i can take with me so i can
104:58 - concatenate all of them butcher
105:01 - feed store groceries
105:03 - and then i will take that first we can
105:05 - just see what it looks like here's the
105:07 - concatenated output but instead of
105:09 - printing it let's redirect it into a
105:11 - file we'll call it
105:13 - everything if i can spell everything
105:17 - okay and now we have a new file called
105:20 - everything let's take a look at it
105:22 - it contains the results of those three
105:24 - other files being concatenated so that
105:26 - can be useful right we can take multiple
105:29 - things stuff them together and put it in
105:32 - another file but as we'll see later we
105:34 - can also actually take multiple things
105:36 - concatenate them and send them to other
105:39 - commands not just send them to a file so
105:41 - we'll cover that later on when we talk
105:43 - about piping one last thing with cat
105:45 - that i'll mention is that we can use the
105:47 - dash n option to get line numbers
105:50 - so maybe not that useful here but if i
105:53 - go back with that super long song of
105:55 - myself poem
105:56 - if i do cat dash n song of myself
106:00 - pretend this is a file with you know
106:01 - some code and there's a problem in here
106:03 - i can find
106:05 - that line number and then tell my
106:06 - co-worker hey it's on 1741.
106:09 - you would probably be in an editor but
106:11 - we'll also learn about some other
106:12 - commands like find and grep which allow
106:14 - us to search for things so we'll get
106:16 - there
106:17 - there are valid use cases for for
106:19 - wanting those line numbers to be
106:20 - available
106:21 - all right
106:22 - the next command we'll look at is called
106:24 - less
106:25 - l-e-s-s less
106:27 - is used to
106:28 - read the contents of files it gives us a
106:31 - nice interactive ui where we can scroll
106:34 - and it's just a lot easier to work with
106:36 - a file compared to looking at the
106:38 - contents that is printed out from cat so
106:41 - just as a reminder here i've got this
106:43 - super long file song of myself if i use
106:45 - cat
106:46 - it prints out the entire thing and i
106:49 - guess that's sometimes useful but in a
106:51 - super long file i've got a scroll
106:53 - forever yes i could use head or tail
106:55 - just to get you know the the very top or
106:58 - the very bottom of the file but this is
106:59 - a lot of scrolling
107:01 - so if i wanted to actually go through
107:02 - this and i wanted to read the entire
107:04 - poem or look at a massive log file from
107:07 - scratch all the way at the beginning i
107:09 - could use cat scroll to the beginning
107:11 - and now just use a terminal and scroll
107:13 - down but it's not that easy it's not a
107:15 - great interface but if i use less
107:18 - followed by the file name so any file
107:20 - name but a long one is ideal because
107:22 - you'll be able to see how useful it is
107:25 - less song of myself.txt
107:27 - now my screen changes it didn't just
107:30 - print out the entire text to my terminal
107:32 - window instead
107:34 - it opens up the less program where i see
107:37 - a page and then i can scroll down with
107:39 - arrow keys
107:41 - just like the man pages so if you
107:43 - remember with the man pages if we open
107:45 - up man some command
107:47 - our prompts goes away we're transported
107:50 - to a new world of man pages and we can
107:52 - scroll i can hit space to go one page at
107:54 - a time
107:56 - and there's quite a bit more we can do
107:58 - in less but first most importantly to
108:00 - get out of here
108:01 - cue just like the man pages so my my
108:05 - history my terminal is not cluttered
108:07 - with thousands of lines of text
108:09 - so that's one benefit but also of course
108:11 - i can read things and scroll up my own
108:13 - pace
108:14 - i can also do things like search so if i
108:16 - want to search in here my cursor is
108:18 - right here
108:19 - it's a little hard to see
108:21 - if i type a forward slash and then i
108:23 - type some phrase or something i'm
108:24 - looking for
108:26 - i don't know let's look for
108:28 - green i don't know if green is in here
108:30 - somewhere but let's see i'm going to
108:31 - type green and hit enter and there we go
108:34 - this is the first match the sniff of
108:36 - green leaves and dry leaves
108:38 - so that's one thing we can do by the way
108:40 - i mentioned you can scroll one page at a
108:42 - time down by hitting the space bar
108:44 - we can scroll up one page at a time by
108:46 - hitting b so b in space
108:50 - we can also use arrow keys up and down
108:52 - we can jump to the end of the file i
108:54 - believe by hitting g
108:56 - capital g yeah we need shift g it takes
108:59 - me to the very end of the file and then
109:01 - lowercase g takes me to the start so
109:03 - here's the very beginning
109:05 - uppercase g takes me to the end and as
109:07 - always q is how i can quit so this is
109:10 - great to work with long files
109:12 - it's just easier to navigate you can
109:14 - search for things
109:16 - unlike if you're just looking at an
109:17 - entire file using cats it's just all
109:20 - vomited on your screen all at once so
109:22 - that's less the next command we'll learn
109:24 - is called echo echo uh it's very simple
109:29 - it does one thing it takes whatever
109:32 - value whatever argument we pass it and
109:34 - it echoes it back it just prints it back
109:36 - it outputs it so that might not seem
109:39 - useful let's get out of here let's clear
109:41 - if i just echo hi
109:44 - well it just echoes high back to me it
109:47 - prints it out
109:48 - so yeah it is not that useful when you
109:51 - just run it like that
109:52 - but one really useful trick is to use
109:55 - echo with a piece of text and then
109:57 - redirect the output to a file
110:00 - so this is a great really fast way of
110:02 - making a new file that contains some
110:03 - little bit of text
110:05 - without even having to open up the file
110:07 - so if i needed to make some config file
110:09 - and it needs to contain
110:11 - i'm just making this up but it needs to
110:13 - contain something like
110:15 - you know username equals cult something
110:18 - like that it needs to have one line in
110:20 - that file
110:21 - well i could make an empty file i could
110:22 - open it up and then i could put this in
110:24 - there save it close the file or
110:27 - i can echo it and then redirect to a
110:30 - file that doesn't even exist yet
110:33 - so that file let's just call it config
110:36 - dots we'll just do txt
110:39 - so it's going to take this argument it's
110:42 - going to echo it back but instead of
110:44 - printing it to the terminal i'm
110:46 - redirecting it to a file that doesn't
110:47 - even exist it will make that file and
110:50 - put this piece of text in it so now
110:53 - we have a config file and if we use cat
110:55 - to look at it
110:57 - there we are it contains that line
110:59 - and i can also you know if i needed to
111:01 - add something to it
111:03 - i can do the same thing where i can
111:04 - append with two greater than signs so if
111:07 - i needed some other config in there i
111:09 - don't know how about
111:10 - key equals
111:12 - that
111:13 - that is now appended into our config
111:16 - file if we take a look
111:17 - there we are it has two lines of text in
111:19 - it so this is not how i would recommend
111:22 - editing files but if you need to make
111:23 - something quickly or just add a small
111:25 - thing to a file quickly this is a really
111:28 - great way of doing it echo some piece of
111:30 - text redirect it into a file so to
111:33 - summarize echo on its own some piece of
111:35 - text
111:36 - it echoes it back to you on the terminal
111:38 - it just prints it out
111:39 - but we can also redirect that and it's a
111:41 - great way to add some text to a file in
111:44 - like two seconds so the next command
111:46 - we'll cover is called wc it's short for
111:48 - word count and it does just that it
111:50 - counts the words in some input
111:53 - for now it's going to be a file but we
111:55 - can actually provide other inputs and it
111:57 - does more than just word count it
111:59 - actually will count the bytes and the
112:00 - lines so if you remember i have this
112:04 - very long song of myself file here
112:07 - i want to know how many lines are in it
112:09 - well if i run wc
112:11 - and then song of myself
112:13 - it tells me well there's three different
112:16 - values here the first one is a number of
112:18 - lines
112:19 - 1757 lines the next one is the number of
112:23 - words
112:24 - and then third this little chunk here uh
112:26 - that is the number of bytes and then the
112:29 - name of the file
112:30 - so if we look at the man page for wc
112:33 - you'll see that it tells us the order
112:35 - again how many lines how many words and
112:37 - how many bytes
112:38 - we can also say actually i just want the
112:40 - lines so we can use dash l or i just
112:43 - want the number of characters dash m
112:45 - or the number of words dash w
112:47 - so let's see how many
112:49 - uh let's see how many lines i don't want
112:51 - all that other stuff and we're gonna do
112:52 - wc-l
112:54 - song of myself.txt
112:56 - there we are i want to know how many uh
113:00 - how many words dash w
113:02 - song of myself we get fifteen thousand
113:04 - seven six seven
113:05 - okay
113:06 - so that's one way of using word count
113:09 - but i'm also introducing a new concept
113:11 - right now something called piping
113:13 - so we're directly passing right now a
113:15 - file to word count but with piping we
113:19 - can do something very different we can
113:21 - actually take the output of one command
113:23 - and pass it as the input to a second
113:25 - command
113:26 - so we saw how to take the output of some
113:29 - command like ls and redirect it to some
113:32 - file this is taking output
113:34 - and then putting it in a file
113:36 - but what i'm talking about is taking
113:38 - output of a command and passing it to a
113:40 - second command
113:42 - so what if i wanted to know how many
113:44 - files are in here so if i do ls-l
113:48 - this is a massive chunk of text right
113:51 - i can take this
113:53 - and i could i guess take it redirect it
113:55 - to a file and count the lines in that
113:57 - file
113:58 - or
113:59 - i can use piping so it's called piping
114:02 - because we use the pipe character
114:04 - located above the return key on the
114:06 - right side of my keyboard
114:07 - i take the first command ls-l
114:10 - and then instead of just printing out
114:11 - the output i want to pipe it to the word
114:14 - count command wc
114:17 - and take a look at that we see the
114:19 - number of lines new line characters
114:22 - number of uh
114:24 - geez words and the number of bytes
114:26 - uh so what we just did was take ls-l i
114:30 - could even do let's do al that will
114:32 - include hidden files if i have any here
114:35 - there's just two of them but we have 64
114:37 - lines now
114:38 - so that's just one quick example but we
114:41 - can also do things like combine two
114:44 - different files using cat and then pipe
114:47 - that to word count and word count is not
114:49 - the only command we can pipe to i'm just
114:50 - introducing that one first uh i could
114:53 - even do date
114:55 - pipe that to word count if i wanted to
114:57 - know how many bytes are in there or how
114:59 - many uh words it's one line
115:01 - i don't know if i'd really want to do
115:03 - that but we definitely can
115:05 - but i have a couple of let's go actually
115:08 - to
115:09 - my shopping once again
115:12 - and i have if you remember this butcher
115:15 - file
115:16 - and feed store well actually let's do
115:18 - groceries so i have butcher and
115:21 - groceries i want to know how many things
115:24 - i have to buy
115:26 - so i'm going to combine those two
115:28 - groceries and butcher with cat so cat
115:31 - groceries and butcher and remember on
115:34 - its own it just smushes them together
115:36 - and prints it out
115:38 - but i'm not going to redirect it to a
115:39 - file i'm going to pipe it to word count
115:43 - and there we go if i just want the lines
115:47 - that will tell me tell me how many items
115:49 - right one item per line and it says nine
115:52 - and that seems correct right one two
115:54 - three four five six seven eight nine
115:56 - different things that i have to buy
115:59 - all right so that's an intro to piping
116:01 - it will pop up again and again as i
116:03 - introduce some other commands that are
116:04 - really more useful when you pipe things
116:07 - to them
116:08 - one more thing i just i'll show quickly
116:10 - i can combine piping and redirection if
116:12 - for some reason i wanted to take this
116:14 - output
116:16 - and then redirect it to a file called
116:19 - number.txt i can do that so this will
116:22 - run first
116:23 - concatenate those two files
116:25 - and then we're taking that information
116:27 - and piping it to the word count command
116:29 - which is just going to give us a number
116:30 - of lines in this case nine and then
116:33 - instead of printing that out like we did
116:35 - here
116:36 - redirect it to a file called number.txt
116:39 - there it is number.txt and if we look
116:42 - inside
116:43 - well it just has the number nine so
116:45 - that's a quick intro to piping
116:47 - next up we'll see some other commands we
116:49 - can pipe to the next command we'll talk
116:51 - about is sort
116:52 - so sort does what it sounds like it
116:54 - sorts information we'll start by just
116:56 - sorting a text file
116:58 - so i have this
117:00 - why don't we start with our everything
117:02 - file so let's take a look at that
117:05 - okay so it has a bunch of different
117:06 - items
117:07 - and i'm going to sort them
117:10 - with sort everything.txt
117:13 - now this is not going to change the file
117:15 - itself this is simply sorting the output
117:19 - it's going to sort what it gets from
117:20 - this file it will read it in sort it and
117:23 - print out the sorted information but it
117:25 - does not store it in that file
117:27 - and you'll see we end up with an
117:29 - alphabetical sort by default so butter
117:32 - chicken feed chicken scratch eggs ground
117:34 - beef ground pork
117:36 - it is case sensitive so an uppercase s
117:39 - comes before a lowercase s
117:42 - and you can actually tell it to not be
117:44 - case sensitive i believe if we look at
117:46 - man sort
117:47 - there is an option in here for
117:50 - where is that ignore case dash f
117:52 - um but this is great this is you know
117:55 - sorting a file alphabetically but just
117:57 - to reiterate it is not changing that
118:00 - everything file
118:01 - it is unsorted
118:03 - now i could redirect of course so i can
118:05 - do this sort everything and then put it
118:07 - into a file called sorted everything
118:11 - and now if we look at that sorted
118:13 - everything file it is indeed sorted
118:16 - we also can tell it to sort numerically
118:19 - so if i had a file that had numbers in
118:21 - it okay i have a file called nums i've
118:24 - just created oop
118:26 - nums
118:27 - it just contains five numbers here if i
118:29 - try and just sort nums as is
118:32 - it doesn't do a numeric sort it does
118:35 - well it sort of does it compares you
118:37 - know the first digit of each and a two
118:40 - so these both have a two that means i
118:42 - guess they come before 54 because that
118:44 - starts with a five but it's not an
118:46 - actual numeric sort
118:48 - but we have the dash n option
118:52 - that will now sort things numerically
118:54 - and there are other sorts that we have
118:56 - at our disposal we can reverse things
118:58 - with the dash r option so let's do that
119:01 - dash n r you can see we now have 999
119:04 - first all the way down to the number two
119:07 - another option that can be useful has to
119:09 - do with duplicate values so why don't i
119:12 - echo
119:13 - 999
119:15 - and i'll append that into my nums file
119:18 - i'll do that a couple of times all right
119:20 - so now when i recall my sorts for nums
119:23 - there's a bunch of those 999s in there
119:26 - if i want to only get the unique values
119:30 - i can use the dash u option for unique
119:33 - so let's do dash n u
119:36 - and now i only get the unique numbers
119:38 - sorted
119:39 - alright so that sorts we can concatenate
119:42 - and pipe information to sort
119:44 - we can do all sorts of things right it
119:46 - doesn't have to be from a file so i'll
119:48 - just show one more example of that let's
119:50 - take the butcher file and the
119:52 - what's another file i have groceries
119:55 - okay and if i want to sort those two i
119:58 - can pipe that oops
120:01 - i don't know if you can hear my cat
120:02 - there
120:03 - i can pipe it to sort and there we are
120:05 - it sorts what it received as its input
120:07 - so it wasn't just one file we took one
120:10 - command cat that gets an output we pipe
120:13 - it over to sort
120:14 - so there we go
120:16 - i could also do things like if i wanted
120:18 - to know how many unique numbers
120:21 - are in this numbers file right nums
120:24 - i could sort nums
120:26 - but i only want the unique so dash u n
120:30 - sort whoops not sort
120:32 - nums
120:34 - and then let's imagine there was like
120:36 - hundreds of them instead of what five i
120:39 - could pipe that over to good old word
120:41 - count and ask for how many lines
120:43 - so take this nums file
120:45 - only sort the unique value sort them
120:47 - numerically but instead of printing the
120:49 - value or the output to the terminal pipe
120:52 - it over to word count where we count the
120:54 - number of lines and the grand total is
120:57 - 5. so this just is to show you that you
120:59 - know we can take sorts
121:01 - and pipe its output to something we can
121:03 - redirect its output to a file or we can
121:06 - take some other command like cats
121:09 - and concatenate two files and then pipe
121:12 - the output to sort
121:14 - so that's sort next up we'll talk about
121:17 - the unique un iq command now the unique
121:20 - command
121:22 - is generally at least when i use it used
121:24 - in conjunction with the sort command
121:27 - so unique
121:28 - is going to let's just take a look at
121:29 - the man page first
121:31 - it reports or omits repeated lines
121:34 - so anytime you have a data set or a file
121:36 - that contains repeated information on
121:38 - different lines and you're trying to
121:40 - either consolidate it or ignore repeated
121:42 - lines we can use the unique command
121:45 - so just show an example
121:48 - i have a
121:49 - file here that i've just made called
121:52 - fave flavors it was uh let's say we run
121:55 - an ice cream shop we asked our our
121:57 - customers what their favorite flavor of
121:59 - ice cream was
122:00 - and
122:01 - we got a bunch of different outputs
122:03 - right chocolate vanilla strawberry a
122:05 - bunch of vanilla's rocky road cookies
122:07 - and cream but there's a lot of
122:08 - duplicated values
122:10 - now if i just run unique on this command
122:13 - or on this file fave flavors
122:17 - well that's weird it really doesn't seem
122:19 - like it works because i see a lot of
122:21 - duplicated values it seems like if it
122:24 - only gives us unique values or you know
122:26 - it removes duplicates we shouldn't see
122:28 - cookies and cream twice we shouldn't see
122:29 - vanilla twice or way more than twice
122:32 - well what it does is it doesn't actually
122:34 - just remove
122:35 - all duplicated values instead
122:38 - it removes adjacent duplicated values
122:41 - and that might seem weird right
122:43 - so we've got strawberry let's take a
122:45 - look here chocolate vanilla strawberry
122:46 - and then two vanillas
122:48 - well if we look at the output from
122:49 - unique we have chocolate vanilla
122:51 - strawberry one vanilla
122:53 - down here we had strawberry three times
122:54 - in a row over here it shows up once in a
122:57 - row when we use unique
122:59 - so it is going to look at one line and
123:01 - then the line after it and if it's the
123:03 - same then it's only going to print out
123:06 - one of those
123:07 - so generally i use this in conjunction
123:09 - with sort
123:11 - so if i sort fave flavors and then pipe
123:14 - that to let me just remind you what that
123:16 - looks like
123:17 - it's alphabetical so now they're all
123:19 - chunked together right cooking cream
123:21 - rocky road strawberry it's all together
123:23 - and then i can pipe that to unique
123:26 - and now we just get the unique values
123:28 - because they were all in a row and the
123:31 - way that unique works is it's only going
123:32 - to take one uh anytime there's
123:34 - duplicates in a row
123:36 - but you might be thinking didn't we just
123:38 - see there's a dash u option
123:41 - and indeed there is a dash view option
123:43 - for sort it kind of makes this obsolete
123:45 - but there's additional behavior to the
123:48 - unique command that can make it useful
123:51 - for example if i do man unique there's
123:54 - an option which is dash d
123:56 - which will only print out the duplicates
123:59 - so i only want the duplicates uh let's
124:02 - try that let's do
124:04 - well unfortunately they're all going to
124:06 - be duplicates aren't they if i do this
124:08 - dash d every single one of these flavors
124:11 - appears more than once but if i echo how
124:14 - about mint
124:16 - into
124:17 - fave flavors
124:20 - and let's do one more flavor uh
124:22 - how about uh pistachio or
124:26 - um
124:27 - how about rainbow sherbet
124:32 - okay
124:33 - so now we have two values that are not
124:35 - unique
124:36 - so if i remove that dash d
124:38 - here is all of the sorted unique flavors
124:43 - so we see a list of them but with dash d
124:46 - now i only want the ones that are
124:48 - duplicated
124:50 - so we no longer have rainbow sherbet and
124:53 - uh mint
124:54 - side note i've always said sherbet my
124:56 - entire life but uh i don't know i was
124:59 - corrected on sherbet so now i'm
125:01 - self-conscious some guess i'm sticking
125:03 - with sherbet
125:04 - um
125:05 - so there's another option
125:07 - instead of dash d
125:08 - we can use the dash u option to display
125:12 - non-duplicate lines so the lines that
125:15 - only appear once
125:16 - dash u
125:18 - and now we can see oh these are the
125:20 - flavors that uh only one person liked in
125:22 - our case we've got mint and rainbow
125:24 - sherbet everything else is duplicated so
125:27 - we don't see it showing up
125:29 - and then an even fancier option is that
125:31 - we can get a count of how many times
125:33 - each line appears with dash c
125:36 - so why don't i do that here i'm going to
125:38 - do sort all the flavors dot txt or fave
125:41 - flavors and then pipe that to unique and
125:44 - then dash c will give me a count and we
125:47 - can see all right there's five
125:48 - chocolates six vanillas one rainbow
125:51 - sherbet and what's extra fun is that we
125:54 - can actually take the output instead of
125:56 - just printing it out i can re-sort that
125:59 - numerically if i wanted to get a ranked
126:02 - list because they all start with a
126:04 - number i can do dash or sort dash n
126:07 - so sort all the contents of that file
126:10 - alphabetically which groups them all
126:12 - together
126:12 - then take that output and pass it to
126:15 - unique which is going to weed out all
126:18 - duplicated lines that are adjacent and
126:20 - give us a count for how many times each
126:22 - one appears but instead of printing that
126:24 - out pipe that to the sort command again
126:26 - where we will sort by number at the
126:29 - beginning
126:30 - and then we could even reverse it with r
126:33 - and we can see the most popular flavor
126:35 - vanilla so boring all the way down to
126:38 - the least popular mint which is this is
126:39 - not accurate i think mint is actually
126:41 - quite popular but anyway
126:44 - that is using piping along with the
126:46 - unique commands kind of a lot to take in
126:48 - so if you just need to sort the unique
126:50 - values in a file you can do the dash u
126:52 - option but if you want a count of how
126:54 - many times uh different lines appear if
126:57 - you want to weed out
126:59 - duplicated values or you only want an
127:02 - output that contains the values that are
127:03 - duplicated you can use the unique
127:05 - command
127:06 - now if you remember when i introduced
127:08 - the echo command if you happen to be
127:10 - somebody watching this entire thing from
127:12 - start to finish uh you may recall at
127:14 - least when i introduced echo i talked
127:16 - about
127:17 - expansions and how
127:19 - later on i would cover this thing called
127:21 - expansions well that's what i want to
127:22 - talk about now
127:24 - what i'm about to show you is not
127:25 - specific to the echo command but we'll
127:27 - be using the echo command to help
127:28 - illustrate uh how these expansions work
127:32 - so when i say expansion what i mean is
127:34 - that there are special characters and
127:36 - special syntax that we can use with
127:38 - various commands that the shell will
127:40 - interpret and expand into some other
127:43 - value
127:44 - and probably the simplest example
127:47 - is actually something we've seen before
127:50 - the tilde
127:51 - tilde expansion
127:53 - if i just echo the character tilde tilde
127:56 - has a special meaning i'll zoom in a
127:58 - little bit as we've talked about it is a
128:00 - shortcut that refers to
128:02 - our home or my current user's home
128:04 - directory so here
128:06 - tilde is slash user slash cold steel now
128:09 - when we echo it what we're actually
128:12 - doing is asking the shell uh you know
128:14 - print out tilde but it's not the
128:16 - character tilde right if it's in quotes
128:19 - then we get the tilde printed out what
128:21 - it's doing instead is it's it's
128:23 - expanding that character it has a
128:25 - special meaning before it even runs the
128:28 - echo command it's going to replace that
128:30 - or expand it
128:32 - to be this and that's what it echoes out
128:34 - so when we do things like cd tilde
128:37 - again the shell steps in and says oh i
128:40 - know that let me expand that
128:42 - and it turns it into slash user slash
128:44 - cold steel
128:45 - and that is where we see d2 so icd to
128:48 - tilde it's the same end result
128:51 - all right so there's other types of
128:52 - expansion though including dollar sign
128:55 - environment variable expansions so in
128:57 - our shell there's a bunch of environment
128:59 - variables available
129:01 - some of the more common ones are things
129:03 - like dollar sign
129:05 - path
129:06 - in all caps if i echo that
129:09 - you'll see that it's been replaced with
129:12 - a very long yours may be much longer
129:14 - actually than this it's not too bad if i
129:16 - run it over here on
129:20 - ubuntu i think i have quite a long path
129:22 - here nah not too bad either
129:25 - so it takes this and it turns it into or
129:27 - it expands it to the value of that
129:30 - variable now if you don't know much
129:31 - about environment variables don't worry
129:32 - about it but here's one more example
129:35 - user that's an environment variable for
129:37 - the current username
129:39 - okay
129:40 - now a more useful thing
129:42 - is path name expansion
129:45 - so path name expansion allows me to use
129:47 - special syntax special characters
129:49 - to match different path names so we've
129:52 - actually seen this before we just
129:53 - haven't called it path name expansion
129:56 - i'm in a directory right now well i'm in
129:58 - my home directory aren't i so there's a
130:00 - whole bunch of stuff here
130:02 - different files and folders um why don't
130:04 - i do this over on ubuntu because i have
130:06 - some more files to work with okay
130:09 - so when i type
130:11 - echo i'm just going to use echo again
130:13 - because it's an easy way to see what the
130:16 - shell is doing for us so it's just going
130:18 - to print back the expanded version of
130:21 - the star character so if i wrap the star
130:24 - character in quotes
130:26 - that's what we actually get echoed back
130:28 - but if i don't have those quotes and i
130:30 - simply echo star
130:32 - what i see is a list of every path name
130:36 - in this current folder so every folder
130:39 - every file name like you know
130:41 - pokemon.txt word.txt
130:44 - and then different folders like cleanup
130:47 - and copies
130:49 - i'm just matching everything so the star
130:52 - means
130:53 - every path here
130:54 - but i can narrow it down and i can say
130:57 - star
130:58 - dot txt and we've seen this sort of
131:00 - thing before
131:02 - again this is going to then be replaced
131:04 - with matching paths so this was replaced
131:07 - with all of that
131:09 - now if i do star.txt it's only going to
131:12 - match something that starts with
131:14 - anything but ends in exactly dot txt
131:18 - okay and so here we are we see our
131:21 - matches that end with txt
131:24 - now echoing them may not be that useful
131:26 - but i can do things like ls-l
131:29 - star dot txt
131:31 - i want to print out long listing
131:34 - information about all text files in here
131:36 - and there we go i only see txt files and
131:40 - all their information so we also have
131:41 - another character we can use to match
131:43 - path names which is the dollar sign the
131:45 - dollar sign the uh question mark uh a
131:48 - question mark will match any single
131:51 - character
131:52 - so this would match any three characters
131:54 - in a row
131:55 - this would match any four characters in
131:57 - a row so let me show you an example if i
131:59 - echo
132:01 - and i'll do anything
132:02 - so a star matches anything and then a
132:05 - dots and then any two characters
132:09 - so this looks weird but it's saying
132:11 - anything that must then end with a dot
132:14 - and then exactly two characters i don't
132:17 - care what those characters are but two
132:18 - characters and oh we don't really match
132:21 - anything do we in this folder i guess we
132:24 - don't have any all right well let's try
132:26 - three characters
132:28 - and now we're just matching all our txt
132:30 - files and zip files
132:33 - it's not that exciting but just as an
132:35 - example if i were to touch app.py and
132:39 - you know app
132:40 - dot
132:42 - js and main.js
132:44 - all right
132:46 - and then i ran our original version here
132:48 - which is anything
132:50 - with a dots and then exactly two
132:52 - characters now we're matching those dot
132:54 - js and dot py extensions so i'm echoing
132:57 - them again that's not what we would
132:59 - normally do we might do something like
133:00 - ls or we could even do rm if i want to
133:04 - remove all those files this is kind of
133:07 - very
133:08 - dangerous and i don't know if i would
133:10 - recommend this but just as an example
133:12 - i could remove those files that have two
133:16 - character extensions that would be a
133:18 - very bizarre thing to want to do just
133:20 - all two character extensions but i can
133:22 - rm
133:24 - star dot question mark question mark so
133:26 - remove all files in here that end with
133:29 - two character extensions
133:31 - and i have it set up again automatically
133:33 - to ask me
133:34 - prompting me if i want to so
133:37 - i will say
133:38 - yes i'll remove all of them remove and
133:41 - remove
133:42 - all right so that's the basics of path
133:44 - name expansion
133:46 - next up we have some other types of
133:48 - expansion so we'll start by talking
133:50 - about curly brace expansion again i'll
133:53 - use echo
133:54 - when the shell encounters curly braces
133:57 - and i provide a comma separated list of
134:00 - values so i could do something like
134:03 - let's just do letters to start
134:05 - a b and c
134:08 - okay if i just echo a b and c it's not
134:10 - going to be very exciting but if i add
134:13 - something before or after
134:15 - let's do
134:16 - abc dot
134:19 - txt okay
134:21 - what this is going to do is create every
134:23 - combination of a followed by txt or dot
134:27 - txt and then b and then c
134:30 - and that's what we get a dot txt b dot
134:32 - txt and c dot txt
134:35 - so whatever these values are separated
134:37 - by commas
134:38 - i can create i can make files with them
134:41 - if i wanted to the shell is going to
134:43 - take this and expand it first so if i
134:45 - did something like touch
134:48 - and then how about um i did app dot
134:52 - and then in curly braces js
134:55 - html
134:56 - css and py if i wanted to do that
135:00 - i'll run it with echo first so you can
135:02 - see what it would make me
135:04 - app.js
135:05 - app.html app.css app.py and then if i
135:09 - wanted to actually create that
135:11 - i could use touch
135:13 - and that will make me all those files
135:16 - so now there's a bunch of stuff here why
135:18 - don't we narrow it down well only ls
135:21 - things that end in two
135:24 - characters or how about
135:26 - app dot
135:27 - and then
135:29 - question mark question mark question
135:30 - mark or how about a star all right and
135:33 - so we can see what we created
135:35 - we can also do numbers and provide
135:37 - ranges so if i echo
135:40 - 1.99
135:43 - this is going to be expanded to the
135:45 - numbers between integers between 1 and
135:47 - 99.
135:48 - so i could create a bunch of files
135:52 - how about
135:53 - day
135:55 - and then let's do one to 365 if i was
135:57 - keeping some sort of journal i'm not
135:59 - making files right now i'm just echoing
136:01 - it but the shell takes this it expands
136:04 - it into this massive list of different
136:06 - numbers or rather different
136:08 - names day 94 day 95 and so on and then
136:13 - i'm echoing it but i could just as
136:15 - easily touch or make directory and
136:18 - create 365 different directories in a
136:20 - single line now there are other types of
136:23 - expansion uh we're not going to spend
136:25 - time talking about them but basically
136:27 - the concept of expansion is that the
136:29 - shell intervenes before a command runs
136:32 - expands some smaller thing usually it's
136:34 - small into a larger piece of text and
136:37 - then passes that to some command and we
136:39 - can use that to our advantage to craft
136:41 - short commands that results in creating
136:44 - hundreds of files or deleting a whole
136:46 - bunch of stuff
136:47 - or just matching a bunch of things by
136:49 - defining a pattern like we saw
136:51 - if we want to match you know anything
136:54 - that how about starts with the letter f
136:56 - and then ends in anything else
136:59 - i'm just echoing it and this is just
137:01 - echoing the paths that match this
137:03 - pattern in my current directory
137:05 - but then i could delete them all if for
137:06 - some reason i didn't want them to start
137:08 - with an f i could delete them all
137:10 - or i could move them all i could copy
137:12 - them there's a whole bunch of things we
137:13 - can do next up we'll cover the diff
137:15 - command which we can use to find the
137:18 - differences between two different files
137:21 - if you've ever used git you probably
137:23 - have seen the get diff command
137:25 - we will actually see
137:27 - what it relies on behind the scenes to
137:29 - generate a diff but first let's make two
137:32 - files or at least one file that is
137:34 - slightly different than another
137:36 - so i have this ice cream flavor five you
137:40 - know fave flavors file i'm going to copy
137:42 - it
137:43 - so copy fave flavors and i'm going to
137:45 - make another file called fave flavors
137:49 - 2 dot txt it's not very original
137:52 - all right so now we have two of them
137:54 - and if i compare the two with diff at
137:57 - the moment
137:59 - they are identical
138:02 - there's no difference so let's change
138:05 - something in fave flavors two let's echo
138:08 - another thing in there how about
138:10 - what's another flavor well let's just do
138:12 - mint again
138:14 - and i'll append that
138:15 - not with a single greater than sign two
138:18 - i want to append to fave flavors
138:21 - two dot txt
138:23 - okay so now that exists at the end of
138:26 - that file
138:28 - just that one extra addition of mint
138:31 - so if i rerun my diff between those two
138:34 - files
138:35 - this is what it tells me
138:38 - 24a25
138:40 - mint now we could spend a lot of time
138:41 - talking about how this works
138:43 - but to read this change command here
138:45 - what it's telling us is that
138:47 - on the first file line 24
138:50 - on the second file line 25 was added
138:54 - so if we change the direction
138:56 - if we instead compared fave flavors to
138:59 - to flav fave flavors just on its own
139:03 - now the output says line 25 on the first
139:07 - file line 24 and the second file was i
139:10 - don't know if the d stands for deleted i
139:11 - believe
139:13 - so you know appended added deleted
139:17 - we can have multiple diffs too in a file
139:19 - just
139:20 - if i quickly change something in
139:23 - how about
139:25 - in fave flavors two so let's open that
139:27 - up i'm gonna change something on line
139:30 - three i'm gonna do strawberry
139:34 - and
139:35 - cream
139:36 - all right i'm going to save that file
139:39 - and close it
139:41 - now if i do my diff between fave
139:44 - flavors
139:46 - and fave flavors two
139:50 - we see we get two different diffs right
139:52 - two different things that were changed
139:53 - on line three of both files it was
139:56 - changed from strawberry to strawberry
139:59 - and cream
140:00 - and then line 24 of the first file line
140:02 - 25 of the second file we added mint
140:05 - anyway uh this is one way of using diff
140:08 - but what's probably more common uh and
140:11 - more useful is to see both files side by
140:13 - side with dash y so that's one option if
140:16 - we pass in dash y
140:18 - uh although in this case um way zoomed
140:20 - in it's kind of disastrous isn't it on
140:22 - this screen size because i've tried to
140:24 - make things readable
140:26 - but if my font were quite small you
140:28 - would see it side by side and then
140:30 - lastly we have the dash u option which
140:33 - is what git uses behind the scenes to
140:35 - display its own diffs
140:37 - and this just gives us a different
140:38 - output if we look at mandif again and we
140:41 - go down to dash u
140:43 - output the num lines of unified context
140:46 - so it gives us some context around each
140:48 - change so let's do that again
140:50 - instead of dash y dash u and what we see
140:53 - here are the files that we're comparing
140:55 - and then context is saying from line one
140:57 - to six we can see what was added or
141:00 - removed uh and then same thing here we
141:02 - can see what was added so this is maybe
141:04 - familiar if you use git and that's the
141:06 - basics of the diff command next up we'll
141:09 - talk about the find command so find
141:12 - helps you find files or folders matching
141:15 - some file pattern but there's quite a
141:17 - bit to it and we could have a 20 minute
141:20 - video at least devoted just to the find
141:22 - command so i'm going to just try and hit
141:24 - the highlights here
141:25 - the first thing you should know is that
141:27 - we can find
141:28 - files and folders by a bunch of
141:30 - different criteria we can find based off
141:32 - of let's open up the man page
141:34 - based off of the name of the file
141:37 - the modification time uh the file size
141:41 - the type if it's a file or a directory
141:44 - or a sim link
141:46 - there are probably many others that i'm
141:47 - forgetting at the moment
141:49 - and i'm just scrolling through the man
141:50 - page here it's quite long as you can see
141:53 - so again we're just going to hit the
141:55 - some of the highlights here okay so the
141:57 - first thing is if we want to find files
142:01 - or directories we need to provide a
142:03 - location to look inside of so find
142:07 - inside of in this case dot meaning the
142:10 - current folder or find in the desktop or
142:12 - find in my
142:14 - animals folder
142:15 - and then we provide some sort of
142:17 - criteria something to search against in
142:20 - this case dash name
142:23 - and then some sort of name that we want
142:26 - to find
142:27 - so i'm just going to search on my
142:29 - desktop i have a bunch of files
142:31 - but find will search recursively
142:34 - so if i do a find dot and nothing else
142:37 - just find dot
142:39 - it is going to find every single file
142:41 - nested somewhere inside my desktop
142:45 - so there's a lot of stuff going on here
142:47 - if i scroll i mean you can see they're
142:49 - all nested
142:50 - they're not actually on the desktop
142:52 - they're nested multiple levels deep
142:54 - uh we didn't specify any way of
142:56 - narrowing what we're looking for but now
142:58 - let's try let's find everything
143:01 - that has
143:02 - in its name and then instead of quotes
143:05 - uh let's search for anything that has
143:08 - hm
143:09 - how about the number
143:11 - seven in it
143:13 - anywhere on my desktop or any folders
143:15 - nested in the desktop or folders nested
143:17 - in those folders and so on
143:20 - really nothing
143:22 - why didn't we find anything aren't there
143:24 - at least there's one file here that has
143:26 - a 7 in its name
143:28 - and the answer here is that it's looking
143:30 - for an exact match a file that has and
143:34 - it is called seven if i made a file
143:37 - called seven right here
143:39 - and i reran it it would work we found
143:41 - that file but what i want to do is find
143:44 - any file on my desktop or nested
143:46 - somewhere on the desktop that has the
143:48 - number 7 in it
143:50 - so this is where the special wildcard
143:52 - characters
143:54 - of a star in our case will come in a
143:57 - star is just going to refer to anything
144:00 - and then a 7 and then anything else
144:03 - optionally before or after so if i do
144:06 - this
144:06 - we now get a bunch of matches a lot of
144:09 - pokemon that i have for a different
144:11 - video i made that have a seven in their
144:13 - name somewhere but i'm sure there's some
144:16 - non-pokemon here we go
144:18 - morning day 27
144:21 - nested very deep inside of this folder
144:24 - or here's you know file 257
144:27 - so we found files that contain seven in
144:30 - their name
144:31 - so if i wanted to find all files for a
144:33 - particular type like all python files
144:36 - dot py
144:37 - i would put a star which again means
144:40 - anything followed by
144:42 - dot p y
144:44 - and it looks like there's just one let's
144:46 - try a dot j s
144:49 - we've got a couple of js files
144:52 - nested in my desktop now remember
144:54 - dots is where i'm searching inside of
144:56 - and that's just my current location but
144:58 - i could instead say i want you to search
145:01 - only within the stuff folder
145:04 - if i can spell it correctly
145:06 - it's not going to find anything but
145:08 - maybe i'll find txt files
145:10 - and there we go we only find txt files
145:13 - inside of stuff
145:15 - so we can also find by type i can find
145:18 - directories or files or sim links so why
145:21 - don't i do a find
145:23 - on my desktop once again and all that i
145:25 - want here
145:27 - are
145:28 - any entries anything that it finds where
145:31 - type is d for directory now i forgot to
145:34 - specify where to search we'll search in
145:36 - our current directory and i get a list
145:39 - uh these are all directories there's a
145:40 - lot here
145:41 - but no files if you notice none of the
145:44 - actual files are present no dot txt or
145:47 - js or whatever it's just the directories
145:49 - if i did type f i only get the files as
145:53 - you can see here these are all of course
145:55 - they don't have extensions so you can't
145:57 - tell but you have to trust me they are
145:59 - all files
146:01 - for each pokemon in this case or
146:04 - whatever you're seeing printed out these
146:05 - are all files there are no directories
146:08 - that i've been found now there's
146:09 - directories referenced in the path to
146:11 - each file but that's not the same thing
146:14 - as the actual directories being returned
146:16 - as a result here
146:18 - so we can combine them too maybe i want
146:20 - to find directories only
146:22 - so i'm going to do dash type is d
146:25 - and name
146:28 - as uh i don't know how about uh an
146:30 - uppercase
146:32 - um uppercase e
146:35 - we'll see if we find anything that
146:37 - contains an uppercase e and we do so
146:39 - only directories somewhere on the
146:41 - desktop
146:42 - where in their name they have an
146:44 - uppercase e so here we go uppercase e
146:47 - uppercase these are all directories
146:49 - now i can also do a case insensitive
146:52 - version
146:53 - if i do i name for insensitive
146:57 - now i'm finding everything that has an e
146:59 - it doesn't actually matter if it's
147:00 - uppercase or lowercase so we see things
147:03 - like right there there's an e in that
147:05 - directory's name there's an uppercase e
147:07 - and a lowercase e
147:09 - okay
147:10 - we can also do fancy logical things like
147:12 - use the or operator so dash or so let's
147:16 - give it a shot let's find uh
147:19 - anything that has in its name so in our
147:21 - current location
147:23 - dash name it starts with the letter e so
147:27 - actually sure let's do e
147:29 - so e and then followed by anything now
147:32 - remember
147:34 - if we put a star there that means
147:36 - anything can come before the e but what
147:38 - i want is it must begin with the letter
147:40 - in this case uppercase e so we get a
147:43 - bunch of the e pokemon and there's some
147:45 - others edgar ethel elvis instead of the
147:48 - chickens directory
147:50 - now if i also wanted to say
147:52 - or name starts with
147:55 - how about
147:56 - f
147:57 - star
148:00 - and now i have fall
148:03 - fungus
148:05 - as well as espeon and you know files
148:09 - that and directories that start with an
148:10 - f or an e
148:12 - uppercase only because i didn't do i
148:15 - name
148:15 - so that's just a taste of using the or
148:17 - operator there's also a not operator
148:21 - we can do things like search by file
148:23 - size how many bytes
148:25 - how many megabytes
148:27 - greater than something so for example to
148:29 - find files that are larger than 100
148:31 - kilobytes but smaller than one megabyte
148:34 - we could run this right here
148:36 - so find where type is file f
148:39 - and size is plus 100k greater than 100k
148:44 - and size is minus
148:46 - one m one megabyte so let's try an
148:49 - example let's do uh find
148:52 - where type is file and size is greater
148:56 - than 100
148:58 - kilobytes
149:00 - and there we are
149:01 - we get a list of files that are greater
149:04 - than 100 kilobytes if i left that size
149:06 - off we get way way more files
149:10 - we can also do things around time so if
149:12 - we want to find files that were edited
149:14 - more than three days ago we would do
149:16 - dash m time which is modified time plus
149:20 - three and then we get to the last little
149:23 - bit that i'm going to mention around
149:24 - find
149:25 - which is this weird looking thing dash
149:28 - exec
149:29 - this is an option we can provide where
149:32 - we then specify a command that we want
149:35 - find to run on each found result
149:38 - so this example is going to find all
149:41 - files in the current directory right
149:42 - type is file
149:44 - and on each one it is going to cat that
149:47 - file out it prints its contents now i'm
149:50 - not going to run that because on my
149:51 - desktop i've got a million files that it
149:53 - will print out
149:54 - but let's talk about this quickly so
149:56 - dash exec
149:58 - is just the option saying hey i'm going
150:00 - to give you a command i want you to run
150:01 - with each match and then here's the
150:04 - command the entire command we're
150:06 - providing we do have to terminate it
150:08 - with this backslash and then a semicolon
150:11 - that is how the terminal knows where
150:13 - that command ends and then this the
150:15 - curly braces opening and closing is
150:18 - going to be replaced it's a placeholder
150:20 - it will be replaced with each found
150:22 - result
150:23 - so let's try an example let me recall
150:26 - this line where we found files that were
150:28 - larger than 100 kilobytes
150:31 - we could verify the size of files one
150:34 - way at least is with dash l ls l rather
150:37 - right and we can see the file size here
150:41 - and there's a lot of them
150:43 - there's a couple that are larger but
150:44 - most of them are pretty small
150:46 - dash l is going to give us that long
150:48 - listing so what i want to try is taking
150:51 - these files that we find that are larger
150:53 - than 100 100 kilobytes and then telling
150:56 - find to then call ls-l
151:01 - and then curly braces
151:02 - and then we need our backslash semicolon
151:06 - and
151:07 - of course
151:08 - my font is quite large here but what you
151:11 - can see is that for each one of those
151:12 - results if i just
151:14 - run find without dash exec these are the
151:17 - results right gg dot i think that's
151:19 - great gatsby.txt
151:21 - uh
151:22 - pokemon exercise nano exercise whatever
151:25 - these different files are they're all
151:27 - here but we actually executed ls-l with
151:31 - each one and we can see that file size
151:33 - is large much much larger than the other
151:36 - ones
151:37 - we could do something instead like if we
151:39 - wanted to cat each file out
151:43 - but again there's going to be
151:46 - quite a few
151:47 - things printed out so all files larger
151:49 - than 100 kilobytes
151:51 - dash exec means i want you to then run
151:53 - each match with cat
151:56 - curly braces just concatenate them all
151:58 - oh my goodness that's a lot of stuff
152:00 - that was just printed out a lot of it is
152:02 - kind of messed up but
152:04 - there we are that is the result of
152:07 - executing that cat command with every
152:10 - single one of the found files that
152:12 - matched with our find command
152:14 - all right so there's a lot more to find
152:15 - you can do some really powerful things
152:17 - but that's just a quick intro next up
152:19 - another command that could have its own
152:21 - video for 20 30 minutes at least
152:24 - grep there are many articles many
152:26 - tutorials that are quite long that exist
152:29 - solely to explain all the different
152:30 - options and various ways of using grep
152:33 - so what it does is it helps us find
152:36 - text inside of files so the find command
152:39 - helps us find files right based off of
152:42 - their file name or different attributes
152:44 - but it's not searching in the files
152:47 - grep will search inside of files
152:50 - so the simplest way to use it is to run
152:53 - grip and then tell it some string or
152:56 - some piece of text or something that
152:57 - we're trying to find
152:59 - and then a file to search inside of
153:02 - so let me show you an example here let's
153:04 - clear this screen all this craziness
153:06 - i have this song of myself file
153:10 - here i opened it in less there's a lot
153:12 - of stuff in here and i want to find
153:14 - every
153:16 - time this file i don't know mentions
153:18 - green in it so i can do grep
153:21 - green
153:22 - song of myself.txt
153:25 - and it prints out to me the matches
153:27 - right it highlights them in a different
153:29 - color
153:30 - of every time in this file the word
153:33 - green showed up
153:35 - so we've got green leaves green and
153:37 - violet dusky green pale green eggs
153:40 - quintillion's green
153:42 - there we go we can also ask grep to give
153:44 - us the line numbers with the dash n
153:47 - option so we'll add that in right there
153:49 - dash n
153:50 - and now i'm getting the line numbers so
153:52 - 32 is the first one all the way to line
153:55 - 1026
153:56 - i can also ask for some context if i use
153:59 - an uppercase c
154:01 - and then i provide an argument a number
154:04 - of lines i want in this case two that
154:06 - will give me two lines before and two
154:08 - lines after each match so let's try that
154:11 - c
154:12 - and then two
154:15 - and here we go
154:16 - so this is one match this is actually
154:18 - the last match on this line we have two
154:20 - lines before and two lines after
154:23 - uh here's another match right we have
154:25 - two lines after two lines before
154:28 - another option we can pass to grep is
154:30 - dash r
154:31 - which is for recursive uh and this is a
154:34 - bit different this will actually tell
154:36 - grep if i do grub dash r and then
154:38 - provide some pattern like
154:40 - chicken
154:41 - it's going to tell it to search
154:42 - recursively in my case right now just in
154:45 - the current directory and all nested
154:47 - subdirectories so instead of just
154:49 - looking inside of one file like
154:51 - hello.txt which doesn't exist
154:54 - now i can look inside of all files at
154:57 - least if i tell it a starting point i
154:59 - think the default is just dot
155:02 - okay so uh what we see here is a bunch
155:05 - of matches
155:06 - one from gg.txt or a couple a couple
155:09 - from sorted everything and everything
155:11 - feedstore.txt
155:13 - website.html
155:16 - greatgatsby.txt
155:18 - so these are all files that were nested
155:19 - somewhere in my desktop
155:22 - and they all contained chicken
155:24 - now uh it is important to note that it
155:26 - is case sensitive so if i did you know
155:28 - uppercase c no matches
155:31 - but i can make it case insensitive with
155:33 - dash i and now i get my matches again
155:36 - now what makes grep really powerful is
155:38 - that it can work with regular
155:39 - expressions which i'm not going to go
155:41 - over right now
155:42 - if you know about regular expressions
155:44 - you know the syntax you can provide
155:46 - regex patterns to grep to search against
155:50 - so you could find all matches of an
155:51 - email pattern or a phone number pattern
155:54 - and that sort of thing okay well i
155:56 - changed my mind i'm going to show a
155:57 - quick example i'm not going to explain
155:59 - any of it
156:00 - because regular expressions is its own
156:01 - crazy topic but what i'm doing here is
156:04 - using a pattern this is a regex that
156:06 - will match email addresses so i'm
156:09 - searching across recursively
156:11 - across in my case the home directory
156:14 - tilde
156:15 - for any matches
156:17 - to this email pattern
156:19 - alright so i didn't type this out myself
156:20 - just to be clear i found an email regex
156:22 - but i'm going to run it
156:24 - and
156:24 - you'll see a bunch of different emails
156:27 - that have been matched
156:28 - being at search.mozilla.org
156:30 - toolkit.mozilla.org
156:33 - toolkit at mozilla again
156:35 - firefox
156:37 - these are all coming from some uh
156:39 - documentation it looks like
156:41 - from firefox here's some other ones
156:45 - anyway the point is we can match these
156:47 - patterns across uh in a file or across
156:49 - our entire machine and there are tons of
156:52 - powerful regular expressions that you
156:53 - can write
156:55 - but we're not going to talk about how
156:56 - that works it's a whole separate topic
156:58 - anyway that's a quick intro to crap next
157:01 - up du disc utility
157:04 - i think that's what it stands for i
157:05 - guess i should verify
157:07 - that would be the logical thing it
157:08 - stands for
157:09 - uh well
157:11 - disk usage no i'm totally wrong i'm
157:13 - pretty sure it's disk usage anyway
157:16 - what we can do with du is find uh the
157:19 - sizes of files and directories on our
157:21 - machine
157:23 - so if i just run du in my current
157:25 - directory wherever i am
157:28 - it's going to give me an output of all
157:31 - the other directories in here and their
157:33 - sizes so you can see
157:35 - you know if i just pick one of these
157:36 - let's find something slightly larger
157:38 - here
157:39 - sure
157:40 - this
157:41 - tar demo folder is 32 kilobytes
157:46 - this wildlife folder is 16. this cleanup
157:49 - directory is 156 kilobytes and so on
157:52 - uh and then down at the very bottom i
157:54 - can see my actual current folder right
157:57 - here
157:57 - is dots is 36 megabytes i can provide a
158:03 - folder to look inside of instead of just
158:04 - my current directory i could say
158:07 - i want to know the pokemon exercise
158:12 - folder
158:13 - what's its size and it's uh let's see
158:15 - 24k
158:16 - we can tell it to give us a different
158:19 - format megabytes or gigabytes using dash
158:22 - g for gigs dash m for megabytes so let's
158:25 - do du
158:27 - we'll do everything here dash m for
158:29 - megabytes
158:30 - uh it's all just one maybe two if i do
158:33 - it on my mac here
158:35 - we may get some more stuff
158:38 - not a whole lot but some of this stuff
158:41 - here's something 410 megabytes here's
158:44 - something that's 25. now you may notice
158:46 - it's not actually giving me uh the unit
158:48 - it's just 1 or 0 or 10. if i use dash h
158:52 - which is for human readable it now is
158:55 - giving me a human readable size so 4k
158:59 - 24k but then also for some of these
159:01 - larger things
159:03 - we get you know gigs 5.7 gigs
159:06 - so this is what i use most of the time
159:08 - if i actually need to read something as
159:10 - a human dash h
159:12 - now here's kind of a nifty thing we can
159:14 - do if i want to find the largest
159:15 - directories on my desktop here i can do
159:18 - d u dash h for human readable
159:21 - okay
159:22 - and i can pipe that to the sort command
159:27 - now we're almost there it is sorting but
159:29 - the way that it's sorting is not exactly
159:31 - correct if you notice here
159:33 - it's doing a sort you know once again
159:35 - based off of the digits so it's saying
159:38 - you know 9.2 m
159:40 - megabytes is somehow smaller
159:43 - than 900 kilobytes
159:46 - so it's putting all the nines together
159:47 - that's
159:48 - that's a start but it's not actually
159:50 - sorting them so sort actually gives us
159:52 - an option if i go to man sort
159:55 - it gives us an option dash h
159:58 - oh where'd you go
160:00 - i lost it here it is human numeric sort
160:02 - so it sorts my numerical value but it
160:04 - takes into account prefix or suffixes
160:06 - like k or m or g
160:09 - so it's for human readable numbers so
160:12 - let's run this again we are going to get
160:14 - a human readable format from du of all
160:17 - the files on my desktop
160:19 - sort them
160:21 - with dash h to make it a human readable
160:23 - sort instead of the default sort
160:25 - and now
160:26 - if we go to the top we get our smallest
160:29 - files
160:30 - the kilobytes and down at the bottom we
160:32 - get our largest files and if i wanted to
160:34 - find the top 10
160:36 - largest files for example i could then
160:39 - pipe that to tail that would be one
160:42 - option and there we go i'm getting the
160:44 - 10 in this case because that's the
160:46 - default for tail
160:47 - largest or i could reverse
160:50 - with dash r
160:52 - and instead get the head which will be
160:54 - the same thing right
160:56 - i'm now getting the sort is in reverse
160:58 - order and i'm taking the first 10
161:00 - instead of the last 10. anyway that's an
161:02 - intro to the d u command the next
161:05 - command we'll see a nice and quick one
161:07 - is df not to be confused with du
161:10 - the du command showed us file sizes and
161:14 - folder sizes whereas the df command will
161:17 - tell us information about the mounted
161:19 - file systems how much space they take up
161:22 - and how much free space they have left
161:24 - so i'll just show you very quickly here
161:26 - if i run df with no arguments or options
161:30 - i'm going to see
161:32 - some output here yours will look
161:34 - different
161:35 - the file system so each individual file
161:37 - system
161:38 - and then the amount of size that it has
161:41 - been allocated how much it uses how much
161:44 - is available now this by default on
161:46 - ubuntu is in one kilobyte blocks it's
161:48 - not so easy to read if i switch
161:51 - over and use the dash h option for human
161:53 - readable
161:55 - now we get megabytes and kilobytes and
161:57 - gigs and that sort of thing
161:59 - okay
162:00 - so we can see things like
162:02 - here is this file system udev
162:05 - uh here's where it's mounted uh here's
162:08 - how large how much space it's been
162:10 - allocated and how much it's using
162:12 - uh i'll show you this on my mac as well
162:16 - so let's do that now i have to zoom out
162:19 - quite a bit just so that we can see the
162:21 - columns but what we'll see here is that
162:24 - some file system uh has been allocated
162:26 - up to
162:27 - 3.6 this is actually tip tebites
162:32 - uh not terabytes uh
162:34 - it's let's see it's a
162:36 - 1.1 times so 10 larger than a terabyte
162:41 - and it really doesn't matter the thing
162:43 - is i know this is a four terabyte
162:45 - computer uh the drive here so three
162:47 - point six terabytes makes sense anyway
162:50 - that's how much space it's been
162:51 - allocated but it's only using this file
162:54 - system at least is only using 10 gigs
162:56 - or you know here's another one this is
162:58 - my slash dev disk 1s2 blah blah blah
163:02 - blah
163:03 - and here's where it's mounted it's also
163:06 - has up to 3.6 tbytes to use but actually
163:11 - it's used 2.2 terabytes out of that
163:15 - anyway you may not really need to use
163:16 - this command but i'm just being
163:18 - comprehensive here one thing that can be
163:20 - nice though is
163:22 - if we pass a file or a folder as an
163:25 - argument to df it will tell us more
163:28 - information about the file system that
163:30 - particular file or folder lives on
163:32 - so if i wanted to know you know where's
163:34 - my desktop and how much space is that
163:37 - file system taking up i can do d let me
163:39 - just clear first i can do df h for human
163:42 - readable and then desktop
163:46 - and we can see this is the file system
163:48 - this is you know the capacity of that
163:49 - file system how much is available and so
163:52 - on
163:53 - so that's all there is to df uh and
163:55 - remember du tells us about the actual
163:58 - sizes of individual files and
164:00 - directories df tells us about i don't
164:03 - know if it's disk free
164:05 - or disk file systems or i don't know
164:07 - what the f stands for i was trying to
164:09 - look at the man pages and figure it out
164:10 - but think of it as disk free sure next
164:13 - up the history command now this one can
164:15 - be very useful especially if you have
164:17 - some long long commands you ran
164:20 - i don't know 20 or 500 commands ago and
164:24 - you want to rerun it and not have to
164:25 - type it yourself again or you don't know
164:27 - what it was that is what the history
164:29 - command helps us with so on its own if
164:31 - we just run history let's do it here on
164:34 - my
164:35 - linux machine so i'm going to run
164:37 - history here
164:39 - i'm going to get a bunch of lines as you
164:42 - can see
164:43 - there's a number next to each and then a
164:46 - command that i ran so we can see a
164:48 - history of all the commands that i've
164:50 - run so history was the most recent
164:52 - command before that i had man df and
164:54 - then d u dash m i had clear i had d u d
164:58 - u d u d u uh you know all these
165:00 - different commands um and let's say this
165:03 - is the command i want to rerun this is
165:05 - the grep that will search for regular
165:07 - expressions uh or sorry it searches for
165:09 - emails using an email regular expression
165:12 - across my entire machine
165:14 - i don't want to have to type this myself
165:16 - one option i guess it's just to copy and
165:18 - paste that definitely but there's also
165:20 - something called history expansion where
165:22 - if i have that number and your numbers
165:25 - are going to be different but if i have
165:26 - a number
165:27 - i can take it and simply run exclamation
165:30 - points and then that number 2064
165:34 - and now it's running that command again
165:36 - it's finding all these matching emails
165:37 - across my machine
165:40 - so
165:40 - just one more example oh geez i need to
165:42 - rerun history
165:45 - and if you prefer you can actually pipe
165:48 - this
165:48 - to less
165:50 - so that command less opens up a program
165:52 - where we can scroll a bit easier we can
165:55 - page through commands one at a time
165:57 - i can find some command like
165:59 - i'm sure this one here
166:02 - that finds
166:03 - things that start with the letter e or f
166:06 - so it's 20 40. i can exit less and just
166:09 - run exclamation point 2040 and now it
166:11 - finds me all the files and directories
166:13 - that have an e or an f uppercase as
166:16 - their first letter another thing you can
166:18 - do is actually combine
166:19 - grep with uh history if you're trying to
166:22 - find some commands you ran a long time
166:24 - ago you know as you probably just saw
166:27 - there's tons of commands here and
166:29 - somewhere in this massive list my
166:31 - history list
166:32 - there was a command i ran and i know
166:35 - that it included the word i don't know
166:37 - cookie but i'm not sure where it is and
166:39 - i want to rerun that well i can run
166:42 - history and then pipe that to grep
166:45 - remember pipe that pipe character allows
166:47 - us to take the output of one command and
166:49 - pass it as input to another so then i
166:51 - can search for
166:53 - cookie
166:55 - and there's quite a few actually
166:57 - surprisingly
166:58 - where there are commands so we're just
167:00 - searching through the text returned from
167:02 - history using grep we found a match five
167:05 - or what six seven different matches and
167:08 - if i want to run one of these i can take
167:10 - that number and exclamation point that
167:12 - number
167:13 - so 1686
167:15 - this is just going to make me a bunch of
167:16 - files so i even want to do that
167:18 - not really but i've already committed
167:21 - okay
167:22 - so you can see it made me those files i
167:24 - think it was cake and cookie and there's
167:26 - cookie
167:27 - cake is up here somewhere anyway that
167:29 - can be quite useful if you know
167:31 - somewhere in this massive history there
167:33 - was some command and it included some
167:35 - pattern or some some word and that's all
167:37 - you remember well you can use grep to
167:40 - search for it the next command we'll
167:41 - cover is ps
167:43 - so ps is a command that helps us inspect
167:46 - or view the process processes processes
167:50 - running on our computer
167:52 - so if we take a look at man ps
167:55 - process status is what it stands for i
167:58 - didn't actually know that i just always
168:00 - thought of process in my head anyway
168:02 - it's going to display information about
168:04 - currently running processes processes
168:07 - and by default if we just run ps i'm on
168:09 - my mac in this example with no other
168:12 - options or arguments it shows me a list
168:15 - of all the processes started uh by me
168:17 - the current user
168:19 - so uh what we see here we've got uh well
168:23 - first of all
168:24 - the process id we've got the time we've
168:26 - got the actual command
168:28 - you can see i've got a bunch of bash
168:30 - shells and uh and then really the only
168:32 - somewhat interesting thing i guess would
168:34 - be this python process i have uh i have
168:37 - a python server in a different tab that
168:39 - i've started but just to show an example
168:42 - i'm gonna start a node server in this
168:44 - tab i've got this app.js i'm going to
168:46 - run it with node here's my server it's
168:49 - running i started a new process
168:51 - now if i run ps again
168:53 - we see
168:54 - somewhere there we are that process
168:57 - right there
168:58 - okay so that is a process i started and
169:01 - we can see it right in this list it has
169:04 - an id
169:05 - and in a moment we'll also learn how we
169:07 - can kill a process where that id can
169:10 - come in handy
169:11 - but there's more to this command we can
169:13 - also view a list of processes initiated
169:15 - by anyone on our machine basically all
169:17 - the processes
169:19 - not just the ones that are user
169:21 - initiated by me
169:23 - so all
169:24 - processes to do that p s
169:28 - a x
169:30 - so this is a pretty common one v s a x
169:32 - we're going to see a lot more going on
169:34 - here
169:36 - so we still have you know that node
169:38 - server i started up we've got our bash
169:40 - instances and then a whole bunch of
169:42 - system stuff look at all these processes
169:45 - now you will see they get cut off here
169:48 - so if they don't wrap over to the next
169:50 - line i can't scroll it just gets cut off
169:53 - so there's a way around that
169:55 - it's a very weird option if we add on
169:57 - two w's a x w w
170:01 - now you'll see that they wrap around
170:04 - so i've got my short processes that i
170:06 - initiated here but then some of these
170:08 - are quite long
170:10 - like this google chrome helper renderer
170:12 - i mean it goes all the way down to what
170:14 - about there i think
170:16 - no actually here i mean that that's very
170:20 - long but it does wrap over instead of
170:22 - being cut off
170:23 - so something that can be very helpful is
170:25 - to combine grep with the ps command so
170:29 - that you can find some process and
170:31 - generally when you're trying to find a
170:33 - process at least when i'm trying to find
170:35 - something i actually might be trying to
170:37 - kill it which is again a command we'll
170:39 - learn shortly
170:41 - so there's this massive list and
170:43 - somewhere in here i do think i have
170:44 - visual studio code open but i don't know
170:46 - what its process id is
170:50 - that's this first column here i could
170:52 - search though so i can recall that
170:54 - command
170:55 - and then pipe it to grep and let's just
170:58 - look for visual to start
171:01 - alright well there's quite a few of
171:02 - those how about visual studio
171:04 - okay so here are all the matches for the
171:07 - visual studio code processes
171:10 - quite a few still wow all right didn't
171:13 - narrow it down all that much
171:15 - but here this is the one we'd probably
171:17 - want to kill the visual studio code.app
171:20 - now i wouldn't actually kill visual
171:22 - studio code this way you can just quit
171:23 - it or force quit it but when i cover
171:25 - kill just in a moment you'll see that
171:27 - there are some situations where you
171:29 - would need to do this you actually would
171:31 - need to find out the process id
171:33 - all right so that's a quick intro to ps
171:36 - there's a lot more to it
171:38 - as you can see there's some options we
171:40 - didn't really cover any of these
171:43 - you can filter processes by who they
171:46 - belong to or who started them you can
171:48 - change the display format you can add
171:50 - more information to be displayed anyway
171:53 - there's a lot more you can do but the
171:54 - basic concept is that it displays
171:56 - information about the processes running
171:59 - on your machine the next command we'll
172:01 - take a look at is top top
172:04 - i actually
172:06 - don't know what that stands for
172:09 - does it tell us not really it says
172:11 - display and update sorted information
172:13 - about processes i think
172:15 - it comes from the fact that it will show
172:17 - us the top
172:19 - most
172:20 - memory intensive processes or the top
172:23 - most cpu intensive processes
172:26 - so what it does if we just run top
172:29 - it's going to open up
172:30 - sort of a different screen we don't see
172:32 - our prompt anymore
172:33 - what we see now is a little dashboard
172:35 - that shows us information by default of
172:38 - the top
172:39 - that must be where it comes from the top
172:42 - most uh cpu intensive processes so you
172:45 - can see over here the command
172:48 - so i've got screenflow that's what i'm
172:49 - using to record this video
172:51 - i've got uh some core audio
172:55 - terminal the top
172:57 - command itself they each have a process
173:00 - id
173:01 - we can see a bunch of other information
173:03 - the memory that they're taking up
173:05 - the cpu percentage
173:07 - and we can also
173:08 - sort instead by memory so if i rerun
173:12 - this it's dash o
173:15 - m e m for memory
173:18 - and you'll see now this is highlighted
173:21 - and we can see they are sorted in order
173:24 - of how much memory these processes take
173:26 - up processes so chrome unsurprisingly is
173:29 - up top and then i've got uh
173:32 - these are i'm using parallels for my
173:34 - virtual machines i have windows running
173:37 - over here and then i've got uh linux
173:40 - running over here so that's what you see
173:42 - there
173:42 - i've got chrome again uh pdf editor
173:46 - the screenflow um anyway it doesn't
173:49 - really matter but what you'll see is
173:50 - different but we can sort things by the
173:53 - amount of memory they take up
173:54 - and we can see that process id which is
173:57 - useful when we want to kill something
173:59 - later on uh you need to reference that
174:02 - process id all right so that's top to
174:04 - get out of here type q
174:06 - that's the easiest way i think you can
174:07 - also get out with control c most likely
174:10 - yeah i just use q the next command we'll
174:13 - cover is kill k-i-l-l
174:16 - we use this command to kill programs but
174:19 - it's actually a little bit more
174:20 - complicated than that it's not just a
174:21 - matter of saying shut this thing down or
174:23 - kill it
174:25 - there are a whole bunch of different
174:27 - different types of signals that we can
174:29 - send when we run the kill program
174:31 - so there's actually a lot of different
174:33 - signals and it can be very overwhelming
174:35 - and confusing if you try and understand
174:36 - them all i'll just quickly show you here
174:39 - if we run the kill command with dash l
174:41 - it's not going to kill anything it
174:43 - instead will list the different signals
174:45 - that we can send
174:47 - so there's things uh actually to make
174:50 - this a bit easier why don't we pipe that
174:51 - to less so i can scroll through it all
174:54 - right so we've got things like
174:56 - sig int and sig il and sig kill sig bus
175:00 - sig term
175:02 - sig charm is actually a pretty common
175:04 - one it's terminate
175:06 - we've got say kill signal kill
175:10 - let's see there's a whole bunch of these
175:12 - the vast vast majority i've never ever
175:14 - had to use
175:15 - and they all are supposed to be
175:17 - different they are supposed to do
175:18 - different things
175:20 - but what's confusing is that it's
175:21 - actually up to the specific program that
175:24 - you're trying to kill it's up to that
175:25 - program source code to handle these
175:28 - different signals
175:29 - okay so let's talk about some of the
175:31 - most common signals
175:33 - and the basic syntax essentially the way
175:35 - that we kill something is by using the
175:37 - process id we saw how we can use
175:40 - commands like ps
175:41 - and top to find a process id
175:44 - and then we specify a signal so
175:47 - we can specify a signal using the long
175:50 - form a word
175:52 - so
175:53 - hup that's a common one means hang up
175:56 - we can send you know term to terminate
175:59 - that's the default but what i prefer to
176:01 - do and what a lot of people do is
176:02 - instead you can use a number so as we
176:05 - saw here there's a number corresponding
176:07 - to each one of these signals so if i go
176:09 - back
176:10 - as i said term is a common one the
176:12 - number there is 15.
176:14 - kill is nine so we could send that
176:17 - signal too all right so
176:20 - if you're wondering what does this all
176:21 - mean when would i use one versus the
176:23 - other the way that i think about it um
176:26 - is that in general i try and use 15
176:28 - first this is the gentlest way to quit
176:30 - something or to stop a process think
176:32 - about with the graphical user interface
176:34 - the different ways of of quitting or of
176:36 - shutting something down
176:38 - one option is to uh just quit your
176:41 - application and save your changes
176:43 - another is to quit and click don't save
176:46 - another option is to
176:48 - force quit the entire application
176:51 - another option is to
176:52 - unplug your computer these all are
176:54 - different ways of of quitting or
176:56 - shutting down a piece of software
176:59 - and that's kind of a silly version uh
177:02 - but the idea is that there are these
177:03 - different signals so 15 or sig term is a
177:06 - gentler way to quit
177:08 - it basically the idea is that your
177:10 - program that you're quitting or killing
177:13 - would have time to
177:15 - tie up any loose ends save any necessary
177:17 - state whereas on the complete other end
177:20 - of the spectrum we have nine which is
177:22 - what a lot of people use so a lot of the
177:24 - tutorials and docs you'll see just says
177:27 - to use nine which is the most brutal way
177:29 - of just shutting everything down and
177:31 - basically just force quitting a program
177:34 - and then there's a whole bunch of stuff
177:35 - in between but i like to try and start
177:37 - with 15 that allows things to shut down
177:39 - how they would normally and if that
177:42 - doesn't work then we use 9 which is just
177:44 - pulling the plug on the life support for
177:46 - that program all right so let's see how
177:48 - it works so just like a burgeoning
177:50 - serial killer we need to find our first
177:52 - thing to kill so fortunately i have a
177:55 - couple of node processes that i want to
177:57 - stop i want to kill
177:59 - if i do ps a here
178:02 - i have a server running uh two actual
178:04 - node servers uh here's the process id if
178:07 - we'll just take that first one and i
178:09 - wanna kill it so i'm gonna copy that id
178:11 - and it turns out that
178:13 - you know i can't stop this any other way
178:15 - normally you start a server and then you
178:16 - can stop it with control c or something
178:18 - but i've lost that window
178:20 - i don't have access to just type control
178:22 - c to quit the server so i need to kill
178:24 - it this way
178:25 - okay so i have the process id now the
178:28 - syntax is kill
178:30 - and then i can provide either a number
178:33 - like if i'm doing nine that is the
178:35 - brutal way of killing something that's
178:37 - the the just immediately kill
178:40 - we can provide the
178:43 - name
178:44 - kill or even the full name sig kill
178:47 - but i'm going to start with the default
178:49 - so if i just kill and then i put the
178:51 - process id in there this will send a
178:53 - term terminate signal that's the gentler
178:56 - way first that's the default so this is
178:58 - a gentle way that gives it time to close
179:00 - up shop and save its state if needed so
179:03 - if i try that i don't get any feedback
179:05 - and if i do psa again
179:08 - it's still there
179:09 - so it didn't seem like it worked just
179:12 - give it a couple of seconds sometimes we
179:14 - will just double check come back nope
179:16 - it's not working
179:18 - so now it's time for more aggressive
179:20 - action
179:21 - we're going to provide a signal and
179:22 - remember we can list all those signals
179:24 - if i do kill dash l
179:27 - this isn't that helpful to be honest uh
179:29 - it i mean it gives us a list but what
179:31 - does this mean
179:33 - what i generally stick with and by far
179:35 - the most common if you are gonna pass
179:36 - one through is nine but remember that's
179:39 - a brutal one nine is the kill signal and
179:42 - that's the one that just pulls the plug
179:45 - so we can pass that in
179:46 - kill let me just clear
179:49 - dash nine
179:50 - and why didn't i just show you it is
179:52 - here right there's that process
179:55 - kill dash nine and then the process id
179:59 - okay once again no feedback whatsoever
180:02 - psa and now it's gone now we just have
180:05 - this other node server running
180:07 - okay so that's the basics of the kill
180:09 - command i know it can be a little
180:10 - overwhelming
180:12 - but the idea is that you provide some
180:14 - signal and then a process id and that
180:16 - signal will be sent to some usually kill
180:19 - or terminate or do something
180:21 - to end that process next up in our
180:23 - killing arsenal is the kill all command
180:26 - so kill all
180:28 - is different from the kill command in
180:29 - that we actually can provide a name
180:32 - instead of a process id we can provide
180:34 - the name of a program that we want to
180:35 - kill
180:37 - and if we have multiple it will kill
180:38 - them all
180:39 - uh so if i happened just
180:43 - maybe happen to have multiple node
180:45 - servers running once again
180:47 - i actually just have them here so here's
180:49 - one
180:50 - and here's the other um
180:52 - i could just you know ctrl c and quit
180:54 - them nice and easy but let's just say i
180:56 - can't uh so i want to kill both of them
180:58 - instead of doing the process ids and all
181:00 - of this i can just do kill all and then
181:03 - provide a signal just like before with
181:05 - regular kill i can do kill or sig kill
181:08 - or nine and this is the most violent way
181:10 - of killing something
181:12 - kill all dash nine and then
181:14 - node so that is the name of the program
181:17 - i wanna kill
181:19 - once again no feedback unfortunately but
181:21 - let's see what happens
181:23 - well i don't see any node processes here
181:25 - and if i go to my terminal windows oh
181:28 - killed
181:28 - and killed
181:31 - so that is the basic use of the kill all
181:33 - command it doesn't require process id
181:35 - it's definitely less precise generally i
181:38 - use kill because i can isolate exactly
181:40 - what i want to kill but if i know
181:41 - there's multiple things or i just it's a
181:43 - pain to find the process id then you can
181:46 - use kill all next up we're going to talk
181:48 - about three commands that go together
181:50 - jobs
181:52 - j-o-b-s
181:53 - vg for background and fg for foreground
181:57 - so these three work in conjunction and
181:59 - they all have to do with running things
182:01 - in the background and well in the
182:02 - foreground
182:04 - so if we have some command or a program
182:06 - that happens to take a long time for
182:09 - example a command like this where i'm
182:10 - using find
182:12 - in the root directory so on the entire
182:13 - machine find all files that have changed
182:17 - in the last one day 24 hours
182:20 - so there's a lot of system files and a
182:22 - whole bunch of stuff it's going to take
182:23 - a long time if i just run it right now
182:26 - i'm going to get a bunch of permission
182:27 - issues but it's still running if you
182:29 - look down here
182:30 - it's going
182:32 - and it's going to take quite a while to
182:34 - check every single file on my machine
182:38 - so it's running in the foreground right
182:39 - now right meaning i can interact with it
182:42 - it's not well happening in the
182:44 - background um so i can stop it right if
182:47 - i do control c
182:48 - that just stops the whole thing
182:50 - um and there's actually something else i
182:53 - can do
182:54 - if i run control z what i can do is
182:56 - suspend it which kind of puts it in a
182:59 - state of uh well suspension it's not
183:01 - stopping it entirely forever it's not
183:03 - ending it it's pausing it so i'm gonna
183:06 - rerun that
183:07 - and by the way what i'm doing here is
183:09 - finding all those files and then putting
183:11 - it all eventually in a file called all
183:14 - changes or all maybe i should rename
183:16 - that to be all changed files or whatever
183:19 - we're not going to be using this to do
183:20 - anything i just am using it to
183:22 - illustrate that we can have these things
183:24 - that take forever
183:25 - so if i hit control z
183:27 - right now
183:29 - you'll see it says stops right here so
183:32 - this is slightly different than what
183:33 - happened earlier
183:35 - and now if i type the jobs command which
183:38 - is how we can check up on any jobs we
183:40 - have running
183:42 - we see this program
183:44 - is currently stopped
183:47 - okay so let's try doing something else
183:50 - what about uh the top command if you
183:52 - remember this it's going to show me all
183:54 - these different processes on my machine
183:57 - and how much memory and all the stuff
183:59 - they're taking up
184:01 - and i can use control z to stop this as
184:05 - well so ctrl c just gets me out of there
184:08 - if i do control z
184:11 - it actually stops that or pauses it and
184:14 - if i type the jobs command again now we
184:16 - have two jobs in here
184:18 - so two different jobs
184:20 - that are both control z they're both
184:22 - suspended
184:24 - now what i can do is selectively
184:27 - re-run or resume one or both of these
184:30 - jobs in the foreground like what we saw
184:32 - here is in the foreground
184:34 - or i can actually run them in the
184:36 - background so that they they keep going
184:39 - but i won't see all this text i won't
184:40 - see them in my terminal but they'll
184:42 - still be running
184:43 - so this jobs command is just how we
184:45 - check up on jobs see what their state is
184:47 - and they also have
184:49 - an id or a job number and that's
184:51 - important because when we want to
184:53 - selectively resume them we can use those
184:55 - numbers
184:56 - all right so the first command i'm going
184:58 - to show you after jobs is actually fg
185:01 - for foreground
185:02 - so if we run foreground and then we
185:04 - specify a number a job number
185:07 - that job will be resumed so if i want to
185:10 - resume the top command its number is 2.
185:14 - so if i do fg
185:16 - 2 there we go
185:19 - it is now running again and it's in the
185:21 - foreground
185:22 - so i could suspend it with ctrl z or i
185:25 - can just get out of here control c or q
185:28 - if i look at jobs now we just have this
185:31 - one job right this is my find program
185:35 - now i can resume this in the foreground
185:38 - by doing fg
185:39 - and then the number one
185:41 - or because it's the only job i could
185:42 - just type fg
185:44 - so i'm going to do that now
185:47 - and here we are it's resumed again in
185:49 - the foreground it's just going to take
185:50 - forever and maybe we'll get some
185:52 - permission denied stuff
185:54 - let's see if there's any text
185:56 - and if i grow tired of this i want it to
185:58 - run in the background i don't want to
186:00 - see all this taking up my terminal
186:02 - screen i want it in the background not
186:03 - the foreground i can suspend it
186:06 - and
186:07 - go back to jobs
186:09 - it's suspended
186:10 - i can resume it but instead of doing
186:12 - foreground one
186:14 - i can do background one whoops
186:17 - and that will resume it it will be
186:19 - running but i'm not gonna see it running
186:22 - so i'm gonna do that
186:24 - so it gives me a little message saying
186:25 - all right this is running and it's in
186:27 - the background and the way that we know
186:28 - it's in the background there's two ways
186:30 - one this ampersand means something is
186:32 - running in the background two if i type
186:34 - jobs
186:35 - it's telling me right here running
186:38 - so it is running but we don't see it
186:39 - running right we don't see all that text
186:42 - but by using the jobs command we can
186:43 - verify it is indeed running
186:45 - i could bring it back to the foreground
186:47 - if i wanted to you know foreground
186:49 - i don't have to specify one it's the
186:51 - only job and here it is it's in the
186:53 - foreground
186:55 - and that's really all that there is to
186:56 - this
186:58 - we can run things in the foreground in
186:59 - the background and we can use the jobs
187:01 - command to check up on them
187:03 - this is going to just take forever let's
187:05 - see if it ever finished i'm just going
187:07 - to quit or stop it uh let's look at our
187:10 - all changes file
187:13 - yep so it's got a lot of stuff in there
187:16 - and let me just prove this to you one
187:17 - more time that it does work so i'm going
187:18 - to remove that all changes file
187:21 - yep
187:22 - all right so now we no longer have that
187:23 - all changes file if you remember i said
187:26 - the ampersand is one way we can send a
187:27 - job to the background uh so here's
187:30 - another a very stupid program in this
187:33 - context uh sleep
187:35 - is uh just going to stop if i just run
187:38 - sleep five i'll just show you the man
187:39 - page this is a new command it just
187:42 - delays for a number of seconds so five
187:45 - seconds i won't do that long let's do uh
187:47 - sleep two seconds
187:49 - so you'll see nothing happens it's a
187:51 - delay for two seconds and then my prompt
187:53 - comes back so we can use this if we're
187:55 - writing a script or something where we
187:57 - need to stop to wait for
187:59 - uh data to come back or to wait for
188:03 - to make a user feel like something is
188:04 - taking longer than it actually is for
188:06 - better ui there's all these different
188:08 - uses but typically i don't run sleep
188:10 - unless i'm teaching it
188:13 - now i can run this in the background so
188:14 - let's do a long sleep like
188:16 - 50 seconds
188:18 - so if i ran this in the foreground again
188:20 - it's stupid to do this but if i did i'm
188:23 - waiting here for 50 seconds um and i
188:25 - can't do anything else so i'm going to
188:27 - control c and end that but if i run it
188:30 - in the background which i can do by just
188:32 - adding an ampersand so sleep for 50
188:34 - seconds in the background that's what
188:36 - the ampersand at the end means
188:38 - now i don't see that happening here if i
188:41 - look at jobs
188:42 - it is running though it is a job it's
188:45 - running in the background
188:46 - and then i could bring it back to the
188:47 - foreground if i wanted to just like that
188:50 - and now it's running in the foreground
188:52 - all right uh so i'm just gonna stop it
188:54 - anyway and if i go back to jobs now
188:56 - there's no jobs all right so that's kind
188:58 - of a lot of stuff around
189:01 - jobs and foreground and background
189:03 - let's just recap that so if you have a
189:05 - program you run a command put an
189:07 - ampersand at the end
189:08 - it's going to run in the background if
189:10 - we don't do that but we want it to run
189:12 - in the background i say after the fact
189:15 - let's rerun my find command this long
189:17 - find command i could run it
189:20 - and then
189:21 - suspend it
189:22 - and then decide i want that to run in
189:24 - the background so i could get the job id
189:27 - i happen to know there's only one job
189:29 - but i could get that id and now say go
189:31 - in the background one
189:33 - and now it's running in the background
189:35 - and it will take a while eventually it
189:37 - will complete
189:39 - it's still running as we can see here it
189:41 - has that ampersand it shows us it's
189:42 - happening in the background
189:45 - i don't know how long it's going to take
189:47 - quite a long time but eventually it will
189:49 - finish
189:50 - next up we're going to talk about
189:52 - compressing files
189:53 - we'll first talk about the gzip command
189:56 - which is used to compress files
189:59 - it uses an algorithm called gzip there
190:01 - are multiple different compression
190:03 - algorithms if we take a look at gzip on
190:06 - the man pages
190:08 - it the whole idea is that it reduces the
190:10 - size of files using
190:13 - lenthil ziv coding lz77
190:16 - so you know compressing is a very
190:18 - complicated um interesting but very
190:21 - complicated
190:22 - area of study and there are quite a few
190:23 - different algorithms
190:25 - but one of the most common on linux at
190:27 - least is gzip so the way that it works
190:30 - is that we have some file hopefully a
190:32 - larger file that we're trying to reduce
190:34 - the size of
190:35 - and we provide it to gzip however i
190:38 - would warn you it's not a huge deal but
190:40 - if you just run gzip with a file name it
190:43 - is going to take that original file
190:45 - compress it and replace the original
190:47 - file so you'll only have the compressed
190:49 - version that ends in gz
190:52 - that's just the extension that it gives
190:53 - it uh if you want to keep the original
190:56 - file you can do two different things
190:58 - this is a slightly clunkier way but the
191:00 - better option in my opinion is to use
191:02 - dash k
191:04 - i don't know if it stands for dash keep
191:05 - that's what i think in my head
191:07 - and that will keep the original file so
191:09 - let me just demonstrate this here i've
191:11 - got a somewhat large text file if i just
191:14 - uh cat it out it's a lot of stuff in
191:17 - there it's the result of running a find
191:19 - command and redirecting the output into
191:21 - this file okay so if i run gzip and i'll
191:24 - do dash k
191:25 - on that file
191:27 - we don't get any output which i'll show
191:29 - you how to correct in just a moment if
191:31 - you want some output but if i type ls
191:34 - we now have
191:35 - this file here all changes.txt so the
191:38 - same name but now it has an
191:41 - additional.gz.gzip extension
191:44 - if i do an ls-l
191:47 - we can see the file
191:48 - size difference but actually let's make
191:50 - it human readable with lh for human
191:52 - readable
191:54 - pretty significant
191:55 - reduction in size almost 2 megabytes
191:58 - down to 200 kilobytes
192:00 - now i'm going to remove that
192:02 - so remove all changes.txt
192:05 - and uh i'm going to just show one more
192:07 - oh no
192:09 - i removed the wrong thing
192:11 - well that's annoying all right
192:14 - it's gone i don't have that original
192:16 - file if you remember when i talked about
192:17 - remove
192:18 - when you remove it doesn't go to a
192:20 - temporary recycling bin it is gone but
192:23 - the good news is we do have the
192:25 - zipped file the gzip compressed version
192:28 - and i can unzip that to get my file back
192:31 - so we'll just jump ahead and talk about
192:33 - unzipping so the way that we can do that
192:36 - is to use the dash
192:38 - d option to decompress that is one way
192:42 - of doing it
192:43 - and then there's also a totally separate
192:45 - command called g unzip which you can use
192:49 - which is basically the exact same thing
192:51 - there's a couple more options but it
192:53 - will unzip a gzip compressed file in the
192:57 - same way that gzip dash d will unzip
193:01 - so let's start with uh well why don't we
193:03 - do g unzip
193:06 - all
193:07 - changes.txt.gz
193:08 - all right i type ls and there we are i
193:12 - now have the uncompressed if we do ls-l
193:16 - let's do lh
193:17 - 1.8 megabyte version
193:20 - okay
193:21 - so let me just show one more thing when
193:23 - we g-zip it again so i have that
193:25 - original i want to keep the original and
193:28 - if i add dash v for verbose it's going
193:31 - to give me information about
193:33 - how much space it reduced or how much it
193:35 - compressed the file
193:37 - all right so i'm going to do gzip dash
193:39 - kv and then
193:41 - my file is all changes.txt
193:44 - and it says it reduced it by almost 87
193:47 - if we do lh for ls
193:49 - we can see once again 1.8 m
193:52 - 232k so a lot smaller and then just one
193:57 - more time we can use g unzip
194:00 - or we can do gzip dash d
194:03 - for decompress
194:05 - on that file
194:07 - and it's going to ask me if i want to
194:08 - overwrite
194:09 - because what i'm doing here right i kept
194:12 - the original so i would be unzipping
194:15 - a new file with the exact same name do i
194:17 - want to replace it sure
194:19 - okay
194:20 - and now
194:22 - we're back to what we were at before
194:25 - it is well let's do h again 1.8
194:28 - megabytes so i unzipped
194:30 - and that's kind of all that there is to
194:31 - that one thing that's important to know
194:33 - about gzip is that it will only zip
194:36 - individual files so it won't you know it
194:38 - won't take 10 files and zip them
194:40 - together into a single compressed file
194:42 - we'll see how to do that with a
194:43 - different command
194:45 - but just to show you what happens if i
194:47 - make let's see i have this one file
194:49 - let's make another file whoops
194:51 - just with some very small text in there
194:54 - i'll call this one.txt
194:56 - and let's do it again actually for 2.txt
195:00 - okay so i now have three files in here
195:02 - if i do gzip and i'll do dash k if i
195:05 - want to keep the originals sure
195:08 - g g zip dash k and then
195:12 - we'll do v as well for verbose all
195:15 - changes and then a space
195:17 - one and two i can provide multiple files
195:21 - and it does compress them but it
195:23 - compresses them individually so we end
195:25 - up with
195:26 - three different gzip files
195:29 - okay so it did not combine them it just
195:32 - compressed multiple
195:33 - so that brings us to our next command
195:36 - tar tar tar is a command that we use to
195:40 - create an archive which is basically a
195:43 - grouping of a bunch of files potentially
195:44 - a bunch of files together into a single
195:47 - file and then we can go and compress
195:49 - that file so the name tar is short i
195:51 - think for tape archive an older
195:54 - relic of uh days gone by
195:57 - but anyway the way that it works is it's
195:59 - kind of complicated there's a lot of
196:01 - options the man page if i just go to
196:03 - mantar it's very long lots of options
196:07 - but i'm just going to show you some of
196:08 - the most basic things that you might
196:10 - want to do primarily taking a folder
196:12 - full of a bunch of files and combining
196:14 - them down into a archive and then
196:17 - compressing that so that we have a
196:19 - single file that is compressed that we
196:21 - can then unzip later and then expand
196:24 - back into a whole bunch of files
196:26 - okay so the syntax the basic syntax is
196:29 - to run tar
196:30 - and then a couple of options to create a
196:32 - new archive
196:34 - to smush files together
196:36 - we provide the different files we want
196:38 - to smush together separated by spaces
196:40 - we provide two options c for create and
196:44 - then f is it's the way we provide the
196:46 - file name that we want it to create so
196:49 - if we provide f we must provide the
196:51 - archive name unlike when we zip a single
196:54 - file it can you know gzip can just use
196:56 - the name of that file and append gz but
196:59 - here we're combining files together so
197:01 - we need to provide an end result name
197:04 - okay
197:05 - so i have
197:07 - a simple oops
197:09 - let me go into that folder a simple
197:11 - folder here
197:12 - ls-lh shows us we've got three files
197:16 - lots of text more text and song of
197:17 - myself.txt
197:19 - i'm going to combine the three of these
197:20 - into a new archive so the way that i do
197:22 - that is tar
197:24 - c for create f
197:27 - is the file option so i provide the file
197:29 - name for the archive i'm going to call
197:31 - it
197:31 - um
197:32 - i don't know archive okay
197:35 - and conventionally these end with dot
197:37 - tar as the extension
197:39 - and then we'll just provide the file so
197:41 - song of myself
197:43 - what was it lots of text more text and
197:46 - then i'll hit enter and this will create
197:48 - a new archive file as you can see right
197:50 - there
197:52 - and this does not mean it's compressed
197:54 - to be clear
197:55 - okay it's just a single file if you look
197:57 - at the file sizes 3.6 megabytes well we
198:00 - had 1.8 1.8 and then 85 kilobytes so we
198:03 - did not lose any size along the way this
198:06 - is not compressed but now i could go and
198:09 - compress this if i wanted to
198:11 - but before we do that let me show you
198:13 - how we can un-archive to extract files
198:16 - from an archive we use the dash x option
198:19 - for extract
198:20 - c was to create x is for extract
198:23 - and if we just do x f and then we need
198:26 - to provide the file name once again this
198:28 - would be the archive we just created
198:30 - this will unarchive it in our current
198:32 - folder but we can also move them so we
198:35 - can provide a directory a destination
198:37 - with dash c
198:39 - and before that we can actually just
198:41 - view what's in the file if we use the
198:44 - dash t option
198:46 - so i can just show you that
198:48 - why don't i move my archive somewhere
198:50 - else let's move um why don't i just make
198:53 - a new directory i'll just call this
198:56 - somewhere
198:57 - and then i'll move my archive into
198:59 - somewhere
199:00 - okay so let's cd into somewhere all
199:03 - right so now i can show that dash t
199:05 - option which we can use to view the
199:07 - files uh that are inside of this archive
199:10 - so we have this let's just say i
199:11 - downloaded it i don't know what's in it
199:13 - well i can do a tar
199:16 - t
199:16 - f archive
199:18 - there we go it says hey there's three
199:20 - files in here
199:22 - i don't have them they're not
199:24 - out of that archive they're still in
199:25 - there all combined down into a single
199:27 - file but i can then extract them i'll
199:30 - just do it in the current directory
199:32 - so to do that it is tar
199:34 - x f and then the archive
199:38 - now i have those three files as you can
199:40 - see here
199:42 - okay and then again i could provide a
199:43 - destination instead if i want to extract
199:45 - them somewhere else with dash uppercase
199:48 - c
199:49 - okay so still no compression the next
199:52 - step is to combine compression gzip is
199:55 - going to be our algorithm along with
199:57 - archiving with tar
199:59 - so we can do this separately just to be
200:01 - clear i could do
200:03 - if i uh just remove
200:06 - lots of text more text and song of
200:08 - myself
200:10 - yes yes yes okay
200:13 - so i have this empty directory except
200:15 - for the tar i can compress that tar as
200:18 - we saw with gzip so gzip and then i'll
200:21 - do dash k to keep the original file if i
200:24 - want to
200:24 - archive.tar
200:26 - and now i have the compressed version
200:30 - okay so it's only 502 kilobytes compared
200:33 - to 3.6 megabytes
200:35 - so let's delete the original tar so
200:37 - rmarchive.tar
200:41 - and now i just have the compressed
200:44 - archive so this is really you know a
200:46 - bunch of files combined down into a
200:48 - single archive then compressed this
200:50 - might be something we download or
200:51 - something we get from some mysterious
200:54 - source now i want to get it back to the
200:57 - original files that are inside of it so
200:59 - i need to uncompress and then i need to
201:01 - unarchive
201:03 - so to uncompress or decompress remember
201:06 - we use gzip
201:08 - and then dash d
201:10 - and then the name of the file
201:13 - so now i just have the regular archive
201:14 - it's much larger right 3.6 megabytes
201:18 - now i need to uh on archive so we need
201:22 - tar.
201:24 - x for extract
201:26 - f so we provide the file which is
201:28 - archive.tar
201:30 - and there we are we get our original
201:32 - stuff back out
201:34 - okay so we can do it in two different
201:36 - steps like we did there make the archive
201:38 - then compress and then uncompress go in
201:40 - the other direction uncompress and then
201:42 - unarchive or we can actually use just
201:45 - the tar command to do it all together
201:48 - the tar command
201:49 - has a special option z for gzip which
201:53 - will also compress and archive with that
201:55 - gzip algorithm at the same time
201:58 - so instead of two separate steps we can
201:59 - do it at once so i'll just show that
202:01 - real quick
202:02 - let's do the same thing
202:03 - let's remove my archive i have my three
202:06 - files i'm going to combine them together
202:09 - with tar
202:10 - i'm going to do create i'm going to zip
202:13 - with
202:14 - gzip and then i'm going to do f so i can
202:16 - provide the file name we'll call this
202:18 - bundle this time dot
202:21 - tar and then space the files i want
202:27 - okay
202:28 - and take a look at what we get
202:30 - i should have probably named it with a
202:32 - dot gz extension but if we look at the
202:35 - bundle.tar
202:37 - it is compressed it's much smaller so
202:39 - you don't have to have that extension
202:40 - but you want that there if somebody else
202:42 - sees it
202:43 - so they know you know this is a gzip
202:46 - file
202:47 - and you need to use g unzip
202:49 - to unzip it so if i want to remove these
202:52 - files so we just have the single archive
202:55 - or the bundle file
202:58 - okay
202:59 - there we are now to unzip it and
203:02 - unarchive i can just run our regular old
203:05 - tar
203:06 - x for extract f provide the file name
203:10 - i don't even have to tell it to use g
203:13 - unzip so let's try it there it is
203:15 - remember it looks like this 500
203:17 - kilobytes single file
203:19 - i'm going to do atar
203:21 - extract and the file name is bundle.tar
203:24 - and let's see what we get
203:26 - there we are we got the three files back
203:28 - out all right so we saw two ways of
203:30 - doing it first we can create a bundle or
203:33 - create a tarball and then compress that
203:36 - or we can do it all in one go if we have
203:38 - multiple files we want to combine and
203:41 - compress we can provide the dash z
203:43 - option as we saw here to create a gzip
203:47 - compressed file next up we'll talk about
203:49 - a fun command called nano n-a-n-o
203:52 - nano is actually a text editor you can
203:55 - run directly from your terminal now
203:57 - there are other text editors some that
203:58 - are quite a bit more powerful
204:00 - than nano
204:01 - but they are also quite a bit more
204:03 - complicated to learn and when you're
204:05 - starting out you can really mess things
204:06 - up so things like vim if you've ever
204:08 - heard of vim
204:10 - powerful but really tricky to learn when
204:13 - you're starting out and also could have
204:14 - its own hour long video there actually
204:16 - are courses on just using it so we're
204:18 - not going to go into that but nano is
204:21 - another editor that comes built in that
204:23 - we can use and the reason it's good to
204:25 - know one of these editors at least and
204:27 - there are others there's emacs and the
204:29 - reason it's good to know them is that
204:31 - you can directly very quickly change
204:33 - files or make modifications add things
204:35 - onto files
204:37 - without having to go through the whole
204:39 - process of opening up an external
204:40 - graphical editor you know you can do
204:42 - things quickly
204:44 - so i don't use something like nano as my
204:46 - main editor i like using vs code or
204:49 - something similar but it doesn't mean
204:51 - you shouldn't know how to use it now the
204:52 - basic usage is nano
204:54 - followed by some file name we want to
204:56 - edit
204:57 - so what do we have here i've got a song
204:59 - of myself
205:00 - txt
205:02 - i'm going to open that up with nano so
205:04 - this is a file we've been using quite a
205:06 - bit throughout the course and when i hit
205:08 - enter you'll see that my prompt goes
205:11 - away i'm now in an editor i can use the
205:14 - arrow keys to move and i can actually
205:16 - immediately start editing and this is
205:17 - different if you ever have encountered
205:20 - vim if you start typing
205:22 - you're not actually going to be editing
205:24 - things immediately there's all these
205:25 - different modes and you might be messing
205:27 - things up significantly but i can start
205:29 - typing so if i want you know i can say
205:31 - hello there
205:34 - and
205:35 - i can use my arrow keys left and right
205:36 - just like a regular cursor up and down
205:39 - um
205:40 - and let's just start with that i'll make
205:42 - a little change there
205:44 - all right so i've made this change
205:46 - now i want to save this
205:48 - this is probably the most important part
205:50 - of working with nano is down at the very
205:52 - bottom
205:53 - down here
205:54 - is kind of a little toolbar
205:57 - this is a list of shortcuts the
206:00 - different commands we can use inside of
206:01 - nano and one of the most important ones
206:04 - is
206:05 - this right here control x this is how we
206:07 - can exit
206:08 - so if i do control x right now
206:11 - first it's going to ask me before you go
206:13 - do you want to save or not
206:15 - i'll save that change so i'll hit y
206:18 - if i don't want to save it i'll type n
206:20 - and if i don't want to quit i can do
206:22 - control c
206:24 - okay so i'm going to hit y to save
206:27 - and then it's going to ask me well do
206:28 - you want to keep the same file name do
206:30 - you want to make a new file name uh you
206:32 - know save it somewhere else i'm just
206:34 - going to hit enter and keep the original
206:36 - file so i'm just saving a new version of
206:39 - song of myself instead of a copy
206:42 - all right
206:43 - so it's still there and how do i take a
206:45 - look at the beginning of the file i just
206:47 - want to see if it changed head song of
206:49 - myself
206:50 - there it is we did successfully make a
206:52 - change
206:53 - now there's more that we can do so i'm
206:55 - going to reopen that file
206:56 - in nano
206:58 - and a couple of things first of all if
207:01 - you notice on the right side here uh i'm
207:03 - getting a little angle bracket uh
207:05 - greater than sign that is telling us
207:07 - that there's more text
207:10 - so you can actually turn word wrapping
207:11 - on or line wrapping if you prefer for it
207:13 - to wrap over
207:15 - but i think the default is for it to
207:16 - just scroll as you see there
207:19 - we have different shortcuts
207:21 - down here so if we wanted to search for
207:25 - example
207:26 - to find something in this file i can do
207:28 - control w all right so control w and
207:31 - then i can provide something i want to
207:33 - look for so
207:34 - i want to change the word green in this
207:37 - file so i'm going to type green and i'll
207:39 - hit enter
207:41 - and
207:42 - my cursor shows up right there on the
207:44 - first match of green
207:46 - now i can keep searching again if i do
207:48 - ctrl w and hit enter again see it
207:51 - already remembers green
207:53 - it takes me to the next match so let's
207:55 - just make this all caps
207:58 - and very long green
208:01 - all right
208:02 - uh i'll save and as we saw previously
208:05 - one way of doing that is by quitting and
208:07 - it will prompt me do you want to save
208:09 - blah blah blah
208:10 - but if i don't want to quit and i just
208:12 - want to save my changes i actually do
208:14 - have ctrl s
208:15 - so i just did it it doesn't show up down
208:17 - here
208:18 - there's far more options that don't show
208:20 - up down here
208:21 - i'll show you how to view them in a
208:22 - moment but ctrl s does save to the
208:26 - current file right it's not making a new
208:27 - file name it doesn't give you an option
208:29 - do you want to save this somewhere else
208:31 - it just saves
208:33 - to the same name okay
208:35 - so if i type ctrl g right here
208:38 - get help
208:40 - i wish it was ctrl h ctrl g is harder to
208:42 - remember
208:43 - we get a whole manual here
208:46 - that explains how it works and then
208:48 - explains all the different shortcuts so
208:50 - there's quite a few things in here
208:52 - we saw ctrl w to search forward
208:56 - we can actually insert another file into
208:59 - this file or into this buffer with ctrl
209:01 - r
209:03 - we can cut and paste so this is one that
209:06 - you know you've probably noticed control
209:08 - c
209:08 - uh and control v for copy and paste
209:11 - don't really work in the terminal
209:13 - control c has its own meaning uh
209:15 - just like control z has its own meaning
209:18 - to suspend a job anyway uh we still can
209:22 - cut and paste the way that we can do it
209:24 - is with ctrl k to cut
209:27 - it actually stands for kill
209:29 - and then u
209:30 - to revive or to unkill i don't know what
209:33 - the u stands for
209:35 - and that will
209:36 - basically take whatever we've cut out
209:38 - and paste it so i can show you that
209:41 - there's options to configure a spell
209:43 - checker
209:44 - we can display line numbers we can go to
209:46 - a particular line number if we know what
209:48 - we want with uh where's that
209:51 - control underscore
209:53 - there's a bunch more stuff so you know
209:54 - this is not a course on nano but just so
209:57 - you know there's a lot to nano
209:59 - okay so to get out of here ctrl x is
210:02 - going to close the help screen
210:05 - now as i said i want to show you cutting
210:07 - and pasting so if i want to cut a line
210:11 - i guess maybe i'll just type a line
210:13 - first
210:14 - hi there
210:15 - cut me out of here please
210:18 - all right if i do ctrl k
210:21 - it's gone
210:22 - and then i can move it down somewhere
210:24 - maybe here and ctrl u
210:27 - it revives it and i keep hitting ctrl u
210:29 - there we go
210:31 - it's just like cut and paste uh if you
210:33 - do forget about that we can see
210:35 - shortcuts down here
210:37 - okay so i'm going to save control s we
210:40 - also can do control o to write out if i
210:43 - wanted to create a copy or a different
210:44 - file name i could type that here so
210:47 - maybe uh you know song of myself 2 dot
210:51 - txt and this is my version
210:54 - i'll hit enter do i want to save it
210:55 - under a different name sure
210:57 - and then i'll get out of here ctrl x
211:00 - one more thing i'll show you you can
211:01 - actually create a new file with nano so
211:04 - if i need to add some text into
211:06 - something
211:07 - a file that doesn't exist i don't have
211:08 - to make the empty file first then open
211:10 - it with nano i can just do nano new file
211:12 - dot txt
211:14 - and now i have an empty file i can type
211:15 - my stuff in here
211:16 - save and quit
211:18 - control s control x and there it is
211:21 - song of myself too from the previous
211:24 - nano and then uh new file.txt
211:28 - okay
211:28 - next up we have the alias command the
211:31 - alias command allows us to define our
211:33 - own aliases our own our own little short
211:36 - custom commands
211:37 - that we can then reuse later on so for
211:40 - example if we find ourselves doing you
211:43 - know ls
211:44 - remember just gives us this information
211:47 - ls-a
211:48 - gives us all including hidden files
211:50 - ls-la
211:52 - gives us listed long format information
211:54 - for all files
211:56 - if we find ourselves doing that a lot we
211:58 - could set up our own alias so that we
212:00 - don't have to type all of that and maybe
212:02 - just have la
212:03 - for example
212:05 - so if we wanted to do that i want la to
212:07 - actually be ls-la
212:10 - the way that we do that is by using the
212:12 - alias command
212:13 - so i'll show an example here i'm going
212:15 - to do alias
212:17 - and then
212:18 - let's just call this my i'm gonna do
212:21 - something really obvious first like uh
212:23 - my ls
212:25 - equals and then in quotes i'm gonna use
212:28 - single quotes there's a distinction here
212:30 - uh single quotes and then i'll do ls
212:33 - dash
212:34 - la just like that
212:37 - okay
212:38 - so if i type alias now
212:40 - i'm gonna see a list of all my aliases i
212:42 - actually have quite a few on here here's
212:44 - the one i just made
212:46 - already and if i try running it my
212:48 - ls there we go i have a new alias
212:52 - i could take something you know really
212:54 - long like if there's some find command
212:57 - that i use a lot
212:58 - let me just show an example here
213:00 - i think i have yeah like this one right
213:03 - here this finds some of the i think it's
213:05 - the top 10 uh most uh cpu intensive
213:09 - processes on my machine um honestly i
213:12 - never use it because i don't even
213:13 - remember this
213:14 - but if i run that it's a very long
213:17 - command relatively long
213:18 - i can alias it to something short so
213:20 - pscpu10
213:22 - and there we are i need to sort of zoom
213:25 - out my font size is too large for me to
213:27 - make sense of this here but that's all
213:28 - right i'm recording i need that large
213:30 - font size the alias we just defined is
213:32 - not permanent if i close this window or
213:35 - even just open another window
213:37 - my ls
213:39 - huh
213:40 - it's not working
213:42 - it doesn't know what the heck i'm
213:43 - talking about so when i just define an
213:45 - alias like bobo right here
213:49 - equals
213:50 - i don't know how about just sleep for 10
213:53 - seconds
213:54 - okay
213:56 - when i define that in my shell directly
213:58 - here
213:59 - it only exists in this exact instance
214:02 - right here
214:03 - it is not going to be created every time
214:06 - i open up a new terminal window or my
214:08 - computer restarts i lose it
214:10 - so if i want to make an alias last if i
214:12 - want to have it persist i need to put it
214:15 - in one of a couple different places
214:18 - it depends on what shell you're using if
214:20 - you're using bash if you're using z
214:21 - shell
214:22 - there are different configuration files
214:25 - now
214:26 - over here i'm using bash this is ubuntu
214:29 - the default shell is bash
214:31 - and if i go to my home directory it's
214:32 - actually where i am right now again home
214:35 - meaning my home folder not the folder
214:38 - actually called home it's confusing but
214:40 - my user's home folder colt um if i do ls
214:43 - dash a
214:44 - there are some of these special config
214:46 - files now there's actually on ubuntu
214:48 - there's one called bash aliases and that
214:50 - is a good place to put aliases however
214:53 - that is particular to some distributions
214:56 - of linux it is not something that you
214:58 - may not see it depending on what distro
215:00 - you're using
215:01 - so a safe place is going to be the bash
215:04 - rc file so it's hidden
215:09 - rc uh and i can open it up i'll use nano
215:11 - to edit it dot bash rc
215:14 - okay now i'm in nano i can scroll down
215:18 - and i can define my own aliases in here
215:21 - um so let's just i think i already have
215:24 - some here there we are
215:25 - uh so i'll just define some in here just
215:28 - as an example uh alias
215:30 - and i'm just going to write the exact
215:32 - same thing that i wrote earlier
215:34 - except i'm putting it in this file and
215:36 - what's special about this file is that
215:38 - when the shell loads up it will run this
215:40 - file and it will run these aliases first
215:43 - before i even have a chance to do
215:45 - anything else
215:46 - in other words it will know about all
215:48 - these aliases i define
215:50 - so um let's see what should we do in
215:52 - here i'll make it an alias called
215:55 - um count
215:57 - okay and count is going to echo
216:00 - and if you remember our expansion i'll
216:02 - just echo 1 to 99
216:05 - i don't know why we do this but sure we
216:07 - will
216:08 - uh and then i'm going to save this file
216:10 - so this is nano the easiest way is just
216:12 - control s
216:14 - and then i'm going to exit with control
216:15 - x
216:16 - okay
216:17 - so can i run counts no i can't run count
216:21 - just yet
216:22 - i could open up a new window and it will
216:24 - run that bash rc file and now if i try
216:27 - running count hey it works
216:29 - alternatively if i don't want to do that
216:31 - i can actually source the command is
216:33 - called source
216:34 - my bashrc file and now i can run count
216:37 - in this same window now if you're on a
216:40 - mac
216:41 - the default shell is z shell as we
216:43 - discussed earlier
216:44 - you could switch over to bash if you
216:46 - wanted to
216:48 - and just type bash and now i'm using
216:51 - bash and i can define my files
216:53 - or rather i can define my aliases
216:56 - inside of my let's do ls-a here
216:59 - lots of hidden files
217:01 - inside of my bash profile here
217:03 - that's where i could do it on a mac or
217:05 - more likely if you're using z shell
217:07 - which is the default shell
217:09 - the file we want to add our alias to is
217:12 - dot zshrc
217:15 - where are you z
217:17 - shrc right there
217:19 - so that is our configuration file for z
217:22 - shell so i can do nano dot z s h
217:25 - r c
217:27 - and scroll down i don't have to scroll
217:29 - down i can define my aliases anywhere in
217:31 - here but somewhere in here i can define
217:33 - an alias so let's do a different i don't
217:36 - know a different version of count
217:39 - these are how we write comments by the
217:41 - way
217:42 - so if you want to have a little note or
217:44 - you want to uh have something not take
217:46 - effect you can put a octathorp or a hash
217:48 - sign in front of it so alias let's call
217:51 - this one um hmm
217:53 - let's do
217:55 - uh i'll just do another
217:56 - i don't know count
217:59 - count again but this time on my mac
218:02 - count is going to be an echo
218:06 - about
218:08 - 1 to 365
218:11 - sure
218:13 - all right
218:14 - and that's it we could also define you
218:17 - know l a more useful and how about ll
218:21 - which will be ls dash l
218:24 - and how about uh
218:26 - we'll do l a
218:28 - will be ls
218:30 - dash l a
218:31 - so
218:32 - now
218:34 - and actually why don't i do one more why
218:36 - don't i alias rm
218:39 - to instead be rm dash
218:41 - verbose so it tells me when it deletes
218:44 - something so i have that over on my
218:46 - ubuntu
218:48 - over here which you may have noticed so
218:50 - let's just define those three alias or
218:52 - four we have count lla and rm i
218:55 - redefined the rm command to actually be
218:57 - rm-v so that dash verbose option is
219:00 - always there
219:01 - i'll save and exit
219:04 - yes i'll save okay so in a new window i
219:07 - can run my count command
219:09 - i have the ll command i have la which
219:12 - also does hidden files we can see my
219:15 - hidden files are showing up
219:16 - and then i did the rm command so let's
219:19 - just create a file called remove me
219:23 - and delete me
219:26 - now if i run rm on remove me and delete
219:30 - me
219:31 - oh well i
219:32 - i didn't fully expand delete and to
219:35 - delete me but still it shows me what it
219:37 - removed so let's try try one more time
219:39 - there let's rm delete
219:42 - me
219:43 - there we go and now it just tells me it
219:45 - gives me a bit of feedback as to what
219:46 - was deleted anyway that's the basics of
219:49 - using the alias command remember where
219:51 - you define those aliases first of all if
219:53 - you don't define them in a file one of
219:55 - these special files they will not
219:57 - persist which is fine sometimes you may
219:59 - not need them to but if you do define
220:01 - them and you want them to continue to
220:03 - exist every time you have a new terminal
220:05 - window make sure you put them in the
220:06 - appropriate file depending on whether
220:08 - you're in zs you're using z shell or
220:10 - bash or some other shell they all have
220:12 - their own config files and one last note
220:15 - about working with aliases and
220:16 - specifically with quotes there's a
220:18 - difference in uh bash between single
220:21 - quotes and double quotes
220:23 - when we have double quotes and we have a
220:25 - variable or some form of
220:28 - so remember there's this variable
220:29 - expansion where we have a dollar sign
220:31 - if i echo
220:33 - some dollar sign and then a variable
220:36 - like path
220:37 - or there's user
220:40 - the shell sees this and it expands that
220:42 - or it replaces it with the actual value
220:45 - for user cults and that is what is
220:48 - echoed out okay so if i defined an alias
220:51 - that i just wanted to i don't know how
220:53 - about
220:53 - well let's just use this example here
220:56 - that is going to ls the contents of our
220:58 - current directory if i do ls
221:01 - dollar sign pwd
221:03 - that's what both of these are
221:05 - one has double quotes one has single
221:06 - quotes the difference is that whenever
221:09 - we use double quotes that variable is
221:11 - going to be resolved the value will be
221:13 - set in stone at the the definition time
221:16 - when we actually run this originally
221:19 - so whatever that pwd value is originally
221:22 - it will always be that but if i use
221:25 - single quotes instead
221:27 - single quotes will be resolved or that
221:28 - variable will be resolved whenever we
221:31 - invoke this alias so this in other words
221:34 - will be dependent on when i run this
221:36 - it's not going to be the same thing
221:38 - every time
221:39 - versus this one here because i use
221:41 - double quotes it's always going to be
221:44 - whatever the value is i'll just show you
221:46 - here
221:47 - if i just paste this into my shell
221:48 - currently the value of pwd it's my
221:51 - current directory
221:53 - so if i do ls this
221:55 - it's printing the contents of my home
221:57 - directory but if i go somewhere else
221:59 - like my desktop and i rerun that
222:02 - it's still printing the contents of my
222:04 - home directory no matter where i am it
222:06 - doesn't matter that i'm on the desktop
222:07 - or if i go into uh
222:10 - i don't know this wildlife folder and i
222:13 - run ls this
222:14 - because i used double quotes when i
222:16 - defined that alias this was set in stone
222:19 - at that moment i defined it
222:22 - now if i instead did this so i'll copy
222:24 - that and i'll put this in here alias ls
222:27 - current
222:29 - it is exactly the same inside the quotes
222:32 - remember if i just echo pwd
222:35 - it's a variable and it's just the exact
222:38 - same thing i see if i type pwd but the
222:40 - difference now is that this is going to
222:42 - rerun every single time
222:44 - that i run ls current
222:47 - so if i go to my home directory and i
222:49 - run ls current
222:51 - it shows me the contents of my actual
222:53 - current directory uh it doesn't matter
222:55 - where i was when i defined this so
222:57 - that's an important distinction when we
222:59 - use double and single quotes next up we
223:01 - get to talk about one of my favorite
223:03 - commands it's not my favorite because i
223:04 - use it very much that'd probably have to
223:06 - be i don't know cd or ls or something
223:09 - like that you just can't get around
223:11 - using those all the time
223:12 - but this command x args i don't use very
223:15 - much at all but when i do use it it
223:16 - really comes in handy it's pretty nifty
223:18 - so here's the whole point of it
223:21 - x-args exists to take
223:24 - output from one command
223:26 - and turn it into arguments for a second
223:29 - command
223:30 - so we've seen how we can take
223:32 - something like well first i'll just show
223:34 - you this folder i have i've got some
223:36 - files
223:37 - player two three four five six all the
223:39 - way up to player nine or player ten
223:42 - um so we've seen how we can do things
223:44 - like take
223:46 - ls and then pass that to sort for
223:50 - example
223:51 - right and what's happening here is that
223:54 - the output of ls is being passed as the
223:56 - input to the sort command
223:59 - however when i say input i'm actually
224:01 - referring to something called standard
224:03 - input somewhat of a long explanation to
224:06 - really go into but the idea is that
224:09 - unlike other commands we've seen like
224:11 - when we touch and make files i'll make
224:13 - another file here player 11.txt
224:16 - and
224:17 - player12.txt
224:18 - these are arguments being passed to the
224:21 - touch command it's a list of values
224:23 - separated by spaces
224:25 - so when i run that we end up creating
224:27 - what two new files and they're in here
224:31 - but when we do ls
224:33 - pipe sort we are not passing arguments
224:36 - to sort and this is what's kind of
224:37 - confusing the sort command is set up to
224:40 - accept values
224:42 - through standard input and it's also set
224:45 - up to be able to sort things as
224:47 - arguments so if i provided a file like i
224:49 - have this file called dead players we'll
224:51 - talk about that in a moment it can sort
224:53 - the contents of that file as well so
224:55 - this is passing an argument versus this
224:59 - right here
225:00 - we're passing the output of ls to the
225:02 - standard input of sort
225:04 - anyway i say all of this because only
225:07 - certain commands are set up to work with
225:09 - pipes
225:10 - only certain commands like sort and
225:12 - there's a lot of other ones that will
225:14 - accept an input
225:15 - through standard input rather than
225:17 - through arguments but there are many
225:19 - that don't so for example
225:22 - touch is actually one i just showed you
225:24 - i can't take the output of one command
225:27 - and pass it to touch at least not
225:29 - without x args so let me show what i'm
225:32 - talking about i'm going to show you
225:34 - first what we can't do the problem that
225:36 - xrx solves
225:38 - so i have some files here
225:40 - player 1 through player 12 these
225:42 - represent players in some game
225:44 - and people die after each round of the
225:47 - game and we need to
225:48 - clear them out we need to get rid of the
225:50 - players that died
225:51 - so i have another file called dead
225:54 - players if i just cat it out here you
225:57 - can see it has the names or the files of
225:59 - the players who are dead so what i want
226:01 - to do is take this file whatever's in it
226:04 - and delete or remove those files from
226:07 - the actual folder
226:09 - now this could be you know hundreds and
226:11 - hundreds of dead players and we could
226:13 - have thousands i actually recorded this
226:15 - once where i did have thousands like
226:17 - when i say once i mean like 10 minutes
226:19 - ago i had thousands of players
226:21 - and then i removed half of them but i
226:23 - realized that the scale was too large
226:25 - you really couldn't tell how many were
226:27 - removed
226:28 - so i scaled it down we're dealing with
226:30 - 12 now and we're going to delete what
226:32 - five of them here
226:34 - so aside from me manually doing rm
226:37 - player one and so on the idea is that
226:39 - this could scale up we could have
226:41 - thousands of players and there's some
226:43 - some list we don't even know you know
226:45 - exactly what's in there but some list of
226:46 - dead players it could be hundreds what i
226:49 - want to do is take
226:51 - whatever's in that file and dynamically
226:54 - remove those files so whatever those
226:56 - names are
226:58 - what i can't do unfortunately is just
227:00 - read the file so
227:02 - we can cat it and then pipe it to rm
227:05 - that will not work
227:07 - because the rm command is one of those
227:09 - commands that is expecting a space
227:12 - separated list of arguments it is not
227:14 - expecting anything to be passed to its
227:16 - via standard input so that's what's
227:18 - happening here with this pipe it takes
227:20 - the output of cat and pipes it over to
227:23 - rm but ram is not set up to handle that
227:26 - so
227:27 - just complains it says hey you didn't
227:28 - pass anything in there's no argument so
227:31 - what do you want me to rm just like if i
227:33 - had run rm here
227:35 - this is where x args comes in the x arcs
227:38 - command will take or it will accept
227:40 - standard input which is what's coming in
227:42 - here from this pipe so cat the output is
227:45 - passed to the standard n of rm but rm
227:47 - doesn't want anything to do with it but
227:49 - if we instead do
227:50 - x args
227:53 - if i can spell it rm
227:55 - what it does is it's kind of like an
227:56 - adapter it will take that standard in
227:59 - and then turn it into
228:01 - a list of arguments that will work for
228:04 - rm
228:05 - so this is the syntax
228:07 - x args and then the command that you
228:10 - want x-args to provide the arguments to
228:13 - all right so we're going to take this
228:15 - list of dead players
228:16 - which when we cut that out it's
228:18 - basically going to take this and provide
228:21 - it to x-args x-args then says okay let
228:24 - me turn that into a list of arguments
228:25 - that will work for rm provide that to rm
228:28 - and now
228:29 - when i run it well
228:32 - we see we lost a lot of players they're
228:34 - now gone right i
228:36 - this could scale up again to be hundreds
228:38 - at one time
228:40 - we can take the contents this is a
228:41 - simple example take the contents of one
228:43 - file and then do something with those
228:46 - contents in this case we've removed
228:48 - files that have that had those names
228:50 - let's take a look at one more example uh
228:53 - what i want to do is run the find
228:55 - command
228:56 - just uh on my desktop in all nested
228:59 - folders and files uh to find how about
229:02 - files that are larger so size is plus
229:05 - one m so greater than one megabyte
229:07 - and this is what it finds for me okay
229:10 - but i want more information about these
229:12 - i actually want to then uh do ls dash l
229:16 - right so we get that long listing format
229:18 - but i want ls-l only for these files
229:21 - which is what seven or so files so um if
229:24 - i try and pipe it to ls dash l
229:28 - well surprise surprise ls is not set up
229:30 - to accept values through standard input
229:33 - which is what the pipe does
229:35 - it is expecting
229:36 - us to provide arguments sure after the
229:39 - fact so we could do you know files that
229:41 - end in txt
229:44 - but that has nothing to do with our find
229:46 - command i want to take the results of
229:48 - the find command and then pass those to
229:51 - ls-l in a format that it will accept
229:54 - so this is again where x-args comes in
229:57 - so this is the list of files that are
229:59 - greater than one megabyte and then i can
230:02 - do x-args oops
230:05 - and then ls dash l that's the command i
230:08 - want to run
230:09 - and here we are we now see let's
230:11 - actually do lh so i can get the human
230:13 - readable format for the sizes
230:15 - not very large files on here 1.8 1.8
230:18 - megabytes 1.2 1.2 but these are all the
230:22 - files that we found from that find
230:23 - command
230:24 - uh those values were then passed to xrx
230:27 - xox stepped in and turned it into a
230:30 - acceptable list of arguments that was
230:32 - then provided to ls-lh
230:35 - and that's how we see this output
230:37 - so there's actually quite a bit more to
230:39 - x-args i'm not going to go into here
230:42 - you can read the man pages
230:43 - it's pretty powerful the different ways
230:45 - you can construct
230:47 - the list of arguments the different
230:48 - separators and delimiters and you can
230:50 - have it replace different things for you
230:52 - along the way
230:54 - you can limit the number of arguments
230:56 - it's quite complicated but what i just
230:58 - showed you are some of the more common
231:00 - simple ways of using it and that's the
231:03 - core purpose of x-args is to take
231:05 - standard input and turn it into a list
231:07 - of arguments that other commands will
231:09 - accept all right so next up we're going
231:11 - to talk about the ln command which is
231:13 - used to create links ln link now when i
231:17 - say link it's not a hyperlink or you
231:19 - know something from a browser
231:21 - a link in linux is or it may be a new
231:24 - concept to you
231:25 - it's kind of similar to the idea of a
231:27 - shortcut your desktop shortcuts on a
231:29 - windows operating system
231:31 - where you have some applications that
231:33 - are installed somewhere else it is not
231:35 - on your desktop they are installed
231:36 - completely in a different area but you
231:39 - have access to start them up you can
231:41 - reference them through the icons on your
231:43 - desktop so there's a link
231:46 - those icons have a little picture of
231:47 - whatever adobe photoshop that icon on my
231:49 - desktop when i double click it
231:52 - it is linked it's referencing some
231:54 - actual program that it starts up
231:57 - so the concept is similar we can have a
231:59 - file that is linked that points to
232:01 - another file
232:03 - so there are two types of links
232:05 - hard links and soft links we'll start by
232:07 - covering hard links which actually are
232:08 - not used as frequently
232:10 - but the idea is when we create a hard
232:13 - link we are creating basically a file
232:16 - that will stay in sync with another file
232:18 - now we're not creating a copy we're not
232:20 - duplicating a file it's different they
232:23 - are pointing to the same thing the same
232:25 - exact file so they're not diverging
232:27 - they're not copies it's not like using
232:29 - the cp command that's important to
232:31 - understand so let me show you an example
232:33 - we'll start nice and simple i've got an
232:35 - empty folder
232:36 - i'm going to echo
232:38 - i am original into a file called
232:42 - original.txt
232:44 - all right so i just made this new file
232:46 - we can cat it out and it says i am
232:49 - original and that's the only file in
232:50 - here
232:51 - now the syntax to make a hard link is ln
232:54 - and then the original file which happens
232:56 - to be called original and then whatever
232:58 - our destination or not destination but
233:00 - whatever the name of the link file that
233:02 - we want to create is i'm going to call
233:03 - mine hardlink.txt
233:06 - so if i type ls we have two files now or
233:09 - what appears to be two files uh this
233:11 - hard link file
233:13 - if i cat it out
233:15 - says i am original it has the same
233:18 - contents remember though it is not a
233:20 - copy it is pointing to the same file as
233:23 - this right here
233:25 - so if i change original let's echo
233:28 - this is more
233:31 - stuff
233:32 - we'll append that into original
233:35 - so if we cat out original we see two
233:38 - lines now and if i cat out the hard link
233:41 - we also see two lines
233:43 - and this goes both directions because
233:46 - they're both referring to the exact same
233:48 - thing if i change hard link
233:51 - uh change from hard link
233:54 - and i echo that into the
233:56 - hard link file
233:59 - which is a hard link to that original
234:01 - file
234:02 - this is what it looks like now
234:04 - and if i cat the original
234:06 - it also has that change so they are two
234:09 - things two arrows pointing to that same
234:11 - file in memory and this means if i were
234:13 - to delete
234:15 - well first if i delete the hard link the
234:17 - original file is still there it's
234:18 - unchanged but if i delete the original
234:20 - file
234:21 - my hard link file will persist it is
234:24 - pointing to that same thing in memory
234:26 - and that's what's a little bit confusing
234:28 - here
234:29 - it is not pointing to the you know this
234:31 - name original.txt it's pointing it's
234:33 - called an inode it doesn't really matter
234:35 - but it's referring to
234:37 - the same thing in memory just two
234:39 - different names for it so if i remove
234:41 - original
234:43 - i'll remove it
234:44 - it's gone but our hard link file that is
234:47 - still there that hard link we created
234:49 - and it still has
234:51 - those contents inside so that's a hard
234:53 - link as i mentioned it's not as commonly
234:55 - used
234:56 - then we have soft links
234:59 - and soft links are different the first
235:01 - thing you should know
235:02 - is that to make one we use the dash s
235:05 - option if you just take a look at man ln
235:08 - and then scroll down
235:11 - somewhere on here here we are dash s for
235:14 - symbolic it will make a symbolic link
235:17 - soft link instead of a hard link so
235:20 - what i'm going to do here is remove my
235:21 - hard link
235:24 - and i'm going to create a new original
235:26 - file so we'll echo i am original again
235:29 - into
235:30 - original.txt
235:32 - oh i did dot tt but that's fine
235:34 - um just quick quiz how would i rename
235:36 - that
235:38 - without moving it anywhere
235:39 - easiest way is just move command
235:42 - original dot txt is the destination and
235:45 - there we go
235:46 - okay so i'm going to make a soft link
235:49 - and to do that it's ln
235:51 - s
235:52 - the file that i'm linking to and then
235:55 - the new soft link or the sim link
235:58 - symbolic link
235:59 - i'm going to just call simlink.txt
236:03 - okay
236:04 - so
236:05 - what i have now is a symbolic link or a
236:08 - soft link and if i type ls
236:10 - you'll see if you have colors enabled it
236:12 - really depends on the terminal you're
236:14 - using your operating system your shell
236:16 - but for most
236:17 - terminals it will probably be a
236:19 - difference and for me it's bolded
236:21 - and it is in a different color cyan
236:24 - it doesn't matter what color it is and
236:26 - even if there's no color difference it
236:28 - doesn't matter if we do ls-l
236:30 - we can see a difference as well if you
236:33 - notice here here's my original file
236:35 - here's the sim link file it has this
236:37 - little arrow pointing to that original
236:40 - file
236:41 - additionally over here we haven't really
236:43 - talked about permissions yet
236:44 - but there's a difference there's a dash
236:47 - here is the first digit and there's an l
236:49 - here as the first digit
236:51 - this tells us that it is a symbolic link
236:53 - it's a link
236:54 - anyway
236:56 - just like before
236:58 - if i change the original file
237:00 - let's do a echo
237:04 - change to original
237:08 - and then we will append that to the
237:10 - original file
237:11 - it now looks like this
237:13 - and if i echo or rather cat the simlink
237:17 - file
237:18 - it also prints out the exact same thing
237:21 - now what if i try and change this sim
237:23 - link file echo change to sim link
237:28 - and i append that to the sim link file
237:32 - all right let's see did that change the
237:33 - sim link
237:35 - and does that mean the original has
237:36 - changed
237:37 - yeah it goes both ways in this sense
237:40 - however where there's a big difference
237:41 - is if i delete the original file
237:44 - so i have both of them here right now if
237:46 - i remove original
237:48 - yes
237:51 - now we have this simlink.txt
237:54 - but it doesn't look very happy it's
237:56 - still there
237:57 - but it's showing up in red all of a
237:58 - sudden and if i try and cat the contents
238:02 - it says no such file or directory so
238:04 - it's this link that it's just pointing
238:06 - to something that doesn't even exist
238:07 - anymore
238:08 - so that's the main difference the
238:10 - symbolic link was pointing to
238:12 - original.txt and when original is gone
238:15 - that link is severed with a hard link
238:18 - a hard blank is pointing to don't think
238:20 - of it as pointing to the file itself but
238:22 - think of the hard link and original.txt
238:25 - as two different pointers to the same
238:27 - thing in memory
238:29 - so if i delete the original it's all
238:31 - right we still have the hard link it's
238:32 - pointing to that same thing in memory
238:34 - but here with a sim link i delete the
238:37 - original
238:38 - well now this sim link has nothing to
238:39 - link to and it still is there right we
238:42 - still see something show up but it's
238:44 - just completely dead inside now you
238:45 - might be wondering why would you ever do
238:48 - this why does it matter
238:50 - and this is one of the harder things to
238:51 - explain or to convince you of when
238:53 - you're a beginner and i honestly don't
238:55 - even use sim links all that much or any
238:57 - links
238:58 - although i end up working with people
239:00 - who do use them and so i you know need
239:02 - to be familiar and comfortable working
239:04 - with them it's pretty straightforward
239:06 - once you get used to just that dash s
239:08 - ln-s but let me show you an example um
239:12 - if you have python installed for me i
239:14 - have python i think it came
239:15 - pre-installed and ubuntu and i have a
239:17 - couple different versions i'm going to
239:19 - run an ls-l
239:21 - on this directory user bin
239:24 - and then
239:25 - python i'll come back to in a moment but
239:27 - user bin is where binaries are installed
239:29 - uh and so it's where python binaries
239:32 - will live by default uh and there's a
239:34 - lot in here so first of all if i just
239:36 - get rid of this python thing
239:38 - there's a lot of different programs in
239:40 - here
239:41 - uh one of which i'm just going to focus
239:43 - on for now is python
239:45 - so if i do an ls dash l user slash bin
239:47 - and then anything that starts with
239:49 - python maybe i'll even do python 3
239:51 - because i have python 2 and 3. what we
239:54 - see here let me clear everything else
239:56 - again and just focus on this
239:59 - what you'll see is that there's four
240:00 - matches
240:02 - there's
240:02 - user bin python 3.8
240:05 - 3-futurized
240:08 - 3-pasteurize
240:10 - and then
240:11 - there's this right here what is that
240:14 - that is a sim link
240:16 - and that sim link is just called python
240:19 - 3 but it's pointing to a specific
240:21 - version
240:22 - so when i run python3
240:25 - that's the command i'm running when i
240:27 - run that right here it's actually a sim
240:29 - link and it's referring right now to 3.8
240:32 - but this allows me to manage different
240:34 - versions i could then have 3.9 or
240:36 - three-point you know python versions
240:38 - that don't exist yet or older versions
240:40 - 3.5
240:42 - i can have them all installed and then
240:44 - whatever this sim link it's like a
240:46 - shortcut whatever python 3 is referring
240:48 - to is what version of python will run
240:51 - so i can manage i can have all those
240:53 - versions installed but only one that is
240:55 - actually run when i call python3 so one
240:58 - with this little shortcut
241:00 - and i run python3 and there we go it
241:02 - doesn't matter if you know python or not
241:04 - uh and it actually we have the same
241:06 - thing if i just do python star
241:08 - python 2
241:09 - i only have one version installed but i
241:12 - have a sim link and i don't set this up
241:14 - myself to be clear this was just done
241:15 - for me when i installed python
241:17 - but python2 simlink is referring to
241:20 - there's a little arrow
241:22 - python 2.7 but i could also have 2.8 and
241:24 - 2.5
241:26 - and then switch versions and when i
241:28 - switch versions python 2 will point to
241:31 - one of those versions
241:33 - so that's just a simple example but
241:35 - there are many ways you can use sim
241:37 - links for now though i just want you to
241:39 - understand that ln is a command and that
241:41 - there are two different types of links
241:42 - we can make we can make a hard link and
241:45 - a soft link also known as a sim or
241:47 - symbolic link all right the next couple
241:49 - of commands we'll learn have to do with
241:51 - users and permissions uh they're pretty
241:54 - important ones that may not come up all
241:57 - the time but when they do come up they
241:59 - are really really useful um so on linux
242:03 - we can have multiple users logged in at
242:05 - the same time um doesn't really happen
242:07 - for me i'm kind of just working on my
242:08 - own on this one machine and for most
242:11 - people
242:12 - i shouldn't say most but i imagine for a
242:15 - lot of you who are watching this video
242:17 - you may be the only person using your
242:19 - machine but it's important to understand
242:21 - that you can have multiple users all
242:24 - logged in simultaneously to your same
242:27 - machine it might be hard to do right you
242:30 - may not have the the
242:32 - multiple screens and keyboards and
242:34 - whatever needed to have different people
242:35 - logged in at the same time although it
242:37 - can also be accomplished virtually the
242:39 - point is it's possible
242:41 - there is a command called who
242:43 - not to be confused with who am i who am
242:45 - i tells us the
242:47 - username based on the current effective
242:49 - user id for me that's cold steel here on
242:52 - my mac
242:53 - who is going to tell us about the users
242:55 - who are logged in and like i said for me
242:57 - it's really just me
243:00 - uh but what we'll actually see if i type
243:02 - it on my mac
243:03 - is
243:04 - currently what five seven different uh
243:07 - well if you include this one eight but
243:09 - right here what we're seeing are seven
243:11 - different uh users it's the same user
243:13 - but they're
243:14 - each added here separately for each time
243:17 - i access or each time i log in via a
243:20 - terminal basically every terminal window
243:22 - counts as a user accessing
243:25 - so i have seven right now
243:27 - this is tty is it it's teletype i
243:30 - believe it's an old relic but
243:33 - anyway if i create a new terminal window
243:36 - just
243:37 - ignore it uh and then run who again we
243:40 - now see we've got a 4 which wasn't there
243:43 - before you may not see that but if i
243:46 - zoom way in
243:49 - it says last login on ttyso
243:53 - so um yep
243:54 - that's why we're seeing all of those
243:56 - there anyway not the most useful command
243:58 - certainly not right now
244:00 - and not for me because i'm the only user
244:02 - but if we're an administrator and we've
244:04 - got a whole bunch of people on a machine
244:06 - at once
244:07 - this could be pretty critical to know
244:09 - who is currently logged in
244:11 - next up we'll cover the su command which
244:14 - is short for switch user this command
244:16 - allows us to switch users to log in as
244:19 - someone else within a terminal show
244:22 - so you may have situations where you
244:24 - might need to do this
244:26 - maybe not it really depends on
244:28 - what you're working on and how your
244:30 - machine is set up
244:32 - but if you are an administrator for
244:34 - example and you need to do something on
244:36 - somebody else's account
244:37 - well all you need to do is run the su
244:40 - command followed by some username
244:43 - now i have a different user on this
244:45 - machine so remember i'm colt on this
244:48 - ubuntu uh distribution here right now
244:50 - that's who i'm logged in as but i have
244:53 - a user called elvis
244:55 - and when i do su elvis it asks me to
244:58 - enter elvis's password so i can't just
245:00 - switch users to be whoever i want
245:03 - without knowing passwords unless i'm a
245:06 - root user unless i have full permissions
245:09 - but i don't
245:10 - so
245:11 - i switch user to elvis i need to know
245:12 - elvis password and i
245:14 - think nope i'm pretty sure i just got it
245:17 - wrong
245:18 - i did this last night let's see
245:21 - there we go entered the correct password
245:24 - uh and you'll see my prompt changes now
245:27 - says elvis at my ubuntu and if i type
245:30 - who am i it now says your elvis
245:34 - but just to be very clear this is in one
245:36 - window
245:37 - over here
245:38 - i'm still cult so i haven't completely
245:41 - logged out and become elvis everywhere
245:43 - it's still
245:44 - my horribly messy desktop but i am elvis
245:48 - in this tab
245:49 - aside from what we see when i run who am
245:51 - i if i cd to my home directory
245:55 - well my home directory tilde if i do pwd
245:58 - is home slash elvis
246:01 - whereas over here i cd2 tilde and i do
246:04 - pwd
246:06 - home slash colt is my home directory
246:08 - so as elvis i can do things like
246:11 - well there's nothing in this home
246:13 - directory but i could make a file
246:15 - touch from
246:17 - elvis.txt
246:19 - and i have permission to do that
246:21 - but if i go
246:22 - back and i go into
246:24 - colts account or rather colt's home
246:27 - folder
246:29 - remember i'm logged in as elvis here not
246:32 - colt
246:32 - uh what happens if i try and make a file
246:34 - here called from
246:36 - elvis.txt
246:38 - i can't do that
246:39 - so i'm logged in as elvis but that
246:41 - doesn't mean i can do everything colt
246:43 - can do we have different permissions and
246:45 - that's something we're going to start to
246:47 - try and understand we'll walk through
246:49 - how permissions work
246:51 - but this is just a quick introduction to
246:52 - the concept that different users have
246:54 - different permissions they can do
246:56 - different things
246:57 - and if i went the other direction as
246:59 - colt
247:00 - you know i can make a folder or a file
247:02 - from colts here no problem
247:05 - but if i back out and i try and go into
247:08 - elvis's directory i can do that but if i
247:11 - try and make a file touch from colts.txt
247:15 - no luck i can't do that i don't have
247:16 - permission
247:18 - anyway uh that's the basic idea of using
247:21 - su you probably wouldn't do this just
247:24 - make a random folder or file in somebody
247:26 - else's home directory but if you do need
247:28 - to switch users that's how you do it you
247:30 - need to enter the password and then to
247:31 - get out of here i think you can type
247:33 - exit also you can just do control d or
247:36 - control c i believe
247:38 - now there's another option when we run
247:41 - su if i do man su
247:44 - there's this dash that we can provide
247:46 - and if you provide that dash let's see
247:47 - if i can find it here
247:49 - it will start the shell as a login shell
247:52 - with an environment similar to a real
247:54 - login this means it clears all the
247:56 - environment variables it initializes the
247:58 - environment variable's home shell user
248:00 - log name and path and it changes us over
248:02 - to the target user's home directory so
248:05 - remember when i logged in as elvis i was
248:09 - actually just in colt's home directory
248:11 - anyway it didn't take me to elvis's
248:13 - directory like a normal login would
248:16 - but if i instead do s u
248:19 - dash
248:20 - and then elvis i can also do dash l
248:23 - but it's so common that you can just do
248:25 - dash it's a very short option i'll type
248:28 - elvis password
248:30 - and it takes me right to elvis's home
248:33 - directory this acts as a real login
248:35 - shell and then to get out of here
248:37 - again i can type exits or it is control
248:40 - d i believe there we go
248:42 - okay so that is su to switch users next
248:46 - up we'll talk about the sudo command
248:48 - s-u-d-o
248:50 - which is short for super user do
248:53 - and the command allows us to
248:55 - run commands other commands as the root
248:58 - user or with elevated permissions
249:01 - so there's this concept of the root user
249:04 - a user in linux who
249:06 - basically has permission to do anything
249:10 - to
249:11 - create new users to change passwords to
249:13 - remove files and folders and we actually
249:16 - if i just run ls dash l here i'm logged
249:19 - in as colt
249:21 - what we see here in this third column is
249:23 - the owner of particular files and
249:26 - folders
249:27 - but if i keep backing out
249:30 - now we see you know my different users
249:32 - if i take a look at one of them like
249:34 - kitty
249:36 - kitty owns these files and folders in
249:39 - her his or her desktop
249:41 - or home folder rather but if i back out
249:43 - another level
249:45 - so here i am one more time
249:47 - now we see a bunch of these really
249:50 - important directories uh that i who owns
249:54 - who who owns you know the bin folder
249:57 - where i have things like
249:59 - if we just cdn there
250:02 - all our programs are installed
250:04 - who's in charge of that which user well
250:06 - if i type ls-l
250:08 - we see root all over the place the root
250:12 - user is in charge or not in charge the
250:15 - root user is the owner of these programs
250:17 - these files and folders uh and that's
250:20 - just one example of you know the
250:21 - significance of root root can do all
250:24 - sorts of things
250:25 - like i said a root user can change
250:27 - someone else's password but as colt's
250:29 - just a regular old user i can't do that
250:32 - now there's something very important to
250:33 - know on ubuntu at least in many linux
250:36 - distributions the root user account is
250:38 - actually locked it's not accessible you
250:41 - can't log into it there's no password
250:44 - i can't just log out and log back in as
250:47 - root if i go to log out
250:51 - we will see
250:53 - yes i'll log out
250:55 - we saw the text root all over the place
250:58 - in my terminal
250:59 - but there is no root account that i can
251:02 - actually log in as
251:04 - so why is this well it's just how ubuntu
251:07 - is set up
251:08 - it was a decision that was made
251:10 - rather than having a single root account
251:13 - with a single password that you can log
251:16 - in as instead
251:18 - individual users i have four here colt
251:20 - kitty carrot and elvis individual users
251:24 - uh may be able to run commands as the
251:27 - root user and that's where this pseudo
251:29 - command comes in
251:31 - so how does this work
251:33 - it's not like it's a free-for-all and
251:35 - every single user on a machine can run
251:37 - commands as the root user
251:39 - uh those permissions are are actually
251:41 - listed out in a particular file
251:44 - there's a lot that goes into it and
251:45 - managing those permissions but i'm just
251:47 - going to show you though
251:48 - is that when you create your initial
251:50 - user account so colt was my initial user
251:53 - account whoops
251:56 - i'm logged in now as colts and i'm
251:58 - looking at my settings i can see
252:00 - different users again none of them are
252:03 - called roots but some of them including
252:05 - colt which was the first account i made
252:07 - by default is an administrator so that
252:09 - means i can add and remove other users i
252:12 - can change settings for all users
252:14 - but that's not the same as being the
252:15 - root user
252:17 - and then some other users carrot elvis
252:20 - are not administrators kitty is an
252:22 - administrator when you make a new user
252:24 - you can decide that now that's just one
252:27 - basic
252:28 - difference or one basic
252:30 - toggle between permissions but we can
252:32 - get very detailed about who is allowed
252:34 - to do what but we're not going to go
252:36 - into that i just wanted to make it clear
252:37 - that this sudo command i'm about to show
252:39 - you is not carte blanche for every user
252:42 - to do everything so i'll demonstrate
252:44 - that
252:45 - okay so how do we use this sudo command
252:48 - the idea is that instead of using a
252:50 - single root password each user has their
252:53 - own password we enter that password it's
252:55 - going to prompt us for that password and
252:57 - then it's going to check do you even
252:59 - have permission to run this command as
253:02 - root so it doesn't turn us into the root
253:04 - user
253:05 - it doesn't give us permissions to do
253:06 - everything if we don't already have them
253:08 - it only allows us to do certain commands
253:11 - that we are specifically already
253:13 - permitted to do it's just an extra level
253:16 - of protection basically you have to type
253:18 - sudo you have to type your password so
253:20 - even if you have those permissions you
253:22 - can't just normally go around deleting
253:23 - everyone's stuff
253:25 - you need to run sudo in order to do that
253:27 - so if i wanted to
253:29 - edit some particular configuration file
253:32 - that affects everyone on a machine
253:35 - if i just tried to open it in nano i'm
253:37 - not going to be able to do that but if i
253:40 - try using sudo first i'll enter my
253:43 - password and it will check if i'm
253:44 - allowed to do that or not so let me show
253:46 - you uh let me get my terminal open
253:48 - so the file that we're going to look at
253:50 - is in slash etsy etc
253:54 - host that's the name of the file
253:56 - and if i just do an ls-l on it
253:59 - remember this is a high up directory it
254:01 - is not located in colt's user directory
254:04 - or any other user it's above
254:06 - and if i run ls-l we can see that the
254:09 - owner is the root user but again there
254:12 - is actually no way to log in as the root
254:14 - user in ubuntu
254:16 - so
254:17 - uh if i want to edit this file for some
254:19 - reason i could try running nano
254:23 - and it does open up i can actually read
254:25 - the contents but it tells me for you
254:27 - this file is unwritable
254:30 - so i can't make changes
254:32 - i'll get out of here but if i now prefix
254:35 - this with sudo
254:37 - super user do
254:39 - this so super user do this command it's
254:42 - first going to say enter your password
254:44 - for colts that's who i currently am and
254:46 - it's going to check if i have permission
254:49 - if i am granted those root permissions
254:52 - to edit this particular file
254:55 - so if i enter my password this is not
254:57 - the root password this is colt's
254:59 - password that i log in with
255:01 - and we see i actually am able to edit
255:04 - this file i'm not going to
255:06 - because i really don't want to but this
255:08 - is a file i can change now
255:10 - but if i go
255:11 - log in as a different user and remember
255:14 - we saw how to do this
255:15 - i can use su dash i have elvis as a user
255:18 - on this account
255:20 - i'll type elvis's password
255:23 - okay
255:24 - who am i i am elvis so if i try and run
255:27 - this nano etc
255:29 - hosts i also see hey you don't have
255:32 - permission to do that that's a file
255:34 - owned by root
255:36 - but if i try sudo
255:39 - just like i did as colt it now asks me
255:41 - for elvis's password so what is elvis's
255:44 - password well i'm not telling you
255:46 - but i know it i type it in
255:48 - and it tells me
255:49 - nope that's not going to work we checked
255:52 - elvis is not in the sudoers or sudoers
255:54 - file we're not going to really go into
255:56 - that but there's ways of managing who
255:58 - can do what it's more of an
255:59 - administrative process or a specialty
256:02 - that i'm just not going to go into here
256:04 - but it's important to note specific
256:06 - users can have different permissions who
256:09 - is allowed to do what as the root user
256:11 - and elvis doesn't have any
256:13 - so i can't edit that file as elvis but
256:16 - again if i switch back to being cult
256:18 - i'll just get out of here with exit
256:20 - and i run that sudo nano blah blah blah
256:24 - i already entered my password so it
256:26 - remembers it there just to be clear
256:28 - but you will need to enter your password
256:30 - when you run sudo your particular user's
256:33 - password now you've probably actually
256:35 - come across this before when it comes to
256:38 - installing software or installing new
256:40 - commands there's a command
256:42 - called tldr i don't have it installed
256:45 - and if i try typing it
256:48 - my shell is going to tell me i don't
256:49 - know what you're talking about but here
256:51 - are some things you could try installing
256:53 - so there's a command called apt install
256:56 - and then the package tldr
256:59 - but if i just run that without sudo
257:03 - i'm not allowed to do that
257:04 - because i'm installing something that
257:07 - is not even just specific to my user
257:09 - here it actually is specific or not
257:11 - specific it would apply to all users on
257:13 - my machine i'm actually installing a
257:15 - program a command that everyone can use
257:18 - so i can't just go around doing that i
257:20 - need to have permission so that's why we
257:22 - run sudo
257:23 - do i have permission to install this
257:25 - well i already entered my password again
257:28 - so it knows who i am and what
257:31 - permissions i have
257:32 - to do as root user i can install it so i
257:35 - will continue
257:37 - and it will take a little while to
257:38 - install
257:39 - the the point of this is not to show you
257:41 - how to install things by the way it's
257:42 - just to show you another situation where
257:45 - you would need to use sudo
257:46 - so anytime you're trying to make changes
257:48 - you run into a permission denied error
257:51 - you'll often be prompted to try it again
257:53 - with sudo first
257:55 - so sudo itself we prefix in front of
257:58 - other commands
257:59 - and then it will prompt us for our
258:00 - password and now i have this tl dr
258:03 - command just show it to you on the man
258:05 - page for it here we are anyway uh it
258:08 - really doesn't matter it was just about
258:09 - using sudo so it really depends on who
258:12 - you're logged in as and what permissions
258:14 - you specifically have been granted and
258:16 - that is something that can be tweaked it
258:18 - can be really
258:20 - down to a pretty granular level i
258:22 - haven't changed anything it's just that
258:24 - some users have administrator
258:26 - permissions on here some of them don't
258:28 - now not all linux distributions will
258:30 - have the root account locked so you
258:32 - can't log into it directly some of them
258:34 - you can but even then we still have
258:36 - access to the sudo command and we can
258:38 - grant specific users
258:40 - different privileges as root it's also
258:43 - you know on my mac i cannot run things
258:45 - with sudo and i often need to if i'm
258:47 - installing something that is system-wide
258:49 - same idea the next command will cover is
258:51 - the password command which is actually
258:53 - pass wd
258:55 - i guess those extra two letters are too
258:57 - long
258:58 - and this is the command we can use to
259:00 - change someone's password so there's two
259:02 - ways of using it you can change your own
259:03 - password by just typing passwd
259:07 - so i'm logged in as called i don't
259:08 - really i mean i guess i'll change my
259:10 - password then i'll change it back
259:11 - so it's going to ask me for my current
259:13 - password so i have to know that and then
259:16 - it asked me for my new password
259:18 - and let's do uh
259:20 - well i'm not gonna tell you and then i
259:21 - have to confirm it again
259:24 - okay i updated my password and you can
259:26 - just trust that it worked i mean
259:28 - i how would you really know i guess i'm
259:30 - not going to tell you what it was before
259:31 - or now although none of them are
259:33 - actually real passwords anyway but it
259:35 - did change and if i were to log out i
259:37 - would need to use that new password so
259:40 - i'm just going to change it back one
259:41 - more time current password whoops i
259:43 - messed up i'm gonna do that again so my
259:46 - current password i just changed it to
259:48 - my new one
259:52 - okay now i can also change someone
259:54 - else's password uh assuming i have root
259:56 - permissions uh so let's say i need to
259:59 - change elvis password he's forgotten it
260:01 - there's actually a lot you can do you
260:02 - can lock someone's password
260:05 - you can
260:06 - if we just go to man
260:07 - pass wd
260:10 - you can do things like
260:12 - expire an account's password which would
260:15 - force them to change their password next
260:17 - time they log in but it doesn't actually
260:18 - give them a new password you can make an
260:21 - empty password to disable a password for
260:23 - an account there's a lot here um i'm
260:25 - just going to show the basics so i want
260:27 - to change elvis password
260:29 - pass wd
260:31 - elvis
260:32 - well
260:33 - i can't do that right as colts i need to
260:35 - do it as the root user or i guess as
260:39 - elvis uh but as the root user is
260:41 - probably more likely right why would
260:43 - elvis need to change his password from
260:44 - my account uh so if i have permissions
260:47 - i'm the administrator remember on ubuntu
260:50 - i can't log in as root so this is the
260:52 - closest thing i'm an admin i have
260:53 - permission to do this but i have to use
260:56 - sudo
260:57 - so sudo password elvis is now going to
261:00 - ask me for my password not elvises it's
261:03 - going to ask me for mine and it's going
261:04 - to just verify are you even allowed to
261:06 - do that as colt
261:07 - okay
261:08 - now it's asking me for elvis's new
261:10 - password
261:11 - so i'm just going to change it to
261:14 - how about hacked
261:16 - okay and one more time
261:19 - and now i just changed elvis password
261:22 - i guess you know i could show it to you
261:24 - quickly if i do an su elvis
261:27 - if i try and use elvis's old password
261:29 - which was
261:30 - something involving the word taco it
261:33 - doesn't work but now if i log in as
261:35 - elvis using hacked
261:38 - it does work
261:39 - and then as elvis i could change my
261:41 - password again
261:43 - using password
261:44 - and i don't need any fancy permissions
261:46 - you can change your own password
261:48 - all right so that's the basic use of
261:50 - password it is past wd there is more to
261:53 - it as i said you can lock someone's
261:54 - password you can delete it uh you can
261:56 - expire it and force them to set a new
261:58 - one when they log in
262:00 - but again it comes down to you can
262:01 - change your own password or if you have
262:04 - permission as the root user
262:06 - you can use sudo in order to change
262:08 - somebody else's password the next
262:10 - command we'll cover is one of my
262:11 - favorites to say out loud chon or town
262:15 - change ownership
262:17 - this is the command we can use to change
262:19 - who owns a particular file or directory
262:23 - so let's talk about what that means to
262:24 - own a file or directory um on every file
262:28 - every directory let me just go home here
262:30 - i'm logged in as colt
262:32 - who am i
262:33 - um when we do ls-l
262:35 - we see a whole bunch of information
262:37 - we're going to talk more about what this
262:39 - is in just a little bit permissions
262:41 - and then this right here this third
262:43 - column
262:45 - is the owner of the entry so in this
262:47 - case the owner of this directory files
262:49 - exercise is me cold
262:52 - uh the owner of music is colt
262:56 - this is pretty normal to own all the
262:59 - stuff in your home directory
263:01 - but if i go to somebody else's directory
263:04 - if i have multiple users let's go to
263:06 - kitty's directory so this is her home
263:09 - directory
263:10 - kitty owns almost all of these files and
263:13 - folders and if i keep backing out
263:15 - further we've seen this before
263:18 - root
263:20 - the root user owns all of these
263:22 - directories and files
263:24 - so the chon command helps us change who
263:26 - owns those files and that's important to
263:29 - do because the owner of a file is
263:30 - allowed to
263:33 - change its permissions to delete it
263:35 - potentially to read or to write to that
263:37 - file
263:38 - it all has to do with what we see over
263:40 - here which we'll get into in just a
263:42 - little bit but for now i just want to
263:44 - show that we can change the owner
263:46 - and then we'll understand we'll try to
263:48 - understand its implications later on
263:50 - when we talk about another command all
263:51 - right so i'm going to go back home
263:54 - and
263:55 - the syntax to change the owner looks
263:58 - like this tone
263:59 - and then the owner that we want to
264:02 - add as the owner so a user
264:04 - and then the file that we're trying to
264:06 - change
264:08 - so um i'm going to go into elvis's
264:10 - directory
264:12 - or maybe
264:13 - it doesn't really matter here i'll go
264:14 - into kitties
264:15 - kitty
264:17 - all these files almost all of them
264:19 - are owned by kitty
264:21 - if i wanted to if i wanted to change the
264:24 - owner of how about kitty's music
264:28 - directory
264:29 - the syntax would be change owner chone
264:32 - and then me colt that's the user i'm
264:35 - trying to add as the owner and then
264:38 - after that
264:39 - music
264:41 - now there is a bit of a problem
264:43 - i can't just change somebody else's you
264:45 - know i can't just make myself the owner
264:47 - of somebody else's directory uh all over
264:49 - the place like that is something i have
264:51 - to have permission to do
264:52 - and we've recently learned that we can
264:55 - use the pseudo command to act as the
264:57 - root user
264:58 - so that is one option here is if i have
265:01 - root permissions i can change the owner
265:03 - of any files sudo
265:05 - tone cult music
265:07 - so it's going to ask me for my password
265:10 - and then i enter it and i don't see
265:12 - anything but that's a good sign
265:15 - that means that i did have permission to
265:16 - do that
265:17 - and now you can see cult is indeed the
265:20 - owner of this music directory
265:23 - now again we haven't really talked about
265:24 - what that means for me to be the owner
265:27 - but i'll just show you for example if i
265:29 - were to go into the desktop
265:34 - and try and create a file touch made by
265:36 - colt
265:38 - i don't have permission in that
265:39 - directory but if i go back out and i go
265:41 - into music
265:43 - if i touch a file touch made by colt
265:47 - i do have permission now because i am
265:49 - the owner
265:50 - as we saw i did ls-l
265:52 - i own that folder music one commonly
265:56 - used flag with chone is uppercase r
265:59 - which we can use to recursively change
266:01 - the ownership of all the files and
266:03 - subdirectories nested in a directory
266:07 - so i have this directory i just made
266:09 - called cat stuff
266:11 - and it has
266:13 - some files inside of it and then a
266:15 - nested directory with some other files
266:17 - and if i decide i want to make the owner
266:19 - of cat stuff kitty and this is all kind
266:22 - of silly and you probably won't just
266:24 - make a directory in your home folder and
266:26 - then make someone else the owner at
266:28 - least not frequently but just for demo
266:30 - purposes if i make kitty another user on
266:32 - my
266:34 - computer if i make her the owner
266:36 - i can do chone
266:38 - kitty
266:39 - and then i need the name of that
266:41 - directory which is cat stuff and i do
266:44 - need to use sudo
266:46 - even though it's my own folder that
266:47 - might seem weird like you should be able
266:49 - to change who owns your own stuff
266:51 - the way linux is set up that is not the
266:53 - case you still need to have root
266:54 - permissions
266:56 - now you can change the permissions
266:58 - attributes we'll talk about very very
267:00 - shortly uh if you are the owner um but
267:03 - you can't change the actual owner of a
267:05 - file unless you have root permissions
267:08 - and i already typed my password a couple
267:09 - minutes ago or seconds ago so i don't
267:11 - have to redo it
267:12 - and if i do ls-l we see
267:15 - where are you
267:17 - cat stuff kitty is the owner but if we
267:20 - cdn to cat stuff
267:22 - ls-l
267:24 - i cult still own all the files and the
267:26 - nested directory so to change that we
267:29 - can just rerun that line
267:31 - the tone line
267:33 - but we use the dash uppercase r to
267:36 - recursively change the ownership and now
267:38 - if i go back into cat stuff
267:41 - kitty is indeed the owner of all the
267:43 - nested contents if we go into toys same
267:45 - thing there kitty is the owner of those
267:47 - files
267:48 - okay
267:49 - now another thing you may notice when i
267:51 - run ls-l
267:53 - let me go to uh how about kitty's home
267:56 - folder
267:57 - so we'll go
267:59 - slash home slash kitty
268:02 - instead of here when i do ls-l on any it
268:05 - doesn't matter where but in this
268:06 - directory ls lsl i see a bunch of
268:08 - folders and files there's an owner that
268:10 - we talked about
268:11 - that is a single user who is the owner
268:15 - of that file
268:16 - but then
268:17 - why does it say kitty again or here it
268:20 - says pals forever what is this second
268:22 - thing
268:23 - this is known as the group owner this is
268:26 - a little confusing but every file on a
268:28 - linux system has an owner and it has a
268:31 - group that owns it and that group can
268:34 - have multiple people's people users who
268:37 - are members of that group and then the
268:38 - group can get its own set of permissions
268:41 - so this means that um you know i could
268:43 - be the owner of this file and i might be
268:45 - able to read write delete whatever i
268:47 - want and then
268:49 - members of the pals forever group might
268:52 - be able to read only but they're not
268:54 - able to edit this file they're not able
268:56 - to write to it
268:58 - so this allows us to have two different
269:00 - levels of permissions the owner can have
269:03 - some set of permissions what are they
269:05 - allowed to do and then members of the
269:07 - group that is an owner the group owner
269:10 - they also can have a separate set of
269:12 - permissions
269:14 - and it's all encoded in these weird
269:16 - little digits that rwx and dash is here
269:19 - we will talk about that very soon but
269:21 - what i want to show you right now is
269:22 - that we can just change the group that
269:24 - owns a file using chone now this is
269:27 - something you probably won't do very
269:28 - much and i'm not diving into groups and
269:30 - managing groups and creating new groups
269:32 - and changing members who belongs to a
269:34 - group that's all more admin stuff anyway
269:38 - not day-to-day user stuff at least in my
269:40 - experience and with my students
269:42 - but it's worth knowing that we can use
269:44 - the shown command to change the group
269:46 - owner
269:47 - so i have this group called pals forever
269:50 - i can actually there's a command called
269:52 - groups i can see all the groups that i
269:54 - the current user belongs to so here's
269:57 - all the groups we've got
269:59 - uh movie club
270:01 - pals forever let's say i want to change
270:04 - the group that owns music
270:06 - from kitty and this is also somewhat
270:09 - confusing by default the group
270:12 - is going to be a group with your
270:13 - username
270:14 - so it says kitty and kitty but this is
270:17 - the group owner this is the owner owner
270:20 - all right
270:21 - if i want to take this music directory
270:23 - and make
270:24 - pals forever the group owner the syntax
270:27 - looks like this
270:28 - where we have the owner name a colon and
270:31 - then the group that we want to add
270:34 - so here if i want to keep the owner as
270:36 - colt i need to do pseudo chone
270:40 - cult colon pals forever
270:44 - and then
270:45 - music is what i'm trying to change
270:48 - so this will be the owner and this is
270:49 - the group owner
270:52 - ls-l and if we look at music that group
270:55 - has changed
270:57 - now again the idea behind groups is that
270:59 - we could have 10 different users who are
271:01 - part of this group and they might be
271:03 - able to read this directory only
271:06 - but then the owner
271:07 - can read and write and execute and do
271:09 - everything
271:10 - so we can have these different levels so
271:12 - it's not just one person who's allowed
271:13 - to do things for the file we can
271:15 - selectively change these groups
271:17 - and add people to the groups but that
271:19 - again is a more advanced admin thing we
271:21 - don't really need to worry about
271:23 - all right so the next thing we're going
271:24 - to talk about
271:26 - is understanding when i do ls-l the very
271:29 - first chunk of really bizarre looking
271:31 - text these characters here we want to
271:34 - understand what these are what they mean
271:36 - because we're also going to learn a
271:38 - command that allows us to change these
271:40 - so what we're looking at right here
271:42 - is for every file every directory
271:44 - these are the permissions or the file
271:46 - attributes they
271:48 - detail what the owner is allowed to do
271:50 - can you read write or execute this file
271:53 - uh what the group members who are part
271:56 - of the group that owns this file can do
271:58 - read write and execute and what everyone
272:00 - else can do can
272:02 - the world at large any user read write
272:05 - or execute
272:06 - so there's a lot to break down there's
272:08 - actually 10 digits here not digits 10
272:10 - characters
272:12 - and the first character
272:13 - actually i'm using some of my slides
272:15 - i've made for a course on udemy if
272:17 - you're interested in a lot more of a
272:20 - deep dive into linux commands
272:22 - because this is just hard to explain
272:23 - without graphics or some visuals so
272:25 - anyway that first letter is either going
272:28 - to be a dash so not a letter that
272:31 - indicates that it's a file a plain old
272:33 - regular file id
272:35 - indicates a directory so we can see that
272:38 - already here's a file dot txt it has a
272:41 - dash
272:42 - that's the first character here's a
272:44 - folder or a directory it has a d
272:47 - and then for sim links i think if i just
272:50 - back out a little bit here
272:52 - they'll start with an l so here's a sim
272:54 - link here we can see we also have that
272:57 - arrow pointing to you know where the
272:59 - link is linking to
273:01 - and it starts with an l so that's the
273:03 - first thing
273:04 - that's kind of just a one-off then we
273:06 - have nine characters which is actually
273:10 - three sets of three
273:12 - the first group of three tells us the
273:14 - permissions for the owner of the file or
273:17 - directory
273:18 - the second group tells us the
273:20 - permissions for the group owner or for
273:22 - members in that group
273:25 - and then finally the third group
273:27 - tells us the permissions for everyone
273:29 - else the world at large any other user
273:31 - that's not the owner or that is not part
273:33 - of the group that owns the file or
273:35 - folder now within each group of three
273:38 - we'll just take the first one so for an
273:40 - owner those first three digits
273:42 - they tell us the read writes and execute
273:45 - permissions for this file can the owner
273:48 - read write or execute so those three
273:50 - characters in a very particular order
273:52 - the read permission is first then the
273:54 - right permission then the execute and
273:56 - then it starts over
273:57 - read write execute for the group owner
273:59 - or group members read write and execute
274:01 - for everyone else
274:03 - so what do these three permissions mean
274:05 - well
274:06 - if we have an r in that first spot right
274:09 - here there's an r here there's an r here
274:11 - there's an arm
274:12 - that means that the file can be read if
274:15 - it's a file or if it's a directory it
274:17 - means that the contents of that
274:18 - directory can be listed okay so here i
274:21 - have a single file i've created called
274:25 - onlycoltscanread.txt
274:28 - and we'll learn how you can change these
274:30 - permissions but i've already changed
274:31 - them the first thing we see here is a
274:33 - dash that means that it's a file
274:35 - then we have those first three digits
274:38 - which are the owner permissions now the
274:40 - owner is colt
274:41 - and there is an r present here which
274:43 - means that i have permission to read
274:46 - the owner whoever that is has permission
274:48 - to read the contents of this file and i
274:50 - can read it
274:51 - okay
274:53 - then we have the next three
274:55 - which is all just dashes which means
274:57 - none of those permissions are present so
274:59 - this is the group permissions anyone
275:01 - who's a member of this group well they
275:03 - don't have any permissions here and then
275:05 - everyone else
275:07 - they also don't have permissions so that
275:09 - r would be that character right there
275:11 - there is no r that means whenever we
275:13 - have a dash that the file is not
275:16 - readable
275:17 - or executable or writable depending on
275:20 - the location of where that dash is
275:22 - so here if there's a dash that means the
275:25 - owner couldn't read it but there is not
275:26 - a dash there's a r which means we do
275:29 - have read permissions so let me
275:30 - demonstrate this if i switch over i'm
275:32 - just going to log in as elvis
275:38 - if i can remember the password
275:40 - uh oh that's not it
275:42 - all right let's try that again
275:46 - oh wait i think i changed it to hacked
275:48 - didn't i i forgot about that
275:51 - there we go all right so i'm now elvis
275:54 - who am i
275:56 - if i do an ls-l well i'm not cult i'm
275:59 - not part of this group uh so i'm
276:02 - considered anyone else i don't have read
276:04 - permissions there's just a dash there if
276:07 - i try and cat the file out
276:09 - permission denied only colt can read
276:12 - that file or only the owner which
276:14 - happens to be colt
276:16 - okay
276:17 - so this pattern holds true for all of
276:20 - these permissions if there's a dash in
276:22 - any of these spots it means that that
276:25 - respective if it's the world the group
276:27 - the owner does not have that permission
276:30 - so here we can see the owner does not
276:32 - have execute permissions the group does
276:34 - not have execute permissions everyone
276:36 - else does not have write or execute
276:39 - permissions
276:40 - now what those mean we'll dive into but
276:42 - for reading as we saw
276:44 - if there's an r there that means the
276:46 - file can be read
276:47 - and if there's an r on a directory that
276:50 - means that we can list the contents of
276:51 - that directory
276:53 - so this is why
276:54 - as elvis
276:55 - i can do ls or ls-l or something on this
277:00 - directory
277:01 - it's actually going to zoom out further
277:03 - or move back one level
277:05 - if we look here
277:06 - this is each user's home folder so we've
277:09 - got carrot colts elvis and kitty
277:12 - each user has rwx that means read write
277:15 - and execute
277:16 - but then
277:17 - there's an r present for everyone else
277:20 - for that world right everyone can still
277:23 - read these directories
277:25 - that doesn't mean i can change them of
277:27 - course but this is why as elvis i can go
277:30 - into colts directories and and list ls-l
277:33 - i have that permission because i have
277:36 - that r attribute right there
277:38 - in that third set so remember
277:41 - first three
277:42 - that's going to be the owner
277:44 - members of the group
277:46 - and then everyone else
277:48 - and i currently
277:50 - and part of that everyone else i'm able
277:52 - to read the contents here but uh through
277:55 - some editing magic uh i did just change
277:58 - the permissions on the permissions
278:01 - directory here if you notice now there
278:03 - is no r present we'll learn how to
278:05 - change that in a bit uh on this third
278:08 - grouping which means that anyone who is
278:10 - not the owner or part of this group
278:12 - cannot read the contents of this
278:14 - directory now it is a directory so what
278:16 - does that mean remember the r character
278:19 - means that you can list the contents of
278:21 - a directory if it's a directory or you
278:23 - can read the contents of a file if it's
278:25 - a file
278:26 - well i'm elvis still if i try an ls that
278:29 - permissions folder
278:31 - i can't
278:32 - i can ls any of the others i can ls
278:34 - music i can ls desktop but when i try
278:38 - permissions
278:39 - i can't do that because once again
278:42 - we no longer have an r present there
278:45 - but if i switch back to being cold
278:47 - now i'm cold
278:49 - we can see
278:50 - i can
278:51 - ls permissions no problem
278:54 - because we have an r in that first
278:56 - grouping which is the owner's permission
278:58 - so i can read all right so that's our
279:01 - first
279:02 - type of permission read permission
279:04 - if there's an r present here here or
279:06 - here that means that either the owner
279:09 - members of the group or everyone else
279:11 - can read
279:12 - next we have this second slot which is
279:15 - for write permissions so a dash means no
279:18 - write permissions a w means write
279:20 - permissions
279:21 - so for a file that means that we can
279:23 - modify the file and for a directory this
279:26 - means that the contents can be modified
279:28 - you could change files you could make a
279:31 - new file for example you could rename
279:34 - but
279:34 - this actually only takes effect if the
279:36 - executable attribute is also set which
279:39 - is that third piece here so let's just
279:42 - focus on files so if we have a w present
279:45 - that means we can write to a file so
279:48 - here we have ilovekitty.txt
279:50 - the owner is cult
279:52 - there's a w there right here's that
279:54 - first group or i shouldn't say group but
279:56 - the first chunk
279:57 - 123 for the owner i can write to that
280:01 - file uh i can echo into it let's just do
280:03 - echo meow
280:05 - into i love
280:08 - no i need uppercase l
280:11 - no problem i'm cold i can do that if i
280:13 - cat it out
280:15 - we see it has meow
280:17 - but now if i switch back to being elvis
280:19 - put elvis's new hacked password in there
280:22 - i am elvis here
280:24 - if i as elvis try and add to that file
280:27 - if i try and open it with nano if i try
280:30 - and echo something into it
280:31 - well elvis is not cult so these
280:33 - permissions don't apply not part of that
280:35 - group parallels so these don't apply but
280:37 - it doesn't matter anyway because it's
280:39 - the same as the permissions for everyone
280:41 - else
280:42 - what we see here is that
280:44 - everyone has read permissions
280:46 - but no write permissions
280:49 - so i cannot write to that file
280:52 - if i try to echo
280:54 - um i don't know hi from elvis into i
280:59 - love kitty
281:01 - permission denied i cannot write to that
281:03 - file
281:04 - but i can print it out or read the
281:06 - contents because once again we have
281:09 - that r right there so i'm elvis that r
281:13 - applies to me i'm not the owner i'm not
281:15 - part of this group we have read but no
281:18 - write permissions and then what about
281:19 - this third slot here
281:21 - so that third slot is either going to be
281:23 - an x or a dash if it's a dash it means
281:28 - no execute or executable permissions
281:30 - if it's an x that means we do have
281:33 - executable permissions so what does that
281:35 - mean
281:36 - well it's easier to understand in the
281:38 - context of directories if we have a
281:41 - directory
281:42 - you'll see actually there's a lot of x's
281:44 - on directories by default everyone has x
281:48 - executable permissions on folders all
281:50 - that means is that we can cd into a
281:53 - directory
281:54 - so
281:55 - it doesn't matter who i am right now
281:57 - let's take a look at the wildlife
281:58 - directory
282:00 - there's an x present for the owner group
282:02 - members and for everyone else so i'm
282:04 - currently elvis i can cd into wildlife
282:07 - no problem
282:08 - i'm in there
282:09 - now if i behind the scenes get rid of
282:12 - that x i'll do it right now there we go
282:15 - there is no x there anymore we're about
282:17 - to see how to do that
282:19 - i'm going to go back to being elvis
282:22 - if i try and cd into wildlife now
282:26 - cd into wildlife
282:28 - permission denied
282:30 - we don't have an x there
282:32 - and for elvis that means he can't
282:34 - execute you cannot cd into that
282:36 - directory now members of the group
282:39 - parallels in this case anyone who's in
282:41 - that group can and then the owner cult
282:44 - can cd as well because that's the owners
282:47 - execute the group members execute and
282:49 - then everyone else is execute
282:51 - so normally you'll have x present all
282:54 - over the place for directories but i
282:55 - just removed it here to show you the
282:56 - consequences i'll go back to being cult
283:00 - and i can cd into wildlife no problem
283:03 - now it's a little trickier to explain
283:05 - what it means when we have a file
283:07 - for files that have an x present here
283:11 - so if i were to show you a couple of
283:13 - examples like this right here these
283:14 - permissions
283:16 - means that an owner has read write and
283:18 - execute permissions for this file no one
283:21 - else has any access whatsoever
283:23 - what does that x mean on a file
283:26 - it means that the file can be treated as
283:28 - a program and can be executed
283:31 - so if you write your own scripts you
283:33 - write your own programs and you want
283:34 - them to become
283:35 - executable you need to have that x there
283:39 - so we're not going to see that right now
283:40 - but i'll show you some examples of
283:42 - things that are executables if we cd
283:45 - back a couple of times
283:46 - we go into bin
283:48 - what we see here if i do an ls-l
283:51 - are lots of x is present but these are
283:54 - actually files so these are programs
283:57 - as you can see
283:59 - so there's a lot of programs here uh
284:01 - once again i'm in slash
284:03 - slash bin rather is my path name right
284:06 - now
284:07 - binaries this is where programs are
284:09 - stored
284:10 - so uh if you know here's touch for
284:13 - example that is a program that i can run
284:16 - obviously we use it all the time or if
284:18 - we find let's see is there another
284:20 - simple one in here here we go here is
284:23 - echo
284:24 - so our echo program that we run that
284:26 - command it's defined right here it's a
284:28 - file it has some code in there
284:30 - and as you see it's x x x that means we
284:34 - can execute it as a program we can
284:37 - actually run it okay so what i want to
284:39 - demonstrate is a little odd but there's
284:41 - a program called ncal it gives us a
284:43 - calendar
284:44 - uh i'm going to make it so i can't
284:46 - actually execute that and then i'm going
284:48 - to undo it but i'm not going to show you
284:49 - how just yet i'm just going to
284:51 - demonstrate so if i do an ls-l on ncal
284:54 - in slash bin here it is
284:56 - we see the owner which is root members
284:59 - of the group which is also root and
285:02 - everyone else has that x present that
285:04 - means anyone can execute this
285:06 - i'm going to change that so i just did
285:08 - that
285:09 - now i do ls
285:10 - dash l on ncal again this program
285:14 - no longer has an x right there it did
285:16 - just a moment ago
285:17 - now this means that only the owner which
285:20 - is root i'm not root only members of the
285:23 - group root which i'm not a member of
285:25 - can execute everyone else does not have
285:28 - that x there no executable permissions
285:31 - on this file
285:32 - so now if i try and run ncal
285:35 - oh
285:36 - permission denied i can't run that
285:38 - script i cannot use that command anymore
285:40 - because it's not executable
285:42 - so that x is very very important uh and
285:45 - you probably wouldn't go around removing
285:47 - those
285:48 - but just to show you what the
285:50 - significance is so to reiterate if
285:52 - there's an x present for a directory
285:54 - that means you can cd into it but for a
285:56 - file that means you can execute it so
285:59 - i'm going to undo that we're going to
286:00 - learn this command that i used to do it
286:02 - it's called chamod change mode
286:04 - but now if i run that ls-lncal
286:07 - i have that x back and now i can run
286:09 - ncal again
286:11 - okay
286:12 - so now we're going to learn how to use
286:14 - this command to change those permissions
286:16 - i just want to run through one more time
286:18 - what these three things mean well
286:20 - there's ten things i guess the first is
286:22 - a dash for a file a d for a directory an
286:25 - l for sim link and then we have three
286:27 - groups of three
286:28 - each of these groupings has three places
286:31 - the first is either an r or a dash and r
286:34 - means read permission is present dash
286:36 - means no read permission
286:38 - w write permission a dash means no right
286:40 - permission and then the final slot is
286:42 - for execute x means it's executable
286:46 - no x a dash means you don't have that
286:48 - permission so the first three read write
286:51 - execute are for the owner of the file or
286:52 - folder the second three are for members
286:55 - of the group that owns that file or
286:57 - folder and then the final three are for
286:59 - everyone else so what does this mean a
287:01 - little quiz here uh what do these this
287:04 - exact set of attributes mean first of
287:07 - all are we talking about directory file
287:09 - sim link
287:11 - answer for your moment or think about it
287:12 - for a moment answer out loud if you'd
287:14 - like we are looking at a file
287:17 - and we can see the owner whoever that is
287:20 - has full permissions read write and
287:22 - execute members of the group owner have
287:25 - read writes but no execute permissions
287:27 - and everyone else only has read
287:30 - permissions
287:31 - okay
287:32 - so now let's talk about how we actually
287:34 - change these how do we use this weird
287:37 - chamod to mode however you want to
287:39 - pronounce it command
287:41 - it first of all stands for change mode
287:44 - and it is the tool it's the command we
287:46 - use to alter those permissions and
287:49 - here's the basic syntax there's actually
287:51 - two main ways of using chamod of
287:54 - specifying the permissions
287:56 - and the first i'm going to show you is
287:57 - the easier one when you're starting out
287:59 - so we have the command
288:01 - chamod change mode
288:03 - and then the mode meaning how we want to
288:06 - change the permissions who are we
288:08 - changing permissions for what are we
288:10 - changing
288:11 - read write execute and are we adding or
288:13 - removing that permission and then
288:15 - finally the file that we're trying to
288:17 - change
288:19 - so
288:19 - this is where it gets a little tricky
288:21 - the first thing we specify is the who
288:24 - we have these different letters u g o
288:27 - and a
288:28 - so u is how we can change the the file
288:30 - permissions for the user which is the
288:32 - owner of the group it's a little
288:34 - confusing because o is actually for
288:35 - others anyway if we have u
288:38 - that means we're changing permission for
288:40 - the user g is for members of the group
288:42 - o is for others and a is for all of
288:45 - those
288:46 - then we have a minus sign a plus sign or
288:49 - an equal sign
288:50 - so a minus sign will remove a permission
288:52 - a plus sign we'll add a permission we'll
288:54 - come back to equals and then finally the
288:56 - permission that we're trying to change
288:58 - read writer x execute
289:01 - so let me just show an example to make
289:02 - it a little clearer here if we have g
289:05 - plus w
289:06 - what we're saying here is four members
289:08 - of the group
289:10 - add so plus
289:12 - the right permission
289:14 - so here's what it looked like before for
289:15 - group r dash dash after we run this it's
289:18 - now r
289:20 - w dash so we added that w there but only
289:25 - for the group
289:26 - here's another example
289:28 - here we have that right permission for
289:31 - uh owner and for group
289:33 - we have an a and that means all so
289:36 - everyone all three of these chunks
289:39 - minus remove the w the right permission
289:42 - so we go from having right here and a
289:45 - right here to now having no right
289:47 - permission no right permission and no
289:49 - write permission
289:51 - so let's show an example
289:53 - why don't i go back to my home directory
289:55 - as colt
289:57 - and
289:58 - let's see i've got this permissions
290:00 - folder inside of it i have only colt
290:03 - coltscanread.txt why don't i change it
290:06 - so that
290:07 - how about
290:08 - everyone so all of us can read the
290:11 - contents of this file
290:13 - so it's not going to have a great name
290:15 - anymore it will still be only colt can
290:17 - read but that's not going to be true
290:19 - so this is what it looks like at the
290:20 - moment i'm going to run chamod change
290:23 - mode
290:24 - and then i'm going to say everyone so a
290:26 - all
290:28 - i want to add the read permission
290:31 - so add the read permission for everyone
290:34 - and then the file
290:36 - ls-l
290:38 - we now see everybody has an r
290:40 - so this means as you know if i go back
290:42 - to being elvis
290:45 - i can read the contents of that file now
290:48 - whoops only
290:50 - why don't i see it here
290:52 - oh jeez because elvis does not have
290:55 - permission
290:57 - to
290:57 - do anything in this directory remember
290:59 - if we back out one level
291:02 - here we are this permissions directory
291:05 - we can see
291:06 - there is no read
291:08 - attribute present so elvis can even list
291:10 - the contents of that folder so why don't
291:13 - we add that r back in with what we know
291:16 - what i want to do is change mode and i'm
291:18 - going to switch back to being colt
291:20 - change mode
291:22 - and what i'm going to do is change it
291:23 - for other
291:25 - so that's what the o if i go back here
291:29 - o means the world or others anybody
291:32 - who's not the owner or part of the group
291:34 - so here's permissions here everyone
291:36 - already has an r
291:38 - group
291:39 - the actual owner but i want to add this
291:40 - r back in so i'm going to say for others
291:44 - plus r add the read attributes
291:47 - for the permissions
291:51 - folder oh i'm in the permissions folder
291:53 - oh come on
291:54 - i gotta back out
291:56 - okay let's try that again for others add
291:59 - the read permission to the permissions
292:01 - directory here it is right now i'm gonna
292:03 - hit enter ls-l
292:06 - and now what do we see on permissions
292:08 - there is an r present that means if i go
292:10 - back to being elvis
292:15 - i can now cd into permissions
292:18 - and finally i can read the contents of
292:21 - only colt can read because now we have
292:24 - permission to read both that file and
292:26 - the parent directory
292:28 - now go back to being colts
292:30 - and what i'm going to do next is show
292:33 - let's see how to revoke permission so we
292:34 - use the minus sign
292:36 - so i'll revoke let's go back to um
292:40 - well let's go back into permissions
292:43 - here's that one file i'm going to revoke
292:46 - the read permission for everyone except
292:49 - for me
292:50 - so i'm going to do that here so i'm
292:52 - going to do
292:53 - change mode why don't i revoke it for
292:55 - the group first to show that so i'm
292:57 - going to say
292:58 - group g
293:00 - minus
293:01 - r
293:02 - for the group members of the group
293:04 - remove or revoke the read permission on
293:06 - only cult can read
293:08 - and now you'll see there's no r present
293:10 - here
293:11 - i could do the same thing but remove it
293:14 - for
293:15 - others
293:16 - ls-l
293:18 - we can see it's now gone
293:20 - now i can also do multiple at once so if
293:22 - i did this o minus rwx this means others
293:27 - remove read write and execute
293:30 - permissions
293:31 - so if i want to add
293:32 - how about full permissions read write
293:34 - and execute for everyone i could do
293:38 - chamod
293:39 - and then for everyone all i want to add
293:43 - read write execute
293:45 - on only can read
293:47 - and there we are our wx our wx rwx
293:51 - so it's now executable it's showing up
293:53 - differently
293:54 - it isn't actually going to do anything
293:56 - if i execute it because
293:58 - well it's not a script just a text file
294:00 - but anyway that's kind of the basics if
294:03 - i wanted to remove execute permissions
294:05 - for everyone you know i could do jamaad
294:08 - all minus x
294:11 - and now we we have rw dash rw dash rw
294:15 - dash so that's a quick intro to using
294:18 - chamod with this syntax now there's
294:20 - actually another syntax that we can use
294:23 - that is quite a bit more
294:24 - intimidating when you're starting out
294:26 - and i'm just going to alert you to his
294:28 - existence we can use octal notation
294:31 - which is base eight for these three
294:33 - digits of binary
294:35 - correspond to a file mode so zero zero
294:38 - zero is going to be dash dash dash one
294:41 - one one is rwx one zero zero is r dash
294:45 - dash so that's the binary here but each
294:48 - one of those in base eight is a single
294:50 - digit zero through seven
294:52 - it can be a little complicated to
294:53 - understand but as you can see here if
294:56 - you saw chamod seven five five what that
294:59 - tells us is for that first chunk
295:02 - seven
295:03 - is one one one meaning rwx
295:06 - five is one oh one right it's binary uh
295:10 - three binary digits is a single octal
295:13 - digit anyway our r dash x is what we end
295:16 - up with there
295:17 - i know it's kind of confusing it really
295:20 - is trust me if i have to teach this uh
295:22 - but there are some modes that are more
295:24 - common and you'll get used to them if
295:25 - you encounter them but you can always
295:27 - use the longer sort of englishy syntax
295:31 - that looks like this you know with the
295:33 - letters and plus or minus
295:35 - rather than having to worry about base 8
295:38 - craziness
295:39 - but that is something you'll see
295:41 - now what about the equal sign
295:43 - i said i'd come back to this the equal
295:45 - sign
295:46 - is basically a way of saying in this
295:48 - example a equals r
295:50 - set for all
295:52 - set it to be
295:53 - only read permissions and nothing else
295:55 - so it it's going to reset every other
295:57 - value so let's see an example of this in
295:59 - action we just have this only can read
296:02 - file which is actually not accurate
296:05 - but if i do want to make let's say
296:08 - i want to
296:10 - i don't know
296:12 - i'm grasping at straws here uh i'll make
296:14 - it so everyone can read and only read so
296:17 - no write permissions no execute
296:20 - what i can do is jamaad everybody all
296:23 - now instead of doing plus read or minus
296:27 - w because minus w would subtract right
296:29 - except get rid of that get rid of that
296:32 - but if i do equals
296:34 - read what this says is that
296:38 - the only permissions that we're having
296:40 - ignore everything else and get rid of
296:41 - them is read for everyone for all
296:45 - so ls-l
296:46 - and there we go everyone can read
296:49 - but nothing else if i instead if i just
296:52 - did a equals
296:54 - i can also do multiple like rw
296:58 - or rwx that's a long way but i can give
297:00 - everybody permissions and then if i went
297:03 - back and re-ran this so that it's
297:05 - equals r
297:07 - again that means only read get rid of
297:10 - everything else so we'll go from rwx rwx
297:12 - rwx to instead
297:15 - rr and just dashes for the read and
297:18 - write permissions
297:20 - all right so i know this is a pretty
297:21 - complicated topic uh there's a lot to
297:24 - cha mod
297:25 - not to mention just pronouncing it
297:27 - oh i guess i did not show we can also
297:30 - change permissions for multiple who at
297:32 - whose at one time
297:34 - so if i wanted to
297:36 - add write permissions only for the owner
297:39 - and the group owner i could do this
297:41 - chamod
297:42 - so the owner is you the group owner is g
297:46 - and then plus w
297:48 - for right
297:49 - and now we can see the owner and the
297:52 - group owner has that w there so we can
297:54 - have multiple values on the left hand
297:56 - side of that whatever plus minus equals
298:00 - and then again we have the octal
298:01 - notation which you'll see um you know
298:04 - 777 means rwx for everyone full
298:07 - permissions uh and you can spend more
298:10 - time learning this if you really care
298:11 - about it it is something you'll see in
298:12 - the wild but for now all i care about is
298:15 - that you understand the basic concept of
298:17 - these permissions and all these
298:19 - different different letters here rwx and
298:22 - dashes what does that mean what is the
298:24 - significance
298:25 - and then remember if we go back we
298:28 - talked about the owner and how we can
298:30 - change a file's owner using tone
298:33 - we can also use it to change the group
298:35 - that owns a file
298:36 - and then we can change individual
298:38 - attributes using chamod change mode
298:41 - that's a lot
298:42 - well we made it to the end we covered a
298:45 - ton of different commands maybe it's a
298:47 - little bit overwhelming maybe you're a
298:48 - little tired of seeing all the scrolling
298:50 - text go by
298:52 - but remember the point of all this is
298:54 - not to memorize and just become an
298:56 - expert on every single command overnight
298:58 - what really matters is being able to put
298:59 - the different pieces together to use the
299:01 - correct command when you need it read
299:03 - the man pages figure out how something
299:05 - works change what options you're using
299:08 - and just kind of duct tape it together
299:10 - when needed obviously some of these
299:12 - commands become second nature
299:15 - lscd touch make directory rm that sort
299:18 - of thing
299:19 - you get pretty comfortable using
299:22 - different expansions and redirection and
299:24 - piping and combining different commands
299:26 - but then some of these more niche
299:27 - commands certainly i wouldn't expect you
299:30 - to just remember and and honestly in
299:32 - preparing this sort of course i always
299:34 - have to look at the man pages and remind
299:36 - myself of all the different options and
299:38 - how they work so thanks again for
299:40 - joining me and remember if you are
299:42 - interested in my bootcamp you can find
299:43 - the link in the description and lastly
299:46 - thanks again to flavio
299:49 - for the excellent handbook
299:51 - all right well it was nice uh i guess
299:53 - recording this in a dark room and
299:54 - editing it in an equally dark room
299:56 - uploading it to youtube
299:59 - and
300:00 - being alone in this whole process
300:02 - but honestly who needs friends or
300:05 - companionship
300:06 - when you have the most sensual command
300:10 - man touch
300:11 - that's really all i need okay i gotta go
300:14 - get my cat to the vet

Cleaned transcript:

learn the 50 most popular linux commands from colt steel all these commands work on linux mac os and any other place you have a unix environment colt is an extremely popular instructor and for good reason he has a knack for teaching complex topics in a way that beginners can understand hey everyone my name is colt steele and today we are going to learn a ton about the command line and different linux commands i'm a developer well honestly more of a teacher who happens to write code i teach inperson web development i've run boot camps in san francisco i now do a lot of online teaching and i have a boot camp i created with springboard if you want to learn more you can find a link in the description and this is a picture of one of my cats i actually have to take her to the vet like in five minutes really her tail is just drooping down for no reason i was gonna take her sooner but you know i had to make this for you let's hope she survives before i say anything else i want to give a big thanks to flavio copez i think i actually only know him as flavio maybe it's pronounced copes but i'm pretty sure it's not anyway uh he generously allowed me to use his linux commands handbook there's a link in the description of course very detailed and thorough handbook if you're not familiar with his work he puts out handbooks and tutorials on all sorts of topics so this is just one of many different handbooks anyway he is allowing me to use his handbook along with some of the materials i've created to create this mutant super course on youtube so we are going to cover 50 actually i think it's a little more than 50 commands that are useful obviously to varying degrees some of them you'll use every single day as a developer for example and then some of them you may never use except in an emergency situation once a year but i'm going to cover a bunch of them they're not really in a particular order especially towards the end of the course but at the beginning i ended up deciding that instead of just 50 random commands in any order i wanted to make something for uh anybody so if you're a beginner you can start at the beginning and we'll go through the basics navigation working with the basic commands and options and making folders and files and so on but then after about this point things really open up and you can jump around to whatever commands you'd like and of course if you're someone who already has some terminal experience some of these commands are familiar to you just hop around take a look at the description there are time stamps and just click on whatever command you're not really comfortable with or you've never heard of there's probably something here for you but if you're a beginner i definitely would recommend starting at the beginning so aside from these commands which there's a lot here and this is a pretty long video i also cover some concepts that are pretty important so the very basics things like why even learn this stuff if you're not a linux user you're on a mac you're on windows why do you need to know linux commands do you need to know them the answer is probably yes if you're trying to break into web development programming coding engineering any sort of techie industry then we'll talk about things like unix and gnu and linux and unixlike and true unix what is all that uh what is a shell what is bash zshell kernel terminology stuff so that's all coming up of course there's time stamps if you want to skip around if you don't care about that stuff and then installation so if you're on a mac you don't really have to do anything if you already have linux installed you don't really have to do anything either and if you're on windows well we have to jump through some hoops the good news is fewer hoops than we had to jump through a couple months or years ago so i'm going to show you how to install something called windows subsystem for linux then we'll also talk about concepts like command structure and arguments and options working with man pages folder structure of linux redirecting standard output appending standard outputs tilde expansion history expansion path name expansion curly brace expansion and permissions so we're going to end with permission is a pretty big chunk honestly at the end of this course it's devoted to just these two commands and understanding how to read and manipulate permissions on linux so there's a lot here there's some introductory conceptual stuff in terminology installation and then we start from the basics so you could know nothing about the terminal never have entered a command in your life start at the beginning and don't skip around or if you feel confident or you know some of this stuff jump around use the time stamps they are there for you all right so let's start with a quick discussion around why this matters why should you learn these commands uh yes at times it might seem like you're you know doing stuff straight out of a 1980s hacker movie um and we're far more advanced and things have improved so much why do we still have to use text commands well there's a bunch of reasons including the fact that you can just do a lot more from the terminal using these commands we're going to learn you'll have more control greater access you can do things you just cannot do otherwise there's just no way around that if you want to start a server manage different processes interact with databases all sorts of things alter permissions you need to know terminal commands to do that another reason it's faster at least once you get past the basic hurdles you learn the commands you get used to them you can do things way faster we can make 10 000 files in a single line i can make 10 000 empty files all with different names doing that graphically with my mouse or file new save file new save would take hours now that's just a sort of farfetched example but in general we can do things much faster the one problem is that when you're learning it's going to be much slower i kind of already hinted at this one but we can actually automate things we can speed up repetitive processes we can save ourselves a lot of time another reason it's available everywhere so if you learn these commands you'll be able to work on any linux distribution you'll be able to then switch over to a mac if needed and use the commands on a mac now on windows yes it's a little bit different so it's not technically available everywhere but these commands we're going to learn are pretty standard across any sort of developer software engineer career which leads me to the next point it's essentially a requirement if you want to be a web developer data scientist devops engineer sys admin security admin machine learning engineer ai engineer whatever any type of coding related career you are probably going to need to use the command line you will have tools that only exist on the command line that you'll need to be able to use so for a lot of people that's the only reason that really matters you just need it if you want to get a job it's just part of the expected skill set also a lot of cloud computing programs or services don't even have a graphical user interface you just have to do things via a command line and again highpaying jobs lots of careers lots of roles that you'll need to at least know the basics of working with terminal commands so the next topic i'd like to quickly discuss is a little bit of context around operating systems and why these commands will work on linux and on mac by default but they're not going to work on a windows machine at least not out of the box so uh there's quite a lot of complicated history uh and and uh drama around different operating systems things being open source versus closed source and competition and copying each other it's quite dramatic but the general gist that you need to understand is that over the years since the very early days of computing well maybe not the super earliest days but we're going back to the 70s here this is a timeline that shows a very detailed timeline that shows operating systems and how they're connected anyway in the 1970s there was something called unix you can see it here and just take a look at all of these lines this whole family of operating systems that it spawned so there's lots and lots of them everything in red here is considered in some way related uh or indebted to unix so that includes things like linux so in this course i'll be using ubuntu which you can see here it is a distribution of linux but there's many many others things like android chrome os but also other uh more common linux distributions like fedora or red hats anyway all this linux stuff is descendant from unix all the way back here in the 70s now we also will see somewhere in here all the different mac operating systems here we are so mac os x we've got ios the apple tv os audio os watch os all these different apple products all the apple operating systems also related to unix but then our good friend windows somewhere down here it's not an it's not even in the same red color just to show how it is completely different it is in green this world of windows so windows windows vista windows xp windows mobile windows phone xbox os all that stuff is over here it's just kind of on its own it is not related it's not you know a descendant of that original unix operating system from way back in the 70s now the reason this matters is that all of these guys in red up here they tend to share the same commands unix was this operating system developed in the mid 60s at bell labs really cool time lots of innovation going on uh but what matters to us today 50 plus years later is that lots of those innovations lots of those new ideas and the specific commands the actual interfaces the way a file system was structured all of that carries over today yes it's changed it's been expanded but it is present in all of those red descendants of unix unfortunately for our windows users those commands don't exist natively on windows windows has its own set of commands its own default shell its own way of doing things so i'm going to talk about how we can get these unix commands to work on windows but just so you understand why this is a problem in the first place it just has to do with the history there are so many of these os's over the years inspired by and descended from the original unix os including linux and mac os but not windows lonely windows over here alright so now we have a basic understanding of the fact that of today's operating systems there's really those two groups everything descended from microsoft and then kind of everything else that is in some form some way related to unix now that's a vast simplification but again we're just talking about popular operating systems so you know linux chrome mac os all these things come from unix now let's talk about linux and unix and all that stuff in a little bit more detail so that you understand what exactly linux is why it exists so this is a diagram from wikipedia that shows the history going back to 1969 early unix versions and how it spawned all the you know other operating systems that are connected to it now what you'll see is that there are three colors red is closed source or pink and that means the code is completely closed off you can't edit it you can't view it you're not allowed to even try to tweak it then we have open source which you may be familiar with that term the code is openly viewable you can change it tweak it make your own versions try things out and then there's in yellow this mixed shared source type of operating systems so what you'll see here is that early on unix and a lot of other operating systems in the early days were mixed or shared source but then there was a plethora of closed source operating systems uh that were very walled off and you were not allowed to do anything with that code you were not allowed to view edit tweak and so on and that led to the rise of something called the free software movement free in this context does not mean no money free beer it instead means free in the context of freedom free speech so this software movement was all about uh the the idea that you should be able to collaborate you should be able to edit code view source code run copy distribute study change and improve software should not be walled off and the leader of this movement was this guy named richard stallman so he began work on something that ended up being called gnu gnu that was his own free software alternative to unix so he wanted to make a full operating system that had everything that normally came with unix but it was going to be completely free again free meaning you could tweak it and edit it do whatever you want to it and see the source code now that's a huge undertaking creating an operating system and at the same time this other developer named linus torvalds or linus torvalds was working on something called a kernel and we'll talk about what that is in a moment but this kernel he was working on he called it linux and a kernel is a very complicated and critical part of an operating system it is the thing that basically sits between the hardware and the software and it facilitates the interactions between different pieces of software and then the actual the physical hardware of the computer so what happened is that richard stallman was working on the gnu project trying to build a full operating system well he didn't have a kernel but at the same time linus torvalds was working on a kernel and torvalds ended up merging his kernel with the existing new components from richard stallman to create this whole operating system just a quick note so i don't get any negative comments here there is a bit of controversy over the name of the resulting operating system a lot of people most people have heard of linux fewer people have heard of gnu the term linux often people use it to refer to the entire resulting system when in reality uh the linux kernel was just one piece that was added on to some existing components but what matters for us here if we go way back to this slide over here is that what we see is a bunch of closed source mix source operating systems all over here and then this thing called linux pops up right there around 1991 in green it's open source now there's not a direct line as you can see going back to any of these what are called true unix operating systems and the reason for that uh is yet another piece of history there is a global consortium called the open group they own the trademark for unix in order for you to call your operating system unix if you make an os and you want it to be certified you have to pay a lot of money you have to go through a bunch of testing you have to comply with a bunch of regulations and standards and it's a complicated process and there's money involved it's not very free free software so we have another term there's true unix you've been certified as a true unix operating system and then we have unixlike operating systems which are compatible with the unix standards they implement things correctly but they haven't been certified as actually true unix and this is often because of financial considerations or ethical objections to the existence of the idea of true unix so what we see on this slide here is linux enters the picture it is not considered true unix but rather it's considered unixlike remember that linux itself is just a kernel which is very very important it's again that piece of the operating system that connects the hardware to the software so that's what linux is really it's the kernel but when we talk about things like ubuntu what ubuntu is is a linux distribution it is one of many many distributions out there there's nearly a thousand last time i checked uh you may have heard of fedora slackware ubuntu that's what i'll be using and what each distribution is it's it's the linux kernel it's some gnu tools documentation a package manager a desktop environment a window management system a whole bunch of other things combined together to form a full operating system so to recap all of that there are tons and tons of operating systems on this chart you can see some are open source some are closed source some are mixed source uh some of them are considered true unix they've paid they've been certified by this foundation or this consortium to be true unix but then over here we have linux linux is fully open source and whether you call it linux or linux gnu or gnu linux it is a unixlike operating system that conforms to all these standards these operating systems do we can use the same commands things are structured the same way there are subtle differences but it doesn't really matter everything on this chart here they're all part of this greater unix family or unix inspired family now we have one last piece of terminology and history and all that stuff to get out of the way before we move on to actually running commands we need to talk about the term shell so you may have heard of this before if you're on windows you may have heard of powershell or you may have heard of bash or z shell or you maybe never have heard of them but there's this concept of something called a shell what the shell is is a very very important piece of software that is going to expose the operating system itself to human users or to other programs so it is the thing that takes our commands and hands them over to the operating system to actually perform and the term shell comes from the fact that it's the outer layer around the operating system like the shell around an oyster so there's this other term terminal way back in the day a terminal used to be an actual piece of hardware it would have a screen and it was a physical device with a keyboard you'd go over and you'd enter your commands into the terminal today terminal is just a piece of software it's an application there's many different terminal applications it's the place we go to type our commands when we hit enter there's some shell that we are using in that terminal window uh by default on ubuntu and most linux distributions that shell is called bash on macs these days the shell is called z shell zsh another very popular shell is fish there are many other shells out there though and again their job is to take commands that we provide or other applications humans or applications provide and then give them over to the operating system and make sense of it all so again i'll be using bash that's the default shell that comes with the boom 2 but if you're on a mac i'll talk about installation and you'll see that fortunately z shell is very very similar and the commands are still going to work so it's not a big deal at all but it's good to know that there are different shells and then the job of that shell is to take those commands and pass them over to the operating system and as i mentioned bash is the most popular shell out there uh especially on linux based systems uh it is the most common default shell and the name if you're wondering it comes from born again shell and it really doesn't matter but it's this reference to this guy steven bourne who created a different shell called sh a direct ancestor of bash so there's sh and then born again sh and again bash will run on pretty much every version of unix or unixlike systems so it does run on macs it runs on you know any linux distribution any of the unix operating systems that you can see on that massive chart next up let's talk about setup and installing things if needed so that you can run these commands so right now we're looking at a linux distribution this is ubuntu this is the linux distribution i'll be using throughout the course if you already have linux if you have some version of it some distribution just use that it's going to be very very similar all that you need to know is there's a builtin terminal application if i just search for terminal i'm going to be running my commands in here probably change the color and this is where i'll type my commands so if you are on a mac you do not need to go and install ubuntu and a virtual machine that's actually how i'm running this i'm still on my mac here but i'm running it in a virtual machine you can do that but unless you have a really good reason to i would just stick with what you know because the commands that i'm going to show you will work on a mac all right so this is just for users who already have ubuntu here's the terminal app you just search for it and we'll run our commands there now if you are a mac user remember it's part of this unix family unixlike operating systems all the commands i'm going to show you will work on the mac all you need to do is search for terminal and it will probably look a bit different than this but you will have a terminal where you can run the same commands i show you so over here on ubuntu when i show the psax ww command it works you don't need to run this by the way but over here on my mac same thing p s a x w w it also works and it will actually learn what this is but it gives me a bunch of stuff all right windows users it's your turn let's talk about installation and the steps we need to go through in order to run linux so remember the problem here is that on windows we just don't have access to the same commands they're implemented differently windows is not part of this unix family this unix like family of operating systems so this means that a lot of the commands you'll learn in this video and that developers use every single day are not going to work on windows or they'll work differently or they'll partially work now windows has its own set of commands and as you could live in that world exclusively it's just a different world so if you want to use a lot of the common developer tools and you know you're watching this video you probably already know what you want to do we need to get some way of running linux commands on windows the way that we do this is really two options there used to only be one we used to have to have a virtual machine it's a pain to install uh it's totally isolated from your actual windows operating system and it can be slow can have a lot of overhead now instead we have a really cool fancy option called wsl windows subsystem for linux this is actually put out by microsoft and it allows us to run a linux environment directly on windows or inside of windows so it's not isolated it's not a virtual machine it actually works directly inside of windows it's just a command line version of of linux to be clear so we're not going to have a separate desktop you're not going to have you know all the apps and stuff that i have on ubuntu but that's kind of the point you can still be a windows user and have linux commands from the command line so it's really really cool it's updated pretty frequently it's still under active development and the really good news is that it's a lot easier to install these days than it used to be you do need to make sure you have windows 10 version 2004 with build number 19041 or higher or windows 11 in order to use the simplified installation instructions otherwise uh you can follow i would recommend going to this webpage anyway docs.microsoft.com look for wsl because this does change but if you have an older version you can still install wsl you just have different instructions but if you have the appropriate build number or higher all we need to do is from the app called powershell which i have open right now you can just search powershell okay this opens up this terminal where i can you can see ps by the way i'm using powershell i can type commands in here and it tells me in that case i don't know what the heck you're talking about but the command we want to run is wsl dash dash install so let's try it wsl dash dash install the requested operation requires elevation so what this is telling me is that i need to have admin privileges or permissions to do that so why is that happening well i need to run powershell as an administrator so i'm going to search again for powershell powershell but i'm going to click on run as administrator here all right and that opens me up a new window it says administrator windows powershell and we try again wsl dash dash install whoops and it might take a little while so i'll be back when hopefully this finishes successfully and if not i guess he'll watch me debug it oh check it out already we can see it's downloading ubuntu so that's the default linux distribution it uses when i first installed wsl a year or two ago for a different course uh you actually had to go and download your linux distribution separately you had to go download wsl separately you had to then connect the two and point it to the particular installation and it was just a huge pain but now hopefully super easy take a look it says the requested operation is successful that's always good changes won't be effective until the system is rebooted so let's reboot okay so once that finishes up i restarted uh i now have actually when i restarted it automatically opened up ubuntu which is now installed it wasn't even a thing before now i have an app i can run called ubuntu it opens up right now at least this terminal that i can see here and it tells me you know i had to install for a few minutes and then it wants me to set up a default user account and this username that i set up does not have to match my windows username but whatever you do you know you want to remember what you put in here so this is going to be for our ubuntu part of this machine i'm going to make my username colt and then a password and you'll want to remember that password you're not going to see what you're typing i'll hit enter and then retype it again you can change that password later i'll actually show you a command you can use to change that password and there we are i now have linux i'm running ubuntu on my windows machine so the commands will learn things like pwd and who am i just to show a couple simple ones or psaxww there are lots and lots of commands we're going to cover and they now will work these commands are running on windows now there is some additional setup you can go through if you go to the installation documentation they recommend on windows that you whoops this is the wrong page here they recommend that after you set up your linux user info which we just did that you can also install an app called windows terminal and windows terminal is uh remember a terminal is just an application that can run different shelves and it can sort of be a jack of all trades we can use windows terminal as our terminal it's just a more sort of fancy better features more customizable terminal application so you do not need to do this but if you want to you can install the windows terminal app and you can make it look all nice and pretty and run ubuntu from inside windows terminal rather than the default terminal that comes with ubuntu so one more time perfectly serviceable just to use this terminal but if you want to get windows terminal if you're serious about you know mastering all this stuff and working as a developer or some other you know you want to use the terminal day in and day out windows terminal is just the better option it has more features so i'm going to install it i'm going to download it just from windows website or microsoft's website now that it finished i'll click launch and remember a terminal is just like a piece of software that can connect or interact with different shells so right now it opened up with powershell which is not what we want to use in this course first of all let's see if i can just make this larger font for you there we go okay it's a little bit larger now so as you can see it's using powershell but i can click this little drop down arrow here and switch over to instead use ubuntu so now i'm in ubuntu you can see my prompt changes here it has my username in there you can customize the appearance and all of that so if we go to settings you know you can go down to ubuntu you can set up a different appearance font size but what you can also do is set the default profile to be ubuntu and if we save that it now means when i make a new window if i just do plus it is ubuntu you can see my little linux penguin that's the logo there and we're now up and running with windows terminal there's a lot you can do to customize it but that's not really the point of this course so now you have it run your commands here when you see me run them in ubuntu uh run them here okie dokie that should hopefully wrap up installation whether you are actually running linux like like i am right now ubuntu this is the desktop version i have the terminal open i will be running my commands right here but if you're not maybe you're using a mac so here's my mac i've got my terminal open right here i'll run commands inside the terminal application here they'll work just the same and then finally if you're on windows hopefully you installed wsl so here we are i'm running this is windows terminal i make sure i'm running ubuntu here i run my commands right here so whichever one you're on just make sure you know where you're going to be running those commands if you're on windows make sure it's not powershell because you'll run into problems we want to make sure we are running ubuntu so that our unix commands will work otherwise they won't yes by the way all three of these are on one computer right now i've got linux windows and my mac okay let's get started okay so now that we hopefully have everything installed correctly we can go ahead and get started now before we do the first thing i just want to make clear is that for the most part there's no order to the commands in this video it's a bunch of commands and they're useful and most of them don't really have to do with one another or depend on each other but early on right now i'm going to go through some of the very basic commands and there is a logical order to how i'm going to teach them all that is to say if you're a complete beginner stay right here and we'll go through the basics in order but if you have experience if you know the basics of ls and man and cd and pwd you may want to skip ahead so check out the time stamps in the description below and click on whatever command looks interesting or you'd like to learn more about but if you are new stick with me let's go ahead and get started all right so before we talk about commands let's talk about not commands in my prompt if i start typing really anything and i hit enter the shell is going to try and process that and figure out what command i'm referring to but i'm not referring to any valid command so i get a message that says command not found same thing on a mac type gibberish we get command not found same thing over here on my windows machine although i'm running linux on windows and i get command not found okay hopefully not that surprising so what we want to do is type commands that actually make sense that the computer can figure out what we're referring to and then run some corresponding program for us and the first really simple one i'm going to show you is maybe not that useful but it's just a good demonstration of a simple command it is who am i all one word no spaces who am i all lowercase it's going to print the username of the currently logged in user so maybe not something you need to do all the time you probably know who you're logged in as though there are uses for this especially in scripting if you write scripts later on but anyway if i just run it here who am i over here on my ubuntu installation i am logged in as colt that is the username i have here's my mac here on who am i my username is slightly different it's my full name called steel and i think on windows it's just cult as well all right so that's our first official command really really simple hopefully nice and straightforward right there's a difference between just typing gibberish and typing a command that is recognized but it is important to note you know who am i like this is not the same thing at all uh there's no real auto complete or spell check or anything like that uh the terminal is just gonna take what you what you give it and try and find that program so it can't find this program who am it only knows who am i okay so the next command we'll look at is called man the man command man is short for manual and that's exactly what it is it is a command that doesn't do anything to our system it's purely informative it tells us information or manual pages for commands as well as some other things not just commands but we're going to focus on the command side of things so anytime we have some new command like we just learned who am i we can actually run man followed by that command name to get a manual page entry for that command so if we need to learn more about who am i or any other command most likely you won't need to learn more about who am i because it's so simple but we can do just that we can run man followed by a command like who am i hit enter and our screen changes pretty drastically that prompt goes away i can't type commands anymore what we see here is a man page it tells us the name of the command prints the effective user id something called a synopsis will come back to this when we learn some other commands and then a description print the username associated with the current effective user id pretty straightforward there's not a whole lot here we can see who wrote the command and we can find a place to report bugs this is a very simple man page some commands have very long pages dozens and dozens of pages you would actually need to scroll through now important to note first of all to get out of here we need to type the letter q if you forget that you can find it down here but remember i am not at my prompt right now i can't type commands so i can't type who am i if i type things i start to see a whole bunch of other texts appear i'm actually looking at some help that tells me more about how this program works so it tells me you know you can exit by typing q or uppercase q or zz you can type h to display the help page that i'm looking at right now so that's what happened i typed who am i hit h but anyway i'm going to type q to get out of there uh now i'm back to the man page for who am i and i'll type q again so just one more time if i type man followed by some command if i want to get out of here type q and now i can type commands again so if i try and run man on its own it's going to tell me what manual page do you want this is a manual command i need to know what you want a manual for so we can actually do man man and that gives us the man page for the man command it's an interface to the system reference manuals there's a bunch here one thing i'll just point out quickly is that we can scroll by using the mouse that is one option but it's a lot easier to scroll one page at a time by hitting space there's a lot of text here and i can scroll down by hitting space rather than having i can also use the arrow keys by the way to go one line at a time up and down which is what i'm doing right now space to go down a page at a time q to get out of here all right so that's the man command nice and simple hopefully very useful especially when we have more complicated commands the next command is also nice and straightforward it is called clear clear and this command will clear your terminal screen it is useful although i'll also show you a shortcut that you can use in place that's actually much shorter so clear will clear the mess on your screen if you have a bunch of stuff here like i do uh clear enter and it's gone so i'll just show another example of that over here this is on my mac let's do some more commands how about man clear let's just take a look at that here is the manual page for the clear command it clears the terminal screen so i'm going to hit q to get out of here so i have a bunch more stuff let's just pretend that's all valid commands i want to get rid of it clear all right nice and easy now let's take a look again at the man page for clear this is on ubuntu and i want to talk about this right here the synopsis so we see the name it's clear here's a little description it clears the terminal screen nice and easy now the synopsis is actually showing us the syntax the accepted options and values we can pass to the clear command so clear is a command that accepts an option we can see if you see anything in square brackets here it means it's optional so you can pass this in you can pass this uppercase v lowercase x now what does that mean well commands accept options that alter their behavior you can change how a command functions so if we scroll further down we can see under options a description of what these different options do now the one i want to talk about is dash x now i don't use this frequently but it's just a good intro to options here it says that it does not attempt to clear the terminals terminal's scrollback buffer using the extended e3 capability i have no idea what that part means but what this means overall is that when we clear with the dash x option it is not going to clear our scroll history so i'm going to get out of here and demonstrate this so i'm going to hit q and let's make some history in here hello there i love you okay none of those are valid commands i can scroll back and you know see those commands and if i type regular clear it's gone i can't scroll back that history is gone now if i recreate some of that hello there i love you a lot if i use clear but this time i provide dash x and that's our first example of an option uh there will be tons of commands we see that accept options and they drastically they can drastically change the behavior of a command i'm going to hit enter and it clears but i can scroll so i don't use that often honestly i'm not showing it to you because it's something you need to know i'm showing it to you because it's an intro to options now one more thing i mentioned there's a shortcut and i don't really type the clear command anyway the shortcut is ctrl l so if i have a bunch of stuff again i want to get rid of it ctrl l and it's gone so that's definitely easier than typing clear it also works over here on my mac it works on wsl just control l okay so that's the clear command nice and easy the next command is also nice and easy it is pwd it stands for print working directory and this is a command that just tells us our current location in a given terminal window so let's start with man pwd and it tells us pwd prints the name of your current slash working directory so just like when we have i'll open up my file explorer here with my graphical user interface using my mouse i have a current directory that i'm inside of i'm viewing right now my desktop as you can see it's selected there or i can view documents or i can view my home folder this would be my current working directory home in this window right here but in a terminal it's a little bit different let me get out of this man page here hit q if i type pwd it tells me in text where my location is so in this window i am on the desktop which is located in the cult folder instead of slash home over here this is a different terminal window it has a different location just like i can have multiple file picker windows here's another one this one's in my home directory and this one's in desktop same idea so i can have in this case pwd a terminal window that is in slash home slash cold slash bin and here's one more different window a much longer path this is the full path to get to my location now i haven't shown you how to move so you probably don't have something like this set up with these different windows by default you can actually configure the default location of a new terminal window for me when i make a new terminal window just click that button there you can also use a shortcut it defaults to the desktop at least on ubuntu over here on my mac when i make a new window it defaults to what is called my home directory slash users slash my username you can configure all of this but it doesn't really matter where you are at the moment all that matters that you can find it by typing pwd alright so the next command we're going to cover is called ls the ls command is short for list and we use it to do just that it will list the contents of a folder so we can see what is inside of a directory you know normally if you're using a graphical user interface you don't need a command you just can see the contents of a folder but in a terminal window that is not how things work at all we have to ask for a list of the contents so here i'm on my desktop as we can see i ran pwd it says slash desktop you can also see my prompt is displaying desktop there as well that is also something you can configure by default though on ubuntu it does show you your current location anyway if i actually look at my desktop i can see a bunch of stuff there and i can list it out using the ls command so if i run ls with nothing else just ls it's going to list the contents of whatever current directory i'm inside of in this window it's the desktop and here we go we get a bunch of text so we see things like you know my folders uh some of them are quite odd here i've got wildlife i've got uh i've got files like greatgatsby.txt so there's some different colors and folders for me our bolded files are not bolded and they're just showing up white but that's all configurable as well but this is showing me all the contents of my desktop if i try it somewhere else here i'm in this slash bin directory i'll type ls i see different contents uh here that's my desktop desktop all right well let's try it on my mac here this is my home directory um i see a bunch of other stuff right this is different i see folders for my courses i make my desktop my documents labs some random things that you need to get rid of like hello.js and orange.python those are my files and folders now we also can provide a folder that we want to look inside of we can provide a path to ls so instead of just looking at our current location i could peak somewhere else so for example right here let's see i'm on my desktop and we saw that there is a wildlife folder on my desktop i could ask what is inside of there by running ls wildlife and i can tab complete so i don't have to type the whole thing and hit enter and i have no idea why i have a wildlife folder that contains three text files called angela one and nico survey it doesn't sound like wildlife to me but okay i've got a meal diary folder let's take a look in there and it has nested folders inside so now we can even burrow further in if we wanted to from my current location on the desktop i could look and set a meal diary and look inside of friday by doing this ls meal diary slash fry and i'm using tab complete so i'm giving it a path a path that is beyond it's not just one folder name it's now two that i want it to peak inside of so peek inside of this and we have breakfast dinner and lunch so i can actually run this again and let's see what's inside of breakfast i don't know if there's anything in there i'm gonna recall the previous line by hitting the up arrow and then just add a b and hit tab yeah there's nothing in there no it's a bit of a letdown so that's one example of using ls where we provide a file or rather a folder path but we can provide a full what's called an absolute path to any location on our machine so this file breakfast or this folder is inside of friday is inside of meal diary which is nested in the desktop which is where i currently am right pwd i'm on the desktop but maybe i want to see what's inside of my documents folder and documents is not on my desktop well one option is to do this ls and then the full path to my documents which is slash home slash colt slash i think it's uppercase documents so i'm using tab completion again so i don't type that myself i don't know if there's much in there nope just a single file but we can see kenneth.txt now i could get there right by just opening the file picker going to documents yes i see it but there are some special things that we can do with the ls command in the terminal as well but just to recap what i showed there we can provide what's called a relative path so relative to our current location i could just say show me list the contents of meal diary but that only works if i'm on the desktop if i'm somewhere else i can't just reference meal diary i need to reference the full path and that's exactly what i did down here to get to documents the documents folder is not in my desktop so i can't do ls documents it's going to tell me i don't know what you're talking about that doesn't exist here on the desktop but if i provide the full path this is the unique location the absolute location of documents i can see it's not exciting but i can see there's one file all right so now let's talk about some of the options ls accepts so let's use that clear command or use ctrl l and then let's run man ls it tells us it does list directory contents and then it says that there's a bunch of different options and i'm going to scroll through them these are all the options a lot of them most of them i don't use doesn't mean they're not useful they're just there's a lot i want to highlight two that are very useful the first one is dash l so let's find it here dash l come on h i j k l doesn't tell us much but it says it will use a long listing format so this means i can take a look around with ls and rather than just getting the file or folder name i can instead add dash l and get a whole bunch of other information so there's a lot we're not going to go over here but there's file permissions there's the owner of the file there's the group owner there's file size information modification date the file name so a lot of stuff here for each individual file so that is dash l now another thing we'll take a look at another option i'm going to go back to man ls is dash a now dash a you can also do the longer form dash dash all all it says is that it does not ignore entries starting with a dot when i just type ls i don't see any files or folders that start with a dot ls dash a i now see quite a few dot bash a bunch of stuff dot profile dot less something dot pseudo something there's probably some different ones on your machine i'll just try another example here lsa on my mac lots and lots of files that start with dot they don't show up if i do a regular ls which you can see right there nothing starts with a dot now we can combine options as well so if i want to and clear this screen i can do ls dash a to see all files including ones that are hidden dash l i want the long format that is one way of doing it but the much shorter and more common way is actually just using a single dash and put your options together so dash a l or dash l a i see the long format all the information for regular files and files and folders that start with a dot so we're getting both of those options uh taking effect at the same time so that's an intro to the ls command so we've seen how to find our current working directory where we are and list the contents of that directory now how do we move around how do we do the equivalent of what i'm doing right here in the file explorer double clicking on you know desktop and then going into this folder or going back how do i move around like i am right here well in the terminal the way that we do that is by using the cd command cd is short for change directory now the first thing you'll notice if you try and read the man page for cd it does not exist it just isn't there when i try it on my mac i see something but it is not a man page 4 cd if we look up here it's a man page for a bunch of commands tons and tons of commands including cd well what's going on here is that the cd command is actually implemented by the shell we don't need to dive into the specifics really at all just i want you to know that you're not going to find a super helpful man page for cd it's one of the few commands that we'll cover that does not have a man page however you can run help it's a different command it's like the shell's version of man help space cd and it's kind of annoying it just prints out text you don't enter that program where you can scroll nicely it just takes up a whole bunch of text but it does tell us it changes the shell working directory change the current directory there are some options we're not really going to use those however let's just see how it works so i'm going to clear my screen first of all remind you where i am in this window i am in my home cult folder if i type ls i see a bunch of other folders so let's say i want to move into one of those folders how about my desktop well the way that i do that is by writing cd and then specifying that path so i'm just going to do d e tab hit enter and you'll see my prompt changes if i type pwd you can see my location has changed to be home slash cult slash desktop before it was just home slash colt so i just jumped i just double clicked into that folder but i didn't click anything it was all done via the terminal so i type ls i'm on the desktop now let's go into the meal diary folder cd into meal diary all right and we're now in here i can cd into how about friday type ls or pwd you can see i'm now at this pretty long path if i type ls let's cd into breakfast so that's a really common thing ls and then immediately after cd you you use ls to look around and then cd to change directories into something that you just found so now i'm in this folder breakfast and i've hit a dead end there's no more folders to cd into uh how would i back out right normally if i did the exact same thing so on my desktop with the graphical user interface it was meal diary is that right if i can find that i double click friday breakfast okay how do i go somewhere else well i have a bunch of options i can hit the back button i can use these buttons up top to jump around but here how do i go back with the cd command well the answer is to use cd followed by dot dot so two dots is a special path that indicates or it refers to the parent directory so it's how i can back up one folder right now i'm in breakfast if i cd dot dot now i've gone back one level into friday pwd you can see i'm in friday type ls this is the contents of the friday directory so that's how i can go back one level i can go back further and repeat it and now i'm back on my desktop now i can also instead of just cding into one folder at a time one level at a time i can jump to any location on my machine as long as i have the full correct path so if i wanted to go back to where we just were which was this location here right desktop meal diary friday slash breakfast i could do that in one step cd and then meal diary slash friday i'm using tab slash breakfast so i don't have to do three separate cds i can jump as many levels as i want and the same actually goes for moving backwards i don't have to do cd dot dots enter cd dot dot enter uh if i want to move back multiple levels i can chain it together i can do this this is one option so it's a little clunky to do it this way but it does work so this is going to take me back one parent folder and then its parent folder and its parent folder and now i type pwd i'm back on the desktop i can also pass in absolute path to cd so everything we've done has been relative to our current location but if i want to go to my documents folder well it's not here it's not in the desktop i can't do cd documents if i try it doesn't know what documents folder i'm talking about it's only looking in my current location and there's nothing called documents on the desktop my documents folder is located at this path it is slash home slash cult slash documents and i can jump right there it doesn't matter where i am i can run that command anywhere and i'll be able to get to documents i'm now in documents one other note around cd and path names you'll see this tilde that refers it's a shorthand that is eventually expanded into your home directory now it's kind of confusing because this is called home but the home directory for each user is a directory with their username so for me it's colt so if i cd to tilde and i do pwd it takes me to slash home slash colt if you cd to tilde it will take you to whatever your usernames folder is and this folder is a very important place it has the desktop it has documents downloads a whole bunch of stuff you can put your own things in here too but even just if you do nothing it contains a lot of important folders and documents uh so that's kind of the basics of cd you can cd into a location that's relative to where you are like desktop i can do multiple levels at once i can back out with cd.dot we combine it often with ls take a look around where do i want to go let's go into wildlife cd wildlife okay i got some stuff in here and i'm not gonna do anything with it let's back out and i can also pass an absolute path at any point uh which is again a full path name not relative to our current location so that is the cd command so next up i want to talk a little bit more about folder structure and how things are organized if you noticed when i talked about absolute paths all absolute paths started with a forward slash and the reason for this is that the very very highest level directory on our machine is the slash directory also known as the root directory which is really confusing people call this root but there's also a directory called root root definitely confusing uh in the same way that people refer to uh you know my home directory colt if that's my username that would be colt's home directory but there's also a directory called home it's uh yeah it's not the most straightforward thing so the top level directory is slash we can actually go there if we wanted to from anywhere on my machine i can do cd slash and if i take a look around we've got a bunch of stuff that we normally don't mess with at least not as a typical daytoday user if you start writing scripts if you start doing admin stuff absolutely there are changes you can make here but we can look around there's a bunch of different files or folders and things called uh sim links that we'll learn more about later on in this video um and that's kind of all i'm going to show in this directory because there's just so much here uh but what i want to mention is that your desktop your documents your music your whatever files and folders you make typically are going to live inside of the home directory inside of your particular username so for me my username is colt we can always find that out if i need to it's also just right here in my prompt cult so i can go into the home directory i'll cd into that if i take a look around every user on my machine has their own unique home folder so carrots cult elvis and kitty let's take a look at kitty's directory whoops not kits kitty and you can see we've got desktop download documents pictures and all the stuff that we would expect i'll back out again and then i'll go into colt and this is where we've been working now i just wanted to reiterate how this all works slash is the root it's the top level directory on our machine we cannot go higher than that if i try and go to slash and then back out i'm not going anywhere i'm just staying right there at slash now as i said every absolute path starts with a slash because an absolute path is the full location the unique full location to reference a particular file or folder so it always starts with a slash now another character that we've talked about briefly is the tilde here which refers to your individual home directory so if i cd to tilde i'm logged in as colt that will take me to slash home slash colt as you can see right here okay and that's all i really wanted to mention around folder structure of course there's a lot more there's all these folders there's dozens of folders here that we're not going to discuss everything we're doing lives inside of our particular username home folder so slash home slash lily slash home slash colt and then remember this difference between relative and absolute paths if i wanted to go let's see where am i right now i am in my home directory if i want to go on to my desktop from here i can just cd into desktop that is relative to my current location but as we talked about that only works if i am in a place where i can view the desktop it's it is in my current folder so basically the only place this would work is from my home directory right here but if i go to slash i'm not going to be able to just cd into desktop i can't auto complete there is no desktop right here so i need to use an absolute path and i could do the full long name cd slash home slash cold slash desktop like that or i can do the slightly shorter version use that tilde character which refers to my home directory slash desktop okay moving on the next command we'll cover has to do with making directories or making folders it is mkdir or make deer mcdurr however you want to pronounce it it is short for make directory and that's exactly what it does it's the command we use to make folders so the basic way we run it is make directory or make deer space and then some folder that we want it to create for us and it will create that folder so let's try it i'm going to cd just onto my desktop i'm going to clear control l and i'm going to make a new folder here i'm going to make a folder called greenhouse i have a new greenhouse actually and i need to manage the crops that i'm growing and starting seeds and bills and maintenance and time sheets for employees i don't know that's just that's the story i'm going with i'm going to make a folder called greenhouse on my desktop so i'm on the desktop right pwd there's no folder called greenhouse you can see it's alphabetical there's it goes from great gatsby grep exercise keys so if i run make directory and then greenhouse if that's the name of the folder i want it to make me i'll hit enter we don't see anything happen but if i type ls again we now have a folder called greenhouse and if i just move this out of the way you'll see on my desktop there's greenhouse it's totally empty it's an empty directory so i can cd into that folder and that's exactly what i'll do cd into greenhouse oops i hit enter too early green house there we go i use tab complete again and now i'm in here so we can also make multiple folders at once you just separate their names by spaces so i'm going to make a winter and summer directory inside of greenhouse make directory winter and summer so i can have you know different schedules for what i'm growing in summer and winter i'll type ls and we see those two folders were just created for me in my current location right that's all i specified was summer and winter i didn't say any fancy path but what i can do is actually provide if i wanted to make inside of summer i wanted to make a folder called how about you know seeds i could do make directory summer slash seeds so i'm inside of greenhouse but i'm not inside of summer so in other words i'm right here in this folder i'm not going to go into summer and then make a folder in two separate steps i'm doing it in one step i just provide a path make the seeds directory instead of summer i'll hit enter okay type ls i don't see it but if i do ls summer there we are i'm looking inside that summer directory there's my seeds folder okay now one last thing i'll show you there's an option that's pretty common which is dash p which allows us to make nested folders so why don't we just take a look at the man page man for make directory and we'll scroll down here's p or the long form dash dash parents it says no error if existing make parent directories as needed so let me show you what it means when it says no error so inside of the winter folder which i'll just point out here graphically i want to make a seeds folder and instead of seeds i want to make a lettuce folder so if i try and do that all at once i'm inside of greenhouse if i do make directory winter slash seeds let me just expand this window a bit here winter seeds slash did i say spinach no i said lettuce if i hit enter here i get an error it says can't create such directory it runs into a problem because it expects that winter slash seeds already exists and it thinks it just wants us or we just want it to make lettuce that's not the case i want it to make seeds and lettuce but seeds doesn't exist it freaks out but that's where the dash p option comes in so make directory dash p winter seeds slash lettuce we're now telling it make any of the needed parent directories along the way to make this lettuce directory we don't get an error and if i type ls here we don't see anything but if i do a lswinter we see seeds if i do ls winter seeds we see lettuce so it successfully made that nested directory and any necessary directories along the way so here's we go back winter it made me seeds and inside of that it made the lettuce so that's the dash p option and that's really all there is to make directory so mkdir followed by whatever directory you want it to make and some location for that directory often it's just your current location but you can provide a path a destination as well so if i wanted to make something all the way back in my home directory which again i can use tilde as a shortcut i could say make directory tilde slash blah blah i'm going to delete this once i learn how to delete folders i won't see anything here but if i go all the way back to my home directory there it is right there so we can provide a relative path an absolute path we just give it some destination to make a folder and it makes it for us that's make directory the next command we'll cover is touch so touch unlike most of the other commands doesn't really tell you a lot about what it does or its name doesn't indicate its most common use make directory makes a directory uh you know change directory changes directory touch is used most of the time at least to create files so there's no create file or make file it's just touch so uh we'll talk about where that name comes from in a moment but let's just try using it if we run touch and we provide it with a file name that doesn't yet exist it will make that file for us so let me go to my desktop i made a greenhouse folder deny and then summer and winter let's cd into summer cd into seeds and let's make some files here so let me clear my screen i'm going to make a file in here there's nothing at the moment i'm going to make a file called how about squash so squash i'm going to have a file full of different types of squash seeds i guess so if i just run squash as is that's totally fine squash if i type ls it made that file for me i'll just show it to you also visually if i go to my desktop i'll go to greenhouse if i can find it summer seeds here's my empty squash file i can open it it's completely empty okay so that's one option i can also provide an extension as i'm making a file so if i want to make a txt file i can do dot txt so let's make another one how about berries how about just melon another summer fruit dot txt and i now have a txt file called melon.txt now it's important to note that the extension you provide it does depend on the exact operating system you're running but the extension does not indicate it doesn't it's not what's used to determine the actual file type of a brand new file so these are all empty files i could make a pdf file if i wanted to touch apple.pdf it's not really summer but if i type ls we've got an apple.pdf but they're all just completely empty at this point if i look at any of these files they are just plain old empty files at the moment of course i can put stuff in them i can change that extension there's all sorts of things we can do so let's try another example i'm on my mac here i'm going to touch multiple files so in this directory it's called colors i have a colors.txt file i'm going to make a couple of new files let's go with red dots pdf and then a space orange dots let's see how about png and then yellow we'll do a different extension here how about an excel xls i type ls those files were created they're all completely empty now here is i'm on my mac this is finder the graphical user interface i've got red.pdf orange.png if i try and open one of these just with my mouse on a mac it does try and use preview it does think that it's a pdf and it says it's empty i don't know what to do with that if i try and do a pdf it does use a pdf reader or pdf viewer but again this is just on my mac if i go back to ubuntu here and i open up a pdf it just opens in a text editor if i open up if i make a png file touch what's another fruit how about barry.png if i try and open that oh it uses the text editor as well okay so it does vary from one system to the next but the point is we just make empty files with touch now let's talk about when we provide a name of a file that already exists so if i run touch barry again i can do that i can just hit the up arrow it's not going to seem like it does much it doesn't make me a second file with the same name that would be a problem what it does instead is that it actually is going to update the timestamp of the file so it touches it if we run man touch always a fun command to type out man touch uh it actually says its main purpose is change file timestamps update the access and modification time of each file that we provide so it says here secondarily a file argument that does not exist is created empty so that's why it's called touch rather than make full make file or create file or something its main purpose at least historically is to change the access and modification times of a file and then oh also if that file doesn't exist it will make it as an empty file so how do we know or how can we view the access and modification times if we remember lsl that flag if we take a look at barry.png here right there october 15 1348 is the modification time that's ls dash l is the long listing format so 1348 let's see it's now 13.50 so if i try and touch barry.png again and i do lsl we now see it's showing october 15th 1350. so it does in fact update that modification time but most of the time 99 of the time that i use touch it's to make files uh and i can make a bunch of them at once as we saw just provide a bunch of file names separated by spaces and it will make them for you okay so we saw how to make files and make folders let's talk about destroying things so to delete a folder we can use the rmdir remove directory command rmdir followed by the name of a folder or a path to a folder that we want to delete or multiple separated by spaces however this will only work if the folder is empty so over here uh i've got i don't have any folders let's make a folder make directory uh delete me in all caps there it is to delete it one option is rmdir delete me i type ls and it's gone but if i back out and i try and delete the seeds folder which is not empty rmdir seeds we get an error failed to remove seeds directory is not empty and that's really all there is to rm deer it removes empty directories only empty directories we'll see another command we can use to remove directories that have stuff inside of them so next up we're going to talk about the rm command rm for remove let's take a look at the man page it says we can use it to remove files or directories so we saw how to use rm deer it only works to remove an empty directory i've got this seeds directory rmd or seeds no luck it's not empty alright so this is where the rm command comes in i'm going to show you how to use it to delete directories in just a moment but we're going to start by deleting files so i'm just going to make a couple files with touch uh how about cat dog carrot um blue all right so i have these four files now i can delete them using rm followed by let's do blue to start uh the name of a file and that's it it is gone now it's very important to note uh there is no intermediate recycling can or trash can or something some sort of bin we can go find all these files we've deleted they are just completely gone they're just vanished from our entire uh system so that can be uh a bit of a scary thing if you're not careful with what you're deleting so you definitely want to make sure you're only ramming things that you mean to rm but the flip side of that is that it's very fast powerful quick and easy to delete things uh just as long as it's not too easy and you slip up so we can delete multiple things multiple files if we just separate them with spaces of course like that carrot cat and dog are all gone so that's the basic use of rm i'll show you one more there's a couple of flags i want to talk about the first flag is dash v this is actually a trend there are many commands that support a dash v for verbose that option in the case of ram will give us some verbose output that that basically explains what it did if you notice here we run it we deleted three things but there's no feedback it's just silently deleting them we had to look to see are they gone well if we use dash v i'm just gonna remake my uh four files again if i use dash v so rm carrot cat dog dash v for verbose now it just tells me what it does each step of the way removed carrot removed cat removed dog pretty straightforward hopefully but the end result is exactly the same you do not need to have that of course it's just something you may want to use some people like to use it and like i said there are other commands like when we see copy cp and move mv we can use dash v for verbose output and it will tell us just copied this file i you know moved this file renamed this file removed okay so that's one flag dash v the next thing i want to talk about is using rm to delete a directory so we talked about rmd or does not work on seeds or any folder that is not empty so that must mean rm will work right let's rm seeds oh no cannot remove seeds is a directory but i thought the whole point was you know rm could delete a folder that has stuff in it yes that is the point uh but we have to use a flag and the flag we need to use is the r flag for recursive so if i do man rm again i'll scroll down a little bit further r so we can do lowercase r uppercase r or dash dash recursive if you really have a lot of time to spend and what this will do is it tells the rm command to remove directories and their contents so that could be other directories and further nested directories there could be hundreds of levels of directories nested down remove them all so here's how we would use it if i want to remove the seeds directory this is what it has inside remember it has four files and i want to remove that entire directory it's just rmr seeds and once again there's no feedback i could have added dash v and it would tell us more but now it is completely gone that's it so i'm going to make a directory again we'll call this zoo let's cd into zoo i'm just going to touch some random let's see animals cat dog snake i don't know jaguar okay so uh i have that zoo directory now i'm going to back out again this time i'm going to delete it with rmr but i'm also going to show you a new flag dash i for interactive and interactive is going to prompt us and ask us if we want to delete each file or not so if we do dash i here and then the folder which in this case is zoo now it's asking me do you want to descend into this directory zoo so do we want to go inside and see what's there i'm going to say y for yes or if i said no then we kind of end it all but i'll do y do i want to remove regular empty file snake yes cat y for yes let's keep jaguars i'm going to say no dog yes and now it's asking me do you want to remove the directory zoo uh i'm going to keep it so that interactive mode allows me to make decisions uh if you're deleting you know 10 000 files maybe not the best option but that is a flag we can use dash i to interactively decide what to delete and what to keep so now if i look at zoo it only has the jaguar file inside one more quick demo i want to show you i have a let's see where did i put that my desktop a directory called meals and inside of meals i made 52 folders one for each week of the year and inside of each week if i just pick one like week 35 there is a folder for each day of the week and for each one of those days there are three files breakfast lunch and dinner dot txt so we've got three files for each day of the week for 52 weeks of the year it's a lot of files and folders nested i'll show it to you here so this is the meals directory all these different weeks pick one pick another day all those files so there's a lot of stuff going on here and i just wanted to show you that i can delete the entire thing very easily and very quickly all those nested folders and files using rm so i'm going to cd back a couple levels one more and one more just to reiterate you know i don't need to do cd dot dot cd dot cd dot dot to go back three levels i could have done that right there or i could have just said take me to the desktop specifically so this would work from anywhere this cd dot dot cd dot dot cd dot dot only works if i'm three levels away you know three levels burrowed down from the desktop if that makes sense this will work from anywhere anyway i have this meals directory i'm going to remove it i need to do a dash r and i'm going to make it verbose so you can see exactly how many things it removes in a single go so this is just one command remember no recycling bin no trash can these files are gone so you obviously want to be careful but here we go rm dash r for recursive so we can delete a directory that has stuff in it and dash v for verbose and if i scroll up i'm going to be scrolling for a long time lots and lots of files and folders deleted in a split second so that's the rm command it also does work to remove empty directories so um in that sense you kind of never have to use rm deer i just show it as a quick you know command that you may encounter some people like it because you know that you're not going to be accidentally deleting stuff that has a bunch of contents inside of it but you could just use the rm command in general to delete files delete empty folders or delete folders full of a bunch of stuff as long as you use the dash r option all right so that is rm the next command i'll show you is one i use all the time on my mac it's called open and it will open a folder open a file outside of the terminal in the the sort of graphical world of our machine so if i make a bunch of files like uh i don't know how about purple i'll just make one dot txt if i now want to do something with that file i don't know i want to view it in finder well i could navigate to it and figure out where this is or i can do open i could do open dots that will open the current directory and here we go a finder window with that directory but i could also say open that particular file and it opens it up in the default application which is just a text editor on my mac but if i had some other file you know i can find an example here if i go to my desktop which i edited out i've navigated here i've got a file uh let's see i've got a pdf file if i open that it opens it up in my case using a pdf editor the default you know what it would open with if i double clicked anyway so that's the open command but it is mac specific so again i can do things like open dot to open the current directory i can see all my files and you know work with them here if i need to i can open a particular file and it's pretty smart but if i try this on ubuntu here i've got two directories here if i try and open that it's going to complain to me it can't do it it doesn't know that command now there is an alternative which is x d g dash open and uh there we go it opens up you know in this case this folder for me if i have a file just call it touch tomato.js if i do xdg dash it's a bit of a annoying one to type but open tomato it opens up the text editor and i can start working on this file now you may need to install it just to be clear i think if on wsl here if i try xdg open dot well i need a dash there it complains and it tells me i need to install it using this command so you can install that if you want but this is one of the main differences here open is a mac only command it might be one of the i think it's the only one we cover in this video that is different between mac and ubuntu or linux the next command we'll look at is mv for move this is how we can move files around it's also how we can rename files and that's going to be the first use case i'll show you if we run mv followed by an existing file and then a space and then a new file name what this will do is move pair turn it into new pair it will rename it so let's try an example here uh oh got a lot going on here why don't i make a new directory in here i'll just call this um commands i'll cd into there okay i'm gonna make a file in here and i'm gonna call this my journal but i spell it wrong like that and i wanna rename it i can use move let me just show you there it is i can use move and then the incorrect name journal.txt and then the new one just like that and again you may not get this verbose output that's just a setting i have but if we type ls we see journal.txt now if you do want that verbose output just for any of these commands like rm if i do m v i get the man page for mv there's an option in here further down dash v which explains what is being done so if you want to know exactly what's going on let's say i want to rename journal the correct version i want it to now be an uppercase j i don't know why if you add dash v which mine have by default you'll get that verbose output honestly i only put that in there when i'm teaching so people can see what's going on i don't really care to get that confirmation it yeah it's gonna work either way and we can see it's been renamed now we can also use move to change the location uh not just rename you know in the same directory but to move a file back a directory or into a completely different directory so let's find an example of that let's just make a directory here i'll call this one i don't know stuff and i realized shoot i really should have made that journal file inside of stuff well i can move it in there it's pretty easy i can just do move the thing i want to move and then the move command is smart enough to know that if the last parameter the last argument is a folder it will be the destination folder so i can move journal into stuff and if i type ls i don't see journal anymore if i look inside of stuff it's inside our journal is inside of stuff i can also do that to multiple files at once so if i touch i don't know about pi and cake and cookie sure i have these three files if i want to move them into stuff i can do mv cake cookie pie and then as long as stuff comes last it will be the destination folder and there we go they are moved into stuff now there's more you can do with move you can move folders around you can rename folders so if i want to rename stuff instead to be stuff in all caps move stuff to be stuff there we go i just renamed it um so yeah that's probably all i'll show you for move it's pretty powerful i use it all the time to move things around you know i could move this entire stuff directory onto the desktop if i wanted to i could do move stuff and then just have it go back one directory right now i'm on this commands folder i want it to go onto desktop it's not here anymore i'll cd back and here it is on my desktop somewhere there it is this is the one the uppercase stuff all right so let's move the next command i'll cover is cp which is for copy we can use this to copy a file or even copy folders so if i make some file i'm on my desktop here there's just too much stuff going on let's go back to my stuff directory okay so i've got this journal file if i want to make a new copy of it let's say for today's journal sure i'm going to copy it i can do cp the thing i'm copying which is journal and then the destination for the copy so if i wanted to be in the same folder then i don't need to do anything just provide a name so how about today's today journal or something like that and that makes me a copy so i have journal and i have todayjournal.txt now these are all empty so it's not that useful to show but if they had content inside of them like i'm on my mac here i have this linuxcommandhandbook.pdf if i want to make a copy of that cp linuxcommandshanbook.pdf and just give it a new name how about handbook dot pdf just like that if i type ls well there's gonna be a lot of stuff on here but there is a handbook.pdf file and if i open it up or just yeah i'll open it sure you'll see that it is a full copy so it's the entire linux handbook here all these commands we've been covering so it doesn't just copy empty files that's very important we can also copy entire directories so let's go back to ubuntu where are you here we are i've got this stuff directory why don't we copy the entire stuff directory so uh cp stuff and then i want to make a directory called stuff copy well if i try that we have a problem it says dash r not specified omitting directory stuff it's not going to copy this well if we take a look at the man page for cp it tells us if i scroll down there is a dash r option which just like with remove rm stands for recursive so if we want to copy the contents of a directory and any nested directories and their contents and so on we need dash r so let's replace this let's rerun it one more time cp dash r stuff stuff copy i have that dash v verbose on by default again you can turn that on if you want or you can just run it with dash v if you really want this output but here we can see it made a copy of the stuff folder and all of its contents so if we take a look here's my stuff copy and inside of it we have all of these files that have been copied as well so we can make copies like that i can also move as i'm creating a copy so if i want a copy of i don't know song of myself and i want it to go inside of stuff copy or instead of stop whatever let's go to my desktop i could do copy song is it capitalized yes it is song of myself long poem and uh let's actually put it uh sure let's put it inside of stuff so stuff slash and then i'm gonna call it s o song of my self sure psalms dot dxd all right so i'm gonna copy it but i'm also moving it at the same time because where i'm copying it to is a different destination i won't see psalms in here if i look in stuff cd into stuff nope where did i put it well wow i'm an idiot i put it inside of stuff with lowercase how confusing it's not in here it's going to be in this one so if i cd into lowercase stuff there it is soms.txt all right so it is there and that is a copy of that file so that is the cp command the next command we'll take a look at is called head so let's look at the man page for head it says that it outputs the first part of files head and tail are often used to refer in programming to two different ends of a structure in this case a file the head of a file is the beginning the tail would be the end so it's a really simple command it just prints out by default i think it is the first the first 10 lines of a file but we can actually specify an exact number using the dash n option but let me just show you uh so i've got this very long file in here which is song of myself.txt it's like hundreds of lines of long poem uh if i run head song of myself.txt it just outputs the first 10 lines now as we saw i can provide the dash n option followed by a number like 100 and it prints the first 100 lines from the beginning of the file so there we go 100 lines and that's kind of all that there is to head now there's also a command called tail let's look at man tail and it unsurprisingly probably outputs the end of a file so by default it's the last 10 lines but we can also provide an exact number using dash n uh and there are some other options here as well but let's just start with that so i'm going to do tail song of myself.txt here are the last 10 lines of song of myself but i can also say i want the last 20 lines and there we are i get the last 20. now with tail i'm on my mac now there's one option that we don't have with head which is dash f where are you here we are dash f it says it causes tail to not stop when the end of file is reached but rather to wait for additional data to be appended to the input basically it's going to read the end of a file and print it out but then also keep printing out any new additions to the end of that file this can be useful for log files output files error logs things that are changing and you want to monitor them if i just do tail this is a on a mac at least this system.log file it doesn't matter really but it's a file that contains a bunch of stuff i honestly don't know what half of it is and if i don't have that dash f option it just stops this is the last thing printed out but if i add that dash f in there whoops i need to make sure i put dash f in there first now my prompt does not come back this file is being printed out the end of it is being printed out and if i do something that would add to that log file if i i may i make a new window like i just did i'll do it again you can see that that log file is changing content is being appended to it so i'm getting a live and as i close as well you can see things are changing i'm getting a live update as i make a new process or i kill a process from this system.log file whereas if i had just i can get out of here by the way ctrl c but if i had just done tail without dash f it's not live it just stops it shows me exactly what's at the end of that file right now but with dash f it keeps listening and keeps updating the output so that's tail so the next command i'm going to show you is one that i don't really use very much i'm showing it to you actually because it helps illustrate some other concept so the command i'm going to show you is called date it's really straightforward date and it just prints out the current date and time let's see i'm sure there's some other options and different things we can do we can specify how it should display the dates honestly we're not going to go into it because as i mentioned i don't use very much it can be useful though if you're writing a script and you need to get access to the current time or the current date day of the week that sort of thing anyway the reason i'm showing it to you is because i'm using it to illustrate something that is not a standalone command we're going to talk about something called redirection so this greater than sign right here we can use to perform something called redirecting standard output so the date command or really any of the commands we've seen if i do ls not la ls or i do date or pwd all of these generate output and that output by default shows up in our terminal right it's printed out as text here but we can actually redirect where that information goes uh by sending it to a file if we wanted to so i can take the current date and store the result instead of printing it out store it in a file and to do that i use the greater than sign again what we're doing here is redirecting standard output okay so let's make a file i'll show you we don't actually have to make a file first but i'm going to make an empty file i'll call it today.txt uh there it is today.txt all right so what i'm going to do next is redirect date so again the date command greater than sign today.txt and this tells the terminal run this command first but whatever output we get don't just print it out instead we're redirecting the output to this file okay and we don't see any output nothing is printed out if i type ls there we are we see today is still there now in a moment i'm going to show you a command we could use to read this file very easily but we do know head we've already seen that so i could do head today.txt and take a look we see that it contains that text so what do you think will happen if i recall this line and i run it again so take the current date whatever that is that output and send it over to this file the file looks like this right now right if i run it again we'll get a different time it's still friday the 15th of october but it's now for what 27. so this should change um but what you'll notice is that it actually ends up replacing the contents of that file so it's not added as a separate line right we don't have two dates in there now it ended up replacing the entire contents of the file so this is very important if i had a lot of stuff in there for example if i navigate back i have this uh let's see stuff directory lowercase stuff i have this song of myself.txt you do not need to follow along with this but this file contains a lot of text if i just look at the first 10 lines it's the entire text of that poem song of myself now if i try and redirect something in there i can take the output of pwd for example and redirect that into song of myself.txt now that is the only thing in that file the output of pwd so we have another option which is to use a different operation very similar we use two greater than signs and this allows us to redirect standard output while also appending to a file instead of overwriting the file entirely so if i just ran you know pwd and then two greater than signs into this file this is let's do it a couple times this is silly to do but if i take a look at that file it now contains what five different lines let's take the date and redirect it into there let's take uh who am i and redirect it into there okay now let's take a look at that file again and you'll see it contains the output of pwd five times the date and then who am i which in this case is colt let's do date one more time or a couple more times let's run head and you can see it did not overwrite the entire file it just appends onto the end so you know date i don't use very much at all redirection though both with a single greater than sign which overwrites a file and two greater than signs is really really common uh the last thing i'll mention is that you can do something like this date redirect into today.txt that file does not exist in this folder if i take a look there is no today but if i do date redirect into today.txt we now have a today file it made it for us so the file does not have to exist in order to uh you know redirect output to it uh it will make that file for us if it needs to all right so we can do it with the date command we can do it with really any command that generates output as we saw i mean i could do if i wanted to ls or lsl that gives me a lot of text i could take that and then redirect that to a new file called you know contents how about that and if we take a look at contents we'll just use head for now this is what the first 10 lines are now there may be yeah i think there's some more that's missing but we're just doing the first 10 and we can see what is inside that file so that's the basic concept of redirecting and then of course if we use 2 greater than signs we are redirecting by appending to a file the output is appended to contents and now if we do head we'll probably need to specify you know i want how about just 40 lines of that file we can see all of this is in there all right so next up we have another command called cat cat and let's start by just taking a look at the man page for cat the name cats comes from the fact that it concatenates files cat but the first use i'm going to show you is something slightly different on its own if we just run cat i'm just going to clear here cat and then a file name like i have this uh song of myself i actually don't think there's we we overwrote that didn't we but if i do cat and then a file name it just prints the contents of that file in this case to my standard output to the terminal if i have and we had that contents file that we just made cat contents it gives me the entire file so it doesn't like head gives us the first 10 by default we can specify the first 20 lines the first 30 lines tail gives us the last 10 the last 20. cat gives us the entire file so i've got this song of myself file very long if i cat song of myself it prints out the entire thing there's a lot here you know i'm scrolling for a very very long time all right so that is something we can do but that's yeah sometimes i'll use that if i want to just check on you know what's in that file i don't remember what's it look like we can do that but there's a lot more we can do with cat as well remember the name cat comes from concatenate so we can actually provide more than one file name and it will print the contents of both of those or three or four however many files it will print all their contents together so on my desktop i have quite a few messy files here i've got one called letters so i'm just going to cat letters all right it just contains letters and then i have this one called words i'm going to cat words and there we are okay so i can cut them individually or i can cut them together just by separating them with a space and now we end up with one output again not very exciting but two different files for red and then concatenated together in this output smushed together so that doesn't seem that useful but where it gets more exciting if exciting to stretch but where it gets more sometimes useful is that we can then redirect that output to another file so i could make one file that is a combination of two or three or four other files or it doesn't have to stop at four i just don't want to keep saying numbers but we can take multiple files concatenate them together and take that output and save it into another file so here's an example of that i have three different shopping lists one for the butcher we can just take a look at that i need ground pork ground beef sausage skirt steak i've got one for the feed store for my animals i need to get chicken scratch chicken feed oyster shells i've got one for groceries milk eggs butter onions tomatoes all right so i want a master list still contrived but you know i want one list that i can take with me so i can concatenate all of them butcher feed store groceries and then i will take that first we can just see what it looks like here's the concatenated output but instead of printing it let's redirect it into a file we'll call it everything if i can spell everything okay and now we have a new file called everything let's take a look at it it contains the results of those three other files being concatenated so that can be useful right we can take multiple things stuff them together and put it in another file but as we'll see later we can also actually take multiple things concatenate them and send them to other commands not just send them to a file so we'll cover that later on when we talk about piping one last thing with cat that i'll mention is that we can use the dash n option to get line numbers so maybe not that useful here but if i go back with that super long song of myself poem if i do cat dash n song of myself pretend this is a file with you know some code and there's a problem in here i can find that line number and then tell my coworker hey it's on 1741. you would probably be in an editor but we'll also learn about some other commands like find and grep which allow us to search for things so we'll get there there are valid use cases for for wanting those line numbers to be available all right the next command we'll look at is called less less less is used to read the contents of files it gives us a nice interactive ui where we can scroll and it's just a lot easier to work with a file compared to looking at the contents that is printed out from cat so just as a reminder here i've got this super long file song of myself if i use cat it prints out the entire thing and i guess that's sometimes useful but in a super long file i've got a scroll forever yes i could use head or tail just to get you know the the very top or the very bottom of the file but this is a lot of scrolling so if i wanted to actually go through this and i wanted to read the entire poem or look at a massive log file from scratch all the way at the beginning i could use cat scroll to the beginning and now just use a terminal and scroll down but it's not that easy it's not a great interface but if i use less followed by the file name so any file name but a long one is ideal because you'll be able to see how useful it is less song of myself.txt now my screen changes it didn't just print out the entire text to my terminal window instead it opens up the less program where i see a page and then i can scroll down with arrow keys just like the man pages so if you remember with the man pages if we open up man some command our prompts goes away we're transported to a new world of man pages and we can scroll i can hit space to go one page at a time and there's quite a bit more we can do in less but first most importantly to get out of here cue just like the man pages so my my history my terminal is not cluttered with thousands of lines of text so that's one benefit but also of course i can read things and scroll up my own pace i can also do things like search so if i want to search in here my cursor is right here it's a little hard to see if i type a forward slash and then i type some phrase or something i'm looking for i don't know let's look for green i don't know if green is in here somewhere but let's see i'm going to type green and hit enter and there we go this is the first match the sniff of green leaves and dry leaves so that's one thing we can do by the way i mentioned you can scroll one page at a time down by hitting the space bar we can scroll up one page at a time by hitting b so b in space we can also use arrow keys up and down we can jump to the end of the file i believe by hitting g capital g yeah we need shift g it takes me to the very end of the file and then lowercase g takes me to the start so here's the very beginning uppercase g takes me to the end and as always q is how i can quit so this is great to work with long files it's just easier to navigate you can search for things unlike if you're just looking at an entire file using cats it's just all vomited on your screen all at once so that's less the next command we'll learn is called echo echo uh it's very simple it does one thing it takes whatever value whatever argument we pass it and it echoes it back it just prints it back it outputs it so that might not seem useful let's get out of here let's clear if i just echo hi well it just echoes high back to me it prints it out so yeah it is not that useful when you just run it like that but one really useful trick is to use echo with a piece of text and then redirect the output to a file so this is a great really fast way of making a new file that contains some little bit of text without even having to open up the file so if i needed to make some config file and it needs to contain i'm just making this up but it needs to contain something like you know username equals cult something like that it needs to have one line in that file well i could make an empty file i could open it up and then i could put this in there save it close the file or i can echo it and then redirect to a file that doesn't even exist yet so that file let's just call it config dots we'll just do txt so it's going to take this argument it's going to echo it back but instead of printing it to the terminal i'm redirecting it to a file that doesn't even exist it will make that file and put this piece of text in it so now we have a config file and if we use cat to look at it there we are it contains that line and i can also you know if i needed to add something to it i can do the same thing where i can append with two greater than signs so if i needed some other config in there i don't know how about key equals that that is now appended into our config file if we take a look there we are it has two lines of text in it so this is not how i would recommend editing files but if you need to make something quickly or just add a small thing to a file quickly this is a really great way of doing it echo some piece of text redirect it into a file so to summarize echo on its own some piece of text it echoes it back to you on the terminal it just prints it out but we can also redirect that and it's a great way to add some text to a file in like two seconds so the next command we'll cover is called wc it's short for word count and it does just that it counts the words in some input for now it's going to be a file but we can actually provide other inputs and it does more than just word count it actually will count the bytes and the lines so if you remember i have this very long song of myself file here i want to know how many lines are in it well if i run wc and then song of myself it tells me well there's three different values here the first one is a number of lines 1757 lines the next one is the number of words and then third this little chunk here uh that is the number of bytes and then the name of the file so if we look at the man page for wc you'll see that it tells us the order again how many lines how many words and how many bytes we can also say actually i just want the lines so we can use dash l or i just want the number of characters dash m or the number of words dash w so let's see how many uh let's see how many lines i don't want all that other stuff and we're gonna do wcl song of myself.txt there we are i want to know how many uh how many words dash w song of myself we get fifteen thousand seven six seven okay so that's one way of using word count but i'm also introducing a new concept right now something called piping so we're directly passing right now a file to word count but with piping we can do something very different we can actually take the output of one command and pass it as the input to a second command so we saw how to take the output of some command like ls and redirect it to some file this is taking output and then putting it in a file but what i'm talking about is taking output of a command and passing it to a second command so what if i wanted to know how many files are in here so if i do lsl this is a massive chunk of text right i can take this and i could i guess take it redirect it to a file and count the lines in that file or i can use piping so it's called piping because we use the pipe character located above the return key on the right side of my keyboard i take the first command lsl and then instead of just printing out the output i want to pipe it to the word count command wc and take a look at that we see the number of lines new line characters number of uh geez words and the number of bytes uh so what we just did was take lsl i could even do let's do al that will include hidden files if i have any here there's just two of them but we have 64 lines now so that's just one quick example but we can also do things like combine two different files using cat and then pipe that to word count and word count is not the only command we can pipe to i'm just introducing that one first uh i could even do date pipe that to word count if i wanted to know how many bytes are in there or how many uh words it's one line i don't know if i'd really want to do that but we definitely can but i have a couple of let's go actually to my shopping once again and i have if you remember this butcher file and feed store well actually let's do groceries so i have butcher and groceries i want to know how many things i have to buy so i'm going to combine those two groceries and butcher with cat so cat groceries and butcher and remember on its own it just smushes them together and prints it out but i'm not going to redirect it to a file i'm going to pipe it to word count and there we go if i just want the lines that will tell me tell me how many items right one item per line and it says nine and that seems correct right one two three four five six seven eight nine different things that i have to buy all right so that's an intro to piping it will pop up again and again as i introduce some other commands that are really more useful when you pipe things to them one more thing i just i'll show quickly i can combine piping and redirection if for some reason i wanted to take this output and then redirect it to a file called number.txt i can do that so this will run first concatenate those two files and then we're taking that information and piping it to the word count command which is just going to give us a number of lines in this case nine and then instead of printing that out like we did here redirect it to a file called number.txt there it is number.txt and if we look inside well it just has the number nine so that's a quick intro to piping next up we'll see some other commands we can pipe to the next command we'll talk about is sort so sort does what it sounds like it sorts information we'll start by just sorting a text file so i have this why don't we start with our everything file so let's take a look at that okay so it has a bunch of different items and i'm going to sort them with sort everything.txt now this is not going to change the file itself this is simply sorting the output it's going to sort what it gets from this file it will read it in sort it and print out the sorted information but it does not store it in that file and you'll see we end up with an alphabetical sort by default so butter chicken feed chicken scratch eggs ground beef ground pork it is case sensitive so an uppercase s comes before a lowercase s and you can actually tell it to not be case sensitive i believe if we look at man sort there is an option in here for where is that ignore case dash f um but this is great this is you know sorting a file alphabetically but just to reiterate it is not changing that everything file it is unsorted now i could redirect of course so i can do this sort everything and then put it into a file called sorted everything and now if we look at that sorted everything file it is indeed sorted we also can tell it to sort numerically so if i had a file that had numbers in it okay i have a file called nums i've just created oop nums it just contains five numbers here if i try and just sort nums as is it doesn't do a numeric sort it does well it sort of does it compares you know the first digit of each and a two so these both have a two that means i guess they come before 54 because that starts with a five but it's not an actual numeric sort but we have the dash n option that will now sort things numerically and there are other sorts that we have at our disposal we can reverse things with the dash r option so let's do that dash n r you can see we now have 999 first all the way down to the number two another option that can be useful has to do with duplicate values so why don't i echo 999 and i'll append that into my nums file i'll do that a couple of times all right so now when i recall my sorts for nums there's a bunch of those 999s in there if i want to only get the unique values i can use the dash u option for unique so let's do dash n u and now i only get the unique numbers sorted alright so that sorts we can concatenate and pipe information to sort we can do all sorts of things right it doesn't have to be from a file so i'll just show one more example of that let's take the butcher file and the what's another file i have groceries okay and if i want to sort those two i can pipe that oops i don't know if you can hear my cat there i can pipe it to sort and there we are it sorts what it received as its input so it wasn't just one file we took one command cat that gets an output we pipe it over to sort so there we go i could also do things like if i wanted to know how many unique numbers are in this numbers file right nums i could sort nums but i only want the unique so dash u n sort whoops not sort nums and then let's imagine there was like hundreds of them instead of what five i could pipe that over to good old word count and ask for how many lines so take this nums file only sort the unique value sort them numerically but instead of printing the value or the output to the terminal pipe it over to word count where we count the number of lines and the grand total is 5. so this just is to show you that you know we can take sorts and pipe its output to something we can redirect its output to a file or we can take some other command like cats and concatenate two files and then pipe the output to sort so that's sort next up we'll talk about the unique un iq command now the unique command is generally at least when i use it used in conjunction with the sort command so unique is going to let's just take a look at the man page first it reports or omits repeated lines so anytime you have a data set or a file that contains repeated information on different lines and you're trying to either consolidate it or ignore repeated lines we can use the unique command so just show an example i have a file here that i've just made called fave flavors it was uh let's say we run an ice cream shop we asked our our customers what their favorite flavor of ice cream was and we got a bunch of different outputs right chocolate vanilla strawberry a bunch of vanilla's rocky road cookies and cream but there's a lot of duplicated values now if i just run unique on this command or on this file fave flavors well that's weird it really doesn't seem like it works because i see a lot of duplicated values it seems like if it only gives us unique values or you know it removes duplicates we shouldn't see cookies and cream twice we shouldn't see vanilla twice or way more than twice well what it does is it doesn't actually just remove all duplicated values instead it removes adjacent duplicated values and that might seem weird right so we've got strawberry let's take a look here chocolate vanilla strawberry and then two vanillas well if we look at the output from unique we have chocolate vanilla strawberry one vanilla down here we had strawberry three times in a row over here it shows up once in a row when we use unique so it is going to look at one line and then the line after it and if it's the same then it's only going to print out one of those so generally i use this in conjunction with sort so if i sort fave flavors and then pipe that to let me just remind you what that looks like it's alphabetical so now they're all chunked together right cooking cream rocky road strawberry it's all together and then i can pipe that to unique and now we just get the unique values because they were all in a row and the way that unique works is it's only going to take one uh anytime there's duplicates in a row but you might be thinking didn't we just see there's a dash u option and indeed there is a dash view option for sort it kind of makes this obsolete but there's additional behavior to the unique command that can make it useful for example if i do man unique there's an option which is dash d which will only print out the duplicates so i only want the duplicates uh let's try that let's do well unfortunately they're all going to be duplicates aren't they if i do this dash d every single one of these flavors appears more than once but if i echo how about mint into fave flavors and let's do one more flavor uh how about uh pistachio or um how about rainbow sherbet okay so now we have two values that are not unique so if i remove that dash d here is all of the sorted unique flavors so we see a list of them but with dash d now i only want the ones that are duplicated so we no longer have rainbow sherbet and uh mint side note i've always said sherbet my entire life but uh i don't know i was corrected on sherbet so now i'm selfconscious some guess i'm sticking with sherbet um so there's another option instead of dash d we can use the dash u option to display nonduplicate lines so the lines that only appear once dash u and now we can see oh these are the flavors that uh only one person liked in our case we've got mint and rainbow sherbet everything else is duplicated so we don't see it showing up and then an even fancier option is that we can get a count of how many times each line appears with dash c so why don't i do that here i'm going to do sort all the flavors dot txt or fave flavors and then pipe that to unique and then dash c will give me a count and we can see all right there's five chocolates six vanillas one rainbow sherbet and what's extra fun is that we can actually take the output instead of just printing it out i can resort that numerically if i wanted to get a ranked list because they all start with a number i can do dash or sort dash n so sort all the contents of that file alphabetically which groups them all together then take that output and pass it to unique which is going to weed out all duplicated lines that are adjacent and give us a count for how many times each one appears but instead of printing that out pipe that to the sort command again where we will sort by number at the beginning and then we could even reverse it with r and we can see the most popular flavor vanilla so boring all the way down to the least popular mint which is this is not accurate i think mint is actually quite popular but anyway that is using piping along with the unique commands kind of a lot to take in so if you just need to sort the unique values in a file you can do the dash u option but if you want a count of how many times uh different lines appear if you want to weed out duplicated values or you only want an output that contains the values that are duplicated you can use the unique command now if you remember when i introduced the echo command if you happen to be somebody watching this entire thing from start to finish uh you may recall at least when i introduced echo i talked about expansions and how later on i would cover this thing called expansions well that's what i want to talk about now what i'm about to show you is not specific to the echo command but we'll be using the echo command to help illustrate uh how these expansions work so when i say expansion what i mean is that there are special characters and special syntax that we can use with various commands that the shell will interpret and expand into some other value and probably the simplest example is actually something we've seen before the tilde tilde expansion if i just echo the character tilde tilde has a special meaning i'll zoom in a little bit as we've talked about it is a shortcut that refers to our home or my current user's home directory so here tilde is slash user slash cold steel now when we echo it what we're actually doing is asking the shell uh you know print out tilde but it's not the character tilde right if it's in quotes then we get the tilde printed out what it's doing instead is it's it's expanding that character it has a special meaning before it even runs the echo command it's going to replace that or expand it to be this and that's what it echoes out so when we do things like cd tilde again the shell steps in and says oh i know that let me expand that and it turns it into slash user slash cold steel and that is where we see d2 so icd to tilde it's the same end result all right so there's other types of expansion though including dollar sign environment variable expansions so in our shell there's a bunch of environment variables available some of the more common ones are things like dollar sign path in all caps if i echo that you'll see that it's been replaced with a very long yours may be much longer actually than this it's not too bad if i run it over here on ubuntu i think i have quite a long path here nah not too bad either so it takes this and it turns it into or it expands it to the value of that variable now if you don't know much about environment variables don't worry about it but here's one more example user that's an environment variable for the current username okay now a more useful thing is path name expansion so path name expansion allows me to use special syntax special characters to match different path names so we've actually seen this before we just haven't called it path name expansion i'm in a directory right now well i'm in my home directory aren't i so there's a whole bunch of stuff here different files and folders um why don't i do this over on ubuntu because i have some more files to work with okay so when i type echo i'm just going to use echo again because it's an easy way to see what the shell is doing for us so it's just going to print back the expanded version of the star character so if i wrap the star character in quotes that's what we actually get echoed back but if i don't have those quotes and i simply echo star what i see is a list of every path name in this current folder so every folder every file name like you know pokemon.txt word.txt and then different folders like cleanup and copies i'm just matching everything so the star means every path here but i can narrow it down and i can say star dot txt and we've seen this sort of thing before again this is going to then be replaced with matching paths so this was replaced with all of that now if i do star.txt it's only going to match something that starts with anything but ends in exactly dot txt okay and so here we are we see our matches that end with txt now echoing them may not be that useful but i can do things like lsl star dot txt i want to print out long listing information about all text files in here and there we go i only see txt files and all their information so we also have another character we can use to match path names which is the dollar sign the dollar sign the uh question mark uh a question mark will match any single character so this would match any three characters in a row this would match any four characters in a row so let me show you an example if i echo and i'll do anything so a star matches anything and then a dots and then any two characters so this looks weird but it's saying anything that must then end with a dot and then exactly two characters i don't care what those characters are but two characters and oh we don't really match anything do we in this folder i guess we don't have any all right well let's try three characters and now we're just matching all our txt files and zip files it's not that exciting but just as an example if i were to touch app.py and you know app dot js and main.js all right and then i ran our original version here which is anything with a dots and then exactly two characters now we're matching those dot js and dot py extensions so i'm echoing them again that's not what we would normally do we might do something like ls or we could even do rm if i want to remove all those files this is kind of very dangerous and i don't know if i would recommend this but just as an example i could remove those files that have two character extensions that would be a very bizarre thing to want to do just all two character extensions but i can rm star dot question mark question mark so remove all files in here that end with two character extensions and i have it set up again automatically to ask me prompting me if i want to so i will say yes i'll remove all of them remove and remove all right so that's the basics of path name expansion next up we have some other types of expansion so we'll start by talking about curly brace expansion again i'll use echo when the shell encounters curly braces and i provide a comma separated list of values so i could do something like let's just do letters to start a b and c okay if i just echo a b and c it's not going to be very exciting but if i add something before or after let's do abc dot txt okay what this is going to do is create every combination of a followed by txt or dot txt and then b and then c and that's what we get a dot txt b dot txt and c dot txt so whatever these values are separated by commas i can create i can make files with them if i wanted to the shell is going to take this and expand it first so if i did something like touch and then how about um i did app dot and then in curly braces js html css and py if i wanted to do that i'll run it with echo first so you can see what it would make me app.js app.html app.css app.py and then if i wanted to actually create that i could use touch and that will make me all those files so now there's a bunch of stuff here why don't we narrow it down well only ls things that end in two characters or how about app dot and then question mark question mark question mark or how about a star all right and so we can see what we created we can also do numbers and provide ranges so if i echo 1.99 this is going to be expanded to the numbers between integers between 1 and 99. so i could create a bunch of files how about day and then let's do one to 365 if i was keeping some sort of journal i'm not making files right now i'm just echoing it but the shell takes this it expands it into this massive list of different numbers or rather different names day 94 day 95 and so on and then i'm echoing it but i could just as easily touch or make directory and create 365 different directories in a single line now there are other types of expansion uh we're not going to spend time talking about them but basically the concept of expansion is that the shell intervenes before a command runs expands some smaller thing usually it's small into a larger piece of text and then passes that to some command and we can use that to our advantage to craft short commands that results in creating hundreds of files or deleting a whole bunch of stuff or just matching a bunch of things by defining a pattern like we saw if we want to match you know anything that how about starts with the letter f and then ends in anything else i'm just echoing it and this is just echoing the paths that match this pattern in my current directory but then i could delete them all if for some reason i didn't want them to start with an f i could delete them all or i could move them all i could copy them there's a whole bunch of things we can do next up we'll cover the diff command which we can use to find the differences between two different files if you've ever used git you probably have seen the get diff command we will actually see what it relies on behind the scenes to generate a diff but first let's make two files or at least one file that is slightly different than another so i have this ice cream flavor five you know fave flavors file i'm going to copy it so copy fave flavors and i'm going to make another file called fave flavors 2 dot txt it's not very original all right so now we have two of them and if i compare the two with diff at the moment they are identical there's no difference so let's change something in fave flavors two let's echo another thing in there how about what's another flavor well let's just do mint again and i'll append that not with a single greater than sign two i want to append to fave flavors two dot txt okay so now that exists at the end of that file just that one extra addition of mint so if i rerun my diff between those two files this is what it tells me 24a25 mint now we could spend a lot of time talking about how this works but to read this change command here what it's telling us is that on the first file line 24 on the second file line 25 was added so if we change the direction if we instead compared fave flavors to to flav fave flavors just on its own now the output says line 25 on the first file line 24 and the second file was i don't know if the d stands for deleted i believe so you know appended added deleted we can have multiple diffs too in a file just if i quickly change something in how about in fave flavors two so let's open that up i'm gonna change something on line three i'm gonna do strawberry and cream all right i'm going to save that file and close it now if i do my diff between fave flavors and fave flavors two we see we get two different diffs right two different things that were changed on line three of both files it was changed from strawberry to strawberry and cream and then line 24 of the first file line 25 of the second file we added mint anyway uh this is one way of using diff but what's probably more common uh and more useful is to see both files side by side with dash y so that's one option if we pass in dash y uh although in this case um way zoomed in it's kind of disastrous isn't it on this screen size because i've tried to make things readable but if my font were quite small you would see it side by side and then lastly we have the dash u option which is what git uses behind the scenes to display its own diffs and this just gives us a different output if we look at mandif again and we go down to dash u output the num lines of unified context so it gives us some context around each change so let's do that again instead of dash y dash u and what we see here are the files that we're comparing and then context is saying from line one to six we can see what was added or removed uh and then same thing here we can see what was added so this is maybe familiar if you use git and that's the basics of the diff command next up we'll talk about the find command so find helps you find files or folders matching some file pattern but there's quite a bit to it and we could have a 20 minute video at least devoted just to the find command so i'm going to just try and hit the highlights here the first thing you should know is that we can find files and folders by a bunch of different criteria we can find based off of let's open up the man page based off of the name of the file the modification time uh the file size the type if it's a file or a directory or a sim link there are probably many others that i'm forgetting at the moment and i'm just scrolling through the man page here it's quite long as you can see so again we're just going to hit the some of the highlights here okay so the first thing is if we want to find files or directories we need to provide a location to look inside of so find inside of in this case dot meaning the current folder or find in the desktop or find in my animals folder and then we provide some sort of criteria something to search against in this case dash name and then some sort of name that we want to find so i'm just going to search on my desktop i have a bunch of files but find will search recursively so if i do a find dot and nothing else just find dot it is going to find every single file nested somewhere inside my desktop so there's a lot of stuff going on here if i scroll i mean you can see they're all nested they're not actually on the desktop they're nested multiple levels deep uh we didn't specify any way of narrowing what we're looking for but now let's try let's find everything that has in its name and then instead of quotes uh let's search for anything that has hm how about the number seven in it anywhere on my desktop or any folders nested in the desktop or folders nested in those folders and so on really nothing why didn't we find anything aren't there at least there's one file here that has a 7 in its name and the answer here is that it's looking for an exact match a file that has and it is called seven if i made a file called seven right here and i reran it it would work we found that file but what i want to do is find any file on my desktop or nested somewhere on the desktop that has the number 7 in it so this is where the special wildcard characters of a star in our case will come in a star is just going to refer to anything and then a 7 and then anything else optionally before or after so if i do this we now get a bunch of matches a lot of pokemon that i have for a different video i made that have a seven in their name somewhere but i'm sure there's some nonpokemon here we go morning day 27 nested very deep inside of this folder or here's you know file 257 so we found files that contain seven in their name so if i wanted to find all files for a particular type like all python files dot py i would put a star which again means anything followed by dot p y and it looks like there's just one let's try a dot j s we've got a couple of js files nested in my desktop now remember dots is where i'm searching inside of and that's just my current location but i could instead say i want you to search only within the stuff folder if i can spell it correctly it's not going to find anything but maybe i'll find txt files and there we go we only find txt files inside of stuff so we can also find by type i can find directories or files or sim links so why don't i do a find on my desktop once again and all that i want here are any entries anything that it finds where type is d for directory now i forgot to specify where to search we'll search in our current directory and i get a list uh these are all directories there's a lot here but no files if you notice none of the actual files are present no dot txt or js or whatever it's just the directories if i did type f i only get the files as you can see here these are all of course they don't have extensions so you can't tell but you have to trust me they are all files for each pokemon in this case or whatever you're seeing printed out these are all files there are no directories that i've been found now there's directories referenced in the path to each file but that's not the same thing as the actual directories being returned as a result here so we can combine them too maybe i want to find directories only so i'm going to do dash type is d and name as uh i don't know how about uh an uppercase um uppercase e we'll see if we find anything that contains an uppercase e and we do so only directories somewhere on the desktop where in their name they have an uppercase e so here we go uppercase e uppercase these are all directories now i can also do a case insensitive version if i do i name for insensitive now i'm finding everything that has an e it doesn't actually matter if it's uppercase or lowercase so we see things like right there there's an e in that directory's name there's an uppercase e and a lowercase e okay we can also do fancy logical things like use the or operator so dash or so let's give it a shot let's find uh anything that has in its name so in our current location dash name it starts with the letter e so actually sure let's do e so e and then followed by anything now remember if we put a star there that means anything can come before the e but what i want is it must begin with the letter in this case uppercase e so we get a bunch of the e pokemon and there's some others edgar ethel elvis instead of the chickens directory now if i also wanted to say or name starts with how about f star and now i have fall fungus as well as espeon and you know files that and directories that start with an f or an e uppercase only because i didn't do i name so that's just a taste of using the or operator there's also a not operator we can do things like search by file size how many bytes how many megabytes greater than something so for example to find files that are larger than 100 kilobytes but smaller than one megabyte we could run this right here so find where type is file f and size is plus 100k greater than 100k and size is minus one m one megabyte so let's try an example let's do uh find where type is file and size is greater than 100 kilobytes and there we are we get a list of files that are greater than 100 kilobytes if i left that size off we get way way more files we can also do things around time so if we want to find files that were edited more than three days ago we would do dash m time which is modified time plus three and then we get to the last little bit that i'm going to mention around find which is this weird looking thing dash exec this is an option we can provide where we then specify a command that we want find to run on each found result so this example is going to find all files in the current directory right type is file and on each one it is going to cat that file out it prints its contents now i'm not going to run that because on my desktop i've got a million files that it will print out but let's talk about this quickly so dash exec is just the option saying hey i'm going to give you a command i want you to run with each match and then here's the command the entire command we're providing we do have to terminate it with this backslash and then a semicolon that is how the terminal knows where that command ends and then this the curly braces opening and closing is going to be replaced it's a placeholder it will be replaced with each found result so let's try an example let me recall this line where we found files that were larger than 100 kilobytes we could verify the size of files one way at least is with dash l ls l rather right and we can see the file size here and there's a lot of them there's a couple that are larger but most of them are pretty small dash l is going to give us that long listing so what i want to try is taking these files that we find that are larger than 100 100 kilobytes and then telling find to then call lsl and then curly braces and then we need our backslash semicolon and of course my font is quite large here but what you can see is that for each one of those results if i just run find without dash exec these are the results right gg dot i think that's great gatsby.txt uh pokemon exercise nano exercise whatever these different files are they're all here but we actually executed lsl with each one and we can see that file size is large much much larger than the other ones we could do something instead like if we wanted to cat each file out but again there's going to be quite a few things printed out so all files larger than 100 kilobytes dash exec means i want you to then run each match with cat curly braces just concatenate them all oh my goodness that's a lot of stuff that was just printed out a lot of it is kind of messed up but there we are that is the result of executing that cat command with every single one of the found files that matched with our find command all right so there's a lot more to find you can do some really powerful things but that's just a quick intro next up another command that could have its own video for 20 30 minutes at least grep there are many articles many tutorials that are quite long that exist solely to explain all the different options and various ways of using grep so what it does is it helps us find text inside of files so the find command helps us find files right based off of their file name or different attributes but it's not searching in the files grep will search inside of files so the simplest way to use it is to run grip and then tell it some string or some piece of text or something that we're trying to find and then a file to search inside of so let me show you an example here let's clear this screen all this craziness i have this song of myself file here i opened it in less there's a lot of stuff in here and i want to find every time this file i don't know mentions green in it so i can do grep green song of myself.txt and it prints out to me the matches right it highlights them in a different color of every time in this file the word green showed up so we've got green leaves green and violet dusky green pale green eggs quintillion's green there we go we can also ask grep to give us the line numbers with the dash n option so we'll add that in right there dash n and now i'm getting the line numbers so 32 is the first one all the way to line 1026 i can also ask for some context if i use an uppercase c and then i provide an argument a number of lines i want in this case two that will give me two lines before and two lines after each match so let's try that c and then two and here we go so this is one match this is actually the last match on this line we have two lines before and two lines after uh here's another match right we have two lines after two lines before another option we can pass to grep is dash r which is for recursive uh and this is a bit different this will actually tell grep if i do grub dash r and then provide some pattern like chicken it's going to tell it to search recursively in my case right now just in the current directory and all nested subdirectories so instead of just looking inside of one file like hello.txt which doesn't exist now i can look inside of all files at least if i tell it a starting point i think the default is just dot okay so uh what we see here is a bunch of matches one from gg.txt or a couple a couple from sorted everything and everything feedstore.txt website.html greatgatsby.txt so these are all files that were nested somewhere in my desktop and they all contained chicken now uh it is important to note that it is case sensitive so if i did you know uppercase c no matches but i can make it case insensitive with dash i and now i get my matches again now what makes grep really powerful is that it can work with regular expressions which i'm not going to go over right now if you know about regular expressions you know the syntax you can provide regex patterns to grep to search against so you could find all matches of an email pattern or a phone number pattern and that sort of thing okay well i changed my mind i'm going to show a quick example i'm not going to explain any of it because regular expressions is its own crazy topic but what i'm doing here is using a pattern this is a regex that will match email addresses so i'm searching across recursively across in my case the home directory tilde for any matches to this email pattern alright so i didn't type this out myself just to be clear i found an email regex but i'm going to run it and you'll see a bunch of different emails that have been matched being at search.mozilla.org toolkit.mozilla.org toolkit at mozilla again firefox these are all coming from some uh documentation it looks like from firefox here's some other ones anyway the point is we can match these patterns across uh in a file or across our entire machine and there are tons of powerful regular expressions that you can write but we're not going to talk about how that works it's a whole separate topic anyway that's a quick intro to crap next up du disc utility i think that's what it stands for i guess i should verify that would be the logical thing it stands for uh well disk usage no i'm totally wrong i'm pretty sure it's disk usage anyway what we can do with du is find uh the sizes of files and directories on our machine so if i just run du in my current directory wherever i am it's going to give me an output of all the other directories in here and their sizes so you can see you know if i just pick one of these let's find something slightly larger here sure this tar demo folder is 32 kilobytes this wildlife folder is 16. this cleanup directory is 156 kilobytes and so on uh and then down at the very bottom i can see my actual current folder right here is dots is 36 megabytes i can provide a folder to look inside of instead of just my current directory i could say i want to know the pokemon exercise folder what's its size and it's uh let's see 24k we can tell it to give us a different format megabytes or gigabytes using dash g for gigs dash m for megabytes so let's do du we'll do everything here dash m for megabytes uh it's all just one maybe two if i do it on my mac here we may get some more stuff not a whole lot but some of this stuff here's something 410 megabytes here's something that's 25. now you may notice it's not actually giving me uh the unit it's just 1 or 0 or 10. if i use dash h which is for human readable it now is giving me a human readable size so 4k 24k but then also for some of these larger things we get you know gigs 5.7 gigs so this is what i use most of the time if i actually need to read something as a human dash h now here's kind of a nifty thing we can do if i want to find the largest directories on my desktop here i can do d u dash h for human readable okay and i can pipe that to the sort command now we're almost there it is sorting but the way that it's sorting is not exactly correct if you notice here it's doing a sort you know once again based off of the digits so it's saying you know 9.2 m megabytes is somehow smaller than 900 kilobytes so it's putting all the nines together that's that's a start but it's not actually sorting them so sort actually gives us an option if i go to man sort it gives us an option dash h oh where'd you go i lost it here it is human numeric sort so it sorts my numerical value but it takes into account prefix or suffixes like k or m or g so it's for human readable numbers so let's run this again we are going to get a human readable format from du of all the files on my desktop sort them with dash h to make it a human readable sort instead of the default sort and now if we go to the top we get our smallest files the kilobytes and down at the bottom we get our largest files and if i wanted to find the top 10 largest files for example i could then pipe that to tail that would be one option and there we go i'm getting the 10 in this case because that's the default for tail largest or i could reverse with dash r and instead get the head which will be the same thing right i'm now getting the sort is in reverse order and i'm taking the first 10 instead of the last 10. anyway that's an intro to the d u command the next command we'll see a nice and quick one is df not to be confused with du the du command showed us file sizes and folder sizes whereas the df command will tell us information about the mounted file systems how much space they take up and how much free space they have left so i'll just show you very quickly here if i run df with no arguments or options i'm going to see some output here yours will look different the file system so each individual file system and then the amount of size that it has been allocated how much it uses how much is available now this by default on ubuntu is in one kilobyte blocks it's not so easy to read if i switch over and use the dash h option for human readable now we get megabytes and kilobytes and gigs and that sort of thing okay so we can see things like here is this file system udev uh here's where it's mounted uh here's how large how much space it's been allocated and how much it's using uh i'll show you this on my mac as well so let's do that now i have to zoom out quite a bit just so that we can see the columns but what we'll see here is that some file system uh has been allocated up to 3.6 this is actually tip tebites uh not terabytes uh it's let's see it's a 1.1 times so 10 larger than a terabyte and it really doesn't matter the thing is i know this is a four terabyte computer uh the drive here so three point six terabytes makes sense anyway that's how much space it's been allocated but it's only using this file system at least is only using 10 gigs or you know here's another one this is my slash dev disk 1s2 blah blah blah blah and here's where it's mounted it's also has up to 3.6 tbytes to use but actually it's used 2.2 terabytes out of that anyway you may not really need to use this command but i'm just being comprehensive here one thing that can be nice though is if we pass a file or a folder as an argument to df it will tell us more information about the file system that particular file or folder lives on so if i wanted to know you know where's my desktop and how much space is that file system taking up i can do d let me just clear first i can do df h for human readable and then desktop and we can see this is the file system this is you know the capacity of that file system how much is available and so on so that's all there is to df uh and remember du tells us about the actual sizes of individual files and directories df tells us about i don't know if it's disk free or disk file systems or i don't know what the f stands for i was trying to look at the man pages and figure it out but think of it as disk free sure next up the history command now this one can be very useful especially if you have some long long commands you ran i don't know 20 or 500 commands ago and you want to rerun it and not have to type it yourself again or you don't know what it was that is what the history command helps us with so on its own if we just run history let's do it here on my linux machine so i'm going to run history here i'm going to get a bunch of lines as you can see there's a number next to each and then a command that i ran so we can see a history of all the commands that i've run so history was the most recent command before that i had man df and then d u dash m i had clear i had d u d u d u d u uh you know all these different commands um and let's say this is the command i want to rerun this is the grep that will search for regular expressions uh or sorry it searches for emails using an email regular expression across my entire machine i don't want to have to type this myself one option i guess it's just to copy and paste that definitely but there's also something called history expansion where if i have that number and your numbers are going to be different but if i have a number i can take it and simply run exclamation points and then that number 2064 and now it's running that command again it's finding all these matching emails across my machine so just one more example oh geez i need to rerun history and if you prefer you can actually pipe this to less so that command less opens up a program where we can scroll a bit easier we can page through commands one at a time i can find some command like i'm sure this one here that finds things that start with the letter e or f so it's 20 40. i can exit less and just run exclamation point 2040 and now it finds me all the files and directories that have an e or an f uppercase as their first letter another thing you can do is actually combine grep with uh history if you're trying to find some commands you ran a long time ago you know as you probably just saw there's tons of commands here and somewhere in this massive list my history list there was a command i ran and i know that it included the word i don't know cookie but i'm not sure where it is and i want to rerun that well i can run history and then pipe that to grep remember pipe that pipe character allows us to take the output of one command and pass it as input to another so then i can search for cookie and there's quite a few actually surprisingly where there are commands so we're just searching through the text returned from history using grep we found a match five or what six seven different matches and if i want to run one of these i can take that number and exclamation point that number so 1686 this is just going to make me a bunch of files so i even want to do that not really but i've already committed okay so you can see it made me those files i think it was cake and cookie and there's cookie cake is up here somewhere anyway that can be quite useful if you know somewhere in this massive history there was some command and it included some pattern or some some word and that's all you remember well you can use grep to search for it the next command we'll cover is ps so ps is a command that helps us inspect or view the process processes processes running on our computer so if we take a look at man ps process status is what it stands for i didn't actually know that i just always thought of process in my head anyway it's going to display information about currently running processes processes and by default if we just run ps i'm on my mac in this example with no other options or arguments it shows me a list of all the processes started uh by me the current user so uh what we see here we've got uh well first of all the process id we've got the time we've got the actual command you can see i've got a bunch of bash shells and uh and then really the only somewhat interesting thing i guess would be this python process i have uh i have a python server in a different tab that i've started but just to show an example i'm gonna start a node server in this tab i've got this app.js i'm going to run it with node here's my server it's running i started a new process now if i run ps again we see somewhere there we are that process right there okay so that is a process i started and we can see it right in this list it has an id and in a moment we'll also learn how we can kill a process where that id can come in handy but there's more to this command we can also view a list of processes initiated by anyone on our machine basically all the processes not just the ones that are user initiated by me so all processes to do that p s a x so this is a pretty common one v s a x we're going to see a lot more going on here so we still have you know that node server i started up we've got our bash instances and then a whole bunch of system stuff look at all these processes now you will see they get cut off here so if they don't wrap over to the next line i can't scroll it just gets cut off so there's a way around that it's a very weird option if we add on two w's a x w w now you'll see that they wrap around so i've got my short processes that i initiated here but then some of these are quite long like this google chrome helper renderer i mean it goes all the way down to what about there i think no actually here i mean that that's very long but it does wrap over instead of being cut off so something that can be very helpful is to combine grep with the ps command so that you can find some process and generally when you're trying to find a process at least when i'm trying to find something i actually might be trying to kill it which is again a command we'll learn shortly so there's this massive list and somewhere in here i do think i have visual studio code open but i don't know what its process id is that's this first column here i could search though so i can recall that command and then pipe it to grep and let's just look for visual to start alright well there's quite a few of those how about visual studio okay so here are all the matches for the visual studio code processes quite a few still wow all right didn't narrow it down all that much but here this is the one we'd probably want to kill the visual studio code.app now i wouldn't actually kill visual studio code this way you can just quit it or force quit it but when i cover kill just in a moment you'll see that there are some situations where you would need to do this you actually would need to find out the process id all right so that's a quick intro to ps there's a lot more to it as you can see there's some options we didn't really cover any of these you can filter processes by who they belong to or who started them you can change the display format you can add more information to be displayed anyway there's a lot more you can do but the basic concept is that it displays information about the processes running on your machine the next command we'll take a look at is top top i actually don't know what that stands for does it tell us not really it says display and update sorted information about processes i think it comes from the fact that it will show us the top most memory intensive processes or the top most cpu intensive processes so what it does if we just run top it's going to open up sort of a different screen we don't see our prompt anymore what we see now is a little dashboard that shows us information by default of the top that must be where it comes from the top most uh cpu intensive processes so you can see over here the command so i've got screenflow that's what i'm using to record this video i've got uh some core audio terminal the top command itself they each have a process id we can see a bunch of other information the memory that they're taking up the cpu percentage and we can also sort instead by memory so if i rerun this it's dash o m e m for memory and you'll see now this is highlighted and we can see they are sorted in order of how much memory these processes take up processes so chrome unsurprisingly is up top and then i've got uh these are i'm using parallels for my virtual machines i have windows running over here and then i've got uh linux running over here so that's what you see there i've got chrome again uh pdf editor the screenflow um anyway it doesn't really matter but what you'll see is different but we can sort things by the amount of memory they take up and we can see that process id which is useful when we want to kill something later on uh you need to reference that process id all right so that's top to get out of here type q that's the easiest way i think you can also get out with control c most likely yeah i just use q the next command we'll cover is kill kill we use this command to kill programs but it's actually a little bit more complicated than that it's not just a matter of saying shut this thing down or kill it there are a whole bunch of different different types of signals that we can send when we run the kill program so there's actually a lot of different signals and it can be very overwhelming and confusing if you try and understand them all i'll just quickly show you here if we run the kill command with dash l it's not going to kill anything it instead will list the different signals that we can send so there's things uh actually to make this a bit easier why don't we pipe that to less so i can scroll through it all right so we've got things like sig int and sig il and sig kill sig bus sig term sig charm is actually a pretty common one it's terminate we've got say kill signal kill let's see there's a whole bunch of these the vast vast majority i've never ever had to use and they all are supposed to be different they are supposed to do different things but what's confusing is that it's actually up to the specific program that you're trying to kill it's up to that program source code to handle these different signals okay so let's talk about some of the most common signals and the basic syntax essentially the way that we kill something is by using the process id we saw how we can use commands like ps and top to find a process id and then we specify a signal so we can specify a signal using the long form a word so hup that's a common one means hang up we can send you know term to terminate that's the default but what i prefer to do and what a lot of people do is instead you can use a number so as we saw here there's a number corresponding to each one of these signals so if i go back as i said term is a common one the number there is 15. kill is nine so we could send that signal too all right so if you're wondering what does this all mean when would i use one versus the other the way that i think about it um is that in general i try and use 15 first this is the gentlest way to quit something or to stop a process think about with the graphical user interface the different ways of of quitting or of shutting something down one option is to uh just quit your application and save your changes another is to quit and click don't save another option is to force quit the entire application another option is to unplug your computer these all are different ways of of quitting or shutting down a piece of software and that's kind of a silly version uh but the idea is that there are these different signals so 15 or sig term is a gentler way to quit it basically the idea is that your program that you're quitting or killing would have time to tie up any loose ends save any necessary state whereas on the complete other end of the spectrum we have nine which is what a lot of people use so a lot of the tutorials and docs you'll see just says to use nine which is the most brutal way of just shutting everything down and basically just force quitting a program and then there's a whole bunch of stuff in between but i like to try and start with 15 that allows things to shut down how they would normally and if that doesn't work then we use 9 which is just pulling the plug on the life support for that program all right so let's see how it works so just like a burgeoning serial killer we need to find our first thing to kill so fortunately i have a couple of node processes that i want to stop i want to kill if i do ps a here i have a server running uh two actual node servers uh here's the process id if we'll just take that first one and i wanna kill it so i'm gonna copy that id and it turns out that you know i can't stop this any other way normally you start a server and then you can stop it with control c or something but i've lost that window i don't have access to just type control c to quit the server so i need to kill it this way okay so i have the process id now the syntax is kill and then i can provide either a number like if i'm doing nine that is the brutal way of killing something that's the the just immediately kill we can provide the name kill or even the full name sig kill but i'm going to start with the default so if i just kill and then i put the process id in there this will send a term terminate signal that's the gentler way first that's the default so this is a gentle way that gives it time to close up shop and save its state if needed so if i try that i don't get any feedback and if i do psa again it's still there so it didn't seem like it worked just give it a couple of seconds sometimes we will just double check come back nope it's not working so now it's time for more aggressive action we're going to provide a signal and remember we can list all those signals if i do kill dash l this isn't that helpful to be honest uh it i mean it gives us a list but what does this mean what i generally stick with and by far the most common if you are gonna pass one through is nine but remember that's a brutal one nine is the kill signal and that's the one that just pulls the plug so we can pass that in kill let me just clear dash nine and why didn't i just show you it is here right there's that process kill dash nine and then the process id okay once again no feedback whatsoever psa and now it's gone now we just have this other node server running okay so that's the basics of the kill command i know it can be a little overwhelming but the idea is that you provide some signal and then a process id and that signal will be sent to some usually kill or terminate or do something to end that process next up in our killing arsenal is the kill all command so kill all is different from the kill command in that we actually can provide a name instead of a process id we can provide the name of a program that we want to kill and if we have multiple it will kill them all uh so if i happened just maybe happen to have multiple node servers running once again i actually just have them here so here's one and here's the other um i could just you know ctrl c and quit them nice and easy but let's just say i can't uh so i want to kill both of them instead of doing the process ids and all of this i can just do kill all and then provide a signal just like before with regular kill i can do kill or sig kill or nine and this is the most violent way of killing something kill all dash nine and then node so that is the name of the program i wanna kill once again no feedback unfortunately but let's see what happens well i don't see any node processes here and if i go to my terminal windows oh killed and killed so that is the basic use of the kill all command it doesn't require process id it's definitely less precise generally i use kill because i can isolate exactly what i want to kill but if i know there's multiple things or i just it's a pain to find the process id then you can use kill all next up we're going to talk about three commands that go together jobs jobs vg for background and fg for foreground so these three work in conjunction and they all have to do with running things in the background and well in the foreground so if we have some command or a program that happens to take a long time for example a command like this where i'm using find in the root directory so on the entire machine find all files that have changed in the last one day 24 hours so there's a lot of system files and a whole bunch of stuff it's going to take a long time if i just run it right now i'm going to get a bunch of permission issues but it's still running if you look down here it's going and it's going to take quite a while to check every single file on my machine so it's running in the foreground right now right meaning i can interact with it it's not well happening in the background um so i can stop it right if i do control c that just stops the whole thing um and there's actually something else i can do if i run control z what i can do is suspend it which kind of puts it in a state of uh well suspension it's not stopping it entirely forever it's not ending it it's pausing it so i'm gonna rerun that and by the way what i'm doing here is finding all those files and then putting it all eventually in a file called all changes or all maybe i should rename that to be all changed files or whatever we're not going to be using this to do anything i just am using it to illustrate that we can have these things that take forever so if i hit control z right now you'll see it says stops right here so this is slightly different than what happened earlier and now if i type the jobs command which is how we can check up on any jobs we have running we see this program is currently stopped okay so let's try doing something else what about uh the top command if you remember this it's going to show me all these different processes on my machine and how much memory and all the stuff they're taking up and i can use control z to stop this as well so ctrl c just gets me out of there if i do control z it actually stops that or pauses it and if i type the jobs command again now we have two jobs in here so two different jobs that are both control z they're both suspended now what i can do is selectively rerun or resume one or both of these jobs in the foreground like what we saw here is in the foreground or i can actually run them in the background so that they they keep going but i won't see all this text i won't see them in my terminal but they'll still be running so this jobs command is just how we check up on jobs see what their state is and they also have an id or a job number and that's important because when we want to selectively resume them we can use those numbers all right so the first command i'm going to show you after jobs is actually fg for foreground so if we run foreground and then we specify a number a job number that job will be resumed so if i want to resume the top command its number is 2. so if i do fg 2 there we go it is now running again and it's in the foreground so i could suspend it with ctrl z or i can just get out of here control c or q if i look at jobs now we just have this one job right this is my find program now i can resume this in the foreground by doing fg and then the number one or because it's the only job i could just type fg so i'm going to do that now and here we are it's resumed again in the foreground it's just going to take forever and maybe we'll get some permission denied stuff let's see if there's any text and if i grow tired of this i want it to run in the background i don't want to see all this taking up my terminal screen i want it in the background not the foreground i can suspend it and go back to jobs it's suspended i can resume it but instead of doing foreground one i can do background one whoops and that will resume it it will be running but i'm not gonna see it running so i'm gonna do that so it gives me a little message saying all right this is running and it's in the background and the way that we know it's in the background there's two ways one this ampersand means something is running in the background two if i type jobs it's telling me right here running so it is running but we don't see it running right we don't see all that text but by using the jobs command we can verify it is indeed running i could bring it back to the foreground if i wanted to you know foreground i don't have to specify one it's the only job and here it is it's in the foreground and that's really all that there is to this we can run things in the foreground in the background and we can use the jobs command to check up on them this is going to just take forever let's see if it ever finished i'm just going to quit or stop it uh let's look at our all changes file yep so it's got a lot of stuff in there and let me just prove this to you one more time that it does work so i'm going to remove that all changes file yep all right so now we no longer have that all changes file if you remember i said the ampersand is one way we can send a job to the background uh so here's another a very stupid program in this context uh sleep is uh just going to stop if i just run sleep five i'll just show you the man page this is a new command it just delays for a number of seconds so five seconds i won't do that long let's do uh sleep two seconds so you'll see nothing happens it's a delay for two seconds and then my prompt comes back so we can use this if we're writing a script or something where we need to stop to wait for uh data to come back or to wait for to make a user feel like something is taking longer than it actually is for better ui there's all these different uses but typically i don't run sleep unless i'm teaching it now i can run this in the background so let's do a long sleep like 50 seconds so if i ran this in the foreground again it's stupid to do this but if i did i'm waiting here for 50 seconds um and i can't do anything else so i'm going to control c and end that but if i run it in the background which i can do by just adding an ampersand so sleep for 50 seconds in the background that's what the ampersand at the end means now i don't see that happening here if i look at jobs it is running though it is a job it's running in the background and then i could bring it back to the foreground if i wanted to just like that and now it's running in the foreground all right uh so i'm just gonna stop it anyway and if i go back to jobs now there's no jobs all right so that's kind of a lot of stuff around jobs and foreground and background let's just recap that so if you have a program you run a command put an ampersand at the end it's going to run in the background if we don't do that but we want it to run in the background i say after the fact let's rerun my find command this long find command i could run it and then suspend it and then decide i want that to run in the background so i could get the job id i happen to know there's only one job but i could get that id and now say go in the background one and now it's running in the background and it will take a while eventually it will complete it's still running as we can see here it has that ampersand it shows us it's happening in the background i don't know how long it's going to take quite a long time but eventually it will finish next up we're going to talk about compressing files we'll first talk about the gzip command which is used to compress files it uses an algorithm called gzip there are multiple different compression algorithms if we take a look at gzip on the man pages it the whole idea is that it reduces the size of files using lenthil ziv coding lz77 so you know compressing is a very complicated um interesting but very complicated area of study and there are quite a few different algorithms but one of the most common on linux at least is gzip so the way that it works is that we have some file hopefully a larger file that we're trying to reduce the size of and we provide it to gzip however i would warn you it's not a huge deal but if you just run gzip with a file name it is going to take that original file compress it and replace the original file so you'll only have the compressed version that ends in gz that's just the extension that it gives it uh if you want to keep the original file you can do two different things this is a slightly clunkier way but the better option in my opinion is to use dash k i don't know if it stands for dash keep that's what i think in my head and that will keep the original file so let me just demonstrate this here i've got a somewhat large text file if i just uh cat it out it's a lot of stuff in there it's the result of running a find command and redirecting the output into this file okay so if i run gzip and i'll do dash k on that file we don't get any output which i'll show you how to correct in just a moment if you want some output but if i type ls we now have this file here all changes.txt so the same name but now it has an additional.gz.gzip extension if i do an lsl we can see the file size difference but actually let's make it human readable with lh for human readable pretty significant reduction in size almost 2 megabytes down to 200 kilobytes now i'm going to remove that so remove all changes.txt and uh i'm going to just show one more oh no i removed the wrong thing well that's annoying all right it's gone i don't have that original file if you remember when i talked about remove when you remove it doesn't go to a temporary recycling bin it is gone but the good news is we do have the zipped file the gzip compressed version and i can unzip that to get my file back so we'll just jump ahead and talk about unzipping so the way that we can do that is to use the dash d option to decompress that is one way of doing it and then there's also a totally separate command called g unzip which you can use which is basically the exact same thing there's a couple more options but it will unzip a gzip compressed file in the same way that gzip dash d will unzip so let's start with uh well why don't we do g unzip all changes.txt.gz all right i type ls and there we are i now have the uncompressed if we do lsl let's do lh 1.8 megabyte version okay so let me just show one more thing when we gzip it again so i have that original i want to keep the original and if i add dash v for verbose it's going to give me information about how much space it reduced or how much it compressed the file all right so i'm going to do gzip dash kv and then my file is all changes.txt and it says it reduced it by almost 87 if we do lh for ls we can see once again 1.8 m 232k so a lot smaller and then just one more time we can use g unzip or we can do gzip dash d for decompress on that file and it's going to ask me if i want to overwrite because what i'm doing here right i kept the original so i would be unzipping a new file with the exact same name do i want to replace it sure okay and now we're back to what we were at before it is well let's do h again 1.8 megabytes so i unzipped and that's kind of all that there is to that one thing that's important to know about gzip is that it will only zip individual files so it won't you know it won't take 10 files and zip them together into a single compressed file we'll see how to do that with a different command but just to show you what happens if i make let's see i have this one file let's make another file whoops just with some very small text in there i'll call this one.txt and let's do it again actually for 2.txt okay so i now have three files in here if i do gzip and i'll do dash k if i want to keep the originals sure g g zip dash k and then we'll do v as well for verbose all changes and then a space one and two i can provide multiple files and it does compress them but it compresses them individually so we end up with three different gzip files okay so it did not combine them it just compressed multiple so that brings us to our next command tar tar tar is a command that we use to create an archive which is basically a grouping of a bunch of files potentially a bunch of files together into a single file and then we can go and compress that file so the name tar is short i think for tape archive an older relic of uh days gone by but anyway the way that it works is it's kind of complicated there's a lot of options the man page if i just go to mantar it's very long lots of options but i'm just going to show you some of the most basic things that you might want to do primarily taking a folder full of a bunch of files and combining them down into a archive and then compressing that so that we have a single file that is compressed that we can then unzip later and then expand back into a whole bunch of files okay so the syntax the basic syntax is to run tar and then a couple of options to create a new archive to smush files together we provide the different files we want to smush together separated by spaces we provide two options c for create and then f is it's the way we provide the file name that we want it to create so if we provide f we must provide the archive name unlike when we zip a single file it can you know gzip can just use the name of that file and append gz but here we're combining files together so we need to provide an end result name okay so i have a simple oops let me go into that folder a simple folder here lslh shows us we've got three files lots of text more text and song of myself.txt i'm going to combine the three of these into a new archive so the way that i do that is tar c for create f is the file option so i provide the file name for the archive i'm going to call it um i don't know archive okay and conventionally these end with dot tar as the extension and then we'll just provide the file so song of myself what was it lots of text more text and then i'll hit enter and this will create a new archive file as you can see right there and this does not mean it's compressed to be clear okay it's just a single file if you look at the file sizes 3.6 megabytes well we had 1.8 1.8 and then 85 kilobytes so we did not lose any size along the way this is not compressed but now i could go and compress this if i wanted to but before we do that let me show you how we can unarchive to extract files from an archive we use the dash x option for extract c was to create x is for extract and if we just do x f and then we need to provide the file name once again this would be the archive we just created this will unarchive it in our current folder but we can also move them so we can provide a directory a destination with dash c and before that we can actually just view what's in the file if we use the dash t option so i can just show you that why don't i move my archive somewhere else let's move um why don't i just make a new directory i'll just call this somewhere and then i'll move my archive into somewhere okay so let's cd into somewhere all right so now i can show that dash t option which we can use to view the files uh that are inside of this archive so we have this let's just say i downloaded it i don't know what's in it well i can do a tar t f archive there we go it says hey there's three files in here i don't have them they're not out of that archive they're still in there all combined down into a single file but i can then extract them i'll just do it in the current directory so to do that it is tar x f and then the archive now i have those three files as you can see here okay and then again i could provide a destination instead if i want to extract them somewhere else with dash uppercase c okay so still no compression the next step is to combine compression gzip is going to be our algorithm along with archiving with tar so we can do this separately just to be clear i could do if i uh just remove lots of text more text and song of myself yes yes yes okay so i have this empty directory except for the tar i can compress that tar as we saw with gzip so gzip and then i'll do dash k to keep the original file if i want to archive.tar and now i have the compressed version okay so it's only 502 kilobytes compared to 3.6 megabytes so let's delete the original tar so rmarchive.tar and now i just have the compressed archive so this is really you know a bunch of files combined down into a single archive then compressed this might be something we download or something we get from some mysterious source now i want to get it back to the original files that are inside of it so i need to uncompress and then i need to unarchive so to uncompress or decompress remember we use gzip and then dash d and then the name of the file so now i just have the regular archive it's much larger right 3.6 megabytes now i need to uh on archive so we need tar. x for extract f so we provide the file which is archive.tar and there we are we get our original stuff back out okay so we can do it in two different steps like we did there make the archive then compress and then uncompress go in the other direction uncompress and then unarchive or we can actually use just the tar command to do it all together the tar command has a special option z for gzip which will also compress and archive with that gzip algorithm at the same time so instead of two separate steps we can do it at once so i'll just show that real quick let's do the same thing let's remove my archive i have my three files i'm going to combine them together with tar i'm going to do create i'm going to zip with gzip and then i'm going to do f so i can provide the file name we'll call this bundle this time dot tar and then space the files i want okay and take a look at what we get i should have probably named it with a dot gz extension but if we look at the bundle.tar it is compressed it's much smaller so you don't have to have that extension but you want that there if somebody else sees it so they know you know this is a gzip file and you need to use g unzip to unzip it so if i want to remove these files so we just have the single archive or the bundle file okay there we are now to unzip it and unarchive i can just run our regular old tar x for extract f provide the file name i don't even have to tell it to use g unzip so let's try it there it is remember it looks like this 500 kilobytes single file i'm going to do atar extract and the file name is bundle.tar and let's see what we get there we are we got the three files back out all right so we saw two ways of doing it first we can create a bundle or create a tarball and then compress that or we can do it all in one go if we have multiple files we want to combine and compress we can provide the dash z option as we saw here to create a gzip compressed file next up we'll talk about a fun command called nano nano nano is actually a text editor you can run directly from your terminal now there are other text editors some that are quite a bit more powerful than nano but they are also quite a bit more complicated to learn and when you're starting out you can really mess things up so things like vim if you've ever heard of vim powerful but really tricky to learn when you're starting out and also could have its own hour long video there actually are courses on just using it so we're not going to go into that but nano is another editor that comes built in that we can use and the reason it's good to know one of these editors at least and there are others there's emacs and the reason it's good to know them is that you can directly very quickly change files or make modifications add things onto files without having to go through the whole process of opening up an external graphical editor you know you can do things quickly so i don't use something like nano as my main editor i like using vs code or something similar but it doesn't mean you shouldn't know how to use it now the basic usage is nano followed by some file name we want to edit so what do we have here i've got a song of myself txt i'm going to open that up with nano so this is a file we've been using quite a bit throughout the course and when i hit enter you'll see that my prompt goes away i'm now in an editor i can use the arrow keys to move and i can actually immediately start editing and this is different if you ever have encountered vim if you start typing you're not actually going to be editing things immediately there's all these different modes and you might be messing things up significantly but i can start typing so if i want you know i can say hello there and i can use my arrow keys left and right just like a regular cursor up and down um and let's just start with that i'll make a little change there all right so i've made this change now i want to save this this is probably the most important part of working with nano is down at the very bottom down here is kind of a little toolbar this is a list of shortcuts the different commands we can use inside of nano and one of the most important ones is this right here control x this is how we can exit so if i do control x right now first it's going to ask me before you go do you want to save or not i'll save that change so i'll hit y if i don't want to save it i'll type n and if i don't want to quit i can do control c okay so i'm going to hit y to save and then it's going to ask me well do you want to keep the same file name do you want to make a new file name uh you know save it somewhere else i'm just going to hit enter and keep the original file so i'm just saving a new version of song of myself instead of a copy all right so it's still there and how do i take a look at the beginning of the file i just want to see if it changed head song of myself there it is we did successfully make a change now there's more that we can do so i'm going to reopen that file in nano and a couple of things first of all if you notice on the right side here uh i'm getting a little angle bracket uh greater than sign that is telling us that there's more text so you can actually turn word wrapping on or line wrapping if you prefer for it to wrap over but i think the default is for it to just scroll as you see there we have different shortcuts down here so if we wanted to search for example to find something in this file i can do control w all right so control w and then i can provide something i want to look for so i want to change the word green in this file so i'm going to type green and i'll hit enter and my cursor shows up right there on the first match of green now i can keep searching again if i do ctrl w and hit enter again see it already remembers green it takes me to the next match so let's just make this all caps and very long green all right uh i'll save and as we saw previously one way of doing that is by quitting and it will prompt me do you want to save blah blah blah but if i don't want to quit and i just want to save my changes i actually do have ctrl s so i just did it it doesn't show up down here there's far more options that don't show up down here i'll show you how to view them in a moment but ctrl s does save to the current file right it's not making a new file name it doesn't give you an option do you want to save this somewhere else it just saves to the same name okay so if i type ctrl g right here get help i wish it was ctrl h ctrl g is harder to remember we get a whole manual here that explains how it works and then explains all the different shortcuts so there's quite a few things in here we saw ctrl w to search forward we can actually insert another file into this file or into this buffer with ctrl r we can cut and paste so this is one that you know you've probably noticed control c uh and control v for copy and paste don't really work in the terminal control c has its own meaning uh just like control z has its own meaning to suspend a job anyway uh we still can cut and paste the way that we can do it is with ctrl k to cut it actually stands for kill and then u to revive or to unkill i don't know what the u stands for and that will basically take whatever we've cut out and paste it so i can show you that there's options to configure a spell checker we can display line numbers we can go to a particular line number if we know what we want with uh where's that control underscore there's a bunch more stuff so you know this is not a course on nano but just so you know there's a lot to nano okay so to get out of here ctrl x is going to close the help screen now as i said i want to show you cutting and pasting so if i want to cut a line i guess maybe i'll just type a line first hi there cut me out of here please all right if i do ctrl k it's gone and then i can move it down somewhere maybe here and ctrl u it revives it and i keep hitting ctrl u there we go it's just like cut and paste uh if you do forget about that we can see shortcuts down here okay so i'm going to save control s we also can do control o to write out if i wanted to create a copy or a different file name i could type that here so maybe uh you know song of myself 2 dot txt and this is my version i'll hit enter do i want to save it under a different name sure and then i'll get out of here ctrl x one more thing i'll show you you can actually create a new file with nano so if i need to add some text into something a file that doesn't exist i don't have to make the empty file first then open it with nano i can just do nano new file dot txt and now i have an empty file i can type my stuff in here save and quit control s control x and there it is song of myself too from the previous nano and then uh new file.txt okay next up we have the alias command the alias command allows us to define our own aliases our own our own little short custom commands that we can then reuse later on so for example if we find ourselves doing you know ls remember just gives us this information lsa gives us all including hidden files lsla gives us listed long format information for all files if we find ourselves doing that a lot we could set up our own alias so that we don't have to type all of that and maybe just have la for example so if we wanted to do that i want la to actually be lsla the way that we do that is by using the alias command so i'll show an example here i'm going to do alias and then let's just call this my i'm gonna do something really obvious first like uh my ls equals and then in quotes i'm gonna use single quotes there's a distinction here uh single quotes and then i'll do ls dash la just like that okay so if i type alias now i'm gonna see a list of all my aliases i actually have quite a few on here here's the one i just made already and if i try running it my ls there we go i have a new alias i could take something you know really long like if there's some find command that i use a lot let me just show an example here i think i have yeah like this one right here this finds some of the i think it's the top 10 uh most uh cpu intensive processes on my machine um honestly i never use it because i don't even remember this but if i run that it's a very long command relatively long i can alias it to something short so pscpu10 and there we are i need to sort of zoom out my font size is too large for me to make sense of this here but that's all right i'm recording i need that large font size the alias we just defined is not permanent if i close this window or even just open another window my ls huh it's not working it doesn't know what the heck i'm talking about so when i just define an alias like bobo right here equals i don't know how about just sleep for 10 seconds okay when i define that in my shell directly here it only exists in this exact instance right here it is not going to be created every time i open up a new terminal window or my computer restarts i lose it so if i want to make an alias last if i want to have it persist i need to put it in one of a couple different places it depends on what shell you're using if you're using bash if you're using z shell there are different configuration files now over here i'm using bash this is ubuntu the default shell is bash and if i go to my home directory it's actually where i am right now again home meaning my home folder not the folder actually called home it's confusing but my user's home folder colt um if i do ls dash a there are some of these special config files now there's actually on ubuntu there's one called bash aliases and that is a good place to put aliases however that is particular to some distributions of linux it is not something that you may not see it depending on what distro you're using so a safe place is going to be the bash rc file so it's hidden rc uh and i can open it up i'll use nano to edit it dot bash rc okay now i'm in nano i can scroll down and i can define my own aliases in here um so let's just i think i already have some here there we are uh so i'll just define some in here just as an example uh alias and i'm just going to write the exact same thing that i wrote earlier except i'm putting it in this file and what's special about this file is that when the shell loads up it will run this file and it will run these aliases first before i even have a chance to do anything else in other words it will know about all these aliases i define so um let's see what should we do in here i'll make it an alias called um count okay and count is going to echo and if you remember our expansion i'll just echo 1 to 99 i don't know why we do this but sure we will uh and then i'm going to save this file so this is nano the easiest way is just control s and then i'm going to exit with control x okay so can i run counts no i can't run count just yet i could open up a new window and it will run that bash rc file and now if i try running count hey it works alternatively if i don't want to do that i can actually source the command is called source my bashrc file and now i can run count in this same window now if you're on a mac the default shell is z shell as we discussed earlier you could switch over to bash if you wanted to and just type bash and now i'm using bash and i can define my files or rather i can define my aliases inside of my let's do lsa here lots of hidden files inside of my bash profile here that's where i could do it on a mac or more likely if you're using z shell which is the default shell the file we want to add our alias to is dot zshrc where are you z shrc right there so that is our configuration file for z shell so i can do nano dot z s h r c and scroll down i don't have to scroll down i can define my aliases anywhere in here but somewhere in here i can define an alias so let's do a different i don't know a different version of count these are how we write comments by the way so if you want to have a little note or you want to uh have something not take effect you can put a octathorp or a hash sign in front of it so alias let's call this one um hmm let's do uh i'll just do another i don't know count count again but this time on my mac count is going to be an echo about 1 to 365 sure all right and that's it we could also define you know l a more useful and how about ll which will be ls dash l and how about uh we'll do l a will be ls dash l a so now and actually why don't i do one more why don't i alias rm to instead be rm dash verbose so it tells me when it deletes something so i have that over on my ubuntu over here which you may have noticed so let's just define those three alias or four we have count lla and rm i redefined the rm command to actually be rmv so that dash verbose option is always there i'll save and exit yes i'll save okay so in a new window i can run my count command i have the ll command i have la which also does hidden files we can see my hidden files are showing up and then i did the rm command so let's just create a file called remove me and delete me now if i run rm on remove me and delete me oh well i i didn't fully expand delete and to delete me but still it shows me what it removed so let's try try one more time there let's rm delete me there we go and now it just tells me it gives me a bit of feedback as to what was deleted anyway that's the basics of using the alias command remember where you define those aliases first of all if you don't define them in a file one of these special files they will not persist which is fine sometimes you may not need them to but if you do define them and you want them to continue to exist every time you have a new terminal window make sure you put them in the appropriate file depending on whether you're in zs you're using z shell or bash or some other shell they all have their own config files and one last note about working with aliases and specifically with quotes there's a difference in uh bash between single quotes and double quotes when we have double quotes and we have a variable or some form of so remember there's this variable expansion where we have a dollar sign if i echo some dollar sign and then a variable like path or there's user the shell sees this and it expands that or it replaces it with the actual value for user cults and that is what is echoed out okay so if i defined an alias that i just wanted to i don't know how about well let's just use this example here that is going to ls the contents of our current directory if i do ls dollar sign pwd that's what both of these are one has double quotes one has single quotes the difference is that whenever we use double quotes that variable is going to be resolved the value will be set in stone at the the definition time when we actually run this originally so whatever that pwd value is originally it will always be that but if i use single quotes instead single quotes will be resolved or that variable will be resolved whenever we invoke this alias so this in other words will be dependent on when i run this it's not going to be the same thing every time versus this one here because i use double quotes it's always going to be whatever the value is i'll just show you here if i just paste this into my shell currently the value of pwd it's my current directory so if i do ls this it's printing the contents of my home directory but if i go somewhere else like my desktop and i rerun that it's still printing the contents of my home directory no matter where i am it doesn't matter that i'm on the desktop or if i go into uh i don't know this wildlife folder and i run ls this because i used double quotes when i defined that alias this was set in stone at that moment i defined it now if i instead did this so i'll copy that and i'll put this in here alias ls current it is exactly the same inside the quotes remember if i just echo pwd it's a variable and it's just the exact same thing i see if i type pwd but the difference now is that this is going to rerun every single time that i run ls current so if i go to my home directory and i run ls current it shows me the contents of my actual current directory uh it doesn't matter where i was when i defined this so that's an important distinction when we use double and single quotes next up we get to talk about one of my favorite commands it's not my favorite because i use it very much that'd probably have to be i don't know cd or ls or something like that you just can't get around using those all the time but this command x args i don't use very much at all but when i do use it it really comes in handy it's pretty nifty so here's the whole point of it xargs exists to take output from one command and turn it into arguments for a second command so we've seen how we can take something like well first i'll just show you this folder i have i've got some files player two three four five six all the way up to player nine or player ten um so we've seen how we can do things like take ls and then pass that to sort for example right and what's happening here is that the output of ls is being passed as the input to the sort command however when i say input i'm actually referring to something called standard input somewhat of a long explanation to really go into but the idea is that unlike other commands we've seen like when we touch and make files i'll make another file here player 11.txt and player12.txt these are arguments being passed to the touch command it's a list of values separated by spaces so when i run that we end up creating what two new files and they're in here but when we do ls pipe sort we are not passing arguments to sort and this is what's kind of confusing the sort command is set up to accept values through standard input and it's also set up to be able to sort things as arguments so if i provided a file like i have this file called dead players we'll talk about that in a moment it can sort the contents of that file as well so this is passing an argument versus this right here we're passing the output of ls to the standard input of sort anyway i say all of this because only certain commands are set up to work with pipes only certain commands like sort and there's a lot of other ones that will accept an input through standard input rather than through arguments but there are many that don't so for example touch is actually one i just showed you i can't take the output of one command and pass it to touch at least not without x args so let me show what i'm talking about i'm going to show you first what we can't do the problem that xrx solves so i have some files here player 1 through player 12 these represent players in some game and people die after each round of the game and we need to clear them out we need to get rid of the players that died so i have another file called dead players if i just cat it out here you can see it has the names or the files of the players who are dead so what i want to do is take this file whatever's in it and delete or remove those files from the actual folder now this could be you know hundreds and hundreds of dead players and we could have thousands i actually recorded this once where i did have thousands like when i say once i mean like 10 minutes ago i had thousands of players and then i removed half of them but i realized that the scale was too large you really couldn't tell how many were removed so i scaled it down we're dealing with 12 now and we're going to delete what five of them here so aside from me manually doing rm player one and so on the idea is that this could scale up we could have thousands of players and there's some some list we don't even know you know exactly what's in there but some list of dead players it could be hundreds what i want to do is take whatever's in that file and dynamically remove those files so whatever those names are what i can't do unfortunately is just read the file so we can cat it and then pipe it to rm that will not work because the rm command is one of those commands that is expecting a space separated list of arguments it is not expecting anything to be passed to its via standard input so that's what's happening here with this pipe it takes the output of cat and pipes it over to rm but ram is not set up to handle that so just complains it says hey you didn't pass anything in there's no argument so what do you want me to rm just like if i had run rm here this is where x args comes in the x arcs command will take or it will accept standard input which is what's coming in here from this pipe so cat the output is passed to the standard n of rm but rm doesn't want anything to do with it but if we instead do x args if i can spell it rm what it does is it's kind of like an adapter it will take that standard in and then turn it into a list of arguments that will work for rm so this is the syntax x args and then the command that you want xargs to provide the arguments to all right so we're going to take this list of dead players which when we cut that out it's basically going to take this and provide it to xargs xargs then says okay let me turn that into a list of arguments that will work for rm provide that to rm and now when i run it well we see we lost a lot of players they're now gone right i this could scale up again to be hundreds at one time we can take the contents this is a simple example take the contents of one file and then do something with those contents in this case we've removed files that have that had those names let's take a look at one more example uh what i want to do is run the find command just uh on my desktop in all nested folders and files uh to find how about files that are larger so size is plus one m so greater than one megabyte and this is what it finds for me okay but i want more information about these i actually want to then uh do ls dash l right so we get that long listing format but i want lsl only for these files which is what seven or so files so um if i try and pipe it to ls dash l well surprise surprise ls is not set up to accept values through standard input which is what the pipe does it is expecting us to provide arguments sure after the fact so we could do you know files that end in txt but that has nothing to do with our find command i want to take the results of the find command and then pass those to lsl in a format that it will accept so this is again where xargs comes in so this is the list of files that are greater than one megabyte and then i can do xargs oops and then ls dash l that's the command i want to run and here we are we now see let's actually do lh so i can get the human readable format for the sizes not very large files on here 1.8 1.8 megabytes 1.2 1.2 but these are all the files that we found from that find command uh those values were then passed to xrx xox stepped in and turned it into a acceptable list of arguments that was then provided to lslh and that's how we see this output so there's actually quite a bit more to xargs i'm not going to go into here you can read the man pages it's pretty powerful the different ways you can construct the list of arguments the different separators and delimiters and you can have it replace different things for you along the way you can limit the number of arguments it's quite complicated but what i just showed you are some of the more common simple ways of using it and that's the core purpose of xargs is to take standard input and turn it into a list of arguments that other commands will accept all right so next up we're going to talk about the ln command which is used to create links ln link now when i say link it's not a hyperlink or you know something from a browser a link in linux is or it may be a new concept to you it's kind of similar to the idea of a shortcut your desktop shortcuts on a windows operating system where you have some applications that are installed somewhere else it is not on your desktop they are installed completely in a different area but you have access to start them up you can reference them through the icons on your desktop so there's a link those icons have a little picture of whatever adobe photoshop that icon on my desktop when i double click it it is linked it's referencing some actual program that it starts up so the concept is similar we can have a file that is linked that points to another file so there are two types of links hard links and soft links we'll start by covering hard links which actually are not used as frequently but the idea is when we create a hard link we are creating basically a file that will stay in sync with another file now we're not creating a copy we're not duplicating a file it's different they are pointing to the same thing the same exact file so they're not diverging they're not copies it's not like using the cp command that's important to understand so let me show you an example we'll start nice and simple i've got an empty folder i'm going to echo i am original into a file called original.txt all right so i just made this new file we can cat it out and it says i am original and that's the only file in here now the syntax to make a hard link is ln and then the original file which happens to be called original and then whatever our destination or not destination but whatever the name of the link file that we want to create is i'm going to call mine hardlink.txt so if i type ls we have two files now or what appears to be two files uh this hard link file if i cat it out says i am original it has the same contents remember though it is not a copy it is pointing to the same file as this right here so if i change original let's echo this is more stuff we'll append that into original so if we cat out original we see two lines now and if i cat out the hard link we also see two lines and this goes both directions because they're both referring to the exact same thing if i change hard link uh change from hard link and i echo that into the hard link file which is a hard link to that original file this is what it looks like now and if i cat the original it also has that change so they are two things two arrows pointing to that same file in memory and this means if i were to delete well first if i delete the hard link the original file is still there it's unchanged but if i delete the original file my hard link file will persist it is pointing to that same thing in memory and that's what's a little bit confusing here it is not pointing to the you know this name original.txt it's pointing it's called an inode it doesn't really matter but it's referring to the same thing in memory just two different names for it so if i remove original i'll remove it it's gone but our hard link file that is still there that hard link we created and it still has those contents inside so that's a hard link as i mentioned it's not as commonly used then we have soft links and soft links are different the first thing you should know is that to make one we use the dash s option if you just take a look at man ln and then scroll down somewhere on here here we are dash s for symbolic it will make a symbolic link soft link instead of a hard link so what i'm going to do here is remove my hard link and i'm going to create a new original file so we'll echo i am original again into original.txt oh i did dot tt but that's fine um just quick quiz how would i rename that without moving it anywhere easiest way is just move command original dot txt is the destination and there we go okay so i'm going to make a soft link and to do that it's ln s the file that i'm linking to and then the new soft link or the sim link symbolic link i'm going to just call simlink.txt okay so what i have now is a symbolic link or a soft link and if i type ls you'll see if you have colors enabled it really depends on the terminal you're using your operating system your shell but for most terminals it will probably be a difference and for me it's bolded and it is in a different color cyan it doesn't matter what color it is and even if there's no color difference it doesn't matter if we do lsl we can see a difference as well if you notice here here's my original file here's the sim link file it has this little arrow pointing to that original file additionally over here we haven't really talked about permissions yet but there's a difference there's a dash here is the first digit and there's an l here as the first digit this tells us that it is a symbolic link it's a link anyway just like before if i change the original file let's do a echo change to original and then we will append that to the original file it now looks like this and if i echo or rather cat the simlink file it also prints out the exact same thing now what if i try and change this sim link file echo change to sim link and i append that to the sim link file all right let's see did that change the sim link and does that mean the original has changed yeah it goes both ways in this sense however where there's a big difference is if i delete the original file so i have both of them here right now if i remove original yes now we have this simlink.txt but it doesn't look very happy it's still there but it's showing up in red all of a sudden and if i try and cat the contents it says no such file or directory so it's this link that it's just pointing to something that doesn't even exist anymore so that's the main difference the symbolic link was pointing to original.txt and when original is gone that link is severed with a hard link a hard blank is pointing to don't think of it as pointing to the file itself but think of the hard link and original.txt as two different pointers to the same thing in memory so if i delete the original it's all right we still have the hard link it's pointing to that same thing in memory but here with a sim link i delete the original well now this sim link has nothing to link to and it still is there right we still see something show up but it's just completely dead inside now you might be wondering why would you ever do this why does it matter and this is one of the harder things to explain or to convince you of when you're a beginner and i honestly don't even use sim links all that much or any links although i end up working with people who do use them and so i you know need to be familiar and comfortable working with them it's pretty straightforward once you get used to just that dash s lns but let me show you an example um if you have python installed for me i have python i think it came preinstalled and ubuntu and i have a couple different versions i'm going to run an lsl on this directory user bin and then python i'll come back to in a moment but user bin is where binaries are installed uh and so it's where python binaries will live by default uh and there's a lot in here so first of all if i just get rid of this python thing there's a lot of different programs in here uh one of which i'm just going to focus on for now is python so if i do an ls dash l user slash bin and then anything that starts with python maybe i'll even do python 3 because i have python 2 and 3. what we see here let me clear everything else again and just focus on this what you'll see is that there's four matches there's user bin python 3.8 3futurized 3pasteurize and then there's this right here what is that that is a sim link and that sim link is just called python 3 but it's pointing to a specific version so when i run python3 that's the command i'm running when i run that right here it's actually a sim link and it's referring right now to 3.8 but this allows me to manage different versions i could then have 3.9 or threepoint you know python versions that don't exist yet or older versions 3.5 i can have them all installed and then whatever this sim link it's like a shortcut whatever python 3 is referring to is what version of python will run so i can manage i can have all those versions installed but only one that is actually run when i call python3 so one with this little shortcut and i run python3 and there we go it doesn't matter if you know python or not uh and it actually we have the same thing if i just do python star python 2 i only have one version installed but i have a sim link and i don't set this up myself to be clear this was just done for me when i installed python but python2 simlink is referring to there's a little arrow python 2.7 but i could also have 2.8 and 2.5 and then switch versions and when i switch versions python 2 will point to one of those versions so that's just a simple example but there are many ways you can use sim links for now though i just want you to understand that ln is a command and that there are two different types of links we can make we can make a hard link and a soft link also known as a sim or symbolic link all right the next couple of commands we'll learn have to do with users and permissions uh they're pretty important ones that may not come up all the time but when they do come up they are really really useful um so on linux we can have multiple users logged in at the same time um doesn't really happen for me i'm kind of just working on my own on this one machine and for most people i shouldn't say most but i imagine for a lot of you who are watching this video you may be the only person using your machine but it's important to understand that you can have multiple users all logged in simultaneously to your same machine it might be hard to do right you may not have the the multiple screens and keyboards and whatever needed to have different people logged in at the same time although it can also be accomplished virtually the point is it's possible there is a command called who not to be confused with who am i who am i tells us the username based on the current effective user id for me that's cold steel here on my mac who is going to tell us about the users who are logged in and like i said for me it's really just me uh but what we'll actually see if i type it on my mac is currently what five seven different uh well if you include this one eight but right here what we're seeing are seven different uh users it's the same user but they're each added here separately for each time i access or each time i log in via a terminal basically every terminal window counts as a user accessing so i have seven right now this is tty is it it's teletype i believe it's an old relic but anyway if i create a new terminal window just ignore it uh and then run who again we now see we've got a 4 which wasn't there before you may not see that but if i zoom way in it says last login on ttyso so um yep that's why we're seeing all of those there anyway not the most useful command certainly not right now and not for me because i'm the only user but if we're an administrator and we've got a whole bunch of people on a machine at once this could be pretty critical to know who is currently logged in next up we'll cover the su command which is short for switch user this command allows us to switch users to log in as someone else within a terminal show so you may have situations where you might need to do this maybe not it really depends on what you're working on and how your machine is set up but if you are an administrator for example and you need to do something on somebody else's account well all you need to do is run the su command followed by some username now i have a different user on this machine so remember i'm colt on this ubuntu uh distribution here right now that's who i'm logged in as but i have a user called elvis and when i do su elvis it asks me to enter elvis's password so i can't just switch users to be whoever i want without knowing passwords unless i'm a root user unless i have full permissions but i don't so i switch user to elvis i need to know elvis password and i think nope i'm pretty sure i just got it wrong i did this last night let's see there we go entered the correct password uh and you'll see my prompt changes now says elvis at my ubuntu and if i type who am i it now says your elvis but just to be very clear this is in one window over here i'm still cult so i haven't completely logged out and become elvis everywhere it's still my horribly messy desktop but i am elvis in this tab aside from what we see when i run who am i if i cd to my home directory well my home directory tilde if i do pwd is home slash elvis whereas over here i cd2 tilde and i do pwd home slash colt is my home directory so as elvis i can do things like well there's nothing in this home directory but i could make a file touch from elvis.txt and i have permission to do that but if i go back and i go into colts account or rather colt's home folder remember i'm logged in as elvis here not colt uh what happens if i try and make a file here called from elvis.txt i can't do that so i'm logged in as elvis but that doesn't mean i can do everything colt can do we have different permissions and that's something we're going to start to try and understand we'll walk through how permissions work but this is just a quick introduction to the concept that different users have different permissions they can do different things and if i went the other direction as colt you know i can make a folder or a file from colts here no problem but if i back out and i try and go into elvis's directory i can do that but if i try and make a file touch from colts.txt no luck i can't do that i don't have permission anyway uh that's the basic idea of using su you probably wouldn't do this just make a random folder or file in somebody else's home directory but if you do need to switch users that's how you do it you need to enter the password and then to get out of here i think you can type exit also you can just do control d or control c i believe now there's another option when we run su if i do man su there's this dash that we can provide and if you provide that dash let's see if i can find it here it will start the shell as a login shell with an environment similar to a real login this means it clears all the environment variables it initializes the environment variable's home shell user log name and path and it changes us over to the target user's home directory so remember when i logged in as elvis i was actually just in colt's home directory anyway it didn't take me to elvis's directory like a normal login would but if i instead do s u dash and then elvis i can also do dash l but it's so common that you can just do dash it's a very short option i'll type elvis password and it takes me right to elvis's home directory this acts as a real login shell and then to get out of here again i can type exits or it is control d i believe there we go okay so that is su to switch users next up we'll talk about the sudo command sudo which is short for super user do and the command allows us to run commands other commands as the root user or with elevated permissions so there's this concept of the root user a user in linux who basically has permission to do anything to create new users to change passwords to remove files and folders and we actually if i just run ls dash l here i'm logged in as colt what we see here in this third column is the owner of particular files and folders but if i keep backing out now we see you know my different users if i take a look at one of them like kitty kitty owns these files and folders in her his or her desktop or home folder rather but if i back out another level so here i am one more time now we see a bunch of these really important directories uh that i who owns who who owns you know the bin folder where i have things like if we just cdn there all our programs are installed who's in charge of that which user well if i type lsl we see root all over the place the root user is in charge or not in charge the root user is the owner of these programs these files and folders uh and that's just one example of you know the significance of root root can do all sorts of things like i said a root user can change someone else's password but as colt's just a regular old user i can't do that now there's something very important to know on ubuntu at least in many linux distributions the root user account is actually locked it's not accessible you can't log into it there's no password i can't just log out and log back in as root if i go to log out we will see yes i'll log out we saw the text root all over the place in my terminal but there is no root account that i can actually log in as so why is this well it's just how ubuntu is set up it was a decision that was made rather than having a single root account with a single password that you can log in as instead individual users i have four here colt kitty carrot and elvis individual users uh may be able to run commands as the root user and that's where this pseudo command comes in so how does this work it's not like it's a freeforall and every single user on a machine can run commands as the root user uh those permissions are are actually listed out in a particular file there's a lot that goes into it and managing those permissions but i'm just going to show you though is that when you create your initial user account so colt was my initial user account whoops i'm logged in now as colts and i'm looking at my settings i can see different users again none of them are called roots but some of them including colt which was the first account i made by default is an administrator so that means i can add and remove other users i can change settings for all users but that's not the same as being the root user and then some other users carrot elvis are not administrators kitty is an administrator when you make a new user you can decide that now that's just one basic difference or one basic toggle between permissions but we can get very detailed about who is allowed to do what but we're not going to go into that i just wanted to make it clear that this sudo command i'm about to show you is not carte blanche for every user to do everything so i'll demonstrate that okay so how do we use this sudo command the idea is that instead of using a single root password each user has their own password we enter that password it's going to prompt us for that password and then it's going to check do you even have permission to run this command as root so it doesn't turn us into the root user it doesn't give us permissions to do everything if we don't already have them it only allows us to do certain commands that we are specifically already permitted to do it's just an extra level of protection basically you have to type sudo you have to type your password so even if you have those permissions you can't just normally go around deleting everyone's stuff you need to run sudo in order to do that so if i wanted to edit some particular configuration file that affects everyone on a machine if i just tried to open it in nano i'm not going to be able to do that but if i try using sudo first i'll enter my password and it will check if i'm allowed to do that or not so let me show you uh let me get my terminal open so the file that we're going to look at is in slash etsy etc host that's the name of the file and if i just do an lsl on it remember this is a high up directory it is not located in colt's user directory or any other user it's above and if i run lsl we can see that the owner is the root user but again there is actually no way to log in as the root user in ubuntu so uh if i want to edit this file for some reason i could try running nano and it does open up i can actually read the contents but it tells me for you this file is unwritable so i can't make changes i'll get out of here but if i now prefix this with sudo super user do this so super user do this command it's first going to say enter your password for colts that's who i currently am and it's going to check if i have permission if i am granted those root permissions to edit this particular file so if i enter my password this is not the root password this is colt's password that i log in with and we see i actually am able to edit this file i'm not going to because i really don't want to but this is a file i can change now but if i go log in as a different user and remember we saw how to do this i can use su dash i have elvis as a user on this account i'll type elvis's password okay who am i i am elvis so if i try and run this nano etc hosts i also see hey you don't have permission to do that that's a file owned by root but if i try sudo just like i did as colt it now asks me for elvis's password so what is elvis's password well i'm not telling you but i know it i type it in and it tells me nope that's not going to work we checked elvis is not in the sudoers or sudoers file we're not going to really go into that but there's ways of managing who can do what it's more of an administrative process or a specialty that i'm just not going to go into here but it's important to note specific users can have different permissions who is allowed to do what as the root user and elvis doesn't have any so i can't edit that file as elvis but again if i switch back to being cult i'll just get out of here with exit and i run that sudo nano blah blah blah i already entered my password so it remembers it there just to be clear but you will need to enter your password when you run sudo your particular user's password now you've probably actually come across this before when it comes to installing software or installing new commands there's a command called tldr i don't have it installed and if i try typing it my shell is going to tell me i don't know what you're talking about but here are some things you could try installing so there's a command called apt install and then the package tldr but if i just run that without sudo i'm not allowed to do that because i'm installing something that is not even just specific to my user here it actually is specific or not specific it would apply to all users on my machine i'm actually installing a program a command that everyone can use so i can't just go around doing that i need to have permission so that's why we run sudo do i have permission to install this well i already entered my password again so it knows who i am and what permissions i have to do as root user i can install it so i will continue and it will take a little while to install the the point of this is not to show you how to install things by the way it's just to show you another situation where you would need to use sudo so anytime you're trying to make changes you run into a permission denied error you'll often be prompted to try it again with sudo first so sudo itself we prefix in front of other commands and then it will prompt us for our password and now i have this tl dr command just show it to you on the man page for it here we are anyway uh it really doesn't matter it was just about using sudo so it really depends on who you're logged in as and what permissions you specifically have been granted and that is something that can be tweaked it can be really down to a pretty granular level i haven't changed anything it's just that some users have administrator permissions on here some of them don't now not all linux distributions will have the root account locked so you can't log into it directly some of them you can but even then we still have access to the sudo command and we can grant specific users different privileges as root it's also you know on my mac i cannot run things with sudo and i often need to if i'm installing something that is systemwide same idea the next command will cover is the password command which is actually pass wd i guess those extra two letters are too long and this is the command we can use to change someone's password so there's two ways of using it you can change your own password by just typing passwd so i'm logged in as called i don't really i mean i guess i'll change my password then i'll change it back so it's going to ask me for my current password so i have to know that and then it asked me for my new password and let's do uh well i'm not gonna tell you and then i have to confirm it again okay i updated my password and you can just trust that it worked i mean i how would you really know i guess i'm not going to tell you what it was before or now although none of them are actually real passwords anyway but it did change and if i were to log out i would need to use that new password so i'm just going to change it back one more time current password whoops i messed up i'm gonna do that again so my current password i just changed it to my new one okay now i can also change someone else's password uh assuming i have root permissions uh so let's say i need to change elvis password he's forgotten it there's actually a lot you can do you can lock someone's password you can if we just go to man pass wd you can do things like expire an account's password which would force them to change their password next time they log in but it doesn't actually give them a new password you can make an empty password to disable a password for an account there's a lot here um i'm just going to show the basics so i want to change elvis password pass wd elvis well i can't do that right as colts i need to do it as the root user or i guess as elvis uh but as the root user is probably more likely right why would elvis need to change his password from my account uh so if i have permissions i'm the administrator remember on ubuntu i can't log in as root so this is the closest thing i'm an admin i have permission to do this but i have to use sudo so sudo password elvis is now going to ask me for my password not elvises it's going to ask me for mine and it's going to just verify are you even allowed to do that as colt okay now it's asking me for elvis's new password so i'm just going to change it to how about hacked okay and one more time and now i just changed elvis password i guess you know i could show it to you quickly if i do an su elvis if i try and use elvis's old password which was something involving the word taco it doesn't work but now if i log in as elvis using hacked it does work and then as elvis i could change my password again using password and i don't need any fancy permissions you can change your own password all right so that's the basic use of password it is past wd there is more to it as i said you can lock someone's password you can delete it uh you can expire it and force them to set a new one when they log in but again it comes down to you can change your own password or if you have permission as the root user you can use sudo in order to change somebody else's password the next command we'll cover is one of my favorites to say out loud chon or town change ownership this is the command we can use to change who owns a particular file or directory so let's talk about what that means to own a file or directory um on every file every directory let me just go home here i'm logged in as colt who am i um when we do lsl we see a whole bunch of information we're going to talk more about what this is in just a little bit permissions and then this right here this third column is the owner of the entry so in this case the owner of this directory files exercise is me cold uh the owner of music is colt this is pretty normal to own all the stuff in your home directory but if i go to somebody else's directory if i have multiple users let's go to kitty's directory so this is her home directory kitty owns almost all of these files and folders and if i keep backing out further we've seen this before root the root user owns all of these directories and files so the chon command helps us change who owns those files and that's important to do because the owner of a file is allowed to change its permissions to delete it potentially to read or to write to that file it all has to do with what we see over here which we'll get into in just a little bit but for now i just want to show that we can change the owner and then we'll understand we'll try to understand its implications later on when we talk about another command all right so i'm going to go back home and the syntax to change the owner looks like this tone and then the owner that we want to add as the owner so a user and then the file that we're trying to change so um i'm going to go into elvis's directory or maybe it doesn't really matter here i'll go into kitties kitty all these files almost all of them are owned by kitty if i wanted to if i wanted to change the owner of how about kitty's music directory the syntax would be change owner chone and then me colt that's the user i'm trying to add as the owner and then after that music now there is a bit of a problem i can't just change somebody else's you know i can't just make myself the owner of somebody else's directory uh all over the place like that is something i have to have permission to do and we've recently learned that we can use the pseudo command to act as the root user so that is one option here is if i have root permissions i can change the owner of any files sudo tone cult music so it's going to ask me for my password and then i enter it and i don't see anything but that's a good sign that means that i did have permission to do that and now you can see cult is indeed the owner of this music directory now again we haven't really talked about what that means for me to be the owner but i'll just show you for example if i were to go into the desktop and try and create a file touch made by colt i don't have permission in that directory but if i go back out and i go into music if i touch a file touch made by colt i do have permission now because i am the owner as we saw i did lsl i own that folder music one commonly used flag with chone is uppercase r which we can use to recursively change the ownership of all the files and subdirectories nested in a directory so i have this directory i just made called cat stuff and it has some files inside of it and then a nested directory with some other files and if i decide i want to make the owner of cat stuff kitty and this is all kind of silly and you probably won't just make a directory in your home folder and then make someone else the owner at least not frequently but just for demo purposes if i make kitty another user on my computer if i make her the owner i can do chone kitty and then i need the name of that directory which is cat stuff and i do need to use sudo even though it's my own folder that might seem weird like you should be able to change who owns your own stuff the way linux is set up that is not the case you still need to have root permissions now you can change the permissions attributes we'll talk about very very shortly uh if you are the owner um but you can't change the actual owner of a file unless you have root permissions and i already typed my password a couple minutes ago or seconds ago so i don't have to redo it and if i do lsl we see where are you cat stuff kitty is the owner but if we cdn to cat stuff lsl i cult still own all the files and the nested directory so to change that we can just rerun that line the tone line but we use the dash uppercase r to recursively change the ownership and now if i go back into cat stuff kitty is indeed the owner of all the nested contents if we go into toys same thing there kitty is the owner of those files okay now another thing you may notice when i run lsl let me go to uh how about kitty's home folder so we'll go slash home slash kitty instead of here when i do lsl on any it doesn't matter where but in this directory ls lsl i see a bunch of folders and files there's an owner that we talked about that is a single user who is the owner of that file but then why does it say kitty again or here it says pals forever what is this second thing this is known as the group owner this is a little confusing but every file on a linux system has an owner and it has a group that owns it and that group can have multiple people's people users who are members of that group and then the group can get its own set of permissions so this means that um you know i could be the owner of this file and i might be able to read write delete whatever i want and then members of the pals forever group might be able to read only but they're not able to edit this file they're not able to write to it so this allows us to have two different levels of permissions the owner can have some set of permissions what are they allowed to do and then members of the group that is an owner the group owner they also can have a separate set of permissions and it's all encoded in these weird little digits that rwx and dash is here we will talk about that very soon but what i want to show you right now is that we can just change the group that owns a file using chone now this is something you probably won't do very much and i'm not diving into groups and managing groups and creating new groups and changing members who belongs to a group that's all more admin stuff anyway not daytoday user stuff at least in my experience and with my students but it's worth knowing that we can use the shown command to change the group owner so i have this group called pals forever i can actually there's a command called groups i can see all the groups that i the current user belongs to so here's all the groups we've got uh movie club pals forever let's say i want to change the group that owns music from kitty and this is also somewhat confusing by default the group is going to be a group with your username so it says kitty and kitty but this is the group owner this is the owner owner all right if i want to take this music directory and make pals forever the group owner the syntax looks like this where we have the owner name a colon and then the group that we want to add so here if i want to keep the owner as colt i need to do pseudo chone cult colon pals forever and then music is what i'm trying to change so this will be the owner and this is the group owner lsl and if we look at music that group has changed now again the idea behind groups is that we could have 10 different users who are part of this group and they might be able to read this directory only but then the owner can read and write and execute and do everything so we can have these different levels so it's not just one person who's allowed to do things for the file we can selectively change these groups and add people to the groups but that again is a more advanced admin thing we don't really need to worry about all right so the next thing we're going to talk about is understanding when i do lsl the very first chunk of really bizarre looking text these characters here we want to understand what these are what they mean because we're also going to learn a command that allows us to change these so what we're looking at right here is for every file every directory these are the permissions or the file attributes they detail what the owner is allowed to do can you read write or execute this file uh what the group members who are part of the group that owns this file can do read write and execute and what everyone else can do can the world at large any user read write or execute so there's a lot to break down there's actually 10 digits here not digits 10 characters and the first character actually i'm using some of my slides i've made for a course on udemy if you're interested in a lot more of a deep dive into linux commands because this is just hard to explain without graphics or some visuals so anyway that first letter is either going to be a dash so not a letter that indicates that it's a file a plain old regular file id indicates a directory so we can see that already here's a file dot txt it has a dash that's the first character here's a folder or a directory it has a d and then for sim links i think if i just back out a little bit here they'll start with an l so here's a sim link here we can see we also have that arrow pointing to you know where the link is linking to and it starts with an l so that's the first thing that's kind of just a oneoff then we have nine characters which is actually three sets of three the first group of three tells us the permissions for the owner of the file or directory the second group tells us the permissions for the group owner or for members in that group and then finally the third group tells us the permissions for everyone else the world at large any other user that's not the owner or that is not part of the group that owns the file or folder now within each group of three we'll just take the first one so for an owner those first three digits they tell us the read writes and execute permissions for this file can the owner read write or execute so those three characters in a very particular order the read permission is first then the right permission then the execute and then it starts over read write execute for the group owner or group members read write and execute for everyone else so what do these three permissions mean well if we have an r in that first spot right here there's an r here there's an r here there's an arm that means that the file can be read if it's a file or if it's a directory it means that the contents of that directory can be listed okay so here i have a single file i've created called onlycoltscanread.txt and we'll learn how you can change these permissions but i've already changed them the first thing we see here is a dash that means that it's a file then we have those first three digits which are the owner permissions now the owner is colt and there is an r present here which means that i have permission to read the owner whoever that is has permission to read the contents of this file and i can read it okay then we have the next three which is all just dashes which means none of those permissions are present so this is the group permissions anyone who's a member of this group well they don't have any permissions here and then everyone else they also don't have permissions so that r would be that character right there there is no r that means whenever we have a dash that the file is not readable or executable or writable depending on the location of where that dash is so here if there's a dash that means the owner couldn't read it but there is not a dash there's a r which means we do have read permissions so let me demonstrate this if i switch over i'm just going to log in as elvis if i can remember the password uh oh that's not it all right let's try that again oh wait i think i changed it to hacked didn't i i forgot about that there we go all right so i'm now elvis who am i if i do an lsl well i'm not cult i'm not part of this group uh so i'm considered anyone else i don't have read permissions there's just a dash there if i try and cat the file out permission denied only colt can read that file or only the owner which happens to be colt okay so this pattern holds true for all of these permissions if there's a dash in any of these spots it means that that respective if it's the world the group the owner does not have that permission so here we can see the owner does not have execute permissions the group does not have execute permissions everyone else does not have write or execute permissions now what those mean we'll dive into but for reading as we saw if there's an r there that means the file can be read and if there's an r on a directory that means that we can list the contents of that directory so this is why as elvis i can do ls or lsl or something on this directory it's actually going to zoom out further or move back one level if we look here this is each user's home folder so we've got carrot colts elvis and kitty each user has rwx that means read write and execute but then there's an r present for everyone else for that world right everyone can still read these directories that doesn't mean i can change them of course but this is why as elvis i can go into colts directories and and list lsl i have that permission because i have that r attribute right there in that third set so remember first three that's going to be the owner members of the group and then everyone else and i currently and part of that everyone else i'm able to read the contents here but uh through some editing magic uh i did just change the permissions on the permissions directory here if you notice now there is no r present we'll learn how to change that in a bit uh on this third grouping which means that anyone who is not the owner or part of this group cannot read the contents of this directory now it is a directory so what does that mean remember the r character means that you can list the contents of a directory if it's a directory or you can read the contents of a file if it's a file well i'm elvis still if i try an ls that permissions folder i can't i can ls any of the others i can ls music i can ls desktop but when i try permissions i can't do that because once again we no longer have an r present there but if i switch back to being cold now i'm cold we can see i can ls permissions no problem because we have an r in that first grouping which is the owner's permission so i can read all right so that's our first type of permission read permission if there's an r present here here or here that means that either the owner members of the group or everyone else can read next we have this second slot which is for write permissions so a dash means no write permissions a w means write permissions so for a file that means that we can modify the file and for a directory this means that the contents can be modified you could change files you could make a new file for example you could rename but this actually only takes effect if the executable attribute is also set which is that third piece here so let's just focus on files so if we have a w present that means we can write to a file so here we have ilovekitty.txt the owner is cult there's a w there right here's that first group or i shouldn't say group but the first chunk 123 for the owner i can write to that file uh i can echo into it let's just do echo meow into i love no i need uppercase l no problem i'm cold i can do that if i cat it out we see it has meow but now if i switch back to being elvis put elvis's new hacked password in there i am elvis here if i as elvis try and add to that file if i try and open it with nano if i try and echo something into it well elvis is not cult so these permissions don't apply not part of that group parallels so these don't apply but it doesn't matter anyway because it's the same as the permissions for everyone else what we see here is that everyone has read permissions but no write permissions so i cannot write to that file if i try to echo um i don't know hi from elvis into i love kitty permission denied i cannot write to that file but i can print it out or read the contents because once again we have that r right there so i'm elvis that r applies to me i'm not the owner i'm not part of this group we have read but no write permissions and then what about this third slot here so that third slot is either going to be an x or a dash if it's a dash it means no execute or executable permissions if it's an x that means we do have executable permissions so what does that mean well it's easier to understand in the context of directories if we have a directory you'll see actually there's a lot of x's on directories by default everyone has x executable permissions on folders all that means is that we can cd into a directory so it doesn't matter who i am right now let's take a look at the wildlife directory there's an x present for the owner group members and for everyone else so i'm currently elvis i can cd into wildlife no problem i'm in there now if i behind the scenes get rid of that x i'll do it right now there we go there is no x there anymore we're about to see how to do that i'm going to go back to being elvis if i try and cd into wildlife now cd into wildlife permission denied we don't have an x there and for elvis that means he can't execute you cannot cd into that directory now members of the group parallels in this case anyone who's in that group can and then the owner cult can cd as well because that's the owners execute the group members execute and then everyone else is execute so normally you'll have x present all over the place for directories but i just removed it here to show you the consequences i'll go back to being cult and i can cd into wildlife no problem now it's a little trickier to explain what it means when we have a file for files that have an x present here so if i were to show you a couple of examples like this right here these permissions means that an owner has read write and execute permissions for this file no one else has any access whatsoever what does that x mean on a file it means that the file can be treated as a program and can be executed so if you write your own scripts you write your own programs and you want them to become executable you need to have that x there so we're not going to see that right now but i'll show you some examples of things that are executables if we cd back a couple of times we go into bin what we see here if i do an lsl are lots of x is present but these are actually files so these are programs as you can see so there's a lot of programs here uh once again i'm in slash slash bin rather is my path name right now binaries this is where programs are stored so uh if you know here's touch for example that is a program that i can run obviously we use it all the time or if we find let's see is there another simple one in here here we go here is echo so our echo program that we run that command it's defined right here it's a file it has some code in there and as you see it's x x x that means we can execute it as a program we can actually run it okay so what i want to demonstrate is a little odd but there's a program called ncal it gives us a calendar uh i'm going to make it so i can't actually execute that and then i'm going to undo it but i'm not going to show you how just yet i'm just going to demonstrate so if i do an lsl on ncal in slash bin here it is we see the owner which is root members of the group which is also root and everyone else has that x present that means anyone can execute this i'm going to change that so i just did that now i do ls dash l on ncal again this program no longer has an x right there it did just a moment ago now this means that only the owner which is root i'm not root only members of the group root which i'm not a member of can execute everyone else does not have that x there no executable permissions on this file so now if i try and run ncal oh permission denied i can't run that script i cannot use that command anymore because it's not executable so that x is very very important uh and you probably wouldn't go around removing those but just to show you what the significance is so to reiterate if there's an x present for a directory that means you can cd into it but for a file that means you can execute it so i'm going to undo that we're going to learn this command that i used to do it it's called chamod change mode but now if i run that lslncal i have that x back and now i can run ncal again okay so now we're going to learn how to use this command to change those permissions i just want to run through one more time what these three things mean well there's ten things i guess the first is a dash for a file a d for a directory an l for sim link and then we have three groups of three each of these groupings has three places the first is either an r or a dash and r means read permission is present dash means no read permission w write permission a dash means no right permission and then the final slot is for execute x means it's executable no x a dash means you don't have that permission so the first three read write execute are for the owner of the file or folder the second three are for members of the group that owns that file or folder and then the final three are for everyone else so what does this mean a little quiz here uh what do these this exact set of attributes mean first of all are we talking about directory file sim link answer for your moment or think about it for a moment answer out loud if you'd like we are looking at a file and we can see the owner whoever that is has full permissions read write and execute members of the group owner have read writes but no execute permissions and everyone else only has read permissions okay so now let's talk about how we actually change these how do we use this weird chamod to mode however you want to pronounce it command it first of all stands for change mode and it is the tool it's the command we use to alter those permissions and here's the basic syntax there's actually two main ways of using chamod of specifying the permissions and the first i'm going to show you is the easier one when you're starting out so we have the command chamod change mode and then the mode meaning how we want to change the permissions who are we changing permissions for what are we changing read write execute and are we adding or removing that permission and then finally the file that we're trying to change so this is where it gets a little tricky the first thing we specify is the who we have these different letters u g o and a so u is how we can change the the file permissions for the user which is the owner of the group it's a little confusing because o is actually for others anyway if we have u that means we're changing permission for the user g is for members of the group o is for others and a is for all of those then we have a minus sign a plus sign or an equal sign so a minus sign will remove a permission a plus sign we'll add a permission we'll come back to equals and then finally the permission that we're trying to change read writer x execute so let me just show an example to make it a little clearer here if we have g plus w what we're saying here is four members of the group add so plus the right permission so here's what it looked like before for group r dash dash after we run this it's now r w dash so we added that w there but only for the group here's another example here we have that right permission for uh owner and for group we have an a and that means all so everyone all three of these chunks minus remove the w the right permission so we go from having right here and a right here to now having no right permission no right permission and no write permission so let's show an example why don't i go back to my home directory as colt and let's see i've got this permissions folder inside of it i have only colt coltscanread.txt why don't i change it so that how about everyone so all of us can read the contents of this file so it's not going to have a great name anymore it will still be only colt can read but that's not going to be true so this is what it looks like at the moment i'm going to run chamod change mode and then i'm going to say everyone so a all i want to add the read permission so add the read permission for everyone and then the file lsl we now see everybody has an r so this means as you know if i go back to being elvis i can read the contents of that file now whoops only why don't i see it here oh jeez because elvis does not have permission to do anything in this directory remember if we back out one level here we are this permissions directory we can see there is no read attribute present so elvis can even list the contents of that folder so why don't we add that r back in with what we know what i want to do is change mode and i'm going to switch back to being colt change mode and what i'm going to do is change it for other so that's what the o if i go back here o means the world or others anybody who's not the owner or part of the group so here's permissions here everyone already has an r group the actual owner but i want to add this r back in so i'm going to say for others plus r add the read attributes for the permissions folder oh i'm in the permissions folder oh come on i gotta back out okay let's try that again for others add the read permission to the permissions directory here it is right now i'm gonna hit enter lsl and now what do we see on permissions there is an r present that means if i go back to being elvis i can now cd into permissions and finally i can read the contents of only colt can read because now we have permission to read both that file and the parent directory now go back to being colts and what i'm going to do next is show let's see how to revoke permission so we use the minus sign so i'll revoke let's go back to um well let's go back into permissions here's that one file i'm going to revoke the read permission for everyone except for me so i'm going to do that here so i'm going to do change mode why don't i revoke it for the group first to show that so i'm going to say group g minus r for the group members of the group remove or revoke the read permission on only cult can read and now you'll see there's no r present here i could do the same thing but remove it for others lsl we can see it's now gone now i can also do multiple at once so if i did this o minus rwx this means others remove read write and execute permissions so if i want to add how about full permissions read write and execute for everyone i could do chamod and then for everyone all i want to add read write execute on only can read and there we are our wx our wx rwx so it's now executable it's showing up differently it isn't actually going to do anything if i execute it because well it's not a script just a text file but anyway that's kind of the basics if i wanted to remove execute permissions for everyone you know i could do jamaad all minus x and now we we have rw dash rw dash rw dash so that's a quick intro to using chamod with this syntax now there's actually another syntax that we can use that is quite a bit more intimidating when you're starting out and i'm just going to alert you to his existence we can use octal notation which is base eight for these three digits of binary correspond to a file mode so zero zero zero is going to be dash dash dash one one one is rwx one zero zero is r dash dash so that's the binary here but each one of those in base eight is a single digit zero through seven it can be a little complicated to understand but as you can see here if you saw chamod seven five five what that tells us is for that first chunk seven is one one one meaning rwx five is one oh one right it's binary uh three binary digits is a single octal digit anyway our r dash x is what we end up with there i know it's kind of confusing it really is trust me if i have to teach this uh but there are some modes that are more common and you'll get used to them if you encounter them but you can always use the longer sort of englishy syntax that looks like this you know with the letters and plus or minus rather than having to worry about base 8 craziness but that is something you'll see now what about the equal sign i said i'd come back to this the equal sign is basically a way of saying in this example a equals r set for all set it to be only read permissions and nothing else so it it's going to reset every other value so let's see an example of this in action we just have this only can read file which is actually not accurate but if i do want to make let's say i want to i don't know i'm grasping at straws here uh i'll make it so everyone can read and only read so no write permissions no execute what i can do is jamaad everybody all now instead of doing plus read or minus w because minus w would subtract right except get rid of that get rid of that but if i do equals read what this says is that the only permissions that we're having ignore everything else and get rid of them is read for everyone for all so lsl and there we go everyone can read but nothing else if i instead if i just did a equals i can also do multiple like rw or rwx that's a long way but i can give everybody permissions and then if i went back and reran this so that it's equals r again that means only read get rid of everything else so we'll go from rwx rwx rwx to instead rr and just dashes for the read and write permissions all right so i know this is a pretty complicated topic uh there's a lot to cha mod not to mention just pronouncing it oh i guess i did not show we can also change permissions for multiple who at whose at one time so if i wanted to add write permissions only for the owner and the group owner i could do this chamod so the owner is you the group owner is g and then plus w for right and now we can see the owner and the group owner has that w there so we can have multiple values on the left hand side of that whatever plus minus equals and then again we have the octal notation which you'll see um you know 777 means rwx for everyone full permissions uh and you can spend more time learning this if you really care about it it is something you'll see in the wild but for now all i care about is that you understand the basic concept of these permissions and all these different different letters here rwx and dashes what does that mean what is the significance and then remember if we go back we talked about the owner and how we can change a file's owner using tone we can also use it to change the group that owns a file and then we can change individual attributes using chamod change mode that's a lot well we made it to the end we covered a ton of different commands maybe it's a little bit overwhelming maybe you're a little tired of seeing all the scrolling text go by but remember the point of all this is not to memorize and just become an expert on every single command overnight what really matters is being able to put the different pieces together to use the correct command when you need it read the man pages figure out how something works change what options you're using and just kind of duct tape it together when needed obviously some of these commands become second nature lscd touch make directory rm that sort of thing you get pretty comfortable using different expansions and redirection and piping and combining different commands but then some of these more niche commands certainly i wouldn't expect you to just remember and and honestly in preparing this sort of course i always have to look at the man pages and remind myself of all the different options and how they work so thanks again for joining me and remember if you are interested in my bootcamp you can find the link in the description and lastly thanks again to flavio for the excellent handbook all right well it was nice uh i guess recording this in a dark room and editing it in an equally dark room uploading it to youtube and being alone in this whole process but honestly who needs friends or companionship when you have the most sensual command man touch that's really all i need okay i gotta go get my cat to the vet
