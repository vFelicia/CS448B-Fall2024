With timestamps:

00:00 - hey there in this video we're going to
00:02 - build a command line chat application
00:05 - my name's alex and i normally run a
00:07 - youtube channel called codecast you can
00:09 - find a link around here somewhere the
00:12 - other day my friend hugo and i we built
00:14 - a little command line chat application
00:17 - and wrote about it over on medium and i
00:19 - thought it would be a really pleasant
00:21 - casual project to teach you how to build
00:24 - step by step here on the free code camp
00:26 - youtube channel
00:28 - in terms of prerequisites or what you
00:30 - need to know already it would be good if
00:32 - you had some basic javascript and
00:34 - node.js knowledge already but you might
00:36 - benefit from seeing some things you
00:38 - haven't learned yet so i'll leave that
00:40 - up to you
00:41 - a big component of our app will be a
00:43 - tool that i'm helping to build over here
00:45 - at pusher called chat kits
00:48 - chat kit in a nutshell it's a hosted api
00:51 - that makes it easier to build chat
00:53 - functionality into our applications
00:56 - functionality like real-time messaging
00:58 - typing indicators read indicators which
01:01 - in turn we can use to power unread
01:03 - message counts and read receipts that
01:05 - kind of thing you might get the idea and
01:08 - if you don't it's okay one of the best
01:10 - ways to learn is by doing so on that
01:13 - note let's jump in and create a chat kit
01:15 - account
01:16 - to do that head over to pusher.com chat
01:20 - kit and hit sign up
01:22 - i already have an account so i'll click
01:24 - sign in instead and log into my existing
01:26 - account
01:27 - from here we can create a new chat kit
01:29 - instance by clicking on create new i'm
01:32 - going to call mine command line chat
01:37 - and for now that's all we're going to do
01:38 - in the dashboard we'll be coming back
01:40 - here in a second to make some updates
01:42 - but for the time being i'm going to
01:43 - switch back to the terminal and make a
01:45 - new directory called command line chat
01:48 - tutorial and run npm init dash y to
01:51 - initialize my package.json file
01:55 - the first thing we'll want to do for
01:56 - this project is create a chat kit
01:59 - authentication server which sounds
02:02 - complicated and it really isn't
02:05 - in fact it's something that's so common
02:06 - when you use chat kit i've created a
02:08 - little snippet here that we can copy and
02:10 - paste to kickstart this project so head
02:12 - over to the description to find this
02:14 - link copy and paste it real quick and in
02:16 - a new file called server.js
02:19 - we can paste it
02:21 - at the top here you can see we import
02:23 - some third-party npm modules which we'll
02:26 - need to install so let's quickly install
02:29 - express
02:31 - the express body parts middleware which
02:34 - allows our server to pass request bodies
02:36 - to get their data
02:38 - because express middleware which can
02:40 - enable cross-origin resource sharing and
02:43 - of course we'll need to push a chat kit
02:45 - server
02:46 - node or client sdk
02:48 - as well speaking of which if we scroll a
02:51 - little bit below the imports you can see
02:54 - that we instantiate the chat kit server
02:56 - sdk and as we do so we pass down an
02:59 - instance locator and a secret key both
03:02 - of which you can access from the chat
03:04 - kit dashboard so head over there and
03:06 - under the keys tab copy your unique
03:09 - instance locator and paste it in place
03:11 - of the placeholder you'll also want to
03:13 - grab the secret key and replace the
03:16 - placeholder with that as well
03:18 - i won't explain this file in too much
03:20 - depth but we basically
03:22 - set up that middleware we installed and
03:24 - then creates a route called slash users
03:26 - which in a nutshell accepts a username
03:29 - and then creates a chat kit user with
03:32 - that username if a user with that
03:34 - username does not already exist if a
03:37 - user with that username already exists
03:40 - it basically does nothing it just
03:42 - returns a successful response to the
03:44 - client in a real world application
03:46 - obviously two users with the same id or
03:49 - username can't exist at the same time
03:51 - and so the logic would likely be
03:53 - different but for our fairly simple
03:55 - application this is good enough
03:57 - similarly down here we create an
03:59 - authenticate endpoint which is a little
04:02 - bit contrived as well the authenticate
04:04 - endpoint is your opportunity to validate
04:07 - that a user is who they say they are
04:10 - however in this particular case we're
04:12 - not really going to authenticate users
04:14 - we're not going to ask them for a
04:15 - password or anything like that so this
04:17 - function is fairly like i say contrived
04:20 - it simply returns a token no matter what
04:23 - and that's okay for the purposes of this
04:25 - application
04:26 - at the very bottom we obviously set up
04:28 - the
04:29 - server as well make sure it's running
04:32 - and that's pretty much it for the server
04:34 - application we could run it now but
04:36 - there wouldn't be much to see we'll come
04:38 - back and run it later when it's more
04:39 - useful
04:41 - next let's create a new file called
04:43 - client.js and in here i'm going to start
04:45 - by creating a new function called main
04:48 - and this is going to be an async
04:50 - function that we pretty much call
04:52 - immediately and the reason why we do
04:53 - this is so that we can use the await
04:55 - keyword within the main function
04:58 - if you're not too comfortable with the
05:00 - async and away keywords then i highly
05:03 - recommend this talk by westboss over
05:05 - here on the free code camp youtube
05:07 - channel
05:08 - now the first thing we'll want to do
05:10 - when the user runs our application is
05:13 - ask them for their username we'll
05:15 - subsequently use this username to create
05:17 - a chat kit user via the server we just
05:20 - created
05:22 - now to ask the user for their username
05:24 - i'm going to use an npm module called
05:27 - prompt now the way prompt works simply
05:29 - is that you install it and import it
05:31 - just like you would most npm modules you
05:34 - call a function called start to
05:35 - initialize the module and then most
05:37 - interaction happens via this get
05:39 - function to which you firstly pass some
05:41 - options we'll explore this in more
05:43 - detail in a second as well as typically
05:46 - a callback function which is called when
05:48 - the user successfully or erroneously
05:51 - enters an input
05:53 - we might tweak this a little bit to use
05:55 - promises but let's start off with the
05:56 - basics by installing prompt so if i head
05:59 - over to the terminal and quickly run npm
06:02 - install
06:03 - save prompt
06:08 - and then just like we saw in the npm
06:10 - docs we can write prompt.start
06:13 - and whereas we would normally call
06:15 - prompt.get
06:17 - what i'm going to do is import another
06:19 - module
06:20 - called utel
06:25 - i'm going to create a new function
06:26 - called get i'm going to set it equal to
06:28 - you tell the promisify
06:34 - prompt.get now instead of calling
06:37 - prompt.get which takes a callback
06:39 - function we're going to call get this
06:41 - local variable instead which is equal to
06:44 - a function that returns a promise now
06:46 - which is going to enable us to use get
06:48 - with the await keyword
06:50 - like this
06:53 - like i skimmed over earlier the get
06:55 - function takes an options argument
06:57 - really this is a schema which is quite
06:59 - an overloaded term in programming but
07:01 - basically it's an outline of what we
07:03 - expect from the user
07:05 - this will be the username schema
07:08 - the description is basically what you
07:10 - want to present to the user so we'll say
07:11 - enter your username and then we specify
07:14 - the name by which we want to reference
07:16 - the user's input later so i'll write
07:18 - username
07:19 - then it's really just the case of
07:21 - creating a result variable and awaiting
07:24 - the results of get username schema on
07:27 - this result we can access the username
07:29 - which is basically
07:31 - the name that we supplied above right in
07:34 - fact we can do this in one step just by
07:35 - using object restructuring like this and
07:38 - just to make sure everything is working
07:39 - nice and fine let's log out the username
07:42 - to the console
07:44 - as you can see when we run the client it
07:46 - asks us for our username i write booker
07:49 - and booker is written to the console one
07:51 - thing i don't really like is this like
07:53 - prompt text at the beginning of my
07:55 - description the way to disable that
07:57 - really simply is to set prompt.message i
08:01 - think equal to an empty string
08:03 - yeah and now you can see when we run
08:04 - that we don't have that black prompt
08:07 - text
08:08 - never mind this error i just killed the
08:10 - application
08:11 - in fact yes come to think of it we
08:14 - should probably wrap
08:15 - most of this function inside of a try
08:17 - catch block if an error happens we'll
08:19 - write it to the console and call
08:21 - process.acce with the status code one
08:27 - this will just make things a little bit
08:28 - easier to debug if things go wrong this
08:31 - is also a good time to mention but you
08:32 - might notice at times that when i write
08:34 - my code it's kind of indented all over
08:36 - the place or maybe it's not as optimal
08:38 - as it could be for example i have
08:40 - superfluous parentheses or something
08:43 - like that yet when i save my file
08:45 - everything gets nice and tidy that's
08:47 - thanks to a javascript tool called
08:49 - prettier which i have integrated in my
08:50 - editor super cool tool check it out if
08:53 - you haven't heard of it already
08:56 - but yeah now we have this username down
08:59 - here we're going to want to send it to
09:01 - the server where we can create a chat
09:03 - kit user and to do that i'm going to use
09:05 - a third-party mod module called axios
09:12 - so let's bring an axios real quick and
09:14 - i'll create a separate function called
09:16 - create user that takes a username it's
09:19 - going to be in a sync function and then
09:21 - we're going to send a post request using
09:22 - axios to http localhost port 3001 i
09:27 - think i'll double check in a second
09:29 - slash users and then we'll specify the
09:31 - body to be equal to the username and
09:34 - again we should probably wrap this in a
09:35 - try catch block just in case something
09:38 - goes wrong
09:41 - let me quickly check server.js for the
09:43 - port number
09:44 - as you can see it's 3001 perfect
09:47 - um
09:48 - so but down here instead of printing the
09:50 - user to the console we can write create
09:54 - user
09:55 - and we'll actually need to await that
09:56 - result right there
10:00 - let's test this out real quick so let me
10:02 - create another splits here where i'll
10:03 - run the server remember i said it wasn't
10:05 - really useful to run before but now it
10:08 - is
10:09 - if i run the application and i enter the
10:11 - username booker we should see in the
10:13 - server output and we do that a user
10:15 - called booker was created if i run the
10:17 - client again and i try and
10:20 - essentially log in as booker again now
10:22 - the user already exists we see that
10:24 - written to the server as well pretty
10:26 - cool right
10:29 - you know else is pretty cool
10:31 - connecting to chat kits while i'm here
10:33 - i'm going to install
10:35 - the pusher chat kit
10:37 - client
10:38 - sdk
10:40 - the reason why i say it so slowly is
10:42 - because it's important to realize that
10:44 - earlier we installed the server chat kit
10:46 - sdk and now we're installing the client
10:49 - chat kit sdk often these would happen in
10:51 - different projects but because we're
10:53 - kind of condensing them it might seem a
10:55 - bit confusing
10:56 - at the top here we can import chat kit
10:59 - in fact specifically we're going to want
11:01 - to bring in the chat kit chat manager
11:03 - and the chat kit token provider
11:08 - and then down here just beneath the call
11:10 - to create user i'm going to initialize
11:13 - chat kit
11:14 - or more specifically the chat kit chat
11:16 - manager i have a handy little snippet
11:18 - for this because i do it quite often the
11:20 - first thing you need to do when
11:22 - initializing the chat manager is specify
11:24 - your instance locator now this is the
11:26 - same instance locator we copied earlier
11:29 - from the dashboard so let's copy it
11:31 - again or copy it from your server file
11:33 - it's the exact same the user id in our
11:35 - case is going to be equal to the user's
11:37 - username this can be a string or a
11:40 - number in our case it makes sense to use
11:42 - the username because that's all we
11:43 - really have and just like we specified
11:45 - the user's endpoint up here down here we
11:49 - need to specify the authenticate
11:51 - endpoint so let's do that now localhost
11:53 - port 3001 slash authenticates
11:59 - in that same snippet i call chat
12:02 - manager.connect and assign the result to
12:04 - a variable or a constant sorry called
12:07 - currentuser now this represents the
12:09 - current user we should be able to come
12:11 - here and print the current user to the
12:13 - console and we can poke around
12:15 - to see what is available on that current
12:17 - user
12:18 - spoiler most interactions with chat kit
12:20 - happen on this current user for example
12:22 - we'll call current user dot send message
12:24 - and so on but actually i can tell you
12:26 - right away that this is not going to
12:28 - work if we run this application now it
12:30 - would blow up and the simple reason is
12:33 - that the chat kit client sdk this module
12:36 - we import up here doesn't work with
12:38 - nodejs out of the box
12:41 - like i mentioned at the beginning of
12:43 - this tutorial i work on the chat kit
12:45 - team and when we started building this
12:47 - client sdk it was mainly built against
12:50 - the web browser which means internally
12:52 - it uses some functions which exist in
12:54 - the web browser but not in node.js so to
12:58 - use the chat kit client in node.js we
13:00 - basically need to
13:02 - for lack of a better word trick chat kit
13:05 - into thinking it's working in the
13:06 - browser
13:09 - to do this we can use an npm module
13:11 - called js dom which we'll need to import
13:20 - and then we'll create a function called
13:21 - make chat kit node compatible this is a
13:25 - snippet i defined for the sake of this
13:27 - screencast because otherwise i wouldn't
13:29 - have remembered the details what it
13:30 - really boils down to is creating this
13:32 - global.window property that chat kit
13:35 - needs internally we'll need to make sure
13:37 - to call this function
13:39 - and then once that's all set up we
13:41 - should i think be able to connect to
13:43 - chat kit and view our current user so
13:46 - let's run the server so we have
13:48 - something to connect to
13:49 - once that's running we'll run the client
13:51 - and connect as booker and see what
13:52 - happens
13:56 - as you can see once we connect we get i
13:58 - mean this input's hard to read obviously
13:59 - it's a lot of tax and a pretty big font
14:01 - and you can get an idea of the kind of
14:03 - functions and properties available on
14:05 - this current user we won't spend too
14:07 - much time looking at it actually because
14:09 - it's quite hard to discern the useful
14:11 - stuff from the uh sort of prototype
14:13 - output and stuff but you can see for
14:14 - example we have like the user's name
14:16 - here so we can access the current user's
14:18 - name by writing currentuser.name and so
14:21 - on you know we'll see this all in action
14:23 - soon enough
14:25 - let's allow the user to choose a room to
14:28 - join and the way we'll do this firstly
14:30 - is by creating a variable called
14:33 - joinable
14:34 - rooms and we're going to set this equal
14:36 - to the result of current user dot get
14:39 - joinable rooms
14:40 - then we'll create a variable beneath it
14:42 - called available rooms i'll explain the
14:45 - distinction in a second but in a
14:47 - nutshell we take the current user.rooms
14:50 - property and the joinable rooms constant
14:52 - we just defined and we merge these two
14:54 - arrays now what's happening here because
14:56 - it seems like we're conflating two ideas
15:00 - um i say that we're going to allow our
15:01 - user to join a room but then we have two
15:03 - concepts joinable and available rooms
15:06 - well in chat kit basically you have this
15:08 - concept of a joinable room it's a room
15:10 - that jacket user is eligible to join
15:12 - they have permission to do so and the
15:14 - room exists but they haven't yet joined
15:16 - once they join that room it's said that
15:18 - the uh
15:20 - user belongs to that room and so you can
15:22 - access an array of all the rooms that a
15:24 - user belongs to um
15:26 - viver's current user.room's property
15:29 - now there's a difference between how you
15:31 - represent this in our code and how we
15:32 - present it to the user the way we'll
15:34 - present it to the user is that all rooms
15:36 - are joinable even if the user has
15:39 - already joined the room this might sound
15:40 - complicated so it might be a bit easier
15:42 - to see in action once we have this
15:44 - available rooms property what we'll do
15:46 - is we'll write them all to the console
15:48 - so write available room stop for reach
15:50 - we'll take the um room and we'll take
15:52 - the index
15:54 - and we'll print that to the console
15:57 - uh so we'll print out the uh
15:59 - index and then we'll print out the room
16:03 - name
16:04 - you know if we run this right now we
16:05 - wouldn't actually see anything because
16:07 - we haven't created any chat kit rooms we
16:09 - have to do that ourselves and there are
16:11 - two ways of approaching this
16:13 - we can either create rooms
16:14 - programmatically using one of the sdks
16:17 - and this is the recommended way and in
16:19 - any real application this is likely the
16:21 - only way for example imagine you're
16:23 - building an application similar to slack
16:26 - or similar to
16:28 - messenger when someone creates a new
16:30 - group you know you're going to need to
16:32 - write some code that creates that group
16:33 - dynamically invites members dynamically
16:35 - all that kind of stuff because we kind
16:37 - of know our parameters here because this
16:39 - is a tutorial we're going to use the
16:41 - second approach which is to use the chat
16:43 - kit dashboard and more specifically the
16:46 - jacket dashboard inspector inspect your
16:48 - inspector here we can create an admin
16:51 - user and then create a room i'll call
16:53 - mine general
16:54 - in fact i'll create two i'll create one
16:56 - called general and i'll create one
16:57 - called free code camp which can be a
17:00 - chat room that people can come to to
17:02 - talk about free code camp now we have
17:04 - those two rooms i would expect that if i
17:06 - run the server
17:08 - and if i run the client and connect it
17:10 - as booker we should be shown a list of
17:12 - available rooms and
17:14 - we probably are we are actually but this
17:17 - is a bit
17:18 - this is a bit broken and let's debug
17:20 - this together first of all the output's
17:22 - a bit messed up because we're still
17:23 - printing out the current user let's fix
17:26 - that the second problem i think is that
17:30 - we
17:31 - see the room index zero and it says it's
17:33 - undefined and i'm trying to think why
17:35 - that is
17:36 - um
17:40 - oh i know why it's because in addition
17:42 - to um
17:44 - destructuring the current use of the
17:46 - room's property will also need to
17:47 - destructure the joinable rooms
17:51 - constant
17:52 - and if you're not familiar with
17:53 - destructuring i should have mentioned
17:54 - this earlier i'm going to make sure to
17:56 - link a tutorial in the description it
17:58 - might be a confusing concept as i even
18:00 - myself got confused just then apparently
18:02 - um
18:04 - but in a nutshell enables you to join a
18:06 - raise let's try this again hopefully now
18:08 - we see a cleaner input and the expected
18:10 - input no
18:12 - less as you can see we have the option
18:15 - to join the general room or the free
18:17 - code camp room next let's prompt the
18:19 - user to choose one of those rooms and so
18:22 - let me just bring this up a little bit
18:23 - and then we'll create another schema
18:25 - this time we'll call this
18:27 - room schema
18:30 - the description is going to be select a
18:32 - room and we'll call this um input
18:37 - chosen room
18:39 - we'll come down here and type kant's
18:41 - chosen
18:42 - room equals a weight get this is the
18:45 - same get function we defined earlier
18:47 - remember this guy
18:50 - and then we'll pass in the room schema
18:53 - once we have that we can actually pull
18:55 - down the room using the index which is
18:58 - essentially what the user supplied right
18:59 - they enter the number zero or one in
19:01 - this case that will correspond to an
19:03 - index in the array in that available
19:06 - rooms array that i'm highlighting right
19:08 - now
19:08 - and and so we can write available rooms
19:13 - chosen room
19:15 - and then it's time to subscribe to that
19:17 - room
19:18 - i have a snippet which can help me do
19:20 - this called subscribe or sub because i'm
19:23 - lazy and i do this a lot the room id is
19:25 - going to be equal to room.id in fact let
19:28 - me take a step back here
19:30 - this subscribe to room function takes a
19:32 - few different options firstly it takes
19:34 - the room id namely the room to subscribe
19:37 - to in this case it's going to be
19:38 - whichever room the user selects
19:41 - then we have the opportunity to specify
19:43 - some hooks the idea of hooks might be
19:45 - familiar to you but it might be more
19:47 - easy to understand if you think about
19:49 - them as events and event handlers for
19:51 - instance whenever a new message is sent
19:53 - in our chat room this on new message
19:56 - function is going to be called this
19:58 - function is going to be called when the
19:59 - current user sends a message that
20:01 - happens in real time which is fairly
20:03 - unimpressive right calling a function on
20:05 - the same
20:06 - client that caused that function to be
20:08 - executed but the place where chat kit
20:10 - really comes in here is that if we
20:11 - distribute this chat application to a
20:14 - bunch of our friends or a bunch of users
20:16 - as they send messages in the same room
20:18 - this all new message function is going
20:19 - to get executed in real time with their
20:22 - messages here we can write the messages
20:24 - to the console
20:26 - we'll want to include the uh
20:30 - message
20:31 - dot
20:32 - sender id which is essentially their
20:34 - username in our case as well as the
20:36 - message text itself and actually we're
20:39 - only going to print this message if the
20:41 - message dot sender id is not equal to
20:45 - our username because if we're the person
20:48 - who sent the message we don't need that
20:50 - to be relayed to ourselves because we're
20:52 - going to see it in the terminal input
20:53 - anyway there's no need obviously to
20:55 - notify the current user but they sent a
20:57 - message of course they know
21:00 - this is tricky to demonstrate because
21:02 - whilst we can subscribe to messages we
21:04 - can't actually send messages yet let's
21:07 - do that now
21:08 - we'll want to capture the user input
21:10 - repeatedly right so we'll want the user
21:12 - to be able to send one message and then
21:13 - another and so on now we could probably
21:16 - adapt the prompt npm module to do this
21:20 - but there's actually a much more
21:21 - suitable module called redline which
21:23 - i'll install now
21:28 - so i'll write npm install dash save
21:31 - redline
21:33 - actually i did notice this when i
21:35 - started recording this screencast but it
21:37 - seems like in note 10 there's another
21:39 - module called line by line that might be
21:42 - a bit more suitable i'll leave that up
21:43 - to you to look into i'm going to use
21:45 - reline because it's what i know and what
21:48 - i know about redline is that you need to
21:50 - import it
21:51 - well i know more than that that's pretty
21:53 - pretty obvious i would say but yeah
21:55 - we'll import redline
21:59 - and then down here beneath our call to
22:02 - subscribe to a room we're going to want
22:04 - to create a constant called inputs that
22:07 - we're going to set equal to redline dot
22:09 - create interface and we call create
22:11 - interface we specify an input option
22:14 - which is going to be equal to
22:15 - process.stdn
22:18 - stdn is like a fancy word for the
22:20 - terminal input basically
22:22 - we often refer to the output as std out
22:24 - as well which you might find interesting
22:26 - if you didn't know already
22:28 - then we can call input.on
22:31 - line
22:32 - and then we'll create an async callback
22:33 - function which gives us that line or
22:35 - that text basically
22:38 - and from here we can write current user
22:41 - dot send message when we call send
22:43 - message we need to specify the room that
22:45 - we're sending that message to all
22:47 - messages have to be sent to a room so
22:49 - that'll be equal to room.id and then the
22:51 - message itself which is going to be
22:53 - equal to the text property
23:03 - that looks good
23:05 - let's test this out i think this should
23:07 - pretty much work how we expect and as
23:10 - ever i'll run the server then connect
23:12 - with the client in fact you know what
23:14 - you know what let's create a new
23:17 - window here
23:19 - first we'll run the server
23:21 - then we'll run one client
23:23 - and then we'll run another client
23:25 - so when this first client will say my
23:27 - name is booker and this client i'll say
23:29 - my name is hugo hugo co-wrote the
23:31 - tutorial with me awesome dude
23:35 - and we'll both join the free code camp
23:36 - channel so i'll join the free code cam
23:38 - channel and then i'll join the free code
23:40 - camp channel for hugo
23:42 - and then
23:43 - to be honest as i'm doing this now it
23:45 - would be nice to have some indication as
23:47 - to when we've connected right now it
23:48 - just feels a bit laggy
23:50 - but if i write hello we should see in
23:52 - the other console on the right there
23:54 - the book has said hello
23:56 - and we don't which is really sad
24:00 - let's figure out why
24:04 - so we get an error here which says
24:06 - expected room id to be of type number
24:08 - but was of type undefined
24:11 - and that's quite strange
24:14 - because i really don't see why room
24:17 - would be undefined here which line did
24:19 - that happen on
24:21 - line 85
24:24 - so yeah right here
24:26 - um
24:30 - ah so what i'm doing is i'm looking up
24:32 - here
24:33 - where i access room.id and
24:36 - i'm sure this worked and so room.id
24:38 - can't be undefined that wouldn't make
24:39 - sense to me anyway but i'm looking at
24:41 - the wrong side of the assignment what
24:43 - i'm actually doing here is assigning a
24:45 - property called room id
24:47 - and down
24:49 - here
24:50 - i'm assigning it to a property called
24:51 - room and what i'm meant to write is room
24:53 - id
24:54 - let's save that and try again so let's
24:56 - just kill these clients real quick and
24:59 - rerun them
25:00 - i'll connect this booker then as a new
25:03 - user let's call that new user bob
25:06 - we'll both join the free code camp room
25:10 - and here i can write hello and as i
25:12 - write hello we should see that in the
25:14 - other window booker said hello bob can
25:17 - then say hi back and we can see in the
25:19 - other window that bob said hi you know
25:22 - obviously these two clients are running
25:24 - side by side on the same machine in the
25:26 - same terminal but we could equally send
25:29 - this file to a friend you know hugo
25:31 - lives in australia i live in london we
25:33 - can both communicate on completely
25:35 - different machines across the ocean um
25:38 - such as the internet which isn't that
25:40 - impressive but i just want to
25:41 - re-emphasize that even though this is
25:43 - happening locally it would also work
25:45 - remotely
25:47 - but yeah that pretty much wraps up the
25:49 - tutorial in summary we built a chat
25:52 - application where we can create users
25:55 - create rooms join rooms then send and
25:57 - receive messages there's so much more we
26:00 - could do to this application if we had
26:02 - time from both a chat perspective and a
26:04 - terminal perspective right so we're
26:06 - barely touching the surface of what chat
26:08 - kit can do we're barely touching the
26:10 - surface of what you can build in the
26:11 - terminal one cool idea hugo and i had
26:14 - was if we could list a
26:16 - list of online users as well as users
26:19 - who have joined the chat previously but
26:21 - aren't online that'd be such a cool
26:23 - terminal interface and it would use a
26:25 - feature of chat kit called chat kit
26:27 - presence basically we could even show
26:29 - typing indicators and read receipts so
26:31 - many cool things but like i say we need
26:33 - to
26:34 - give it a rest for now if you'd be
26:36 - interested to learn more if you want to
26:38 - see a continuation of this application
26:40 - of part two if you will please let us
26:42 - know in the youtube comments or in the
26:43 - comments over on medium you might also
26:46 - want to check out the medium post
26:47 - because in addition to what you've just
26:49 - seen me build right here we also outline
26:51 - how to add a loading spinner to your
26:53 - application which is a really nifty way
26:55 - to make your application feel faster um
26:58 - as well just as well just for a bit of
26:59 - fun right
27:00 - but yeah thank you so much for watching
27:02 - please do make sure to subscribe both to
27:04 - the free code camp youtube channel as
27:06 - well as myself over on the codecast
27:08 - youtube channel you can also follow
27:10 - myself on twitter
27:11 - i'm at booker codes thank you

Cleaned transcript:

hey there in this video we're going to build a command line chat application my name's alex and i normally run a youtube channel called codecast you can find a link around here somewhere the other day my friend hugo and i we built a little command line chat application and wrote about it over on medium and i thought it would be a really pleasant casual project to teach you how to build step by step here on the free code camp youtube channel in terms of prerequisites or what you need to know already it would be good if you had some basic javascript and node.js knowledge already but you might benefit from seeing some things you haven't learned yet so i'll leave that up to you a big component of our app will be a tool that i'm helping to build over here at pusher called chat kits chat kit in a nutshell it's a hosted api that makes it easier to build chat functionality into our applications functionality like realtime messaging typing indicators read indicators which in turn we can use to power unread message counts and read receipts that kind of thing you might get the idea and if you don't it's okay one of the best ways to learn is by doing so on that note let's jump in and create a chat kit account to do that head over to pusher.com chat kit and hit sign up i already have an account so i'll click sign in instead and log into my existing account from here we can create a new chat kit instance by clicking on create new i'm going to call mine command line chat and for now that's all we're going to do in the dashboard we'll be coming back here in a second to make some updates but for the time being i'm going to switch back to the terminal and make a new directory called command line chat tutorial and run npm init dash y to initialize my package.json file the first thing we'll want to do for this project is create a chat kit authentication server which sounds complicated and it really isn't in fact it's something that's so common when you use chat kit i've created a little snippet here that we can copy and paste to kickstart this project so head over to the description to find this link copy and paste it real quick and in a new file called server.js we can paste it at the top here you can see we import some thirdparty npm modules which we'll need to install so let's quickly install express the express body parts middleware which allows our server to pass request bodies to get their data because express middleware which can enable crossorigin resource sharing and of course we'll need to push a chat kit server node or client sdk as well speaking of which if we scroll a little bit below the imports you can see that we instantiate the chat kit server sdk and as we do so we pass down an instance locator and a secret key both of which you can access from the chat kit dashboard so head over there and under the keys tab copy your unique instance locator and paste it in place of the placeholder you'll also want to grab the secret key and replace the placeholder with that as well i won't explain this file in too much depth but we basically set up that middleware we installed and then creates a route called slash users which in a nutshell accepts a username and then creates a chat kit user with that username if a user with that username does not already exist if a user with that username already exists it basically does nothing it just returns a successful response to the client in a real world application obviously two users with the same id or username can't exist at the same time and so the logic would likely be different but for our fairly simple application this is good enough similarly down here we create an authenticate endpoint which is a little bit contrived as well the authenticate endpoint is your opportunity to validate that a user is who they say they are however in this particular case we're not really going to authenticate users we're not going to ask them for a password or anything like that so this function is fairly like i say contrived it simply returns a token no matter what and that's okay for the purposes of this application at the very bottom we obviously set up the server as well make sure it's running and that's pretty much it for the server application we could run it now but there wouldn't be much to see we'll come back and run it later when it's more useful next let's create a new file called client.js and in here i'm going to start by creating a new function called main and this is going to be an async function that we pretty much call immediately and the reason why we do this is so that we can use the await keyword within the main function if you're not too comfortable with the async and away keywords then i highly recommend this talk by westboss over here on the free code camp youtube channel now the first thing we'll want to do when the user runs our application is ask them for their username we'll subsequently use this username to create a chat kit user via the server we just created now to ask the user for their username i'm going to use an npm module called prompt now the way prompt works simply is that you install it and import it just like you would most npm modules you call a function called start to initialize the module and then most interaction happens via this get function to which you firstly pass some options we'll explore this in more detail in a second as well as typically a callback function which is called when the user successfully or erroneously enters an input we might tweak this a little bit to use promises but let's start off with the basics by installing prompt so if i head over to the terminal and quickly run npm install save prompt and then just like we saw in the npm docs we can write prompt.start and whereas we would normally call prompt.get what i'm going to do is import another module called utel i'm going to create a new function called get i'm going to set it equal to you tell the promisify prompt.get now instead of calling prompt.get which takes a callback function we're going to call get this local variable instead which is equal to a function that returns a promise now which is going to enable us to use get with the await keyword like this like i skimmed over earlier the get function takes an options argument really this is a schema which is quite an overloaded term in programming but basically it's an outline of what we expect from the user this will be the username schema the description is basically what you want to present to the user so we'll say enter your username and then we specify the name by which we want to reference the user's input later so i'll write username then it's really just the case of creating a result variable and awaiting the results of get username schema on this result we can access the username which is basically the name that we supplied above right in fact we can do this in one step just by using object restructuring like this and just to make sure everything is working nice and fine let's log out the username to the console as you can see when we run the client it asks us for our username i write booker and booker is written to the console one thing i don't really like is this like prompt text at the beginning of my description the way to disable that really simply is to set prompt.message i think equal to an empty string yeah and now you can see when we run that we don't have that black prompt text never mind this error i just killed the application in fact yes come to think of it we should probably wrap most of this function inside of a try catch block if an error happens we'll write it to the console and call process.acce with the status code one this will just make things a little bit easier to debug if things go wrong this is also a good time to mention but you might notice at times that when i write my code it's kind of indented all over the place or maybe it's not as optimal as it could be for example i have superfluous parentheses or something like that yet when i save my file everything gets nice and tidy that's thanks to a javascript tool called prettier which i have integrated in my editor super cool tool check it out if you haven't heard of it already but yeah now we have this username down here we're going to want to send it to the server where we can create a chat kit user and to do that i'm going to use a thirdparty mod module called axios so let's bring an axios real quick and i'll create a separate function called create user that takes a username it's going to be in a sync function and then we're going to send a post request using axios to http localhost port 3001 i think i'll double check in a second slash users and then we'll specify the body to be equal to the username and again we should probably wrap this in a try catch block just in case something goes wrong let me quickly check server.js for the port number as you can see it's 3001 perfect um so but down here instead of printing the user to the console we can write create user and we'll actually need to await that result right there let's test this out real quick so let me create another splits here where i'll run the server remember i said it wasn't really useful to run before but now it is if i run the application and i enter the username booker we should see in the server output and we do that a user called booker was created if i run the client again and i try and essentially log in as booker again now the user already exists we see that written to the server as well pretty cool right you know else is pretty cool connecting to chat kits while i'm here i'm going to install the pusher chat kit client sdk the reason why i say it so slowly is because it's important to realize that earlier we installed the server chat kit sdk and now we're installing the client chat kit sdk often these would happen in different projects but because we're kind of condensing them it might seem a bit confusing at the top here we can import chat kit in fact specifically we're going to want to bring in the chat kit chat manager and the chat kit token provider and then down here just beneath the call to create user i'm going to initialize chat kit or more specifically the chat kit chat manager i have a handy little snippet for this because i do it quite often the first thing you need to do when initializing the chat manager is specify your instance locator now this is the same instance locator we copied earlier from the dashboard so let's copy it again or copy it from your server file it's the exact same the user id in our case is going to be equal to the user's username this can be a string or a number in our case it makes sense to use the username because that's all we really have and just like we specified the user's endpoint up here down here we need to specify the authenticate endpoint so let's do that now localhost port 3001 slash authenticates in that same snippet i call chat manager.connect and assign the result to a variable or a constant sorry called currentuser now this represents the current user we should be able to come here and print the current user to the console and we can poke around to see what is available on that current user spoiler most interactions with chat kit happen on this current user for example we'll call current user dot send message and so on but actually i can tell you right away that this is not going to work if we run this application now it would blow up and the simple reason is that the chat kit client sdk this module we import up here doesn't work with nodejs out of the box like i mentioned at the beginning of this tutorial i work on the chat kit team and when we started building this client sdk it was mainly built against the web browser which means internally it uses some functions which exist in the web browser but not in node.js so to use the chat kit client in node.js we basically need to for lack of a better word trick chat kit into thinking it's working in the browser to do this we can use an npm module called js dom which we'll need to import and then we'll create a function called make chat kit node compatible this is a snippet i defined for the sake of this screencast because otherwise i wouldn't have remembered the details what it really boils down to is creating this global.window property that chat kit needs internally we'll need to make sure to call this function and then once that's all set up we should i think be able to connect to chat kit and view our current user so let's run the server so we have something to connect to once that's running we'll run the client and connect as booker and see what happens as you can see once we connect we get i mean this input's hard to read obviously it's a lot of tax and a pretty big font and you can get an idea of the kind of functions and properties available on this current user we won't spend too much time looking at it actually because it's quite hard to discern the useful stuff from the uh sort of prototype output and stuff but you can see for example we have like the user's name here so we can access the current user's name by writing currentuser.name and so on you know we'll see this all in action soon enough let's allow the user to choose a room to join and the way we'll do this firstly is by creating a variable called joinable rooms and we're going to set this equal to the result of current user dot get joinable rooms then we'll create a variable beneath it called available rooms i'll explain the distinction in a second but in a nutshell we take the current user.rooms property and the joinable rooms constant we just defined and we merge these two arrays now what's happening here because it seems like we're conflating two ideas um i say that we're going to allow our user to join a room but then we have two concepts joinable and available rooms well in chat kit basically you have this concept of a joinable room it's a room that jacket user is eligible to join they have permission to do so and the room exists but they haven't yet joined once they join that room it's said that the uh user belongs to that room and so you can access an array of all the rooms that a user belongs to um viver's current user.room's property now there's a difference between how you represent this in our code and how we present it to the user the way we'll present it to the user is that all rooms are joinable even if the user has already joined the room this might sound complicated so it might be a bit easier to see in action once we have this available rooms property what we'll do is we'll write them all to the console so write available room stop for reach we'll take the um room and we'll take the index and we'll print that to the console uh so we'll print out the uh index and then we'll print out the room name you know if we run this right now we wouldn't actually see anything because we haven't created any chat kit rooms we have to do that ourselves and there are two ways of approaching this we can either create rooms programmatically using one of the sdks and this is the recommended way and in any real application this is likely the only way for example imagine you're building an application similar to slack or similar to messenger when someone creates a new group you know you're going to need to write some code that creates that group dynamically invites members dynamically all that kind of stuff because we kind of know our parameters here because this is a tutorial we're going to use the second approach which is to use the chat kit dashboard and more specifically the jacket dashboard inspector inspect your inspector here we can create an admin user and then create a room i'll call mine general in fact i'll create two i'll create one called general and i'll create one called free code camp which can be a chat room that people can come to to talk about free code camp now we have those two rooms i would expect that if i run the server and if i run the client and connect it as booker we should be shown a list of available rooms and we probably are we are actually but this is a bit this is a bit broken and let's debug this together first of all the output's a bit messed up because we're still printing out the current user let's fix that the second problem i think is that we see the room index zero and it says it's undefined and i'm trying to think why that is um oh i know why it's because in addition to um destructuring the current use of the room's property will also need to destructure the joinable rooms constant and if you're not familiar with destructuring i should have mentioned this earlier i'm going to make sure to link a tutorial in the description it might be a confusing concept as i even myself got confused just then apparently um but in a nutshell enables you to join a raise let's try this again hopefully now we see a cleaner input and the expected input no less as you can see we have the option to join the general room or the free code camp room next let's prompt the user to choose one of those rooms and so let me just bring this up a little bit and then we'll create another schema this time we'll call this room schema the description is going to be select a room and we'll call this um input chosen room we'll come down here and type kant's chosen room equals a weight get this is the same get function we defined earlier remember this guy and then we'll pass in the room schema once we have that we can actually pull down the room using the index which is essentially what the user supplied right they enter the number zero or one in this case that will correspond to an index in the array in that available rooms array that i'm highlighting right now and and so we can write available rooms chosen room and then it's time to subscribe to that room i have a snippet which can help me do this called subscribe or sub because i'm lazy and i do this a lot the room id is going to be equal to room.id in fact let me take a step back here this subscribe to room function takes a few different options firstly it takes the room id namely the room to subscribe to in this case it's going to be whichever room the user selects then we have the opportunity to specify some hooks the idea of hooks might be familiar to you but it might be more easy to understand if you think about them as events and event handlers for instance whenever a new message is sent in our chat room this on new message function is going to be called this function is going to be called when the current user sends a message that happens in real time which is fairly unimpressive right calling a function on the same client that caused that function to be executed but the place where chat kit really comes in here is that if we distribute this chat application to a bunch of our friends or a bunch of users as they send messages in the same room this all new message function is going to get executed in real time with their messages here we can write the messages to the console we'll want to include the uh message dot sender id which is essentially their username in our case as well as the message text itself and actually we're only going to print this message if the message dot sender id is not equal to our username because if we're the person who sent the message we don't need that to be relayed to ourselves because we're going to see it in the terminal input anyway there's no need obviously to notify the current user but they sent a message of course they know this is tricky to demonstrate because whilst we can subscribe to messages we can't actually send messages yet let's do that now we'll want to capture the user input repeatedly right so we'll want the user to be able to send one message and then another and so on now we could probably adapt the prompt npm module to do this but there's actually a much more suitable module called redline which i'll install now so i'll write npm install dash save redline actually i did notice this when i started recording this screencast but it seems like in note 10 there's another module called line by line that might be a bit more suitable i'll leave that up to you to look into i'm going to use reline because it's what i know and what i know about redline is that you need to import it well i know more than that that's pretty pretty obvious i would say but yeah we'll import redline and then down here beneath our call to subscribe to a room we're going to want to create a constant called inputs that we're going to set equal to redline dot create interface and we call create interface we specify an input option which is going to be equal to process.stdn stdn is like a fancy word for the terminal input basically we often refer to the output as std out as well which you might find interesting if you didn't know already then we can call input.on line and then we'll create an async callback function which gives us that line or that text basically and from here we can write current user dot send message when we call send message we need to specify the room that we're sending that message to all messages have to be sent to a room so that'll be equal to room.id and then the message itself which is going to be equal to the text property that looks good let's test this out i think this should pretty much work how we expect and as ever i'll run the server then connect with the client in fact you know what you know what let's create a new window here first we'll run the server then we'll run one client and then we'll run another client so when this first client will say my name is booker and this client i'll say my name is hugo hugo cowrote the tutorial with me awesome dude and we'll both join the free code camp channel so i'll join the free code cam channel and then i'll join the free code camp channel for hugo and then to be honest as i'm doing this now it would be nice to have some indication as to when we've connected right now it just feels a bit laggy but if i write hello we should see in the other console on the right there the book has said hello and we don't which is really sad let's figure out why so we get an error here which says expected room id to be of type number but was of type undefined and that's quite strange because i really don't see why room would be undefined here which line did that happen on line 85 so yeah right here um ah so what i'm doing is i'm looking up here where i access room.id and i'm sure this worked and so room.id can't be undefined that wouldn't make sense to me anyway but i'm looking at the wrong side of the assignment what i'm actually doing here is assigning a property called room id and down here i'm assigning it to a property called room and what i'm meant to write is room id let's save that and try again so let's just kill these clients real quick and rerun them i'll connect this booker then as a new user let's call that new user bob we'll both join the free code camp room and here i can write hello and as i write hello we should see that in the other window booker said hello bob can then say hi back and we can see in the other window that bob said hi you know obviously these two clients are running side by side on the same machine in the same terminal but we could equally send this file to a friend you know hugo lives in australia i live in london we can both communicate on completely different machines across the ocean um such as the internet which isn't that impressive but i just want to reemphasize that even though this is happening locally it would also work remotely but yeah that pretty much wraps up the tutorial in summary we built a chat application where we can create users create rooms join rooms then send and receive messages there's so much more we could do to this application if we had time from both a chat perspective and a terminal perspective right so we're barely touching the surface of what chat kit can do we're barely touching the surface of what you can build in the terminal one cool idea hugo and i had was if we could list a list of online users as well as users who have joined the chat previously but aren't online that'd be such a cool terminal interface and it would use a feature of chat kit called chat kit presence basically we could even show typing indicators and read receipts so many cool things but like i say we need to give it a rest for now if you'd be interested to learn more if you want to see a continuation of this application of part two if you will please let us know in the youtube comments or in the comments over on medium you might also want to check out the medium post because in addition to what you've just seen me build right here we also outline how to add a loading spinner to your application which is a really nifty way to make your application feel faster um as well just as well just for a bit of fun right but yeah thank you so much for watching please do make sure to subscribe both to the free code camp youtube channel as well as myself over on the codecast youtube channel you can also follow myself on twitter i'm at booker codes thank you
