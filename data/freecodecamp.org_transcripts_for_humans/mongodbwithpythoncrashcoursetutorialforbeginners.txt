With timestamps:

00:01 - hello and welcome to mongodb quickstart
00:03 - with python mongodb is one of the most
00:06 - popular and exciting database
00:08 - technologies around python is one of the
00:10 - most popular and fastest growing
00:12 - language there is and these two
00:13 - technologies work great together and
00:15 - that's exactly what this course is about
00:17 - so we're going to quickly get started
00:19 - with mongodb write some code against it
00:21 - and build some realistic applications so
00:25 - the goal with this class is to teach you
00:26 - mongodb we assume you know a little bit
00:28 - of python but you'll of course pick some
00:30 - things up along the way if you don't
00:31 - know it already and really we want to
00:33 - get you going quick hence the name quick
00:35 - start so let's get started by talking
00:37 - about what we're going to cover in this
00:39 - course we're going to focus on three
00:40 - main things we're going to start with
00:42 - why do you care about nosql and document
00:45 - databases how do document databases make
00:48 - working with schemas easier modeling
00:51 - data easier as well as add performance
00:54 - and flexibility to our applications
00:55 - we're going to talk about modeling
00:57 - specifically because this is one of the
00:59 - things that is pretty challenging about
01:00 - document databases if you come from a
01:02 - relational database world you probably
01:04 - know about third normal form this is a
01:06 - way to carefully and sort of structured
01:08 - way to plan out how you model your data
01:11 - in document databases you don't really
01:12 - have that there's a lot
01:14 - more sort of flexibility in how you
01:16 - design things
01:18 - this is great for you once you
01:19 - understand it and you're really good at
01:21 - it but it's challenging to know how to
01:23 - model things when you get started
01:24 - because there's so much flexibility and
01:26 - it's kind of open-ended feels a little
01:28 - more like art than science in some sense
01:30 - so we're going to focus specifically on
01:32 - techniques and trade-offs and some
01:35 - guidelines i've come up with to help you
01:37 - be successful modeling your data with
01:39 - document databases such as mongodb
01:42 - and then we're going to start writing
01:43 - code for real we're going to use a
01:46 - odm object document mapper think of like
01:49 - sql alchemy but for document databases
01:51 - called engine and we're going to
01:53 - use that to
01:55 - create some classes to model our data
01:57 - and map those classes to and from
01:59 - mongodb and use that as the foundation
02:01 - of our application speaking of
02:02 - applications what are we going to build
02:04 - in this class well we're going to build
02:06 - an airbnb clone but for snakes okay so
02:09 - we're going to build snake bnb and this
02:11 - allows you when you're traveling with
02:13 - your snake your pet snake you don't want
02:16 - it to have to live out in the car or
02:18 - something like that you want to get it a
02:20 - cage that it can live in a proper snake
02:22 - cage or it'll be happy so they'll be
02:24 - owners of cages who can put their cages
02:26 - up for rent and snake owners pet owners
02:29 - who want to travel with their pets and
02:31 - have their pet have a place to stay so
02:33 - we're going to create this sort of silly
02:34 - airbnb knock off clone but we're going
02:36 - to model many of the operations you
02:38 - would see in real airbnb on our
02:41 - application here so it's going to be
02:42 - pretty rich in terms of data as far as
02:44 - tools go well of course we're going to
02:45 - talk about mongodb right that's the
02:47 - database we're using but you're also
02:49 - going to learn some other things that
02:50 - are pretty awesome in the course we're
02:52 - going to talk about engine this is
02:54 - the primary library we're going to use
02:56 - to talk to mongodb it's built upon
02:58 - another one that's very popular that is
03:00 - sort of the lowest level official way to
03:02 - talk to mongodb called pymongo so you
03:04 - might see a little bit of both of those
03:05 - actually in the course
03:07 - we're going to use what i think is the
03:08 - best tool for accessing mongodb
03:11 - something that used to be called
03:12 - robomongo but now it's called robo3t
03:16 - because it was acquired by a company
03:17 - called 3t so this is part command line
03:20 - part gui way to interact with mongodb
03:23 - and it's beautiful and free open source
03:25 - it's great
03:26 - also we're going to use pycharm for our
03:28 - python code you don't have to use
03:30 - pycharm for this course but you'll see
03:32 - me using it and i think you'll see a lot
03:33 - of benefits as we go
03:36 - speaking of me who am i anyway who is
03:37 - this voice that you're listening to hi
03:39 - my name is michael kennedy you can find
03:40 - me on twitter at m kennedy and what
03:43 - makes me qualified to teach this course
03:45 - well first of all i host the most
03:47 - popular python podcast called talk
03:49 - python to me and i've interviewed many
03:51 - many people including some of the folks
03:53 - from mongodb the company as well as
03:55 - authors who've written about mongodb
03:57 - design patterns and things like that so
03:59 - i've had a lot of experience working
04:00 - with people in python and magady b
04:02 - i've created the talk python training
04:05 - company and written many python courses
04:08 - and mongodb courses there as well
04:10 - and also i'm part of the mogadib masters
04:13 - program
04:14 - so this is a group of about 35 external
04:17 - community members who give advice back
04:20 - to mongodb and i've been part of this
04:22 - for many years worked closely with the
04:23 - folks inside mongodb over the years so
04:26 - this is what you have in store for you
04:28 - lots of awesome mongodb and python i
04:30 - hope you're excited let's get right to
04:32 - it
04:34 - let's begin by looking at why you might
04:36 - choose mongodb
04:38 - over other nosql databases other
04:41 - document databases or even other
04:43 - relational databases i'm sure you've
04:45 - heard of mongodb that's why you're
04:46 - taking this course but how popular is it
04:49 - relative to
04:50 - other databases is it really the right
04:52 - choice well let's look at some data from
04:55 - 2017. if you compare mongodb against
04:58 - other nosql databases cassandra couchdb
05:01 - ravendb things like that you will find
05:04 - one of these databases is unlike the
05:06 - others look at that that's incredible
05:08 - how much more popular mongodb is over
05:11 - these and it's not just the popularity
05:13 - that it's 5 10 times maybe 50 times more
05:17 - popular than ravendb that's great that's
05:19 - very important but also the trend right
05:22 - these others are either flat or turning
05:23 - downwards and this is besides a little
05:25 - blip here based on probably like the end
05:27 - of the year um numbers or something like
05:30 - that at the end of the data this is a
05:32 - really big deal right this is incredible
05:34 - how much growth that is here and it's
05:37 - still going up so mongodb is really
05:39 - really popular in terms of a database
05:42 - that people are using and that's great
05:44 - because that means it's well tested when
05:46 - we get to the section a little bit later
05:48 - we'll look at some of the users of
05:50 - mongodb but it's really important that
05:51 - there are some heavy workloads put onto
05:54 - these databases that you're going to
05:55 - depend upon and if it can take what
05:57 - those people are doing surely it can
05:59 - take what you have to throw at it as
06:00 - well now mongodb is also loved if you
06:03 - look at stack overflow at their 2017
06:07 - developer survey
06:08 - and you look at the most loved databases
06:11 - these are databases that the developers
06:14 - are using currently and how they feel
06:15 - about it you see mongodb ranks right
06:18 - near the top so definitely 55 percent of
06:20 - the people who are using mongodb love it
06:23 - compared to say like sqlite or cassandra
06:26 - so this is pretty good but what's even
06:27 - more interesting is that it's
06:29 - the most wanted database so these are
06:32 - technologies that you're not currently
06:33 - able to work with but you would like to
06:35 - so there are tons of people that want to
06:36 - work with mongodb but for whatever
06:38 - reason they've got some legacy system
06:40 - built on you know mysql or whatever they
06:42 - don't get the chance to so all these
06:44 - pieces of data tell you mongodb is a
06:46 - really good technology to have in your
06:48 - tool belt and it's easy to get a hold of
06:50 - right mongodb is open source and it's
06:52 - free you can just go to github.com
06:54 - mongodb and clone it and it's
06:57 - right there so you can see it has 11 000
06:59 - stars 3000 forex in this screenshot i
07:02 - took here it was updated two hours ago
07:04 - it's under very very active development
07:06 - so it's a live and vibrant project
07:08 - finally if you actually want to get
07:10 - mongodb don't go to github github is
07:12 - cool it's great you have the source but
07:14 - don't go there what you really want to
07:15 - do is you want to go to mongodb.com
07:18 - download center or just go to
07:20 - mongodb.com and click download it'll
07:22 - take you here and you download it here
07:24 - you get it as a binary so if you're on
07:26 - mac i recommend you use homebrew to
07:28 - install it but you can also download a
07:30 - tarball if you're on windows get the msi
07:32 - and on linux you can actually install it
07:34 - with aptitude or some package manager
07:37 - like that in this course we're not going
07:38 - to go in the details of setting up
07:40 - mongodb just follow the instructions in
07:42 - the full mongodb course we have we walk
07:43 - through all the steps but we just want
07:45 - to get started this is the quick start
07:46 - so let's keep moving let's look at one
07:48 - of these records stored in mongodb to
07:51 - see how document databases work
07:53 - here we have a json record this is
07:56 - actually from one of my courses the
07:58 - python jump start by building 10 apps
08:00 - and this is how i represent it in the
08:01 - database we've got standard
08:04 - columnar type things so we have an id we
08:06 - have a title a course id duration in
08:08 - seconds these types of things now first
08:10 - of all you might be wondering wait a
08:12 - minute json database json database is
08:15 - that really efficient well probably not
08:17 - what mongodb actually stores is a binary
08:20 - representation so like a binary
08:22 - tokenized version of this record but
08:25 - they call it bson because it's like
08:27 - binary json but we're humans we don't
08:29 - read binary we read text so we're
08:31 - looking at the textual representation so
08:33 - this is not exactly how it gets stored
08:34 - but this is pretty close so we have
08:36 - these regular column type pieces of
08:38 - information id and title and so on we
08:41 - also have this other
08:42 - thing these lectures now these lectures
08:44 - are in this chapter represented by this
08:46 - record from this course and notice the
08:48 - bracket in javascript which basically
08:50 - this is means that is a array and the
08:54 - array contains a bunch of sub-objects so
08:56 - this is really interesting instead of
08:58 - just having a
08:59 - chapter table and a lecture table and
09:01 - doing a join or something like that a
09:03 - foreign key relationship we're actually
09:04 - putting the lectures inside the same
09:07 - record so this is pretty interesting
09:09 - when you look at it like this you can
09:10 - imagine that this is like a pre-computed
09:13 - join if i do a query for the lecture say
09:16 - given id 1001 and i get this record back
09:20 - it already has the lectures i don't have
09:22 - to make another round trip to the
09:23 - database to get them i don't have to do
09:24 - a join against several tables in that
09:27 - original query it's literally a primary
09:29 - key query against an indexed primary key
09:32 - and is insanely fast and yet it already
09:34 - comes back with all this extra
09:35 - information so this is really cool if i
09:37 - get the chapter i have the lectures
09:39 - great but you might be wondering well
09:42 - really what if i need to ask the
09:43 - question in reverse
09:45 - like fundamentally if i need to get at
09:47 - lecture
09:48 - 10106 will i be able to query mongodb
09:52 - quickly and efficiently to get that
09:55 - lecture and it turns out the answer is
09:58 - yes and that's why document databases
10:00 - are awesome it's not just like some
10:01 - nested blob stored in the original
10:03 - record you can as part of the query
10:06 - language and part of indexes traverse
10:08 - these hierarchies in very very rich and
10:10 - powerful ways so we don't lose very much
10:13 - query capability just by putting the
10:15 - lectures in this one record so this is
10:17 - really neat and this is sort of the
10:19 - foundational
10:20 - most important takeaway from document
10:22 - databases we store them as these
10:24 - flexible json type of objects and we can
10:27 - nest additional things like lists of
10:31 - numbers or even sub-documents as we have
10:32 - in this case
10:36 - now before we move on let's take a
10:38 - moment and look at who uses mongodb now
10:40 - programming languages and databases and
10:43 - technologies aren't necessarily
10:45 - popularity contests just because
10:47 - something's popular it doesn't
10:48 - necessarily mean that it's great you
10:50 - know evidence php for example or vb or
10:53 - something like this technologies are
10:55 - popular and some of them are great and
10:57 - sometimes great technologies are popular
10:59 - so there are some important things that
11:01 - come along with being popular and used
11:04 - in by big important companies and that
11:06 - means these things are durable and
11:08 - tested and they've really been through
11:09 - the ringer so mongodb has been used by
11:12 - some
11:13 - really big customers and some really
11:15 - interesting use cases and i know some of
11:17 - the biggest ones are actually not on
11:18 - this page even they're not listed here
11:20 - so i'm taking a quick tour of a couple
11:22 - of customers who are using mongodb and
11:24 - we'll look at how they're using it okay
11:26 - so the first one that i want to look at
11:28 - let's scroll down here and see some
11:29 - names that you might know some cool
11:30 - stuff here let's check out royal bank of
11:32 - scotland so banks are supposed to be
11:33 - conservative right things like this they
11:35 - probably wouldn't use weird nosql
11:37 - document databases they're going to
11:38 - stick to their traditional oracle or sql
11:40 - server or whatever well if we look at
11:42 - royal bank of scotland they're using
11:44 - mongodb to support a global enterprise
11:47 - data service underpinning several core
11:49 - trading systems if you're bank the core
11:51 - trading system's pretty much
11:54 - the center of the universe right so the
11:56 - fact that they're driving that with
11:57 -  and that's high performance and
11:58 - it's doing that for them that's really
12:00 - awesome let's check out expedia so
12:01 - expedia they have their app built on
12:03 - mongodb and they're supporting millions
12:05 - of customers shopping for flights hotels
12:09 - cars things like that that's pretty
12:11 - awesome let's check out another one down
12:12 - here ea so video games right this is the
12:15 - world's best-selling sports game
12:17 - franchise and they rely on mongodb to
12:19 - scale to millions of players that is
12:21 - really awesome one more before we move
12:23 - on so these guys down here a little
12:25 - farther at sail through
12:28 - sail through is a company that does like
12:30 - outbound mail and analytics and things
12:32 - like that so they are a marketing
12:34 - company very much doing tons of email
12:36 - type of stuff like i said and they have
12:38 - over 40 terabytes of data in 120
12:42 - physical mostly physical nodes right so
12:44 - 120 servers
12:47 - all
12:47 - working running mongodb in some giant
12:51 - cluster which is a pretty awesome use
12:53 - case and of course you have things like
12:54 - shutterfly running on mongodb
12:56 - squarespace on and on there's a ton of
12:58 - cool uh use cases down here but i think
13:00 - you've got the idea
13:02 - are you ready to model some real
13:04 - applications in mongodb using documents
13:07 - it's time to get our hands dirty and
13:08 - really start building something so in
13:10 - this chapter we're going to go through
13:12 - our snakebnb application come up with
13:14 - the entities the classes and tables or
13:17 - collections as they're called a mongodb
13:19 - and model them out so we're going to
13:20 - first look at
13:22 - how this modeling and document databases
13:25 - compares to traditional third normal
13:27 - form modeling in relational databases
13:29 - i'm going to use a pretty simple example
13:30 - but i think you'll get the idea and
13:32 - you'll see it much more in action when
13:35 - we build the real app so let's take this
13:37 - simple bookstore model here we have
13:39 - books they have a bunch of properties we
13:40 - have people who publish those books
13:42 - named publishers they have a name when
13:44 - they were founded and you can navigate
13:46 - this foreign key relationship from
13:48 - publisher over to the publisher id on
13:50 - the book now we also have a user and a
13:53 - user might rate a book so we have users
13:56 - and we have ratings and we have a
13:57 - foreign key relationship between them
13:58 - and they know from rating over to book
14:01 - we have a one-to-many relationship there
14:03 - right a book can have many ratings so we
14:05 - have a couple of foreign key
14:06 - relationships going on this place now
14:08 - let me tell you in a real application
14:10 - there'd be many more little tables with
14:13 - extra information like this like ratings
14:14 - about books and so on and like let's say
14:17 - reviews for example things like that
14:19 - maybe even related items that we
14:21 - pre-computed from some sort of machine
14:23 - learning but we want to store that in
14:25 - the database so imagine this model here
14:28 - having like 15 tables with relationships
14:31 - across all the various pieces back and
14:32 - forth right so i just want to keep it
14:34 - simple if it's on the screen you're not
14:35 - going to go crazy with it so how would
14:37 - we model this in mongodb how will we
14:39 - model this using documents well you
14:41 - would see that it's somewhat simpler the
14:43 - more craziness that we had on the
14:45 - relational model the sort of more
14:47 - contrast you will see here so we still
14:48 - have our publisher and they have their
14:49 - id and when they are founded we have our
14:51 - user the same columns or pieces of
14:54 - information there as well same as book
14:56 - but now our ratings we've decided you
14:58 - know when we get a book most of the time
14:59 - we actually want to know the rating we
15:01 - want to say like this is a 3.4 star book
15:04 - or it has 72 ratings even in a list we
15:07 - want to show that stuff so we're pretty
15:09 - sure we want to have these ratings
15:11 - always with the books so why put them in
15:13 - a separate table let's embed them now we
15:15 - still have some relationships like we
15:16 - had in the relational model for example
15:18 - we have our publisher id on books and
15:20 - that links over to publisher now this is
15:23 - what in mongodb i refer to as a soft
15:25 - foreign key constraint if there is a
15:26 - relationship between books and publisher
15:29 - it's the publisher id set to the id of
15:30 - the publisher but the database itself
15:32 - doesn't enforce this right so you need
15:34 - to be a little more careful in your app
15:35 - and we'll see how we do that when we get
15:37 - to the code but as i was saying about
15:39 - ratings these we're not going to put in
15:40 - a separate collection in fact we're
15:42 - going to store those inside of our books
15:45 - so we can embed these objects and arrays
15:48 - of either straight values like numbers
15:50 - or strings or actual sub documents like
15:53 - our ratings here so whenever one two
15:55 - three and so on is actually part of the
15:57 - record of the book so when we get the
15:58 - book record back we already have the
16:00 - ratings things like that so again we can
16:02 - think of this ratings being embedded
16:05 - within books as a pre-computed join
16:08 - there's a slight bit of overhead if you
16:10 - actually wanted the book without the
16:11 - ratings and you're just going to get
16:13 - them back and ignore them most of the
16:14 - time anyway if that was the case but if
16:17 - most of the time you do want the
16:18 - radiance this is a huge speed up and
16:20 - like i said imagine there were 15 tables
16:22 - before and five of them could be
16:23 - collapsed into the books they have a
16:25 - five-way join going down to a single
16:27 - primary key query that'd be amazing as
16:30 - we discussed modeling with documents and
16:33 - document databases is a little bit more
16:34 - art there's a little bit more
16:36 - flexibility and kind of just gut feel of
16:38 - how you should do it but let me give you
16:40 - some guidelines that will give you a
16:42 - clear set of considerations as you work
16:45 - on your data models
16:47 - you'll see that the primary question for
16:49 - working with document databases is to
16:52 - embed or not to embed that is when
16:54 - there's relationship between two things
16:56 - in your application should one of those
16:59 - be a sub document should be contained
17:01 - within the same record as the thing it
17:03 - is related to or should they be two
17:05 - separate collections what mongodb calls
17:07 - tables collections because they're not
17:09 - tabular right should those be two
17:10 - separate collections that just relate to
17:13 - each other so we're going to try to
17:14 - answer this question i'll try to provide
17:16 - you some guidelines for answering this
17:18 - question so the first one is is the
17:20 - embedded data wanted 80 of the time when
17:24 - you have the the outer or other related
17:27 - object okay so let's go back to our
17:29 - example we just worked with we had a
17:30 - book and the book had radiance so to
17:32 - make this concrete the question here is
17:35 - do we care about having information
17:36 - about the ratings most of the time when
17:39 - we're working with books so if our
17:41 - website like lists books and that
17:43 - listing has the number of ratings and
17:45 - the average rating and things like that
17:47 - listed as part of the listing you pull
17:49 - up a book maybe the ratings and the
17:50 - reviews are shown right there most of
17:53 - the time we have the book we have the
17:54 - ratings evolved somehow then we would
17:56 - want to embed the ratings within the
17:58 - book right that's what we did in our
18:00 - data model we said yes actually we do
18:02 - want the ratings most of the time now
18:04 - let's look at this in reverse how often
18:07 - do you want the embedded data without
18:09 - the containing document so in the same
18:11 - example how often is it the case that
18:13 - you would like the ratings without the
18:16 - book so what use cases for maybe like
18:19 - where would that show up in our app so
18:20 - like maybe you as a user go to your
18:23 - profile page on the bookstore and there
18:25 - you can see all the books you've rated
18:26 - right and the the details about the
18:28 - rating you don't actually care about
18:29 - necessarily the books you just want
18:30 - these are the ratings that i've given to
18:32 - things and here's my comments and so on
18:35 - i don't actually want most of the
18:36 - details or maybe any of the details
18:38 - about the book itself so if you're in
18:40 - that sort of situation a lot of the time
18:42 - you might want to put that into a
18:44 - separate collection and not embed it you
18:46 - can still
18:47 - do it you can still do this query and it
18:48 - will come back very quickly there's ways
18:50 - to work with it but you'll see that you
18:52 - have to do a query against the database
18:53 - and then a little bit of filtering on
18:55 - the application side so it's not
18:57 - prohibitive it's not that you can't get
19:00 - the containing document with the
19:01 - contained document without its container
19:03 - but it's a little bit more clumsy all
19:06 - right so if this is something you
19:07 - frequently want to do then maybe
19:09 - consider not embedding it now is the
19:11 - embedded document a bounded set so let's
19:14 - look at ratings how many ratings might a
19:16 - book have 10 ratings 100 ratings a
19:18 - thousand ratings is that number going to
19:20 - just grow grow the number of ratings
19:22 - that we have if this was like page views
19:25 - and details about the browser or ip
19:27 - address and date and time of a page
19:29 - being viewed i would not make a good
19:31 - candidate for embedding that like say
19:32 - for views of a book because that could
19:34 - just grow and grow and grow as the
19:35 - popular your site grows and it could
19:37 - make the document so large that when you
19:39 - retrieve it from the database actually
19:40 - the network traffic and the disk traffic
19:42 - would be a problem i don't really see
19:43 - that happening with ratings i mean even
19:45 - on amazon like super popular books have
19:48 - hundreds not millions of ratings so this
19:50 - is probably okay but if it's an
19:52 - unbounded set you do not want to embed
19:55 - it and is that bound small right like
19:57 - maybe millions of views still being
20:00 - recorded within sign of a book would be
20:02 - a really bad idea and the reason is
20:03 - these documents are limited to 16
20:06 - megabytes so no single record in mongodb
20:08 - can be larger than 16 megabytes and this
20:10 - is not a limitation of mongodb this is
20:13 - them trying to protect you from yourself
20:14 - you do not want to go and just say query
20:17 - by say isbn and try to pull back a book
20:20 - and actually read 100 megabytes off a
20:22 - disk and over the network that would
20:23 - destroy the performance of your database
20:25 - so having these very very large records
20:28 - is a problem so they actually set an
20:30 - upper bound on how large that can be and
20:32 - that limit is right now currently at the
20:35 - time of the recording 16 megabytes but
20:37 - you shouldn't think of 16 megabytes as
20:38 - like well if it's 10 megabytes
20:40 - everything's fine we're still got a long
20:42 - ways to go no you should try to keep
20:44 - these you know in the kilobytes tens 20s
20:46 - hundreds of kilobytes not megabytes
20:48 - because that's going to really hurt your
20:50 - database performance unless some
20:52 - situation it just makes a ton of sense
20:54 - to have these very large documents so
20:55 - having small bounded sets means that
20:58 - your documents won't grow into huge huge
21:00 - monolithic things that are hard to work
21:02 - with also how varied are your queries so
21:05 - one of the things that you do with
21:06 - document databases is you try to
21:08 - structure the documents to answer the
21:11 - most common questions in the most
21:14 - well-structured way right so if you're
21:16 - always going to say i would like to on
21:18 - my pages show a book and it's related
21:20 - ratings you would absolutely put the
21:22 - ratings inside the book because that
21:23 - means you just do a query against a book
21:25 - and you already have that like kind of
21:27 - pre-joined data but if it's sort of a
21:29 - data warehouse and you're asking all
21:30 - kinds of questions from all different
21:32 - sorts of applications then trying to
21:34 - understand well what is the right way to
21:36 - build my document so it matches the
21:37 - queries i typically do or the ones that
21:39 - i need to be really quick and fast that
21:41 - becomes hard because there's all these
21:43 - different queries and they have like you
21:44 - know one the way you model for one is
21:46 - actually the opposite of the way you
21:48 - model for the other right so depending
21:50 - how focused your application is or how
21:52 - many applications are using the database
21:55 - you'll have a different answer to this
21:56 - question so the more specific your
21:57 - queries are the more likely you are to
21:59 - embed things and structure them exactly
22:01 - to match those queries related to that
22:03 - is are you working with an integration
22:06 - database or an application database
22:09 - we'll get to that next
22:10 - so wait what is an integration database
22:13 - so if you were just working on your own
22:14 - personal website or some small project
22:17 - you don't have an integration database
22:18 - but if you work at a big
22:20 - enterprise a big corporation where
22:22 - there's many internal systems you may be
22:24 - working with an integration database and
22:26 - honestly that's not a great fit for
22:28 - nosql databases in general but it also
22:30 - makes designing documents for them more
22:32 - difficult so in large corporations we
22:35 - have many applications that share the
22:37 - same data one way that we have built
22:41 - applications to share data is to just
22:43 - share the same database so we might have
22:45 - a bunch of different applications and
22:47 - they're all going to talk to the same
22:48 - database so they all have the same
22:50 - concept of a user they all have the same
22:52 - concept of an order things like that and
22:54 - this means the concept of the user is as
22:56 - complicated as it can get maybe the
22:58 - application in the top left could have a
22:59 - real simple user the one in the top
23:01 - right actually needs something else the
23:02 - bottom one is something else still and
23:04 - so you've kind of got a model across all
23:06 - these applications and that makes it
23:08 - super tricky also in nosql databases and
23:10 - document databases the relationships are
23:12 - enforced in the application so that
23:14 - means that all of these have to agree on
23:16 - what the constraints are what the
23:17 - relationships are and that can actually
23:19 - cause data integrity issues so there's a
23:21 - lot of reasons that integration database
23:22 - isn't a great idea for relational
23:24 - databases in fact it's not a great idea
23:26 - at all but it has been used and because
23:28 - there's different applications with
23:30 - different query patterns it makes
23:31 - designing your documents more difficult
23:33 - so instead what do we do we build
23:35 - application databases maybe we have a
23:37 - bunch of different applications just
23:39 - like before but they all have their own
23:40 - data store and they all talk to their
23:42 - own databases of course they need to
23:44 - exchange data like before so maybe we do
23:46 - some sort of microservice thing where
23:47 - they talk to a service bus or they just
23:49 - talk to each other things like that and
23:51 - that means each individual green
23:53 - database and interaction with its own
23:55 - application is super super focused and
23:58 - limited and here in these cases
24:00 - mongodb document databases make a lot
24:02 - more sense and it's easier to design the
24:04 - documents because the range of queries
24:07 - is extremely focused so you can target
24:09 - those particular questions against a
24:12 - small set of queries the guidelines we
24:14 - just talked about so this is the kind of
24:16 - model you want to have if you're doing
24:17 - data exchange within your organization
24:20 - and you're working with a document
24:21 - database i don't know about you but i
24:24 - feel like we've talked about coding and
24:26 - talked about mongodb in theory enough
24:28 - and it's time to write some code and use
24:30 - mongodb so that brings us to getting
24:32 - started with our demo application so
24:34 - throughout the rest of the course we're
24:35 - going to spend a significant amount of
24:36 - time focusing on this
24:38 - and remember we're building snakebnb
24:41 - this wonderful experience where snake
24:43 - owners and their pets can shear other
24:46 - snake cages when they're traveling so
24:47 - they feel totally comfortable on every
24:49 - vacation you need to take your snake on
24:51 - course it's just a knock off of airbnb
24:53 - type thing and in this video we're going
24:55 - to see how to get it from github and how
24:57 - to get it up and running in python and
24:59 - pycharm so we'll start out over here on
25:00 - github.com mike c kennedy slash mongodb
25:03 - quick start dash course and you can see
25:05 - that we've got a couple of things here
25:07 - we've got some data this is empty right
25:09 - now but i'm going to fill it up with
25:10 - stuff as we go through the class so
25:12 - you'll be able to recreate the database
25:14 - there'll be instructions in there on how
25:15 - to restore that and then if you go over
25:17 - to source this is the most interesting
25:18 - part we're going to be working in this
25:21 - area here but i've made a snapshot of
25:23 - starter code snakeb this is exactly a
25:26 - snapshot of what we're starting from
25:28 - okay but i'm going to be working in here
25:30 - because i want to have it build up right
25:31 - also trying to do make some branches or
25:34 - other save points really obvious
25:36 - when we get to the various videos right
25:38 - now there's no other branches but we'll
25:39 - get to those okay let's go and check
25:41 - this out so we'll go copy what we need
25:44 - and we'll say git clone this
25:47 - nice and quick
25:48 - and let's go work with it so over here
25:52 - we have our source code and we have our
25:54 - snakebnb and we have our starter code
25:57 - snakebnb so these are the the two
25:59 - projects here and what i want to do is
26:01 - i'm going to put this into pycharm on
26:03 - mac os you can just drag and drop this
26:05 - onto pie chart and load the project from
26:08 - that folder however if you do this on
26:10 - windows or on linux i think you have to
26:12 - go to pycharm and say file open
26:14 - directory however before i do let's go
26:16 - into this folder really quick and create
26:19 - a virtual environment so you may be
26:20 - familiar with python and virtual
26:22 - environments and so on but if you're not
26:24 - let me give you the quick overview of
26:25 - what's what's going on here if we look
26:28 - here we're going to have apparently a
26:30 - misspelled requirements file which we're
26:32 - going to take care of in a second but
26:33 - notice in this requirements file these
26:35 - are the external libraries pymongo and
26:37 -  engine for mongodb and some other
26:39 - random stuff for
26:42 - working with color output on the console
26:44 - as well as parsing date times entered
26:47 - from the user so we need these libraries
26:49 - and we don't want to install them and
26:50 - manage them basically as a machine wide
26:53 - thing we would install them into our
26:54 - virtual environment so let's go over
26:57 - here first rename requirements
27:00 - and we're going to go and actually
27:02 - create the virtual environment and then
27:03 - we'll install we can install stuff into
27:05 - it so here we are again in the source
27:08 - folder so we'll say python3 dash m v env
27:12 - so run the virtual environment module
27:14 - into dot env this
27:16 - naming convention.mv something that
27:18 - pycharm understands will automatically
27:19 - detect and start using we're going to
27:21 - pass the copies flag that's only
27:23 - required on mac os i believe but anyway
27:25 - we'll go with that now if we do an lsah
27:28 - you can see this hidden.emv but we don't
27:30 - need to do anything else with it pycharm
27:32 - should take it from here so we can go
27:34 - and grab this folder on mac os memory
27:36 - file open directory on the other os's
27:39 - and drop it here so let's go ahead and
27:40 - tell pycharm about
27:42 - git
27:43 - the very first time pipedrop will index
27:46 - the python environment we gave it and
27:48 - then it should be up and running okay so
27:50 - let's look down here in the terminal you
27:51 - should see the dot env
27:53 - you can ask questions like which python
27:55 - and it shows you it's the one that we
27:57 - created in windows it's where python not
27:59 - which python if we go over here we have
28:02 - our requirements and so on now the other
28:03 - thing we need to do is we need to right
28:05 - click and say set this as like the
28:07 - relative path so in this file when i
28:11 - import some other file it looks relative
28:14 - to that so you can say right click here
28:16 - and say mark directory as sources root
28:18 - or just be in this folder when you run
28:20 - it in python basically you're working
28:22 - directly okay so we're almost ready to
28:23 - run things the last thing we need to do
28:25 - is install these requirements so we can
28:27 - say pip
28:28 - install
28:29 - dash r the requirements file and that
28:31 - will install those libraries for us so
28:33 - when we run the application it has
28:35 - everything it needs so if we try to run
28:36 - it now it'll crash and say it can't find
28:38 - colorama or something like that now this
28:40 - application is empty it doesn't do
28:42 - anything other than ask for a couple of
28:43 - prompts there's no data access for
28:45 - mongodb anything in here but let's go
28:47 - ahead and just get it to run so we can
28:48 - right click on program and right click
28:51 - and say run program
28:53 - it runs and you can see if i make it
28:55 - bigger here we have our snakebnb and i
28:57 - put a little snake there for you guys
28:59 - and it asks you a question are you a
29:00 - guest or a host are you looking for a
29:02 - cage or do you want to offer up your
29:03 - cage so let's go with guest and it lets
29:06 - you do things like create an account add
29:09 - your snake so on so i could say i'd like
29:11 - to log in so do you know that's not
29:13 - implemented yet in fact that's what
29:14 - we're going to be doing next
29:16 - is implementing all of these features in
29:18 - the database creating an account logging
29:20 - in booking a cage viewing cages things
29:23 - like that right so all the actions you
29:25 - might do in a typical airbnb situation
29:27 - so that's it for now we have this up and
29:29 - running let's do one more thing
29:32 - because of the output this i find this
29:34 - looks a little better if we just run it
29:35 - separate outside of pycharm so we can
29:37 - say copy the path here
29:40 - and
29:41 - we're still in this folder with the dot
29:43 - environment so we need to activate it if
29:44 - we're going to run it over here so we
29:46 - would say a dot space dot env spin slash
29:50 - activate on windows you don't need the
29:52 - first thought and it's not been it's
29:54 - script script or scripts i can't
29:55 - remember i think it's scripts either way
29:57 - our prompt should change
29:59 - and now we can run this
30:01 - here's our snake again okay so we're all
30:03 - set up and ready to run our code
30:07 - it's time to write some code against
30:09 - mongodb and connect to mongodb and we're
30:11 - going to do that with an odm and object
30:13 - document mapper if this term is new to
30:15 - you think of object relational mapper
30:17 - like sql alchemy but for document
30:19 - databases instead so let's compare first
30:22 - this odm style of programming against
30:24 - the most basic lowest level way to
30:27 - program or interact with mongodb from
30:29 - python called pi so every
30:31 - programming language that you can talk
30:33 - to mongodb from there's many of them 20
30:36 - 30 i don't know something like that many
30:37 - many languages can talk to mongodb and
30:40 - they each have what's called a driver
30:41 - and this is typically provided by
30:43 - mongodb the company itself so pymongo is
30:46 - no different it's this low level
30:49 - foundational way to talk to mongodb and
30:52 - you do this in the native query syntax
30:54 - of
30:55 - mongodb this javascript json style of
30:58 - interacting with the database now it's
31:00 - important to know that if you're working
31:01 - with mongodb in terms of running and
31:03 - managing it but from writing code we're
31:06 - going to focus on something higher level
31:08 - and odm so we can take structured
31:10 - classes and map those to and from the
31:12 - database so let's see how it would work
31:14 - if we just use pymonga so we've got our
31:16 - app here and we have the pi
31:18 - package we're going to work with and we
31:20 - have mongodb the database so we write
31:22 - direct queries in this raw mongodb api
31:26 - so you have to know the api really
31:27 - carefully you have to map those back to
31:29 - your classes basically what you do is
31:31 - you pass dictionaries to pymongo it uses
31:34 - those as part of the query and then you
31:35 - get the dictionaries back it's pretty
31:37 - unstructured but it's very low level and
31:38 - fast with an odm similarly we've got our
31:41 - app and we've got pi and mongodb
31:44 - but we also have another layer the layer
31:46 - that we directly interact with called
31:48 - the odm object document mapper and
31:50 - there's a bunch of different kinds
31:51 - there's engine there's ming
31:53 - there's kit there's alchemy
31:56 - mini and there's more than that
31:58 - actually there's a ton of them just so
32:00 - happens we're going to use engine
32:01 - one of the more popular and well
32:03 - polished ones i think so in this model
32:05 - we don't query in terms of raw
32:07 - dictionaries against pymongo we just
32:09 - talk to the classes defined by the odm
32:11 - and our queries are based on those types
32:14 - on those classes that itself will
32:16 - translate to the mongodb api sometimes
32:19 - in real basic ways sometimes really
32:20 - advanced ways and it will actually
32:22 - leverage some of the advanced operators
32:24 - the dollar operators if you're familiar
32:26 - with them for mongodb like dollar set
32:28 - dollar add to set things like this so
32:30 - really really cool that it leverages the
32:33 - advanced operators not just you know
32:36 - save this document read this document
32:37 - type programming i think the odm model
32:40 - is a much better way to write your
32:41 - application you'll see there's not much
32:42 - structure in a schema-less database so
32:46 - having a little bit of extra structure
32:47 - defined by these classes that are part
32:50 - of this odm model really adds a lot of
32:52 - safety to your application in my opinion
32:54 - the odm we're going to use for this
32:56 - course is engine and you can find
32:58 - its home page and details about it
33:00 - documentation and so on at
33:02 - mongoengine.org so engine is open
33:04 - source like many things you'll find in
33:06 - python as we said it depends upon pi
33:08 -  you saw us install it earlier we
33:10 - just did pip install engine and
33:13 - that installed pymongo along with it we
33:15 - did that through the requirements file
33:16 - but you can do that directly if you
33:18 - prefer you can find engine on
33:20 - github you can see that it's quite
33:21 - popular almost 2 000 stars this is much
33:24 - more popular than the other mongodb odms
33:28 - as far as i can tell look into other
33:29 - ones this is definitely the most popular
33:32 - or at least among the most popular of
33:34 - them and it's very actively under
33:35 - development i just took the screenshot
33:37 - right now before i started recording
33:39 - here to give you the latest version you
33:41 - can see that it's been updated in the
33:43 - last 24 hours some other stuff under the
33:47 - actual code has been updated in the last
33:50 - 21 hours so very active this is
33:52 - important for an open source project
33:54 - you're going to depend upon so i think
33:55 - you know judging by that engine is
33:57 - the best choice and the api is excellent
33:59 - we're going to start working with it
34:00 - next the first thing we need to do to
34:02 - start working with engine is tell
34:04 -  engine how to speak to mongodb
34:07 - let's go back to our snakebnb app we've
34:09 - been working on and we're going to go in
34:11 - here to this data section and we're
34:13 - going to create a new file new python
34:15 - file called setup so in here we're
34:18 - going to write a simple method that we
34:20 - can call from other places and as you'll
34:22 - see in the slides that we look at later
34:25 - for real applications that use proper
34:28 - connections encryption accounts things
34:30 - like that this can be a little more
34:31 - complicated but it's going to start out
34:32 - pretty simple so we'll say global init
34:35 - and in here we just want to call one
34:37 - function so we're going to have to have
34:39 -  engine here so we'll import
34:42 - engine and we just say mongoengine dot
34:44 - register connection and the first thing
34:46 - that we pass is an alias so i'll be real
34:48 - explicit say alias equals core now what
34:51 - is this alias thing about we can have
34:53 - multiple connections to even multiple
34:55 - databases or even multiple database
34:56 - servers
34:58 - registered here so we could have like a
35:00 - core
35:01 - data and say analytics for just
35:03 - analytics that goes to a separate
35:04 - database that maybe has tons more data
35:06 - because it's like page views and actions
35:08 - and so on but we might keep that
35:10 - separate so we can back it up on a
35:11 - separate schedule something like that
35:13 - and then we need to set the name of the
35:15 - database and we'll set that to snake bnb
35:18 - do a quick format here and it's all good
35:20 - to go like i said this gets more
35:22 - interesting in real connections but
35:24 - we're going to need to
35:25 - call this to talk to mongodb so let's go
35:28 - over to your little program and you saw
35:30 - up here at the top there was this to do
35:31 - set up engine global values and
35:33 - that was basically what we were doing
35:35 - there so we need to come over here and
35:37 - say we need to go to data dot
35:39 - setup as we'll just call a setup
35:42 - and this should be pretty simple manga
35:44 - setup dot global init now we just need
35:46 - to make sure we call this once in our
35:48 - application and we need to do this
35:49 - before
35:51 - we actually interact with anything else
35:53 - so let's go and apply these settings
35:55 - over
35:56 - to our entities as well
35:58 - so we'll look at snakes first now this
36:01 - model is going to be mapped into
36:03 - one or more of those databases well one
36:05 - among many potential databases so the
36:08 - way that we can tell it how to work
36:10 -  engine will use a property we can
36:12 - add to it we can say meta equals and we
36:14 - give it a dictionary and we can say db
36:16 - underscore alias and we'll say core here
36:19 - okay while we're at it let's say
36:20 - collection
36:21 - is snakes so even though we called it
36:24 - capital s snake the thing in the
36:26 - database where these records these
36:28 - documents are stored will be called
36:29 - snakes plural lowercase and here we can
36:32 - tell it this goes into the core database
36:34 - unlike maybe the analytics one or
36:36 - something like right we're only going to
36:37 - have one in here but for our example you
36:39 - want to have this here so in case you
36:41 - want to add more later right i'll go
36:42 - ahead and add the rest of these to
36:44 - owners and cages but not bookings
36:47 - because bookings is going to be nested
36:49 - inside here all right so we don't need
36:51 - to tell that how it gets stored because
36:52 - it's stored alongside cage which will
36:55 - say cages and
36:57 - no surprise owners all right so those
36:59 - are our three top level entities that
37:00 - map to our three top level collections
37:02 - in mongodb now we've registered the
37:04 - connection by using our setup
37:06 - global which we just call registered
37:08 - connection like i said this can get way
37:10 - more complicated in reality and then we
37:12 - just go and we set this meta to use the
37:14 - core connection as well as naming the
37:16 - actual table or collection it's going to
37:18 - go to let's take a moment and look at
37:20 - this concept of registering connections
37:22 - we're going to need to work with moggle
37:24 - edge and so of course import
37:26 - engine and we need to set the alias and
37:28 - the name of the database so it should
37:30 - say engine.register connection
37:32 - give it the alias give it the name we
37:33 - need to call this before we start
37:35 - interacting with our classes and other
37:37 - types before we try to do any queries or
37:39 - save any data this has to be all set up
37:41 - so this is what we wrote in our
37:42 - application and this works fine when
37:43 - you're talking to the local mongodb
37:46 - running no encryption no accounts
37:48 - default port running on the local
37:50 - machine same machine as this code now if
37:52 - you're doing this in production
37:54 - there's more to it all right you need to
37:55 - set the username and password which you
37:57 - have to set up in mongodb there's none
37:59 - by default so you've got to set that up
38:01 - with the right permissions probably it's
38:02 - a different server on an alternative
38:04 - port so set the host in the port you
38:06 - would like to create a some sort of
38:08 - admin account which is associated with
38:10 - that username and password so you say
38:12 - look you authenticate an admin use this
38:14 - mechanism and finally if you're going to
38:16 - do connections across you know somewhere
38:19 - outside your data center you pretty much
38:20 - should just turn this on is you need to
38:22 - turn on ssl and configure the server for
38:24 - ssl and then you pass that additional
38:26 - data in addition to the alias and the db
38:29 - now there's a lot going on here and
38:31 - deployment and running mongodb in
38:33 - production is not as simple maybe as it
38:35 - could be certainly it's something you
38:37 - need to be very careful about like no
38:39 - authentication no encryption
38:41 - right don't run your code that way it's
38:43 - fine to do it for development but don't
38:45 - do it for production in my full mongodb
38:47 - course i actually go in to spend an hour
38:49 - go and create a linux server and set it
38:51 - up in a cluster of the database and the
38:54 - web servers and those kind of things and
38:56 - really make this work perfectly and
38:58 - safely but in this course we're not
38:59 - going to go into it i just want to leave
39:00 - you with you need to set this up you can
39:03 - look at the mongodb.org site as well or
39:05 - mongodb.com site and go through the
39:07 - documentation on some of the steps or
39:09 - just take my other course if you're
39:10 - really going to go and use this in
39:12 - production
39:16 - so far we've modeled our data with
39:17 - python classes but there was no real
39:19 -  engine entity stuff they wouldn't
39:22 - actually be saved or processed by
39:24 - engine just happens to be we kind of
39:26 - sketched them out in python class style
39:28 - so we're going to change that now we're
39:29 - going to go make our standard plain old
39:31 - python classes proper engine
39:34 - entities snake is pretty simple so let's
39:36 - start there so in order to work with
39:38 -  engine over here i'm going to have
39:39 - to import
39:41 - now you might want to
39:43 - do from engine import some things
39:45 - but i like to be real explicit like
39:47 - these things are coming from
39:48 - engine even in my production code so
39:50 - this is how i'm going to do it and we're
39:51 - going to set the register date to a
39:53 - particular type of descriptor that comes
39:56 - from engine and at sort of the
39:58 - type level this tells engine what
40:00 - type of data and constraints and
40:02 - requirements go onto this field however
40:05 - at runtime it's going to act like say a
40:07 - date time or whatever it is in this case
40:09 - the date time and species would be
40:10 - string and so on so we'll come over and
40:12 - say engine dot date time field and
40:15 - we'll just go like this so this will
40:16 - tell engine to map that to the
40:18 - database as a date time field over here
40:20 - we'll say engine dot string field
40:22 - and over here the length let's say this
40:25 - is in meters and that's probably decent
40:27 - enough floats right so this will be a
40:29 - float field the name again a string
40:31 - field whether it's venomous or not
40:33 - that's true or false um i guess it could
40:35 - be a number like level of venomous i
40:37 - don't know but we're going to call this
40:38 - a boolean field and that's that so our
40:41 - snake is all ready to map into mongodb
40:44 - mongodb doesn't have things like
40:45 - required fields or default values or
40:48 - anything like that but engine does
40:50 - so let's change this to make it a little
40:52 - simpler to create a snake so for example
40:54 - registered date is almost always just
40:56 - whenever you inserted it right so what
40:58 - we can do is we can come over here and
40:59 - set a default function that will execute
41:01 - any time engine inserts a new
41:03 - snake so we're going to start with date
41:05 - time so the function that we want to
41:06 - call is the now function which gives us
41:09 - a full year month day hour minute second
41:12 - representation of time so we'll come
41:13 - down here's a
41:15 - daytime.datetime.now and be very careful
41:17 - not to put the parentheses you're
41:18 - passing the function not the value of
41:21 - now that would be like when the program
41:22 - started so that can be a little tricky
41:24 - over here for species let's say that you
41:26 - have to save the species so we can say
41:28 - this is going to be required is true in
41:30 - fact the length is required the name is
41:32 - required whether it's venomous is
41:34 - required we could have things like um
41:37 - minimum values have to be like
41:39 - 0.001 or you know things like this right
41:42 - so you can't have like a negative length
41:43 - there's a lot of cool constraints that
41:45 - we can do with our types here so this
41:47 - snake is now ready to be used in our
41:50 - database let's look at the next one
41:52 - let's work on the cage next so again
41:54 - import engine
41:56 - we'll use that in a few places this is
41:57 - exactly the same here so set the default
42:00 - and then the name is just going to be a
42:02 - string and so on so i'll just sketch
42:03 - these out for you
42:05 - so these seem like reasonable types here
42:07 - and let's go ahead and set the required
42:09 - properties for things that we
42:11 - require
42:12 - so most of these will be required
42:14 - and whether or not we allow dangerous
42:16 - snakes if you don't set that let's say
42:18 - no by default you're not going to have a
42:20 - dangerous snake okay so these are just
42:22 - like the snake before this however gets
42:24 - more interesting so we're going to come
42:26 - down here and we're going to set this to
42:27 - be a engine dot embedded document
42:31 - so we could have just a single thing
42:33 - like a booking or
42:34 - a
42:35 - like say embed the snake in the owner or
42:37 - something like that but we want to have
42:39 - a list of embedded documents and what we
42:41 - need to pass in here is the actual type
42:44 - that is contained in there so we're
42:45 - going to import data.bookings.booking
42:48 - one other thing that i also realized i
42:50 - forgot to do in the previous ones we'll
42:52 - go back and fix that is we need to tell
42:53 - mongoengine that this is a top-level
42:55 - document so we need to make this have a
42:58 - base cloud of type document we'll do
43:00 - that for snakes as well
43:07 - now let's go to the booking we were just
43:09 - working with that so this one recall is
43:12 - is the type that's embedded within of
43:14 - the cage it's embedded in the cage that
43:16 - means it's not
43:17 - a document right that would be a top
43:19 - level thing this is an embedded document
43:22 - right so this can be contained within
43:23 - other documents but it itself cannot be
43:26 - top level so let's go ahead and set
43:27 - these as well
43:31 - now when we're talking about ids and
43:32 - mongodb the default is something called
43:34 - an object id like a uuid or good or
43:37 - something and so when we're talking
43:39 - about a reference typically it's one of
43:42 - these it doesn't have to be what it
43:43 - typically is
43:46 - there we go so we've got our two
43:48 - references as object ids we've got our
43:50 - booking date which does not have to be
43:52 - required and it doesn't have a default
43:53 - value this is when it was booked which
43:55 - happens after the booking
43:58 - slot was made available
44:00 - and but at the time of creation of the
44:01 - slot of booking right with like putting
44:03 - up for booking you have to say the check
44:05 - in and checkout date
44:06 - and again the reviews these are not
44:08 - getting set until after i set this to
44:11 - zero so we can say like you know require
44:14 - it to be one to five if they actually
44:17 - rate the thing and then you can sort of
44:18 - exclude the ones that are zero
44:21 - the final one is owner and it's very
44:23 - very similar i'll just sketch that out
44:24 - for you
44:26 - okay so we've got our flat pieces here
44:28 - our register date name and email and now
44:30 - we're gonna have a list of ids so we'll
44:32 - come in here and say mongoengine.list
44:34 - field for both of them
44:38 - so this will let us store the object ids
44:41 - that refer to the snakes and the object
44:43 - ids that refer to the cages last thing
44:45 - to do is make the base class
44:47 - the document here
44:49 - all right so what have we done we've set
44:51 - all the fields to their respective types
44:54 - out of engine as descriptors we've
44:56 - set either default or required values
44:59 - and we've set the metadata which talks
45:01 - about which database connection to use
45:03 - and what to call the collection when it
45:05 - goes into the database and we've done
45:08 - that for our three top level items here
45:11 - the one that is different that stands
45:12 - out is the booking which is embedded
45:14 - within the cage
45:16 - and this is an embedded document
45:18 - but otherwise everything goes pretty
45:20 - much the same
45:23 - let's review the core concepts around
45:25 - creating engine entities
45:27 - we started out by creating what i called
45:30 - basic classes these are classes that
45:32 - could just as easily been mapped to a
45:34 - relational database because they just
45:36 - have flat fields or columns if you want
45:38 - to think of them that way
45:40 - and none of the nested or particular
45:43 - capabilities of document databases so
45:45 - the one that matched that was the snake
45:47 - and the snake we make sure that it
45:49 - derives from mongoengine.document
45:51 - and then we specify the fields by
45:54 - passing along or creating these
45:56 - engine descriptors so we said there's a
45:58 - registered date and that's a
46:00 - engine.datetimefield
46:01 - the length that was a float that was the
46:03 - length of the snake in meters the name
46:05 - of the snake is a string species as an a
46:08 - as a string as well and whether or not
46:10 - it's venomous that's a boolean true or
46:13 - false so you can see we can map out the
46:15 - types for this basic snake class really
46:17 - easily here of course our snake should
46:20 - have default values constraints like
46:22 - required fields and things like that so
46:25 - here we've taken that same snake class
46:27 - and we've added a default value for the
46:29 - registered date we said just call the
46:32 - function
46:33 - datetime.datetime.now anytime you insert
46:35 - a new snake so it's going to
46:36 - automatically tag that new entity or
46:39 - that new document with the date in which
46:41 - it was inserted now remember be super
46:43 - careful did not call the function now
46:45 - but pass the function now
46:48 - okay we also set the length to a float
46:50 - we said that's a required float you have
46:53 - to specify the length or
46:55 - you know engine will give you an
46:56 - error so you can't insert this thing
46:57 - that field is required it's interesting
46:59 - that that's not a feature of mongodb
47:01 - that's a feature of engine so by
47:03 - using engine instead of say
47:05 - pymongo we get these additional features
47:07 - same for the default and name species
47:10 - and venomous also these are all required
47:12 - so we can do this here now again this is
47:14 - still one of these sort of basic classes
47:16 - with just our constraints and defaults
47:18 - let's look at the cage the cage is more
47:22 - takes better advantage of the document
47:24 - database
47:25 - so we have the name the price the square
47:27 - meters required standard stuff there we
47:30 - also have the bookings these are either
47:32 - the times in which a cage could be
47:34 - booked or an active booking where snake
47:37 - has registered
47:38 - to be there on a certain time
47:40 - we modeled that through the booking
47:41 - class and we said this cage is going to
47:43 - embed the bookings into it so to do that
47:46 - we use the engine embedded
47:48 - document list field so a list of
47:51 - embedded documents and the argument we
47:53 - pass is the type of embedded document so
47:56 - it's a
47:57 - booking that we're putting into this
47:58 - list
47:59 - all right now how does this look if we
48:02 - populate this cage and we add a couple
48:04 - of bookings and we call save well it
48:05 - looks like this
48:07 - it has the standard fields right like a
48:10 - auto generated underscore id the date
48:12 - that was registered this is set as the
48:14 - default value in the full class
48:16 - we have the name the price the square
48:19 - meters and so on so that's all standard
48:20 - stuff and we've seen that before
48:22 - but the bookings part check that out so
48:25 - we have bookings and it's a list right
48:27 - square brackets technically an array in
48:30 - javascript right and the items in this
48:33 - list
48:34 - are those bookings so we have a check-in
48:36 - date checkout date and the ratings so
48:38 - we've have added two bookings in here
48:41 - now we didn't fill out the they're not
48:43 - booked so we don't have a guest snake
48:44 - and an owner id
48:47 - and they haven't already taken them so
48:48 - they haven't rated it or given a review
48:50 - so some of the pieces are not saved into
48:52 - the database to save space nonetheless
48:54 - here we have our embedded bookings
48:57 - inside of our document and we did that
49:00 - through the embedded document list field
49:03 - we have our models our classes in place
49:06 - we have engine registered and told
49:09 - to connect to the default values for all
49:11 - the local stuff for mongodb running
49:14 - locally i already have mongodb started
49:16 - up and running check out the
49:18 - documentation on how to get that working
49:20 - on your operating system like i said at
49:21 - the beginning
49:22 - and it's time to create an account log
49:25 - in basically start implementing all
49:27 - these actions and now we'll really get
49:30 - to start programming with the entities
49:32 - we've designed in engine so let's
49:34 - begin
49:35 - by going down here to create account in
49:38 - program host so we're going to be able
49:39 - to use this for actually both the host
49:41 - and the guest
49:43 - right so you can see there's a couple
49:44 - things we have to do and then we're
49:45 - going to create the account so let's
49:47 - work on this get name and email first
49:48 - we'll say name equals and we'll just use
49:50 - simple input stuff
49:53 - what is
49:54 - your name something like this
49:56 - and we'll do email
49:59 - email we should of course have them you
50:01 - know give us a password and things like
50:03 - that but this is not a real website
50:04 - we're not really actually
50:06 - logging in it's just sort of a user
50:08 - creation type thing
50:09 - so we're going to create the account now
50:10 - i could go write the engine code
50:13 - to talk to and do the inserts here
50:15 - but you'll see that we can do much much
50:17 - better if we isolate all of these
50:19 - behaviors
50:21 - within a central location that we can
50:24 - use throughout our application
50:25 - in these nosql databases these document
50:28 - databases there's
50:30 - not much structure in the database
50:32 - so we already have some structure added
50:34 - by having our classes our engine
50:36 - types that we work with but we can also
50:39 - do a little bit better by having like a
50:41 - centralized data access piece
50:43 - so that's what we're going to work with
50:45 - here let's go create something called a
50:48 - data service
50:49 - and we'll just put a bunch of functions
50:51 - that we need to work with here so let's
50:54 - go back and let's import this and i'm
50:56 - going to import it in like a little
50:57 - short way so we'll say import
51:00 - services dot data service as svc okay
51:04 - we're just going to use the functions
51:06 - out of that module by calling it that so
51:08 - we come back down here
51:09 - so to say not implemented let's say this
51:14 - say svc.create an account
51:17 - and we're going to pass the name and the
51:19 - email
51:20 - what we're going to get back is an
51:22 - account so we want to actually store
51:24 - that
51:26 - in in the statefulness of our
51:28 - application again in a web app this
51:29 - would be with cookies and we get it back
51:31 - from the database every time but
51:33 - we have this state thing which has an
51:35 - active account
51:37 - so
51:38 - what we're going to do is we're going to
51:39 - come over here and we're going to say
51:41 - state
51:43 - dot active account
51:44 - equals this so we're going to get back
51:46 - an account from here now pie chart says
51:49 - whoa there's something going on here
51:51 - there's no account there's no method
51:52 - called create account function but if i
51:55 - hit
51:56 - alt enter
51:57 - then it'll say you want to create one of
51:59 - course we want to create one so name
52:01 - let's even give this a little bit of
52:03 - typing type hints here say it's going to
52:05 - return
52:06 - an owner
52:09 - okay
52:10 - so that's all well and good now we need
52:12 - to use this so now we get to programming
52:14 - with engine how do we create one
52:16 - of these owners well how would you do it
52:18 - if it was a regular
52:20 - class you would say this
52:23 - and you would set some properties like
52:24 - name equals name owner
52:29 - email is that and now we want to put in
52:31 - the database so we do that by calling
52:33 - using uh what's called the active record
52:35 - design pattern we'll just call save
52:37 - right on this now we want to return
52:39 - owner
52:41 - now the
52:42 - important point here is when we call
52:43 - save all the default values are set when
52:46 - we call save the primary key the
52:48 - underscore id is automatically generated
52:51 - here it's just dot id
52:53 - at engine but in the database
52:54 - level underscore id that's automatically
52:57 - set so this thing is up and running we
52:59 - should have everything
53:00 - working well here
53:02 - so let's go ahead and try to run this
53:04 - and see if everything's hanging together
53:06 - let me run it over like this
53:11 - so here's our snake b and b we're going
53:12 - to go and say we're a host notice at the
53:15 - prompt here this little yellow thing
53:18 - there's no
53:19 - name so we'll go and create an account
53:21 - with my name my name is michael and my
53:23 - email is michael talk python.fm
53:27 - boom logged in you can see
53:29 - now the prompt has my logged in name
53:32 - the next thing we've got to do let's
53:34 - just go from top to bottom let's go and
53:36 - log in however there is a problem what
53:38 - if i say i want to create an account i
53:40 - say my name is michael two
53:42 - and i say it's michael at talk
53:46 - python.fm if i hit enter there's just
53:48 - two of those that's bad
53:51 - so
53:51 - what we want to do is we want to do a
53:53 - little check over here
53:57 - so this is great we got this working and
53:58 - let's go ahead and annotate the type
54:00 - here as well let's say this is an owner
54:04 - that's going to let us when we interact
54:06 - with it later say things like this and
54:09 - get you know
54:10 - all the intellisense and whatnot snake
54:12 - ids and whatever
54:13 - okay now before we do this we want to
54:16 - verify that the account doesn't exist so
54:18 - we'll say
54:19 - old account so let's say find an account
54:22 - by email and again this doesn't exist so
54:24 - we'll create this function over here
54:27 - this will let us see how to query all
54:29 - right so to insert we create one of
54:31 - these and we call save
54:33 - to do the query we're going to do like
54:36 - this we'll say owner equals we work with
54:39 - the type and we say objects now
54:42 - there's a couple of things we could do
54:43 - we could say filter kind of lose
54:45 - autocomplete here but that's fine we
54:47 - could say filter and we could say email
54:49 - equals email
54:50 - okay
54:51 - so we would match one of the fields
54:54 - there all right and we would not put
54:56 - that of course
54:57 - and this is going to return a query and
55:00 - we want just one of them so we'll say
55:01 - first
55:02 - now it turns out when you have just one
55:04 - filter statement you can actually
55:06 - condense it down like this so we'll go
55:08 - ahead and write that and we'll just say
55:09 - return owner okay so there's our find
55:11 - account by email
55:13 - and we'll check
55:16 - if old account
55:17 - it'll be none if it's not found so if
55:20 - there's an old account we'll print
55:22 - i wrote a few functions error message
55:25 - success message with some coloration
55:26 - we'll say
55:28 - error
55:30 - account with email already exists
55:33 - and let's make this a cool
55:35 - python36f string
55:40 - like so
55:42 - of course we want to bail we don't want
55:44 - to actually create it here we could
55:46 - maybe do something like that print let's
55:48 - do the success
55:52 - created new account with id
55:56 - and let's say state.activeaccount.id
56:00 - like so great let's just run this one
56:03 - more time
56:08 - so we're going to come in as a host
56:10 - we'll create an account let's call this
56:12 - um call it sarah so sarah wants to come
56:14 - in maybe she's going to be able to like
56:16 - she's going to be a guest
56:18 - but right we're going to use
56:20 - this host path to do it for a second
56:21 - there so
56:23 - sarah talk python.fm
56:26 - great we've created a new account now
56:28 - let's just test this thing again so
56:30 - we'll say i want to create an account
56:32 - again
56:33 - sarah doesn't actually matter let's say
56:36 - susie and it's sarah talk python.fm this
56:40 - should no longer work it should go and
56:42 - query the database and find this and no
56:44 - no no error an account email sarah talk
56:47 - python already exists perfect
56:49 - i think the create account is done
56:55 - so we saved some data and it looked like
56:57 - it went into the database
56:58 - right when we successfully saved it we
57:00 - saw an id was generated we tried to log
57:02 - in with the same or creating account the
57:04 - same email we got an error new node that
57:06 - already exists so it's definitely
57:07 - working but let's look at the data with
57:10 - my favorite tool for working with
57:12 - mongodb
57:13 - robo 3d it used to be called robomongo
57:16 - robo3t so here it is and you can see
57:19 - just by virtue of calling save that
57:21 - actually connected to the database
57:23 - created
57:24 - this particular connected to the server
57:26 - created this database and the various
57:28 - collections we only called save on
57:30 - owners so we only have owners so far
57:33 - never mind the fact that we've created
57:34 - the other types we haven't saved
57:35 - anything there so it doesn't exist
57:38 - and we can come down here and we can say
57:39 - view documents and we actually have the
57:41 - two documents here remember we created
57:43 - two accounts and we can view them this
57:45 - way
57:46 - and there you go we have michael and my
57:48 - email sarah and her email the registered
57:51 - dates and times and we no longer we we
57:53 - don't yet have a snake or a cage because
57:56 - well we haven't implemented the ability
57:57 - to do that but we're going to have snake
57:59 - id and cage ids in here as we create
58:01 - these snakes and cages
58:03 - this is a really great way to work with
58:05 - the data if you go back to this mode you
58:07 - can even
58:08 - edit it and make changes in here if you
58:10 - really wanted to
58:11 - all right so definitely recommend
58:14 - installing this it works on all the
58:15 - platforms it's free and it's awesome
58:18 - we're able to create our account so
58:21 - let's now add the ability to log in once
58:23 - we exit the application so we're over
58:25 - here in the log into account and the
58:27 - program hosts this is super easy we just
58:29 - have to get the email from the user
58:32 - like this so we'll say something to the
58:34 - fact of
58:35 - the login asking what their email is and
58:37 - let's go ahead and do a strip
58:40 - and a dot lower on this and in fact
58:42 - let's always store that so i'll go back
58:44 - up to our create account and do that
58:46 - here so strip takes all the white space
58:48 - in case there's like a space or
58:49 - something on the end and lower of course
58:51 - makes it lower case
58:53 - so then we just need to see if the
58:55 - account exists well we actually already
58:57 - wrote that so let's say this
59:00 - say the account is
59:02 - the service not find account by guesting
59:05 - email
59:06 - and then we'll say we add a little error
59:08 - handling say if not account
59:11 - say error message
59:14 - so nothing there and if it worked all we
59:16 - have to do is save it and maybe say
59:18 - you've logged in yay
59:20 - so
59:21 - let's
59:22 - say state
59:23 - dot active account
59:25 - is account
59:26 - and then we'll do a success message
59:30 - logged in successfully
59:33 - and then our little prompt will change
59:34 - straight away so that should be good
59:36 - let's try this
59:40 - come over here to the host let's try to
59:43 - log in
59:44 - and remember there's no real passwords
59:46 - we're just sort of playing around with
59:47 - accounts here so michael at
59:49 - talk python.fm
59:52 - boom logged in successfully awesome and
59:54 - you can see the prompt changed let's try
59:56 - to log in again i'll try to just use
59:58 - jeff j.com nope could not find email
60:01 - with jeff
60:02 - j.com looks like
60:05 - login is working
60:08 - next thing we need to do as the host is
60:09 - to be able to register our cage so then
60:12 - people can view it and maybe book it
60:14 - that'd be great right so let's go over
60:17 - here and work with that now the cage has
60:19 - to be associated with an owner through
60:21 - this soft forum key relationship in
60:23 - mongodb
60:24 - so we're going to require an account and
60:26 - that's going to look like just an error
60:28 - message so like something like this
60:32 - so we'll just say if there's no account
60:34 - you must log in first to register a cage
60:36 - all right so now we know we have the
60:38 - account we're going to use that as part
60:39 - of it and let's go ahead and figure out
60:41 - how many square meters this is going to
60:44 - be so we'll say meters equals something
60:47 - like this
60:54 - now you might want to just directly
60:55 - convert that into a float but i found as
60:57 - i was interacting with this application
60:59 - like i'd accidentally like go to
61:01 - register a cage and i meant to list them
61:03 - you want some kind of way to cancel out
61:04 - so let's just suppose if they don't
61:06 - enter anything they just hit enter it
61:07 - kind of short circuits everything so
61:09 - we'll say if not
61:13 - something like this so if they don't
61:15 - enter anything we'll just bail out so
61:16 - otherwise we'll just say
61:19 - float of meter so convert it from a
61:20 - string to a float we're not doing error
61:22 - handling on this right you guys should
61:24 - probably add that but we're going to
61:26 - just do this and we have to ask a bunch
61:28 - of other questions is it carpeted does
61:29 - it have toys things like that and
61:33 - let me just copy that over
61:35 - because there's no point in seeing you
61:37 - that's typed in it's just user input
61:38 - stuff right
61:40 - and then we want to go down
61:42 - and we want to actually register the
61:44 - cage again we want to do this at our
61:46 - data layer not here in our application
61:47 - code so we'll say svc register cage and
61:50 - again that doesn't exist but it's going
61:52 - to in a second so we are going to pass
61:55 - the account
61:59 - we'll pass the active account here we'll
62:01 - pass the name of the cage
62:03 - we'll pass
62:05 - whether or not it allows dangerous
62:08 - just all of these items whether or not
62:10 - it has toys
62:12 - whether it's carpeted
62:14 - and the meters
62:17 - okay so we're going to go and call this
62:19 - function which obviously doesn't exist
62:21 - yet but
62:22 - by john will write it for us thank you
62:24 - by charm
62:25 - so here we can say this is an owner
62:28 - here's the name and string and so on
62:31 - there we go
62:32 - and let's say this is going to return a
62:34 - cage which we have to import at the top
62:36 - again thank you pyjar
62:38 - so this is very very similar to the
62:40 - create account we're just going to
62:41 - create a cage and save it
62:46 - so we set all the properties and we'll
62:47 - call cage.save and that's going to
62:50 - store it in the database now
62:53 - we want to remember if we look
62:55 - over at our owners
62:57 - it has cage ids to manage the
63:00 - relationship
63:02 - so the order in which we do this is
63:03 - super important now
63:06 - we need to be a little bit careful with
63:07 - this account here
63:09 - we want to make sure that we're getting
63:11 - the latest account from the database so
63:13 - we'll do something like this we'll say
63:16 - account equals
63:20 - find account by email this
63:22 - activeaccount.email see that make sure
63:24 - that we don't have any stale data
63:27 - i'm going to go account dot
63:30 - cage ids this is a list so we can append
63:34 - to the cage dot id now it's super
63:36 - important the order here we must call
63:38 - save so that this is an actual
63:42 - generated value it's just none
63:43 - beforehand so we want to make sure
63:45 - that's generated in the database and
63:47 - then we can return the cage
63:51 - so that little warning up there goes
63:52 - away because we are returning the cage
63:57 - the other thing that we need to do
63:58 - is this has changed the account
64:02 - but we haven't pushed those changes back
64:04 - to the database
64:07 - all right so our register cage seems
64:09 - like it's working let's go over here and
64:12 - let's do one more thing
64:13 - this active account
64:16 - needs to have that data adjusted as well
64:18 - so let's go over here to state and has a
64:21 - reload account that's not written yet
64:23 - let's do that
64:24 - so this is super easy to do all we have
64:27 - to do is
64:28 - go to the database and
64:30 - pull it back so we have this active
64:31 - account global variable
64:33 - and we can come over here and say
64:36 - import the service and here we just say
64:38 - find account by email
64:40 - activeaccount.email
64:42 - all right that's all we got to do to
64:43 - reload it so this will make sure that
64:46 - when we work with our state.active
64:48 - account it's the fresh one that just got
64:50 - its data changed
64:52 - down here
64:53 - let's do one more thing before we carry
64:55 - on let's go ahead and uh implement
64:57 - register
64:58 - cage here and let's spell suppress
65:00 - correctly
65:01 - let's
65:02 - be at the ability to list our cages so
65:04 - that we can test that this actually
65:06 - worked let's also do a success message
65:10 - registered new cage
65:13 - with id
65:16 - make that an f string actually
65:20 - cage.id so we gotta store that up here
65:25 - excellent so now we've got our cage and
65:27 - we'll see that come out but let's go
65:28 - ahead and we're gonna require an account
65:31 - again
65:32 - which is the same info up here
65:38 - and all we've got to do is get the cages
65:40 - so let's write something like this we'll
65:43 - say
65:43 - cages equals service not
65:46 - find
65:47 - cages for user
65:52 - all right go to write that function
65:54 - there we go creates an account let's not
65:56 - call it active account we'll just say
65:58 - account
66:01 - and that is an owner
66:03 - and it returns a cage actually not a
66:05 - cage what does it return it returns a
66:07 - list of cages so we got to go to the
66:08 - typing module
66:10 - here typing
66:12 - and do a cage okay
66:14 - perfect so what we're going to do is we
66:16 - already have the owner and because of
66:18 - our refresh account stuff it should be
66:20 - fresh so we'll have cage ids
66:23 - and we sh we should have this account
66:24 - dot cage ids right there we can use
66:28 - so now how do we query for this
66:30 - particular thing we're going to do
66:32 - something we haven't seen yet so we're
66:34 - going to come to the cage and again
66:35 - we're going to go to this objects i'm
66:37 - going to do the query
66:39 - but instead of saying remember before we
66:40 - had email equals and that did the query
66:43 - against mongodb for testing equality we
66:45 - have something
66:46 - different we need to do we want to go to
66:48 - the id of the cage and we don't want to
66:50 - just say well it's equal to it's not
66:52 - going to be equal to the list right we
66:54 - can't say
66:55 - not cage ids because
66:57 - one is like an object id and one is a
67:00 - list of object ids so we have to use a
67:02 - special operator and mongodb has all
67:05 - these so-called dollar operators
67:07 - dollar set
67:09 - dollar in dollar not dollar or these
67:12 - types of things and the way we work with
67:15 - those in engine is we use a double
67:18 - underscore to say
67:20 - we're applying this to the id but then
67:21 - there's this other thing that we're
67:23 - doing i'm going to say in
67:25 - so this query right here maybe a little
67:27 - cleanup this query says go to the cage
67:29 - and find all the cages whose id is in
67:32 - this list of ids
67:34 - right
67:35 - and now we'll have cages equals this is
67:38 - a query but we want to execute the query
67:41 - and sort of snapshot it for our app so
67:43 - we'll
67:45 - and we'll return
67:47 - cages
67:48 - and that should make our half our app
67:49 - totally happy that little warning went
67:51 - away
67:52 - okay great so we've written this
67:54 - function and we've used the in operator
67:56 - the double underscore to access it
67:58 - here's our cages we just need to print
68:00 - them out 4c in cages
68:04 - and let's make these f strings and we'll
68:06 - come here and we'll say c dot what do we
68:08 - want here we want name
68:13 - let's also print out something like this
68:17 - you have however many length of cages
68:19 - you have and then we'll print those off
68:21 - okay
68:22 - let's try to test these two things that
68:24 - we've written
68:27 - for host we first want to register a
68:29 - cage actually let's try to lister cages
68:32 - ah log in um michael at
68:36 - talkbython.fm and let's list our cages
68:40 - you have zero cages great so let's
68:42 - register a cage now we're logged in at a
68:44 - lettuce
68:45 - it's 2.2 square meters
68:48 - yes it's carpeted yes it has toys no has
68:50 - no venomous this will be
68:53 - bully's cage
68:56 - ah it looks like we haven't set the
68:57 - price hmm we've forgotten something
69:00 - haven't we okay
69:01 - so good thing we tested that here
69:06 - say price and this will be
69:09 - how much are you charging all right
69:10 - let's go add price here
69:12 - price
69:14 - okay so price okay
69:17 - that was kind of annoying that that
69:18 - crashed but it's also cool why is that
69:20 - cool because hey we said the cage must
69:22 - have a price and it didn't if that was
69:24 - regular mongodb that would have just let
69:26 - that happen but because it was
69:28 - engine did not all right let's do this
69:30 - again
69:37 - plus my cages
69:40 - oops list my cages we have no cages
69:42 - let's register arcade do this again
69:50 - how much are we charging and charging 29
69:52 - tonight this is one fancy cage folks
69:55 - boom we've registered a new cage now
69:57 - let's list your cages oh we have one
70:00 - cages well maybe a plurality thing there
70:03 - but bully's cage is that let's register
70:05 - one more cage
70:07 - this is a huge cage it's carpeted it has
70:09 - all the toys and this one's even for
70:11 - venomous snakes this would be
70:16 - the large boa cage who knows and this is
70:18 - 30 39
70:20 - now if we look at our cages we have two
70:22 - cages
70:23 - beautiful so it looks like our
70:24 - registering and our listing cages is
70:26 - working great
70:28 - let's add a bookable time to one of our
70:31 - existing cages we were able to register
70:34 - cages and list them now let's make them
70:35 - available for
70:37 - snakes to stay in
70:39 - so we're going to work on this update
70:40 - availability method here we've got our
70:44 - requirement that you have to have an
70:45 - account because they're your cages whose
70:48 - cages you're going to manage right
70:49 - things like that and we're going to just
70:51 - print out the list cages i've changed
70:53 - that slightly so it has a number i'll
70:55 - show you really quick i'm using
70:57 - enumerate and an index so it says 1 2 3
71:00 - instead of star star star because we
71:02 - want to ask like hey
71:04 - what cage do you want to work with so
71:06 - we're going to add that here and just
71:07 - for the sake of time i'm just going to
71:09 - paste that so it's going to say what
71:10 - cage do you want
71:12 - either you can cancel or it's going to
71:14 - parse that into an integer and then
71:16 - we're going to work with a particular
71:18 - cage so let's go down here and say
71:21 - selected cage oh of course we need the
71:23 - cages let's say cages equals we'll just
71:25 - use our service again
71:28 - get the cages for
71:30 - state.active account
71:32 - and we'll down here get in here and say
71:34 - cages of
71:35 - cage number
71:37 - minus one because we're showing them one
71:38 - two three we've got to convert that back
71:40 - to zero based
71:42 - okay once we've got our cage set we need
71:44 - to get the dates we've selected this
71:46 - cage we'll say the name that you're
71:47 - gonna work with and then we're gonna say
71:49 - enter a date year month day that you'd
71:51 - like to start this available time slot
71:54 - on and for how many days right so i want
71:56 - to start a particular date and make that
71:58 - available for five days
72:01 - now we're using this thing called parser
72:04 - and that comes from date util so python
72:07 - dash date utils module name it's in the
72:09 - requirements already
72:11 - parser is a really sweet way to parse
72:14 - date times it has many many different
72:16 - formats it understands so we're going to
72:17 - use that instead of the built-in date
72:19 - time parsing now once we have this we
72:21 - just need to go and use our service and
72:23 - write another data access method so
72:25 - we'll say add
72:27 - available
72:28 - date and what are we going to pass we
72:30 - have to have the account let's say
72:32 - active account there
72:34 - of the selected cage that we're going to
72:36 - add it to we have to have the start date
72:39 - and the days
72:40 - and let's go ahead and say state.reload
72:43 - account because this might change the
72:45 - account
72:47 - and then we want to just have a little
72:48 - success message like hey good job
72:53 - and f string this
72:59 - okay so now we're down to just pure data
73:02 - access and the interesting part
73:03 - right
73:05 - let's go have pycharm add that function
73:08 - and we'll have a few things here
73:10 - so this is going to be an owner
73:15 - cage date time
73:26 - and it end and it's gonna return nothing
73:28 - okay this looks great so remember what
73:30 - we're adding here is actually a booking
73:33 - and bookings are not top level items but
73:35 - we'll go and create one
73:37 - to get started and we'll say booking is
73:39 - a booking like so
73:41 - and we just got to set the properties
73:45 - this one we've got to do a tiny bit of
73:46 - math here so we'll say start date plus
73:49 - time delta
73:57 - now we want to change the cage and the
74:00 - way it's working probably it's fine to
74:01 - just change the cage and call save but i
74:04 - want to make sure that we absolutely are
74:06 - working with what's in the database so
74:08 - i'll say cage equals
74:11 - actually
74:13 - we can just look it up here i think i'm
74:14 - not sure if we need it again so we'll
74:15 - just say cage dot
74:17 - objects
74:19 - id equals kj id dot first
74:22 - okay then we're going to go over here
74:24 - select cage that was
74:26 - let's change that here
74:30 - again remember the bookings are not top
74:32 - level items they live inside of the
74:34 - cages so here we're going to append the
74:36 - booking here and we call
74:38 - save on the cage
74:41 - not on the booking object right because
74:43 - it doesn't live its own it lives inside
74:45 - the cages
74:47 - here we could return the cage i suppose
74:50 - if we want you know because here's kind
74:51 - of the updated cage we could even
74:54 - tell consumers that that happens
74:57 - i guess we don't need our active account
74:59 - here do we so we can go ahead and drop
75:01 - that and let's just do a quick clean up
75:03 - here get rid of this
75:04 - we're not doing that nothing changes
75:06 - there
75:07 - okay great it looks like we can probably
75:09 - add some time let's go and try to test
75:11 - this out here
75:13 - we're gonna be host we need to log in
75:16 - let's see our cages okay so we've got
75:18 - these two let's update the cage
75:20 - availability the large boa constrictor
75:23 - one is available so that's gonna be
75:25 - number two
75:26 - great we've selected it it's gonna be
75:28 - 2018
75:30 - slash 01.01
75:33 - brand new year
75:35 - cage is available and let's say that's
75:37 - for five days
75:38 - great a date was added let's add one
75:41 - more
75:43 - cool now if we list our cages
75:45 - you can see our low large bow
75:47 - constrictor cage now has two available
75:49 - bookings
75:50 - it has this time for five days and that
75:52 - time for 10 days and neither of them are
75:55 - booked because no guests have come along
75:56 - and actually booked it but
75:59 - it's available and now they can go and
76:01 - ask hey what cages are available for my
76:03 - snake
76:04 - and when they ask
76:05 - this boa cage this large broke age
76:07 - should come up maybe we'll make a little
76:09 - side money why our boa constrictor is
76:11 - not using it
76:13 - so before we finish the host side where
76:16 - you actually can see your bookings and
76:17 - things like that that turns out to be
76:19 - one of the most complex types of queries
76:21 - we're doing in this entire application
76:23 - i want to make sure that you can book
76:25 - some stuff so you can see it so the data
76:27 - comes out when we write it that'll make
76:28 - a lot more sense so let's take a moment
76:30 - and focus on the guest side of the
76:32 - things let people come in log in create
76:34 - an account
76:36 - register their snakes and so on
76:38 - so if we go up to the top to our little
76:40 - switch
76:40 - action thing here
76:42 - notice that i'm using the create and
76:44 - login from host there's no reason to
76:46 - write that code twice we'll just use
76:47 - that one now the thing i want to focus
76:49 - on for a moment is adding a snake and
76:51 - viewing your snake now this is super
76:53 - super similar to what we already did so
76:56 - let's go ahead and just
76:57 - talk through this real quick instead of
76:59 - write it from scratch so just like
77:00 - before we have to have an account we ask
77:02 - a few basic questions like what is your
77:04 - snake's name let them cancel by hitting
77:06 - nothing in the first one get the
77:08 - information about the snake and then we
77:09 - call the function add snake and you know
77:12 - you can see this is very very similar so
77:14 - we're going to get the owner get the
77:16 - owner back and maybe it makes more sense
77:18 - because we've been writing the others
77:19 - like this to go like this we're going to
77:21 - create the snake and save it but
77:22 - remember the relationship between snake
77:24 - and owners is managed
77:26 - by the snake ids inside of the owner so
77:29 - we're going to go get a fresh copy of
77:30 - the owner from the database
77:32 - update that and save it then we'll give
77:34 - back the snake that we just created
77:37 - also we call a quick reload account to
77:39 - make sure the snake ids for some reason
77:40 - if they get reused real quick
77:42 - are in the active in-memory account so
77:45 - that's all it means to create a snake
77:47 - just like
77:48 - creating a cage was
77:50 - so everything is exactly the same there
77:52 - and then to view your snakes we just
77:54 - write the function get me the snakes for
77:56 - the user and then we loop over them that
77:59 - again is very much like the cages
78:02 - we get the owner in this case just to be
78:04 - sure that we have the fresh set of ids
78:07 - there
78:07 - and then we do the id in
78:09 - owner.snakeids and we can call the all
78:12 - function and then convert it to a list i
78:14 - suppose we could probably skip this but
78:16 - either way this is all good
78:17 - so this gives us our snakes and we're
78:19 - going to
78:20 - list it out let's go and just run that
78:21 - to make sure this is all working here
78:23 - this time we're going to be a guest and
78:25 - let's go ahead and log in and this time
78:27 - i want to log in as sarah so sarah is
78:29 - going to be my guest and michael is
78:31 - going to be the person with the cages
78:33 - we'll log in
78:34 - so we're logged in as sarah
78:36 - and let's say i'd like to view my snakes
78:39 - hmm you have zero snakes okay let's add
78:41 - a snake
78:43 - so i have slither
78:45 - and slither is 1.2 meters long this is a
78:48 - large
78:49 - gardener
78:51 - and no those are not venomous so we've
78:53 - created slither
78:54 - and let's add one more snake this is
78:56 - going to be bully
78:58 - and bully is 0.5.4 meters let's say this
79:01 - is a
79:02 - bull snake
79:04 - a no
79:05 - now if we save your snakes there's your
79:07 - two snakes okay so our guest side of
79:10 - registering a snake so that we can book
79:12 - it into a cage
79:13 - and viewing it that kind of stuff is all
79:15 - finished
79:18 - so we have cages we have available dates
79:20 - and gauges and we have snakes
79:22 - time to book a snake into a cage and one
79:24 - of those available dates this turns out
79:26 - to be one of the more complicated things
79:28 - we're going to do in this application
79:30 - and there's a lot of like input and
79:32 - juggling stuff so i'm going to paste a
79:34 - few things here just about
79:36 - asking questions about the dates and
79:38 - stuff and then we're going to go and
79:40 - write the database queries from scratch
79:42 - so let's start here we're going to start
79:44 - by making sure you have an account
79:47 - and then we're going to get all the
79:48 - snakes and make sure you have a snake
79:50 - because having an account is not enough
79:51 - you also have to have a snake you can
79:53 - put into there
79:54 - we're going to ask some questions about
79:56 - when do you want to do this we're going
79:58 - to use python date util to parse that so
80:01 - just like before we're going to do a
80:02 - little error handling to make sure like
80:04 - you're not trying to book some sort of
80:06 - reverse thing like i check in before i
80:09 - check out all right check out before i
80:10 - check in something like this right okay
80:12 - so then the next thing we need to do is
80:14 - find out the available cages and this is
80:16 - where it gets interesting so we're going
80:18 - to write a function called get available
80:19 - cages we're going to take the check in
80:20 - the checkout and the snake
80:23 - oh we also need to figure out which
80:25 - snake you want so first of all let's do
80:28 - a
80:28 - you know enumerate list out your snakes
80:30 - and we'll say snake one the snake two is
80:33 - that and he'll pick the snake okay
80:36 - so
80:37 - take our snakes pick that got our k our
80:39 - time and then we're going to go to the
80:40 - database and find a particular cage
80:44 - that we can work with now that's not all
80:46 - there is to it so this is just going to
80:48 - get us the cages that could be booked
80:49 - and then we have to ask that's this
80:52 - little section right here then we have
80:53 - to let the user pick a cage and we'll
80:56 - find the underlying booking behind it so
80:58 - let's write this function so this is
80:59 - going to be a date time
81:01 - date time and a snake
81:09 - you of course don't have to put the type
81:10 - hints but i find like at the data access
81:13 - layer it's really helpful maybe through
81:15 - you can see it through the rest of the
81:16 - application i'm not doing this but at
81:18 - the data access layer i find it really
81:20 - helpful to say like these are the things
81:22 - that go in these are things that go out
81:23 - this is like how we're working with the
81:25 - database okay so here's where we get
81:27 - down to business we're going to come in
81:29 - here let me move this up for you so we
81:30 - need to do a couple of things we need to
81:33 - find all the cages
81:35 - that have bookings that are not booked
81:38 - between this time and that time all
81:40 - right and we need the snake information
81:43 - because we not all cages allow
81:46 - poisonous snakes and they don't all
81:48 - necessarily fit if i have a 20-foot
81:50 - snake i can't put it into a two-foot
81:52 - cage
81:53 - so let's just do a little quick um
81:56 - rule of thumb to say if your snake is
81:59 - four times longer or more than the cage
82:02 - then the snake can't go into it right
82:04 - stinks can curl up but they can only
82:05 - curl up so much so we'll say something
82:07 - like the minimum size of the cage we're
82:09 - gonna get is snake dot length over four
82:13 - okay so this this is going to be part of
82:15 - our query the date's gonna be part of
82:16 - the query and the whether or not it's
82:18 - venomous or not we're gonna do a few
82:20 - interesting things here this is
82:21 - definitely one of the more complicated
82:23 - queries so i'm going to the cage and
82:24 - we'll say objects
82:26 - and when you have these complex queries
82:28 - i find it's nice to spread this across
82:30 - multiple lines so i'll say dot filter
82:33 - i have multiple filters and these are
82:34 - effectively ands
82:36 - so i'll say square
82:38 - meters now i'd like to say let's say
82:40 - equals min size or greater right just
82:43 - like we saw with the dollar operators
82:45 - about in there's one for greater than or
82:47 - equal and we can say the square meters
82:49 - are greater than or equal to this
82:50 - minimum size but that's not the only
82:52 - thing that we need we also need to go
82:55 - and do another pretty wild thing we want
82:57 - to go to the bookings now remember just
82:59 - refresh over here we have a cage the
83:02 - cage has a bookings field we go to the
83:04 - definition for bookings bookings have a
83:07 - check in date and a check out date
83:09 - we want to work with that how do we do
83:11 - that in engine
83:13 - we come over here and we can traverse
83:15 - that hierarchy with underscores as well
83:17 - so we can say bookings dot check-in date
83:20 - and we want to have
83:22 - the check-in date
83:24 - before or equal to
83:26 - the check-in that was passed right so
83:29 - the time you can check in has to proceed
83:31 - the time this person is checking in
83:34 - then we'll do something similar for
83:36 - check out
83:39 - okay so this is part of the query
83:42 - now if the snake is poisonous we also
83:45 - want to say that they allow poisonous
83:47 - snakes so we'll say this we'll say if
83:49 - snake dot is venomous we need to augment
83:52 - this query so we can do that because it
83:54 - hasn't executed yet it's like the
83:56 - potential
83:57 - to be executed so we can say query
83:59 - equals query dot filter and what
84:03 - does the thing allow dangerous snakes
84:05 - that's what we want to work with
84:09 - equals true
84:10 - because non-dangerous ones can stay in
84:12 - cages that will either allow or not
84:14 - allow dangerous snakes but if it's
84:15 - venomous we have to have this additional
84:18 - criteria
84:20 - and maybe we want to have some kind of
84:22 - order by like we'd like to show them the
84:23 - cheaper ones so let's go like this we'll
84:25 - say cages equals and we'll finalize the
84:28 - query like this we'll say query
84:30 - order by
84:34 - now you don't do this sort of default
84:36 - this named parameter type thing for this
84:40 - i want to order by price and default is
84:42 - ascending so cheapest ones first and
84:44 - maybe you want to see the biggest ones
84:46 - first
84:47 - as well so we'll say square
84:49 - meters
84:51 - like this so we're going to say first
84:52 - order by price lowest to highest and
84:55 - then show us if like the price is the
84:56 - same show us
84:58 - the largest ones
85:00 - at that price level down to the smallest
85:02 - ones
85:04 - excellent so
85:05 - this is pretty much working it turns out
85:09 - it looks like it's going to completely
85:10 - work but it turns out that there's a
85:12 - challenge we're going to run into and in
85:14 - pymongo this is straightforward to solve
85:16 - although i have to use a lot of
85:17 - operators these dollar operators to make
85:19 - it work but i haven't found a good way
85:21 - in engine and so i still find on
85:24 - balance that work with engine even
85:25 - for this query is better but here's the
85:27 - problem what this query is asking you're
85:29 - probably thinking it looks right
85:31 - you know it takes a moment to realize
85:33 - the challenge we're hitting here
85:36 - what this query says is go to the cage
85:38 - and find me the cage with the square
85:40 - meters at least minimum size that's
85:41 - totally fine that works perfectly
85:44 - and it says show me where there's a
85:46 - booking greater than checkout and
85:48 - there's a booking
85:49 - um oops this should be
85:52 - greater than that was almost an error so
85:56 - where
85:57 - there's a checkout date passed equal to
85:59 - or past where i'm willing to check out
86:01 - for my snake
86:02 - the problem is
86:04 - if i have let's say 20 bookings
86:07 - in this cage
86:09 - right i probably want to check one more
86:11 - thing but i can just check it
86:13 - down more we're going to have to do one
86:14 - more bit at the bottom but
86:16 - the problem is what if
86:19 - there's two bookings one that starts way
86:22 - in the past but the checkout is like one
86:24 - day later
86:26 - and then there's another one where the
86:28 - checkout date is way in the future but
86:30 - you can only check in when the day
86:31 - before and these are not the same
86:32 - bookings right there's a booking where
86:34 - the check-in date is before the check-in
86:36 - and there's a booking where the checkout
86:37 - date is after the checkout but those are
86:40 - not the same you need to say there's an
86:42 - individual booking
86:44 - not
86:45 - like some set of bookings where one
86:47 - matches one clause and the other matches
86:49 - the other so the way you do that in
86:52 -  is you say dollar element match i
86:54 - think it's lmatch
86:57 - my element match is the
86:59 - description of the thing so you can say
87:02 - both it must have both of these but i
87:04 - don't see how to do that in engine
87:06 - it seems like it should be possible but
87:08 - uh it certainly is possible for equality
87:10 - but for the these operators plus element
87:13 - match didn't seem to work for me anyway
87:16 - if you figure out feel free to use
87:17 - element match i didn't so i've got to
87:20 - add one more line here and i'm just
87:22 - going to copy that over real quick and
87:24 - we'll talk about it
87:25 - so what we're going to do is we're going
87:26 - to say let's go and actually these are
87:28 - the cages we care about
87:30 - i'm going to iterate over the query
87:32 - which executes it here
87:34 - and remember the cage each cage contains
87:36 - the number of bookings for each booking
87:38 - i want to check that both
87:40 - the check-in is before and the check-in
87:42 - is after
87:44 - and
87:45 - that the snake id is none so it's not
87:47 - already booked during that time so if
87:50 - it's both available
87:52 - and the check in checkout date
87:54 - matches
87:56 - then we can make that part of our final
87:58 - cage there
87:59 - our final cage list okay so
88:02 - and it says it returns this but actually
88:04 - what it returns is a list of cage here
88:06 - we go
88:08 - okay so that's what we got to do if i
88:10 - could get element match to work with
88:12 - greater than less than in engine
88:14 - this would not be necessary you could
88:16 - just straight up
88:17 - run that query
88:19 - but anyway it's not a huge deal remember
88:21 - this set is already filtered down to
88:23 - where
88:24 - significantly right where the check in
88:26 - and checkouts do match it just happens
88:28 - to be maybe one more thing is missing
88:30 - there okay so we're getting the
88:32 - available dates so let's come back to
88:34 - our
88:34 - guests here we've got our available
88:36 - cages
88:37 - now we just have to like show them to
88:39 - the user and let them pick it
88:42 - all right so let's just take some
88:44 - pre-written code for this there are
88:45 - certain number of cages available and
88:46 - we're going to enumerate over them
88:49 - and
88:50 - don't need the average rating right now
88:59 - do like this so we're just going to
89:01 - print out the name the square meters
89:02 - whether it's carpeted and whether or not
89:04 - it has toys we don't want that to be
89:05 - true false let's put that yes or no like
89:07 - more friendly right
89:09 - and if there's no cages sorry there's no
89:11 - cages but if there are we'll ask you
89:13 - which one and we'll pick that out you
89:16 - know zero based of course
89:18 - and finally the final thing to do is
89:19 - going to be book a cage and then
89:21 - actually
89:22 - we'll just give out this nice little
89:23 - error mess this nice little success
89:25 - message saying hey
89:26 - you booked it for this time so
89:28 - last thing to do with this book in a
89:30 - cage is to actually book it
89:34 - so let's go over here
89:36 - apply term write it one more
89:38 - time here and now
89:40 - what we're going to do is we're going to
89:42 - loop over
89:43 - that cage's booking so
89:45 - the way it works is they've selected a
89:47 - cage
89:48 - they haven't selected individual booking
89:51 - so we just have to go one more time over
89:53 - the bookings and go uh let's find a
89:54 - booking within this cage which we know
89:56 - exists because it's in the list and
89:58 - let's assign it to the snake
90:00 - so we'll do something like this we'll
90:02 - come down here and we'll start out by
90:04 - this little booking to nothing just in
90:07 - case
90:08 - for some odd reason we don't find one
90:10 - i'm going to go through and again do
90:11 - this similar test as we did right there
90:14 - right we've got to find the available
90:15 - booking within the cage we know it
90:17 - exists but we got to find it then down
90:19 - here we're going to just set a few
90:21 - things say the booking
90:23 - dot guest
90:25 - and get a little uh intel telesense auto
90:28 - completion if you want
90:32 - set the guest owner id
90:35 - i guess we've probably got to pass the
90:37 - account as well
90:40 - we'll say
90:42 - countdown id
90:44 - say booking dot
90:52 - set the booked date it was booked right
90:54 - now regardless of when the booking was
90:58 - and we also need to set the snake
91:05 - there we go and
91:07 - then we got to go back and save it but
91:09 - remember don't call save there we call
91:11 - cage.save okay
91:13 - excellent now i think it just believes
91:15 - that's a misspelling but i'm going to
91:17 - say it's not
91:18 - all right so that should let us book a
91:20 - cage
91:22 - that was a tough one right so
91:24 - pretty interesting query we're using the
91:26 - operators greater than less than we're
91:29 - traversing the hierarchy
91:30 - and uh like i said we're
91:33 - sort of effectively in memory applying
91:35 - this element match match works in
91:37 - engine but i couldn't get it to work
91:39 - with both element match and the
91:41 - operators so anyway this will be fine
91:45 - come down here and
91:47 - given a cage we'll pull out the booking
91:49 - we probably could structure it slightly
91:50 - differently so we could skip this step
91:52 - and somehow capture the booking directly
91:54 - but this is fine it works plenty fast
91:56 - for what we're doing set the
91:58 - hey you booked it values of the booking
92:00 - and call save all right i think it's
92:03 - time for us to test our our bokeh
92:05 - booker cage and i noticed i almost
92:08 - forgot to add this here
92:10 - state.activeaccount when i added it
92:11 - below so let's go and run this
92:15 - we'll come in here and we'll be whoops
92:18 - be a guest
92:19 - and let's go and log in
92:24 - and let's
92:25 - see our snakes we have these two snakes
92:26 - neither of them are venomous let's book
92:28 - a cage
92:29 - i'm going to start by booking this now
92:31 - how do i know that date because over
92:33 - here
92:35 - we have
92:36 - two available bookings for the large boa
92:38 - cage
92:39 - and
92:40 - these times one to six in january so
92:43 - we'll go to let's say two to four should
92:45 - be fine
92:46 - got this
92:48 - four
92:50 - and it says which snake remember we it
92:52 - matters the size of the cage and snake
92:54 - as well as whether it's venomous so
92:56 - we'll pick slither
92:58 - and hey look the one cage is here let's
92:59 - say all right let's book it
93:02 - we've successfully booked the large boa
93:05 - all right
93:07 - now we haven't written view your
93:09 - bookings
93:10 - but we do have that i believe
93:13 - we might have that for the other one
93:15 - go over here as a host and we log in as
93:17 - michael
93:18 - i think we might not have implemented
93:20 - this as well but we can list our cages
93:24 - yes there we go we can see that we have
93:26 - two cages bully's cage and large boa and
93:30 - look at that one somebody has booked
93:33 - this one this slot for the large bow
93:35 - cage yes so it looks like that worked
93:38 - successfully just like we expected
93:41 - all right we're down to the very last
93:43 - thing we're going to do as a guest which
93:44 - is to view our bookings we were able to
93:47 - book a cage but as a guest we couldn't
93:49 - see he you know can't say what are your
93:51 - upcoming stays for your snakes and
93:52 - things like that
93:54 - so again just for the sake of time let
93:56 - me go over here and put some pre-written
93:58 - code and we'll go write the data access
94:00 - layer
94:01 - so require an account and we're going to
94:04 - call get bookings for user and this is
94:06 - going to return a set of bookings and
94:08 - just to remind you what that looks like
94:11 - the bookings are going to have the date
94:13 - possible reviews the snake id is going
94:16 - to be really important so what we want
94:18 - to do is we want to say give us the
94:20 - snake given a snake id
94:23 - and a super simple way for us to do that
94:25 - is to actually just generate a
94:27 - dictionary using a dictionary
94:29 - comprehension so this little expression
94:32 - here is going to create a dictionary
94:34 - where the key is the id and the value is
94:36 - the snake for all the snakes belonging
94:39 - to us whoever the logged in user is
94:41 - then when we get the bookings and we'll
94:43 - this is the part we're going to write
94:45 - and then we're going to loop over here
94:47 - and we're going to print out hey
94:49 - the snake i'm going to use the
94:50 - dictionary lookup to get the name here
94:53 - i'm going to print the cage name
94:56 - and
94:58 - need an import date time there
95:00 - i'm gonna create a date time and
95:02 - do a little bit of math here on the
95:05 - checkout so we're gonna turn this back
95:06 - into days you're checking in on this day
95:08 - for five days something like that
95:10 - okay so that's what our view bookings
95:13 - ui that's pretty much a stretch right
95:15 - with our app but that's kind of a this
95:17 - is kind of the ui code if you will but
95:19 - we've got to write this get bookings for
95:22 - user
95:24 - this is going to be a bson.object id
95:28 - and what we're going to get back
95:30 - is a list of booking i believe now
95:33 - notice one other thing before we write
95:35 - this code
95:37 - over here we're saying b dot cage dot
95:40 - name now cages have bookings but
95:43 - bookings don't have cages there's not a
95:45 - super nice way to create that reverse
95:49 - association in engine
95:52 - so what we're going to do is part of
95:53 - what we're going to do in this function
95:55 - is we're going to set up that
95:56 - relationship
95:57 - and let's call this
95:59 - user id or account id something like
96:01 - that okay so the first thing we need to
96:04 - do is find the owner
96:06 - so call this account equals
96:09 - let's pass in an email instead something
96:12 - like that and before i forget
96:14 - passing the email there okay great so
96:16 - we'll have our account and we've already
96:18 - verified that they're logged in so we
96:20 - can just assume that that happens
96:22 - so we can say booked cages and so we can
96:24 - find all the cages that have been booked
96:26 - by this person so we can say cage
96:29 - not objects
96:32 - and now we'll do a few other interesting
96:33 - things we haven't seen yet say filter
96:35 - and here we'll say
96:36 - bookings double underscore
96:39 - and then we're looking for what let's
96:41 - see the guest
96:43 - owner id let's go to our booking
96:48 - that matches the owner
96:50 - that equals to account
96:52 - dot id
96:54 - we don't actually care about all the
96:56 - details about the cage and you could
96:57 - skip this little part right here but
96:59 - just as as a means of efficiency we can
97:02 - come over here and say only we haven't
97:04 - talked about this yet so what we can do
97:06 - is say we only want to get back two
97:09 - pieces of information not potentially
97:11 - tons of information in this document we
97:13 - want the bookings
97:14 - and we want the name so when we say
97:16 - cage.name above
97:18 - that means something right
97:21 - so let's create the bookings and we'll
97:22 - do this with a list comprehension so
97:24 - we'll say bookings
97:26 - is this i'm going to write in one way
97:28 - and then i have to make a change to this
97:30 - reverse association with the cage so i
97:32 - can say
97:33 - booking
97:35 - or booking
97:38 - in the book cages but remember
97:41 - there are other bookings that are
97:42 - unrelated to us here right it could be
97:44 - two different snakes staying the same
97:46 - cage different days we need a little
97:48 - test
97:53 - all right so this is going to be the
97:55 - bookings that are
97:57 - assigned to us within the cages for
98:00 - which we have booked right so show me
98:02 - all the cages where we've booked at
98:04 - least one of the bookings then we're
98:06 - going to strip out the unrelated ones
98:08 - so you might think that we're kind of
98:10 - done and we're very very close to done
98:12 - but we're not done
98:13 - so if we run this
98:15 - you should see this is going to crash
98:17 - because of that line right there now oh
98:20 - i almost messed this up so this is
98:21 - actually for
98:23 - cage in the book cages and each cage
98:26 - contains a booking so we've got to do a
98:28 - double loop here booking in
98:30 - cage.bookings
98:32 - so what we're going to do is going to
98:33 - take this hierarchical list of cages
98:36 - which inside nested inside them contain
98:39 - a bunch of bookings and we're going to
98:40 - flatten that list with a double loop go
98:42 - through each cage go through each
98:44 - booking and just turn that into a list
98:47 - and across all those bookings across all
98:49 - the cages only show the ones which we
98:52 - some point have booked okay
98:54 - so this is close but if we try to run it
98:57 - this reverse lookup of the cage here is
99:00 - not going to work
99:01 - so
99:02 - let's see we can try to run that real
99:04 - quick
99:05 - save
99:07 - go as a guest log in and sarah
99:11 - now if we try to view your bookings see
99:13 - no cage so let's do a one more little
99:16 - trick we can do a transformation at this
99:19 - level right this is like the select part
99:21 - of the list comprehension now this has
99:24 - to be an expression and
99:26 - i don't think we can do this with a
99:28 - lambda expression because it it doesn't
99:30 - allow us to make modifications so we've
99:31 - got to define this little local function
99:33 - so
99:34 - i'll say map
99:36 - cage
99:37 - to booking
99:40 - given
99:42 - a cage in a booking it's gonna be the
99:44 - silliest thing you've seen booking.cage
99:47 - equals cage
99:48 - well
99:49 - and then we're going to return cage
99:52 - sorry booking so why do we need that we
99:56 - need that so we come down here and we
99:57 - add
99:58 - this function it's going to take a
100:00 - booking and it's going to put that same
100:02 - booking right back into the list but the
100:04 - booking will be changed in that it's
100:06 - going to have a cage associated with it
100:08 - okay so i know that's not super obvious
100:10 - but that's what we need to make that one
100:12 - line work oh wow i made a quick error
100:15 - here
100:16 - uh those i had booking cage
100:18 - here and cage booking there so cage
100:21 - booking gate okay okay
100:23 - looks like it's ready let's try again
100:35 - all right let's view our bookings
100:37 - it works we have one booking
100:40 - our snake slither is booked in the large
100:42 - boa on this days for five days so let's
100:45 - add one more booking just to make sure
100:47 - this is working so book a cage
100:51 - all right so let's try to book that
100:53 - other available booking uh this time i'm
100:54 - gonna put bully in there and i guess
100:57 - we're gonna book that one great if we
100:58 - view our bookings again we now have our
101:00 - snakes booked into the different
101:02 - sections at the different times let's
101:04 - just try one more time now that those
101:06 - bookings should have been used up to see
101:09 - what happens so let's try to book one
101:11 - more cage
101:12 - say we'll start on that date let's check
101:14 - out on that date
101:16 - and we'll use this one sorry no cages
101:19 - both the available slots have already
101:20 - been booked just so happens to be to our
101:23 - snakes awesome it looks like the guest
101:25 - side of things is 100 working
101:30 - we just have one function left to write
101:32 - for viewing the bookings as a host what
101:36 - bookings available booking dates in your
101:38 - cages have been booked and we'll be done
101:40 - with this application so this require
101:43 - account stuff paste that that's the same
101:45 - nothing special there
101:47 - now we want to get the cages for the
101:49 - current user well guess what we've
101:51 - already written that
101:53 - find cages for user state dot active
101:55 - account that's cool so that was already
101:58 - done at some point along the way
102:00 - and then what we need to do is we want
102:02 - to get the bookings
102:04 - and we want actually a flat list of
102:07 - these are all available slots that
102:08 - people have booked across
102:10 - all the cages
102:12 - all right so what we're going to do is
102:14 - something called bookings like this a
102:16 - list comprehension and we're going to
102:18 - use sort of a dual comprehension to
102:21 - flatten it so
102:22 - i'm going to put
102:24 - something here one and two things i'll
102:26 - say what those are for in a minute so we
102:27 - want to say 4c in cages
102:30 - and then for each cage we're going to
102:32 - say for
102:33 - b in c dot bookings
102:36 - now we don't want all of them right
102:38 - there's already a way to see that kind
102:39 - of stuff but what we want is the ones
102:42 - that have been booked we know they're
102:43 - booked
102:44 - if the booked time or the book date was
102:47 - set so say if b dot book date is not
102:51 - none
102:52 - what do we want to get back here we want
102:53 - to get the cage and the booking so
102:56 - we're going to get a flat list of all
102:57 - the bookings and along with it we're
102:59 - going to carry along it's it's book it's
103:02 - cage that it came from
103:03 - so that's pretty straightforward and
103:05 - then that's this part getting them as a
103:07 - flat list and then the last thing to do
103:09 - is just print them out and that's a lot
103:11 - of typing for not a lot of value so
103:13 - let's
103:14 - paste that over
103:16 - we'll import date time
103:19 - and we're going to
103:20 - as we loop over them we're going to
103:22 - unpack that tuple so the cb here gets
103:25 - unpacked into the cb right there and
103:28 - we'll say for this cage it was booked on
103:29 - this date um by so and so
103:32 - all right it looks like this is going to
103:33 - work i have a lot of faith in it let's
103:35 - give it a try
103:36 - we'll come over here we're going to be a
103:37 - host we're going to log in as me
103:42 - and are you ready moment of truth view
103:45 - your bookings
103:46 - no
103:47 - there's no duration in days
103:50 - ah
103:50 - so where did this duration days go
103:54 - so this is the booking let's look at the
103:55 - booking real quick here it has a check
103:57 - in and check out date
103:59 - let's add this duration in days now if
104:01 - we add it as an actual
104:03 - thing that engine saves that won't
104:06 - be so great because it's going to have
104:08 - duplicate data check in checkout and
104:10 - days like they could get out of sync so
104:12 - what we're going to do is we're going to
104:13 - add a property
104:14 - so we have a property called duration in
104:20 - days ah so close
104:22 - days is that the same yes duration and
104:24 - days so down here we just need to use
104:27 - the time delta to figure out what that
104:29 - is so we'll say dt equals self not check
104:32 - out date minus self.check in date
104:35 - and we'll return dt.days
104:37 - all right let's try to run this again
104:41 - oh double double ats come on too much
104:43 - help here
104:46 - there we go all right come in as a host
104:48 - vlog is me
104:49 - oh ready view your bookings
104:52 - beautiful and you can see our property
104:54 - is working just right there so five days
104:58 - and ten days
105:00 - now
105:00 - remember when we actually check we said
105:02 - we're going to book it
105:04 - we could book it for a subset of time
105:07 - we just don't store the data for how
105:08 - long the user said versus how long the
105:10 - time slot was
105:12 - so they kind of get that whole slot and
105:14 - that slot is worth five days and ten
105:15 - days in duration
105:17 - but given the data that we're keeping
105:19 - this is working totally well
105:22 - so i think we've done everything we can
105:24 - create an account log in we can list our
105:26 - cages
105:28 - we can register a cage which we already
105:30 - did we can update the availability which
105:33 - is how we got these slots we can view
105:35 - our bookings which we just wrote
105:36 - and we could even get little help and go
105:38 - back to the main menu and we could check
105:41 - out the guest just one more time around
105:43 - again create login same thing
105:45 - um it says book a cage that's
105:48 - reserve a cage for your snake
105:50 - we saw that we can add snakes oh i gotta
105:53 - log in as sarah she's the one with
105:54 - snakes
105:57 - she has those snakes there she can view
105:59 - her bookings from the perspective of her
106:01 - snake not from the available slots
106:04 - things like that right she only sees her
106:06 - bookings not all the bookings
106:08 - across everything
106:09 - and we go back to the main menu or
106:11 - because we're done we can say goodbye to
106:13 - snakebnb
106:17 - now that we've built our app let's
106:19 - review some of the core concepts we saw
106:21 - along the way
106:22 - if we want to insert an object we just
106:25 - create a standard python object style we
106:28 - just say owner equals owner call the
106:31 - initializer we could either pass the
106:33 - values as keyword arguments or we could
106:35 - say owner.name equals name owner.email
106:38 - equals email
106:39 - and at this moment there is no id
106:41 - associated with this object but then we
106:43 - just call owner.save and now the object
106:46 - id or whatever the
106:48 - primary key is we can set functions to
106:50 - be called when that happens for that
106:52 - generation
106:53 - whatever that's going to be we've got it
106:55 - set after you call save so now you can
106:57 - start working with it as if it came from
106:59 - the database
107:01 - we also might want to insert a bunch of
107:02 - things it turns out if you have a
107:04 - hundred thousand items
107:06 - to insert and you create one save let's
107:08 - create one called save create one called
107:10 - save it's a lot of database back and
107:12 - forth and it's very slow so what you
107:13 - would rather do is create a list of them
107:16 - so here we have a bunch of snakes we
107:17 - want to save we create a bunch of them
107:19 - put them in this list
107:20 - and then you call
107:21 - snake.objects.insert and you give it the
107:23 - list and that's much quicker if you want
107:25 - to do a bulk insert type thing
107:27 - we saw that querying the database is
107:28 - pretty straightforward the way it works
107:30 - is we start with the collection the type
107:32 - that represents the collection we want
107:34 - to work with and then we say dot filter
107:37 - so here we're saying filter and we want
107:39 - to do a match where the email equals the
107:41 - value of the email variable and you
107:43 - could have more than one thing in here
107:45 - you can have more than one filter
107:46 - statement and those basically combine as
107:48 - an and now this would return a
107:52 - potentially a bunch of owners but
107:54 - we don't want a bunch of owners we want
107:56 - the one that we know matches this email
107:58 - so we can say dot first and it'll give
108:00 - us the one or at least the first item to
108:02 - match if there's no no match we get
108:05 - none back we don't get a crash or
108:06 - anything like that
108:09 - when we're querying against just plain
108:11 - straight fields in our object that's
108:14 - pretty straightforward we said email
108:15 - equals the value that we're looking for
108:17 - but if we're looking deep inside of a
108:20 - hierarchy can get a little more let's
108:22 - say not obvious so we're combining two
108:25 - really interesting things here we're
108:26 - going to the cage we're going to search
108:28 - within the bookings
108:31 - embedded document list right bookings
108:34 - was a list and it contains a bunch of
108:35 - these booking objects so the first thing
108:38 - that we're doing is using double
108:39 - underscore say bookings guest snake id
108:41 - so we're looking at the value guest
108:43 - snake id of the booking items within
108:45 - that list
108:46 - and
108:47 - we're also applying the in operator so
108:50 - the double underscore in means the
108:53 - collection on the right
108:55 - we're doing an in test for the various
108:57 - booking snake id
108:59 - so we use the double underscore to
109:01 - separate and navigate the levels and sub
109:03 - documents as well as to apply the
109:05 - particular dollar operators and then
109:08 - what i consider best practice is to
109:11 - fully execute the query before you leave
109:14 - this function if we just return to book
109:15 - cages it kind of still is not yet
109:18 - executed it hasn't quite talked to the
109:19 - database and so i want the database to
109:21 - be done and over with by the time we
109:23 - leave this method so wrapping it in a
109:25 - list will execute all that stuff and
109:27 - pull it back for super large amounts of
109:29 - data there might be reasons you don't do
109:31 - this but
109:32 - for most of them i would do something
109:34 - like this
109:36 - now sometimes you don't want a quality
109:38 - in your matches you want some kind of
109:40 - operator like greater than or less than
109:42 - or
109:43 - in or things like that so here you can
109:45 - see we're going to the cage and we're
109:47 - finding all the cages where the square
109:49 - meter is at least the minimum size so
109:52 - just like with sub documents we use the
109:54 - double underscore and the operator name
109:56 - gte here
109:58 - to actually do this query right there's
110:00 - a bunch of dollar operators you can find
110:02 - them in the mongodb documentation and
110:03 - you apply all of them
110:05 - in this way
110:07 - now the other thing that we're looking
110:08 - at here that we didn't do in our app is
110:10 - count so if we want to know how many
110:12 - cages there were we could say do the
110:14 - query dot count and it'll just do a
110:16 - count in the database rather than pull
110:18 - all the objects back where you do a
110:20 - length of it or something like that
110:23 - the most straightforward way to make
110:25 - changes to a document or to a record is
110:28 - to go get it from the database change
110:30 - the class and call save so in this
110:32 - example we're going to go get the owner
110:33 - out of the database make sure that's all
110:35 - good right don't have errors we're going
110:37 - to create a snake we're going to do work
110:40 - with the snake and then we want to
110:42 - append the snake id
110:44 - onto
110:45 - the owner's snake id collection so on
110:48 - line 11 we say owner.snakeids.append
110:51 - and we give it this new id that was
110:53 - gotten from the snake on line nine when
110:55 - we called save and we save the owner and
110:58 - that's that all right so we get the
110:59 - document we make a change to it in the
111:01 - case of line 11 here and then we just
111:03 - call save and that pushes it back
111:05 - this works but that transfers the entire
111:07 - document out of the database over to our
111:10 - app serial deserializes it processes it
111:12 - and then reverses that back to the
111:14 - database
111:15 - that can be slow but that can also have
111:18 - concurrency issues if two people run
111:21 - this exact same method at almost exactly
111:23 - the same time with the same email
111:25 - address there's a chance
111:27 - that one save is going to overwrite the
111:29 - snake ids of the other right both of
111:31 - them read the owner one makes a change
111:33 - one makes a change one saves the other
111:35 - saves you only have one snake not two
111:38 - so there are challenges with this but if
111:40 - you're pretty confident that that's not
111:41 - an issue you're going to run into this
111:43 - is a really nice and easy way to do it
111:46 - well mongodb and engine let us
111:48 - work with these documents make changes
111:50 - and push them back in there might be a
111:52 - better way
111:53 - so if we know that we want to just
111:56 - change some small part of the document
111:58 - in a very controlled way we might want
112:00 - to use some of the atomic operators so
112:02 - here let's suppose
112:04 - that there's a number of stays
112:07 - field which is an integer
112:08 - in the cage so we just keep track of how
112:10 - many times people have stayed at it
112:12 - now there probably are better ways to
112:14 - get this but let's suppose that is a
112:16 - number and we want to increment it so
112:18 - instead of pulling the cage back and
112:19 - doing a plus equals one sort of thing
112:21 - and saving it we can literally go to
112:23 -  and say increment this number
112:26 - the value of number of stays by one and
112:28 - that could be negative that could be 10
112:30 - but i have 1 here
112:32 - so you write the query dot update 1
112:35 - and then pass the little operator so
112:36 - that's really great now how about this
112:38 - putting the snake id on the owner well
112:41 - we can do that too
112:43 - so over here we're adding a snake we
112:45 - generate the snake we call save that's
112:46 - standard that's an insert but then this
112:49 - line where we have the number of updated
112:51 - we have owner objects emails email and
112:54 - instead of
112:55 - saying you know get it back make the
112:57 - change
112:58 - append it to the snake ids and call save
113:00 - we're doing something with an operator
113:02 - so we're seeing update 1 and we're using
113:04 - the push operator that's dollar push
113:07 - and we're going to push it onto the
113:08 - snake ids
113:10 - collection another thing we might do
113:12 - which probably makes even more sense
113:14 - would be add to set that's another
113:16 - related operator that will say add this
113:18 - id to this set or this list if and only
113:21 - if it doesn't already exist so you won't
113:22 - get duplicates right so we're pushing
113:25 - the snake id on there that way we never
113:27 - pull the owner back these are atomic
113:29 - they're perfectly fine in concurrent
113:31 - situations things like that so this time
113:33 - we have to check that we updated it in a
113:35 - different way but you know the same
113:37 - effect as we saw before
113:40 - so engine supports these in-place
113:42 - updates array operations and set
113:45 - operations so like increment as well as
113:48 - push and these are both better for
113:49 - concurrent safety think of them as
113:51 - basically transactional and they're
113:53 - better in pure performance so they're
113:55 - not always as simple to work with but
113:57 - they are better if you can use them
114:00 - there it is the finish line you have
114:02 - made it congratulations i hope you've
114:04 - learned a lot throughout this course we
114:06 - really have covered a majority of what
114:08 - you need to program against mongodb so
114:11 - you've done it you've crossed the line
114:13 - now you know enough to start building
114:15 - applications based on mongodb so the big
114:18 - question is what are you going to build
114:20 - now i hope you go out and build
114:21 - something amazing please share it with
114:23 - me when you do
114:24 - i want to take this moment to remind you
114:26 - to get the source code come over to
114:28 - github.com mike c kennedy slash mongodb
114:31 - quick start dash course and star and
114:34 - fork this so you're sure to have a copy
114:36 - so one thing i do want to take you
114:38 - through really quick two things one i
114:40 - covered in the beginning is there is the
114:43 - starter code which is here this is
114:45 - exactly what we started from and here
114:47 - is what we have finished with you can
114:49 - see right there 15 minutes ago i wrote
114:52 - final code but i also wanted to make
114:54 - sure there were save points along the
114:56 - way so if we go back here and check out
114:58 - the branches you'll see there's all
115:00 - these different branches so these are
115:02 - all different save points that you can
115:04 - grab so if i go here for example you can
115:06 - see final registered and list cages
115:09 - guests can now book a snake into a cage
115:11 - and things like so these are different
115:13 - points in the course that you can go
115:15 - back and forward to so be sure to make
115:16 - use of the branches and things like that
115:19 - if that can help you
115:21 - you've learned a bunch of stuff to
115:23 - program mongodb using engine but
115:25 - there's actually a lot of other things
115:27 - that you need to take into consideration
115:29 - when you're doing mongodb in production
115:31 - for real applications so i want to
115:33 - encourage you to check out my paid
115:35 - course mongodb for python developers and
115:38 - just some of the things we're covering
115:40 - you've seen a little bit of it but
115:41 - there's actually a lot more so this is
115:43 - over seven hours of professional grade
115:45 - mongodb and python programming not just
115:48 -  engine but the core pymongo the
115:50 - javascript api and so on so let's see a
115:52 - little bit of what's covered so we talk
115:54 - at in depth about how to set up your
115:56 - machine whether it's windows mac or
115:59 - linux the tools that we're going to use
116:00 - how to get them installed why the theory
116:03 - behind of nosql y nosql why document
116:05 - databases mongodb's native shell and
116:08 - native query syntax so when we run these
116:10 - operations these queries filter
116:12 - statements and so on in engine how
116:15 - does that map down to the database this
116:16 - is important because when you're running
116:19 - mongodb and production you need to be
116:21 - able to use the tools and the query
116:22 - language to talk to it
116:24 - manage it right and that is in this
116:26 - native query api how to model data with
116:30 - documents we did talk about this we go
116:32 - into more depth in this course mongodb
116:34 - from pi this is the foundation of
116:37 -  engine and basically the python's
116:40 - equivalent of the native query syntax
116:42 -  engine that's we covered a lot of
116:44 - that in this course so this is pretty
116:46 - similar high performance techniques so
116:48 - performance around document design
116:49 - performance around indexes and using
116:52 - profiling to discover where you need
116:54 - those so that's covered in this course
116:55 - and super super important is how to
116:57 - properly deploy mongodb in production on
117:00 - the internet so it doesn't get hacked
117:02 - and you don't lose data or anything like
117:04 - that so if you want to check out this
117:05 - course here's a tremendously long url
117:08 - that you very likely don't want to type
117:10 - so type this bit dot lee slash manga
117:12 - course and that'll take you right there
117:14 - you can check it out i encourage you to
117:15 - take this course if you like what you
117:17 - saw on this course here's seven more
117:18 - hours going even more in depth so with
117:21 - that i want to say thank you
117:23 - thank you so much for taking my course i
117:25 - really hope you learned a lot and you
117:26 - enjoyed it please connect with me on
117:28 - twitter at m kennedy or various other
117:30 - places you find me on the internet
117:32 - thanks and see you later

Cleaned transcript:

hello and welcome to mongodb quickstart with python mongodb is one of the most popular and exciting database technologies around python is one of the most popular and fastest growing language there is and these two technologies work great together and that's exactly what this course is about so we're going to quickly get started with mongodb write some code against it and build some realistic applications so the goal with this class is to teach you mongodb we assume you know a little bit of python but you'll of course pick some things up along the way if you don't know it already and really we want to get you going quick hence the name quick start so let's get started by talking about what we're going to cover in this course we're going to focus on three main things we're going to start with why do you care about nosql and document databases how do document databases make working with schemas easier modeling data easier as well as add performance and flexibility to our applications we're going to talk about modeling specifically because this is one of the things that is pretty challenging about document databases if you come from a relational database world you probably know about third normal form this is a way to carefully and sort of structured way to plan out how you model your data in document databases you don't really have that there's a lot more sort of flexibility in how you design things this is great for you once you understand it and you're really good at it but it's challenging to know how to model things when you get started because there's so much flexibility and it's kind of openended feels a little more like art than science in some sense so we're going to focus specifically on techniques and tradeoffs and some guidelines i've come up with to help you be successful modeling your data with document databases such as mongodb and then we're going to start writing code for real we're going to use a odm object document mapper think of like sql alchemy but for document databases called engine and we're going to use that to create some classes to model our data and map those classes to and from mongodb and use that as the foundation of our application speaking of applications what are we going to build in this class well we're going to build an airbnb clone but for snakes okay so we're going to build snake bnb and this allows you when you're traveling with your snake your pet snake you don't want it to have to live out in the car or something like that you want to get it a cage that it can live in a proper snake cage or it'll be happy so they'll be owners of cages who can put their cages up for rent and snake owners pet owners who want to travel with their pets and have their pet have a place to stay so we're going to create this sort of silly airbnb knock off clone but we're going to model many of the operations you would see in real airbnb on our application here so it's going to be pretty rich in terms of data as far as tools go well of course we're going to talk about mongodb right that's the database we're using but you're also going to learn some other things that are pretty awesome in the course we're going to talk about engine this is the primary library we're going to use to talk to mongodb it's built upon another one that's very popular that is sort of the lowest level official way to talk to mongodb called pymongo so you might see a little bit of both of those actually in the course we're going to use what i think is the best tool for accessing mongodb something that used to be called robomongo but now it's called robo3t because it was acquired by a company called 3t so this is part command line part gui way to interact with mongodb and it's beautiful and free open source it's great also we're going to use pycharm for our python code you don't have to use pycharm for this course but you'll see me using it and i think you'll see a lot of benefits as we go speaking of me who am i anyway who is this voice that you're listening to hi my name is michael kennedy you can find me on twitter at m kennedy and what makes me qualified to teach this course well first of all i host the most popular python podcast called talk python to me and i've interviewed many many people including some of the folks from mongodb the company as well as authors who've written about mongodb design patterns and things like that so i've had a lot of experience working with people in python and magady b i've created the talk python training company and written many python courses and mongodb courses there as well and also i'm part of the mogadib masters program so this is a group of about 35 external community members who give advice back to mongodb and i've been part of this for many years worked closely with the folks inside mongodb over the years so this is what you have in store for you lots of awesome mongodb and python i hope you're excited let's get right to it let's begin by looking at why you might choose mongodb over other nosql databases other document databases or even other relational databases i'm sure you've heard of mongodb that's why you're taking this course but how popular is it relative to other databases is it really the right choice well let's look at some data from 2017. if you compare mongodb against other nosql databases cassandra couchdb ravendb things like that you will find one of these databases is unlike the others look at that that's incredible how much more popular mongodb is over these and it's not just the popularity that it's 5 10 times maybe 50 times more popular than ravendb that's great that's very important but also the trend right these others are either flat or turning downwards and this is besides a little blip here based on probably like the end of the year um numbers or something like that at the end of the data this is a really big deal right this is incredible how much growth that is here and it's still going up so mongodb is really really popular in terms of a database that people are using and that's great because that means it's well tested when we get to the section a little bit later we'll look at some of the users of mongodb but it's really important that there are some heavy workloads put onto these databases that you're going to depend upon and if it can take what those people are doing surely it can take what you have to throw at it as well now mongodb is also loved if you look at stack overflow at their 2017 developer survey and you look at the most loved databases these are databases that the developers are using currently and how they feel about it you see mongodb ranks right near the top so definitely 55 percent of the people who are using mongodb love it compared to say like sqlite or cassandra so this is pretty good but what's even more interesting is that it's the most wanted database so these are technologies that you're not currently able to work with but you would like to so there are tons of people that want to work with mongodb but for whatever reason they've got some legacy system built on you know mysql or whatever they don't get the chance to so all these pieces of data tell you mongodb is a really good technology to have in your tool belt and it's easy to get a hold of right mongodb is open source and it's free you can just go to github.com mongodb and clone it and it's right there so you can see it has 11 000 stars 3000 forex in this screenshot i took here it was updated two hours ago it's under very very active development so it's a live and vibrant project finally if you actually want to get mongodb don't go to github github is cool it's great you have the source but don't go there what you really want to do is you want to go to mongodb.com download center or just go to mongodb.com and click download it'll take you here and you download it here you get it as a binary so if you're on mac i recommend you use homebrew to install it but you can also download a tarball if you're on windows get the msi and on linux you can actually install it with aptitude or some package manager like that in this course we're not going to go in the details of setting up mongodb just follow the instructions in the full mongodb course we have we walk through all the steps but we just want to get started this is the quick start so let's keep moving let's look at one of these records stored in mongodb to see how document databases work here we have a json record this is actually from one of my courses the python jump start by building 10 apps and this is how i represent it in the database we've got standard columnar type things so we have an id we have a title a course id duration in seconds these types of things now first of all you might be wondering wait a minute json database json database is that really efficient well probably not what mongodb actually stores is a binary representation so like a binary tokenized version of this record but they call it bson because it's like binary json but we're humans we don't read binary we read text so we're looking at the textual representation so this is not exactly how it gets stored but this is pretty close so we have these regular column type pieces of information id and title and so on we also have this other thing these lectures now these lectures are in this chapter represented by this record from this course and notice the bracket in javascript which basically this is means that is a array and the array contains a bunch of subobjects so this is really interesting instead of just having a chapter table and a lecture table and doing a join or something like that a foreign key relationship we're actually putting the lectures inside the same record so this is pretty interesting when you look at it like this you can imagine that this is like a precomputed join if i do a query for the lecture say given id 1001 and i get this record back it already has the lectures i don't have to make another round trip to the database to get them i don't have to do a join against several tables in that original query it's literally a primary key query against an indexed primary key and is insanely fast and yet it already comes back with all this extra information so this is really cool if i get the chapter i have the lectures great but you might be wondering well really what if i need to ask the question in reverse like fundamentally if i need to get at lecture 10106 will i be able to query mongodb quickly and efficiently to get that lecture and it turns out the answer is yes and that's why document databases are awesome it's not just like some nested blob stored in the original record you can as part of the query language and part of indexes traverse these hierarchies in very very rich and powerful ways so we don't lose very much query capability just by putting the lectures in this one record so this is really neat and this is sort of the foundational most important takeaway from document databases we store them as these flexible json type of objects and we can nest additional things like lists of numbers or even subdocuments as we have in this case now before we move on let's take a moment and look at who uses mongodb now programming languages and databases and technologies aren't necessarily popularity contests just because something's popular it doesn't necessarily mean that it's great you know evidence php for example or vb or something like this technologies are popular and some of them are great and sometimes great technologies are popular so there are some important things that come along with being popular and used in by big important companies and that means these things are durable and tested and they've really been through the ringer so mongodb has been used by some really big customers and some really interesting use cases and i know some of the biggest ones are actually not on this page even they're not listed here so i'm taking a quick tour of a couple of customers who are using mongodb and we'll look at how they're using it okay so the first one that i want to look at let's scroll down here and see some names that you might know some cool stuff here let's check out royal bank of scotland so banks are supposed to be conservative right things like this they probably wouldn't use weird nosql document databases they're going to stick to their traditional oracle or sql server or whatever well if we look at royal bank of scotland they're using mongodb to support a global enterprise data service underpinning several core trading systems if you're bank the core trading system's pretty much the center of the universe right so the fact that they're driving that with and that's high performance and it's doing that for them that's really awesome let's check out expedia so expedia they have their app built on mongodb and they're supporting millions of customers shopping for flights hotels cars things like that that's pretty awesome let's check out another one down here ea so video games right this is the world's bestselling sports game franchise and they rely on mongodb to scale to millions of players that is really awesome one more before we move on so these guys down here a little farther at sail through sail through is a company that does like outbound mail and analytics and things like that so they are a marketing company very much doing tons of email type of stuff like i said and they have over 40 terabytes of data in 120 physical mostly physical nodes right so 120 servers all working running mongodb in some giant cluster which is a pretty awesome use case and of course you have things like shutterfly running on mongodb squarespace on and on there's a ton of cool uh use cases down here but i think you've got the idea are you ready to model some real applications in mongodb using documents it's time to get our hands dirty and really start building something so in this chapter we're going to go through our snakebnb application come up with the entities the classes and tables or collections as they're called a mongodb and model them out so we're going to first look at how this modeling and document databases compares to traditional third normal form modeling in relational databases i'm going to use a pretty simple example but i think you'll get the idea and you'll see it much more in action when we build the real app so let's take this simple bookstore model here we have books they have a bunch of properties we have people who publish those books named publishers they have a name when they were founded and you can navigate this foreign key relationship from publisher over to the publisher id on the book now we also have a user and a user might rate a book so we have users and we have ratings and we have a foreign key relationship between them and they know from rating over to book we have a onetomany relationship there right a book can have many ratings so we have a couple of foreign key relationships going on this place now let me tell you in a real application there'd be many more little tables with extra information like this like ratings about books and so on and like let's say reviews for example things like that maybe even related items that we precomputed from some sort of machine learning but we want to store that in the database so imagine this model here having like 15 tables with relationships across all the various pieces back and forth right so i just want to keep it simple if it's on the screen you're not going to go crazy with it so how would we model this in mongodb how will we model this using documents well you would see that it's somewhat simpler the more craziness that we had on the relational model the sort of more contrast you will see here so we still have our publisher and they have their id and when they are founded we have our user the same columns or pieces of information there as well same as book but now our ratings we've decided you know when we get a book most of the time we actually want to know the rating we want to say like this is a 3.4 star book or it has 72 ratings even in a list we want to show that stuff so we're pretty sure we want to have these ratings always with the books so why put them in a separate table let's embed them now we still have some relationships like we had in the relational model for example we have our publisher id on books and that links over to publisher now this is what in mongodb i refer to as a soft foreign key constraint if there is a relationship between books and publisher it's the publisher id set to the id of the publisher but the database itself doesn't enforce this right so you need to be a little more careful in your app and we'll see how we do that when we get to the code but as i was saying about ratings these we're not going to put in a separate collection in fact we're going to store those inside of our books so we can embed these objects and arrays of either straight values like numbers or strings or actual sub documents like our ratings here so whenever one two three and so on is actually part of the record of the book so when we get the book record back we already have the ratings things like that so again we can think of this ratings being embedded within books as a precomputed join there's a slight bit of overhead if you actually wanted the book without the ratings and you're just going to get them back and ignore them most of the time anyway if that was the case but if most of the time you do want the radiance this is a huge speed up and like i said imagine there were 15 tables before and five of them could be collapsed into the books they have a fiveway join going down to a single primary key query that'd be amazing as we discussed modeling with documents and document databases is a little bit more art there's a little bit more flexibility and kind of just gut feel of how you should do it but let me give you some guidelines that will give you a clear set of considerations as you work on your data models you'll see that the primary question for working with document databases is to embed or not to embed that is when there's relationship between two things in your application should one of those be a sub document should be contained within the same record as the thing it is related to or should they be two separate collections what mongodb calls tables collections because they're not tabular right should those be two separate collections that just relate to each other so we're going to try to answer this question i'll try to provide you some guidelines for answering this question so the first one is is the embedded data wanted 80 of the time when you have the the outer or other related object okay so let's go back to our example we just worked with we had a book and the book had radiance so to make this concrete the question here is do we care about having information about the ratings most of the time when we're working with books so if our website like lists books and that listing has the number of ratings and the average rating and things like that listed as part of the listing you pull up a book maybe the ratings and the reviews are shown right there most of the time we have the book we have the ratings evolved somehow then we would want to embed the ratings within the book right that's what we did in our data model we said yes actually we do want the ratings most of the time now let's look at this in reverse how often do you want the embedded data without the containing document so in the same example how often is it the case that you would like the ratings without the book so what use cases for maybe like where would that show up in our app so like maybe you as a user go to your profile page on the bookstore and there you can see all the books you've rated right and the the details about the rating you don't actually care about necessarily the books you just want these are the ratings that i've given to things and here's my comments and so on i don't actually want most of the details or maybe any of the details about the book itself so if you're in that sort of situation a lot of the time you might want to put that into a separate collection and not embed it you can still do it you can still do this query and it will come back very quickly there's ways to work with it but you'll see that you have to do a query against the database and then a little bit of filtering on the application side so it's not prohibitive it's not that you can't get the containing document with the contained document without its container but it's a little bit more clumsy all right so if this is something you frequently want to do then maybe consider not embedding it now is the embedded document a bounded set so let's look at ratings how many ratings might a book have 10 ratings 100 ratings a thousand ratings is that number going to just grow grow the number of ratings that we have if this was like page views and details about the browser or ip address and date and time of a page being viewed i would not make a good candidate for embedding that like say for views of a book because that could just grow and grow and grow as the popular your site grows and it could make the document so large that when you retrieve it from the database actually the network traffic and the disk traffic would be a problem i don't really see that happening with ratings i mean even on amazon like super popular books have hundreds not millions of ratings so this is probably okay but if it's an unbounded set you do not want to embed it and is that bound small right like maybe millions of views still being recorded within sign of a book would be a really bad idea and the reason is these documents are limited to 16 megabytes so no single record in mongodb can be larger than 16 megabytes and this is not a limitation of mongodb this is them trying to protect you from yourself you do not want to go and just say query by say isbn and try to pull back a book and actually read 100 megabytes off a disk and over the network that would destroy the performance of your database so having these very very large records is a problem so they actually set an upper bound on how large that can be and that limit is right now currently at the time of the recording 16 megabytes but you shouldn't think of 16 megabytes as like well if it's 10 megabytes everything's fine we're still got a long ways to go no you should try to keep these you know in the kilobytes tens 20s hundreds of kilobytes not megabytes because that's going to really hurt your database performance unless some situation it just makes a ton of sense to have these very large documents so having small bounded sets means that your documents won't grow into huge huge monolithic things that are hard to work with also how varied are your queries so one of the things that you do with document databases is you try to structure the documents to answer the most common questions in the most wellstructured way right so if you're always going to say i would like to on my pages show a book and it's related ratings you would absolutely put the ratings inside the book because that means you just do a query against a book and you already have that like kind of prejoined data but if it's sort of a data warehouse and you're asking all kinds of questions from all different sorts of applications then trying to understand well what is the right way to build my document so it matches the queries i typically do or the ones that i need to be really quick and fast that becomes hard because there's all these different queries and they have like you know one the way you model for one is actually the opposite of the way you model for the other right so depending how focused your application is or how many applications are using the database you'll have a different answer to this question so the more specific your queries are the more likely you are to embed things and structure them exactly to match those queries related to that is are you working with an integration database or an application database we'll get to that next so wait what is an integration database so if you were just working on your own personal website or some small project you don't have an integration database but if you work at a big enterprise a big corporation where there's many internal systems you may be working with an integration database and honestly that's not a great fit for nosql databases in general but it also makes designing documents for them more difficult so in large corporations we have many applications that share the same data one way that we have built applications to share data is to just share the same database so we might have a bunch of different applications and they're all going to talk to the same database so they all have the same concept of a user they all have the same concept of an order things like that and this means the concept of the user is as complicated as it can get maybe the application in the top left could have a real simple user the one in the top right actually needs something else the bottom one is something else still and so you've kind of got a model across all these applications and that makes it super tricky also in nosql databases and document databases the relationships are enforced in the application so that means that all of these have to agree on what the constraints are what the relationships are and that can actually cause data integrity issues so there's a lot of reasons that integration database isn't a great idea for relational databases in fact it's not a great idea at all but it has been used and because there's different applications with different query patterns it makes designing your documents more difficult so instead what do we do we build application databases maybe we have a bunch of different applications just like before but they all have their own data store and they all talk to their own databases of course they need to exchange data like before so maybe we do some sort of microservice thing where they talk to a service bus or they just talk to each other things like that and that means each individual green database and interaction with its own application is super super focused and limited and here in these cases mongodb document databases make a lot more sense and it's easier to design the documents because the range of queries is extremely focused so you can target those particular questions against a small set of queries the guidelines we just talked about so this is the kind of model you want to have if you're doing data exchange within your organization and you're working with a document database i don't know about you but i feel like we've talked about coding and talked about mongodb in theory enough and it's time to write some code and use mongodb so that brings us to getting started with our demo application so throughout the rest of the course we're going to spend a significant amount of time focusing on this and remember we're building snakebnb this wonderful experience where snake owners and their pets can shear other snake cages when they're traveling so they feel totally comfortable on every vacation you need to take your snake on course it's just a knock off of airbnb type thing and in this video we're going to see how to get it from github and how to get it up and running in python and pycharm so we'll start out over here on github.com mike c kennedy slash mongodb quick start dash course and you can see that we've got a couple of things here we've got some data this is empty right now but i'm going to fill it up with stuff as we go through the class so you'll be able to recreate the database there'll be instructions in there on how to restore that and then if you go over to source this is the most interesting part we're going to be working in this area here but i've made a snapshot of starter code snakeb this is exactly a snapshot of what we're starting from okay but i'm going to be working in here because i want to have it build up right also trying to do make some branches or other save points really obvious when we get to the various videos right now there's no other branches but we'll get to those okay let's go and check this out so we'll go copy what we need and we'll say git clone this nice and quick and let's go work with it so over here we have our source code and we have our snakebnb and we have our starter code snakebnb so these are the the two projects here and what i want to do is i'm going to put this into pycharm on mac os you can just drag and drop this onto pie chart and load the project from that folder however if you do this on windows or on linux i think you have to go to pycharm and say file open directory however before i do let's go into this folder really quick and create a virtual environment so you may be familiar with python and virtual environments and so on but if you're not let me give you the quick overview of what's what's going on here if we look here we're going to have apparently a misspelled requirements file which we're going to take care of in a second but notice in this requirements file these are the external libraries pymongo and engine for mongodb and some other random stuff for working with color output on the console as well as parsing date times entered from the user so we need these libraries and we don't want to install them and manage them basically as a machine wide thing we would install them into our virtual environment so let's go over here first rename requirements and we're going to go and actually create the virtual environment and then we'll install we can install stuff into it so here we are again in the source folder so we'll say python3 dash m v env so run the virtual environment module into dot env this naming convention.mv something that pycharm understands will automatically detect and start using we're going to pass the copies flag that's only required on mac os i believe but anyway we'll go with that now if we do an lsah you can see this hidden.emv but we don't need to do anything else with it pycharm should take it from here so we can go and grab this folder on mac os memory file open directory on the other os's and drop it here so let's go ahead and tell pycharm about git the very first time pipedrop will index the python environment we gave it and then it should be up and running okay so let's look down here in the terminal you should see the dot env you can ask questions like which python and it shows you it's the one that we created in windows it's where python not which python if we go over here we have our requirements and so on now the other thing we need to do is we need to right click and say set this as like the relative path so in this file when i import some other file it looks relative to that so you can say right click here and say mark directory as sources root or just be in this folder when you run it in python basically you're working directly okay so we're almost ready to run things the last thing we need to do is install these requirements so we can say pip install dash r the requirements file and that will install those libraries for us so when we run the application it has everything it needs so if we try to run it now it'll crash and say it can't find colorama or something like that now this application is empty it doesn't do anything other than ask for a couple of prompts there's no data access for mongodb anything in here but let's go ahead and just get it to run so we can right click on program and right click and say run program it runs and you can see if i make it bigger here we have our snakebnb and i put a little snake there for you guys and it asks you a question are you a guest or a host are you looking for a cage or do you want to offer up your cage so let's go with guest and it lets you do things like create an account add your snake so on so i could say i'd like to log in so do you know that's not implemented yet in fact that's what we're going to be doing next is implementing all of these features in the database creating an account logging in booking a cage viewing cages things like that right so all the actions you might do in a typical airbnb situation so that's it for now we have this up and running let's do one more thing because of the output this i find this looks a little better if we just run it separate outside of pycharm so we can say copy the path here and we're still in this folder with the dot environment so we need to activate it if we're going to run it over here so we would say a dot space dot env spin slash activate on windows you don't need the first thought and it's not been it's script script or scripts i can't remember i think it's scripts either way our prompt should change and now we can run this here's our snake again okay so we're all set up and ready to run our code it's time to write some code against mongodb and connect to mongodb and we're going to do that with an odm and object document mapper if this term is new to you think of object relational mapper like sql alchemy but for document databases instead so let's compare first this odm style of programming against the most basic lowest level way to program or interact with mongodb from python called pi so every programming language that you can talk to mongodb from there's many of them 20 30 i don't know something like that many many languages can talk to mongodb and they each have what's called a driver and this is typically provided by mongodb the company itself so pymongo is no different it's this low level foundational way to talk to mongodb and you do this in the native query syntax of mongodb this javascript json style of interacting with the database now it's important to know that if you're working with mongodb in terms of running and managing it but from writing code we're going to focus on something higher level and odm so we can take structured classes and map those to and from the database so let's see how it would work if we just use pymonga so we've got our app here and we have the pi package we're going to work with and we have mongodb the database so we write direct queries in this raw mongodb api so you have to know the api really carefully you have to map those back to your classes basically what you do is you pass dictionaries to pymongo it uses those as part of the query and then you get the dictionaries back it's pretty unstructured but it's very low level and fast with an odm similarly we've got our app and we've got pi and mongodb but we also have another layer the layer that we directly interact with called the odm object document mapper and there's a bunch of different kinds there's engine there's ming there's kit there's alchemy mini and there's more than that actually there's a ton of them just so happens we're going to use engine one of the more popular and well polished ones i think so in this model we don't query in terms of raw dictionaries against pymongo we just talk to the classes defined by the odm and our queries are based on those types on those classes that itself will translate to the mongodb api sometimes in real basic ways sometimes really advanced ways and it will actually leverage some of the advanced operators the dollar operators if you're familiar with them for mongodb like dollar set dollar add to set things like this so really really cool that it leverages the advanced operators not just you know save this document read this document type programming i think the odm model is a much better way to write your application you'll see there's not much structure in a schemaless database so having a little bit of extra structure defined by these classes that are part of this odm model really adds a lot of safety to your application in my opinion the odm we're going to use for this course is engine and you can find its home page and details about it documentation and so on at mongoengine.org so engine is open source like many things you'll find in python as we said it depends upon pi you saw us install it earlier we just did pip install engine and that installed pymongo along with it we did that through the requirements file but you can do that directly if you prefer you can find engine on github you can see that it's quite popular almost 2 000 stars this is much more popular than the other mongodb odms as far as i can tell look into other ones this is definitely the most popular or at least among the most popular of them and it's very actively under development i just took the screenshot right now before i started recording here to give you the latest version you can see that it's been updated in the last 24 hours some other stuff under the actual code has been updated in the last 21 hours so very active this is important for an open source project you're going to depend upon so i think you know judging by that engine is the best choice and the api is excellent we're going to start working with it next the first thing we need to do to start working with engine is tell engine how to speak to mongodb let's go back to our snakebnb app we've been working on and we're going to go in here to this data section and we're going to create a new file new python file called setup so in here we're going to write a simple method that we can call from other places and as you'll see in the slides that we look at later for real applications that use proper connections encryption accounts things like that this can be a little more complicated but it's going to start out pretty simple so we'll say global init and in here we just want to call one function so we're going to have to have engine here so we'll import engine and we just say mongoengine dot register connection and the first thing that we pass is an alias so i'll be real explicit say alias equals core now what is this alias thing about we can have multiple connections to even multiple databases or even multiple database servers registered here so we could have like a core data and say analytics for just analytics that goes to a separate database that maybe has tons more data because it's like page views and actions and so on but we might keep that separate so we can back it up on a separate schedule something like that and then we need to set the name of the database and we'll set that to snake bnb do a quick format here and it's all good to go like i said this gets more interesting in real connections but we're going to need to call this to talk to mongodb so let's go over to your little program and you saw up here at the top there was this to do set up engine global values and that was basically what we were doing there so we need to come over here and say we need to go to data dot setup as we'll just call a setup and this should be pretty simple manga setup dot global init now we just need to make sure we call this once in our application and we need to do this before we actually interact with anything else so let's go and apply these settings over to our entities as well so we'll look at snakes first now this model is going to be mapped into one or more of those databases well one among many potential databases so the way that we can tell it how to work engine will use a property we can add to it we can say meta equals and we give it a dictionary and we can say db underscore alias and we'll say core here okay while we're at it let's say collection is snakes so even though we called it capital s snake the thing in the database where these records these documents are stored will be called snakes plural lowercase and here we can tell it this goes into the core database unlike maybe the analytics one or something like right we're only going to have one in here but for our example you want to have this here so in case you want to add more later right i'll go ahead and add the rest of these to owners and cages but not bookings because bookings is going to be nested inside here all right so we don't need to tell that how it gets stored because it's stored alongside cage which will say cages and no surprise owners all right so those are our three top level entities that map to our three top level collections in mongodb now we've registered the connection by using our setup global which we just call registered connection like i said this can get way more complicated in reality and then we just go and we set this meta to use the core connection as well as naming the actual table or collection it's going to go to let's take a moment and look at this concept of registering connections we're going to need to work with moggle edge and so of course import engine and we need to set the alias and the name of the database so it should say engine.register connection give it the alias give it the name we need to call this before we start interacting with our classes and other types before we try to do any queries or save any data this has to be all set up so this is what we wrote in our application and this works fine when you're talking to the local mongodb running no encryption no accounts default port running on the local machine same machine as this code now if you're doing this in production there's more to it all right you need to set the username and password which you have to set up in mongodb there's none by default so you've got to set that up with the right permissions probably it's a different server on an alternative port so set the host in the port you would like to create a some sort of admin account which is associated with that username and password so you say look you authenticate an admin use this mechanism and finally if you're going to do connections across you know somewhere outside your data center you pretty much should just turn this on is you need to turn on ssl and configure the server for ssl and then you pass that additional data in addition to the alias and the db now there's a lot going on here and deployment and running mongodb in production is not as simple maybe as it could be certainly it's something you need to be very careful about like no authentication no encryption right don't run your code that way it's fine to do it for development but don't do it for production in my full mongodb course i actually go in to spend an hour go and create a linux server and set it up in a cluster of the database and the web servers and those kind of things and really make this work perfectly and safely but in this course we're not going to go into it i just want to leave you with you need to set this up you can look at the mongodb.org site as well or mongodb.com site and go through the documentation on some of the steps or just take my other course if you're really going to go and use this in production so far we've modeled our data with python classes but there was no real engine entity stuff they wouldn't actually be saved or processed by engine just happens to be we kind of sketched them out in python class style so we're going to change that now we're going to go make our standard plain old python classes proper engine entities snake is pretty simple so let's start there so in order to work with engine over here i'm going to have to import now you might want to do from engine import some things but i like to be real explicit like these things are coming from engine even in my production code so this is how i'm going to do it and we're going to set the register date to a particular type of descriptor that comes from engine and at sort of the type level this tells engine what type of data and constraints and requirements go onto this field however at runtime it's going to act like say a date time or whatever it is in this case the date time and species would be string and so on so we'll come over and say engine dot date time field and we'll just go like this so this will tell engine to map that to the database as a date time field over here we'll say engine dot string field and over here the length let's say this is in meters and that's probably decent enough floats right so this will be a float field the name again a string field whether it's venomous or not that's true or false um i guess it could be a number like level of venomous i don't know but we're going to call this a boolean field and that's that so our snake is all ready to map into mongodb mongodb doesn't have things like required fields or default values or anything like that but engine does so let's change this to make it a little simpler to create a snake so for example registered date is almost always just whenever you inserted it right so what we can do is we can come over here and set a default function that will execute any time engine inserts a new snake so we're going to start with date time so the function that we want to call is the now function which gives us a full year month day hour minute second representation of time so we'll come down here's a daytime.datetime.now and be very careful not to put the parentheses you're passing the function not the value of now that would be like when the program started so that can be a little tricky over here for species let's say that you have to save the species so we can say this is going to be required is true in fact the length is required the name is required whether it's venomous is required we could have things like um minimum values have to be like 0.001 or you know things like this right so you can't have like a negative length there's a lot of cool constraints that we can do with our types here so this snake is now ready to be used in our database let's look at the next one let's work on the cage next so again import engine we'll use that in a few places this is exactly the same here so set the default and then the name is just going to be a string and so on so i'll just sketch these out for you so these seem like reasonable types here and let's go ahead and set the required properties for things that we require so most of these will be required and whether or not we allow dangerous snakes if you don't set that let's say no by default you're not going to have a dangerous snake okay so these are just like the snake before this however gets more interesting so we're going to come down here and we're going to set this to be a engine dot embedded document so we could have just a single thing like a booking or a like say embed the snake in the owner or something like that but we want to have a list of embedded documents and what we need to pass in here is the actual type that is contained in there so we're going to import data.bookings.booking one other thing that i also realized i forgot to do in the previous ones we'll go back and fix that is we need to tell mongoengine that this is a toplevel document so we need to make this have a base cloud of type document we'll do that for snakes as well now let's go to the booking we were just working with that so this one recall is is the type that's embedded within of the cage it's embedded in the cage that means it's not a document right that would be a top level thing this is an embedded document right so this can be contained within other documents but it itself cannot be top level so let's go ahead and set these as well now when we're talking about ids and mongodb the default is something called an object id like a uuid or good or something and so when we're talking about a reference typically it's one of these it doesn't have to be what it typically is there we go so we've got our two references as object ids we've got our booking date which does not have to be required and it doesn't have a default value this is when it was booked which happens after the booking slot was made available and but at the time of creation of the slot of booking right with like putting up for booking you have to say the check in and checkout date and again the reviews these are not getting set until after i set this to zero so we can say like you know require it to be one to five if they actually rate the thing and then you can sort of exclude the ones that are zero the final one is owner and it's very very similar i'll just sketch that out for you okay so we've got our flat pieces here our register date name and email and now we're gonna have a list of ids so we'll come in here and say mongoengine.list field for both of them so this will let us store the object ids that refer to the snakes and the object ids that refer to the cages last thing to do is make the base class the document here all right so what have we done we've set all the fields to their respective types out of engine as descriptors we've set either default or required values and we've set the metadata which talks about which database connection to use and what to call the collection when it goes into the database and we've done that for our three top level items here the one that is different that stands out is the booking which is embedded within the cage and this is an embedded document but otherwise everything goes pretty much the same let's review the core concepts around creating engine entities we started out by creating what i called basic classes these are classes that could just as easily been mapped to a relational database because they just have flat fields or columns if you want to think of them that way and none of the nested or particular capabilities of document databases so the one that matched that was the snake and the snake we make sure that it derives from mongoengine.document and then we specify the fields by passing along or creating these engine descriptors so we said there's a registered date and that's a engine.datetimefield the length that was a float that was the length of the snake in meters the name of the snake is a string species as an a as a string as well and whether or not it's venomous that's a boolean true or false so you can see we can map out the types for this basic snake class really easily here of course our snake should have default values constraints like required fields and things like that so here we've taken that same snake class and we've added a default value for the registered date we said just call the function datetime.datetime.now anytime you insert a new snake so it's going to automatically tag that new entity or that new document with the date in which it was inserted now remember be super careful did not call the function now but pass the function now okay we also set the length to a float we said that's a required float you have to specify the length or you know engine will give you an error so you can't insert this thing that field is required it's interesting that that's not a feature of mongodb that's a feature of engine so by using engine instead of say pymongo we get these additional features same for the default and name species and venomous also these are all required so we can do this here now again this is still one of these sort of basic classes with just our constraints and defaults let's look at the cage the cage is more takes better advantage of the document database so we have the name the price the square meters required standard stuff there we also have the bookings these are either the times in which a cage could be booked or an active booking where snake has registered to be there on a certain time we modeled that through the booking class and we said this cage is going to embed the bookings into it so to do that we use the engine embedded document list field so a list of embedded documents and the argument we pass is the type of embedded document so it's a booking that we're putting into this list all right now how does this look if we populate this cage and we add a couple of bookings and we call save well it looks like this it has the standard fields right like a auto generated underscore id the date that was registered this is set as the default value in the full class we have the name the price the square meters and so on so that's all standard stuff and we've seen that before but the bookings part check that out so we have bookings and it's a list right square brackets technically an array in javascript right and the items in this list are those bookings so we have a checkin date checkout date and the ratings so we've have added two bookings in here now we didn't fill out the they're not booked so we don't have a guest snake and an owner id and they haven't already taken them so they haven't rated it or given a review so some of the pieces are not saved into the database to save space nonetheless here we have our embedded bookings inside of our document and we did that through the embedded document list field we have our models our classes in place we have engine registered and told to connect to the default values for all the local stuff for mongodb running locally i already have mongodb started up and running check out the documentation on how to get that working on your operating system like i said at the beginning and it's time to create an account log in basically start implementing all these actions and now we'll really get to start programming with the entities we've designed in engine so let's begin by going down here to create account in program host so we're going to be able to use this for actually both the host and the guest right so you can see there's a couple things we have to do and then we're going to create the account so let's work on this get name and email first we'll say name equals and we'll just use simple input stuff what is your name something like this and we'll do email email we should of course have them you know give us a password and things like that but this is not a real website we're not really actually logging in it's just sort of a user creation type thing so we're going to create the account now i could go write the engine code to talk to and do the inserts here but you'll see that we can do much much better if we isolate all of these behaviors within a central location that we can use throughout our application in these nosql databases these document databases there's not much structure in the database so we already have some structure added by having our classes our engine types that we work with but we can also do a little bit better by having like a centralized data access piece so that's what we're going to work with here let's go create something called a data service and we'll just put a bunch of functions that we need to work with here so let's go back and let's import this and i'm going to import it in like a little short way so we'll say import services dot data service as svc okay we're just going to use the functions out of that module by calling it that so we come back down here so to say not implemented let's say this say svc.create an account and we're going to pass the name and the email what we're going to get back is an account so we want to actually store that in in the statefulness of our application again in a web app this would be with cookies and we get it back from the database every time but we have this state thing which has an active account so what we're going to do is we're going to come over here and we're going to say state dot active account equals this so we're going to get back an account from here now pie chart says whoa there's something going on here there's no account there's no method called create account function but if i hit alt enter then it'll say you want to create one of course we want to create one so name let's even give this a little bit of typing type hints here say it's going to return an owner okay so that's all well and good now we need to use this so now we get to programming with engine how do we create one of these owners well how would you do it if it was a regular class you would say this and you would set some properties like name equals name owner email is that and now we want to put in the database so we do that by calling using uh what's called the active record design pattern we'll just call save right on this now we want to return owner now the important point here is when we call save all the default values are set when we call save the primary key the underscore id is automatically generated here it's just dot id at engine but in the database level underscore id that's automatically set so this thing is up and running we should have everything working well here so let's go ahead and try to run this and see if everything's hanging together let me run it over like this so here's our snake b and b we're going to go and say we're a host notice at the prompt here this little yellow thing there's no name so we'll go and create an account with my name my name is michael and my email is michael talk python.fm boom logged in you can see now the prompt has my logged in name the next thing we've got to do let's just go from top to bottom let's go and log in however there is a problem what if i say i want to create an account i say my name is michael two and i say it's michael at talk python.fm if i hit enter there's just two of those that's bad so what we want to do is we want to do a little check over here so this is great we got this working and let's go ahead and annotate the type here as well let's say this is an owner that's going to let us when we interact with it later say things like this and get you know all the intellisense and whatnot snake ids and whatever okay now before we do this we want to verify that the account doesn't exist so we'll say old account so let's say find an account by email and again this doesn't exist so we'll create this function over here this will let us see how to query all right so to insert we create one of these and we call save to do the query we're going to do like this we'll say owner equals we work with the type and we say objects now there's a couple of things we could do we could say filter kind of lose autocomplete here but that's fine we could say filter and we could say email equals email okay so we would match one of the fields there all right and we would not put that of course and this is going to return a query and we want just one of them so we'll say first now it turns out when you have just one filter statement you can actually condense it down like this so we'll go ahead and write that and we'll just say return owner okay so there's our find account by email and we'll check if old account it'll be none if it's not found so if there's an old account we'll print i wrote a few functions error message success message with some coloration we'll say error account with email already exists and let's make this a cool python36f string like so of course we want to bail we don't want to actually create it here we could maybe do something like that print let's do the success created new account with id and let's say state.activeaccount.id like so great let's just run this one more time so we're going to come in as a host we'll create an account let's call this um call it sarah so sarah wants to come in maybe she's going to be able to like she's going to be a guest but right we're going to use this host path to do it for a second there so sarah talk python.fm great we've created a new account now let's just test this thing again so we'll say i want to create an account again sarah doesn't actually matter let's say susie and it's sarah talk python.fm this should no longer work it should go and query the database and find this and no no no error an account email sarah talk python already exists perfect i think the create account is done so we saved some data and it looked like it went into the database right when we successfully saved it we saw an id was generated we tried to log in with the same or creating account the same email we got an error new node that already exists so it's definitely working but let's look at the data with my favorite tool for working with mongodb robo 3d it used to be called robomongo robo3t so here it is and you can see just by virtue of calling save that actually connected to the database created this particular connected to the server created this database and the various collections we only called save on owners so we only have owners so far never mind the fact that we've created the other types we haven't saved anything there so it doesn't exist and we can come down here and we can say view documents and we actually have the two documents here remember we created two accounts and we can view them this way and there you go we have michael and my email sarah and her email the registered dates and times and we no longer we we don't yet have a snake or a cage because well we haven't implemented the ability to do that but we're going to have snake id and cage ids in here as we create these snakes and cages this is a really great way to work with the data if you go back to this mode you can even edit it and make changes in here if you really wanted to all right so definitely recommend installing this it works on all the platforms it's free and it's awesome we're able to create our account so let's now add the ability to log in once we exit the application so we're over here in the log into account and the program hosts this is super easy we just have to get the email from the user like this so we'll say something to the fact of the login asking what their email is and let's go ahead and do a strip and a dot lower on this and in fact let's always store that so i'll go back up to our create account and do that here so strip takes all the white space in case there's like a space or something on the end and lower of course makes it lower case so then we just need to see if the account exists well we actually already wrote that so let's say this say the account is the service not find account by guesting email and then we'll say we add a little error handling say if not account say error message so nothing there and if it worked all we have to do is save it and maybe say you've logged in yay so let's say state dot active account is account and then we'll do a success message logged in successfully and then our little prompt will change straight away so that should be good let's try this come over here to the host let's try to log in and remember there's no real passwords we're just sort of playing around with accounts here so michael at talk python.fm boom logged in successfully awesome and you can see the prompt changed let's try to log in again i'll try to just use jeff j.com nope could not find email with jeff j.com looks like login is working next thing we need to do as the host is to be able to register our cage so then people can view it and maybe book it that'd be great right so let's go over here and work with that now the cage has to be associated with an owner through this soft forum key relationship in mongodb so we're going to require an account and that's going to look like just an error message so like something like this so we'll just say if there's no account you must log in first to register a cage all right so now we know we have the account we're going to use that as part of it and let's go ahead and figure out how many square meters this is going to be so we'll say meters equals something like this now you might want to just directly convert that into a float but i found as i was interacting with this application like i'd accidentally like go to register a cage and i meant to list them you want some kind of way to cancel out so let's just suppose if they don't enter anything they just hit enter it kind of short circuits everything so we'll say if not something like this so if they don't enter anything we'll just bail out so otherwise we'll just say float of meter so convert it from a string to a float we're not doing error handling on this right you guys should probably add that but we're going to just do this and we have to ask a bunch of other questions is it carpeted does it have toys things like that and let me just copy that over because there's no point in seeing you that's typed in it's just user input stuff right and then we want to go down and we want to actually register the cage again we want to do this at our data layer not here in our application code so we'll say svc register cage and again that doesn't exist but it's going to in a second so we are going to pass the account we'll pass the active account here we'll pass the name of the cage we'll pass whether or not it allows dangerous just all of these items whether or not it has toys whether it's carpeted and the meters okay so we're going to go and call this function which obviously doesn't exist yet but by john will write it for us thank you by charm so here we can say this is an owner here's the name and string and so on there we go and let's say this is going to return a cage which we have to import at the top again thank you pyjar so this is very very similar to the create account we're just going to create a cage and save it so we set all the properties and we'll call cage.save and that's going to store it in the database now we want to remember if we look over at our owners it has cage ids to manage the relationship so the order in which we do this is super important now we need to be a little bit careful with this account here we want to make sure that we're getting the latest account from the database so we'll do something like this we'll say account equals find account by email this activeaccount.email see that make sure that we don't have any stale data i'm going to go account dot cage ids this is a list so we can append to the cage dot id now it's super important the order here we must call save so that this is an actual generated value it's just none beforehand so we want to make sure that's generated in the database and then we can return the cage so that little warning up there goes away because we are returning the cage the other thing that we need to do is this has changed the account but we haven't pushed those changes back to the database all right so our register cage seems like it's working let's go over here and let's do one more thing this active account needs to have that data adjusted as well so let's go over here to state and has a reload account that's not written yet let's do that so this is super easy to do all we have to do is go to the database and pull it back so we have this active account global variable and we can come over here and say import the service and here we just say find account by email activeaccount.email all right that's all we got to do to reload it so this will make sure that when we work with our state.active account it's the fresh one that just got its data changed down here let's do one more thing before we carry on let's go ahead and uh implement register cage here and let's spell suppress correctly let's be at the ability to list our cages so that we can test that this actually worked let's also do a success message registered new cage with id make that an f string actually cage.id so we gotta store that up here excellent so now we've got our cage and we'll see that come out but let's go ahead and we're gonna require an account again which is the same info up here and all we've got to do is get the cages so let's write something like this we'll say cages equals service not find cages for user all right go to write that function there we go creates an account let's not call it active account we'll just say account and that is an owner and it returns a cage actually not a cage what does it return it returns a list of cages so we got to go to the typing module here typing and do a cage okay perfect so what we're going to do is we already have the owner and because of our refresh account stuff it should be fresh so we'll have cage ids and we sh we should have this account dot cage ids right there we can use so now how do we query for this particular thing we're going to do something we haven't seen yet so we're going to come to the cage and again we're going to go to this objects i'm going to do the query but instead of saying remember before we had email equals and that did the query against mongodb for testing equality we have something different we need to do we want to go to the id of the cage and we don't want to just say well it's equal to it's not going to be equal to the list right we can't say not cage ids because one is like an object id and one is a list of object ids so we have to use a special operator and mongodb has all these socalled dollar operators dollar set dollar in dollar not dollar or these types of things and the way we work with those in engine is we use a double underscore to say we're applying this to the id but then there's this other thing that we're doing i'm going to say in so this query right here maybe a little cleanup this query says go to the cage and find all the cages whose id is in this list of ids right and now we'll have cages equals this is a query but we want to execute the query and sort of snapshot it for our app so we'll and we'll return cages and that should make our half our app totally happy that little warning went away okay great so we've written this function and we've used the in operator the double underscore to access it here's our cages we just need to print them out 4c in cages and let's make these f strings and we'll come here and we'll say c dot what do we want here we want name let's also print out something like this you have however many length of cages you have and then we'll print those off okay let's try to test these two things that we've written for host we first want to register a cage actually let's try to lister cages ah log in um michael at talkbython.fm and let's list our cages you have zero cages great so let's register a cage now we're logged in at a lettuce it's 2.2 square meters yes it's carpeted yes it has toys no has no venomous this will be bully's cage ah it looks like we haven't set the price hmm we've forgotten something haven't we okay so good thing we tested that here say price and this will be how much are you charging all right let's go add price here price okay so price okay that was kind of annoying that that crashed but it's also cool why is that cool because hey we said the cage must have a price and it didn't if that was regular mongodb that would have just let that happen but because it was engine did not all right let's do this again plus my cages oops list my cages we have no cages let's register arcade do this again how much are we charging and charging 29 tonight this is one fancy cage folks boom we've registered a new cage now let's list your cages oh we have one cages well maybe a plurality thing there but bully's cage is that let's register one more cage this is a huge cage it's carpeted it has all the toys and this one's even for venomous snakes this would be the large boa cage who knows and this is 30 39 now if we look at our cages we have two cages beautiful so it looks like our registering and our listing cages is working great let's add a bookable time to one of our existing cages we were able to register cages and list them now let's make them available for snakes to stay in so we're going to work on this update availability method here we've got our requirement that you have to have an account because they're your cages whose cages you're going to manage right things like that and we're going to just print out the list cages i've changed that slightly so it has a number i'll show you really quick i'm using enumerate and an index so it says 1 2 3 instead of star star star because we want to ask like hey what cage do you want to work with so we're going to add that here and just for the sake of time i'm just going to paste that so it's going to say what cage do you want either you can cancel or it's going to parse that into an integer and then we're going to work with a particular cage so let's go down here and say selected cage oh of course we need the cages let's say cages equals we'll just use our service again get the cages for state.active account and we'll down here get in here and say cages of cage number minus one because we're showing them one two three we've got to convert that back to zero based okay once we've got our cage set we need to get the dates we've selected this cage we'll say the name that you're gonna work with and then we're gonna say enter a date year month day that you'd like to start this available time slot on and for how many days right so i want to start a particular date and make that available for five days now we're using this thing called parser and that comes from date util so python dash date utils module name it's in the requirements already parser is a really sweet way to parse date times it has many many different formats it understands so we're going to use that instead of the builtin date time parsing now once we have this we just need to go and use our service and write another data access method so we'll say add available date and what are we going to pass we have to have the account let's say active account there of the selected cage that we're going to add it to we have to have the start date and the days and let's go ahead and say state.reload account because this might change the account and then we want to just have a little success message like hey good job and f string this okay so now we're down to just pure data access and the interesting part right let's go have pycharm add that function and we'll have a few things here so this is going to be an owner cage date time and it end and it's gonna return nothing okay this looks great so remember what we're adding here is actually a booking and bookings are not top level items but we'll go and create one to get started and we'll say booking is a booking like so and we just got to set the properties this one we've got to do a tiny bit of math here so we'll say start date plus time delta now we want to change the cage and the way it's working probably it's fine to just change the cage and call save but i want to make sure that we absolutely are working with what's in the database so i'll say cage equals actually we can just look it up here i think i'm not sure if we need it again so we'll just say cage dot objects id equals kj id dot first okay then we're going to go over here select cage that was let's change that here again remember the bookings are not top level items they live inside of the cages so here we're going to append the booking here and we call save on the cage not on the booking object right because it doesn't live its own it lives inside the cages here we could return the cage i suppose if we want you know because here's kind of the updated cage we could even tell consumers that that happens i guess we don't need our active account here do we so we can go ahead and drop that and let's just do a quick clean up here get rid of this we're not doing that nothing changes there okay great it looks like we can probably add some time let's go and try to test this out here we're gonna be host we need to log in let's see our cages okay so we've got these two let's update the cage availability the large boa constrictor one is available so that's gonna be number two great we've selected it it's gonna be 2018 slash 01.01 brand new year cage is available and let's say that's for five days great a date was added let's add one more cool now if we list our cages you can see our low large bow constrictor cage now has two available bookings it has this time for five days and that time for 10 days and neither of them are booked because no guests have come along and actually booked it but it's available and now they can go and ask hey what cages are available for my snake and when they ask this boa cage this large broke age should come up maybe we'll make a little side money why our boa constrictor is not using it so before we finish the host side where you actually can see your bookings and things like that that turns out to be one of the most complex types of queries we're doing in this entire application i want to make sure that you can book some stuff so you can see it so the data comes out when we write it that'll make a lot more sense so let's take a moment and focus on the guest side of the things let people come in log in create an account register their snakes and so on so if we go up to the top to our little switch action thing here notice that i'm using the create and login from host there's no reason to write that code twice we'll just use that one now the thing i want to focus on for a moment is adding a snake and viewing your snake now this is super super similar to what we already did so let's go ahead and just talk through this real quick instead of write it from scratch so just like before we have to have an account we ask a few basic questions like what is your snake's name let them cancel by hitting nothing in the first one get the information about the snake and then we call the function add snake and you know you can see this is very very similar so we're going to get the owner get the owner back and maybe it makes more sense because we've been writing the others like this to go like this we're going to create the snake and save it but remember the relationship between snake and owners is managed by the snake ids inside of the owner so we're going to go get a fresh copy of the owner from the database update that and save it then we'll give back the snake that we just created also we call a quick reload account to make sure the snake ids for some reason if they get reused real quick are in the active inmemory account so that's all it means to create a snake just like creating a cage was so everything is exactly the same there and then to view your snakes we just write the function get me the snakes for the user and then we loop over them that again is very much like the cages we get the owner in this case just to be sure that we have the fresh set of ids there and then we do the id in owner.snakeids and we can call the all function and then convert it to a list i suppose we could probably skip this but either way this is all good so this gives us our snakes and we're going to list it out let's go and just run that to make sure this is all working here this time we're going to be a guest and let's go ahead and log in and this time i want to log in as sarah so sarah is going to be my guest and michael is going to be the person with the cages we'll log in so we're logged in as sarah and let's say i'd like to view my snakes hmm you have zero snakes okay let's add a snake so i have slither and slither is 1.2 meters long this is a large gardener and no those are not venomous so we've created slither and let's add one more snake this is going to be bully and bully is 0.5.4 meters let's say this is a bull snake a no now if we save your snakes there's your two snakes okay so our guest side of registering a snake so that we can book it into a cage and viewing it that kind of stuff is all finished so we have cages we have available dates and gauges and we have snakes time to book a snake into a cage and one of those available dates this turns out to be one of the more complicated things we're going to do in this application and there's a lot of like input and juggling stuff so i'm going to paste a few things here just about asking questions about the dates and stuff and then we're going to go and write the database queries from scratch so let's start here we're going to start by making sure you have an account and then we're going to get all the snakes and make sure you have a snake because having an account is not enough you also have to have a snake you can put into there we're going to ask some questions about when do you want to do this we're going to use python date util to parse that so just like before we're going to do a little error handling to make sure like you're not trying to book some sort of reverse thing like i check in before i check out all right check out before i check in something like this right okay so then the next thing we need to do is find out the available cages and this is where it gets interesting so we're going to write a function called get available cages we're going to take the check in the checkout and the snake oh we also need to figure out which snake you want so first of all let's do a you know enumerate list out your snakes and we'll say snake one the snake two is that and he'll pick the snake okay so take our snakes pick that got our k our time and then we're going to go to the database and find a particular cage that we can work with now that's not all there is to it so this is just going to get us the cages that could be booked and then we have to ask that's this little section right here then we have to let the user pick a cage and we'll find the underlying booking behind it so let's write this function so this is going to be a date time date time and a snake you of course don't have to put the type hints but i find like at the data access layer it's really helpful maybe through you can see it through the rest of the application i'm not doing this but at the data access layer i find it really helpful to say like these are the things that go in these are things that go out this is like how we're working with the database okay so here's where we get down to business we're going to come in here let me move this up for you so we need to do a couple of things we need to find all the cages that have bookings that are not booked between this time and that time all right and we need the snake information because we not all cages allow poisonous snakes and they don't all necessarily fit if i have a 20foot snake i can't put it into a twofoot cage so let's just do a little quick um rule of thumb to say if your snake is four times longer or more than the cage then the snake can't go into it right stinks can curl up but they can only curl up so much so we'll say something like the minimum size of the cage we're gonna get is snake dot length over four okay so this this is going to be part of our query the date's gonna be part of the query and the whether or not it's venomous or not we're gonna do a few interesting things here this is definitely one of the more complicated queries so i'm going to the cage and we'll say objects and when you have these complex queries i find it's nice to spread this across multiple lines so i'll say dot filter i have multiple filters and these are effectively ands so i'll say square meters now i'd like to say let's say equals min size or greater right just like we saw with the dollar operators about in there's one for greater than or equal and we can say the square meters are greater than or equal to this minimum size but that's not the only thing that we need we also need to go and do another pretty wild thing we want to go to the bookings now remember just refresh over here we have a cage the cage has a bookings field we go to the definition for bookings bookings have a check in date and a check out date we want to work with that how do we do that in engine we come over here and we can traverse that hierarchy with underscores as well so we can say bookings dot checkin date and we want to have the checkin date before or equal to the checkin that was passed right so the time you can check in has to proceed the time this person is checking in then we'll do something similar for check out okay so this is part of the query now if the snake is poisonous we also want to say that they allow poisonous snakes so we'll say this we'll say if snake dot is venomous we need to augment this query so we can do that because it hasn't executed yet it's like the potential to be executed so we can say query equals query dot filter and what does the thing allow dangerous snakes that's what we want to work with equals true because nondangerous ones can stay in cages that will either allow or not allow dangerous snakes but if it's venomous we have to have this additional criteria and maybe we want to have some kind of order by like we'd like to show them the cheaper ones so let's go like this we'll say cages equals and we'll finalize the query like this we'll say query order by now you don't do this sort of default this named parameter type thing for this i want to order by price and default is ascending so cheapest ones first and maybe you want to see the biggest ones first as well so we'll say square meters like this so we're going to say first order by price lowest to highest and then show us if like the price is the same show us the largest ones at that price level down to the smallest ones excellent so this is pretty much working it turns out it looks like it's going to completely work but it turns out that there's a challenge we're going to run into and in pymongo this is straightforward to solve although i have to use a lot of operators these dollar operators to make it work but i haven't found a good way in engine and so i still find on balance that work with engine even for this query is better but here's the problem what this query is asking you're probably thinking it looks right you know it takes a moment to realize the challenge we're hitting here what this query says is go to the cage and find me the cage with the square meters at least minimum size that's totally fine that works perfectly and it says show me where there's a booking greater than checkout and there's a booking um oops this should be greater than that was almost an error so where there's a checkout date passed equal to or past where i'm willing to check out for my snake the problem is if i have let's say 20 bookings in this cage right i probably want to check one more thing but i can just check it down more we're going to have to do one more bit at the bottom but the problem is what if there's two bookings one that starts way in the past but the checkout is like one day later and then there's another one where the checkout date is way in the future but you can only check in when the day before and these are not the same bookings right there's a booking where the checkin date is before the checkin and there's a booking where the checkout date is after the checkout but those are not the same you need to say there's an individual booking not like some set of bookings where one matches one clause and the other matches the other so the way you do that in is you say dollar element match i think it's lmatch my element match is the description of the thing so you can say both it must have both of these but i don't see how to do that in engine it seems like it should be possible but uh it certainly is possible for equality but for the these operators plus element match didn't seem to work for me anyway if you figure out feel free to use element match i didn't so i've got to add one more line here and i'm just going to copy that over real quick and we'll talk about it so what we're going to do is we're going to say let's go and actually these are the cages we care about i'm going to iterate over the query which executes it here and remember the cage each cage contains the number of bookings for each booking i want to check that both the checkin is before and the checkin is after and that the snake id is none so it's not already booked during that time so if it's both available and the check in checkout date matches then we can make that part of our final cage there our final cage list okay so and it says it returns this but actually what it returns is a list of cage here we go okay so that's what we got to do if i could get element match to work with greater than less than in engine this would not be necessary you could just straight up run that query but anyway it's not a huge deal remember this set is already filtered down to where significantly right where the check in and checkouts do match it just happens to be maybe one more thing is missing there okay so we're getting the available dates so let's come back to our guests here we've got our available cages now we just have to like show them to the user and let them pick it all right so let's just take some prewritten code for this there are certain number of cages available and we're going to enumerate over them and don't need the average rating right now do like this so we're just going to print out the name the square meters whether it's carpeted and whether or not it has toys we don't want that to be true false let's put that yes or no like more friendly right and if there's no cages sorry there's no cages but if there are we'll ask you which one and we'll pick that out you know zero based of course and finally the final thing to do is going to be book a cage and then actually we'll just give out this nice little error mess this nice little success message saying hey you booked it for this time so last thing to do with this book in a cage is to actually book it so let's go over here apply term write it one more time here and now what we're going to do is we're going to loop over that cage's booking so the way it works is they've selected a cage they haven't selected individual booking so we just have to go one more time over the bookings and go uh let's find a booking within this cage which we know exists because it's in the list and let's assign it to the snake so we'll do something like this we'll come down here and we'll start out by this little booking to nothing just in case for some odd reason we don't find one i'm going to go through and again do this similar test as we did right there right we've got to find the available booking within the cage we know it exists but we got to find it then down here we're going to just set a few things say the booking dot guest and get a little uh intel telesense auto completion if you want set the guest owner id i guess we've probably got to pass the account as well we'll say countdown id say booking dot set the booked date it was booked right now regardless of when the booking was and we also need to set the snake there we go and then we got to go back and save it but remember don't call save there we call cage.save okay excellent now i think it just believes that's a misspelling but i'm going to say it's not all right so that should let us book a cage that was a tough one right so pretty interesting query we're using the operators greater than less than we're traversing the hierarchy and uh like i said we're sort of effectively in memory applying this element match match works in engine but i couldn't get it to work with both element match and the operators so anyway this will be fine come down here and given a cage we'll pull out the booking we probably could structure it slightly differently so we could skip this step and somehow capture the booking directly but this is fine it works plenty fast for what we're doing set the hey you booked it values of the booking and call save all right i think it's time for us to test our our bokeh booker cage and i noticed i almost forgot to add this here state.activeaccount when i added it below so let's go and run this we'll come in here and we'll be whoops be a guest and let's go and log in and let's see our snakes we have these two snakes neither of them are venomous let's book a cage i'm going to start by booking this now how do i know that date because over here we have two available bookings for the large boa cage and these times one to six in january so we'll go to let's say two to four should be fine got this four and it says which snake remember we it matters the size of the cage and snake as well as whether it's venomous so we'll pick slither and hey look the one cage is here let's say all right let's book it we've successfully booked the large boa all right now we haven't written view your bookings but we do have that i believe we might have that for the other one go over here as a host and we log in as michael i think we might not have implemented this as well but we can list our cages yes there we go we can see that we have two cages bully's cage and large boa and look at that one somebody has booked this one this slot for the large bow cage yes so it looks like that worked successfully just like we expected all right we're down to the very last thing we're going to do as a guest which is to view our bookings we were able to book a cage but as a guest we couldn't see he you know can't say what are your upcoming stays for your snakes and things like that so again just for the sake of time let me go over here and put some prewritten code and we'll go write the data access layer so require an account and we're going to call get bookings for user and this is going to return a set of bookings and just to remind you what that looks like the bookings are going to have the date possible reviews the snake id is going to be really important so what we want to do is we want to say give us the snake given a snake id and a super simple way for us to do that is to actually just generate a dictionary using a dictionary comprehension so this little expression here is going to create a dictionary where the key is the id and the value is the snake for all the snakes belonging to us whoever the logged in user is then when we get the bookings and we'll this is the part we're going to write and then we're going to loop over here and we're going to print out hey the snake i'm going to use the dictionary lookup to get the name here i'm going to print the cage name and need an import date time there i'm gonna create a date time and do a little bit of math here on the checkout so we're gonna turn this back into days you're checking in on this day for five days something like that okay so that's what our view bookings ui that's pretty much a stretch right with our app but that's kind of a this is kind of the ui code if you will but we've got to write this get bookings for user this is going to be a bson.object id and what we're going to get back is a list of booking i believe now notice one other thing before we write this code over here we're saying b dot cage dot name now cages have bookings but bookings don't have cages there's not a super nice way to create that reverse association in engine so what we're going to do is part of what we're going to do in this function is we're going to set up that relationship and let's call this user id or account id something like that okay so the first thing we need to do is find the owner so call this account equals let's pass in an email instead something like that and before i forget passing the email there okay great so we'll have our account and we've already verified that they're logged in so we can just assume that that happens so we can say booked cages and so we can find all the cages that have been booked by this person so we can say cage not objects and now we'll do a few other interesting things we haven't seen yet say filter and here we'll say bookings double underscore and then we're looking for what let's see the guest owner id let's go to our booking that matches the owner that equals to account dot id we don't actually care about all the details about the cage and you could skip this little part right here but just as as a means of efficiency we can come over here and say only we haven't talked about this yet so what we can do is say we only want to get back two pieces of information not potentially tons of information in this document we want the bookings and we want the name so when we say cage.name above that means something right so let's create the bookings and we'll do this with a list comprehension so we'll say bookings is this i'm going to write in one way and then i have to make a change to this reverse association with the cage so i can say booking or booking in the book cages but remember there are other bookings that are unrelated to us here right it could be two different snakes staying the same cage different days we need a little test all right so this is going to be the bookings that are assigned to us within the cages for which we have booked right so show me all the cages where we've booked at least one of the bookings then we're going to strip out the unrelated ones so you might think that we're kind of done and we're very very close to done but we're not done so if we run this you should see this is going to crash because of that line right there now oh i almost messed this up so this is actually for cage in the book cages and each cage contains a booking so we've got to do a double loop here booking in cage.bookings so what we're going to do is going to take this hierarchical list of cages which inside nested inside them contain a bunch of bookings and we're going to flatten that list with a double loop go through each cage go through each booking and just turn that into a list and across all those bookings across all the cages only show the ones which we some point have booked okay so this is close but if we try to run it this reverse lookup of the cage here is not going to work so let's see we can try to run that real quick save go as a guest log in and sarah now if we try to view your bookings see no cage so let's do a one more little trick we can do a transformation at this level right this is like the select part of the list comprehension now this has to be an expression and i don't think we can do this with a lambda expression because it it doesn't allow us to make modifications so we've got to define this little local function so i'll say map cage to booking given a cage in a booking it's gonna be the silliest thing you've seen booking.cage equals cage well and then we're going to return cage sorry booking so why do we need that we need that so we come down here and we add this function it's going to take a booking and it's going to put that same booking right back into the list but the booking will be changed in that it's going to have a cage associated with it okay so i know that's not super obvious but that's what we need to make that one line work oh wow i made a quick error here uh those i had booking cage here and cage booking there so cage booking gate okay okay looks like it's ready let's try again all right let's view our bookings it works we have one booking our snake slither is booked in the large boa on this days for five days so let's add one more booking just to make sure this is working so book a cage all right so let's try to book that other available booking uh this time i'm gonna put bully in there and i guess we're gonna book that one great if we view our bookings again we now have our snakes booked into the different sections at the different times let's just try one more time now that those bookings should have been used up to see what happens so let's try to book one more cage say we'll start on that date let's check out on that date and we'll use this one sorry no cages both the available slots have already been booked just so happens to be to our snakes awesome it looks like the guest side of things is 100 working we just have one function left to write for viewing the bookings as a host what bookings available booking dates in your cages have been booked and we'll be done with this application so this require account stuff paste that that's the same nothing special there now we want to get the cages for the current user well guess what we've already written that find cages for user state dot active account that's cool so that was already done at some point along the way and then what we need to do is we want to get the bookings and we want actually a flat list of these are all available slots that people have booked across all the cages all right so what we're going to do is something called bookings like this a list comprehension and we're going to use sort of a dual comprehension to flatten it so i'm going to put something here one and two things i'll say what those are for in a minute so we want to say 4c in cages and then for each cage we're going to say for b in c dot bookings now we don't want all of them right there's already a way to see that kind of stuff but what we want is the ones that have been booked we know they're booked if the booked time or the book date was set so say if b dot book date is not none what do we want to get back here we want to get the cage and the booking so we're going to get a flat list of all the bookings and along with it we're going to carry along it's it's book it's cage that it came from so that's pretty straightforward and then that's this part getting them as a flat list and then the last thing to do is just print them out and that's a lot of typing for not a lot of value so let's paste that over we'll import date time and we're going to as we loop over them we're going to unpack that tuple so the cb here gets unpacked into the cb right there and we'll say for this cage it was booked on this date um by so and so all right it looks like this is going to work i have a lot of faith in it let's give it a try we'll come over here we're going to be a host we're going to log in as me and are you ready moment of truth view your bookings no there's no duration in days ah so where did this duration days go so this is the booking let's look at the booking real quick here it has a check in and check out date let's add this duration in days now if we add it as an actual thing that engine saves that won't be so great because it's going to have duplicate data check in checkout and days like they could get out of sync so what we're going to do is we're going to add a property so we have a property called duration in days ah so close days is that the same yes duration and days so down here we just need to use the time delta to figure out what that is so we'll say dt equals self not check out date minus self.check in date and we'll return dt.days all right let's try to run this again oh double double ats come on too much help here there we go all right come in as a host vlog is me oh ready view your bookings beautiful and you can see our property is working just right there so five days and ten days now remember when we actually check we said we're going to book it we could book it for a subset of time we just don't store the data for how long the user said versus how long the time slot was so they kind of get that whole slot and that slot is worth five days and ten days in duration but given the data that we're keeping this is working totally well so i think we've done everything we can create an account log in we can list our cages we can register a cage which we already did we can update the availability which is how we got these slots we can view our bookings which we just wrote and we could even get little help and go back to the main menu and we could check out the guest just one more time around again create login same thing um it says book a cage that's reserve a cage for your snake we saw that we can add snakes oh i gotta log in as sarah she's the one with snakes she has those snakes there she can view her bookings from the perspective of her snake not from the available slots things like that right she only sees her bookings not all the bookings across everything and we go back to the main menu or because we're done we can say goodbye to snakebnb now that we've built our app let's review some of the core concepts we saw along the way if we want to insert an object we just create a standard python object style we just say owner equals owner call the initializer we could either pass the values as keyword arguments or we could say owner.name equals name owner.email equals email and at this moment there is no id associated with this object but then we just call owner.save and now the object id or whatever the primary key is we can set functions to be called when that happens for that generation whatever that's going to be we've got it set after you call save so now you can start working with it as if it came from the database we also might want to insert a bunch of things it turns out if you have a hundred thousand items to insert and you create one save let's create one called save create one called save it's a lot of database back and forth and it's very slow so what you would rather do is create a list of them so here we have a bunch of snakes we want to save we create a bunch of them put them in this list and then you call snake.objects.insert and you give it the list and that's much quicker if you want to do a bulk insert type thing we saw that querying the database is pretty straightforward the way it works is we start with the collection the type that represents the collection we want to work with and then we say dot filter so here we're saying filter and we want to do a match where the email equals the value of the email variable and you could have more than one thing in here you can have more than one filter statement and those basically combine as an and now this would return a potentially a bunch of owners but we don't want a bunch of owners we want the one that we know matches this email so we can say dot first and it'll give us the one or at least the first item to match if there's no no match we get none back we don't get a crash or anything like that when we're querying against just plain straight fields in our object that's pretty straightforward we said email equals the value that we're looking for but if we're looking deep inside of a hierarchy can get a little more let's say not obvious so we're combining two really interesting things here we're going to the cage we're going to search within the bookings embedded document list right bookings was a list and it contains a bunch of these booking objects so the first thing that we're doing is using double underscore say bookings guest snake id so we're looking at the value guest snake id of the booking items within that list and we're also applying the in operator so the double underscore in means the collection on the right we're doing an in test for the various booking snake id so we use the double underscore to separate and navigate the levels and sub documents as well as to apply the particular dollar operators and then what i consider best practice is to fully execute the query before you leave this function if we just return to book cages it kind of still is not yet executed it hasn't quite talked to the database and so i want the database to be done and over with by the time we leave this method so wrapping it in a list will execute all that stuff and pull it back for super large amounts of data there might be reasons you don't do this but for most of them i would do something like this now sometimes you don't want a quality in your matches you want some kind of operator like greater than or less than or in or things like that so here you can see we're going to the cage and we're finding all the cages where the square meter is at least the minimum size so just like with sub documents we use the double underscore and the operator name gte here to actually do this query right there's a bunch of dollar operators you can find them in the mongodb documentation and you apply all of them in this way now the other thing that we're looking at here that we didn't do in our app is count so if we want to know how many cages there were we could say do the query dot count and it'll just do a count in the database rather than pull all the objects back where you do a length of it or something like that the most straightforward way to make changes to a document or to a record is to go get it from the database change the class and call save so in this example we're going to go get the owner out of the database make sure that's all good right don't have errors we're going to create a snake we're going to do work with the snake and then we want to append the snake id onto the owner's snake id collection so on line 11 we say owner.snakeids.append and we give it this new id that was gotten from the snake on line nine when we called save and we save the owner and that's that all right so we get the document we make a change to it in the case of line 11 here and then we just call save and that pushes it back this works but that transfers the entire document out of the database over to our app serial deserializes it processes it and then reverses that back to the database that can be slow but that can also have concurrency issues if two people run this exact same method at almost exactly the same time with the same email address there's a chance that one save is going to overwrite the snake ids of the other right both of them read the owner one makes a change one makes a change one saves the other saves you only have one snake not two so there are challenges with this but if you're pretty confident that that's not an issue you're going to run into this is a really nice and easy way to do it well mongodb and engine let us work with these documents make changes and push them back in there might be a better way so if we know that we want to just change some small part of the document in a very controlled way we might want to use some of the atomic operators so here let's suppose that there's a number of stays field which is an integer in the cage so we just keep track of how many times people have stayed at it now there probably are better ways to get this but let's suppose that is a number and we want to increment it so instead of pulling the cage back and doing a plus equals one sort of thing and saving it we can literally go to and say increment this number the value of number of stays by one and that could be negative that could be 10 but i have 1 here so you write the query dot update 1 and then pass the little operator so that's really great now how about this putting the snake id on the owner well we can do that too so over here we're adding a snake we generate the snake we call save that's standard that's an insert but then this line where we have the number of updated we have owner objects emails email and instead of saying you know get it back make the change append it to the snake ids and call save we're doing something with an operator so we're seeing update 1 and we're using the push operator that's dollar push and we're going to push it onto the snake ids collection another thing we might do which probably makes even more sense would be add to set that's another related operator that will say add this id to this set or this list if and only if it doesn't already exist so you won't get duplicates right so we're pushing the snake id on there that way we never pull the owner back these are atomic they're perfectly fine in concurrent situations things like that so this time we have to check that we updated it in a different way but you know the same effect as we saw before so engine supports these inplace updates array operations and set operations so like increment as well as push and these are both better for concurrent safety think of them as basically transactional and they're better in pure performance so they're not always as simple to work with but they are better if you can use them there it is the finish line you have made it congratulations i hope you've learned a lot throughout this course we really have covered a majority of what you need to program against mongodb so you've done it you've crossed the line now you know enough to start building applications based on mongodb so the big question is what are you going to build now i hope you go out and build something amazing please share it with me when you do i want to take this moment to remind you to get the source code come over to github.com mike c kennedy slash mongodb quick start dash course and star and fork this so you're sure to have a copy so one thing i do want to take you through really quick two things one i covered in the beginning is there is the starter code which is here this is exactly what we started from and here is what we have finished with you can see right there 15 minutes ago i wrote final code but i also wanted to make sure there were save points along the way so if we go back here and check out the branches you'll see there's all these different branches so these are all different save points that you can grab so if i go here for example you can see final registered and list cages guests can now book a snake into a cage and things like so these are different points in the course that you can go back and forward to so be sure to make use of the branches and things like that if that can help you you've learned a bunch of stuff to program mongodb using engine but there's actually a lot of other things that you need to take into consideration when you're doing mongodb in production for real applications so i want to encourage you to check out my paid course mongodb for python developers and just some of the things we're covering you've seen a little bit of it but there's actually a lot more so this is over seven hours of professional grade mongodb and python programming not just engine but the core pymongo the javascript api and so on so let's see a little bit of what's covered so we talk at in depth about how to set up your machine whether it's windows mac or linux the tools that we're going to use how to get them installed why the theory behind of nosql y nosql why document databases mongodb's native shell and native query syntax so when we run these operations these queries filter statements and so on in engine how does that map down to the database this is important because when you're running mongodb and production you need to be able to use the tools and the query language to talk to it manage it right and that is in this native query api how to model data with documents we did talk about this we go into more depth in this course mongodb from pi this is the foundation of engine and basically the python's equivalent of the native query syntax engine that's we covered a lot of that in this course so this is pretty similar high performance techniques so performance around document design performance around indexes and using profiling to discover where you need those so that's covered in this course and super super important is how to properly deploy mongodb in production on the internet so it doesn't get hacked and you don't lose data or anything like that so if you want to check out this course here's a tremendously long url that you very likely don't want to type so type this bit dot lee slash manga course and that'll take you right there you can check it out i encourage you to take this course if you like what you saw on this course here's seven more hours going even more in depth so with that i want to say thank you thank you so much for taking my course i really hope you learned a lot and you enjoyed it please connect with me on twitter at m kennedy or various other places you find me on the internet thanks and see you later
