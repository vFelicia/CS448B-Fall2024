With timestamps:

00:00 - [MUSIC PLAYING]
00:49 - DAVID MALAN: All right.
00:51 - This CS50 and this is
lecture 7 wherein we pick up
00:55 - where we left off last time
in talking more about Python,
00:58 - but this time using Python for
even more powerful purposes,
01:02 - an alliteration I didn't intend
until I just said it there.
01:04 - But the goal here with
Python now is to actually use
01:07 - this language to generate another
language, in particular HTML.
01:11 - And what we'll do is start to provide
all the more of a mental model
01:15 - for what you would call
separation of concerns, whereby
01:17 - when you design more complicated
web based, or rather when you design
01:21 - more complicated software, you tend to
try to adopt certain design patterns so
01:25 - that you're not just writing
everything in one big file that
01:28 - gets a little confusing, unwieldy
to maintain and to add to over time.
01:31 - But you start to separate your
concerns, and your functionality,
01:34 - and your features, and
your collaborators' work
01:36 - into different files and
different methodologies.
01:39 - So we'll try to give you some of these
industry standard approaches today
01:42 - and why they actually solved problems.
01:43 - But, of course, how did we get here?
01:45 - A few weeks ago, we
talked about this thing,
01:46 - this virtual envelope
that just represents
01:48 - packets of information, zeros and ones,
going across the internet from point A
01:52 - to point B. And among the
messages in these envelopes
01:55 - might be for web requests.
01:56 - And we talked about HTTP, a protocol,
hypertext transfer protocol,
02:00 - that just sends message like
this inside of the envelope.
02:03 - And this is requesting, of
course, the default page
02:06 - of a website as implied by the slash.
02:08 - And in many cases, but
not always, this implies
02:11 - a default file name of index.html.
02:13 - But that's a human
convention, not a requirement.
02:16 - Hopefully, the server responds with
a numeric code equal to what integer?
02:23 - 200, hopefully, a number
that we never actually
02:26 - really see unless you
get more comfortable
02:28 - and start poking around
Chrome's inspector
02:30 - and you look at your network traffic.
02:31 - Right.
02:32 - So here is an actual
successful response,
02:34 - which means everything is indeed OK.
02:36 - And if the browser looks a little
farther down in the virtual envelope,
02:40 - if you will, it will see another
language called HTML, HyperText Markup
02:43 - Language, which is the stuff
we wrote a couple of weeks ago
02:46 - and you'll continue writing this week as
you now dynamically generate websites.
02:51 - But what we'll introduce today is
what's also known as a framework,
02:55 - or, more precisely, a microframework,
because we'll see in just a few minutes
02:58 - time that it can actually be
really annoying and really tedious
03:02 - to generate websites
automatically using Python
03:05 - if you have to write Python code alone.
03:07 - And so humans, over
the past several years,
03:09 - have noticed, wow, every time I
make a web application using Python,
03:13 - I find myself typing
the same lines of code
03:15 - again and again just to get started,
or when I'm collaborating with someone
03:18 - else, I find that, ooh, it's
a little hard to collaborate
03:21 - if we're all working in the same file.
03:23 - So humans have invented
what are called frameworks.
03:25 - And this is an example
of code written in Python
03:29 - but using a framework called Flask.
03:31 - So whereas Bootstrap, which
you've played with a little bit,
03:34 - is a framework for CSS and JavaScript,
they have some dynamic features
03:38 - as well, Flask is a
framework for Python that
03:42 - just gives you some library
code that you can use freely
03:45 - in your own applications.
03:46 - And it just makes it, ultimately, a
little easier to get your work done
03:50 - and build the thing you
want to build as opposed
03:52 - to having to reinvent the wheel again
and again like people before you.
03:57 - And so here is a methodology to
which I alluded earlier just to have
04:01 - a mental model for the coming weeks.
04:03 - So up until now, pretty
much every program
04:05 - we've written in C and
most recently in Python
04:09 - you could call like controller code
or controller logic or business logic.
04:14 - Right.
04:14 - It's all about getting
something done logically,
04:16 - usually in one file, maybe two files if
you have another helpers.ce or header
04:21 - file or whatnot.
04:22 - But we've been writing logic.
04:24 - But today and two weeks
ago when we will focus
04:26 - on web programming in HTML and CSS,
there's the second part of our world.
04:31 - There's like the logic that gets the
interesting work done with loops,
04:34 - and conditions, and all that.
04:35 - But there's also now going
to be the aesthetics,
04:37 - the stuff that the user actually sees
and the way you present your data.
04:42 - So we're going to just introduce
two letters of an acronym
04:45 - today moving forward.
04:46 - Anytime you start writing
logical code in Python,
04:49 - it's going to be called your controller.
04:51 - It's sort of like the machine that
operates your entire web application,
04:55 - but anytime you do
something more aesthetic,
04:57 - we're going to call that your view
code, so C and V being the letters here.
05:01 - And this just refers to
a separation of concerns.
05:03 - Your logic goes in this file.
05:05 - And your aesthetics and
formatting go in this other file.
05:08 - Next week, we'll introduce databases
in SQL, structured query language.
05:12 - And we'll introduce an M here,
because the acronym that's
05:15 - in vogue for quite some time
now is MVC, though there
05:18 - are alternatives to this mental model.
05:19 - And that just means there
are three different types
05:21 - of things you should be thinking
about when building an application.
05:24 - But today we're going to focus on
these two, controller and view.
05:27 - And up until now, we've pretty much
been doing entirely controller stuff
05:30 - when writing code.
05:32 - So the motivation, ultimately, will
be to get to the point of building,
05:35 - essentially, this, the freshman
intramural sports website,
05:39 - which I was the first one to
make back in 1996 as a sophomore,
05:44 - maybe 1997 as a junior, after
having only taken CS50 and a follow
05:48 - on class CS51.
05:49 - And even though this is horrifying
to see nowadays, underneath the hood
05:54 - was a whole bunch of controller logic
and a whole bunch of model code,
05:57 - even though I don't think
MVC existed as an acronym
06:00 - back then till humans
figured out the pattern.
06:02 - But what it did have via the menu up
here was a whole lot of functionality.
06:06 - So no longer did you have to walk
across campus filling out a form
06:09 - and drop off a sheet of paper in
an RA or a proctor's dorm room.
06:13 - You can instead just go on the web,
which all of us surely take for granted
06:16 - today, fill out a web-based form.
06:18 - And then at the time, the
proctor in charge of froshims
06:22 - would get an email confirming who
had actually registered for a sport.
06:25 - And eventually we added CSV
files, comma separated values
06:28 - files like spreadsheets, in
which the data was saved.
06:30 - Then we had this really
cool tournament bracket
06:32 - thing, which was all very dynamic
and impressive I'm sure at the time.
06:35 - But we'll focus on really
just the fundamentals today.
06:38 - So how do we get there?
06:39 - Well, let me go ahead
and open up CS50 IDE
06:42 - and propose that if we want
to make a website, a web
06:46 - application really, and by application
I mean something that does have logic.
06:50 - By website, it's generally
something that's static.
06:52 - So that's what a web app is.
06:53 - It's something that changes based on
who's using it, when you're using it,
06:56 - and what you're doing with it.
06:58 - Let me go ahead, and in the most
annoying tedious way possible,
07:02 - implement a web
application using Python.
07:05 - So I'm going to go ahead and open a file
called serve.pie to serve up a website.
07:11 - And I'm going to go ahead
and import some library code.
07:13 - So from HTTP server, import something
called base HTTP request handler
07:19 - and also something called HTTP server.
07:21 - And then I'm going to go ahead
and use this keyword class, which
07:24 - is HTTP server, server request, request
handler, base HTTP request handler--
07:36 - handler.
07:37 - Then I'm going to go ahead
and in here implement
07:39 - a function called def
do_GET, which implies--
07:44 - this is a function in Python that
should be called anytime a user
07:48 - visits my web server via
GET, the type of verb
07:51 - that we've talked about
in the context of the web.
07:54 - So suppose that my only
goal here is to make
07:56 - a web-based application that for
the moment just says hello world.
08:00 - We know how to do this with HTML,
but with HTML that's just a file.
08:03 - Let's write a program that
not just prints hello world,
08:07 - but generates a web page
containing hello world.
08:10 - So the way I might do this is this.
08:11 - I can literally say self, because self
refers to the web server in this case.
08:15 - And I can go ahead and send
a response code of 200,
08:18 - just kind of presumptuously
assuming everything's
08:20 - going to be OK in a moment.
08:22 - Then I'm going to go ahead
and send a header, which
08:24 - recall, we've discussed
briefly in the past,
08:26 - whereby this header is going to
be content type and its value
08:31 - is going to be text HTML,
which is a clue to browser
08:34 - that it's receiving not a GIF,
or JPEG, or something else,
08:37 - but an actual HTML page.
08:39 - And then I'm going to go ahead
and say that's it for the headers.
08:42 - I'm going to call function
called end headers.
08:44 - And then lastly, I'm
going to use Python code
08:47 - to dynamically generate my website.
08:49 - Now, what does the website have to have?
08:51 - Just hello world at the end of the
day, but there's a whole bunch of html
08:54 - we need to do in order
to get to that point.
08:56 - So I'm going to use a function
called wfile write in order
09:00 - to write out the following.
09:02 - Let me go ahead and write out doctype--
09:05 - whoops, exclamation point doctype HTML.
09:09 - Then let me go ahead and do the same
thing, wfile.write, let me go ahead
09:14 - and copy paste this moving forward,
which, of course, is always
09:17 - a bad instinct.
09:18 - Then let me go ahead and output
HTML lang equals en for English.
09:24 - And notice I'm using single
quotes inside my double quotes
09:26 - so that Python doesn't get confused.
09:28 - Then let me go ahead and
output head tag here.
09:33 - Then what comes after
the head tag typically?
09:36 - Yeah, so usually title lately.
09:38 - So title will be like hello
title, close the title tag.
09:44 - And now we're going to go ahead
and what comes after title?
09:49 - Close head, I think, if
I'm doing this right.
09:51 - And then after this we
probably have a body.
09:55 - And then oh my God, this is the
worst way to build a website.
09:58 - But let's go ahead and now say
something simple like hello world.
10:02 - And now let's go in here
and say something like body.
10:06 - And then finally, let's go ahead
and end the page and say slash HTML.
10:13 - Done.
10:14 - OK, and now I actually need to configure
the server to listen on a port.
10:17 - So let me go ahead and define a TCP
port of 8080, which we've been using.
10:21 - Let me go ahead and define
the server's address as being,
10:23 - oh 0.0.0.0, which is what the IDE uses
by default, like a lot of servers.
10:28 - And then let me create the
web server, HTTP server.
10:32 - server_address HTTP server request
handler, httpd.serve_forever.
10:43 - OK, that is how you make a
web-based application that
10:45 - dynamically generates HTML.
10:47 - In retrospect, I really regret typing
all of that out because the whole point
10:51 - now is to throw this code away.
10:53 - Like, this is why frameworks exist.
10:55 - If my goal quite simply at hand is
to write Python code that dynamically
11:00 - generates HTML, then calling
lots of functions like write,
11:04 - which is essentially the equivalent of
print in this context, is just tedious.
11:08 - I got bored writing it, I
accomplished so terribly
11:11 - little at the end of the day.
11:12 - And so frameworks exist
to make our lives easier.
11:15 - But what's going on underneath
the hood is exactly this.
11:19 - When we start using this
framework called Flask,
11:21 - it's just going to make all
of this automated for us.
11:24 - It's going to make it easier to
specify the IP address that you
11:27 - want to run your web
server on, it's going
11:29 - to make it easier to specify the
port number that you want your server
11:32 - to be listening on, and
it's going to make it easier
11:35 - to respond to get requests
because Flask will
11:38 - take care of the implementation of some
function like this one called do get.
11:44 - So all of this is there
underneath the hood,
11:46 - but the flask framework gives
us essentially an abstraction
11:50 - on top of that.
11:51 - So what do I actually mean by that?
11:53 - If we want to distill this now
into a simpler web application,
11:57 - first let's go ahead and do this.
11:58 - Let me go ahead and open up a terminal
window and let me go into my code
12:03 - here and go ahead and
run Python of serve.py.
12:07 - And you'll see nothing seems
to be happening just yet.
12:10 - So I'm going to go to
cs50 IDE web server
12:11 - to open up a tab containing the
web server that I'm now running.
12:15 - And you'll see that's it.
12:17 - That's the only thing I
accomplished right now.
12:18 - It's not dynamic to be sure, but
there is code and Python code
12:21 - there with which I could actually
do something dynamically.
12:25 - But let's instead do this now
with Flask, this framework
12:28 - that seems to make our lives easier.
12:30 - I'm going to go ahead and make a
program called application.py, which
12:34 - is just a convention.
12:35 - I could call it anything I want.
12:37 - And I'm going to go ahead
and say the following.
12:39 - Let's first go ahead and import
this framework called Flask.
12:42 - And specifically import
capitalized flask, which
12:45 - is the name of the framework itself.
12:46 - And then let me preemptively
import a couple of functions
12:49 - called render template and then this
special global variable called request.
12:53 - You would only know to do this
from reading the documentation.
12:55 - But now let me go ahead
and say, hey Flask,
12:58 - could you please give
me a web application?
13:01 - And this is copy paste.
13:02 - You need this at the top
of any Flask application,
13:04 - and it just means turn this file--
13:07 - application.py-- into a web application.
13:11 - Then lastly, I'm going
to go ahead and do this.
13:13 - I'm going to tell Flask I
want to build an app that
13:15 - has a route that's listening for
slash inside of that virtual envelope.
13:20 - And whenever, Flask, you see a
request for slash from some user,
13:25 - go ahead and call this function
which I arbitrarily called index,
13:29 - but I could call it foo,
or bar, or whatever.
13:31 - And what I want you to do
is this, return hello world.
13:36 - And that's it.
13:38 - So all of those other lines I
tediously wrote out a moment ago
13:41 - are now distilled into just
7 lines, which none of which
13:44 - are completely obvious
how they work just yet.
13:47 - But if you assume that this means
give me access to the library,
13:50 - turned my file into a web
application, and listen now
13:53 - for get requests on slash,
it kind of makes sense
13:57 - and fits into the mental model that
we introduced a couple of weeks
13:59 - ago with HTML and CSS itself.
14:02 - And to run this server, what I'm going
to do now in my hello directory, which
14:06 - is where a online copy of this
is on the course's website,
14:09 - I'm going to go ahead and
quite simply say Flask run.
14:11 - So Flask is not only a framework
or code that you have access
14:14 - to as free and open
source code, but it's also
14:17 - a program you can run at the
command line that also figures out
14:19 - how to turn the server on
and just run it forever.
14:22 - You're going to see some diagnostic
output at first glance, most of which
14:25 - you don't have to care about.
14:26 - But there will be a few
URL that's spit out which
14:29 - is based on your own user name.
14:30 - Mine today is jharvard 3 just
for demonstration purposes.
14:34 - And if you click on that
URL and then click Open,
14:37 - you'll see now this version of the
same application doing just this.
14:42 - Now, I'm kind of cheating, though.
14:43 - Because if I open up Chrome and view
my page source, notice that of course
14:47 - I'm cheating because all I've
done is print out hello world.
14:51 - And if I view the
source of this page, I'm
14:52 - literally only going to say
hello world and no actual HTML
14:57 - because I literally didn't
type out any HTML in my file.
15:00 - But it turns out that Flask
makes this easy, as well.
15:04 - So let me go ahead and stop the
server here for just a moment.
15:06 - Control-c is your
friend, it gets you out
15:08 - of whatever program is actually running.
15:10 - And let me go ahead and do this.
15:12 - Let me go ahead and not just
return quote-unquote hello world
15:14 - as a hardcoded value.
15:16 - Let me go ahead and return the rendering
of a template called index.html.
15:22 - And so this is a feature of Flask, too.
15:24 - If you want to separate your logic--
15:27 - your controller-- from your HTML--
15:29 - your view-- you literally put
the former in application.pi,
15:33 - and you put the latter in
an HTML file like this.
15:36 - And you tell the controller code--
15:38 - application.py-- show
the user, to render
15:41 - for the user the index.html file.
15:44 - So where do I put this?
15:46 - The convention would be to make
a directory called templates.
15:50 - And then in that directory, go ahead
and put a file called index.html.
15:55 - And if I go ahead and open
up the file that I already
15:57 - created in advance of class here, let
me just show you what this looks like.
16:01 - And then we'll take a
look at it in a browser.
16:03 - Here is HTML now with
a pretty fancy feature
16:09 - that we're about to
reveal the utility of.
16:11 - What jumps out at you
is new in this file?
16:16 - AUDIENCE: Two curly braces on the name.
16:18 - DAVID MALAN: Yeah, two curly braces.
16:20 - And somehow or other that
used to be saying world,
16:22 - but in my final version
of this I actually
16:25 - am hinting at some more
powerful capabilities.
16:27 - This kind of looks like a
placeholder, if you will.
16:29 - Maybe someone's actual name.
16:31 - And here's where the power of
something like Flask comes into play.
16:34 - It makes it really easy
to do something like this.
16:37 - So let me go ahead
and actually turn this
16:39 - into something a little
more interesting.
16:41 - Let me go into application.py.
16:43 - And before I actually render this HTML
file, let me go ahead and do this.
16:47 - Let me go ahead and declare
a variable called name.
16:50 - And let me go ahead and
check the incoming request,
16:54 - the inside of that virtual envelope.
16:56 - Let me check its arguments or any of
the HTTP parameters that were passed in
17:01 - and try to get something
called name like this.
17:05 - Let me go ahead and save
that and then notice this.
17:07 - Render template takes
multiple arguments.
17:10 - The first one should be the name
of the template you want to render.
17:12 - But if you want to pass
in data dynamically,
17:15 - you can use named parameters in Python.
17:19 - Recall from last week that you can
do things like this, x equals y,
17:22 - and z equals w.
17:23 - You can pass in the names of
the things you want to pass in
17:26 - and their corresponding values.
17:28 - So if I want to pass in a name variable
and set it equal to the name variable
17:35 - that I just defined,
watch what we can do here.
17:38 - Let me go back to my console.
17:41 - Let me go ahead and rerun in my hello
directory, which is available online,
17:45 - Flask run.
17:47 - And now let me go over to this where
it previously said hello world.
17:51 - Let me now, just like with our
Google example a couple of weeks
17:54 - ago, type in not q equals cats,
which is what we did last time,
17:57 - but maybe name equals David
to simulate a get request.
18:01 - And if I did everything right, when I
hit Enter I now see this dynamically.
18:06 - And if I change this now from
David to, say, Veronica, of course,
18:10 - this is going to
dynamically output this.
18:11 - Can someone now try to break my code?
18:14 - Propose an input that I should try
to see if I messed up somewhere.
18:19 - AUDIENCE: No entry.
18:21 - DAVID MALAN: OK, no input.
18:22 - Or what's that?
18:24 - say again?
18:26 - Name equals name, I like that one, too.
18:28 - So let's try that, name equals name.
18:29 - So OK, I mean it's kind of maybe like
a grammatical bug or semantic bug,
18:34 - but not really a code bug per se.
18:37 - That's just user error.
18:38 - But what if I just get rid of it?
18:40 - OK, that just looks a little stupid.
18:42 - So an aesthetic bug, but we should
probably start handling this.
18:44 - What if I get rid of name altogether?
18:46 - Interesting.
18:47 - It seems that my final version actually
has some built in functionality.
18:50 - So where is that coming from?
18:52 - Well, what if I did this?
18:53 - It turns out that I could
say something like this.
18:56 - If not name, then go ahead
and set name equal to world
18:59 - would be one way of doing it.
19:01 - Or I could actually
use the function here.
19:04 - Turns out that this get function
can take a default value.
19:07 - And so if you read the
documentation, you'll
19:09 - see that the second
value you provide will be
19:11 - used if the user hasn't provided one.
19:13 - And so indeed, if I reload now
and see nothing, I get world.
19:17 - And if I instead do name equals, say,
Brian, I get that dynamic output.
19:21 - And so when I say web application,
this is just a hint of what I mean.
19:26 - This is dynamically generated content.
19:28 - It's not hardcoded, because it's
actually coming from the user.
19:31 - So when Google implements its
slash search web application,
19:35 - this is the kind of thing they're doing.
19:37 - It's way more involved, of course.
19:38 - They're searching a database, looking
for cats, and dogs, or whatever
19:41 - it is you're searching for
and then generating HTML.
19:44 - But notice with just
this simple approach
19:46 - can we ourselves generate
any HTML we want dynamically.
19:50 - Because all we have
to do in that template
19:52 - called index.html is exactly this.
19:56 - Hello, comma, and then
a placeholder where
19:59 - name is the variable you're passing in.
20:01 - And so to be clear, it doesn't
have to be called name.
20:04 - I could do something like foo,
which would be a little nonsensical.
20:07 - But if I do that, the variable I
plug in needs to be called foo here.
20:11 - And so there's a one
to one correspondence
20:13 - between the things before the
equal signs and where they get
20:16 - plugged in down here.
20:19 - Any questions, then, on this
simple example, but building block?
20:22 - Yeah?
20:23 - AUDIENCE: [INAUDIBLE]
dynamically generated.
20:27 - DAVID MALAN: Sure.
20:28 - By dynamically generated, I mean I have
not written in advance by typing it out
20:34 - manually a web page that says
hello David, or hello Brian,
20:37 - or hello Veronica.
20:40 - Those pages are all generated
dynamically based on user input.
20:45 - I wrote most of those pages.
20:46 - I wrote everything up into and
after the comma, but then-- sorry,
20:49 - up to the comma, but then the
names are dynamically added.
20:54 - Good question.
20:54 - Other questions?
20:57 - All right.
20:58 - So why don't we rewind
to 1997 or so and see
21:04 - if we can't build a more dynamic
web application that actually allow
21:07 - students to register
for something that's
21:09 - a little more compelling than
just providing their name?
21:12 - So let me go ahead and open up froshim0,
which is the first larger scale
21:17 - application we have here today.
21:18 - And notice that I have a few files.
21:21 - So already things are going to
escalate quickly whereby we're
21:24 - going to suddenly introduce
multiple templates,
21:26 - but we'll do this in
order to solve a problem.
21:28 - But first let me go ahead
and open up application,py,
21:31 - which just like your main function
in C is kind of the entry point now
21:35 - to a web-based application.
21:37 - So notice that-- let's start like this.
21:40 - Let me go ahead and delete that
and start from the beginning here.
21:44 - Let's go ahead and do this.
21:47 - In froshim0, we have this
default route of slash,
21:52 - and notice that it's going
to render index.html.
21:55 - So when you start to
read someone else's code,
21:56 - you kind of follow these breadcrumbs.
21:58 - So let me go ahead and open
the same folder, froshim0.
22:01 - Let me go into--
22:03 - let me go ahead, rather, let's
do this from scratch, actually.
22:06 - Let's do this.
22:07 - Index.html, and let me do
the familiar doctype HTML.
22:13 - Then let me go ahead and do an HTML tag
here, it finishes my thought for me.
22:16 - The head tag here, the title tag
here, froshim0 will be the title here.
22:22 - Let me go ahead and create a body.
22:23 - And now for this web
page, I want to go ahead
22:26 - and have a few things via which the
user can actually register for froshim.
22:30 - So let me go ahead and
have just some title text
22:32 - here, like register for froshims
like I did back in the day.
22:36 - Then let me go ahead
and start a form tag.
22:38 - And then in here, what
information might a student
22:41 - want to provide when registering
for something like a sports team?
22:44 - AUDIENCE: Name.
22:45 - DAVID MALAN: OK, the student's name.
22:46 - So input type equals text.
22:50 - The name of this input probably
shouldn't be something generic like q,
22:53 - it should probably be more
descriptive like name.
22:55 - So its a little weird
looking, but name equals name.
22:57 - And we'll go ahead and do this.
22:58 - And if we really want
to be fancy, we can
23:00 - do like a placeholder text of name just
to in light gray text show the user
23:04 - what we want.
23:05 - And then back in the day,
minimally the students
23:07 - registering for sports
had to provide their dorm,
23:09 - so the building in which they lived.
23:11 - So in HTML, we've got
a bunch of input types.
23:14 - We've got text boxes, turns out there's
text areas which are even bigger,
23:17 - check boxes, radio buttons, what's most
apt perhaps for choosing your dorm?
23:23 - AUDIENCE: Dropdown list.
23:24 - DAVID MALAN: Like a dropdown
list, otherwise called a menu.
23:28 - But which tag?
23:31 - AUDIENCE: Container?
23:32 - DAVID MALAN: Not a container, a
little more precise than that.
23:34 - With what tag can you
generate a dropdown list
23:37 - if you've done this before in HTML?
23:39 - AUDIENCE: Select.
23:40 - DAVID MALAN: Select.
23:41 - So it's not perfectly clearly named,
but it's, indeed, a select menu by name.
23:45 - And so I can actually do this.
23:47 - Select, and the name of this
field will be dorm, for instance.
23:50 - And then inside of this I'm going
to go ahead and have a few options.
23:53 - So one option might be
let's say Apley Court, which
23:58 - is one of the buildings
in which freshmen live.
24:01 - There might be another
one called Canoday,
24:03 - and then there's going
to be bunches of others.
24:05 - And then notice, too, if you've never
used a select menu, which you wouldn't
24:08 - have really had occasion to
yet unless you've done this
24:10 - before, these options also have to
have values, which for my purposes
24:14 - are going to be exactly the same.
24:16 - But whereas what's between the
tags is what the human sees,
24:20 - it's what's between these
quotes as the value of value
24:24 - that the computer actually sees.
24:26 - So these are the words that
populate the dropdown menu,
24:29 - these are the values that actually
gets stuffed into the virtual envelope
24:32 - that the student him or
herself actually see.
24:35 - So let me go ahead and save this.
24:37 - Let me go ahead and
now open up my console.
24:41 - And I'm going to borrow
a little code just so
24:43 - that we can do this from scratch here.
24:45 - So let me go ahead and grab from
froshim0 my application.py file
24:51 - and go into my workspace.
24:55 - So let me go ahead now
and run Flask run wherein
24:59 - I have this application.py file.
25:01 - I'm going to see the URL
at which my code now lives.
25:04 - And if I open this up, I'm going
to see an internal server error.
25:07 - So intended at some point because
internal server error, recall,
25:11 - was one of the more arcane status
codes, 500, that you probably
25:14 - have not seen unless you're visiting
a website where something has actually
25:17 - going wrong.
25:18 - So how do I begin to figure
out what has gone wrong now
25:21 - that I'm actually writing code and
not just writing hard coded HTML?
25:24 - Well, all of the clues
are going to be found
25:27 - here inside of the console window.
25:30 - So when you're running Flask you are
running a full fledged web server.
25:33 - You are listening via TCP/IP for
incoming requests from users.
25:39 - And so what you'll see in the console
is not just the diagnostic output
25:42 - when you first start Flask, but you're
going to see all of the error messages
25:46 - that might actually happen thereafter.
25:48 - And this is a little cryptic looking.
25:50 - Frankly, it's overwhelming to
see this text at first glance.
25:53 - But whereas in Clang
and in C it generally
25:56 - helps to look at the very top,
sometimes the error messages
25:59 - here in this context of Flask
are kind of toward the bottom.
26:02 - And here we have template not found.
26:04 - Template because it
can't find index.html.
26:06 - And that's just because I screwed up.
26:08 - So let me actually exit
Flask by typing control-c.
26:11 - And if I type ls in my directory,
notice that I haven't quite
26:14 - practiced what I've preached.
26:16 - It's perhaps a little subtle,
but I haven't organized myself
26:19 - in the right way.
26:19 - What have I done wrong?
26:23 - Yeah?
26:24 - AUDIENCE: Didn't make
a templates directory.
26:25 - DAVID MALAN: Yeah, it's
kind of a silly mistake.
26:26 - I didn't make a templates directory.
26:28 - So you can do this in
a few different ways.
26:30 - By the folder icon up here,
you can create a new folder
26:32 - by right clicking or control clicking.
26:34 - Or in Linux you can do make
dir for make directory.
26:37 - And so I can do make
dir templates enter.
26:40 - And then I can move my
index.html file, which
26:43 - I wrote a moment ago, into my templates
directory by just using mv for move.
26:47 - And now I can go ahead and run
Flask run, cross my fingers,
26:52 - go back to the browser
tab and click reload,
26:54 - and voila, now I actually see the form.
26:57 - So have these kinds of instincts.
26:58 - I didn't actually intend that,
but I forgot to create the folder.
27:01 - I got this server error.
27:02 - You don't have to just
stare at the browser, which
27:03 - is not going to have much information.
27:05 - But if you look at the
console, the terminal window
27:07 - that you have control over will you
see those clang-like error messages.
27:11 - So here we have a basic HTML form.
27:13 - It's not complete because
I didn't bother typing out
27:15 - all of the dorm names, but I
do have an input of type text
27:18 - as well as the Select menu.
27:19 - And I'm also kind of missing
a key detail, it seems.
27:22 - What should I probably add to this form?
27:24 - AUDIENCE: Where you're selecting.
27:25 - DAVID MALAN: Well, I'm selecting--
27:26 - I could be selecting dorm, so I
could clean this up in a couple ways.
27:29 - I also am missing a Submit button.
27:31 - Now, it turns out you
could probably hit Enter
27:33 - and it would actually be submitted
by default. But we can fix this.
27:36 - So let me go into index.html.
27:38 - Let me shrink this tab just a little
bit and let me fix both of these things.
27:42 - So let me go ahead and open
up this latest version, which
27:46 - is now in that templates directory.
27:50 - Let me go ahead and at the bottom
here do an input type equals submit,
27:55 - the value of which is going
to be a register, just to make
27:57 - clear to the human what's going on.
27:59 - Let me go ahead and go back
to my form, click reload.
28:04 - And nothing's happened just yet.
28:05 - And that's because by default when you
make changes to some of your files,
28:10 - Flask is not going to notice.
28:11 - And we'll fix this actually
in the coming problem
28:13 - set by adding more
code and a little more
28:15 - complexity to automate this for you.
28:17 - But when in doubt, just
control-c to quit flask.
28:20 - Then go ahead and rerun
flask, that will reload all
28:23 - of your HTML, all of your Python code.
28:25 - And if I now go back here and click
reload, we'll see the Register button.
28:28 - So there should never be any surprises.
28:31 - And if there are, just try to
get to the diagnosis thereof.
28:35 - This is also a little unclear,
too, to what this menu is.
28:38 - So it turns out that if you actually
create a bogus option like this
28:42 - that has no value and say something
like dorm, you can save this.
28:47 - Let's go ahead and restart
Flask and reload the page here.
28:50 - You'll see that now you see dorm.
28:52 - Unfortunately, this is kind
of stupid because now dorm
28:56 - is where you can
literally live apparently,
28:58 - which doesn't quite feel right.
28:59 - So there's HTML fixes for this too.
29:01 - I can actually go in here
and technically say disabled,
29:05 - so you can't actually select that.
29:06 - Now if I rerun Flask and reload,
now it still shows it there.
29:12 - But because I already selected
Apley Court, you can see it in gray.
29:15 - And we can actually be
a little more specific,
29:16 - if you want to not only disable it, but
select it by default and then go ahead
29:21 - and reload the page here,
now you'll see hopefully
29:24 - what's familiar on most websites.
29:25 - It says dorm, but it's disabled.
29:27 - And even though the
silly checkmark is there,
29:29 - you're forced to choose an actual dorm.
29:31 - So these are minor aesthetics,
but the kind of things
29:33 - you now have control over.
29:35 - So what's going to happen?
29:36 - I haven't actually specified
where this form should
29:39 - go when I actually register because I'm
missing some key details on the form
29:42 - tag.
29:43 - And we haven't done this
in a couple of weeks.
29:45 - But when we were playfully
reimplementing Google,
29:48 - what else did we add to the form tag?
29:52 - What attributes?
29:56 - Anyone remember?
29:58 - Yeah.
29:59 - Oh, say again?
30:01 - Action, which means what?
30:04 - AUDIENCE: What to do.
30:05 - DAVID MALAN: What to do.
30:06 - All right, so the
action we want to take,
30:08 - even though this is not
necessarily perfectly well named,
30:11 - is where do you want
to submit the form to?
30:13 - And I could actually submit
this in a few different ways.
30:16 - I'm going to go ahead
and say, you know what,
30:18 - submit it to a reasonably
named route slash register.
30:21 - Google, for instance, might
have code that instead says
30:23 - to submit their form to slash search.
30:25 - But we're not searching for
something, we're registering.
30:27 - So the name of the route
is entirely up to us.
30:29 - And via what method should
we submit this information?
30:32 - What are our two options?
30:33 - AUDIENCE: Get or post.
30:34 - DAVID MALAN: Get or post.
30:35 - Get tends to be the default
if you don't mention in links.
30:38 - Why might you want to use post instead?
30:41 - AUDIENCE: You want it to go to a
database in order to do something.
30:44 - DAVID MALAN: Yeah, you want it to
go to a database and do something.
30:46 - And the right verb to use
there is to post information
30:49 - as opposed to getting information.
30:51 - And even more specifically when it
comes to privacy, when you use post,
30:54 - the information doesn't
end up in the user's URL,
30:56 - and therefore doesn't end
up in his or her history,
30:58 - and therefore doesn't end up in a place
that siblings, or roommates, or anyone
31:02 - else can actually see
just by poking around.
31:04 - So we'll, indeed, go ahead, because
this is my name, and dorm, and maybe
31:07 - my phone number, and email,
and credit card number,
31:09 - and the like on some other website.
31:10 - I'm going to use post for that instead.
31:13 - So the catch here is
that this week, we now
31:16 - have the ability to
implement slash register.
31:18 - Two weeks ago we could just send
people to Google's slash search,
31:22 - but now we have the ability
to make our own routes.
31:25 - But how many routes have we
defined thus far in application.py?
31:29 - Just the one.
31:30 - And again, some new syntax with
the funky at sign and the route
31:34 - keyword here.
31:35 - But let me actually
just intuitively guess
31:38 - that if I go ahead and say
app.route slash register,
31:43 - I bet I could implement a second
route and tell the web server
31:46 - to listen in two places, on slash
as well as on slash register.
31:50 - But if I wanted to listen specifically
on post, it actually has to be this.
31:55 - Methods equals quote-unquote post.
31:58 - Because by default just for
convenience, it assumes only gets.
32:02 - So I need to add that.
32:03 - You'd only know that
from the documentation.
32:05 - Now I'm going to go ahead
and define a function.
32:07 - This is slightly an
annoying feature of Flask.
32:09 - You have to give the function a
name even though you'll probably
32:11 - never reference it anywhere.
32:13 - So I'm going to go ahead and just
reasonably call this register.
32:15 - And now I have a to do.
32:18 - What am I going to want to do when
the user clicks that Submit button?
32:23 - AUDIENCE: Store it.
32:23 - DAVID MALAN: I want
to store it somewhere.
32:25 - So I probably want to store it.
32:27 - But what might I want to do first
before he or she is actually
32:30 - allowed to register, even though
they've clicked that submit form?
32:34 - Maybe confirm their information, right?
32:36 - Because if a lazy user comes in, or if
a user accidentally clicks the button
32:39 - or hits enter, they might actually
submit nothing-- no name, no dorm.
32:42 - That's not useful information.
32:44 - It could just be perceived as spam.
32:45 - So we probably want to ask
some kind of logical question
32:48 - like if they didn't give us a name
or they didn't give us a dorm,
32:51 - yell at the user in some way.
32:53 - So I'm going to go ahead and do that.
32:54 - So let me actually
express this in Python,
32:56 - kind of like we did last week
with some error checking.
32:58 - So recall that the user's name can
be gotten from an HTTP parameter.
33:03 - From the request.args get, and
then ask for the name parameter.
33:09 - Their dorm, meanwhile, can come
from request.args get dorm.
33:13 - And again, this
request.args is something
33:16 - we gave ourselves access to up
here when we said, hey Flask,
33:19 - please give me access to the user's
request, that virtual envelope.
33:22 - Request.arg refers to all of
the HTTP parameters in the URL.
33:26 - And get is just a function or a
method built into that special Flask
33:30 - feature that allows us to get
a specific parameter like name,
33:33 - or dorm, or anything else.
33:35 - And recall that in Python, what's kind
of nice is that you can say pretty
33:38 - English-like, if not name or not--
33:42 - not dorm, let's go ahead
and reprimand the user.
33:46 - For instance, we could say failure
because he or she did not actually
33:50 - cooperate as we intended.
33:51 - Otherwise if they did
cooperate, I'm going
33:54 - to go ahead and render template success.
33:58 - And we'll flesh this
out in just a moment.
34:00 - So I've got two scenarios handled.
34:01 - If they didn't cooperate or if they
did, render quote-unquote failure
34:05 - or a full fledged HTML template.
34:07 - So now that I've implemented slash
register and I'm listening for a route
34:12 - by a post, let's go ahead and
reload the page for good measure.
34:15 - Type in my name.
34:16 - Not going to tell you my dorm, but
you're going to notice as much.
34:20 - OK, so now the server has noticed that
I didn't actually cooperate and provide
34:24 - both a name and a dorm.
34:25 - And so it's returning to me
just quote-unquote failure.
34:27 - So that's good because now I know, all
right, I did something wrong clearly.
34:31 - Let me go back let me go ahead
and maybe do Canaday here.
34:34 - And now let me go ahead and register.
34:36 - But, but, but, but, this I know
in advance is going to err.
34:39 - Why?
34:40 - I don't have a success.html.
34:42 - OK, so let's preemptively address this.
34:44 - Let me actually go in here
to my templates directory.
34:47 - I'm going to go ahead and create
a new file called success.html.
34:52 - Let me go into the
templates to save it there.
34:54 - And you know what, success
can be a pretty simple page.
34:56 - And let me open my index page, let
me copy that, let me go into success,
35:00 - let me paste this.
35:01 - Let me get rid of all of that body
and just say success, for instance.
35:06 - So let me now go ahead
and go restart Flask,
35:10 - because I've made a new template.
35:12 - Let me go ahead and reload the
form just for good measure.
35:14 - Let me go ahead and give you my name
this time, and OK, I live in Canaday,
35:17 - and register.
35:19 - And what did I do wrong this time?
35:22 - So it turns out you can't
do it this way, obviously.
35:25 - [LAUGHTER] So when you're
actually submitting information to
35:31 - via a form via get,
Flask very cleverly puts
35:35 - that information in a different place.
35:37 - Because by definition, as I
claim very correctly earlier,
35:40 - in request.args are all
of the key value pairs
35:42 - that are in the URL that are
coming in from the user's request.
35:46 - But when you submit via post, for
reasons I wish were now otherwise
35:50 - you actually have to access those
values via a different variable.
35:54 - So instead of using request.args, you
have to use request.form both here
35:58 - and here to make clear-- and this is
horribly named for exactly the reasons
36:02 - that I think I'm tripping over here--
36:04 - because they actually are both coming
in via a form, via a get or post.
36:09 - But Flask puts get arguments in args
and puts post arguments in form.
36:15 - Thereby leading clearly
to potential confusion.
36:18 - But if I go ahead now and load this
version of the site and I keep hoping,
36:24 - I'm going to go ahead now run Flask,
restart this page, type in David,
36:31 - give you my dorm, and register and
successfully register for froshim.
36:36 - See how easy web programming is?
36:39 - So hopefully now we can at least focus
on the structure of what I've done
36:44 - and now begin to improve it.
36:45 - Because notice that I kind of did not
practice what I preached a moment ago.
36:49 - What habit did I violate when
I whipped up success.html?
36:56 - How did I get to that point?
36:57 - Yeah?
36:57 - AUDIENCE: Copy and paste.
36:57 - DAVID MALAN: Yeah, I copied and paste.
36:59 - Which again, usually in programming
not the right thing to do.
37:02 - Might get the job done super fast,
but it's probably the wrong instinct,
37:05 - because it's going to get
harder and harder to maintain.
37:07 - Now, why is that?
37:08 - You've played HTML a
couple of weeks ago.
37:10 - And recall from that problem set
when you had to make a home page,
37:13 - you probably found yourselves
copying and pasting across your two,
37:17 - or three, or four pages because you
wanted them to kind of look the same.
37:20 - And therefore it made sense for
them to have some commonalities.
37:23 - But in HTML alone, there was no way to
say use the same layout for my whole
37:28 - site-- use the same color scheme,
the same fonts, the same CSS--
37:32 - but just change the body of the
page for each individual page.
37:35 - And so some of you very rightly
on discourse and beyond like
37:38 - posted questions asking,
could you do this?
37:39 - And you can't really in HTML alone.
37:43 - But now that we have access to
Python, an actual programming language
37:46 - they can do things logically,
now you can actually
37:48 - start to factor those things out, too.
37:50 - And notice in this file, success.html,
as well as in index.html,
37:57 - what are some of the
commonalities, suffice it to say?
38:00 - The form is only in
one of them, but what
38:02 - else is obviously redundant everywhere?
38:06 - The title, the head of the page more
generally, the doctype at the very top,
38:10 - the body tag alone.
38:11 - And you could imagine there'd be even
more details like from your own home
38:14 - pages that you wanted to be
the same across multiple pages.
38:18 - So let's actually take a look at
a refactorization of this code,
38:22 - the one I did write in
advance in froshim0,
38:25 - and you'll see why it
actually makes sense
38:28 - to have not only multiple
files, each of which
38:30 - represents one of your
routes or your views,
38:34 - but also to have this
file called layout.html.
38:37 - In Flask, when building a
web application that you know
38:40 - is going to follow a certain
structural pattern, commonalities
38:43 - across all of your pages,
you can actually do this.
38:46 - So in this file here, layout.html
is a whole bunch of hardcoded HTML.
38:52 - And it's pretty simple.
38:53 - It's got my HTML tag, head tag, title
tag, body tag, and a few other things,
38:57 - but that's the general
structure of the page.
38:59 - And notice it has this
funky syntax in the middle.
39:02 - In white here is what's
called the block.
39:04 - This is now Flask specific.
39:07 - Just like Flask supports those
two curly braces on the left
39:09 - and the right that says
put a value here, flask
39:12 - also supports this other notation,
curly brace percent and percent curly
39:17 - brace that actually allows you to put
placeholders for actual chunks of HTML.
39:22 - Not just variables, but
actual chunks of HTML.
39:26 - And so this layout you can
think of as a mold or a template
39:29 - literally that all of your other pages
are going to be structured based on,
39:33 - but they are going to vary in
this line and only this line.
39:37 - And we're going to put as much HTML
between the body tags as we want,
39:40 - the open and the close tag.
39:42 - This just indicates to Flask this is
the stuff that should be changing.
39:45 - So if I now look at my
index.html, which recall earlier
39:50 - contained my form index.html.
39:53 - Notice that here's the form,
and I finished it earlier.
39:55 - I went ahead and typed out
all of the freshman dorms,
39:57 - not just the two of them.
39:59 - And you'll see that the
file starts almost the same
40:01 - and then continues with more stuff.
40:03 - But notice what's missing
from index.html this time.
40:07 - No doctype.
40:08 - No HTML tag.
40:09 - No head tag, no title tag, no body tag.
40:12 - All of the common stuff
has been factored out.
40:14 - But there's some funky new syntax
that, again, is Flask specific.
40:18 - This first line is the link
between this file and the layout.
40:22 - That first line says, hey
Flask, this index.html file
40:25 - extends the definition of layout.html.
40:29 - So it says grab that template
and plug myself in there.
40:31 - What do you want to plug in?
40:32 - The same syntax here.
40:34 - When you actually put
stuff between the block tag
40:37 - and the end block tag, which is down
below, that's when you say to Flask,
40:42 - go ahead and take this stuff and plug
it into the placeholder in the layout.
40:46 - So meanwhile, the success page also
now can be a little more sophisticated.
40:51 - If I go into success,
it's not very complicated.
40:54 - And honestly, it doesn't
even look like HTML
40:55 - anymore because we're using
these more dynamic features.
40:58 - But this just says, hey
Flask, use the same layout
41:01 - so the page is structured
exactly the same.
41:03 - But for the body, go ahead and
plug in this value instead.
41:07 - So indeed, when you go ahead
and load this success message,
41:10 - you see this message
here-- not just success,
41:12 - I expounded here and
said you are registered.
41:14 - Well, not really, that's
because there's no database yet.
41:16 - But that's going to generate
a full fledged HTML page.
41:19 - And what about failure?
41:20 - Before I was just cheating and
just saying return failure,
41:22 - quote-unquote, no HTML at all.
41:24 - The failure page is going
to be almost the same,
41:27 - but now I can actually
provide some descriptive text.
41:30 - This body just says you must
provide your name and dorm,
41:33 - thereby admonishing the user for
not having cooperated properly.
41:37 - So now your home pages, if you
kind of extrapolate from this,
41:40 - could have the exact same
layout, aesthetics and menu bars,
41:43 - and all of that fanciness, but only
the content would have to change.
41:46 - And you can get out of the business
of just copying and pasting.
41:49 - So there, too, to your question
earlier about dynamism,
41:51 - the dynamism doesn't have
to just come from the user.
41:54 - It can also come from the
construction dynamically of a website
41:58 - based on multiple pages.
41:59 - So at the end of the
day, the browser has
42:00 - no idea that Python exists,
has no familiarity with Flask.
42:05 - All the browser still
sees is an HTML page.
42:08 - But what Flask and in
turn Python are doing
42:10 - for us is constructing that
page dynamically, following
42:13 - the rules from two weeks
to go in HTML and CSS,
42:15 - and following last week's
rules on how Python works.
42:19 - Questions?
42:22 - AUDIENCE: So even though [INAUDIBLE]
42:33 - DAVID MALAN: It's not.
42:35 - Good question.
42:36 - This new syntax, the double curly
braces that we saw earlier and now
42:39 - the curly brace percent signs, this
is actually yet another language
42:43 - called jinja--
42:44 - J-I-N-J-A-- which is
a templating language.
42:48 - And there's dozens of these things
in the world, people just come up
42:51 - with their own syntax.
42:52 - And the reason for the funky
syntax is that the author of jinja
42:56 - presumably could think
of no other language that
42:58 - uses like a curly brace
and a percent sign
43:01 - and a percent sign and a curly brace.
43:03 - And so therefore they
decided, you know what,
43:05 - I'm going to use this syntax because
it will look distinct from HTML,
43:08 - and CSS, and Python So
that frameworks like Flask
43:11 - don't confuse it with something else.
43:14 - AUDIENCE: So do you have to upload that
into [INAUDIBLE],, or is it automatic?
43:18 - DAVID MALAN: It's
automatically supported.
43:20 - So Flask by default supports jinja.
43:23 - It could have come up with
its own templating syntax.
43:25 - But whoever invented Flask decided
I don't need to reinvent this wheel,
43:29 - someone else already made
a templating language
43:31 - that gives me this functionality.
43:32 - So I'm going to combine
our works into one.
43:34 - And I didn't call it a
language a moment ago,
43:36 - because frankly, HTML,
CSS, Python, JavaScript--
43:39 - I mean, we're already
running out of fingers here.
43:41 - But jinja is, indeed,
yet another language.
43:43 - It's just not a programming
language per se,
43:46 - though it will have some
control flow features
43:48 - that we'll see in a little bit.
43:49 - It's just much more limited than Python.
43:51 - Other questions?
43:52 - AUDIENCE: Is it possible to combine
the success and failure HTML
43:54 - files into one just for better design?
43:57 - DAVID MALAN: Good question.
43:58 - Could you combine the success
and the failure pages into one?
44:03 - Short answer, yes.
44:04 - And let me not show it yet, because
it'll get a little more complicated.
44:07 - But yes, I could imagine passing
a variable in that's a Boolean--
44:11 - true or false--
44:12 - into just one of these templates.
44:13 - And maybe I call the new
template result.html.
44:17 - I can actually then have an if
condition in my template that
44:20 - says if the result is true, say this.
44:23 - Else if the result is
false, say this other thing.
44:25 - So you could do that, yes.
44:27 - Generally, though, it's probably
cleaner to keep messaging separate
44:31 - if they functionally do something else.
44:32 - After all, these files
are pretty small anyway.
44:35 - Yeah?
44:36 - AUDIENCE: Just for
question, what does the user
44:38 - see if they were to open up
the debugging console on Chrome
44:42 - and look at at it, what do they
see as the HTML that shows up?
44:46 - DAVID MALAN: Really good question.
44:47 - What does the user see?
44:48 - We can answer this by just
literally opening Chrome and opening
44:51 - View Page Source or the Inspector.
44:53 - This is what the browser sees.
44:55 - So when I claimed earlier that the
browser has no idea of Python or Flask
44:58 - are even involved,
that is, indeed, true.
45:00 - Because what browser's
receiving at the end of the day
45:02 - is just this, the
dynamically constructed HTML.
45:06 - Good question.
45:06 - Yeah?
45:07 - AUDIENCE: [INAUDIBLE] can you
also put Python code in there,
45:11 - or is it just HTML?
45:11 - Good question.
45:12 - We'll see more of this
in just a little bit.
45:14 - The question is, can you between
the curly brace and percent signs
45:17 - put actual Python code?
45:19 - You can put stuff that looks like
Python code, but not all of Python.
45:23 - And so more of that in a bit.
45:24 - AUDIENCE: Is there a function
call or something like that?
45:26 - DAVID MALAN: Only certain functions.
45:27 - Templating languages, long
story short, are sandbox so
45:30 - that they are not as expressive
as a real programming language.
45:33 - Otherwise you are vulnerable
to potential hacks.
45:36 - You want their functionality to
be very limited because they're
45:38 - only about displaying data, not about
thinking or doing logic generally.
45:42 - More on that in a bit.
45:43 - All right, that was a lot all at once.
45:45 - Let's take a five minute break
here, turn on some music, come back,
45:48 - and we'll make this act better.
45:49 - All right, we are back.
45:51 - So to recap where
froshim0 left off, we now
45:54 - have this structure which
is pretty much conventional.
45:58 - Any web application
we make here on out is
46:00 - going to follow this pattern of having
an application.py entry point where
46:04 - all the interesting stuff
starts, a layout.html file
46:08 - in your templates
directory that lays out
46:09 - the whole site and any commonalities,
and then one or more other pages that
46:13 - actually represent your individual
views that correspond to one or more
46:17 - of your actual routes.
46:18 - So now we're at the point
of a stable baseline,
46:21 - but had we dived in right to this, it
would perhaps not make as much sense
46:25 - as to why we did this
various factorization.
46:27 - So let's now improve this.
46:29 - Because of course, if
you look at success.html,
46:31 - it just claims you are registered.
46:33 - Well, not really.
46:34 - Because in application.py, did we do
anything with the user's information?
46:40 - No.
46:41 - We just checked, did
they give us information?
46:43 - And if so, we claim success.
46:44 - Else if they missed their name and/or
their dorm, we just claimed failure.
46:48 - So what might a data
structure be in Python
46:51 - where we could store registrants?
46:53 - We don't have databases
yet, we don't have SQL yet.
46:55 - That's a week ahead.
46:56 - AUDIENCE: Array.
46:57 - DAVID MALAN: Yeah, we could
use an array, otherwise known
46:59 - as a list in Python.
47:00 - So let me propose how we might do this.
47:02 - Let me actually open up froshims1 for
our second iteration of this program.
47:08 - And in application.py, notice this.
47:10 - At the very top of the
file, not only am I
47:12 - creating my application using
the same line as before,
47:16 - and I've commented things this time
in advance using the hash symbol,
47:19 - notice that I claim that
on line 6 and 7 here, here
47:22 - is an empty list for all of the
students who have registered.
47:25 - This way we can keep
the information around.
47:27 - And we only did this briefly
last time, but does anyone
47:29 - remember how you add
something to a list in Python?
47:33 - By what function?
47:35 - Append.
47:36 - So if you have .append at
the end of a list's name,
47:38 - you can add something to it.
47:39 - So where is that going to go?
47:41 - Well, here is my route for slash,
implies, again, get by default.
47:44 - That's the default route
that a human might get,
47:46 - and they are going to see
index.html, which contains that form.
47:50 - If I scroll down now, you'll see that I
have a register route just like before.
47:55 - But I'm doing one additional step.
47:58 - Which is the new line here, to be clear?
48:01 - Yeah, 26.
48:03 - So I could implement this
in any number of ways.
48:05 - But the key detail is that I
reference the list name-- students,
48:08 - but I could have called it anything.
48:09 - .append, as someone proposed, is how you
add something to the end of the list.
48:12 - And then I can add anything I want.
48:14 - To keep it simple, I'm
just going to add a string.
48:16 - And I'm going to keep
it super simple and just
48:18 - say the string is so-and-so
from such and such a dorm.
48:21 - So David from Matthews Hall,
or Brian from wherever.
48:25 - And so here we have placeholders
using f strings in Python.
48:28 - So this has nothing
to do with Flask, this
48:30 - has nothing to do with jinja or
anything we just talked about.
48:33 - This has to do everything with
last week's syntax in Python alone.
48:37 - So this appends to that list
this name from this dorm.
48:42 - So let's go ahead now
and try this version out.
48:44 - If I go into my source sub and directory
for today's code into froshims1
48:50 - and run flask run, we'll see
a URL that I can now visit.
48:54 - Let me go ahead and
open that for froshims1.
48:56 - Notice that I have that
complete dropdown now.
48:59 - Let me go ahead and say David, but
I'm not going to tell you my dorm
49:02 - yet and try to register.
49:04 - Now I see a more friendly
message, not just failure.
49:07 - And that's because of my
new and improved template.
49:10 - OK, I'll go ahead and be David,
and I'll be from Matthews here.
49:12 - Let me go ahead and register and voila.
49:14 - Now we see David from
Matthews has registered.
49:17 - And it seems to be all of a sudden
in the form of a new bulleted list.
49:20 - But where did that actually come from?
49:22 - Well, I don't know.
49:22 - Let me try this again.
49:23 - Let me go back to slash, which is
the route that gives me the form.
49:26 - Let me go ahead and type in not
David this time, but say, Brian.
49:29 - And Brian, which dorm are you in?
49:31 - AUDIENCE: Pennypacker.
49:32 - DAVID MALAN: Pennypacker.
49:33 - So let me choose this from the
menu instead and click Register.
49:36 - And now we see Brian from Pennypacker.
49:37 - So somehow the application
is changing state,
49:39 - and notice the URL that we're
at is called slash registrants.
49:43 - So that seems to be a third route this
time that apparently is not interactive
49:47 - per se, it just spits out the
list of registered students.
49:50 - So let's just put the
proverbial engineering hat on.
49:53 - If we go about implementing
this slash registrants route,
49:56 - logically what must that code be doing
in verbal pseudocode, if you will?
50:03 - AUDIENCE: A for loop?
50:05 - DAVID MALAN: Like a for
loop, iterating over what?
50:07 - AUDIENCE: In the list that
saves all the registrants.
50:10 - DAVID MALAN: Yeah.
50:11 - Iterating over the
list of students which
50:13 - contains all of those registrants.
50:14 - And the template, meanwhile, probably
has like an LI tag for list item
50:18 - and a UL tag for unordered list,
which gives me the bulleted list.
50:22 - So let's take a look at that.
50:23 - So how do we follow these breadcrumbs?
50:25 - Well, if I scroll up in
application.py, we'll
50:29 - see a route called slash registrants.
50:31 - And you'll see that
all it does apparently
50:33 - is it returns a template
called registered.html,
50:36 - where registered.html is probably a
template that is generating that list.
50:40 - But there's something
different this time.
50:42 - I'm passing in an argument.
50:44 - And we saw this earlier.
50:45 - When I wanted to pass in name
equals David or name equals Brian,
50:48 - I just grabbed that from a variable.
50:51 - This time I'm not doing request.args,
I'm not doing request.form.
50:54 - Because what is students?
50:58 - Where did this come from?
51:00 - That's the list from higher up.
51:02 - Recall that we have this global variable
at the top of the program, students,
51:06 - which is initialized to an empty list.
51:08 - But recall that we keep appending
to it in my register route.
51:11 - So I can go ahead and
say, you know what?
51:13 - Go ahead and pass into register.html
a template-- or rather, a list--
51:18 - called students whose
value is exactly that.
51:21 - And again, it's stupid looking that
you have the same word on the left
51:24 - and the right of the variable name.
51:26 - You could do this differently.
51:27 - Again, you could say foo, you
could say x, or y, or anything.
51:30 - But frankly, it tends to
make most sense, just pass
51:32 - in the same name as the variable that
you care about so that the template can
51:36 - see exactly that.
51:37 - So what's the next breadcrumb?
51:38 - If I want to understand
exactly what is happening,
51:40 - what file should I open up next perhaps?
51:43 - Probably register.html.
51:44 - So let's go in there.
51:46 - It's in my templates
directory by definition,
51:48 - and you'll see, indeed, a failure
message which allows me to error check.
51:51 - Index, which contains the form; layout,
which contains the overall structure;
51:55 - and finally, registered.html.
51:58 - And now we can answer the question that
you asked earlier about Python code
52:01 - in the template.
52:03 - So this one looks more
advanced than before,
52:05 - but notice it follows a pattern.
52:07 - Register.html extends that same layout.
52:10 - So it borrows from that same
mold, so it looks the same.
52:13 - The body of this page, though,
is just this snippet of HTML.
52:16 - Give me an unordered list,
open and closed, and this
52:19 - is what you can do now with jinja.
52:21 - Again, it's almost
identical to Python, so you
52:23 - don't have to worry about thinking
about learning yet another language.
52:26 - It's just a subset of
Python essentially.
52:28 - So if I want to output in the
list of all of the students,
52:33 - I use my jinja syntax here, my template
syntax with curly brace percent.
52:37 - And I say for student and students.
52:38 - Just like in Python, that induces
an iteration over that list.
52:42 - And then what do I want to output?
52:43 - Well, we can borrow our curly
braces from our name example
52:46 - and just do list item, plug in the
name of the student, close list item.
52:51 - And then endfor.
52:53 - So this is the one stupid
thing with the templates.
52:55 - Whereas in Python proper,
recall that you can just
52:58 - say for student in
students, you have a colon
53:00 - and then indentation handles everything.
53:02 - The problem with that
in the world of HTML
53:04 - is that browsers recall
ignore all whitespace,
53:07 - like whitespace has no special
significance, but in Python it does.
53:10 - So the way people solve
this is you literally,
53:14 - if a little weirdly, say endfor--
53:16 - one word, no space.
53:17 - And that's it.
53:18 - And indentation helps you
read something like this.
53:20 - So what is the HTML I'm getting back?
53:22 - I can actually look at this.
53:23 - Let me go ahead and view
page source in Chrome,
53:26 - and you'll see it's not quite
as pretty as might be ideal
53:28 - because there's a lot of whitespace
which comes from those templates
53:31 - from my having pretty
printed those, as well.
53:33 - But this is syntactically correct,
and I'm dynamically putting
53:36 - this part inside of this layout.
53:40 - Any questions, then, on this?
53:42 - AUDIENCE: So if we restart
the server, whatever's stored
53:47 - in the list, that goes away, right?
53:49 - DAVID MALAN: Good question.
53:50 - Let's kill Flask with control-c.
53:51 - Let's rerun the server.
53:53 - And let me go back to my
registrants route and reload.
53:57 - And sadly, yes, this is not the best
way to register students for a sport.
54:01 - Because if the server ever goes
offline, loses power, you hit control-c,
54:04 - you obviously, indeed, lose everyone.
54:06 - And notice, too, even
though we've generally
54:08 - frowned upon using global variables,
which this students list indeed
54:12 - is, why did I define it
up here in line 7 and not,
54:17 - for instance, in my register route here?
54:20 - Because indeed, I'm
appending to the list here.
54:23 - But I very deliberately did
not declare the list there.
54:28 - Yeah?
54:29 - AUDIENCE: You're using
it in other parts.
54:31 - DAVID MALAN: I'm using it elsewhere in
my other routes, the registrants route.
54:34 - And also even more to the point,
if I declared a list here,
54:38 - it becomes by definition
a local variable.
54:40 - Which means as soon as
this function exits,
54:41 - now I've just thrown away those
students who register immediately not
54:45 - even after a control-c.
54:47 - So this was a better approach
to do it, but it's not
54:49 - what I did way back in my day.
54:51 - I actually did something
that was a little fancier.
54:54 - So at the time, I didn't
really know-- at least in,
54:56 - what, 1997-- anything about databases.
54:58 - I don't think I even knew about
CSV files just yet, or at least
55:01 - how to create them dynamically.
55:02 - So I instead took this approach.
55:05 - Let me go into froshims2, and it has
noticed the same templates as before.
55:11 - And indeed, I pretty much copied
and pasted for this second example.
55:14 - But in application.py,
notice this fanciness.
55:17 - So here I have almost the same
thing up top in terms of Flask,
55:22 - but I'm also using this OS
library, more on that in a bit.
55:25 - But what about line 2?
55:27 - It's subtle, but I rattled this acronym
off I think just once weeks ago, SMTP.
55:33 - Does anyone know what that stands for?
55:34 - AUDIENCE: Simple mail transfer protocol?
55:36 - DAVID MALAN: Yeah, simple mail
transfer protocol-- email, that is.
55:39 - So Python comes with
built in functionality
55:41 - via which you can send emails,
and this is exactly what I
55:43 - did when I first made this website.
55:45 - Didn't know anything about
databases, I didn't know anything
55:47 - about saving things to files
just yet, I was still learning.
55:50 - But I didn't realize, hm,
I could use programming
55:53 - to send an email to the proctor or
the RA who was overseeing the sports
55:56 - program so that they could
just save it in a folder
55:59 - and know who had registered.
56:00 - It's not super user
friendly, but it at least
56:03 - got the job done because they were
then able to track everything.
56:06 - So in this program, notice that
I have my route for my form.
56:11 - And I have this register route
but a few new lines of code.
56:14 - And you would only know how to do
this by reading the documentation.
56:17 - But in this case here, notice what
I'm doing in my register route.
56:20 - I'm first getting the user's name and
their email this time and their dorm.
56:25 - Then I'm error checking.
56:26 - If they didn't give me a name,
or their email, or the dorm,
56:29 - render failure.html to
apprise them as much.
56:32 - Then go ahead and do
these lines of code.
56:34 - And this is more of a mouthful,
and you would only, again,
56:36 - know this from the documentation.
56:38 - But it turns out if you
read the documentation
56:40 - for this SMTP lib or library, you can
use lines of code like this as follows.
56:46 - You can tell the library what
server to use for sending email.
56:49 - And it turns out if you
read Gmail's documentation,
56:52 - you can use smtp.gmail.com to
automatically send e-mails not using
56:56 - the web UI, but using code.
56:57 - 587 is the TCP port that they use.
57:00 - So it's not 80, it's not
443, it's 587 by convention.
57:04 - Starttls, if you read the
documentation, says turn on encryption.
57:07 - So the email is encrypted
between you and Gmail.
57:11 - Then go ahead and log in with a
certain username and password.
57:13 - I created an account in advance called
jharvard@cs50.net, and my password
57:17 - is in my IDE's environment.
57:19 - I stored it elsewhere so that
it's not visible on screen,
57:21 - otherwise people could
send emails as John.
57:24 - Then I go ahead and call literally
a function called send mail.
57:27 - And if you read the
documentation, this one
57:29 - takes as argument who you
want to send email to,
57:33 - the contents of the email
that you want to send,
57:36 - and the message that you
actually want to send here.
57:39 - Or rather, this is the from
address, the to address,
57:42 - and the actual message
that you want to send.
57:44 - After that, you just go ahead and
render template and assume success.
57:48 - I could add more error
checking, like I should probably
57:49 - check if anything went wrong
here, but I'm keeping it simple.
57:52 - But these new lines that are
highlighted actually send an email.
57:56 - So let's try this.
57:56 - Let me go into froshims2 and let
me go ahead and do Flask run.
58:02 - Let me go ahead and open
up the page here, slash.
58:06 - And notice I do, indeed, have
a second field for text now.
58:09 - So this will be David,
and this will be--
58:12 - let's see, how about let's go
ahead and just register not myself,
58:16 - since it's not my email account,
but John Harvard who we claim's
58:19 - email is cs50.net, jharvard thereat.
58:22 - And he lives in say, Weld.
58:25 - Let's go ahead and click Register.
58:29 - All right, it's taking a
little longer this time,
58:31 - but it was doing a little
more work sending an email.
58:33 - So now let's try to go to
gmail.com, open this up.
58:38 - Ooh.
58:39 - In my inbox, you are registered.
58:41 - If I open this up,
notice jharvard@cs50.net
58:45 - has sent me an email by a BC seed,
at least keep part of the information
58:48 - private.
58:48 - And it just says in the body of
the message if I move the cursor,
58:52 - you are registered.
58:54 - So I did a little more
back in 1997, but I
58:56 - included like the user's name, and
their email address, and their dorm,
58:59 - and maybe their phone number or whatnot,
and the sports they were interested in.
59:03 - But the idea is exactly that.
59:04 - You can send any information
you want just by now using code.
59:07 - You could not do that with
HTML or with CSS alone.
59:12 - Any questions, then, on this?
59:16 - Yeah?
59:16 - AUDIENCE: Last week when we wrote
code in Python we had to like
59:19 - say if name equals the
function to like execute that.
59:24 - How come in this we're not doing that?
59:26 - DAVID MALAN: That was all in JavaScript.
59:27 - So that allusion to if name equals,
and then you assign it to a function,
59:31 - I think you're referring to
our JavaScript examples, no?
59:35 - OK.
59:36 - So we'll actually come back
to that in a little bit
59:38 - where we reintroduce
a bit of JavaScript,
59:39 - which actually gives us some
more functionality reminiscent
59:42 - of those examples.
59:43 - Other question?
59:44 - AUDIENCE: What email address
did you send that email from,
59:47 - and don't you need to enter
like a password to make sure
59:50 - that no one just randomly sends email?
59:52 - DAVID MALAN: Yeah, it's
a really good question.
59:54 - So via what email address did I
send that, and to whom was it sent?
59:57 - So again, this is the from
address, this is the to address,
60:01 - and this is now the message.
60:02 - And just because I only have one email
account open, I had John send himself
60:06 - an email in this case.
60:07 - Theoretically if I were running the
freshmen intramural sports program,
60:11 - I could try to do this and change
this from address to be myself.
60:16 - The catch is that Gmail actually has
protections in place so that if you've
60:19 - logged in as jharvard
with his password, then
60:23 - the email, no matter what you
specify as the from address,
60:26 - is actually going to be overridden
to be from John Harvard.
60:29 - However, this does speak to the
potential insecurity of email.
60:32 - If you don't use Gmail
but you use a third party
60:34 - service that is not so rigorous
with its error checking,
60:36 - it is incredibly easy to fake
emails from one person to another.
60:40 - I mean, look through your
spam folder sometime.
60:42 - Most of those people who send
you those spams don't exist.
60:45 - Like, the email addresses
and/or the names are fake.
60:48 - And yet they might appear to actually
be from a sibling of yours, a family
60:52 - member, or a friend, even though
those humans did not send e-mails.
60:55 - And that's because some
spammer has written code
60:57 - like this in Python or
some other language,
60:59 - but has overridden these fields,
but used a server that's not Gmail
61:03 - that doesn't enforce these policies.
61:07 - Other questions?
61:09 - Fun fact, also in 1995,
I learned how to send--
61:12 - or how to change the
from address on an email.
61:15 - And turns out at Harvard there's
this entity called the ad
61:17 - board who doesn't like doing this.
61:19 - So don't do that.
61:22 - Sometimes there's human defenses in
place for this, not just technological.
61:25 - Thankfully, my friend whom I
faked an email from did not--
61:30 - it worked out OK.
61:31 - All right.
61:33 - You have now great power,
don't use it for evil.
61:36 - All right, so let's go ahead now and
do another example, but that takes this
61:40 - a further step, adding, finally
some persistence of information.
61:44 - Let's go ahead into froshims3
now and open up application.py.
61:48 - So recall that we can use CSV
files-- comma separated value files--
61:53 - to create the illusion
of like spreadsheets,
61:55 - but now we're actually going
to create them ourselves.
61:58 - The code for this is a
little more involved,
62:00 - and the only thing I've changed
now really is the register method.
62:03 - So in version one of this code, I saved
it in a global list just in memory.
62:07 - That was not good because it
gets thrown away too easily.
62:09 - Version two of this
we just sent an email
62:11 - to the proctor who runs the program.
62:12 - That was a little better, because at
least they can then save the email.
62:15 - Version three, we're going to use
a very lightweight database called
62:18 - the CSV file that saves it
to my hard drive permanently.
62:22 - So even when the server stops,
the data is still there.
62:25 - So in Python, how does this work?
62:27 - Well, notice that I've improved my
register route this time as follows.
62:30 - If the user did not give
me their name or dorm,
62:33 - then I go ahead and render a failure.
62:35 - That's pretty much the
same logic as before,
62:36 - but I didn't bother declaring
the variables this time,
62:39 - I just called the functions directly.
62:41 - Here's a new line of code that might be
reminiscent of some of your past file
62:44 - I/O code.
62:45 - In line 16 here, I'm telling Python
to go ahead and open a file called
62:50 - registered.csv quote-unquote a.
62:53 - So we've seen R, we've
seen W for read and write.
62:56 - Anyone recall what a is, or no?
62:59 - AUDIENCE: Append.
63:00 - DAVID MALAN: It happens to
mean append, which means just
63:02 - add a row to the file, which is nice.
63:04 - Because if there's already students
registered, when a new one registers
63:06 - we just want to append to
the bottom of the file.
63:08 - Quote-unquote a is supported by
Python with this open function.
63:12 - That gives me back a reference
or like a pointer to file,
63:15 - even though Python
does not have pointers.
63:17 - Then this is the new feature.
63:19 - And here, too, you'd only know
this from having seen an example
63:21 - or you reading the documentation.
63:22 - You can use the CSV library, which
we'll see as imported up above.
63:26 - And you can ask for a writer, a piece
of code that writes out-- that is,
63:31 - creates--
63:31 - CSV files.
63:33 - And specifically, you want
to write to this file.
63:35 - That library-- the CSV
library-- comes with a function
63:38 - called write row, which
does what it says.
63:40 - If you pass it in a comma
separated list of fields
63:43 - that you want to represent your
first column, your second column,
63:46 - and your third column, it will
handle the writing for you
63:49 - so you don't have to get
into the weeds of file I/O
63:51 - like you did several problem sets ago.
63:53 - Notice the subtlety.
63:54 - You do need to have these
second pair of parentheses,
63:58 - because technically what
you're giving it is a tuple.
64:00 - We talked very briefly
about that last week,
64:02 - which is just like an x comma y
pair, or latitude comma longitude.
64:06 - Same idea here.
64:07 - First column, second column, and
so forth is a so-called tuple.
64:11 - Then I close the file,
then I render the template.
64:13 - So what does this actually do for me?
64:15 - Well, let me go into my
folder froshims3 here.
64:19 - And notice register.csv
at the moment is empty.
64:22 - This is a CSV file.
64:23 - Nothing's going on inside of that.
64:25 - There's no one registered yet.
64:27 - But let me go ahead, then, and
go into froshims3, run Flask run.
64:32 - Let me go ahead and load this up.
64:33 - And you'll see the same kind
of form, but also a new link.
64:37 - Notice that no one's registered
yet if I click on that link.
64:40 - But if I go into here and register
David from Matthews and click Register,
64:46 - now it claims I am registered really.
64:48 - Let me click this link and notice
that it's very small on the screen,
64:52 - but slash registered is
where this is going to lead
64:54 - me, which is just where I was before.
64:56 - You see that now David
from Matthews registered.
64:58 - Let me go back to the form itself.
65:00 - Let's register, say,
Brian from Pennypacker.
65:02 - Click Register.
65:04 - He, too, is apparently registered.
65:05 - Let's click that link.
65:06 - Brian from Pennypacker.
65:07 - All right, so where is this data going?
65:09 - Let me go back to the IDE,
close my registered CSV file,
65:13 - because it's probably
changed and open it up.
65:16 - And voila, indeed, it's
prompting me to reload it.
65:19 - There is the file.
65:20 - And notice David comma Matthews, Brian
comma Pennypacker, all of those rows
65:25 - were written out for me.
65:26 - So now I actually have a database.
65:28 - And even though it's kind of a simple
database, you know what I can do?
65:31 - Let me go ahead and right click
or control click on it in the IDE,
65:34 - download it into my Downloads folder.
65:37 - And then if I actually
open this thing, if I
65:39 - have Excel installed
or Apple Numbers, which
65:42 - is the first time I've ever used it,
let me go ahead and open that file.
65:47 - Opening register.csv.
65:49 - And voila, here now is a file.
65:51 - And Numbers is formatting
it in kind of a funky way,
65:54 - but it is showing rows and columns.
65:56 - Those of you who are more familiar
with Excel we can do that, too.
65:58 - Let me go down here.
66:00 - Let me go into my Downloads folder.
66:03 - Control click or right click here, and
this time open it with Microsoft Excel.
66:07 - And if you've seen Excel before,
we'll probably see a very similar UI.
66:10 - Because anytime Excel or Numbers--
66:12 - OK, first time I've used Excel.
66:14 - So that, too, will open up
some rows and columns, as well.
66:18 - So CSV files are just very
lightweight spreadsheets.
66:20 - But what's cool about them is that
you can create them so easily.
66:24 - You just have to put commas in there.
66:25 - Now, as an aside, can you
contrive a user's input
66:29 - that could potentially break a CSV file?
66:32 - What could a human type in that could
potentially break your own CSV files?
66:37 - A comma, right?
66:38 - If it's like David Mayland comma
junior, or something like that.
66:42 - Or anything with weird punctuation.
66:45 - This is why you use libraries.
66:46 - That CSV library in
this code, which we're
66:49 - importing at the very top of
this version 3 of the code,
66:53 - is actually handling all
of that complexity for us.
66:55 - When the library encounters David
Mayland comma junior if that's
66:58 - the user's input, it
will then additionally
67:00 - put quotes around my whole
name, thereby making sure
67:03 - that my comma is inside
quotes and not, therefore,
67:06 - confused with the special comma that
demarcates the start of other columns.
67:10 - So again, that's why you
don't reinvent the wheel,
67:12 - because corner cases like that arise.
67:14 - Well, what about slash registered,
which is this list that's
67:17 - generating an unordered list?
67:18 - Let's see how that works.
67:20 - If I scroll down to this
code, notice that it's not
67:23 - just a simple matter of
grabbing a global variable,
67:25 - because there is no
global variable anymore.
67:28 - Now I have to read it
from that CSV file.
67:30 - So here's three new lines of
code that work as follows.
67:34 - I'm going to go ahead and open this
file, register.csv, in Read mode
67:38 - this time, not append.
67:40 - I'm going to go ahead now and say
hey Python, use the CSV reader--
67:44 - which is the opposite of writer--
67:45 - on that file.
67:47 - And then, hey Python, go ahead and
turn that whole reader into a list.
67:50 - So you'd only know this from
reading the documentation.
67:53 - It turns out this is the recommendation.
67:54 - If you want to take a reader and
just read the whole thing into memory
67:57 - at once and convert it to a Python
list, you literally just pass it
68:00 - to this list function.
68:01 - That gives me a list I'm
going to call students,
68:04 - and then I can do my
same code as before.
68:06 - For good measure, I
should probably do what
68:08 - I did last time, which is file.close
to close the file, as well, just
68:13 - to make sure it's closed
the next time it's opened.
68:15 - But I can actually simplify this,
and you'll see more of these examples
68:18 - online.
68:19 - It's actually more conventional
in Python not to do this,
68:23 - but instead to change
your code as follows.
68:25 - To not bother closing it explicitly,
to instead use a keyword called with
68:31 - to instead put the variable name back
there and indent everything underneath.
68:35 - Doesn't matter for our
purposes which one you do.
68:38 - The first one was correct.
68:39 - The second one is correct.
68:40 - This is just more conventional,
if only because it handles
68:43 - the closing of the file for you.
68:44 - So if you see this online, that's
all that's happening there.
68:47 - But it's just like in C doing fopen and
fclose, or in this case open and close
68:53 - like I had a moment ago.
68:54 - Any questions, then?
68:56 - AUDIENCE: How would
you handle duplicates?
68:58 - DAVID MALAN: How would I duplicates?
68:59 - good question.
69:00 - So haven't handled duplicates here
at all, and David from Matthews
69:03 - could register again and again.
69:05 - But logically what might I do?
69:07 - Well, it probably belongs
here in my register route.
69:10 - I probably want to do more error
checking than just these two lines.
69:14 - Because what I probably want to
do to see if David from Matthews
69:17 - is already registered
is open the CSV file,
69:20 - iterate over its lines looking for
David and for Matthews on the same line
69:26 - and then show a failure to
the user if he or she is
69:29 - trying to register for a second time.
69:31 - I've not made it easy with
this code, and frankly that's
69:33 - going to be so much
easier next week with SQL.
69:35 - SQL, this other language
for databases, will
69:37 - make it easy to search data
that has already been saved.
69:41 - CSV files do not make this easy.
69:43 - It's doable, but you have
to write more lines of code.
69:46 - So more on that to come.
69:47 - Other questions?
69:51 - All right, so let's skip
ahead to one final example,
69:55 - froshim6, which we'll do something
a little more for us here.
70:00 - So if I go ahead into
froshim6, notice that if I
70:04 - do Flask run, and go back to the
website here, and reload the screen,
70:08 - and I go ahead and give you my name, but
no, I'm not going to give you my dorm,
70:13 - we have this feature.
70:14 - It's ugly again, but where did
we see this kind of functionality
70:18 - when the user does not cooperate?
70:23 - Or how did I implement this, apparently?
70:25 - AUDIENCE: JavaScript?
70:26 - DAVID MALAN: Yeah, JavaScript.
70:27 - So it turns out that with
Python, you can obviously
70:30 - validate the user's input on the
server by just checking what's
70:33 - in request.args or request.form and
then yell at the user success or failure
70:37 - accordingly.
70:38 - But you can also use JavaScript-- and
honestly, we did this two weeks ago,
70:42 - so we just seem to be solving
the same problems again.
70:44 - So how do you think about this?
70:46 - Should I be checking for the
user's name and dorm in JavaScript?
70:50 - Should I be checking for the
user's name and dorm on the server?
70:56 - I mean, mixed messages now.
70:59 - AUDIENCE: Whatever's fastest.
71:01 - DAVID MALAN: Whatever fastest.
71:02 - That's a pretty good heuristic
to use, what's fastest.
71:04 - And we can make it prettier by
using Bootstrap or some library
71:07 - to give you like a colorful box, or
red error text or something like that.
71:10 - So which probably is faster,
Python or JavaScript?
71:14 - AUDIENCE: JavaScript.
71:14 - DAVID MALAN: JavaScript.
71:15 - Why, is JavaScript just a
better, faster language?
71:18 - AUDIENCE: You're not
creating it [INAUDIBLE]
71:20 - DAVID MALAN: Say again?
71:20 - AUDIENCE: You're not
creating it on a new server,
71:22 - so it's all happening on the same--
71:24 - DAVID MALAN: That's why, yeah.
71:25 - We don't have to get into the
religious debate of which language
71:27 - is better or faster, but where they're
running is certainly important.
71:30 - JavaScript is running, recall,
by definition, in the browser.
71:34 - It is sent as JavaScript
code to the browser
71:36 - which then executes it client side.
71:37 - Python by definition today is
doing everything server side.
71:40 - And indeed, the browser
doesn't even know
71:42 - Python is involved, because all it
gets is the HTML code that results.
71:47 - So OK, that seems to
be an argument for not
71:49 - doing all of the new work we did
today with if not name, if not dorm,
71:53 - and all of that, and
just use JavaScript.
71:55 - But the problem is that if you get
a little sloppy or a little clever
72:00 - and only implement your
error checking client side.
72:03 - Because as you say, it's faster,
and frankly once I make it prettier,
72:06 - it's just going to be more
interactive and more seamless.
72:09 - The problem is you can't
and should not trust users.
72:12 - Suppose that I'm a
malicious user and I just
72:15 - want to inject some bogus data into
your website, or I want to spam you,
72:18 - or subscribe 1,000 freshmen who
don't actually exist, or just
72:22 - generally create problems for you.
72:24 - Well, you might think,
well, that's OK, I
72:26 - have some defenses in
place, and JavaScript code,
72:28 - and this adversary is going to get
very quick feedback, very pretty
72:31 - feedback that they've not
provided these various fields.
72:34 - But honestly, you can't trust
anything ever coming from the human.
72:38 - If I open up Chrome's
developer tools, and I
72:41 - go to this down here to the dot
dot dot menu, and I go to Settings,
72:45 - and I go down here, there.
72:50 - That's all it takes to
disable all of your hard work.
72:52 - He or she can just
open up their browser--
72:54 - Chrome or something else--
72:55 - turn off JavaScript.
72:57 - So now when I actually
submit this form, there's
73:00 - going to be no on-submit
checking, no on-click handling.
73:02 - All of that is disabled.
73:04 - So if I go ahead and
click Register, I at least
73:07 - still, in this version of froshims,
have server side checking, as well.
73:11 - So this might be a little frustrating,
but it's kind of the reality.
73:14 - It is perfectly fine
to use JavaScript code
73:16 - and use client side code to give the
user a better experience-- a.k.a.
73:19 - UX, user experience.
73:21 - But you can't cut
corners and not implement
73:24 - the same kind of logic
server side because you
73:27 - need to defend against this.
73:28 - Otherwise bogus data is going
to end up in your database,
73:30 - things are going to go wrong.
73:32 - Never, ever, ever trust the user.
73:35 - Any questions?
73:37 - AUDIENCE: Can you do the same via CSS?
73:38 - DAVID MALAN: Can you
do the same with CSS?
73:40 - AUDIENCE: Yes, can you [INAUDIBLE]
JavaScript [INAUDIBLE]??
73:43 - DAVID MALAN: Not with CSS alone.
73:44 - You can use CSS to make the
error messages far prettier, yes,
73:47 - but not logically enough with CSS alone.
73:51 - And in fact, just to give you a sense
now how you can make things prettier
73:54 - since I keep alluding to better design
skills than the ones I'm showing here.
73:58 - If we go to Bootstrap, this very
popular, free, and open source
74:01 - library for CSS, it actually has
some interactive features, as well.
74:05 - And if I go under components in
the documentation and I scroll down
74:08 - and I go to forms,
you'll see, one, notice
74:11 - that these forms are already
way prettier than the ones
74:14 - I've been making, right?
74:15 - It's like black text, and
gray text, and small text.
74:17 - It just looks nicer and cleaner.
74:19 - But it's relatively easy to do this.
74:21 - And indeed, for the next
problems that you'll
74:22 - be welcome to copy and paste some
of this sample code and HTML,
74:26 - use Bootstrap CSS just to
make your forms prettier.
74:29 - But what it can really do if I
go to the sub menu over here,
74:32 - notice that there's this
validation section in Bootstrap.
74:34 - And other libraries have this, too.
74:36 - And you'll want to read
the actual documentation.
74:38 - But if I just scroll down for a while,
here's a sample form in Bootstrap.
74:41 - It already looks a little prettier than
anything I've made in just raw HTML.
74:45 - But notice if I don't cooperate, you
can do really cool validation of forms
74:50 - with green and red text if
the user does or doesn't
74:53 - cooperate by using a mix of CSS,
but with some JavaScript code.
74:57 - And so what Bootstrap does
for you is it actually
74:59 - automates some of the process
of that JavaScript code
75:01 - that we saw two weeks
ago and just used now.
75:04 - But it doesn't just pop
up a message for the user,
75:06 - it actually gives them
more immediate feedback.
75:08 - And almost any popular web site
you visit these days gives you
75:11 - this more immediate proximal input.
75:13 - Generally you don't see some
simple error message popping up,
75:16 - even though that's easier to do.
75:19 - Any questions?
75:22 - All right, so where did
that logic come from?
75:24 - So let me go into, for
instance, my template
75:27 - file now for the form in froshim6--
75:30 - again, the last of these examples--
75:32 - and you'll notice that I did this.
75:34 - If I scroll through this
file, you'll see the same HTML
75:37 - as we've been using for some time.
75:39 - But notice at the bottom of the
page that I draw some inspiration
75:43 - from two weeks back when we looked
at HTML, and CSS, and JavaScript.
75:48 - So just as a quick refresher,
notice how this is working.
75:51 - This line of code says
in JavaScript check
75:54 - the document using the query selector,
which lets you select anything
75:57 - in the web page looking for a form.
76:00 - When that form is submitted, call
the following anonymous function.
76:05 - If the document query selector finds
an input that does not have a value--
76:11 - and I say not because of
the exclamation point here--
76:13 - then yell at the user with
this, you must provide your name
76:15 - and return false.
76:17 - Else if the user did not provide a value
for the select menu-- a.k.a. the dorm--
76:22 - go ahead and alert them that
they must provide the dorm,
76:25 - otherwise return true.
76:26 - And just to be clear and to
recall from two weeks ago,
76:29 - what am I returning false?
76:31 - What does that effect have logically?
76:36 - Yeah, say again?
76:38 - What was that?
76:40 - I heard a whisper here.
76:41 - No?
76:43 - Yeah, it prevents
submission of the form.
76:46 - The default behavior of a form
is it wants to be submitted.
76:48 - That's why they exist.
76:49 - But if you return
false in JavaScript, it
76:51 - will short circuit that and
prevent that default behavior,
76:54 - thereby stopping the user from
submitting the form at all.
76:58 - So let's take one step back now, there's
now so much going on in this one file
77:02 - alone.
77:03 - In this sixth and final
example, notice that we
77:05 - have application.py, which is the
entry point, the so-called controller
77:09 - of this web application.
77:11 - It has a route which very simply
for slash looks like this.
77:15 - When the user gets slash, this
template is simply returned.
77:19 - What is in that index.html template?
77:22 - Well, it contains a partial HTML file.
77:25 - It contains this HTML.
77:27 - But it does not contain the doctype,
the HTML tag, head tag, the body tag,
77:31 - the title tag, and all of that.
77:32 - It only contains the stuff that
should go inside of the body tag.
77:37 - Because this file is
using a bit of jinja,
77:39 - which is the templating
language that Flask uses.
77:42 - You can just think of it
as Flask, that's fine.
77:44 - It uses some HTML here, but it also in
the bottom of the file uses JavaScript.
77:51 - And so just as before when we've
looked at the source of the page, what
77:55 - I'm going to see in the browser
on this forms page is no jinja,
78:00 - no Python, nothing related to Flask.
78:02 - Just a fully formed HTML
page that also now contains
78:06 - some of that client side code.
78:08 - And so I have this mixture now
of several different language,
78:11 - but each of which solves
a very distinct problem.
78:15 - Yeah?
78:16 - AUDIENCE: So I think it was a
week ago or two weeks ago when
78:21 - we were working on
JavaScript and CSS, you
78:23 - were saying that it's preferable
to split languages, not
78:28 - mix them in the same document.
78:30 - Right now we are mixing
multiple languages.
78:32 - DAVID MALAN: Really good observation.
78:34 - So a couple of weeks ago I really
preached the separation of concerns,
78:37 - and therefore separation of files.
78:38 - And that's why we
introduced a .css file,
78:40 - we also briefly showed
examples of a .js file.
78:44 - The short answer is as your
applications get more complex,
78:47 - life starts to get messy.
78:48 - And the team and I were
actually talking about this
78:50 - earlier as to how to present
some of these examples,
78:53 - because what you are seeing in my
design decision here is a tension.
78:57 - So that tension here is as follows.
79:00 - It is not necessarily the best practice
to just have your logical JavaScript
79:04 - code comingled with your HTML.
79:06 - It makes it harder to
collaborate with someone else.
79:08 - If one of you is really good at design
and wants to work on the HTML and CSS,
79:11 - the other person really wants to do
the JavaScript code, kind of hard
79:14 - to do that when they're
both in the same file.
79:16 - So we could factor this out.
79:17 - I could change this line, just
to be super clear, to be this.
79:23 - Instead of putting my actual code in the
file, I could do something like this.
79:27 - The source of this shall be
form.js, and that is just it.
79:32 - And then I have a separate file maybe
my colleague works in as follows.
79:36 - But at some point the thoughts
that go through my head
79:38 - are, it's only like 10
lines of code and I just
79:42 - have to create a second file
now, and that second file
79:45 - is going to be maybe in a
different folder as my template.
79:48 - And you know, it feels like this
is just overengineering a solution
79:51 - to the problem.
79:52 - However, once it's 20 lines, 100
lines, now OK, now it's feeling messy.
79:57 - Somewhere there's this inflection point.
79:59 - And this is where reasonable people will
disagree, and I might argue one way,
80:02 - you might argue the other way.
80:03 - And honestly, both of
us are probably right.
80:05 - And so this just speaks to the
web's development over time.
80:09 - And there's fancier frameworks
now. and if we tie things earlier
80:12 - into the question about CS50 beyond,
an opportunity after this class that
80:16 - looks more closely at
web programming, there
80:18 - are even fancier frameworks nowadays
than Flask and than Bootstrap
80:22 - that if tried to solve this problem.
80:23 - React is one of the most popular
ones developed by Facebook,
80:26 - now open source and
used by so many people
80:28 - around the world that
actually addresses this issue.
80:30 - And it allows you to separate
your HTML from your CSS
80:33 - from your JavaScript in different parts
of the file but still in the same file.
80:37 - And that was their particular solution.
80:39 - And View and Angular, there are so many
different solutions to these problems.
80:42 - And unfortunately, once we take
the training wheels of CS50 off,
80:45 - this is what's ahead of you.
80:46 - The world is messy.
80:47 - And the reason there are so many
darn languages and frameworks is
80:50 - because people like you have
these instincts and think,
80:53 - this could be done better.
80:55 - And thus do we iterate and
have new and new technologies.
80:57 - But this is the kind of
stuff-- and honestly, this
80:59 - is the kind of silliness
that changes over time.
81:02 - The fundamentals of HTTP,
and client side code,
81:04 - and JavaScript code, those
fundamentals are invariant
81:07 - even as the implementation
details change.
81:10 - So the short answer is,
could this be better?
81:12 - Probably.
81:13 - Could it be much better?
81:14 - I don't know.
81:15 - It really now becomes more
of a debate among developers.
81:18 - Good question.
81:20 - All right, so let's now use
some of these basic building
81:23 - blocks to make a final set
of examples that demonstrates
81:26 - a feature with which most of us are
pretty familiar reminiscent of what we
81:29 - did two weeks ago with Google Search.
81:31 - At the time we searched for cats.
81:32 - Today we'll keep it a little
simpler and a little less graphical
81:35 - and just search for words.
81:36 - Because you'll recall from
our speller problem set,
81:38 - you implemented a spell checker
with 140,000 plus English words.
81:42 - That's a pretty juicy
dataset to search over,
81:45 - and you're probably all familiar
with autocomplete these days.
81:49 - There's hardly a website these
days that when you start typing it
81:52 - doesn't try to finish
your thought for you.
81:54 - Google, Facebook, any a
number of other sites.
81:56 - So autocomplete, how does that work?
81:58 - Well, let me propose the
following mental model.
82:00 - If you do have some data set
like a big list of words,
82:03 - or a big list of Facebook friends,
or a big list of whatever,
82:06 - you might store that server side
because it's a lot, a lot of data.
82:09 - And in fact, next week you
might store in a big database.
82:12 - But for today we'll
just store it in a file
82:14 - like we did for the speller piece set.
82:15 - But if you want to create
an interactive experience
82:18 - for the human, what
language are you're probably
82:20 - going to want to use so that he
or she gets immediate feedback?
82:24 - Probably JavaScript, right?
82:25 - That's the whole principle.
82:26 - Client side code is just going
to execute faster because there's
82:28 - no internet between you and the code.
82:30 - But with Python, you
have access to files.
82:33 - And yet with JavaScript code you
have closer access to the user,
82:36 - so there's these tensions.
82:38 - So how could we go about building a
site that lets a human via form search
82:43 - across that file for words?
82:45 - Well, let's start as follows.
82:47 - So in word 0 we have the following.
82:52 - Large, which is just a text file
borrowed from the speller problem set,
82:56 - 140,000 words, one poor line therein.
82:58 - I'm not even going to
double click and open it
83:00 - because it's so darn big it'll
take a few seconds to open.
83:03 - In application.py we have probably
the entry point to this application,
83:06 - and in templates we have just
three templates this time.
83:09 - So just when you're reading someone
else's code for the first time,
83:12 - where should our entry point be?
83:13 - Where should we start looking
to understand what's going on?
83:18 - Maybe application.py.
83:19 - Or honestly, you know what?
83:20 - If you want to see what
something does, run it.
83:23 - No harm in doing that.
83:23 - So lets run Flask run.
83:25 - Make this a little bit bigger.
83:26 - Let me open up the URL here,
open, and I see a very simple form
83:30 - asking me for a query.
83:31 - Let me go ahead and search
for a and click Search.
83:35 - And after a moment, OK.
83:37 - This is a lot of words,
but apparently these
83:40 - are all the English words
that our dictionary knows
83:42 - about that start with the letter a.
83:44 - And if I go all the way
to the bottom, you'll
83:46 - see it stops with az whatever
with no B words, in fact.
83:49 - Well, let's make sure this actually
works and isn't just a trick.
83:52 - Let's search for b words.
83:54 - OK, so that seems to work, as well.
83:56 - And notice I borrowed some
inspiration from Google.
83:58 - Notice that the route I'm using is
called slash search like two weeks ago.
84:02 - Does take a cue parameter for query,
and b is whatever the human typed in.
84:06 - So if I want to search
for z the words, enter,
84:10 - I should hopefully get back now z words.
84:11 - So now unlike two weeks ago, we
can implement both the front end
84:15 - and the back end for a search engine.
84:17 - But our search engine's
searching now just for words.
84:19 - So let's look at application.py as
proposed, which is the entry point,
84:23 - and let's see how I'm doing this.
84:24 - So this is some code that I
borrowed a little bit from last week
84:28 - when we quickly implemented
the spell checker
84:30 - in like 12 or 20 lines of Python code.
84:33 - I'm declaring a global
variable called words,
84:35 - and I capitalized it just to
be reminiscent of last time
84:38 - and the problem set.
84:39 - I'm using this syntax
which I alluded to earlier
84:41 - is just more conventional or Pythonic.
84:43 - Open the large file in Read
mode and call the variable file.
84:47 - Then here is a for loop via
which you can iterate over
84:50 - every line in the file,
reading one at a time.
84:53 - But recall, what does every
line in this file end with?
84:58 - Like a backslash n, and we don't
really want those as part of the words.
85:01 - That's not part of the English word.
85:03 - So R strip, right strip removes any
whitespace from the end of the string.
85:07 - And that's why I needed
to add that extra line.
85:09 - So I'm just cleaning up the
file or massaging the data
85:11 - as you might do with any sort
of data based application.
85:15 - So then I just seem to have this
route that renders the template.
85:18 - If I look in index.html,
let's follow the bread crumbs.
85:21 - Go into index.html.
85:23 - OK, not that much going on here.
85:24 - Looks like an HTML form, the
action of which is slash search,
85:27 - just like Google's.
85:28 - The method of which is is
get just like Google's.
85:31 - There's nothing really private about
the words I'm searching for here,
85:34 - so I don't care.
85:35 - There's some fancier features here.
85:37 - Notice placeholder is the
grayed out text the human sees.
85:39 - Auto focus.
85:41 - What does this do again?
85:42 - This is just a UI feature,
better user experience.
85:45 - AUDIENCE: Puts the like,
right in the text box.
85:47 - DAVID MALAN: Yeah, it puts the
cursor right in the text box.
85:50 - To focus on something in a
web page means make it what's
85:53 - interacting with the user right now.
85:54 - And Mac OS, for instance,
highlights it in blue.
85:56 - So when you first load
the page, the cursoe's
85:58 - blinking in the choice of text
boxes that you care about most.
86:02 - Autocomplete off just disables the
browser's version of autocomplete.
86:05 - So I don't see past searches,
just because the whole point here
86:08 - is to implement this
ourselves ultimately,
86:10 - and then I have my search button.
86:11 - This is just jinja stuff from
Flask so that I have a layout file.
86:15 - Lets follow that breadcrumb.
86:16 - Lay out.html, nothing really
that interesting going on there.
86:20 - If you've ever wondered why we
have these in a lot of our demos,
86:23 - this cryptic looking line here
just makes web sites look better
86:26 - on mobile devices.
86:27 - Typically by default if you pull up
your phone and look at a website,
86:30 - if it doesn't have
that kind of line, like
86:32 - the text is going to be super
tiny unless you pinch and zoom.
86:35 - By using this line and
variations thereof,
86:38 - it will increase the
default font size a bit
86:40 - to make it a little more
tolerable on small screen.
86:42 - So it's an easy win
for users experience.
86:44 - OK, I seem to have exhausted all the
interesting stuff in these templates.
86:48 - Let's look at another and final route.
86:50 - Here's my search route, and
this is pretty Pythonic.
86:55 - This is a mouthful, and
will re-implement it
86:57 - in a different way in just a moment.
86:59 - So I have a search route that listens
for get requests on slash search.
87:02 - Then this crazy looking line is
about as Pythonic as code gets.
87:07 - And I'll explain what
this is doing and why
87:08 - it's conventional as opposed to
straightforward at first glance.
87:14 - And then I render the template,
passing in these words.
87:17 - So this one liner on line
17 actually has the effect
87:20 - of searching 140,000
words for whatever words
87:23 - start with what the user typed in.
87:26 - See, this would be a
pain in the neck to do.
87:28 - In Python you can do it
with literally one line.
87:30 - A long line, but one line nonetheless.
87:33 - Let me make this more clear.
87:34 - If I were to search for
words in this big file,
87:38 - I might do something like this.
87:39 - Words is an empty list.
87:41 - So this lower case words is
all of the words that match,
87:43 - that I want to send back to the user.
87:45 - So by default I have no
idea what to send back.
87:47 - But I do know I can do this.
87:48 - For word in Words--
87:50 - which is the capitalized variable,
the constant up at the top
87:53 - that has the whole--
or not even constant,
87:55 - but the global variable that has
all of the words from the file, here
87:58 - is a for loop over those.
88:00 - I can now say something like this.
88:02 - If the current word starts with
whatever the user typed in-- well,
88:07 - what's the user typing in?
88:08 - Well, q equals request.args.get
quote-unquote q,
88:13 - gives me the user's name, dorm,
or in this case Q value for query.
88:17 - So if the word that we're currently
iterating over starts with q,
88:22 - I can go ahead and append to my--
whoops, append to this list that word.
88:33 - Would you say you're comfortable
with these lines here?
88:35 - To recap, give me an empty list in
which to store the search results,
88:41 - iterate over all possible
140,000 plus words, get--
88:44 - and actually, this was stupid.
88:45 - I should just put this up here, because
I only need to check for that once.
88:49 - So store the user's input
in a variable called q.
88:52 - For each word among the 140,000, check
if it starts with the user's input--
88:57 - a, b, z, whatever.
88:59 - And if so, append it to there.
89:02 - So let's temporarily get rid of
this and just render the template.
89:05 - So notice this gets the job done,
but this is very C-like logic.
89:09 - It's not wrong, it's perfectly correct.
89:11 - But Python is a language
that's meant to be
89:14 - a little more human readable
and a little more elegant,
89:17 - if a little more non-obvious.
89:19 - So this one line does
the exact same thing
89:21 - using a feature called a
list comprehension, which
89:24 - is ironic if you don't quite
comprehend how it's working.
89:27 - But here's the variable I
want to create called Words.
89:30 - These square brackets
here say give me a list.
89:33 - What do you want to put in that list?
89:34 - I want to put a word in this list.
89:36 - Which word do you want
to put in this list?
89:38 - The result of inducing this loop
and then only putting in this list
89:42 - a word if it starts with
what the human typed in.
89:46 - So it takes some getting
used to, but this is just
89:48 - a one liner way, a very Pythonic way of
expressing those several lines of very
89:53 - procedural code into a simple one line.
89:56 - Is it better?
89:57 - Not if you can't read it.
89:58 - But once you get more
comfortable with Python,
90:00 - yes, it's better because it's less code.
90:02 - Yeah?
90:02 - AUDIENCE: You said Python uses
notation to tell where conditions are.
90:07 - How is [INAUDIBLE]?
90:09 - DAVID MALAN: Good question.
90:10 - In this case of a list
comprehension, you can only
90:13 - have one line or one condition.
90:16 - You can't have multiple lines therein,
so I cannot start hitting Enter
90:19 - and indenting here.
90:20 - It's just not allowed.
90:21 - So you would only use this-- and I'm
frankly really pushing the limits.
90:24 - You should only really use this
syntax when it fits on your screen
90:27 - or fits on a reasonable person's screen.
90:30 - After that you should probably do
something a little more expressive.
90:33 - Other questions?
90:35 - But this is very common to see online.
90:36 - So any tutorials, if you ever
see this kind of one liner,
90:39 - just try to think about it from that
approach what it is actually doing.
90:43 - OK, so propose from a user
experience perspective
90:46 - how could this program be better?
90:48 - Because this is just our first version.
90:50 - So what could be better
for the user than this?
90:57 - What could be better?
90:59 - Yeah?
91:00 - AUDIENCE: Just going back,
can you explain words in caps?
91:06 - DAVID MALAN: Oh, sure.
91:07 - Words in caps is this global variable I
defined up here that stores all 140,000
91:13 - plus words.
91:14 - That's the really big file
called large, the text file.
91:17 - Down here I just need a local variable.
91:20 - And if it's more clear, I could
call it results and then just
91:23 - say results equals results.
91:24 - That is the subset of words
that start with a, or b,
91:28 - or whatever the human typed in.
91:30 - That's all.
91:31 - Good question.
91:32 - Yeah?
91:32 - AUDIENCE: Why do we
change the last time-- why
91:34 - did you have to change args to form?
91:37 - DAVID MALAN: Why did I
have to change my args to--
91:39 - AUDIENCE: Forms?
91:41 - DAVID MALAN: So earlier today when I
didn't understand what was going on,
91:45 - you should use request.args
for get requests.
91:49 - You should use request.form
for post requests.
91:52 - AUDIENCE: But it's still .get after?
91:55 - DAVID MALAN: It's always .get, yes.
91:57 - But you change what you're
getting things from.
91:59 - In an ideal world, it would have been
something-- oh, I see what you mean.
92:03 - Get in this sense is the verb.
92:05 - We humans mean go get something.
92:08 - Args in this sense,
if they had done get--
92:11 - I'm making this up, but this
is probably why they did this.
92:14 - Because get from get seems weird,
whereas get from post is less weird.
92:18 - But it's just they called
it args and form instead.
92:21 - OK, so let's actually
improve this, but how?
92:24 - What could be better for the user?
92:26 - Yeah?
92:26 - AUDIENCE: They could search a
word, not just the first letter.
92:28 - DAVID MALAN: OK, maybe
searching a whole word
92:29 - would be good, not
just the first letter.
92:31 - What else could we do?
92:33 - AUDIENCE: We can create an
index list of letters and words?
92:38 - DAVID MALAN: OK, we could
create an index list.
92:40 - So maybe using a hash or some form
of inspiration from our problem
92:45 - set with Speller and actually use
a more sophisticated data structure
92:47 - to get these answers more quickly.
92:49 - And let me propose, too, the goal here
is to actually implement autocomplete,
92:53 - and this was not auto complete.
92:54 - This was like old school search.
92:56 - Type in a query, hit Enter,
get a page of results.
92:58 - What if we want to do
something more immediate?
93:00 - So let me actually propose this.
93:02 - Before looking at the code,
let me go into words 1.
93:05 - Let me go ahead and run
Flask in that directory.
93:07 - Let me go ahead and
reload the form here,
93:09 - and now notice no Submit button
because there's not going
93:12 - to be any actual submissions here.
93:13 - But I'm going to go ahead and hit the
letter A, and ooh, that's kind of cool.
93:18 - Let me delete that, goes away.
93:20 - B, there's all the B words.
93:22 - Let me go B-A words, B-A-B
words, B-A-B-A words.
93:28 - This is how autocomplete works.
93:31 - So it seems to be responding immediately
to my input, so something's happening.
93:35 - But I'm not actually
submitting the form.
93:37 - So I'm kind of using it now,
it seems client side JavaScript
93:40 - to maybe talk to the server?
93:42 - Let's infer.
93:42 - So here, too, this
should be your instinct.
93:44 - Whenever you're trying to understand
how someone's website works,
93:47 - if you want to learn from it or mimic
certain fundamental functionality,
93:50 - go ahead and inspect the page.
93:52 - And you don't probably care
too much about the HTML yet.
93:55 - Where is this data coming from?
93:57 - Let me click on the Network tab, which
we looked at a couple of weeks ago.
94:00 - Let me go ahead and restart this
and let me clear this and start
94:03 - from the beginning of the story.
94:04 - Let's see what happens when I
type the letter A. Interesting.
94:08 - There is a web request.
94:10 - So if I zoom in down here, notice
that my browser actually searched
94:14 - for Q equals A, the human's input.
94:17 - Let me go ahead and-- it
keeps searching because I'm
94:19 - using keyboard shortcuts here.
94:20 - But let me go ahead and click this row.
94:22 - Notice what happened.
94:24 - I made a request to slash search
question mark q equals a via get.
94:29 - Let's see what the response was.
94:31 - The response here, if
I view the source--
94:34 - or rather, if I read the response--
94:37 - notice what came back.
94:38 - It looks like my server returned to me
a fragment of HTML containing hundreds,
94:44 - maybe thousands of words starting
with A. But notice there's no UL tag,
94:47 - there's no head tag, no title, no body,
it's just a partial HTML fragment.
94:51 - But that's interesting, because I know
with Python I can do exactly that.
94:54 - I can generate anything
I want on the server,
94:57 - and then maybe the browser can just
plug in those changed the results.
95:01 - So let me go ahead and look
at the code for this page.
95:03 - If I go now to the browser's
source code, the view page source,
95:08 - you'll see a few new lines.
95:10 - So to do this easily, I'm
actually using another library.
95:14 - This one is called jQuery.
95:15 - This was for many years
super, super popular.
95:18 - It's kind of starting
to fall out of vogue,
95:19 - but it's still so
powerful and so useful.
95:21 - And it's used by Bootstrap, the
other CSS library we've talked about,
95:25 - so it's perfectly
reasonable to use it here.
95:28 - Notice how I'm including
it with the script tag,
95:30 - and it's hosted on a
third party website so
95:32 - that I don't have to save a
copy of it myself on my own IDE.
95:35 - Then let's look at the
code I actually wrote.
95:38 - So notice that atop this file
is not even a full fledged form,
95:41 - it is just the HTML input.
95:43 - Because I don't need a full form.
95:44 - I don't need an action,
I don't need a method,
95:46 - because I'm not submitting it
anywhere with the human's cooperation.
95:50 - I'm going to use my own code.
95:51 - So in my script tag here, my
JavaScript code, notice what I'm doing.
95:55 - This is some code from
like two weeks ago.
95:57 - I'm going to search the tree
that represents this web page.
96:01 - And indeed, it is meant to be a tree.
96:02 - Recall from that time when
we looked at an HTML page,
96:05 - there is in memory, thanks to
the browser, something treelike--
96:09 - a DOM, document object model--
that represents your page.
96:12 - Using JavaScript, can we change
that page after the fact?
96:16 - So what am I going to do?
96:18 - I'm going to tell the browser whenever
this input hears an event called on key
96:23 - up-- so whenever the field has
focus-- it's blue in Mac OS--
96:27 - and the human hits the
key and then let's go,
96:30 - and the key goes up, go ahead and
call the following anonymous function.
96:34 - What do you want that to do?
96:35 - Now, this code is a
little cryptic, but let
96:37 - me walk us through it because
it's only three lines.
96:40 - This code here is using
a special feature--
96:44 - dollar sign-- that comes from
this library called jQuery.
96:47 - More on that in a moment.
96:48 - That library, somewhat confusingly
named, has a function called get,
96:54 - which has nothing to do with Python
or the one we just talked about.
96:57 - But this has to do with an HTTP get.
96:59 - With this line of code,
you can tell a browser,
97:02 - even after a web page has been loaded,
go get me this other URL, please.
97:06 - So what URL do you want to get?
97:08 - Go ahead and get me from the same
server slash search q equals,
97:13 - and then what does plus mean
in JavaScript if you recall?
97:17 - Concatenation.
97:18 - So it means just append
one string to the other.
97:20 - So this is like saying,
go ahead and get me
97:22 - the URL that ends with slash search,
question mark, Q equals A, or Q equals
97:27 - B, or Q equals Z. Whatever
the human typed and just gets
97:31 - slapped onto the end.
97:32 - And then that's where
we're getting it from.
97:34 - Input.value is the user's
input, the value thereof.
97:37 - And then the last line-- and
this is perhaps the fanciest--
97:40 - notice that I have an
anonymous function.
97:43 - In this library called
jQuery, there is this function
97:47 - called get that gets a URL.
97:49 - When the server responds to your request
with a virtual envelope of its own,
97:54 - this anonymous function gets
called and the response envelope
97:57 - gets handed to you, so to speak, as
a data argument, as a data variable.
98:03 - Then what you can you do?
98:05 - Document.queryselector UL.
98:07 - What is UL?
98:08 - It's an unordered list that by default
on this page has nothing in it.
98:11 - But recall that what the server is
sending back is a bunch of LI tags.
98:15 - That's great, because I want to put
those LI tags right in between here.
98:18 - So how do I do that?
98:19 - I go into the so-called
inner HTML of the UL tag,
98:21 - and you might not have seen this before.
98:23 - But you can change the contents
of an existing tag inside of it
98:28 - by using inner HTML and
just plop the data in there.
98:31 - And so what's happening is this.
98:34 - Let me go ahead and open
up Chrome's inspector.
98:36 - Reload the page so it's empty.
98:37 - Let me open up Chrome's inspector.
98:40 - Go to elements, as is the
default. And notice on this page,
98:43 - notice that UL tag is opened and
closed with nothing inside of it.
98:48 - The moment, though, I search for
something, watch what happens.
98:51 - If I search for a, all of a sudden--
98:54 - ooh, it blinked, it's a little small.
98:56 - Now there's a little triangle there.
98:58 - What's inside of it?
98:59 - All of those LI tags that
came from the server.
99:03 - So with JavaScript, we
have this amazing power now
99:05 - to change what's inside of a web page
by just asking the server for more data.
99:10 - So if you've ever used
Facebook, or you've
99:11 - used Google Chat, or any websites that's
dynamically changing every second,
99:15 - every minute and each time you
get a message, you can literally,
99:17 - if you get a little nosy, open up
Chrome's inspector and watch the DOM,
99:21 - watch this elements tab.
99:23 - And you'll see new stuff
popping up every time
99:25 - you get a message, or a chat, or any
other such notification on the screen.
99:29 - Now as an aside, this is a little
sloppy to be returning HTML,
99:32 - but let's see how it's done.
99:34 - Let me go into application.py for
words one, which is this example here.
99:39 - And in application.py, notice
what I'm doing is this.
99:43 - Rather than return a
whole page of results,
99:46 - I'm returning a template
called search.html.
99:49 - All of the rest of this
code is identical to before.
99:52 - If I go into my templates and go into
search.html, look how terribly simple
99:57 - the code is on the server.
99:59 - If all you want to do is spit
out a bunch of list items,
100:02 - this is all you need.
100:02 - There's no template.
100:03 - Like there's no extends layout because
you're not returning a whole web page,
100:06 - you're returning a tiny,
tiny, tiny fragment of HTML.
100:11 - But this is arguably a little
sloppy, because there's
100:14 - a lot of redundancy
in what's coming back.
100:16 - If I look at this tag that's
coming back from the server,
100:19 - what is obviously redundant about all
of this information that's coming back?
100:22 - And if I look at the Network tab,
you really see it under response.
100:25 - What's redundant?
100:26 - AUDIENCE: You're doing a bunch of calls
to the same address and to the same--
100:29 - DAVID MALAN: This was just because I
hit some, like, zoom in and zoom out,
100:32 - so it pretended to
make multiple requests.
100:34 - So red herring there.
100:35 - Focus only on this part here.
100:37 - What's redundant about all
of the data coming back?
100:41 - It's just keeps saying list
item, word, close list item.
100:43 - List item, word, clothes list item.
100:45 - I mean come on, just use
a more efficient syntax.
100:48 - Just separate things with commas
or something lighter weight.
100:51 - This is sending way many bytes.
100:53 - I mean, look.
100:53 - There's thousands of bytes.
100:55 - This is kilobytes by
definition of information
100:58 - that we're sending just
to send open bracket,
101:00 - LI close bracket again and again.
101:02 - This is not very efficient.
101:03 - And so the world actually has
adopted a different approach,
101:06 - and I'm going to show this in words 2
that actually returns something called
101:10 - JavaScript Object Notation, which is
a more succinct representation of this
101:15 - as follows.
101:15 - Let me go into words
2, run Flask in there.
101:20 - Search for the same kind
of thing and then watch
101:22 - what happens over the
network panel this time.
101:24 - When I search for A, immediately
get back the same visual result.
101:28 - But if I look at this search
query, now look what comes back.
101:31 - I claim that this is a much more compact
representation of the same information.
101:35 - It's a little annoying
that there's double quotes,
101:37 - because those are a little redundant.
101:38 - But at least double quotes
are a lot more efficient
101:40 - than open bracket, LI, closed bracket,
and then the opposite at the end.
101:43 - So this is what's called
JavaScript Object Notation.
101:46 - And as this square
bracket here and thousands
101:49 - of words later the square
bracket on the end implies,
101:52 - this is a JavaScript array that's
being sent back from the server.
101:57 - So the only thing that's
changed here is as follows.
101:59 - In words 2, this example,
notice that I don't even
102:04 - need to return a template anymore.
102:06 - This code is the same as
the past two examples.
102:08 - This is how I'm searching
140,000 words quickly.
102:11 - But if I include now a fancier
function from Flask called jsonify--
102:16 - which is not really a word.
102:17 - But jsonify, that takes
any data structure
102:20 - you have data in like this
list of words, the matches,
102:24 - and it turns it into that text based
representation with quotes and commas.
102:28 - And you don't even have to
write a template yourself.
102:30 - And indeed, I got rid of search.html.
102:33 - The only thing you have to do to
give yourself access to this feature
102:35 - is import not just render
template, and request,
102:39 - and Flask, but jsonify, as
well, from the Flask library.
102:44 - Which is just one more feature.
102:47 - Any questions on that before we bring
it all together with one final example?
102:53 - Yeah?
102:53 - AUDIENCE: Can double quotes
break that into [INAUDIBLE]??
102:57 - DAVID MALAN: Can double
quotes break that?
102:59 - Good question, great instincts.
103:00 - No because the author of
jsonify was smart about this.
103:04 - And if that author notices a quote
like an apostrophe, or like something
103:09 - in your own name that has a quote,
it will escape it in some way,
103:14 - usually with a backslash.
103:15 - Good instincts.
103:16 - But that's why you probably wouldn't
want to write this code yourself
103:19 - because then you have to think of
all of those corner cases as opposed
103:22 - to focusing on the parts you care about.
103:25 - All right, so there's one final example.
103:27 - And it's perhaps to come full circle
here, do we even need the server?
103:32 - These 140,000 words right now
are in a file called large.
103:36 - My web application loads that file
into memory and then searches it.
103:39 - But who else could search
over a big list of files?
103:45 - Where else could we put this logic?
103:48 - The browser, right?
103:49 - Browser gives you JavaScript,
JavaScript's a language,
103:52 - languages can search things.
103:54 - So let me try this instead.
103:55 - In our words 3 example here,
notice that I've got one new file.
104:00 - In advance, you know, I took my big text
file that just had one word per line
104:04 - and I put it into a standard
format just because it
104:06 - makes my life a little easier.
104:08 - And I called it large.json.
104:10 - And in there, actually, where if I open
up this folder, you'll see large.js,
104:16 - which is a second file,
this time a JavaScript file,
104:20 - in which I've just declared a
JavaScript array of all 140,000 words
104:26 - for better or for worse.
104:27 - I just put them into a
slightly different format
104:29 - with commas, and quotes,
and square brackets,
104:31 - and I gave this whole thing a variable
name at the very top of the file.
104:35 - Now, why is this useful?
104:36 - Well, if I go into
index.html, notice that there
104:39 - is no more application.py or
templates for this example whatsoever.
104:43 - We've gotten rid of
Python entirely, I don't
104:45 - know if it's for the better
or worse, but we'll now see.
104:48 - So in this file, notice we
have an input tag as before,
104:51 - a placeholder for all of
the ULs, but we're also
104:55 - now including this large.js file.
104:57 - Thereby telling the browser
please download all 140,000 words
105:02 - and then search them locally.
105:04 - How am I going to search it locally?
105:06 - I've essentially converted the
language I wrote in Python a bit
105:09 - ago into JavaScript as follows.
105:11 - Here says the browser go get me the
input that the user can type into.
105:16 - This tells the browser, go
ahead and listen for key up.
105:19 - Whenever that happens,
please call this function
105:21 - which has no name, because I want
you to just call it immediately,
105:24 - I don't need its name.
105:25 - This function is defined
by these several lines.
105:27 - These several lines have to do
a bit more work than before.
105:30 - Because before the server
was doing all the hard work
105:32 - sending back all of the data, and
we just jammed it into the web page.
105:36 - But here I'm going to build up
a list a little more manually.
105:40 - So I'm going to let a
variable called html
105:42 - equals quote unquote, because I want
to build up the unordered list myself.
105:46 - Then if the human, indeed,
types something in--
105:48 - so if their input is non null, so
if they type at least one character,
105:52 - do the following.
105:53 - This is weird in
JavaScript, but when you
105:54 - iterate over an array in JavaScript,
you use the preposition of not in.
105:59 - So for word of words, go
ahead and do the following.
106:03 - If the current word starts with--
notice the capitalized w-- also
106:07 - different from Python, but same
idea, just different spelling--
106:10 - if the word I'm iterating over starts
with whatever the human inputted,
106:14 - we found a match.
106:15 - Go ahead and append
to this HTML variable,
106:18 - open bracket LI closed bracket,
concatenate the word to it,
106:22 - and then close bracket, as well.
106:25 - So I'm constructing a variable
in the browser's memory
106:28 - containing HTML that I want to
jam into the DOM ultimately.
106:32 - How do I do that.
106:33 - Well, at the very last line I say
to the document, select the UL tag,
106:37 - go inside of its HTML,
and change whatever
106:39 - is there to this string of HTML,
which is presumably 0 or more LI tags
106:46 - now based on those search results.
106:47 - So now let me go back to words 1--
106:50 - rather, let me go back
to this example here.
106:53 - Let me go ahead and serve this up.
106:55 - It's not Flask anymore, so I have to
use our server from two weeks ago,
106:58 - HTTP server, to serve up HTML.
107:01 - Let me go ahead and reload the screen
here, open up index.html, and now
107:06 - notice we're good to go.
107:08 - What do you want to search for?
107:09 - A, B, C. And let's open
up the Network tab.
107:15 - Inspect, Network.
107:17 - Let's see what happens
every time I search.
107:19 - Z, Y, Q, A. Why is there
no network traffic now?
107:26 - AUDIENCE: There's no network traffic.
107:28 - DAVID MALAN: OK, but that's what I said.
107:30 - But why is there no network traffic?
107:32 - It's not sending any routes, it's
not talking to a backend server.
107:35 - Why?
107:36 - Because all the data I
might need is already local.
107:38 - So mixed messages here, too.
107:41 - Which is better, which is right?
107:42 - What's the takeaway?
107:43 - How do you think about this?
107:44 - Because now, whereas a lot of our
programs early on in the semester
107:47 - were relatively small even though
they didn't feel that way at the time,
107:50 - now we have even more
design possibilities.
107:52 - And the answers are
increasingly non-obvious,
107:55 - and this is why you as
programmers will just
107:57 - get more comfortable with
conventions, you'll maybe
107:59 - practice what you've
seen preached first,
108:00 - then you'll decide as you
might be already saying,
108:02 - I don't like that, I'm going
to do this some other way.
108:05 - So how do you think about which of
these several words examples is best?
108:08 - Version 0 was let the
server do all the work
108:11 - and just send back a full new page
of results like Google in 1999 did.
108:15 - Then version 1, we added
a bit of JavaScript
108:18 - that used jQuery the library
to talk to the server using
108:21 - a technique called Ajax--
108:23 - asynchronous JavaScript and XML--
108:24 - but that just means go get me more
data and we returned LI elements.
108:28 - Then we decided that's
a little sloppy, don't
108:29 - seem to send me all
these useless tags, just
108:31 - send a comma separated list of words.
108:34 - That was version 2.
108:35 - And then this last version
gets rid of all of that
108:37 - and just sends all the
words to the browser
108:39 - and lets it deal with it entirely.
108:43 - Who likes which best, 0, 1, 2, or 3?
108:48 - What do you think?
108:49 - AUDIENCE: So if you aren't
supposed to trust the user in case
108:52 - they turn off the JavaScript, then
their decision of the functionality
108:55 - of the website works.
108:57 - DAVID MALAN: That's a good trade-off.
108:59 - So if the user turns off JavaScript, 3--
109:02 - OK, it won't offend anyone--
109:03 - 3 2, and 1 won't work anymore
because JavaScript's disabled.
109:07 - Now, do you care about that?
109:09 - Maybe not.
109:09 - It's a small number of
users on the internet who
109:11 - are so concerned with this they
just turn off JavaScript altogether,
109:14 - and the reality is so many websites just
break these days without JavaScript.
109:17 - That might be a reasonable
cost of doing business.
109:20 - Other thoughts?
109:20 - Yeah?
109:21 - AUDIENCE: Is the last
version the fastest?
109:23 - DAVID MALAN: Is the last
version the fastest?
109:25 - I don't know, how could we assess that?
109:29 - Yeah, I mean, we can
literally measure it.
109:31 - And honestly, built into Chrome in
other tabs that I've not even clicked on
109:34 - are a lot of performance
tools where you can actually
109:36 - monitor how long everything's taking.
109:38 - This is called benchmarking
more generally,
109:40 - and this is what you did
essentially in the speller problems
109:42 - that even though we wrote the
code that timed everything
109:44 - and measured everything,
to answer that question,
109:46 - you could just try timing
every one of the examples
109:49 - and then decide for yourself
which is best, sure.
109:51 - Yeah?
109:52 - AUDIENCE: The last thing I
have with problematic issue
109:54 - is like my phone's old, and it
doesn't have a lot of memory,
109:57 - and I may not have the
fastest plan on Earth.
110:00 - So you might be charging me more data,
you might be slowing my phone down.
110:06 - DAVID MALAN: Very reasonable concern.
110:07 - Let me go into our dictionary file
here and list the size of this.
110:13 - That large.js file is 2.2
megabytes, which on mobile devices,
110:17 - especially in places where your signal
is slow, or your bytes are expensive,
110:21 - or you only have
intermittent access, I mean,
110:23 - that's kind of obnoxious to
send two megabytes to the user
110:26 - if you can avoid it, especially when
you can send only the subset of results,
110:30 - a few kilobytes maybe,
of matches instead.
110:33 - So a very reasonable concern.
110:34 - Cost, user experience, performance.
110:36 - Other thoughts?
110:39 - Which is better for people on university
and corporate campuses who tend
110:42 - to have really good internet access?
110:46 - Say again?
110:47 - 3, OK.
110:47 - But what if it's not
140,000 words, but it's
110:50 - like a billion pictures of
cats that Google indexes?
110:54 - Or hundreds or thousands of friends
and all of their profile data?
110:58 - Like at some point there's
this inflection point
111:00 - where too much data, right?
111:01 - It's not reasonable, it's too much.
111:03 - You don't want to just get a
copy of your corporate database
111:05 - to every one of your users just
for them to search more locally.
111:08 - So again, these are the
non-obvious questions.
111:10 - And one of the goals of,
frankly, the final project
111:12 - if you do something web based, or
mobile based, or C based, or anything,
111:15 - is all of these questions
now boil down to you.
111:17 - Like we have no
well-defined answers in mind
111:20 - as to what your final project should
do and how it should do it best.
111:23 - But in the weeks ahead, you'll be
pre-proposing some project ideas,
111:26 - proposing an actual project idea, and
then designing and implementing this.
111:29 - And you, too, will
probably feel this tension
111:31 - where the answer is not always obvious,
your teaching fellow might not even
111:34 - know how to answer your
question, because he or she will
111:36 - have thoughts of their own.
111:37 - But it's ultimately up to you.
111:38 - And we're now at the point
of a level of coding maturity
111:42 - where we're taking the training
wheels off and more of the decisions
111:45 - are now left to you.
111:47 - Let's end here.
111:48 - Stick around for one on
one questions, and we'll
111:50 - see you next week for databases.

Cleaned transcript:

[MUSIC PLAYING] DAVID MALAN All right. This CS50 and this is lecture 7 wherein we pick up where we left off last time in talking more about Python, but this time using Python for even more powerful purposes, an alliteration I didn't intend until I just said it there. But the goal here with Python now is to actually use this language to generate another language, in particular HTML. And what we'll do is start to provide all the more of a mental model for what you would call separation of concerns, whereby when you design more complicated web based, or rather when you design more complicated software, you tend to try to adopt certain design patterns so that you're not just writing everything in one big file that gets a little confusing, unwieldy to maintain and to add to over time. But you start to separate your concerns, and your functionality, and your features, and your collaborators' work into different files and different methodologies. So we'll try to give you some of these industry standard approaches today and why they actually solved problems. But, of course, how did we get here? A few weeks ago, we talked about this thing, this virtual envelope that just represents packets of information, zeros and ones, going across the internet from point A to point B. And among the messages in these envelopes might be for web requests. And we talked about HTTP, a protocol, hypertext transfer protocol, that just sends message like this inside of the envelope. And this is requesting, of course, the default page of a website as implied by the slash. And in many cases, but not always, this implies a default file name of index.html. But that's a human convention, not a requirement. Hopefully, the server responds with a numeric code equal to what integer? 200, hopefully, a number that we never actually really see unless you get more comfortable and start poking around Chrome's inspector and you look at your network traffic. Right. So here is an actual successful response, which means everything is indeed OK. And if the browser looks a little farther down in the virtual envelope, if you will, it will see another language called HTML, HyperText Markup Language, which is the stuff we wrote a couple of weeks ago and you'll continue writing this week as you now dynamically generate websites. But what we'll introduce today is what's also known as a framework, or, more precisely, a microframework, because we'll see in just a few minutes time that it can actually be really annoying and really tedious to generate websites automatically using Python if you have to write Python code alone. And so humans, over the past several years, have noticed, wow, every time I make a web application using Python, I find myself typing the same lines of code again and again just to get started, or when I'm collaborating with someone else, I find that, ooh, it's a little hard to collaborate if we're all working in the same file. So humans have invented what are called frameworks. And this is an example of code written in Python but using a framework called Flask. So whereas Bootstrap, which you've played with a little bit, is a framework for CSS and JavaScript, they have some dynamic features as well, Flask is a framework for Python that just gives you some library code that you can use freely in your own applications. And it just makes it, ultimately, a little easier to get your work done and build the thing you want to build as opposed to having to reinvent the wheel again and again like people before you. And so here is a methodology to which I alluded earlier just to have a mental model for the coming weeks. So up until now, pretty much every program we've written in C and most recently in Python you could call like controller code or controller logic or business logic. Right. It's all about getting something done logically, usually in one file, maybe two files if you have another helpers.ce or header file or whatnot. But we've been writing logic. But today and two weeks ago when we will focus on web programming in HTML and CSS, there's the second part of our world. There's like the logic that gets the interesting work done with loops, and conditions, and all that. But there's also now going to be the aesthetics, the stuff that the user actually sees and the way you present your data. So we're going to just introduce two letters of an acronym today moving forward. Anytime you start writing logical code in Python, it's going to be called your controller. It's sort of like the machine that operates your entire web application, but anytime you do something more aesthetic, we're going to call that your view code, so C and V being the letters here. And this just refers to a separation of concerns. Your logic goes in this file. And your aesthetics and formatting go in this other file. Next week, we'll introduce databases in SQL, structured query language. And we'll introduce an M here, because the acronym that's in vogue for quite some time now is MVC, though there are alternatives to this mental model. And that just means there are three different types of things you should be thinking about when building an application. But today we're going to focus on these two, controller and view. And up until now, we've pretty much been doing entirely controller stuff when writing code. So the motivation, ultimately, will be to get to the point of building, essentially, this, the freshman intramural sports website, which I was the first one to make back in 1996 as a sophomore, maybe 1997 as a junior, after having only taken CS50 and a follow on class CS51. And even though this is horrifying to see nowadays, underneath the hood was a whole bunch of controller logic and a whole bunch of model code, even though I don't think MVC existed as an acronym back then till humans figured out the pattern. But what it did have via the menu up here was a whole lot of functionality. So no longer did you have to walk across campus filling out a form and drop off a sheet of paper in an RA or a proctor's dorm room. You can instead just go on the web, which all of us surely take for granted today, fill out a webbased form. And then at the time, the proctor in charge of froshims would get an email confirming who had actually registered for a sport. And eventually we added CSV files, comma separated values files like spreadsheets, in which the data was saved. Then we had this really cool tournament bracket thing, which was all very dynamic and impressive I'm sure at the time. But we'll focus on really just the fundamentals today. So how do we get there? Well, let me go ahead and open up CS50 IDE and propose that if we want to make a website, a web application really, and by application I mean something that does have logic. By website, it's generally something that's static. So that's what a web app is. It's something that changes based on who's using it, when you're using it, and what you're doing with it. Let me go ahead, and in the most annoying tedious way possible, implement a web application using Python. So I'm going to go ahead and open a file called serve.pie to serve up a website. And I'm going to go ahead and import some library code. So from HTTP server, import something called base HTTP request handler and also something called HTTP server. And then I'm going to go ahead and use this keyword class, which is HTTP server, server request, request handler, base HTTP request handler handler. Then I'm going to go ahead and in here implement a function called def do_GET, which implies this is a function in Python that should be called anytime a user visits my web server via GET, the type of verb that we've talked about in the context of the web. So suppose that my only goal here is to make a webbased application that for the moment just says hello world. We know how to do this with HTML, but with HTML that's just a file. Let's write a program that not just prints hello world, but generates a web page containing hello world. So the way I might do this is this. I can literally say self, because self refers to the web server in this case. And I can go ahead and send a response code of 200, just kind of presumptuously assuming everything's going to be OK in a moment. Then I'm going to go ahead and send a header, which recall, we've discussed briefly in the past, whereby this header is going to be content type and its value is going to be text HTML, which is a clue to browser that it's receiving not a GIF, or JPEG, or something else, but an actual HTML page. And then I'm going to go ahead and say that's it for the headers. I'm going to call function called end headers. And then lastly, I'm going to use Python code to dynamically generate my website. Now, what does the website have to have? Just hello world at the end of the day, but there's a whole bunch of html we need to do in order to get to that point. So I'm going to use a function called wfile write in order to write out the following. Let me go ahead and write out doctype whoops, exclamation point doctype HTML. Then let me go ahead and do the same thing, wfile.write, let me go ahead and copy paste this moving forward, which, of course, is always a bad instinct. Then let me go ahead and output HTML lang equals en for English. And notice I'm using single quotes inside my double quotes so that Python doesn't get confused. Then let me go ahead and output head tag here. Then what comes after the head tag typically? Yeah, so usually title lately. So title will be like hello title, close the title tag. And now we're going to go ahead and what comes after title? Close head, I think, if I'm doing this right. And then after this we probably have a body. And then oh my God, this is the worst way to build a website. But let's go ahead and now say something simple like hello world. And now let's go in here and say something like body. And then finally, let's go ahead and end the page and say slash HTML. Done. OK, and now I actually need to configure the server to listen on a port. So let me go ahead and define a TCP port of 8080, which we've been using. Let me go ahead and define the server's address as being, oh 0.0.0.0, which is what the IDE uses by default, like a lot of servers. And then let me create the web server, HTTP server. server_address HTTP server request handler, httpd.serve_forever. OK, that is how you make a webbased application that dynamically generates HTML. In retrospect, I really regret typing all of that out because the whole point now is to throw this code away. Like, this is why frameworks exist. If my goal quite simply at hand is to write Python code that dynamically generates HTML, then calling lots of functions like write, which is essentially the equivalent of print in this context, is just tedious. I got bored writing it, I accomplished so terribly little at the end of the day. And so frameworks exist to make our lives easier. But what's going on underneath the hood is exactly this. When we start using this framework called Flask, it's just going to make all of this automated for us. It's going to make it easier to specify the IP address that you want to run your web server on, it's going to make it easier to specify the port number that you want your server to be listening on, and it's going to make it easier to respond to get requests because Flask will take care of the implementation of some function like this one called do get. So all of this is there underneath the hood, but the flask framework gives us essentially an abstraction on top of that. So what do I actually mean by that? If we want to distill this now into a simpler web application, first let's go ahead and do this. Let me go ahead and open up a terminal window and let me go into my code here and go ahead and run Python of serve.py. And you'll see nothing seems to be happening just yet. So I'm going to go to cs50 IDE web server to open up a tab containing the web server that I'm now running. And you'll see that's it. That's the only thing I accomplished right now. It's not dynamic to be sure, but there is code and Python code there with which I could actually do something dynamically. But let's instead do this now with Flask, this framework that seems to make our lives easier. I'm going to go ahead and make a program called application.py, which is just a convention. I could call it anything I want. And I'm going to go ahead and say the following. Let's first go ahead and import this framework called Flask. And specifically import capitalized flask, which is the name of the framework itself. And then let me preemptively import a couple of functions called render template and then this special global variable called request. You would only know to do this from reading the documentation. But now let me go ahead and say, hey Flask, could you please give me a web application? And this is copy paste. You need this at the top of any Flask application, and it just means turn this file application.py into a web application. Then lastly, I'm going to go ahead and do this. I'm going to tell Flask I want to build an app that has a route that's listening for slash inside of that virtual envelope. And whenever, Flask, you see a request for slash from some user, go ahead and call this function which I arbitrarily called index, but I could call it foo, or bar, or whatever. And what I want you to do is this, return hello world. And that's it. So all of those other lines I tediously wrote out a moment ago are now distilled into just 7 lines, which none of which are completely obvious how they work just yet. But if you assume that this means give me access to the library, turned my file into a web application, and listen now for get requests on slash, it kind of makes sense and fits into the mental model that we introduced a couple of weeks ago with HTML and CSS itself. And to run this server, what I'm going to do now in my hello directory, which is where a online copy of this is on the course's website, I'm going to go ahead and quite simply say Flask run. So Flask is not only a framework or code that you have access to as free and open source code, but it's also a program you can run at the command line that also figures out how to turn the server on and just run it forever. You're going to see some diagnostic output at first glance, most of which you don't have to care about. But there will be a few URL that's spit out which is based on your own user name. Mine today is jharvard 3 just for demonstration purposes. And if you click on that URL and then click Open, you'll see now this version of the same application doing just this. Now, I'm kind of cheating, though. Because if I open up Chrome and view my page source, notice that of course I'm cheating because all I've done is print out hello world. And if I view the source of this page, I'm literally only going to say hello world and no actual HTML because I literally didn't type out any HTML in my file. But it turns out that Flask makes this easy, as well. So let me go ahead and stop the server here for just a moment. Controlc is your friend, it gets you out of whatever program is actually running. And let me go ahead and do this. Let me go ahead and not just return quoteunquote hello world as a hardcoded value. Let me go ahead and return the rendering of a template called index.html. And so this is a feature of Flask, too. If you want to separate your logic your controller from your HTML your view you literally put the former in application.pi, and you put the latter in an HTML file like this. And you tell the controller code application.py show the user, to render for the user the index.html file. So where do I put this? The convention would be to make a directory called templates. And then in that directory, go ahead and put a file called index.html. And if I go ahead and open up the file that I already created in advance of class here, let me just show you what this looks like. And then we'll take a look at it in a browser. Here is HTML now with a pretty fancy feature that we're about to reveal the utility of. What jumps out at you is new in this file? AUDIENCE Two curly braces on the name. DAVID MALAN Yeah, two curly braces. And somehow or other that used to be saying world, but in my final version of this I actually am hinting at some more powerful capabilities. This kind of looks like a placeholder, if you will. Maybe someone's actual name. And here's where the power of something like Flask comes into play. It makes it really easy to do something like this. So let me go ahead and actually turn this into something a little more interesting. Let me go into application.py. And before I actually render this HTML file, let me go ahead and do this. Let me go ahead and declare a variable called name. And let me go ahead and check the incoming request, the inside of that virtual envelope. Let me check its arguments or any of the HTTP parameters that were passed in and try to get something called name like this. Let me go ahead and save that and then notice this. Render template takes multiple arguments. The first one should be the name of the template you want to render. But if you want to pass in data dynamically, you can use named parameters in Python. Recall from last week that you can do things like this, x equals y, and z equals w. You can pass in the names of the things you want to pass in and their corresponding values. So if I want to pass in a name variable and set it equal to the name variable that I just defined, watch what we can do here. Let me go back to my console. Let me go ahead and rerun in my hello directory, which is available online, Flask run. And now let me go over to this where it previously said hello world. Let me now, just like with our Google example a couple of weeks ago, type in not q equals cats, which is what we did last time, but maybe name equals David to simulate a get request. And if I did everything right, when I hit Enter I now see this dynamically. And if I change this now from David to, say, Veronica, of course, this is going to dynamically output this. Can someone now try to break my code? Propose an input that I should try to see if I messed up somewhere. AUDIENCE No entry. DAVID MALAN OK, no input. Or what's that? say again? Name equals name, I like that one, too. So let's try that, name equals name. So OK, I mean it's kind of maybe like a grammatical bug or semantic bug, but not really a code bug per se. That's just user error. But what if I just get rid of it? OK, that just looks a little stupid. So an aesthetic bug, but we should probably start handling this. What if I get rid of name altogether? Interesting. It seems that my final version actually has some built in functionality. So where is that coming from? Well, what if I did this? It turns out that I could say something like this. If not name, then go ahead and set name equal to world would be one way of doing it. Or I could actually use the function here. Turns out that this get function can take a default value. And so if you read the documentation, you'll see that the second value you provide will be used if the user hasn't provided one. And so indeed, if I reload now and see nothing, I get world. And if I instead do name equals, say, Brian, I get that dynamic output. And so when I say web application, this is just a hint of what I mean. This is dynamically generated content. It's not hardcoded, because it's actually coming from the user. So when Google implements its slash search web application, this is the kind of thing they're doing. It's way more involved, of course. They're searching a database, looking for cats, and dogs, or whatever it is you're searching for and then generating HTML. But notice with just this simple approach can we ourselves generate any HTML we want dynamically. Because all we have to do in that template called index.html is exactly this. Hello, comma, and then a placeholder where name is the variable you're passing in. And so to be clear, it doesn't have to be called name. I could do something like foo, which would be a little nonsensical. But if I do that, the variable I plug in needs to be called foo here. And so there's a one to one correspondence between the things before the equal signs and where they get plugged in down here. Any questions, then, on this simple example, but building block? Yeah? AUDIENCE [INAUDIBLE] dynamically generated. DAVID MALAN Sure. By dynamically generated, I mean I have not written in advance by typing it out manually a web page that says hello David, or hello Brian, or hello Veronica. Those pages are all generated dynamically based on user input. I wrote most of those pages. I wrote everything up into and after the comma, but then sorry, up to the comma, but then the names are dynamically added. Good question. Other questions? All right. So why don't we rewind to 1997 or so and see if we can't build a more dynamic web application that actually allow students to register for something that's a little more compelling than just providing their name? So let me go ahead and open up froshim0, which is the first larger scale application we have here today. And notice that I have a few files. So already things are going to escalate quickly whereby we're going to suddenly introduce multiple templates, but we'll do this in order to solve a problem. But first let me go ahead and open up application,py, which just like your main function in C is kind of the entry point now to a webbased application. So notice that let's start like this. Let me go ahead and delete that and start from the beginning here. Let's go ahead and do this. In froshim0, we have this default route of slash, and notice that it's going to render index.html. So when you start to read someone else's code, you kind of follow these breadcrumbs. So let me go ahead and open the same folder, froshim0. Let me go into let me go ahead, rather, let's do this from scratch, actually. Let's do this. Index.html, and let me do the familiar doctype HTML. Then let me go ahead and do an HTML tag here, it finishes my thought for me. The head tag here, the title tag here, froshim0 will be the title here. Let me go ahead and create a body. And now for this web page, I want to go ahead and have a few things via which the user can actually register for froshim. So let me go ahead and have just some title text here, like register for froshims like I did back in the day. Then let me go ahead and start a form tag. And then in here, what information might a student want to provide when registering for something like a sports team? AUDIENCE Name. DAVID MALAN OK, the student's name. So input type equals text. The name of this input probably shouldn't be something generic like q, it should probably be more descriptive like name. So its a little weird looking, but name equals name. And we'll go ahead and do this. And if we really want to be fancy, we can do like a placeholder text of name just to in light gray text show the user what we want. And then back in the day, minimally the students registering for sports had to provide their dorm, so the building in which they lived. So in HTML, we've got a bunch of input types. We've got text boxes, turns out there's text areas which are even bigger, check boxes, radio buttons, what's most apt perhaps for choosing your dorm? AUDIENCE Dropdown list. DAVID MALAN Like a dropdown list, otherwise called a menu. But which tag? AUDIENCE Container? DAVID MALAN Not a container, a little more precise than that. With what tag can you generate a dropdown list if you've done this before in HTML? AUDIENCE Select. DAVID MALAN Select. So it's not perfectly clearly named, but it's, indeed, a select menu by name. And so I can actually do this. Select, and the name of this field will be dorm, for instance. And then inside of this I'm going to go ahead and have a few options. So one option might be let's say Apley Court, which is one of the buildings in which freshmen live. There might be another one called Canoday, and then there's going to be bunches of others. And then notice, too, if you've never used a select menu, which you wouldn't have really had occasion to yet unless you've done this before, these options also have to have values, which for my purposes are going to be exactly the same. But whereas what's between the tags is what the human sees, it's what's between these quotes as the value of value that the computer actually sees. So these are the words that populate the dropdown menu, these are the values that actually gets stuffed into the virtual envelope that the student him or herself actually see. So let me go ahead and save this. Let me go ahead and now open up my console. And I'm going to borrow a little code just so that we can do this from scratch here. So let me go ahead and grab from froshim0 my application.py file and go into my workspace. So let me go ahead now and run Flask run wherein I have this application.py file. I'm going to see the URL at which my code now lives. And if I open this up, I'm going to see an internal server error. So intended at some point because internal server error, recall, was one of the more arcane status codes, 500, that you probably have not seen unless you're visiting a website where something has actually going wrong. So how do I begin to figure out what has gone wrong now that I'm actually writing code and not just writing hard coded HTML? Well, all of the clues are going to be found here inside of the console window. So when you're running Flask you are running a full fledged web server. You are listening via TCP/IP for incoming requests from users. And so what you'll see in the console is not just the diagnostic output when you first start Flask, but you're going to see all of the error messages that might actually happen thereafter. And this is a little cryptic looking. Frankly, it's overwhelming to see this text at first glance. But whereas in Clang and in C it generally helps to look at the very top, sometimes the error messages here in this context of Flask are kind of toward the bottom. And here we have template not found. Template because it can't find index.html. And that's just because I screwed up. So let me actually exit Flask by typing controlc. And if I type ls in my directory, notice that I haven't quite practiced what I've preached. It's perhaps a little subtle, but I haven't organized myself in the right way. What have I done wrong? Yeah? AUDIENCE Didn't make a templates directory. DAVID MALAN Yeah, it's kind of a silly mistake. I didn't make a templates directory. So you can do this in a few different ways. By the folder icon up here, you can create a new folder by right clicking or control clicking. Or in Linux you can do make dir for make directory. And so I can do make dir templates enter. And then I can move my index.html file, which I wrote a moment ago, into my templates directory by just using mv for move. And now I can go ahead and run Flask run, cross my fingers, go back to the browser tab and click reload, and voila, now I actually see the form. So have these kinds of instincts. I didn't actually intend that, but I forgot to create the folder. I got this server error. You don't have to just stare at the browser, which is not going to have much information. But if you look at the console, the terminal window that you have control over will you see those clanglike error messages. So here we have a basic HTML form. It's not complete because I didn't bother typing out all of the dorm names, but I do have an input of type text as well as the Select menu. And I'm also kind of missing a key detail, it seems. What should I probably add to this form? AUDIENCE Where you're selecting. DAVID MALAN Well, I'm selecting I could be selecting dorm, so I could clean this up in a couple ways. I also am missing a Submit button. Now, it turns out you could probably hit Enter and it would actually be submitted by default. But we can fix this. So let me go into index.html. Let me shrink this tab just a little bit and let me fix both of these things. So let me go ahead and open up this latest version, which is now in that templates directory. Let me go ahead and at the bottom here do an input type equals submit, the value of which is going to be a register, just to make clear to the human what's going on. Let me go ahead and go back to my form, click reload. And nothing's happened just yet. And that's because by default when you make changes to some of your files, Flask is not going to notice. And we'll fix this actually in the coming problem set by adding more code and a little more complexity to automate this for you. But when in doubt, just controlc to quit flask. Then go ahead and rerun flask, that will reload all of your HTML, all of your Python code. And if I now go back here and click reload, we'll see the Register button. So there should never be any surprises. And if there are, just try to get to the diagnosis thereof. This is also a little unclear, too, to what this menu is. So it turns out that if you actually create a bogus option like this that has no value and say something like dorm, you can save this. Let's go ahead and restart Flask and reload the page here. You'll see that now you see dorm. Unfortunately, this is kind of stupid because now dorm is where you can literally live apparently, which doesn't quite feel right. So there's HTML fixes for this too. I can actually go in here and technically say disabled, so you can't actually select that. Now if I rerun Flask and reload, now it still shows it there. But because I already selected Apley Court, you can see it in gray. And we can actually be a little more specific, if you want to not only disable it, but select it by default and then go ahead and reload the page here, now you'll see hopefully what's familiar on most websites. It says dorm, but it's disabled. And even though the silly checkmark is there, you're forced to choose an actual dorm. So these are minor aesthetics, but the kind of things you now have control over. So what's going to happen? I haven't actually specified where this form should go when I actually register because I'm missing some key details on the form tag. And we haven't done this in a couple of weeks. But when we were playfully reimplementing Google, what else did we add to the form tag? What attributes? Anyone remember? Yeah. Oh, say again? Action, which means what? AUDIENCE What to do. DAVID MALAN What to do. All right, so the action we want to take, even though this is not necessarily perfectly well named, is where do you want to submit the form to? And I could actually submit this in a few different ways. I'm going to go ahead and say, you know what, submit it to a reasonably named route slash register. Google, for instance, might have code that instead says to submit their form to slash search. But we're not searching for something, we're registering. So the name of the route is entirely up to us. And via what method should we submit this information? What are our two options? AUDIENCE Get or post. DAVID MALAN Get or post. Get tends to be the default if you don't mention in links. Why might you want to use post instead? AUDIENCE You want it to go to a database in order to do something. DAVID MALAN Yeah, you want it to go to a database and do something. And the right verb to use there is to post information as opposed to getting information. And even more specifically when it comes to privacy, when you use post, the information doesn't end up in the user's URL, and therefore doesn't end up in his or her history, and therefore doesn't end up in a place that siblings, or roommates, or anyone else can actually see just by poking around. So we'll, indeed, go ahead, because this is my name, and dorm, and maybe my phone number, and email, and credit card number, and the like on some other website. I'm going to use post for that instead. So the catch here is that this week, we now have the ability to implement slash register. Two weeks ago we could just send people to Google's slash search, but now we have the ability to make our own routes. But how many routes have we defined thus far in application.py? Just the one. And again, some new syntax with the funky at sign and the route keyword here. But let me actually just intuitively guess that if I go ahead and say app.route slash register, I bet I could implement a second route and tell the web server to listen in two places, on slash as well as on slash register. But if I wanted to listen specifically on post, it actually has to be this. Methods equals quoteunquote post. Because by default just for convenience, it assumes only gets. So I need to add that. You'd only know that from the documentation. Now I'm going to go ahead and define a function. This is slightly an annoying feature of Flask. You have to give the function a name even though you'll probably never reference it anywhere. So I'm going to go ahead and just reasonably call this register. And now I have a to do. What am I going to want to do when the user clicks that Submit button? AUDIENCE Store it. DAVID MALAN I want to store it somewhere. So I probably want to store it. But what might I want to do first before he or she is actually allowed to register, even though they've clicked that submit form? Maybe confirm their information, right? Because if a lazy user comes in, or if a user accidentally clicks the button or hits enter, they might actually submit nothing no name, no dorm. That's not useful information. It could just be perceived as spam. So we probably want to ask some kind of logical question like if they didn't give us a name or they didn't give us a dorm, yell at the user in some way. So I'm going to go ahead and do that. So let me actually express this in Python, kind of like we did last week with some error checking. So recall that the user's name can be gotten from an HTTP parameter. From the request.args get, and then ask for the name parameter. Their dorm, meanwhile, can come from request.args get dorm. And again, this request.args is something we gave ourselves access to up here when we said, hey Flask, please give me access to the user's request, that virtual envelope. Request.arg refers to all of the HTTP parameters in the URL. And get is just a function or a method built into that special Flask feature that allows us to get a specific parameter like name, or dorm, or anything else. And recall that in Python, what's kind of nice is that you can say pretty Englishlike, if not name or not not dorm, let's go ahead and reprimand the user. For instance, we could say failure because he or she did not actually cooperate as we intended. Otherwise if they did cooperate, I'm going to go ahead and render template success. And we'll flesh this out in just a moment. So I've got two scenarios handled. If they didn't cooperate or if they did, render quoteunquote failure or a full fledged HTML template. So now that I've implemented slash register and I'm listening for a route by a post, let's go ahead and reload the page for good measure. Type in my name. Not going to tell you my dorm, but you're going to notice as much. OK, so now the server has noticed that I didn't actually cooperate and provide both a name and a dorm. And so it's returning to me just quoteunquote failure. So that's good because now I know, all right, I did something wrong clearly. Let me go back let me go ahead and maybe do Canaday here. And now let me go ahead and register. But, but, but, but, this I know in advance is going to err. Why? I don't have a success.html. OK, so let's preemptively address this. Let me actually go in here to my templates directory. I'm going to go ahead and create a new file called success.html. Let me go into the templates to save it there. And you know what, success can be a pretty simple page. And let me open my index page, let me copy that, let me go into success, let me paste this. Let me get rid of all of that body and just say success, for instance. So let me now go ahead and go restart Flask, because I've made a new template. Let me go ahead and reload the form just for good measure. Let me go ahead and give you my name this time, and OK, I live in Canaday, and register. And what did I do wrong this time? So it turns out you can't do it this way, obviously. [LAUGHTER] So when you're actually submitting information to via a form via get, Flask very cleverly puts that information in a different place. Because by definition, as I claim very correctly earlier, in request.args are all of the key value pairs that are in the URL that are coming in from the user's request. But when you submit via post, for reasons I wish were now otherwise you actually have to access those values via a different variable. So instead of using request.args, you have to use request.form both here and here to make clear and this is horribly named for exactly the reasons that I think I'm tripping over here because they actually are both coming in via a form, via a get or post. But Flask puts get arguments in args and puts post arguments in form. Thereby leading clearly to potential confusion. But if I go ahead now and load this version of the site and I keep hoping, I'm going to go ahead now run Flask, restart this page, type in David, give you my dorm, and register and successfully register for froshim. See how easy web programming is? So hopefully now we can at least focus on the structure of what I've done and now begin to improve it. Because notice that I kind of did not practice what I preached a moment ago. What habit did I violate when I whipped up success.html? How did I get to that point? Yeah? AUDIENCE Copy and paste. DAVID MALAN Yeah, I copied and paste. Which again, usually in programming not the right thing to do. Might get the job done super fast, but it's probably the wrong instinct, because it's going to get harder and harder to maintain. Now, why is that? You've played HTML a couple of weeks ago. And recall from that problem set when you had to make a home page, you probably found yourselves copying and pasting across your two, or three, or four pages because you wanted them to kind of look the same. And therefore it made sense for them to have some commonalities. But in HTML alone, there was no way to say use the same layout for my whole site use the same color scheme, the same fonts, the same CSS but just change the body of the page for each individual page. And so some of you very rightly on discourse and beyond like posted questions asking, could you do this? And you can't really in HTML alone. But now that we have access to Python, an actual programming language they can do things logically, now you can actually start to factor those things out, too. And notice in this file, success.html, as well as in index.html, what are some of the commonalities, suffice it to say? The form is only in one of them, but what else is obviously redundant everywhere? The title, the head of the page more generally, the doctype at the very top, the body tag alone. And you could imagine there'd be even more details like from your own home pages that you wanted to be the same across multiple pages. So let's actually take a look at a refactorization of this code, the one I did write in advance in froshim0, and you'll see why it actually makes sense to have not only multiple files, each of which represents one of your routes or your views, but also to have this file called layout.html. In Flask, when building a web application that you know is going to follow a certain structural pattern, commonalities across all of your pages, you can actually do this. So in this file here, layout.html is a whole bunch of hardcoded HTML. And it's pretty simple. It's got my HTML tag, head tag, title tag, body tag, and a few other things, but that's the general structure of the page. And notice it has this funky syntax in the middle. In white here is what's called the block. This is now Flask specific. Just like Flask supports those two curly braces on the left and the right that says put a value here, flask also supports this other notation, curly brace percent and percent curly brace that actually allows you to put placeholders for actual chunks of HTML. Not just variables, but actual chunks of HTML. And so this layout you can think of as a mold or a template literally that all of your other pages are going to be structured based on, but they are going to vary in this line and only this line. And we're going to put as much HTML between the body tags as we want, the open and the close tag. This just indicates to Flask this is the stuff that should be changing. So if I now look at my index.html, which recall earlier contained my form index.html. Notice that here's the form, and I finished it earlier. I went ahead and typed out all of the freshman dorms, not just the two of them. And you'll see that the file starts almost the same and then continues with more stuff. But notice what's missing from index.html this time. No doctype. No HTML tag. No head tag, no title tag, no body tag. All of the common stuff has been factored out. But there's some funky new syntax that, again, is Flask specific. This first line is the link between this file and the layout. That first line says, hey Flask, this index.html file extends the definition of layout.html. So it says grab that template and plug myself in there. What do you want to plug in? The same syntax here. When you actually put stuff between the block tag and the end block tag, which is down below, that's when you say to Flask, go ahead and take this stuff and plug it into the placeholder in the layout. So meanwhile, the success page also now can be a little more sophisticated. If I go into success, it's not very complicated. And honestly, it doesn't even look like HTML anymore because we're using these more dynamic features. But this just says, hey Flask, use the same layout so the page is structured exactly the same. But for the body, go ahead and plug in this value instead. So indeed, when you go ahead and load this success message, you see this message here not just success, I expounded here and said you are registered. Well, not really, that's because there's no database yet. But that's going to generate a full fledged HTML page. And what about failure? Before I was just cheating and just saying return failure, quoteunquote, no HTML at all. The failure page is going to be almost the same, but now I can actually provide some descriptive text. This body just says you must provide your name and dorm, thereby admonishing the user for not having cooperated properly. So now your home pages, if you kind of extrapolate from this, could have the exact same layout, aesthetics and menu bars, and all of that fanciness, but only the content would have to change. And you can get out of the business of just copying and pasting. So there, too, to your question earlier about dynamism, the dynamism doesn't have to just come from the user. It can also come from the construction dynamically of a website based on multiple pages. So at the end of the day, the browser has no idea that Python exists, has no familiarity with Flask. All the browser still sees is an HTML page. But what Flask and in turn Python are doing for us is constructing that page dynamically, following the rules from two weeks to go in HTML and CSS, and following last week's rules on how Python works. Questions? AUDIENCE So even though [INAUDIBLE] DAVID MALAN It's not. Good question. This new syntax, the double curly braces that we saw earlier and now the curly brace percent signs, this is actually yet another language called jinja JINJA which is a templating language. And there's dozens of these things in the world, people just come up with their own syntax. And the reason for the funky syntax is that the author of jinja presumably could think of no other language that uses like a curly brace and a percent sign and a percent sign and a curly brace. And so therefore they decided, you know what, I'm going to use this syntax because it will look distinct from HTML, and CSS, and Python So that frameworks like Flask don't confuse it with something else. AUDIENCE So do you have to upload that into [INAUDIBLE],, or is it automatic? DAVID MALAN It's automatically supported. So Flask by default supports jinja. It could have come up with its own templating syntax. But whoever invented Flask decided I don't need to reinvent this wheel, someone else already made a templating language that gives me this functionality. So I'm going to combine our works into one. And I didn't call it a language a moment ago, because frankly, HTML, CSS, Python, JavaScript I mean, we're already running out of fingers here. But jinja is, indeed, yet another language. It's just not a programming language per se, though it will have some control flow features that we'll see in a little bit. It's just much more limited than Python. Other questions? AUDIENCE Is it possible to combine the success and failure HTML files into one just for better design? DAVID MALAN Good question. Could you combine the success and the failure pages into one? Short answer, yes. And let me not show it yet, because it'll get a little more complicated. But yes, I could imagine passing a variable in that's a Boolean true or false into just one of these templates. And maybe I call the new template result.html. I can actually then have an if condition in my template that says if the result is true, say this. Else if the result is false, say this other thing. So you could do that, yes. Generally, though, it's probably cleaner to keep messaging separate if they functionally do something else. After all, these files are pretty small anyway. Yeah? AUDIENCE Just for question, what does the user see if they were to open up the debugging console on Chrome and look at at it, what do they see as the HTML that shows up? DAVID MALAN Really good question. What does the user see? We can answer this by just literally opening Chrome and opening View Page Source or the Inspector. This is what the browser sees. So when I claimed earlier that the browser has no idea of Python or Flask are even involved, that is, indeed, true. Because what browser's receiving at the end of the day is just this, the dynamically constructed HTML. Good question. Yeah? AUDIENCE [INAUDIBLE] can you also put Python code in there, or is it just HTML? Good question. We'll see more of this in just a little bit. The question is, can you between the curly brace and percent signs put actual Python code? You can put stuff that looks like Python code, but not all of Python. And so more of that in a bit. AUDIENCE Is there a function call or something like that? DAVID MALAN Only certain functions. Templating languages, long story short, are sandbox so that they are not as expressive as a real programming language. Otherwise you are vulnerable to potential hacks. You want their functionality to be very limited because they're only about displaying data, not about thinking or doing logic generally. More on that in a bit. All right, that was a lot all at once. Let's take a five minute break here, turn on some music, come back, and we'll make this act better. All right, we are back. So to recap where froshim0 left off, we now have this structure which is pretty much conventional. Any web application we make here on out is going to follow this pattern of having an application.py entry point where all the interesting stuff starts, a layout.html file in your templates directory that lays out the whole site and any commonalities, and then one or more other pages that actually represent your individual views that correspond to one or more of your actual routes. So now we're at the point of a stable baseline, but had we dived in right to this, it would perhaps not make as much sense as to why we did this various factorization. So let's now improve this. Because of course, if you look at success.html, it just claims you are registered. Well, not really. Because in application.py, did we do anything with the user's information? No. We just checked, did they give us information? And if so, we claim success. Else if they missed their name and/or their dorm, we just claimed failure. So what might a data structure be in Python where we could store registrants? We don't have databases yet, we don't have SQL yet. That's a week ahead. AUDIENCE Array. DAVID MALAN Yeah, we could use an array, otherwise known as a list in Python. So let me propose how we might do this. Let me actually open up froshims1 for our second iteration of this program. And in application.py, notice this. At the very top of the file, not only am I creating my application using the same line as before, and I've commented things this time in advance using the hash symbol, notice that I claim that on line 6 and 7 here, here is an empty list for all of the students who have registered. This way we can keep the information around. And we only did this briefly last time, but does anyone remember how you add something to a list in Python? By what function? Append. So if you have .append at the end of a list's name, you can add something to it. So where is that going to go? Well, here is my route for slash, implies, again, get by default. That's the default route that a human might get, and they are going to see index.html, which contains that form. If I scroll down now, you'll see that I have a register route just like before. But I'm doing one additional step. Which is the new line here, to be clear? Yeah, 26. So I could implement this in any number of ways. But the key detail is that I reference the list name students, but I could have called it anything. .append, as someone proposed, is how you add something to the end of the list. And then I can add anything I want. To keep it simple, I'm just going to add a string. And I'm going to keep it super simple and just say the string is soandso from such and such a dorm. So David from Matthews Hall, or Brian from wherever. And so here we have placeholders using f strings in Python. So this has nothing to do with Flask, this has nothing to do with jinja or anything we just talked about. This has to do everything with last week's syntax in Python alone. So this appends to that list this name from this dorm. So let's go ahead now and try this version out. If I go into my source sub and directory for today's code into froshims1 and run flask run, we'll see a URL that I can now visit. Let me go ahead and open that for froshims1. Notice that I have that complete dropdown now. Let me go ahead and say David, but I'm not going to tell you my dorm yet and try to register. Now I see a more friendly message, not just failure. And that's because of my new and improved template. OK, I'll go ahead and be David, and I'll be from Matthews here. Let me go ahead and register and voila. Now we see David from Matthews has registered. And it seems to be all of a sudden in the form of a new bulleted list. But where did that actually come from? Well, I don't know. Let me try this again. Let me go back to slash, which is the route that gives me the form. Let me go ahead and type in not David this time, but say, Brian. And Brian, which dorm are you in? AUDIENCE Pennypacker. DAVID MALAN Pennypacker. So let me choose this from the menu instead and click Register. And now we see Brian from Pennypacker. So somehow the application is changing state, and notice the URL that we're at is called slash registrants. So that seems to be a third route this time that apparently is not interactive per se, it just spits out the list of registered students. So let's just put the proverbial engineering hat on. If we go about implementing this slash registrants route, logically what must that code be doing in verbal pseudocode, if you will? AUDIENCE A for loop? DAVID MALAN Like a for loop, iterating over what? AUDIENCE In the list that saves all the registrants. DAVID MALAN Yeah. Iterating over the list of students which contains all of those registrants. And the template, meanwhile, probably has like an LI tag for list item and a UL tag for unordered list, which gives me the bulleted list. So let's take a look at that. So how do we follow these breadcrumbs? Well, if I scroll up in application.py, we'll see a route called slash registrants. And you'll see that all it does apparently is it returns a template called registered.html, where registered.html is probably a template that is generating that list. But there's something different this time. I'm passing in an argument. And we saw this earlier. When I wanted to pass in name equals David or name equals Brian, I just grabbed that from a variable. This time I'm not doing request.args, I'm not doing request.form. Because what is students? Where did this come from? That's the list from higher up. Recall that we have this global variable at the top of the program, students, which is initialized to an empty list. But recall that we keep appending to it in my register route. So I can go ahead and say, you know what? Go ahead and pass into register.html a template or rather, a list called students whose value is exactly that. And again, it's stupid looking that you have the same word on the left and the right of the variable name. You could do this differently. Again, you could say foo, you could say x, or y, or anything. But frankly, it tends to make most sense, just pass in the same name as the variable that you care about so that the template can see exactly that. So what's the next breadcrumb? If I want to understand exactly what is happening, what file should I open up next perhaps? Probably register.html. So let's go in there. It's in my templates directory by definition, and you'll see, indeed, a failure message which allows me to error check. Index, which contains the form; layout, which contains the overall structure; and finally, registered.html. And now we can answer the question that you asked earlier about Python code in the template. So this one looks more advanced than before, but notice it follows a pattern. Register.html extends that same layout. So it borrows from that same mold, so it looks the same. The body of this page, though, is just this snippet of HTML. Give me an unordered list, open and closed, and this is what you can do now with jinja. Again, it's almost identical to Python, so you don't have to worry about thinking about learning yet another language. It's just a subset of Python essentially. So if I want to output in the list of all of the students, I use my jinja syntax here, my template syntax with curly brace percent. And I say for student and students. Just like in Python, that induces an iteration over that list. And then what do I want to output? Well, we can borrow our curly braces from our name example and just do list item, plug in the name of the student, close list item. And then endfor. So this is the one stupid thing with the templates. Whereas in Python proper, recall that you can just say for student in students, you have a colon and then indentation handles everything. The problem with that in the world of HTML is that browsers recall ignore all whitespace, like whitespace has no special significance, but in Python it does. So the way people solve this is you literally, if a little weirdly, say endfor one word, no space. And that's it. And indentation helps you read something like this. So what is the HTML I'm getting back? I can actually look at this. Let me go ahead and view page source in Chrome, and you'll see it's not quite as pretty as might be ideal because there's a lot of whitespace which comes from those templates from my having pretty printed those, as well. But this is syntactically correct, and I'm dynamically putting this part inside of this layout. Any questions, then, on this? AUDIENCE So if we restart the server, whatever's stored in the list, that goes away, right? DAVID MALAN Good question. Let's kill Flask with controlc. Let's rerun the server. And let me go back to my registrants route and reload. And sadly, yes, this is not the best way to register students for a sport. Because if the server ever goes offline, loses power, you hit controlc, you obviously, indeed, lose everyone. And notice, too, even though we've generally frowned upon using global variables, which this students list indeed is, why did I define it up here in line 7 and not, for instance, in my register route here? Because indeed, I'm appending to the list here. But I very deliberately did not declare the list there. Yeah? AUDIENCE You're using it in other parts. DAVID MALAN I'm using it elsewhere in my other routes, the registrants route. And also even more to the point, if I declared a list here, it becomes by definition a local variable. Which means as soon as this function exits, now I've just thrown away those students who register immediately not even after a controlc. So this was a better approach to do it, but it's not what I did way back in my day. I actually did something that was a little fancier. So at the time, I didn't really know at least in, what, 1997 anything about databases. I don't think I even knew about CSV files just yet, or at least how to create them dynamically. So I instead took this approach. Let me go into froshims2, and it has noticed the same templates as before. And indeed, I pretty much copied and pasted for this second example. But in application.py, notice this fanciness. So here I have almost the same thing up top in terms of Flask, but I'm also using this OS library, more on that in a bit. But what about line 2? It's subtle, but I rattled this acronym off I think just once weeks ago, SMTP. Does anyone know what that stands for? AUDIENCE Simple mail transfer protocol? DAVID MALAN Yeah, simple mail transfer protocol email, that is. So Python comes with built in functionality via which you can send emails, and this is exactly what I did when I first made this website. Didn't know anything about databases, I didn't know anything about saving things to files just yet, I was still learning. But I didn't realize, hm, I could use programming to send an email to the proctor or the RA who was overseeing the sports program so that they could just save it in a folder and know who had registered. It's not super user friendly, but it at least got the job done because they were then able to track everything. So in this program, notice that I have my route for my form. And I have this register route but a few new lines of code. And you would only know how to do this by reading the documentation. But in this case here, notice what I'm doing in my register route. I'm first getting the user's name and their email this time and their dorm. Then I'm error checking. If they didn't give me a name, or their email, or the dorm, render failure.html to apprise them as much. Then go ahead and do these lines of code. And this is more of a mouthful, and you would only, again, know this from the documentation. But it turns out if you read the documentation for this SMTP lib or library, you can use lines of code like this as follows. You can tell the library what server to use for sending email. And it turns out if you read Gmail's documentation, you can use smtp.gmail.com to automatically send emails not using the web UI, but using code. 587 is the TCP port that they use. So it's not 80, it's not 443, it's 587 by convention. Starttls, if you read the documentation, says turn on encryption. So the email is encrypted between you and Gmail. Then go ahead and log in with a certain username and password. I created an account in advance called jharvard@cs50.net, and my password is in my IDE's environment. I stored it elsewhere so that it's not visible on screen, otherwise people could send emails as John. Then I go ahead and call literally a function called send mail. And if you read the documentation, this one takes as argument who you want to send email to, the contents of the email that you want to send, and the message that you actually want to send here. Or rather, this is the from address, the to address, and the actual message that you want to send. After that, you just go ahead and render template and assume success. I could add more error checking, like I should probably check if anything went wrong here, but I'm keeping it simple. But these new lines that are highlighted actually send an email. So let's try this. Let me go into froshims2 and let me go ahead and do Flask run. Let me go ahead and open up the page here, slash. And notice I do, indeed, have a second field for text now. So this will be David, and this will be let's see, how about let's go ahead and just register not myself, since it's not my email account, but John Harvard who we claim's email is cs50.net, jharvard thereat. And he lives in say, Weld. Let's go ahead and click Register. All right, it's taking a little longer this time, but it was doing a little more work sending an email. So now let's try to go to gmail.com, open this up. Ooh. In my inbox, you are registered. If I open this up, notice jharvard@cs50.net has sent me an email by a BC seed, at least keep part of the information private. And it just says in the body of the message if I move the cursor, you are registered. So I did a little more back in 1997, but I included like the user's name, and their email address, and their dorm, and maybe their phone number or whatnot, and the sports they were interested in. But the idea is exactly that. You can send any information you want just by now using code. You could not do that with HTML or with CSS alone. Any questions, then, on this? Yeah? AUDIENCE Last week when we wrote code in Python we had to like say if name equals the function to like execute that. How come in this we're not doing that? DAVID MALAN That was all in JavaScript. So that allusion to if name equals, and then you assign it to a function, I think you're referring to our JavaScript examples, no? OK. So we'll actually come back to that in a little bit where we reintroduce a bit of JavaScript, which actually gives us some more functionality reminiscent of those examples. Other question? AUDIENCE What email address did you send that email from, and don't you need to enter like a password to make sure that no one just randomly sends email? DAVID MALAN Yeah, it's a really good question. So via what email address did I send that, and to whom was it sent? So again, this is the from address, this is the to address, and this is now the message. And just because I only have one email account open, I had John send himself an email in this case. Theoretically if I were running the freshmen intramural sports program, I could try to do this and change this from address to be myself. The catch is that Gmail actually has protections in place so that if you've logged in as jharvard with his password, then the email, no matter what you specify as the from address, is actually going to be overridden to be from John Harvard. However, this does speak to the potential insecurity of email. If you don't use Gmail but you use a third party service that is not so rigorous with its error checking, it is incredibly easy to fake emails from one person to another. I mean, look through your spam folder sometime. Most of those people who send you those spams don't exist. Like, the email addresses and/or the names are fake. And yet they might appear to actually be from a sibling of yours, a family member, or a friend, even though those humans did not send emails. And that's because some spammer has written code like this in Python or some other language, but has overridden these fields, but used a server that's not Gmail that doesn't enforce these policies. Other questions? Fun fact, also in 1995, I learned how to send or how to change the from address on an email. And turns out at Harvard there's this entity called the ad board who doesn't like doing this. So don't do that. Sometimes there's human defenses in place for this, not just technological. Thankfully, my friend whom I faked an email from did not it worked out OK. All right. You have now great power, don't use it for evil. All right, so let's go ahead now and do another example, but that takes this a further step, adding, finally some persistence of information. Let's go ahead into froshims3 now and open up application.py. So recall that we can use CSV files comma separated value files to create the illusion of like spreadsheets, but now we're actually going to create them ourselves. The code for this is a little more involved, and the only thing I've changed now really is the register method. So in version one of this code, I saved it in a global list just in memory. That was not good because it gets thrown away too easily. Version two of this we just sent an email to the proctor who runs the program. That was a little better, because at least they can then save the email. Version three, we're going to use a very lightweight database called the CSV file that saves it to my hard drive permanently. So even when the server stops, the data is still there. So in Python, how does this work? Well, notice that I've improved my register route this time as follows. If the user did not give me their name or dorm, then I go ahead and render a failure. That's pretty much the same logic as before, but I didn't bother declaring the variables this time, I just called the functions directly. Here's a new line of code that might be reminiscent of some of your past file I/O code. In line 16 here, I'm telling Python to go ahead and open a file called registered.csv quoteunquote a. So we've seen R, we've seen W for read and write. Anyone recall what a is, or no? AUDIENCE Append. DAVID MALAN It happens to mean append, which means just add a row to the file, which is nice. Because if there's already students registered, when a new one registers we just want to append to the bottom of the file. Quoteunquote a is supported by Python with this open function. That gives me back a reference or like a pointer to file, even though Python does not have pointers. Then this is the new feature. And here, too, you'd only know this from having seen an example or you reading the documentation. You can use the CSV library, which we'll see as imported up above. And you can ask for a writer, a piece of code that writes out that is, creates CSV files. And specifically, you want to write to this file. That library the CSV library comes with a function called write row, which does what it says. If you pass it in a comma separated list of fields that you want to represent your first column, your second column, and your third column, it will handle the writing for you so you don't have to get into the weeds of file I/O like you did several problem sets ago. Notice the subtlety. You do need to have these second pair of parentheses, because technically what you're giving it is a tuple. We talked very briefly about that last week, which is just like an x comma y pair, or latitude comma longitude. Same idea here. First column, second column, and so forth is a socalled tuple. Then I close the file, then I render the template. So what does this actually do for me? Well, let me go into my folder froshims3 here. And notice register.csv at the moment is empty. This is a CSV file. Nothing's going on inside of that. There's no one registered yet. But let me go ahead, then, and go into froshims3, run Flask run. Let me go ahead and load this up. And you'll see the same kind of form, but also a new link. Notice that no one's registered yet if I click on that link. But if I go into here and register David from Matthews and click Register, now it claims I am registered really. Let me click this link and notice that it's very small on the screen, but slash registered is where this is going to lead me, which is just where I was before. You see that now David from Matthews registered. Let me go back to the form itself. Let's register, say, Brian from Pennypacker. Click Register. He, too, is apparently registered. Let's click that link. Brian from Pennypacker. All right, so where is this data going? Let me go back to the IDE, close my registered CSV file, because it's probably changed and open it up. And voila, indeed, it's prompting me to reload it. There is the file. And notice David comma Matthews, Brian comma Pennypacker, all of those rows were written out for me. So now I actually have a database. And even though it's kind of a simple database, you know what I can do? Let me go ahead and right click or control click on it in the IDE, download it into my Downloads folder. And then if I actually open this thing, if I have Excel installed or Apple Numbers, which is the first time I've ever used it, let me go ahead and open that file. Opening register.csv. And voila, here now is a file. And Numbers is formatting it in kind of a funky way, but it is showing rows and columns. Those of you who are more familiar with Excel we can do that, too. Let me go down here. Let me go into my Downloads folder. Control click or right click here, and this time open it with Microsoft Excel. And if you've seen Excel before, we'll probably see a very similar UI. Because anytime Excel or Numbers OK, first time I've used Excel. So that, too, will open up some rows and columns, as well. So CSV files are just very lightweight spreadsheets. But what's cool about them is that you can create them so easily. You just have to put commas in there. Now, as an aside, can you contrive a user's input that could potentially break a CSV file? What could a human type in that could potentially break your own CSV files? A comma, right? If it's like David Mayland comma junior, or something like that. Or anything with weird punctuation. This is why you use libraries. That CSV library in this code, which we're importing at the very top of this version 3 of the code, is actually handling all of that complexity for us. When the library encounters David Mayland comma junior if that's the user's input, it will then additionally put quotes around my whole name, thereby making sure that my comma is inside quotes and not, therefore, confused with the special comma that demarcates the start of other columns. So again, that's why you don't reinvent the wheel, because corner cases like that arise. Well, what about slash registered, which is this list that's generating an unordered list? Let's see how that works. If I scroll down to this code, notice that it's not just a simple matter of grabbing a global variable, because there is no global variable anymore. Now I have to read it from that CSV file. So here's three new lines of code that work as follows. I'm going to go ahead and open this file, register.csv, in Read mode this time, not append. I'm going to go ahead now and say hey Python, use the CSV reader which is the opposite of writer on that file. And then, hey Python, go ahead and turn that whole reader into a list. So you'd only know this from reading the documentation. It turns out this is the recommendation. If you want to take a reader and just read the whole thing into memory at once and convert it to a Python list, you literally just pass it to this list function. That gives me a list I'm going to call students, and then I can do my same code as before. For good measure, I should probably do what I did last time, which is file.close to close the file, as well, just to make sure it's closed the next time it's opened. But I can actually simplify this, and you'll see more of these examples online. It's actually more conventional in Python not to do this, but instead to change your code as follows. To not bother closing it explicitly, to instead use a keyword called with to instead put the variable name back there and indent everything underneath. Doesn't matter for our purposes which one you do. The first one was correct. The second one is correct. This is just more conventional, if only because it handles the closing of the file for you. So if you see this online, that's all that's happening there. But it's just like in C doing fopen and fclose, or in this case open and close like I had a moment ago. Any questions, then? AUDIENCE How would you handle duplicates? DAVID MALAN How would I duplicates? good question. So haven't handled duplicates here at all, and David from Matthews could register again and again. But logically what might I do? Well, it probably belongs here in my register route. I probably want to do more error checking than just these two lines. Because what I probably want to do to see if David from Matthews is already registered is open the CSV file, iterate over its lines looking for David and for Matthews on the same line and then show a failure to the user if he or she is trying to register for a second time. I've not made it easy with this code, and frankly that's going to be so much easier next week with SQL. SQL, this other language for databases, will make it easy to search data that has already been saved. CSV files do not make this easy. It's doable, but you have to write more lines of code. So more on that to come. Other questions? All right, so let's skip ahead to one final example, froshim6, which we'll do something a little more for us here. So if I go ahead into froshim6, notice that if I do Flask run, and go back to the website here, and reload the screen, and I go ahead and give you my name, but no, I'm not going to give you my dorm, we have this feature. It's ugly again, but where did we see this kind of functionality when the user does not cooperate? Or how did I implement this, apparently? AUDIENCE JavaScript? DAVID MALAN Yeah, JavaScript. So it turns out that with Python, you can obviously validate the user's input on the server by just checking what's in request.args or request.form and then yell at the user success or failure accordingly. But you can also use JavaScript and honestly, we did this two weeks ago, so we just seem to be solving the same problems again. So how do you think about this? Should I be checking for the user's name and dorm in JavaScript? Should I be checking for the user's name and dorm on the server? I mean, mixed messages now. AUDIENCE Whatever's fastest. DAVID MALAN Whatever fastest. That's a pretty good heuristic to use, what's fastest. And we can make it prettier by using Bootstrap or some library to give you like a colorful box, or red error text or something like that. So which probably is faster, Python or JavaScript? AUDIENCE JavaScript. DAVID MALAN JavaScript. Why, is JavaScript just a better, faster language? AUDIENCE You're not creating it [INAUDIBLE] DAVID MALAN Say again? AUDIENCE You're not creating it on a new server, so it's all happening on the same DAVID MALAN That's why, yeah. We don't have to get into the religious debate of which language is better or faster, but where they're running is certainly important. JavaScript is running, recall, by definition, in the browser. It is sent as JavaScript code to the browser which then executes it client side. Python by definition today is doing everything server side. And indeed, the browser doesn't even know Python is involved, because all it gets is the HTML code that results. So OK, that seems to be an argument for not doing all of the new work we did today with if not name, if not dorm, and all of that, and just use JavaScript. But the problem is that if you get a little sloppy or a little clever and only implement your error checking client side. Because as you say, it's faster, and frankly once I make it prettier, it's just going to be more interactive and more seamless. The problem is you can't and should not trust users. Suppose that I'm a malicious user and I just want to inject some bogus data into your website, or I want to spam you, or subscribe 1,000 freshmen who don't actually exist, or just generally create problems for you. Well, you might think, well, that's OK, I have some defenses in place, and JavaScript code, and this adversary is going to get very quick feedback, very pretty feedback that they've not provided these various fields. But honestly, you can't trust anything ever coming from the human. If I open up Chrome's developer tools, and I go to this down here to the dot dot dot menu, and I go to Settings, and I go down here, there. That's all it takes to disable all of your hard work. He or she can just open up their browser Chrome or something else turn off JavaScript. So now when I actually submit this form, there's going to be no onsubmit checking, no onclick handling. All of that is disabled. So if I go ahead and click Register, I at least still, in this version of froshims, have server side checking, as well. So this might be a little frustrating, but it's kind of the reality. It is perfectly fine to use JavaScript code and use client side code to give the user a better experience a.k.a. UX, user experience. But you can't cut corners and not implement the same kind of logic server side because you need to defend against this. Otherwise bogus data is going to end up in your database, things are going to go wrong. Never, ever, ever trust the user. Any questions? AUDIENCE Can you do the same via CSS? DAVID MALAN Can you do the same with CSS? AUDIENCE Yes, can you [INAUDIBLE] JavaScript [INAUDIBLE]?? DAVID MALAN Not with CSS alone. You can use CSS to make the error messages far prettier, yes, but not logically enough with CSS alone. And in fact, just to give you a sense now how you can make things prettier since I keep alluding to better design skills than the ones I'm showing here. If we go to Bootstrap, this very popular, free, and open source library for CSS, it actually has some interactive features, as well. And if I go under components in the documentation and I scroll down and I go to forms, you'll see, one, notice that these forms are already way prettier than the ones I've been making, right? It's like black text, and gray text, and small text. It just looks nicer and cleaner. But it's relatively easy to do this. And indeed, for the next problems that you'll be welcome to copy and paste some of this sample code and HTML, use Bootstrap CSS just to make your forms prettier. But what it can really do if I go to the sub menu over here, notice that there's this validation section in Bootstrap. And other libraries have this, too. And you'll want to read the actual documentation. But if I just scroll down for a while, here's a sample form in Bootstrap. It already looks a little prettier than anything I've made in just raw HTML. But notice if I don't cooperate, you can do really cool validation of forms with green and red text if the user does or doesn't cooperate by using a mix of CSS, but with some JavaScript code. And so what Bootstrap does for you is it actually automates some of the process of that JavaScript code that we saw two weeks ago and just used now. But it doesn't just pop up a message for the user, it actually gives them more immediate feedback. And almost any popular web site you visit these days gives you this more immediate proximal input. Generally you don't see some simple error message popping up, even though that's easier to do. Any questions? All right, so where did that logic come from? So let me go into, for instance, my template file now for the form in froshim6 again, the last of these examples and you'll notice that I did this. If I scroll through this file, you'll see the same HTML as we've been using for some time. But notice at the bottom of the page that I draw some inspiration from two weeks back when we looked at HTML, and CSS, and JavaScript. So just as a quick refresher, notice how this is working. This line of code says in JavaScript check the document using the query selector, which lets you select anything in the web page looking for a form. When that form is submitted, call the following anonymous function. If the document query selector finds an input that does not have a value and I say not because of the exclamation point here then yell at the user with this, you must provide your name and return false. Else if the user did not provide a value for the select menu a.k.a. the dorm go ahead and alert them that they must provide the dorm, otherwise return true. And just to be clear and to recall from two weeks ago, what am I returning false? What does that effect have logically? Yeah, say again? What was that? I heard a whisper here. No? Yeah, it prevents submission of the form. The default behavior of a form is it wants to be submitted. That's why they exist. But if you return false in JavaScript, it will short circuit that and prevent that default behavior, thereby stopping the user from submitting the form at all. So let's take one step back now, there's now so much going on in this one file alone. In this sixth and final example, notice that we have application.py, which is the entry point, the socalled controller of this web application. It has a route which very simply for slash looks like this. When the user gets slash, this template is simply returned. What is in that index.html template? Well, it contains a partial HTML file. It contains this HTML. But it does not contain the doctype, the HTML tag, head tag, the body tag, the title tag, and all of that. It only contains the stuff that should go inside of the body tag. Because this file is using a bit of jinja, which is the templating language that Flask uses. You can just think of it as Flask, that's fine. It uses some HTML here, but it also in the bottom of the file uses JavaScript. And so just as before when we've looked at the source of the page, what I'm going to see in the browser on this forms page is no jinja, no Python, nothing related to Flask. Just a fully formed HTML page that also now contains some of that client side code. And so I have this mixture now of several different language, but each of which solves a very distinct problem. Yeah? AUDIENCE So I think it was a week ago or two weeks ago when we were working on JavaScript and CSS, you were saying that it's preferable to split languages, not mix them in the same document. Right now we are mixing multiple languages. DAVID MALAN Really good observation. So a couple of weeks ago I really preached the separation of concerns, and therefore separation of files. And that's why we introduced a .css file, we also briefly showed examples of a .js file. The short answer is as your applications get more complex, life starts to get messy. And the team and I were actually talking about this earlier as to how to present some of these examples, because what you are seeing in my design decision here is a tension. So that tension here is as follows. It is not necessarily the best practice to just have your logical JavaScript code comingled with your HTML. It makes it harder to collaborate with someone else. If one of you is really good at design and wants to work on the HTML and CSS, the other person really wants to do the JavaScript code, kind of hard to do that when they're both in the same file. So we could factor this out. I could change this line, just to be super clear, to be this. Instead of putting my actual code in the file, I could do something like this. The source of this shall be form.js, and that is just it. And then I have a separate file maybe my colleague works in as follows. But at some point the thoughts that go through my head are, it's only like 10 lines of code and I just have to create a second file now, and that second file is going to be maybe in a different folder as my template. And you know, it feels like this is just overengineering a solution to the problem. However, once it's 20 lines, 100 lines, now OK, now it's feeling messy. Somewhere there's this inflection point. And this is where reasonable people will disagree, and I might argue one way, you might argue the other way. And honestly, both of us are probably right. And so this just speaks to the web's development over time. And there's fancier frameworks now. and if we tie things earlier into the question about CS50 beyond, an opportunity after this class that looks more closely at web programming, there are even fancier frameworks nowadays than Flask and than Bootstrap that if tried to solve this problem. React is one of the most popular ones developed by Facebook, now open source and used by so many people around the world that actually addresses this issue. And it allows you to separate your HTML from your CSS from your JavaScript in different parts of the file but still in the same file. And that was their particular solution. And View and Angular, there are so many different solutions to these problems. And unfortunately, once we take the training wheels of CS50 off, this is what's ahead of you. The world is messy. And the reason there are so many darn languages and frameworks is because people like you have these instincts and think, this could be done better. And thus do we iterate and have new and new technologies. But this is the kind of stuff and honestly, this is the kind of silliness that changes over time. The fundamentals of HTTP, and client side code, and JavaScript code, those fundamentals are invariant even as the implementation details change. So the short answer is, could this be better? Probably. Could it be much better? I don't know. It really now becomes more of a debate among developers. Good question. All right, so let's now use some of these basic building blocks to make a final set of examples that demonstrates a feature with which most of us are pretty familiar reminiscent of what we did two weeks ago with Google Search. At the time we searched for cats. Today we'll keep it a little simpler and a little less graphical and just search for words. Because you'll recall from our speller problem set, you implemented a spell checker with 140,000 plus English words. That's a pretty juicy dataset to search over, and you're probably all familiar with autocomplete these days. There's hardly a website these days that when you start typing it doesn't try to finish your thought for you. Google, Facebook, any a number of other sites. So autocomplete, how does that work? Well, let me propose the following mental model. If you do have some data set like a big list of words, or a big list of Facebook friends, or a big list of whatever, you might store that server side because it's a lot, a lot of data. And in fact, next week you might store in a big database. But for today we'll just store it in a file like we did for the speller piece set. But if you want to create an interactive experience for the human, what language are you're probably going to want to use so that he or she gets immediate feedback? Probably JavaScript, right? That's the whole principle. Client side code is just going to execute faster because there's no internet between you and the code. But with Python, you have access to files. And yet with JavaScript code you have closer access to the user, so there's these tensions. So how could we go about building a site that lets a human via form search across that file for words? Well, let's start as follows. So in word 0 we have the following. Large, which is just a text file borrowed from the speller problem set, 140,000 words, one poor line therein. I'm not even going to double click and open it because it's so darn big it'll take a few seconds to open. In application.py we have probably the entry point to this application, and in templates we have just three templates this time. So just when you're reading someone else's code for the first time, where should our entry point be? Where should we start looking to understand what's going on? Maybe application.py. Or honestly, you know what? If you want to see what something does, run it. No harm in doing that. So lets run Flask run. Make this a little bit bigger. Let me open up the URL here, open, and I see a very simple form asking me for a query. Let me go ahead and search for a and click Search. And after a moment, OK. This is a lot of words, but apparently these are all the English words that our dictionary knows about that start with the letter a. And if I go all the way to the bottom, you'll see it stops with az whatever with no B words, in fact. Well, let's make sure this actually works and isn't just a trick. Let's search for b words. OK, so that seems to work, as well. And notice I borrowed some inspiration from Google. Notice that the route I'm using is called slash search like two weeks ago. Does take a cue parameter for query, and b is whatever the human typed in. So if I want to search for z the words, enter, I should hopefully get back now z words. So now unlike two weeks ago, we can implement both the front end and the back end for a search engine. But our search engine's searching now just for words. So let's look at application.py as proposed, which is the entry point, and let's see how I'm doing this. So this is some code that I borrowed a little bit from last week when we quickly implemented the spell checker in like 12 or 20 lines of Python code. I'm declaring a global variable called words, and I capitalized it just to be reminiscent of last time and the problem set. I'm using this syntax which I alluded to earlier is just more conventional or Pythonic. Open the large file in Read mode and call the variable file. Then here is a for loop via which you can iterate over every line in the file, reading one at a time. But recall, what does every line in this file end with? Like a backslash n, and we don't really want those as part of the words. That's not part of the English word. So R strip, right strip removes any whitespace from the end of the string. And that's why I needed to add that extra line. So I'm just cleaning up the file or massaging the data as you might do with any sort of data based application. So then I just seem to have this route that renders the template. If I look in index.html, let's follow the bread crumbs. Go into index.html. OK, not that much going on here. Looks like an HTML form, the action of which is slash search, just like Google's. The method of which is is get just like Google's. There's nothing really private about the words I'm searching for here, so I don't care. There's some fancier features here. Notice placeholder is the grayed out text the human sees. Auto focus. What does this do again? This is just a UI feature, better user experience. AUDIENCE Puts the like, right in the text box. DAVID MALAN Yeah, it puts the cursor right in the text box. To focus on something in a web page means make it what's interacting with the user right now. And Mac OS, for instance, highlights it in blue. So when you first load the page, the cursoe's blinking in the choice of text boxes that you care about most. Autocomplete off just disables the browser's version of autocomplete. So I don't see past searches, just because the whole point here is to implement this ourselves ultimately, and then I have my search button. This is just jinja stuff from Flask so that I have a layout file. Lets follow that breadcrumb. Lay out.html, nothing really that interesting going on there. If you've ever wondered why we have these in a lot of our demos, this cryptic looking line here just makes web sites look better on mobile devices. Typically by default if you pull up your phone and look at a website, if it doesn't have that kind of line, like the text is going to be super tiny unless you pinch and zoom. By using this line and variations thereof, it will increase the default font size a bit to make it a little more tolerable on small screen. So it's an easy win for users experience. OK, I seem to have exhausted all the interesting stuff in these templates. Let's look at another and final route. Here's my search route, and this is pretty Pythonic. This is a mouthful, and will reimplement it in a different way in just a moment. So I have a search route that listens for get requests on slash search. Then this crazy looking line is about as Pythonic as code gets. And I'll explain what this is doing and why it's conventional as opposed to straightforward at first glance. And then I render the template, passing in these words. So this one liner on line 17 actually has the effect of searching 140,000 words for whatever words start with what the user typed in. See, this would be a pain in the neck to do. In Python you can do it with literally one line. A long line, but one line nonetheless. Let me make this more clear. If I were to search for words in this big file, I might do something like this. Words is an empty list. So this lower case words is all of the words that match, that I want to send back to the user. So by default I have no idea what to send back. But I do know I can do this. For word in Words which is the capitalized variable, the constant up at the top that has the whole or not even constant, but the global variable that has all of the words from the file, here is a for loop over those. I can now say something like this. If the current word starts with whatever the user typed in well, what's the user typing in? Well, q equals request.args.get quoteunquote q, gives me the user's name, dorm, or in this case Q value for query. So if the word that we're currently iterating over starts with q, I can go ahead and append to my whoops, append to this list that word. Would you say you're comfortable with these lines here? To recap, give me an empty list in which to store the search results, iterate over all possible 140,000 plus words, get and actually, this was stupid. I should just put this up here, because I only need to check for that once. So store the user's input in a variable called q. For each word among the 140,000, check if it starts with the user's input a, b, z, whatever. And if so, append it to there. So let's temporarily get rid of this and just render the template. So notice this gets the job done, but this is very Clike logic. It's not wrong, it's perfectly correct. But Python is a language that's meant to be a little more human readable and a little more elegant, if a little more nonobvious. So this one line does the exact same thing using a feature called a list comprehension, which is ironic if you don't quite comprehend how it's working. But here's the variable I want to create called Words. These square brackets here say give me a list. What do you want to put in that list? I want to put a word in this list. Which word do you want to put in this list? The result of inducing this loop and then only putting in this list a word if it starts with what the human typed in. So it takes some getting used to, but this is just a one liner way, a very Pythonic way of expressing those several lines of very procedural code into a simple one line. Is it better? Not if you can't read it. But once you get more comfortable with Python, yes, it's better because it's less code. Yeah? AUDIENCE You said Python uses notation to tell where conditions are. How is [INAUDIBLE]? DAVID MALAN Good question. In this case of a list comprehension, you can only have one line or one condition. You can't have multiple lines therein, so I cannot start hitting Enter and indenting here. It's just not allowed. So you would only use this and I'm frankly really pushing the limits. You should only really use this syntax when it fits on your screen or fits on a reasonable person's screen. After that you should probably do something a little more expressive. Other questions? But this is very common to see online. So any tutorials, if you ever see this kind of one liner, just try to think about it from that approach what it is actually doing. OK, so propose from a user experience perspective how could this program be better? Because this is just our first version. So what could be better for the user than this? What could be better? Yeah? AUDIENCE Just going back, can you explain words in caps? DAVID MALAN Oh, sure. Words in caps is this global variable I defined up here that stores all 140,000 plus words. That's the really big file called large, the text file. Down here I just need a local variable. And if it's more clear, I could call it results and then just say results equals results. That is the subset of words that start with a, or b, or whatever the human typed in. That's all. Good question. Yeah? AUDIENCE Why do we change the last time why did you have to change args to form? DAVID MALAN Why did I have to change my args to AUDIENCE Forms? DAVID MALAN So earlier today when I didn't understand what was going on, you should use request.args for get requests. You should use request.form for post requests. AUDIENCE But it's still .get after? DAVID MALAN It's always .get, yes. But you change what you're getting things from. In an ideal world, it would have been something oh, I see what you mean. Get in this sense is the verb. We humans mean go get something. Args in this sense, if they had done get I'm making this up, but this is probably why they did this. Because get from get seems weird, whereas get from post is less weird. But it's just they called it args and form instead. OK, so let's actually improve this, but how? What could be better for the user? Yeah? AUDIENCE They could search a word, not just the first letter. DAVID MALAN OK, maybe searching a whole word would be good, not just the first letter. What else could we do? AUDIENCE We can create an index list of letters and words? DAVID MALAN OK, we could create an index list. So maybe using a hash or some form of inspiration from our problem set with Speller and actually use a more sophisticated data structure to get these answers more quickly. And let me propose, too, the goal here is to actually implement autocomplete, and this was not auto complete. This was like old school search. Type in a query, hit Enter, get a page of results. What if we want to do something more immediate? So let me actually propose this. Before looking at the code, let me go into words 1. Let me go ahead and run Flask in that directory. Let me go ahead and reload the form here, and now notice no Submit button because there's not going to be any actual submissions here. But I'm going to go ahead and hit the letter A, and ooh, that's kind of cool. Let me delete that, goes away. B, there's all the B words. Let me go BA words, BAB words, BABA words. This is how autocomplete works. So it seems to be responding immediately to my input, so something's happening. But I'm not actually submitting the form. So I'm kind of using it now, it seems client side JavaScript to maybe talk to the server? Let's infer. So here, too, this should be your instinct. Whenever you're trying to understand how someone's website works, if you want to learn from it or mimic certain fundamental functionality, go ahead and inspect the page. And you don't probably care too much about the HTML yet. Where is this data coming from? Let me click on the Network tab, which we looked at a couple of weeks ago. Let me go ahead and restart this and let me clear this and start from the beginning of the story. Let's see what happens when I type the letter A. Interesting. There is a web request. So if I zoom in down here, notice that my browser actually searched for Q equals A, the human's input. Let me go ahead and it keeps searching because I'm using keyboard shortcuts here. But let me go ahead and click this row. Notice what happened. I made a request to slash search question mark q equals a via get. Let's see what the response was. The response here, if I view the source or rather, if I read the response notice what came back. It looks like my server returned to me a fragment of HTML containing hundreds, maybe thousands of words starting with A. But notice there's no UL tag, there's no head tag, no title, no body, it's just a partial HTML fragment. But that's interesting, because I know with Python I can do exactly that. I can generate anything I want on the server, and then maybe the browser can just plug in those changed the results. So let me go ahead and look at the code for this page. If I go now to the browser's source code, the view page source, you'll see a few new lines. So to do this easily, I'm actually using another library. This one is called jQuery. This was for many years super, super popular. It's kind of starting to fall out of vogue, but it's still so powerful and so useful. And it's used by Bootstrap, the other CSS library we've talked about, so it's perfectly reasonable to use it here. Notice how I'm including it with the script tag, and it's hosted on a third party website so that I don't have to save a copy of it myself on my own IDE. Then let's look at the code I actually wrote. So notice that atop this file is not even a full fledged form, it is just the HTML input. Because I don't need a full form. I don't need an action, I don't need a method, because I'm not submitting it anywhere with the human's cooperation. I'm going to use my own code. So in my script tag here, my JavaScript code, notice what I'm doing. This is some code from like two weeks ago. I'm going to search the tree that represents this web page. And indeed, it is meant to be a tree. Recall from that time when we looked at an HTML page, there is in memory, thanks to the browser, something treelike a DOM, document object model that represents your page. Using JavaScript, can we change that page after the fact? So what am I going to do? I'm going to tell the browser whenever this input hears an event called on key up so whenever the field has focus it's blue in Mac OS and the human hits the key and then let's go, and the key goes up, go ahead and call the following anonymous function. What do you want that to do? Now, this code is a little cryptic, but let me walk us through it because it's only three lines. This code here is using a special feature dollar sign that comes from this library called jQuery. More on that in a moment. That library, somewhat confusingly named, has a function called get, which has nothing to do with Python or the one we just talked about. But this has to do with an HTTP get. With this line of code, you can tell a browser, even after a web page has been loaded, go get me this other URL, please. So what URL do you want to get? Go ahead and get me from the same server slash search q equals, and then what does plus mean in JavaScript if you recall? Concatenation. So it means just append one string to the other. So this is like saying, go ahead and get me the URL that ends with slash search, question mark, Q equals A, or Q equals B, or Q equals Z. Whatever the human typed and just gets slapped onto the end. And then that's where we're getting it from. Input.value is the user's input, the value thereof. And then the last line and this is perhaps the fanciest notice that I have an anonymous function. In this library called jQuery, there is this function called get that gets a URL. When the server responds to your request with a virtual envelope of its own, this anonymous function gets called and the response envelope gets handed to you, so to speak, as a data argument, as a data variable. Then what you can you do? Document.queryselector UL. What is UL? It's an unordered list that by default on this page has nothing in it. But recall that what the server is sending back is a bunch of LI tags. That's great, because I want to put those LI tags right in between here. So how do I do that? I go into the socalled inner HTML of the UL tag, and you might not have seen this before. But you can change the contents of an existing tag inside of it by using inner HTML and just plop the data in there. And so what's happening is this. Let me go ahead and open up Chrome's inspector. Reload the page so it's empty. Let me open up Chrome's inspector. Go to elements, as is the default. And notice on this page, notice that UL tag is opened and closed with nothing inside of it. The moment, though, I search for something, watch what happens. If I search for a, all of a sudden ooh, it blinked, it's a little small. Now there's a little triangle there. What's inside of it? All of those LI tags that came from the server. So with JavaScript, we have this amazing power now to change what's inside of a web page by just asking the server for more data. So if you've ever used Facebook, or you've used Google Chat, or any websites that's dynamically changing every second, every minute and each time you get a message, you can literally, if you get a little nosy, open up Chrome's inspector and watch the DOM, watch this elements tab. And you'll see new stuff popping up every time you get a message, or a chat, or any other such notification on the screen. Now as an aside, this is a little sloppy to be returning HTML, but let's see how it's done. Let me go into application.py for words one, which is this example here. And in application.py, notice what I'm doing is this. Rather than return a whole page of results, I'm returning a template called search.html. All of the rest of this code is identical to before. If I go into my templates and go into search.html, look how terribly simple the code is on the server. If all you want to do is spit out a bunch of list items, this is all you need. There's no template. Like there's no extends layout because you're not returning a whole web page, you're returning a tiny, tiny, tiny fragment of HTML. But this is arguably a little sloppy, because there's a lot of redundancy in what's coming back. If I look at this tag that's coming back from the server, what is obviously redundant about all of this information that's coming back? And if I look at the Network tab, you really see it under response. What's redundant? AUDIENCE You're doing a bunch of calls to the same address and to the same DAVID MALAN This was just because I hit some, like, zoom in and zoom out, so it pretended to make multiple requests. So red herring there. Focus only on this part here. What's redundant about all of the data coming back? It's just keeps saying list item, word, close list item. List item, word, clothes list item. I mean come on, just use a more efficient syntax. Just separate things with commas or something lighter weight. This is sending way many bytes. I mean, look. There's thousands of bytes. This is kilobytes by definition of information that we're sending just to send open bracket, LI close bracket again and again. This is not very efficient. And so the world actually has adopted a different approach, and I'm going to show this in words 2 that actually returns something called JavaScript Object Notation, which is a more succinct representation of this as follows. Let me go into words 2, run Flask in there. Search for the same kind of thing and then watch what happens over the network panel this time. When I search for A, immediately get back the same visual result. But if I look at this search query, now look what comes back. I claim that this is a much more compact representation of the same information. It's a little annoying that there's double quotes, because those are a little redundant. But at least double quotes are a lot more efficient than open bracket, LI, closed bracket, and then the opposite at the end. So this is what's called JavaScript Object Notation. And as this square bracket here and thousands of words later the square bracket on the end implies, this is a JavaScript array that's being sent back from the server. So the only thing that's changed here is as follows. In words 2, this example, notice that I don't even need to return a template anymore. This code is the same as the past two examples. This is how I'm searching 140,000 words quickly. But if I include now a fancier function from Flask called jsonify which is not really a word. But jsonify, that takes any data structure you have data in like this list of words, the matches, and it turns it into that text based representation with quotes and commas. And you don't even have to write a template yourself. And indeed, I got rid of search.html. The only thing you have to do to give yourself access to this feature is import not just render template, and request, and Flask, but jsonify, as well, from the Flask library. Which is just one more feature. Any questions on that before we bring it all together with one final example? Yeah? AUDIENCE Can double quotes break that into [INAUDIBLE]?? DAVID MALAN Can double quotes break that? Good question, great instincts. No because the author of jsonify was smart about this. And if that author notices a quote like an apostrophe, or like something in your own name that has a quote, it will escape it in some way, usually with a backslash. Good instincts. But that's why you probably wouldn't want to write this code yourself because then you have to think of all of those corner cases as opposed to focusing on the parts you care about. All right, so there's one final example. And it's perhaps to come full circle here, do we even need the server? These 140,000 words right now are in a file called large. My web application loads that file into memory and then searches it. But who else could search over a big list of files? Where else could we put this logic? The browser, right? Browser gives you JavaScript, JavaScript's a language, languages can search things. So let me try this instead. In our words 3 example here, notice that I've got one new file. In advance, you know, I took my big text file that just had one word per line and I put it into a standard format just because it makes my life a little easier. And I called it large.json. And in there, actually, where if I open up this folder, you'll see large.js, which is a second file, this time a JavaScript file, in which I've just declared a JavaScript array of all 140,000 words for better or for worse. I just put them into a slightly different format with commas, and quotes, and square brackets, and I gave this whole thing a variable name at the very top of the file. Now, why is this useful? Well, if I go into index.html, notice that there is no more application.py or templates for this example whatsoever. We've gotten rid of Python entirely, I don't know if it's for the better or worse, but we'll now see. So in this file, notice we have an input tag as before, a placeholder for all of the ULs, but we're also now including this large.js file. Thereby telling the browser please download all 140,000 words and then search them locally. How am I going to search it locally? I've essentially converted the language I wrote in Python a bit ago into JavaScript as follows. Here says the browser go get me the input that the user can type into. This tells the browser, go ahead and listen for key up. Whenever that happens, please call this function which has no name, because I want you to just call it immediately, I don't need its name. This function is defined by these several lines. These several lines have to do a bit more work than before. Because before the server was doing all the hard work sending back all of the data, and we just jammed it into the web page. But here I'm going to build up a list a little more manually. So I'm going to let a variable called html equals quote unquote, because I want to build up the unordered list myself. Then if the human, indeed, types something in so if their input is non null, so if they type at least one character, do the following. This is weird in JavaScript, but when you iterate over an array in JavaScript, you use the preposition of not in. So for word of words, go ahead and do the following. If the current word starts with notice the capitalized w also different from Python, but same idea, just different spelling if the word I'm iterating over starts with whatever the human inputted, we found a match. Go ahead and append to this HTML variable, open bracket LI closed bracket, concatenate the word to it, and then close bracket, as well. So I'm constructing a variable in the browser's memory containing HTML that I want to jam into the DOM ultimately. How do I do that. Well, at the very last line I say to the document, select the UL tag, go inside of its HTML, and change whatever is there to this string of HTML, which is presumably 0 or more LI tags now based on those search results. So now let me go back to words 1 rather, let me go back to this example here. Let me go ahead and serve this up. It's not Flask anymore, so I have to use our server from two weeks ago, HTTP server, to serve up HTML. Let me go ahead and reload the screen here, open up index.html, and now notice we're good to go. What do you want to search for? A, B, C. And let's open up the Network tab. Inspect, Network. Let's see what happens every time I search. Z, Y, Q, A. Why is there no network traffic now? AUDIENCE There's no network traffic. DAVID MALAN OK, but that's what I said. But why is there no network traffic? It's not sending any routes, it's not talking to a backend server. Why? Because all the data I might need is already local. So mixed messages here, too. Which is better, which is right? What's the takeaway? How do you think about this? Because now, whereas a lot of our programs early on in the semester were relatively small even though they didn't feel that way at the time, now we have even more design possibilities. And the answers are increasingly nonobvious, and this is why you as programmers will just get more comfortable with conventions, you'll maybe practice what you've seen preached first, then you'll decide as you might be already saying, I don't like that, I'm going to do this some other way. So how do you think about which of these several words examples is best? Version 0 was let the server do all the work and just send back a full new page of results like Google in 1999 did. Then version 1, we added a bit of JavaScript that used jQuery the library to talk to the server using a technique called Ajax asynchronous JavaScript and XML but that just means go get me more data and we returned LI elements. Then we decided that's a little sloppy, don't seem to send me all these useless tags, just send a comma separated list of words. That was version 2. And then this last version gets rid of all of that and just sends all the words to the browser and lets it deal with it entirely. Who likes which best, 0, 1, 2, or 3? What do you think? AUDIENCE So if you aren't supposed to trust the user in case they turn off the JavaScript, then their decision of the functionality of the website works. DAVID MALAN That's a good tradeoff. So if the user turns off JavaScript, 3 OK, it won't offend anyone 3 2, and 1 won't work anymore because JavaScript's disabled. Now, do you care about that? Maybe not. It's a small number of users on the internet who are so concerned with this they just turn off JavaScript altogether, and the reality is so many websites just break these days without JavaScript. That might be a reasonable cost of doing business. Other thoughts? Yeah? AUDIENCE Is the last version the fastest? DAVID MALAN Is the last version the fastest? I don't know, how could we assess that? Yeah, I mean, we can literally measure it. And honestly, built into Chrome in other tabs that I've not even clicked on are a lot of performance tools where you can actually monitor how long everything's taking. This is called benchmarking more generally, and this is what you did essentially in the speller problems that even though we wrote the code that timed everything and measured everything, to answer that question, you could just try timing every one of the examples and then decide for yourself which is best, sure. Yeah? AUDIENCE The last thing I have with problematic issue is like my phone's old, and it doesn't have a lot of memory, and I may not have the fastest plan on Earth. So you might be charging me more data, you might be slowing my phone down. DAVID MALAN Very reasonable concern. Let me go into our dictionary file here and list the size of this. That large.js file is 2.2 megabytes, which on mobile devices, especially in places where your signal is slow, or your bytes are expensive, or you only have intermittent access, I mean, that's kind of obnoxious to send two megabytes to the user if you can avoid it, especially when you can send only the subset of results, a few kilobytes maybe, of matches instead. So a very reasonable concern. Cost, user experience, performance. Other thoughts? Which is better for people on university and corporate campuses who tend to have really good internet access? Say again? 3, OK. But what if it's not 140,000 words, but it's like a billion pictures of cats that Google indexes? Or hundreds or thousands of friends and all of their profile data? Like at some point there's this inflection point where too much data, right? It's not reasonable, it's too much. You don't want to just get a copy of your corporate database to every one of your users just for them to search more locally. So again, these are the nonobvious questions. And one of the goals of, frankly, the final project if you do something web based, or mobile based, or C based, or anything, is all of these questions now boil down to you. Like we have no welldefined answers in mind as to what your final project should do and how it should do it best. But in the weeks ahead, you'll be preproposing some project ideas, proposing an actual project idea, and then designing and implementing this. And you, too, will probably feel this tension where the answer is not always obvious, your teaching fellow might not even know how to answer your question, because he or she will have thoughts of their own. But it's ultimately up to you. And we're now at the point of a level of coding maturity where we're taking the training wheels off and more of the decisions are now left to you. Let's end here. Stick around for one on one questions, and we'll see you next week for databases.
