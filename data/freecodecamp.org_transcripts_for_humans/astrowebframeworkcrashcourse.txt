With timestamps:

00:00 - Astro is an all-in-one web framework for
00:03 - building fast content-focused websites
00:05 - like landing pages blogs technical
00:08 - documentation and more in this course
00:10 - James Q Quick will teach you about this
00:13 - increasingly popular framework James is
00:16 - a popular instructor and keynote
00:18 - conference speaker he's the perfect
00:21 - person to teach you about Astro let's
00:24 - learn all about Astro one of the most
00:26 - exciting and up-and-coming JavaScript
00:27 - Frameworks my name is James he quick and
00:30 - I absolutely love Astro so in this crash
00:32 - course we're going to cover some of the
00:33 - Core Concepts of Astro along the way
00:35 - we'll talk about file based routing
00:38 - creating and managing markdown and MDX
00:40 - contact with content Collections and
00:42 - typescript we'll talk about Dynamic
00:44 - routes and we'll even at the end of this
00:46 - video get into deploying this to netlify
00:49 - and versel we'll also talk about the
00:51 - server-side capabilities of Astro going
00:53 - from a statically generated site to a
00:55 - server-side rendered site and show you
00:57 - how you can add server endpoints to your
00:59 - Astro application as well lastly we'll
01:01 - talk about a few neat features of Astro
01:03 - along the way like view transitions
01:05 - which allows you to add beautiful
01:06 - transitions between your pages and your
01:09 - Astro application with just one line of
01:10 - code now if you enjoy what we cover in
01:13 - this crash course and you want to learn
01:14 - more you can check out my full course at
01:17 - astrocourse.dev to learn all the ins and
01:20 - outs of Astro 3.0 that said let's go
01:23 - ahead and get started let's start on the
01:25 - Astro documentation page where we can
01:27 - see the getting started instructions for
01:29 - creating a brand new project with Astro
01:31 - version 3 which is the most recent
01:33 - version of Astro now on this
01:35 - documentation page they kind of give you
01:36 - an overview some of the things that
01:38 - we've talked about some key features Etc
01:39 - and then if you scroll down they'll give
01:41 - you a couple of ways to get started with
01:43 - Astro one cool way to do that is with
01:45 - the astro.new website and what this is
01:48 - is a collection of different Astro
01:50 - projects that you can open up that have
01:51 - already been created and kind of get
01:53 - started working with them right inside
01:54 - of Stack Blitz now in this case we're
01:57 - going to create our own project from
01:58 - scratch so we're going to do this inside
02:00 - of our own vs code window and terminal
02:03 - to be able to create the project and
02:04 - then go and work and build out the
02:06 - tutorial or the blog that we're going to
02:08 - build now one thing I do want to show
02:10 - and we'll kind of reference this
02:11 - throughout this crash course is the
02:12 - ability to search for anything that we
02:15 - might want in this course on the Azure
02:17 - documentation page so once you get to
02:19 - the Astro docs you can come up to the
02:21 - top left and you can click to open the
02:23 - search window and you can search for a
02:25 - server or anything server side rendering
02:28 - for example and then click on one of
02:30 - these and go straight to those pages the
02:32 - other thing I want to show you that's
02:33 - pretty neat is on this page you can hold
02:35 - command K on Mac or control K on Windows
02:39 - to be able to pull that up as well so
02:41 - you don't have to go and click that
02:42 - yourself you can just open that with the
02:44 - shortcut window
02:45 - that said what we're going to do is copy
02:47 - this command to be able to create a
02:48 - brand new Azure project and then run
02:50 - this in our terminal so that we can get
02:52 - started
02:52 - so I'm going to scroll over to my vs
02:54 - code window and this is an open mtvs
02:57 - code window and I'm going to first
02:59 - switch over to the directory that I want
03:01 - to create the project so I'm going to
03:02 - switch into code and then my demos
03:05 - directory and then from here I'm going
03:07 - to paste in that command from the Azure
03:09 - docs to create the new project so once I
03:11 - press enter this will ask me a few
03:13 - different things first of all are we
03:14 - okay installing the package that's
03:16 - needed to generate our project and this
03:18 - is actually a good error to have here so
03:21 - with the latest version of Astro you're
03:23 - required to have a version 18 or higher
03:26 - of node.js to be able to run the
03:27 - installer so I wanted to leave this in
03:30 - as a reminder that you'll need to be
03:31 - working with a version 18 or higher now
03:34 - for me personally I use NVM to manage my
03:38 - different versions of node to handle
03:40 - this this is the easiest way that I
03:41 - found to handle working with different
03:43 - versions of node so I can use my NVM
03:46 - command and then NVM use and then type
03:48 - 18 and this will let me use a version of
03:51 - node that is a 18. now I can also use
03:55 - NVM to install a version of node like 20
03:57 - for example and that will go and install
03:59 - a different version of node that I could
04:01 - use at any time but in this case since
04:03 - I'm now using version 18 I can scroll
04:06 - back through my commands and run that
04:07 - same create command inside of my
04:09 - terminal now you see we get the really
04:11 - awesome animated experience where Astro
04:14 - is going to walk us through creating
04:16 - this new project
04:17 - so in this case we need to give it a
04:19 - folder that we're going to create the
04:20 - project in I'm going to call this FCC
04:23 - Astro crash course so you'll just do dot
04:27 - slash and then whatever the folder is of
04:30 - whatever the name is of the folder that
04:32 - you wanted to create in
04:34 - this case we're going to start with
04:35 - sample files you could also choose a
04:37 - Blog template where they'll have a lot
04:39 - of the stuff done that we will be
04:40 - building from scratch you could also
04:42 - additionally choose an empty project to
04:44 - just start completely from scratch in
04:46 - this case we'll accept the sample files
04:47 - and what it's doing now is it's going to
04:49 - start to copy over the sample files
04:51 - which is done and then it's going to ask
04:52 - whether or not we want it to install the
04:54 - dependencies and we can press enter on
04:56 - yes and let it go and run and install
04:58 - all of these dependencies
05:01 - so we'll let that run for a second and
05:03 - come back when it's finished all right
05:04 - so those dependencies have been
05:06 - installed and the next question is do we
05:08 - plan to write typescript which in this
05:10 - case we do so we'll click yes and then
05:12 - we'll choose the strict or recommended
05:13 - version of how strict with typescript we
05:15 - should be lastly the question is do we
05:18 - want this to initialize a new git
05:20 - repository in this case we'll say yes
05:22 - because we're going to use this
05:23 - repository to deploy this later on to
05:26 - netlify and versel
05:28 - so we'll click yes here
05:30 - and then we get our out animation from
05:32 - Houston which is the Astro mascot we'll
05:34 - come back to Houston in a little bit and
05:37 - the next thing I want to do is open this
05:38 - project inside of vs code so I can use
05:41 - the command code R which means to reuse
05:43 - the window that I'm currently in and
05:45 - then I'm going to choose my SEC Astro
05:47 - crash course window
05:49 - notice it pops up here with this
05:51 - intellisense if you're curious where
05:53 - this little window is coming from this
05:54 - is coming from an extension called fig
05:56 - dot IO which is really great to kind of
05:59 - supercharge your powers inside of your
06:01 - terminal
06:02 - so I'm going to press enter and then
06:03 - we'll open this up inside of that same
06:05 - window in vs code and now I'm going to
06:08 - go to the bottom and open my terminal
06:10 - again and inside of here I'm going to
06:11 - run npm run Dev and this should now
06:14 - start our Astro project and it will run
06:16 - it at Port
06:17 - 4321 they chose this port because it is
06:21 - kind of like four three two one blast
06:22 - off which is kind of neat so I'm going
06:24 - to open a new tab in my browser and open
06:26 - up my browser to localhost 4321 and you
06:31 - see this is the starter application that
06:32 - we get with Astro where we have a
06:34 - welcome to Astro we have a little code
06:37 - challenge of how to make an update to
06:38 - this which is right here then we have
06:40 - links to documentation integration
06:42 - themes Community Etc so we have our
06:45 - beginner Astro application created let's
06:48 - go and walk through the code and talk a
06:49 - little bit about what all is there
06:51 - so first off we have our public
06:53 - directory this is where we would store
06:55 - any public assets like images or other
06:58 - things that we want to be publicly
06:59 - available from our site now these are
07:02 - going to be directly available after the
07:04 - end of the URL so what this means is
07:05 - since we have
07:07 - favicon.svg we could come to the end of
07:10 - our URL and type in
07:12 - favacon.svg and now that'll take us to
07:15 - that file which is not going to show a
07:16 - whole lot because it's an SVG and we're
07:18 - not going to have good visibility here
07:19 - but we do have the access to be able to
07:22 - access that directly so anything that
07:24 - you put inside of the public directory
07:26 - will just be shipped with your built
07:28 - version of your site and included and
07:30 - would be available after the slash in
07:32 - your url after that we have our source
07:35 - directory this is where all of our code
07:36 - is really going to live and what Astro
07:39 - really depends on is this page based
07:41 - routing where we have different files
07:43 - under the Pages directory are going to
07:45 - represent as you might have guessed it
07:46 - different pages in your application
07:49 - so let's just open the
07:51 - index.astro file and take a look the
07:54 - first thing we'll notice is that it is a
07:56 - DOT ASTRO File it's not a DOT JS it's
07:59 - not a DOT TS this is dot Astro and this
08:01 - obviously is going to signify to the
08:04 - developer to yourself and to your editor
08:06 - we'll talk about this in a minute that
08:07 - this is an astro component now Astro
08:10 - components are made up of two different
08:12 - sections there is the kind of JavaScript
08:14 - section which goes in these three dash
08:17 - blocks we could call these front matter
08:20 - we'll talk more about front matter
08:21 - inside of markdown files but inside of
08:25 - these three dash blocks we can add any
08:28 - sort of JavaScript that we want
08:29 - including importing other components so
08:32 - you can see we import our layout and our
08:34 - card and in this case we can find both
08:36 - of these in their appropriate
08:37 - directories under layout is the first
08:40 - one if we scroll down we see a reference
08:42 - to slot now slot is where we're going to
08:45 - take whatever information is in between
08:46 - this component when we use it the layout
08:49 - component and then inject that right
08:50 - inside of the component that we have
08:52 - defined here so what this looks like if
08:54 - we come down to our index.astro since we
08:57 - wrap this entire page which has a lot of
08:59 - code in it since we wrap this entire
09:01 - page with this layout component all of
09:04 - the stuff in between
09:06 - the layout tags which is here all of
09:09 - that is considered the slot and that
09:11 - will be rendered inside of this layout
09:13 - component right here so inside of the
09:15 - body now inside of the layout you'll
09:17 - also see a few other things you'll see
09:19 - that we can Define typescript interfaces
09:22 - for our props after we Define those we
09:25 - can then de-structure those properties
09:26 - and then use them inside of our
09:28 - application
09:29 - just like we're using the title inside
09:31 - of the title tag inside of the head for
09:34 - our application now notice we can use
09:36 - these JavaScript variables by putting
09:40 - them in between the two brackets so
09:43 - inside of these two brackets we're able
09:45 - to basically kind of write JavaScript
09:46 - here which enables us to use variables
09:48 - that we defined up above
09:51 - so in this layout file you'll also see
09:53 - the other components that make up a
09:55 - basic HTML file you'll see the doctype
09:58 - defined at the top you'll see the HTML
10:00 - tag you'll see head and we'll we'll see
10:03 - a few different of our meta tags here
10:05 - like description viewport Etc we'll also
10:08 - see a reference to our title and then if
10:10 - we scroll down we'll see a lot of CSS in
10:13 - here now Astro has a few different ways
10:15 - that you can write CSS one of the ways
10:17 - that you can do that is just by adding a
10:19 - style tag right inside of your Astro
10:22 - components now this may or may not make
10:24 - you excited this is something that gets
10:26 - debated about whether or not your style
10:27 - should be co-located with your actual
10:29 - markdown and with your JavaScript but in
10:32 - Astro you have the ability to write all
10:35 - three together so your JavaScript your
10:37 - markup or your HTML and then your Styles
10:40 - in here as well
10:41 - now style is typically in here are
10:43 - scoped to a given component
10:46 - so you can see here that we have an is
10:48 - global tag that's associated with this
10:50 - style which means all of these styles
10:52 - are going to be applied to every single
10:54 - page on our application versus if we go
10:57 - to our index.astro component and scroll
10:59 - down there's going to be Styles here and
11:02 - these styles are not Global they're only
11:05 - referencing material that's inside of
11:08 - the component that it's in which in this
11:09 - case is a page component which is the
11:11 - index.astro now we can see another good
11:14 - example of this with the actual card
11:16 - component you can see we Define our
11:18 - props here we destructure those props we
11:20 - have markup we reference those
11:22 - properties inside of our markup and then
11:24 - we also have style tags down here as
11:27 - well now again these styles are only
11:29 - applying to things that are inside of
11:31 - this card component and won't be applied
11:33 - anywhere else so an example of this is
11:37 - if I were to select the main tag and did
11:40 - a background color of red this actually
11:44 - won't appear to have any difference or
11:47 - make any difference on our application
11:48 - and that's because there's no main tag
11:51 - inside of this card component and these
11:53 - styles are only applied to that however
11:56 - if I went to the layout and I now chose
11:59 - to select the main tag and did a
12:01 - background
12:03 - of red now we'll see that this red color
12:06 - is going to come into play because these
12:08 - styles are Global and are going to be
12:10 - applied anywhere there is a main tag so
12:13 - really important to remember that the
12:15 - Styles inside of Astro by default are
12:17 - scoped to that component and won't be
12:20 - interfering with other styles that you
12:21 - have in other components
12:23 - now in this case in this crash course
12:25 - we're going to use Tailwind CSS to style
12:27 - our application so we're actually not
12:29 - going to worry about all these styles
12:30 - that are defined inside of here we'll
12:32 - come back and clean these out in a
12:34 - minute and kind of reset this with some
12:36 - beginner styles for us to work with but
12:38 - if you were building an Azure project
12:39 - yourself you do have a few different
12:41 - ways that you could choose to do CSS in
12:43 - this case we are just going to use
12:45 - Tailwind CSS which has become incredibly
12:47 - popular
12:49 - so that's the majority of the basics of
12:51 - the layout for your code inside of the
12:54 - source directory there's a few other
12:56 - files a git ignore file which is pretty
12:58 - standard there's also the astro.config
13:01 - file and this is really important
13:03 - because this is where we can add
13:04 - Integrations in Astro we can also Define
13:07 - different things about our project like
13:09 - how this project is going to be built
13:11 - and where it's going to be hosted so by
13:14 - default Astro is a statically generated
13:16 - site we'll talk more and more about this
13:18 - we don't have to configure anything for
13:20 - that to be supported but if we wanted to
13:22 - convert this to be a server-side
13:23 - rendered site we could configure this in
13:25 - here and then configure where and how we
13:27 - want to deploy this at the end of this
13:29 - video we'll talk about deploying this to
13:31 - both netlify and versel but in this case
13:34 - we don't have anything to change yet in
13:36 - the Azure config although we will come
13:37 - back to this shortly next up we have our
13:40 - package.json with a few commands on how
13:42 - to run the project we have the readme
13:44 - and then we have a TS config which just
13:46 - extends the typescript config that comes
13:48 - from Astro so is going to give us all
13:50 - the basic rules for working with
13:52 - typescript inside of our Astro project
13:54 - you could go and customize that in any
13:56 - way that you want to but in this case we
13:58 - don't need to now I want to take a few
14:00 - minutes to talk about setting up your vs
14:02 - code instance to work with Astro in the
14:04 - best way now the most important thing
14:07 - you'll need to install is the actual
14:09 - Astro extension which comes from Astro
14:11 - themselves now what this does is it
14:13 - allows these Astro components these
14:16 - Astro files to be recognized as Astro
14:19 - files so that we get appropriate
14:20 - intellisense coloring Etc so notice down
14:24 - at the bottom here that vs code is
14:25 - recognizing this as an astrophile and
14:28 - then based on that and based on this
14:29 - extension knows what to do and how to
14:31 - color this now if we were to disable
14:33 - this just to show you what this looks
14:35 - like and we restart this all of our code
14:39 - highlighting our syntax our intellisense
14:42 - Etc goes away inside of these Astro
14:44 - components and vs code considers this to
14:46 - be a plain text file which is obviously
14:48 - not what we on so you'll want to make
14:51 - sure to install the Astro extension to
14:53 - get all of the benefits that come along
14:55 - with it it's by far the best way to work
14:57 - with Astro so I'm going to enable that
14:59 - and notice all of that comes back now
15:01 - another one that I have installed is an
15:03 - astro Snippets extension there's lots
15:05 - that you can do with Astro in terms of
15:07 - different types of file different things
15:08 - you might want to do this is a great set
15:11 - of Snippets that you could start with
15:12 - that kind of help generate components
15:14 - quicker and easier for you as you're
15:16 - going along
15:17 - now there's one more extension from the
15:19 - Astro team which is the Houston
15:21 - extension now Houston is the actual
15:23 - mascot for Astro and they've built a lot
15:25 - of fun things around this so with the
15:27 - Houston extension you get the Astro vs
15:30 - code theme mimicking the colors from
15:32 - Houston which is pretty neat I like this
15:34 - a lot in addition to that inside of the
15:36 - file explorer you get a little Houston
15:38 - Tab and you get kind of an animated
15:40 - Houston icon that shows you whether or
15:42 - not your application is running well or
15:44 - not based on it being happy or sad so
15:47 - it's a nice little touch to kind of feel
15:49 - like you're inside of the Astro
15:50 - community so you can install this and
15:52 - kind of have some fun with that if
15:54 - you're interested now me personally I'm
15:56 - using my personal James Q Quick theme so
15:58 - if you're interested in having your
16:00 - colors look exactly like mine you can
16:02 - search James you quick to get set up
16:03 - there the last thing I want to show you
16:05 - is the Tailwind CSS intellisense
16:08 - extension this is one that I use all the
16:10 - time when working with Tailwind so that
16:13 - it helps me kind of auto complete or
16:15 - remember what all the different styles
16:17 - are that that I'm trying to work with so
16:19 - you'll see this more as we work work
16:20 - through this and start writing some code
16:22 - now with all of that set up let's go
16:24 - back to the Azure documentation and see
16:26 - how to install Tailwind so let's just
16:28 - search in the documentation for tailwind
16:30 - and we'll be taken to the Astro JS
16:32 - Tailwind extension or integration that
16:34 - we can add
16:36 - which is one of the really cool things
16:37 - about Astro is that it comes with
16:39 - Integrations which makes it really easy
16:41 - to add support for other UI Frameworks
16:43 - for example to be able to deploy SSR to
16:46 - different places and a bunch of other
16:48 - really neat things so let's scroll down
16:49 - we can kind of skip the why tailwind and
16:51 - let's come down to the npx Astro ad
16:54 - Tailwind command which allows us to add
16:56 - Tailwind in one command and be able to
16:58 - work with it right after that so let's
17:01 - stop our running application let's paste
17:03 - in our MPX Astro ad Tailwind command and
17:06 - this will kind of walk us through what
17:07 - it's going to do to make sure we're okay
17:09 - with it doing all of these things so do
17:12 - we want to allow it to install the
17:13 - Tailwind CSS extension and the astrojs
17:16 - Tailwind package yes absolutely in this
17:19 - case it says it's going to generate a
17:20 - tail 1 config file which we absolutely
17:22 - want so we'll say yes and then lastly it
17:25 - says it's going to update the Astro
17:26 - config file to be able to support
17:28 - Tailwind so we'll say yes to that as
17:29 - well now just to confirm what this did
17:32 - let's search for the Astro config file
17:34 - let's open this up and what it did is it
17:36 - added an integration section here and
17:38 - then inside of that array it added a
17:40 - call to the Tailwind function that gets
17:42 - imported from the astrojs Tailwind
17:45 - package so this in theory is how we
17:48 - would manually install Integrations into
17:50 - our applications but in this case Astro
17:53 - gives us this command the Astro add
17:55 - command to be able to do all this stuff
17:57 - for us which is really really nice
17:59 - so let's go into our layout file and
18:02 - let's get rid of all of the styles that
18:04 - are defined in here because we're going
18:05 - to use Tailwind for our Styles and not
18:07 - use the built-in styles that come with
18:08 - the application now just to make sure
18:11 - let's go ahead and run this to have this
18:13 - running we can make a few changes inside
18:15 - of this layout file to start to get the
18:19 - base of our application going
18:21 - now the first thing to notice is that
18:22 - we're only defining one property that
18:25 - could be passed in as props which is the
18:27 - title now we could additionally add
18:29 - extra ones like the description we can
18:31 - have this be optional so we'll have that
18:33 - be defined as a string so the optional
18:36 - question mark or the question mark
18:37 - denotes this as optional and we can also
18:40 - Define an image in here as well so now
18:43 - that we get all three of those we can
18:45 - destructure them so that we can be able
18:47 - to use these as well
18:49 - all right so we have these three
18:51 - properties but we're not using all of
18:52 - them just yet we're only referencing the
18:55 - title and not the description or the
18:58 - image yet so inside of the content for
19:01 - the description we could reset this
19:04 - to be description
19:06 - and we can also reference our image by
19:09 - using it for the OG image type now we're
19:12 - not going to get all the way into all
19:13 - the different OG tags that we could use
19:15 - let's start with a meta tag with a
19:18 - property
19:19 - of OG
19:22 - image and then we'll say the content is
19:25 - going to be that image property that we
19:27 - pass in so we'll put this in here as
19:30 - image
19:31 - now one thing you might be wondering is
19:33 - what if the description and the image
19:35 - are not passed in here we should
19:37 - probably have a default property that we
19:39 - can use so in this case for the
19:41 - description we can set the default right
19:43 - in line in here by doing equals and then
19:45 - assigning this to a string now what
19:47 - we're building is a an application
19:50 - called Rhythm Nation and this is a
19:52 - community
19:53 - of music producers and in
19:57 - enthusiasts and then we want to give a
20:00 - default value to the image as well now
20:02 - we'll come back to this in the images
20:03 - section but I'm going to set this to a
20:05 - default
20:06 - of Slash Images slash band dot jpeg now
20:12 - remember we talked about the public
20:13 - directory what this is referring to
20:15 - would be a file ban.jpg inside of an
20:19 - images directory inside of public but
20:21 - we'll come back to that in a little bit
20:22 - for now we're just kind of setting these
20:24 - by default now just to show that these
20:26 - are coming up we can come
20:28 - back to our running application which
20:30 - now looks a little bit different because
20:32 - we got rid of those Styles and if we
20:33 - look inside of the head we should see
20:36 - that we now see our description here we
20:38 - also see our OG image which if we try to
20:40 - access will not be available yet then we
20:42 - still have our same title which is great
20:44 - so all those things are working well
20:46 - there's a lot more that you could dive
20:48 - into with OG tags for helping your
20:51 - website show up on social media
20:54 - post for example or embeds and slack or
20:57 - Discord but that's a conversation for
20:59 - another day just know that you have
21:00 - complete control to add all of those
21:01 - inside of here
21:03 - now inside of the layout what I want to
21:05 - do is add some Tailwind classes in here
21:07 - and what we can start with is a Min
21:09 - height of screen
21:12 - so before we save that let's go and look
21:14 - at the body tag in here and if we see
21:18 - this body tag is not taking up the
21:20 - entire height so we can start to style
21:22 - that a little bit with Min h of screen
21:24 - and now we should see that this body is
21:26 - now taking up the entire height which
21:28 - also is confirming that our tail one
21:30 - classes are working
21:32 - now from here I want to add a header
21:34 - component that can show the basics of
21:37 - our application so in this case I'm
21:39 - going to copy a little bit of code but
21:40 - inside of components I'm going to create
21:42 - the header.astro component and I'm going
21:45 - to paste in some starter code for us to
21:47 - work with now we'll walk through the
21:49 - code that's here so we Define our header
21:51 - we give some Tailwind CSS classes again
21:54 - this is not a crash course on Tailwind
21:56 - specifically but we have some classes
21:58 - for our header we then have an image
22:00 - icon that we can have to show in the top
22:03 - left we'll come back to that in a second
22:04 - then we have a few links to the
22:06 - different pages on this application like
22:08 - the home page the about and the blog
22:10 - so from here what I want to do is import
22:12 - this into our body or into the body of
22:16 - the layout component so I can actually
22:18 - Open Bracket and start to type our
22:20 - header and then oftentimes I'll get
22:22 - intellisense for this but it looks like
22:24 - it's not opening for me so I can go and
22:26 - do a manual import up here instead so at
22:29 - the top of this we can import header
22:32 - from and then we'll go back a directory
22:34 - into the components directory and then
22:36 - grab the header.astro
22:39 - so we could save this and we should now
22:41 - see the basics of our application
22:43 - starting to come together we have our
22:44 - header up here we have a missing icon up
22:47 - here and we'll need to add that inside
22:49 - of our source code so that we can
22:51 - actually have this show up so one of the
22:53 - things that we can do is go ahead and go
22:56 - to the Astro course demo final source
22:59 - code and then inside of the public
23:01 - directory we have an images directory
23:04 - and we have a heartbeat.png both of
23:07 - which we're going to need so we can
23:09 - click on the heartbeat.png and we can
23:11 - download this so we can download that
23:14 - file and then additionally we're going
23:16 - to need the images directory as well so
23:19 - from the images directory we can
23:22 - download this directory as well
23:24 - all right so that should download all of
23:26 - those files
23:27 - and so what you'll need to do is go and
23:29 - find the heartbeat image and then that
23:32 - directory that we just downloaded and it
23:33 - will add that into our source code so in
23:35 - this case I'm going to take the
23:36 - heartbeat.png and I'm going to add this
23:38 - into the public directory so there that
23:41 - is there and if we look inside of our
23:43 - header it's referencing slash
23:45 - heartbeat.png which should reference a
23:47 - heartbeat image right inside of that
23:48 - public directory so now if we come back
23:51 - and go to our application
23:53 - and refresh we should see that heartbeat
23:55 - icon is starting to show up which is
23:57 - great now the other thing we wanted to
23:59 - do is take those images that we
24:01 - downloaded in the zip folder and add
24:03 - those to the public directory as well
24:05 - so inside of the public directory I'm
24:06 - going to create an images
24:08 - folder and I'm going to drag all those
24:10 - images that we just downloaded into that
24:12 - folder so into the images directory here
24:16 - now one additional benefit of that if we
24:18 - remember is back in the layout component
24:20 - we defined a default image
24:24 - for our OG image to be inside of the
24:27 - images directory just like we did and
24:28 - then the band.jpg so this now should be
24:31 - the default image that shows up for our
24:33 - OG image tags and actually we can test
24:36 - this by going directly to this inside of
24:38 - the URL so we go to slash images and
24:40 - then slash band dot uh not jog but JPEG
24:44 - and we should now see this entire image
24:46 - showing up so we know that that is
24:48 - working as well so we have our images
24:50 - copied over which is exactly what we
24:52 - want we have our header showing up up
24:55 - here above we have links to our
24:57 - different pages which we haven't created
24:59 - yet and now we can go into our index
25:02 - component that root page
25:04 - and we can get rid of all of the Styles
25:06 - so we can delete all of these Styles and
25:08 - we can delete all of the main content
25:10 - that's in here as well so let's just
25:13 - scroll all the way through and get rid
25:14 - of everything inside of Main
25:17 - and in this case we're going to update
25:18 - this title to be relevant to the blog
25:22 - post the blog site that we're working on
25:24 - which is the Rhythm Nation blog so it's
25:27 - just the demo idea here but
25:30 - let's go ahead and type that in Rhythm
25:33 - Nation blog and now we can add a title
25:36 - to this as well so I'm going to actually
25:37 - create a new component for an H1 that we
25:40 - can reuse so we'll create an H1
25:42 - component dot Astro I'm going to copy
25:44 - over the tiny bit of code that we have
25:46 - for this where we Define our props we
25:49 - take a text property as our prop we
25:51 - destructure that and then we put it
25:53 - inside of an H1 that already has the
25:55 - Tailwind Styles created so I'm going to
25:58 - save this and then back inside of the
26:00 - index
26:01 - we can now reference our H1 component
26:04 - and we'll pass in a property
26:07 - of rhythm
26:09 - nation and then we'll need to import
26:11 - this component so that we can reference
26:13 - it so we'll import H1 from and then
26:16 - we'll go into that components directory
26:18 - and then we'll grab the H1 dot Astro and
26:21 - now we should see a basic title showing
26:23 - up now one thing you might notice is
26:25 - that we need some spacing on the outside
26:27 - of this so one more component that we're
26:29 - going to create is the main dot Astro
26:32 - component and what we're going to do is
26:34 - use this component to wrap all of the
26:36 - other things that we do so in this case
26:38 - I'm going to open up a main tag
26:40 - and then we'll pass in everything in
26:42 - between as the slot and then we'll just
26:44 - add some Tailwind classes in here so
26:47 - we'll have a px of 24 which is padding X
26:51 - we'll set a Max width of 7 XL we'll set
26:55 - MX to be Auto which is going to
26:57 - automatically Center everything
26:58 - horizontally and then we'll set the
27:00 - width to be full and then lastly we can
27:03 - set the padding to be 5 on screens
27:07 - that are at Max small size so this is
27:12 - saying that we'll have a padding X of 5
27:14 - on screens extra small and small and
27:16 - then above that anything bigger will
27:18 - have a padding X of 24. now the last
27:21 - thing we'll need to do we can actually
27:22 - duplicate this import we can import the
27:25 - main component
27:26 - from that components directory and we
27:29 - can now use our main component instead
27:31 - of just the main tag and that should
27:33 - wrap everything and give some spacing on
27:35 - the outside so now we have a clean
27:37 - section here for our main content that
27:39 - has that padding on the outside we have
27:41 - our header we have our images loaded and
27:43 - we can start to do more with this
27:45 - application by building out blog
27:46 - functionality and leveraging the content
27:48 - collection feature in Astro which is one
27:51 - of my favorite features of Astro now if
27:53 - we look at the final demo from the full
27:54 - Astro course we can see we have a home
27:57 - page where we show a bunch of blog posts
27:58 - we have tags Etc but what I want to show
28:01 - you is that if we go to the slash Blog
28:04 - Page we can see a list of all these blog
28:06 - posts which is what we're going to start
28:07 - to work on now so we can see a list of
28:10 - all the blog posts in addition to
28:12 - all the images that are associated with
28:14 - them so if we scroll through we can see
28:17 - these blog posts and then if we click on
28:18 - one we'll actually be taken to the
28:20 - specific route for the individual page
28:22 - so notice inside of the URL we have our
28:25 - root URL slash blog and then slash the
28:28 - title of that blog post and a sluggified
28:30 - version which means having dashes in
28:33 - between all of the words so let's start
28:35 - to work on setting up our application in
28:37 - this crash course to be able to work
28:39 - with markdown using content collections
28:41 - in Astro
28:43 - so let's go over to the Astro
28:45 - documentation and let's search for
28:47 - Content collections so what content
28:49 - collections are are a way to organize
28:51 - and manage and author content in any
28:54 - Astro project and in my personal opinion
28:55 - this is the best experience for working
28:58 - with content specifically markdown and
29:00 - or MDX content that I've ever seen
29:02 - across any platform which gets me really
29:04 - really excited so our content
29:07 - collections again give us a way to
29:08 - organize all these inside of a special
29:10 - directory in Astro called content
29:12 - directory so under Source slash content
29:15 - we can then create a directory for each
29:17 - different type of content that we want
29:19 - to create in this case their demo they
29:21 - have newsletter in our case we will have
29:23 - blog and that's where all of our blog
29:25 - posts will live as markdown files inside
29:28 - of there now you can scroll down and
29:30 - find a lot more about this with multiple
29:32 - collections Etc but the one thing I do
29:34 - want to show you is how to define
29:36 - collections inside of the content config
29:39 - file which is a typescript file and
29:42 - allows you to Define types for your
29:44 - individual collections like the blog
29:46 - collection using Zod to have typescript
29:50 - type associated with each of your
29:52 - collections so you define a collection
29:54 - you define a schema and you can Define
29:56 - all the different properties that are
29:58 - going to be associated with each piece
30:00 - of content now before we actually get
30:02 - into the code the one thing we will need
30:04 - to do is go back to the Astro course
30:06 - demo and we'll need to download some
30:08 - sample markdown files that we have in
30:10 - here to reference inside of our
30:11 - application so inside of the Azure
30:14 - course demo there is the source
30:16 - directory and then inside of there just
30:18 - like we talked about is a Content
30:19 - directory and then inside of there is
30:21 - the post directory so what you'll want
30:23 - to do is go and download this entire
30:26 - directory of all of these posts
30:29 - now after you do that you'll want to
30:30 - make sure to extract all of those and
30:33 - then we'll go inside of our source
30:35 - directory we'll now create our content
30:38 - directory and then inside of there we'll
30:40 - create another new folder called posts
30:43 - and then we'll take all of that that we
30:45 - just copied
30:47 - and drag it into the post directory
30:50 - now one thing I did Skip from copying
30:52 - over is the images directory that you
30:55 - can see here but that's something we'll
30:56 - come back to when we get into image
30:58 - optimizations so let's just take a real
31:01 - quick look at what we have inside of
31:03 - this content so inside of here we have
31:06 - our front matter at the top of each one
31:08 - of these markdown files and we have an
31:11 - author we have categories we have a date
31:13 - we have whether or not this blog post is
31:14 - featured we have a cover image to be
31:17 - referenced and then we have a title now
31:19 - this is all the front matter what we're
31:20 - going to do with content collections is
31:22 - Define a data type that represents this
31:25 - and stores or or gives us intellisense
31:28 - inside of our Editor to know which of
31:30 - these properties to associate with our
31:32 - given blog posts specifically with a
31:34 - given collection which in this case is
31:36 - our blog post now at the bottom of this
31:38 - you can see all of the sample markdown
31:40 - that's included here so this is just
31:42 - some getting started markdown so we have
31:44 - something to render you could obviously
31:46 - go and create your own markdown with
31:48 - your own content if you wanted to
31:50 - now one thing I do want to change is the
31:52 - reference to where these images are
31:55 - stored so actually I'm going to select
31:57 - this whole thing and I'm going to do
31:59 - command shift F on Mac or Ctrl shift F
32:02 - on Windows and I'm going to change this
32:04 - slightly and I'm going to get rid of
32:06 - this leading dot in each one of these
32:08 - blog posts or each one of these markdown
32:09 - files and we'll come back to that again
32:11 - when we talk about updating our images
32:14 - to work with the image component that
32:16 - comes with Astro to optimize our images
32:18 - but right now I want this to point to
32:20 - the public images directory where those
32:23 - different images are again we'll come
32:25 - back to this in a minute so we have our
32:27 - sample markdown and now we need to go
32:29 - into the content directory and we need
32:32 - to create our config dot TS file so
32:36 - let's start to work on defining a
32:37 - Content collection inside of this config
32:39 - file now to start we're going to import
32:41 - the Define collection
32:43 - function and then the Z for Zod
32:47 - from the Astro
32:49 - content
32:51 - import so this is giving a little bit of
32:54 - an issue saying it cannot be found this
32:55 - should be okay so as we go through this
32:58 - we'll make sure to run it just to make
32:59 - sure and then from here I want to Define
33:01 - my post collection and this is going to
33:04 - call the Define collection function
33:06 - we'll call this and we'll pass it a
33:08 - config object now this config object
33:11 - will then have a schema
33:14 - and we'll say that the schema is going
33:16 - to be a z dot object which is a function
33:19 - and we'll pass that a configuration
33:21 - object as well so we're using Z dot
33:24 - object to say that this schema is going
33:26 - to be an object and then now we can
33:27 - Define the different properties that
33:29 - it's going to have so we can Define it
33:31 - to have a property of author and then
33:33 - using Z which is Zod we can say where
33:35 - this is going to be a string then we'll
33:38 - have a date which in this case is also a
33:41 - string
33:42 - will have an image which is a string
33:45 - we'll come back to this in a minute and
33:47 - then we'll have a title which is a
33:49 - string as well now the cool thing about
33:51 - Zod is that it has other data types that
33:54 - you can work with where you can add a
33:55 - lot of customization on what exactly
33:57 - these types should look like
33:59 - and then lastly what we want to do is
34:01 - export a variable called collections and
34:04 - this is going to be an object and we'll
34:06 - say a key is going to be post and then
34:08 - it's going to have a value of posts
34:11 - collection and it's really important
34:13 - that this word here match up with the
34:15 - name of the directory that that content
34:16 - is in so those two things should match
34:19 - which means our post collection should
34:21 - be inside of this post directory inside
34:23 - of content so now that we have our
34:26 - definitions for our content we want to
34:27 - start to query this content so that we
34:29 - can start to display this inside of our
34:31 - slash blog page so to do this we'll need
34:34 - to create another component inside of
34:36 - our Pages directory and we're going to
34:38 - create the blog Dot
34:40 - Astro component now in here we can start
34:43 - to query our content by referencing the
34:46 - get
34:47 - collection function that comes from that
34:50 - Astro content namespace so this is going
34:53 - to be a function that we can call
34:55 - to get the content associated with a
34:58 - specific collection so in this case
35:00 - we're going to assign this to a variable
35:01 - called post we're going to await a call
35:04 - to get collection and then inside of a
35:07 - string we're going to pass it the name
35:09 - of the content that we're looking for
35:10 - now notice it gives me intellisense in
35:12 - here because it knows what the different
35:14 - content collections are that I've
35:15 - defined so I can now query these posts
35:18 - inside of here and now we can be able we
35:21 - should be able to log the post to the
35:24 - console
35:25 - so important to note with Astro
35:28 - is all of this code is going to be run
35:31 - statically at build time so it won't
35:33 - quite look this way when we run this now
35:35 - but when this is deployed all of this
35:38 - content is going to be queried and
35:39 - generated at build time and then
35:41 - deployed statically we'll talk more
35:42 - about this as we convert to SSR later in
35:45 - this video but in this case we should be
35:47 - able to go back to our site
35:50 - we should be able to click on the blog
35:52 - page nothing will show up but if we go
35:55 - back to our logs we should see that this
35:58 - is actually querying all of this content
36:00 - which is pretty nice
36:02 - so what I want to do is start to be able
36:04 - to display the basics here so one thing
36:06 - I'm going to do is copy over the
36:08 - structure of a page from that root page
36:11 - and now we'll say this title is going to
36:13 - be a Blog and then Rhythm Nation maybe
36:16 - not Rhythm Nation blog because that's
36:17 - repetitive we also have missing Imports
36:19 - so I can do command and period and go to
36:22 - add all missing Imports this would be
36:24 - control period if you're on Windows
36:25 - machine now we have all of our Imports
36:28 - and then we can also update this to be
36:30 - blog so now we should at least have the
36:33 - basics of a page kind of showing here so
36:35 - Rhythm Nation blog so that's great but
36:37 - now we want to actually be able to
36:39 - display that content so one one of the
36:41 - things that we could do is we could
36:43 - iterate through our posts so we could
36:46 - say post Dot and then map and then get a
36:49 - reference to each post and then for each
36:51 - post what do we want to return
36:54 - so inside inside of here we could start
36:57 - with an H2 and then reference the post
37:00 - Dot
37:01 - data that's going to be all of our front
37:03 - matter and then inside of here when we
37:06 - press enter we now get intellisense for
37:07 - all those properties which in this case
37:09 - I'm going to choose the title so this is
37:11 - not going to look great but at least we
37:12 - have the ability to show that all these
37:14 - post titles are being queried here
37:17 - now the other thing we might want to do
37:18 - is wrap this all in an anchor tag so if
37:21 - we
37:22 - kind of stub out an anchor tag here and
37:25 - wrap our H2 what we want to do is we
37:28 - want to set the href to a particular URL
37:32 - that will take the user to that blog
37:34 - post so in this case we can Define this
37:37 - ourselves by using an ESX template
37:39 - literal string and we could say this is
37:41 - going to take the user to slash blog
37:42 - slash and then inside of our Temple
37:45 - literal string we can reference the post
37:47 - dot slug so this is going to be the
37:50 - sluggified version of that based on the
37:52 - name of that actual file so now each one
37:55 - of these should be a link to that blog
37:58 - post even though that page doesn't exist
38:00 - yet so if we hover on this on the bottom
38:02 - left you can see it links to slash bog
38:04 - slash blah blah if we click on this it
38:06 - doesn't exist and that's our
38:07 - responsibility to go and create that so
38:10 - we want to do a couple of things in here
38:11 - to make this look a little bit better
38:13 - we'll cheat a little bit and copy in
38:15 - some components to help us we'll start
38:17 - with the post list dot Astro component
38:20 - now in this case what we're going to to
38:22 - do is Define
38:24 - our props to take in a prop of post
38:27 - which is an array of a collection entry
38:31 - of the type of posts now again post is
38:34 - going back to that collection that we
38:36 - Define and we're just saying we have a
38:38 - an array of those posts that we're
38:40 - passing inside of here now then we have
38:43 - our Tailwind CSS to be able to display a
38:46 - CSS grid here with two columns on bigger
38:48 - screens and then go down to one column
38:50 - on smaller screens and then we display
38:52 - each individual post with a post
38:54 - component that we haven't created yet so
38:57 - inside of our post our inside of
38:59 - components we'll create one more
39:01 - component and this is going to be the
39:03 - post component that we can paste in
39:06 - all right so very similar we Define a
39:09 - prop in here where we're going to take
39:11 - one property which is a collection entry
39:13 - of posts so it's one post we then
39:16 - destructure that and now we can
39:17 - reference each piece of that data so
39:20 - notice we also have the same kind of
39:22 - Link in here with an H2 where we have
39:24 - the post.data.title then we have the
39:27 - link that's linking to slash blog and
39:29 - then the slug we also are referencing
39:32 - the body of our blog post but we're
39:35 - using a few CSS or Tailwind CSS classes
39:37 - or one and here to say line clamp of two
39:41 - this will give it a maximum line maximum
39:44 - display of two lines and then use
39:45 - ellipses to finish it out
39:47 - and then at the top of this we're also
39:49 - referencing our image which will come
39:51 - back to in a minute as we go and
39:53 - optimize these in a second so we can
39:55 - save this we can save the post list
39:57 - component let's go back to our Blog Page
40:00 - and let's get rid of this log and just
40:02 - make sure all this stuff looks good so
40:04 - let's scroll to the bottom of these logs
40:06 - in the terminal there we go and then now
40:08 - if we refresh our page here nothing
40:11 - looks different because we actually need
40:12 - to use that post list component so we'll
40:15 - replace the anchor tag that we wrote
40:18 - we'll reference the post list component
40:20 - and then we'll pass into that our post
40:23 - property that we queried above
40:25 - and then we'll need to also import this
40:28 - so I'm going to copy the layout import
40:30 - paste in and post list and then paste in
40:33 - or type in post list here as well
40:38 - and this is from the components not the
40:41 - layouts directory
40:43 - so now we should see that we're actually
40:45 - loading each of these posts and it's
40:46 - linking to the individual page for that
40:49 - post so notice this doesn't display yet
40:51 - because we haven't generated those pages
40:53 - but we do have the ability to link to
40:55 - each individual blog post which is
40:56 - pretty neat now let's go ahead and
40:58 - generate the pages for each one of these
41:00 - now to do this let's go to the Astro
41:03 - documentation really quick to kind of
41:04 - show you how we're going to so we can
41:06 - search for dynamic routes and in this
41:09 - case what we do is Define a file that
41:12 - basically is going to have a placeholder
41:13 - in the file name that tells us some
41:16 - property that we can use to then query
41:18 - and display the appropriate information
41:20 - for that post now in our case what we're
41:23 - going to reference is the slug of the
41:25 - blog post so inside of our Pages
41:28 - directory we can create a new folder
41:30 - slash or blog and then inside of here
41:33 - we're going to create a new file that
41:35 - says inside of brackets Slug and then
41:37 - dot Astro now what this means again is
41:40 - that we're going to be able to get the
41:42 - slug for each one of these posts by
41:44 - defining each one of the different
41:46 - routes that we have
41:48 - now the way we Define each one of these
41:49 - routes is we open up our JavaScript
41:52 - snippet here and then we're going to
41:54 - export a function called get static
41:56 - paths this is going to be an async
41:58 - function
41:59 - and then inside of here we want to query
42:01 - all of our posts so just like we did
42:03 - before we'll call git collection
42:06 - and we'll pass in the posts name
42:09 - and we'll need to import that git
42:11 - collection function so we'll import this
42:15 - git collection and we'll also import
42:18 - collection entry
42:20 - from Astro
42:22 - content
42:24 - and once we have each one of our posts
42:26 - what we want to use what we want to do
42:28 - is use those posts to be able to
42:29 - generate the path that should be created
42:31 - by Astro for each one of these different
42:33 - individual blog posts so we're going to
42:36 - create a paths property we'll take our
42:38 - post variable we'll map through it we'll
42:41 - get a reference to each post
42:44 - and then inside of here we want to
42:46 - return an object and this is going to
42:48 - have a couple of different properties
42:49 - the first one is params so now inside of
42:53 - our prams these are params that we can
42:55 - pass directly to this component so we
42:57 - want to pass in that slug property and
42:59 - it's going to come from post dot slug
43:02 - and then we want to pass in our props so
43:05 - our props is going to be the post itself
43:09 - so by the by exporting this get static
43:11 - pass function we're basically defining a
43:13 - path and a property for each one of
43:15 - these blog posts that will generate
43:17 - statically for application
43:19 - now from here we can kind of Define how
43:22 - this component is going to work so we'll
43:24 - Define the props type this is going to
43:27 - have one property of posts that's going
43:29 - to be a collection entry it's also going
43:31 - to be referencing that post collection
43:33 - so we'll have one post is being passed
43:36 - in we can then destructure this so we
43:39 - can get the post from Astro dot props
43:44 - and then from that post we can grab the
43:46 - content so we can destructure the
43:48 - content itself
43:50 - from the post.render function which is
43:54 - an async function
43:55 - now from here we want to kind of lay out
43:58 - a blog post page just like we've done a
44:00 - few times before so let's copy over a
44:03 - few of these different components and
44:04 - let's just paste this in so I have our
44:07 - layout
44:08 - we'll have our main and we'll have our
44:10 - H1 and we can import all of these at the
44:13 - top so we can import layout
44:15 - and we can import the H1
44:19 - and lastly our main
44:22 - and so we've imported all three of the
44:24 - components that we're going to use in
44:25 - here and just to start we can now start
44:27 - to update a bit of information based on
44:30 - this individual blog post so in this
44:32 - title we want this to actually be the
44:34 - title of the blog post that we're on so
44:36 - we can take post dot data
44:38 - dot title
44:41 - and then inside of our H1 on the page we
44:44 - can do the same thing so we want to
44:45 - reference our post.data DOT title
44:49 - so what we should have done now is we
44:51 - should have generated a page for each
44:52 - one of our blog posts that will in this
44:54 - case just display the title of that blog
44:56 - post so if we click on one of these blog
44:59 - posts from the slash blog page it should
45:01 - take us to this page but it looks like
45:03 - we have some sort of error in how we
45:05 - defined our git static path function so
45:08 - it's expecting an array but got
45:10 - undefined so let's go back up and double
45:12 - check that
45:14 - so it looks like we defined our path but
45:16 - we didn't return this in the end so the
45:19 - most important part about the get static
45:20 - path function is it has to return those
45:23 - paths so that Astro knows what to do
45:25 - with them to generate the individual
45:27 - pages
45:28 - so hopefully that will handle this now
45:30 - if we refresh we see the title now
45:33 - coming up at the top and we have our
45:34 - individual blog post Pages for each of
45:37 - these individual blog posts so that's
45:39 - great we have each of those defined we
45:41 - can now kind of copy a little bit of
45:43 - code from the post component so if we go
45:46 - back to the post component and look at
45:48 - the image we can now copy this end just
45:52 - so we're starting to display some more
45:53 - things on here so if we paste this in
45:56 - under the H1
45:58 - we should now see our images popping up
46:00 - so it looks like it's not quite the size
46:03 - that we want because we're now shrinking
46:05 - this to be a width of 600 so we can
46:08 - update this to be 1024 and I think that
46:11 - should give us now kind of the full
46:13 - screen or almost full screen page that
46:16 - we're looking for and then lastly we can
46:19 - render this content component that we
46:22 - got from the render function of our
46:24 - posts so up here we called post.render
46:27 - we got the content component we can
46:29 - render this but it's not going to look
46:31 - great so you can see we have all of our
46:33 - content here but this doesn't quite look
46:34 - great and that's because we don't have
46:36 - any Styles defined for this
46:38 - now in our case what we're going to use
46:40 - is the Tailwind CSS typography package
46:43 - to handle this for us so Tailwind CSS
46:45 - typography you can search this basically
46:48 - what we're going to do is install this
46:49 - plugin and then we'll be able to use
46:51 - this inside of our page to be able to
46:54 - display this stuff appropriately so I'm
46:56 - going to copy this install command let's
46:58 - go back let's paste
47:01 - this in this is going to install the
47:03 - Tailwind CSS typography package
47:06 - then inside of our Tailwind config we
47:11 - need to make sure to reference this so
47:12 - we're going to inside of this array
47:14 - require
47:15 - and then we're going to require the
47:17 - Tailwind
47:19 - CSS typography package
47:22 - and then lastly for this to work inside
47:25 - of where we render our content we're
47:26 - going to need to wrap this in a class
47:28 - or a div
47:30 - that has a few classes primarily the
47:33 - pros and Pros 2XL class so those are the
47:36 - classes that kind of activate this
47:38 - extension or to be able to use that
47:40 - plug-in to be able to render all of our
47:41 - content
47:42 - so let's go ahead and run this with our
47:44 - run Dev command we can now come back to
47:46 - our application we can refresh this and
47:49 - we should see that this now is looking a
47:50 - lot better and this is starting to feel
47:52 - like a real blog so we have if we go
47:55 - back we have a list of all of our blog
47:56 - posts
47:59 - and then we can click on the individual
48:00 - Pages see the image and see all the
48:03 - content which is pretty neat
48:04 - now one thing that's interesting that's
48:06 - not very optimized on here is the way
48:08 - we're referencing our images so if we go
48:10 - into our Network Tab and just look at
48:13 - our images as they load in we'll notice
48:16 - a couple of things a couple of things
48:18 - we're loading all of these images even
48:20 - before we scroll down to see them so
48:22 - that's a little bit unnecessary it would
48:24 - be more optimal if we were only loading
48:26 - images as we're getting close to
48:27 - scrolling down to them then we'll also
48:29 - see that these are being loaded as JPEG
48:31 - files which are not the most optimal
48:33 - format webp would be a better format and
48:36 - see that these are really big images so
48:39 - six megabytes four megabytes Etc so we
48:41 - can use the Astro image component to
48:43 - make this a lot better and much more
48:45 - optimal so let's go back to the Azure
48:47 - documentation and let's just search for
48:49 - image and let's just go to the top level
48:51 - images here
48:52 - and let's go down to the actual image
48:55 - component which is what we're going to
48:56 - use to be able to do a lot of
48:57 - optimizations with our images
49:00 - so we can import the image component
49:02 - from the image assets namespace and
49:06 - basically just replace the regular IMG
49:08 - tag that we were already using we'll
49:10 - have to do a few more things in here but
49:12 - let's start with that so inside of our
49:14 - post component we can copy in the import
49:16 - for this image component and we can now
49:19 - replace that IMG with our image
49:21 - component now if we come back to our
49:24 - application we can see that this is
49:26 - going to work but nothing has really
49:28 - changed so we're still loading all of
49:30 - these files and they're still jpegs and
49:33 - they're still pretty big so one of the
49:35 - things we want to do is actually move
49:37 - this image's directory into our content
49:39 - directory
49:41 - and actually specifically we're going to
49:42 - move this into our slash post directory
49:45 - because these are going to be all the
49:46 - images that are associated with these
49:48 - posts now then inside of our markdown
49:51 - we're going to update if you remember we
49:53 - changed this at the beginning we're
49:55 - going to select this little bit and
49:57 - we'll do command shift F or Ctrl shift F
49:59 - to select all of that and what we want
50:01 - to do is we want to update this to go
50:03 - from slash to dot slash so slash implies
50:07 - that it should look at the root of the
50:08 - application which is at the end of the
50:10 - URL dot slash now means we should look
50:13 - relative to where the actual file is so
50:16 - in this case it's going to be relative
50:17 - to where this markdown file is and
50:20 - that's going to be inside of that post
50:21 - directory so I'm going to update each
50:23 - one of these posts to reference
50:25 - dot slash image
50:28 - and we would think that would work but
50:30 - we actually have an error in here of
50:33 - something isn't working that's because
50:35 - we need to go back to our config for
50:38 - Content Collections and we need to
50:40 - update our image property to actually
50:42 - use and image object that Astro gives to
50:45 - us
50:45 - so what we're going to do is turn
50:47 - instead of returning this object
50:49 - directly we're going to turn this schema
50:51 - value into a function
50:55 - and so this is going to then return that
50:57 - Z dot object but by defining this as an
51:00 - a function we can now destructure a
51:02 - property called image and now we can
51:05 - reference our image type to be of Type
51:09 - image or call that image function so
51:11 - this is going to more explicitly
51:13 - references as an image in a way that
51:15 - Astro can understand in a way that could
51:17 - also import those images from the
51:19 - content or inside of the source content
51:22 - directory so let's try this one more
51:24 - time
51:25 - run this again
51:27 - so the first thing that you notice so
51:29 - you might notice is that the URL for
51:30 - these images are looking kind of weird
51:32 - that's because Astro is using kind of
51:34 - internal URLs to Define how to render
51:37 - these images so if you look really
51:40 - closely you can see it defines the
51:41 - format and width and height Etc but we
51:44 - can see that these are loading webp
51:45 - images and that these are much smaller
51:47 - than what they were originally so our
51:49 - page now is going to load much faster
51:51 - because these images are much more
51:53 - optimized and they're a better format
51:55 - and they're much much smaller now if we
51:57 - click on one of these individual Pages
51:58 - notice that this isn't working and
52:00 - that's because we're referencing this
52:02 - using the old image IMG tag which can't
52:05 - be referenced here so let's go into the
52:08 - slug page
52:10 - and let's just update this to use the
52:12 - image component from Astro assets and we
52:15 - should be able to just say this as is
52:17 - and have this be working so now we're
52:19 - able to load this image and this should
52:21 - also be choosing a webp version of this
52:24 - which should be smaller than what it was
52:25 - originally so now we have a working list
52:28 - of all the blog posts we can then go to
52:30 - the individual page for a blog post we
52:32 - see an optimized image and we can see
52:34 - all the content associated with that
52:36 - blog post as well now with all this in
52:38 - place there's one really neat thing that
52:40 - we can add that's really easy in Astro
52:42 - and pretty amazing if we look at
52:44 - navigating between these Pages we see
52:45 - kind of this page refresh we actually
52:48 - don't have the about page created but we
52:50 - see kind of the page refresh as we go
52:52 - between individual pages and we can
52:54 - actually make this a little bit easier
52:56 - by using the view transitions API in
52:58 - Astro this will only take a second to
53:00 - add but it does make a big difference in
53:03 - how you can view and navigate through
53:04 - your application so inside of the view
53:08 - transitions API you can you can read a
53:10 - lot more about this we can basically
53:12 - import this component and then use it
53:14 - inside of the head of any page that we
53:16 - want to have those transitions between
53:18 - so since we want to by default use this
53:21 - on every single page we can actually
53:23 - just import this inside of our layout
53:26 - file and then somewhere in the head we
53:29 - can just reference this View
53:32 - transitions component and save and now
53:34 - we're actually going to be be able to
53:36 - see a difference between how we navigate
53:37 - our Pages this is pretty neat so let's
53:40 - go from this page to home notice we get
53:43 - kind of that animation we go to blog we
53:45 - get animation we see this page we get
53:47 - the animation so it looks like a much
53:49 - much better experience of navigating
53:51 - between pages with just one component
53:53 - that we can add now there's some
53:55 - additional ways that you can customize
53:56 - this you can also Pass State from one
53:58 - page to another which is pretty neat we
54:00 - won't go any deeper into this but it is
54:02 - nice to know that we can add this pretty
54:04 - easily to make the transitions that our
54:06 - application look look a lot better now
54:08 - one additional thing I wanted to show
54:09 - you is that you have the ability to not
54:11 - only use markdown inside of Astro for
54:14 - your content you can also add MDX and
54:17 - the support for this comes with a
54:19 - an integration that we can add with one
54:22 - of those npx Astro ad commands so let's
54:25 - go and add support for markdown by
54:27 - pasting in this command this will make a
54:30 - change to the Astro config and install
54:32 - that package so we'll just go ahead and
54:33 - say yes to all the things that it needs
54:35 - to do yes all right so that should be
54:38 - added
54:39 - and now we can do an npm run Dev to
54:41 - start this again and what we should see
54:43 - if we come back to our markdown files
54:47 - for example the behind the scenes is we
54:49 - can now rename this file
54:52 - and we could rename this to an MDX file
54:56 - and now all of this should still stay
54:58 - the same so if we come back to the
55:00 - application so if we refresh this we see
55:02 - this stays the exact same which is
55:04 - exactly what we wanted but now we can
55:06 - harness the power of MDX in addition to
55:08 - just the markdown that we were already
55:09 - using
55:11 - now if we scroll back up there's a quick
55:12 - section on why MDX so now we're not
55:16 - going to dive deep into this but there
55:17 - are lots of really cool things that you
55:19 - can do like MDX only features so you can
55:22 - use exported variables inside of MDX so
55:25 - if you wanted to create variables at the
55:27 - top you could then reference that you
55:29 - can also use your front matter variables
55:31 - so you could use those directly inside
55:33 - of here as well and the last thing is
55:35 - you can reference Astro components and
55:38 - UI components of other Frameworks like
55:40 - react view Etc inside of this as well so
55:44 - if we look in the example in here inside
55:46 - of the MDX part we're importing two
55:48 - different components one Astro component
55:51 - and one react component that we can then
55:54 - display right in line inside of our
55:56 - markdown content now this is really
55:58 - useful for as an example to do like a
56:00 - call out inside of your blog post if you
56:02 - want to customize a call out to send
56:04 - somebody to a newsletter or something
56:06 - else you could Define those components
56:07 - and bring those into your H to your MDX
56:11 - files anytime that you want or need
56:15 - so we're not going to dive any deeper
56:16 - into MDX that's kind of a section on its
56:19 - own but it is nice to know that you have
56:20 - the ability to work with both markdown
56:22 - and MDX files in your content with Astro
56:26 - now we can start to work on deploying
56:28 - this application so we initialize this
56:31 - initially as a GitHub or a git
56:34 - repository so we can now do a git status
56:36 - and we can see all the things that we've
56:38 - changed now in this case we can add
56:40 - everything with Git add star and then we
56:42 - can do a get commit Dash M to say
56:45 - initial commit and all of this stuff has
56:49 - been committed to this local git
56:50 - repository now the next step is we we
56:53 - need to connect this to a GitHub
56:54 - repository that we can then use to
56:57 - deploy to netlify or versal so on
57:01 - github.com you can go to the top right
57:03 - you can click new repository and then we
57:06 - can call this FCC
57:08 - Astro
57:10 - crash course test
57:13 - we'll have this be a public directory we
57:15 - don't want to add a readme because we'll
57:17 - take care of that ourselves we don't
57:18 - want to add it get ignore so we can
57:20 - create this very blank repository and
57:22 - then what we'll do is just take the code
57:26 - into our terminal that pushes from an
57:29 - existing repository to our local git
57:32 - repository to this GitHub repository so
57:35 - you can copy this section where it adds
57:37 - the origin and the remote or it adds the
57:40 - remote origin and then pushes everything
57:43 - locally to that remote project inside of
57:46 - GitHub
57:47 - all right so it looked like it pushed
57:49 - all of that code up if we come back to
57:51 - the GitHub repository we can come in
57:53 - here and see that this has been added
57:55 - and so now our next step is to go to
57:57 - we'll start with netlify we can do
57:59 - netlify and versal these are both free
58:01 - so you'll sign up with a free account
58:02 - after you do you can log in on netlify
58:04 - and basically what we're going to do is
58:06 - add a new site where we're going to
58:08 - import from an existing project we'll
58:11 - choose to deploy with GitHub and then
58:13 - what we'll need to do is go and choose
58:14 - that project that we just created so I
58:16 - can search FCC Dash and this should be
58:19 - enough to pull up that project all right
58:22 - so we can now pull this in we don't need
58:24 - to customize anything it should pick up
58:26 - on what the build command is
58:27 - automatically so we can go into go ahead
58:30 - and deploy this and it should run a
58:31 - build and then have the site ready for
58:33 - us to use after it's done
58:36 - all right so it looked like this build
58:38 - has finished you can now kind of choose
58:40 - the random URL that they gave you and we
58:42 - should see that this is deployed our
58:44 - application successfully so we can see
58:46 - our Blog Page we can go and click on
58:47 - individual ones as well so that is on
58:50 - netlify we could also choose to deploy
58:52 - this on Verso almost the exact same
58:54 - process you'll sign up for a free
58:56 - account you can then come and add a new
58:58 - project you're going to import this from
59:00 - a git repository choose from that FCC
59:03 - crash course project and GitHub choose
59:06 - all the defaults and then go and deploy
59:08 - and then after this is finished we
59:10 - should have this deployed on versel as
59:12 - well
59:13 - all right so it looks like this has
59:15 - finished on versel we can continue to
59:16 - the dashboard then we can visit this at
59:19 - the random URL that it's generated for
59:20 - us also now so far everything that we've
59:23 - done with Astro has been statically
59:26 - generated pages but we can start to look
59:28 - into the SSR capabilities of Astro so
59:31 - Astro actually has the ability to do a
59:34 - full back end if you so decide and you
59:37 - have the ability to Define what type of
59:40 - output your site is going to have so by
59:43 - default it is static which takes no
59:44 - additional configuration for us to do
59:46 - but there also is the ability to Define
59:48 - it as a server rendered application by
59:50 - default it says to use this one most or
59:53 - all of your sites should be server
59:54 - rendered you can also opt into
59:56 - pre-rendering or static Pages for
59:58 - individual Pages you also have the
60:00 - option to do hybrid which is basically
60:02 - saying it's going to pre-render by
60:04 - default and then you can Define for
60:06 - individual pages to opt out of
60:09 - pre-rendering before we make this
60:11 - transition into server-side rendering in
60:13 - our code let's actually take a couple
60:14 - minutes to talk about the difference
60:15 - between static site generation or SSG
60:18 - versus SSR which is server side
60:20 - rendering and we'll talk about this
60:22 - while using diagrams to kind of explain
60:23 - the differences between the two
60:25 - so let's start with what we've already
60:27 - been using which is SSG or static site
60:29 - generation and this is what Astro does
60:31 - by default quick reminder if you want to
60:33 - follow up on this diagram later on you
60:35 - can find the link in the description
60:36 - below so what happens here is when we
60:38 - deploy our application we deploy this to
60:40 - something like netlify or versel or
60:42 - there's lots of other hosts that you
60:43 - could use as well so when this thing is
60:46 - deploying it actually runs a build and
60:48 - during that build process what happens
60:49 - is for each one of those individual
60:51 - pages that we have in our Astro
60:52 - application it actually generates the
60:54 - HTML file at build time for each one of
60:57 - those so we have one for our index.html
61:00 - page we have one for our blog.html page
61:02 - and then additionally we have a an HTML
61:05 - page created for each one of our blog
61:07 - posts and that's where we Define that
61:09 - export or we exported that get static
61:11 - paths function where we defined each one
61:14 - of the paths that we wanted to be able
61:15 - to support and then to generate the
61:17 - content for
61:18 - so the important part about this is SSG
61:20 - at build time is going to go ahead and
61:22 - create the content or the HTML Pages for
61:25 - each one of these Pages at build time so
61:28 - that it's ready and accessible by the
61:30 - time someone comes and tries to view one
61:32 - of these blog posts for example or one
61:34 - of these other pages and that's an
61:36 - important next step to talk about is the
61:37 - actual request time so what happens well
61:40 - these individual files that are
61:42 - generated during the build process are
61:43 - then saved to a CDN or a Content
61:45 - delivery Network that are replicated all
61:47 - across the world what this means is that
61:49 - those files now are very fast to access
61:52 - and return When a request comes in from
61:54 - the browser so let's say that you go to
61:56 - the browser and you type in local not
61:58 - localhost but you type in the URL of the
62:00 - application that you're trying to work
62:01 - on and you go to the index page that's
62:04 - going to make a request to the CDN it's
62:06 - going to now return that index.html page
62:08 - now let's say you then want to go to the
62:10 - blog page while you make another request
62:12 - to the CDN the CDN now is going to
62:13 - return blog.html or if you're going to
62:16 - one of the specific Pages for an
62:17 - individual blog post it's going to
62:20 - return those pages as well again because
62:22 - they've already been predefined now this
62:24 - starts to differ a lot when we look at
62:26 - SSR or server-side rendering so I've got
62:29 - almost an empty diagram here for SSR
62:32 - build time so with server-side rendering
62:34 - you're still going to have a build
62:35 - process to go through and run all of
62:37 - your code you may run tests if you have
62:39 - them but basically this is going to go
62:41 - through and do the build of your
62:43 - application and you may have some static
62:45 - Pages we'll talk about how to mix these
62:47 - in a second but for the most part what
62:50 - this is going to do is now kind of have
62:51 - that server configured so that it can
62:53 - handle those requests as it comes in so
62:56 - notice there's no predefined HTML pages
62:58 - that are already calculated for us that
63:01 - means if we scroll down now that
63:02 - something has to happen at request time
63:04 - when this request comes in from the
63:06 - browser so notice instead of having a
63:08 - CDN we now have an application server so
63:11 - requests will go from the browser to the
63:13 - application server now for this
63:15 - application server to respond back most
63:17 - likely specifically in this case with
63:19 - our blog post individual blog post Pages
63:21 - it's going to need to get the
63:23 - information necessary for those blog
63:25 - posts from the database now in our case
63:27 - we're not using a traditional database
63:28 - we're using embedded markdown in our
63:30 - source code but it basically works the
63:31 - same way so let's say that we make a
63:34 - request to slash blog slash blog dash
63:37 - one for example that's the website that
63:39 - we're trying to go to well this is going
63:41 - to now make a request to the database
63:44 - let's add a new piece of text in here
63:45 - and it's going to say give me all the
63:47 - information that you have about blog one
63:49 - so from the database the database is
63:52 - going to return back the data for blog
63:55 - one to the application server the
63:57 - application server is now going to turn
63:59 - that back into an HTML page which will
64:02 - look like if we add our corresponding
64:05 - piece of text to your slash blog
64:07 - slash blog-1 Dot
64:10 - HTML we can move this up a little bit
64:13 - for readability so basically with SSR or
64:16 - server side generated Pages or
64:18 - applications every request that comes in
64:20 - is going to go to an application server
64:22 - it is it is then going to query the
64:24 - database or in whatever format it is
64:26 - which might be embedded markdown that
64:28 - will return the data the application
64:30 - server will then take that content and
64:33 - turn it into an HTML page that can be
64:34 - rendered on the browser and viewed by
64:36 - the user so that's a quick overview of
64:38 - the difference between SSG and SSR let's
64:41 - go back to our code and start to make
64:42 - this work inside of Astro
64:45 - so in this case we can start by going
64:47 - into the Astro config and we can choose
64:50 - the output property to be
64:52 - server now if we try to run this we
64:55 - should see that this is going to break
64:56 - and that's because we're doing a couple
64:58 - of things that are specifically geared
65:00 - towards statically generated pages so
65:03 - let's go to our running application and
65:06 - refresh and we see that we now are
65:08 - having an issue on the individual blog
65:10 - post pages and that's because the way
65:12 - that we're generating those pages is
65:15 - using this get static paths function and
65:17 - that doesn't exist inside of an SSR
65:21 - deployed application now one thing we
65:23 - could do is we could look in the
65:25 - documentation and we could see how to
65:27 - define this as a pre-rendered page that
65:30 - means it's going to generate this page
65:31 - statically so if we add this at the top
65:34 - of this file and refresh this actually
65:35 - will go back to working as we expect so
65:38 - now we see we have that blog post we can
65:40 - go back to all of them and go to another
65:42 - one Etc but just for practice and kind
65:45 - of experience let's go back and get rid
65:48 - of the pre-render and let's see what it
65:50 - would take to actually figure out how to
65:52 - generate generate these Pages inside of
65:54 - an SSR environment now in this case what
65:57 - we're going to do is go back to our page
65:59 - and we can actually get rid of this
66:01 - entire get static paths function
66:04 - and we can
66:06 - start at the top here and most
66:07 - importantly what we're going to do is
66:09 - destructure a property called slug from
66:12 - Astro dot params now what Astro is going
66:15 - to do is because of this slug definition
66:18 - up here it's going to pass this log into
66:20 - the Astro dot params object to let us
66:25 - reference it and use that in here to
66:27 - dynamically query that post from Astro
66:29 - we can also get rid of our definition
66:32 - for the posts and our prop types and
66:35 - then what we're going to do is we're
66:36 - going to get that post from in a
66:39 - weighted call to git entry by slug now
66:44 - this is a function up here that comes
66:45 - from Astro content it's a function that
66:47 - they give us and we can say what content
66:50 - collection we want to get this from
66:51 - which in this case is post and then we
66:53 - can pass in the slug now in this case
66:56 - it's going to throw an error or show us
66:57 - the typescript error because slug could
66:59 - be potentially undefined so we're just
67:01 - going to say this is going to be a
67:03 - string so that we get our appropriate
67:04 - type in here
67:06 - now in this case it's throwing an error
67:08 - because it's saying that we might query
67:09 - for a post that also doesn't exist and
67:12 - what we could do we could say if that
67:14 - post doesn't exist we could do an astro
67:17 - redirect so we could return an astro
67:19 - re-direct to
67:22 - the slash four or four four or four page
67:25 - just just to show that that thing wasn't
67:27 - found now we could go and customize this
67:29 - and do anything that we wanted to handle
67:30 - it but in this case this ought to be
67:32 - enough just to get this working and now
67:34 - have these dynamically generated Pages
67:36 - be dynamically generated with
67:38 - server-side rendering instead of
67:39 - statically generated pages
67:41 - so if we go back we should see that we
67:43 - have all of these showing up in our blog
67:45 - index page and then clicking on one
67:47 - should be able to show all the details
67:48 - for this blog post as well so we've now
67:51 - completely flipped how we're rendering
67:53 - these blog posts Pages now they're
67:56 - server side rendered and what this means
67:57 - just to clarify is as the request comes
68:00 - into this URL it's going to send a
68:02 - request to the server the server is
68:03 - going to query based on that URL the
68:05 - individual blog post return that back
68:08 - and then use that to render the page
68:09 - that shows up on the screen as opposed
68:11 - to previously
68:13 - we had each of these Pages generated
68:15 - statically at build time for all the
68:18 - blog posts that we have now the cool
68:20 - thing about this is we can still go back
68:22 - and configure individual pages to be
68:25 - configured as static so as an example on
68:28 - the home page there's no reason that
68:30 - this shouldn't just be a static page
68:33 - so we could still export a kant's pre
68:36 - render variable that's set to true and
68:39 - now we'll mark this index page as static
68:42 - so if we go back here this will be a
68:44 - static page versus this is server side
68:47 - rendered and this individual page or all
68:50 - the individual Pages for our blog post
68:53 - are server side rendered as well now I
68:56 - do want to show one more thing that you
68:58 - can do is when you have server side
69:00 - rendered enabled you can Define API
69:03 - endpoints so we can search for Server
69:05 - endpoints in here and basically what
69:07 - that allows us to do is have a file
69:09 - inside of our Pages directory that just
69:12 - basically serves as an API endpoint
69:14 - instead of actually returning an astro
69:16 - component so if we go into our Pages
69:18 - directory we could create a new folder
69:20 - slash or called API and then we can just
69:24 - create a test dot TS now notice this is
69:27 - a TS file instead of an astro component
69:29 - again because it only runs on the server
69:32 - and if we look in here just copied kind
69:34 - of the basic uh starter code that they
69:36 - give us but we're not going to reference
69:37 - any of this so we can kind of get rid of
69:40 - all of this information about products
69:43 - and then we can return back an object
69:46 - with a message that says hello world so
69:49 - this is how we Define a starter function
69:52 - four API endpoints so in this case we're
69:55 - also not referencing this params
69:57 - parameter so what we defined is a git
70:00 - endpoint where we're basically just
70:01 - going to return hello world as Json so
70:04 - we can save this we can then go back to
70:06 - our application we can then open the URL
70:09 - and go back to the root and then slash
70:12 - API slash test and we should get back
70:14 - that message with hello world now what's
70:17 - really cool is we can Define all of our
70:18 - HTTP endpoints with this as well so we
70:21 - could also
70:23 - export a post function if we wanted to
70:26 - we could return with the same thing now
70:29 - unfortunately there's not a way to be
70:30 - able to test this inside of the browser
70:32 - because the browser can only send git
70:34 - requests so I have the postman extension
70:36 - inside of vs code installed so if you
70:38 - wanted to follow along you can install
70:40 - the postman extension this has been kind
70:42 - of my default way of doing testing apis
70:45 - for a long time but now they have the
70:47 - the vs code extension to go with it so
70:49 - we can create a new HTTP request and we
70:52 - can now send a post request to the same
70:55 - general idea so
70:57 - localhost4321 and this will be slash API
71:00 - slash test
71:02 - and we'll send that and we'll get the
71:03 - same response that we just got back with
71:05 - the message of hello world now inside of
71:08 - handling our post requests
71:10 - we could also destructure the request as
71:13 - well and then we could get the body
71:16 - from that request
71:18 - by calling a weight request dot Json
71:22 - and then we could just return this just
71:24 - to show that we're actually getting it
71:25 - so let's just return that body which is
71:27 - going to be an object so we're
71:29 - destructuring this request notice we
71:31 - also don't have typescript types around
71:33 - this so we could Define this a little
71:35 - bit differently if we wanted to I'm just
71:37 - going to copy in a new kind of function
71:39 - definition here so this is going to use
71:41 - in Arrow function syntax where we Define
71:44 - now our posts to be an API route so we
71:48 - can add the missing import for that and
71:50 - now it's going to give us intellisense
71:52 - for the request so if we do dot we can
71:54 - see all the things that we have access
71:55 - to there we also then can see things
71:58 - that we might have on our params in here
72:00 - as well so we can now save this and what
72:03 - we should see is if we go back to our
72:05 - request this is a post request but it
72:07 - doesn't have a body so we can now inject
72:10 - in here a raw body with Json and we
72:13 - could have an object and we could have a
72:15 - property of a name we could say Astro
72:19 - crash
72:21 - course and then what this should return
72:23 - back with is that same object that we
72:25 - can see down here so we have the ability
72:27 - in Astro to Define any and all kind of
72:30 - server capabilities that we wanted we
72:32 - could handle form submissions we could
72:33 - Define API endpoints for all of our
72:35 - different methods which is really really
72:37 - cool and really really powerful so I
72:39 - think the only next step is to show how
72:41 - do we actually deploy this to netlify
72:43 - and versel now that we're doing server
72:44 - side rendering so inside of here we have
72:48 - a plug-in or an integration for both
72:50 - netlify and versel so I'm going to copy
72:54 - and paste this command so here's the
72:55 - netlify one
72:57 - and let's paste this in here for netlify
72:59 - and this is going to add that package
73:02 - and then it's going to make an addition
73:04 - to our astro.config file to use netlify
73:08 - as the host so notice it says adapter is
73:11 - netlify we'll say yes
73:13 - and then if we look inside of the Astro
73:15 - config we should see that it's
73:16 - referencing adapter and netlify here so
73:19 - now what we want to do is we we will add
73:23 - everything we'll do a git commit with a
73:26 - message of added SSR and deploy to
73:31 - netlify
73:32 - and then since this is already connected
73:34 - to our netlify site we can push this and
73:37 - netlify ought to automatically pick this
73:39 - up pick up that change let's just log
73:41 - back in it should pick up that change
73:43 - automatically and it should be building
73:45 - a new version of that that now is going
73:47 - to be our server-side rendered version
73:49 - so we'll let this go through our build
73:51 - and then we'll open this up to make sure
73:52 - everything looks okay
73:54 - now as this is building one thing to
73:56 - notice it's referencing netlify
73:58 - functions I actually just missed it but
74:00 - inside of building you can see that it
74:01 - references deploying this to netlify
74:04 - functions so that's how it's actually
74:05 - able to deploy this it looks like
74:07 - everything is complete we should be able
74:09 - to open this production deploy hopefully
74:12 - everything now continues to look okay
74:14 - just like it did before and we can see
74:16 - the individual blog post Pages as well
74:18 - now next we'll need to do this for
74:21 - versel so we can copy in that same
74:23 - command and then add in versel and this
74:27 - is going to go through that same process
74:28 - add the versel package and then it's
74:30 - going to update the Astro config to
74:33 - reference that versl adapter so we can
74:35 - say yes to that as well so now this is
74:37 - updated we can add everything again we
74:40 - can commit and say hosting on versa then
74:45 - we can push this now do note that this
74:48 - deploy in netlify we're still connected
74:50 - to netlfi so this will kick off another
74:52 - build that next build will fail in
74:54 - netlify but what we do want to see is
74:57 - inside of our cell we should see that
74:59 - this is kicking off a new build and
75:01 - versaille so we can see under the
75:04 - building tab that it's going through and
75:06 - it's doing this
75:07 - so when that finishes we should see that
75:10 - we have the same deployed application
75:12 - hosted now on versel using SSR
75:16 - all right so it looks like it's finished
75:17 - we should now be able to visit this and
75:19 - we have the same experience where we can
75:21 - go to blog we can see all the pages we
75:23 - can go to the individual page Etc
75:26 - now going back to the idea of SSR inside
75:29 - of Astro one of the coolest things that
75:32 - you could do in addition to API
75:33 - endpoints and other things is you could
75:35 - start to incorporate authentication into
75:37 - your applications so you have the
75:39 - ability with Astro to create
75:40 - full-fledged full stack applications and
75:43 - you can do authentication in here by
75:45 - referencing cookies as an example so you
75:48 - could track a session in a cookie for a
75:49 - user and you could gate pages to prevent
75:52 - users from getting to certain pages if
75:54 - they're not logged in or if they don't
75:55 - have certain permissions or anything
75:57 - like that with authentication in that
76:00 - full Astro course we actually build a
76:02 - basic authentication strategy using SSR
76:05 - and Astro as well as taking advantages
76:09 - of taking advantage of cookies and then
76:12 - having that reference users that are
76:14 - saved inside of a Zeta database so
76:16 - another really cool full stack
76:18 - implication or example of what you can
76:20 - build with Astro now if you want a full
76:23 - overview of what we build in that course
76:24 - you can go to Astro core Dev and it
76:27 - breaks down everything that we're going
76:28 - to build inside of this full application
76:30 - including all the topics that are
76:32 - covered the pricing Etc so if you're
76:34 - interested in that you can find that at
76:36 - astrocourse.dev
76:38 - all in all I hope you're as excited
76:40 - about Astro as a framework as I am
76:42 - obviously I'm pretty excited so thanks
76:45 - for checking out this crash course and I
76:46 - really hope that you enjoyed it

Cleaned transcript:

Astro is an allinone web framework for building fast contentfocused websites like landing pages blogs technical documentation and more in this course James Q Quick will teach you about this increasingly popular framework James is a popular instructor and keynote conference speaker he's the perfect person to teach you about Astro let's learn all about Astro one of the most exciting and upandcoming JavaScript Frameworks my name is James he quick and I absolutely love Astro so in this crash course we're going to cover some of the Core Concepts of Astro along the way we'll talk about file based routing creating and managing markdown and MDX contact with content Collections and typescript we'll talk about Dynamic routes and we'll even at the end of this video get into deploying this to netlify and versel we'll also talk about the serverside capabilities of Astro going from a statically generated site to a serverside rendered site and show you how you can add server endpoints to your Astro application as well lastly we'll talk about a few neat features of Astro along the way like view transitions which allows you to add beautiful transitions between your pages and your Astro application with just one line of code now if you enjoy what we cover in this crash course and you want to learn more you can check out my full course at astrocourse.dev to learn all the ins and outs of Astro 3.0 that said let's go ahead and get started let's start on the Astro documentation page where we can see the getting started instructions for creating a brand new project with Astro version 3 which is the most recent version of Astro now on this documentation page they kind of give you an overview some of the things that we've talked about some key features Etc and then if you scroll down they'll give you a couple of ways to get started with Astro one cool way to do that is with the astro.new website and what this is is a collection of different Astro projects that you can open up that have already been created and kind of get started working with them right inside of Stack Blitz now in this case we're going to create our own project from scratch so we're going to do this inside of our own vs code window and terminal to be able to create the project and then go and work and build out the tutorial or the blog that we're going to build now one thing I do want to show and we'll kind of reference this throughout this crash course is the ability to search for anything that we might want in this course on the Azure documentation page so once you get to the Astro docs you can come up to the top left and you can click to open the search window and you can search for a server or anything server side rendering for example and then click on one of these and go straight to those pages the other thing I want to show you that's pretty neat is on this page you can hold command K on Mac or control K on Windows to be able to pull that up as well so you don't have to go and click that yourself you can just open that with the shortcut window that said what we're going to do is copy this command to be able to create a brand new Azure project and then run this in our terminal so that we can get started so I'm going to scroll over to my vs code window and this is an open mtvs code window and I'm going to first switch over to the directory that I want to create the project so I'm going to switch into code and then my demos directory and then from here I'm going to paste in that command from the Azure docs to create the new project so once I press enter this will ask me a few different things first of all are we okay installing the package that's needed to generate our project and this is actually a good error to have here so with the latest version of Astro you're required to have a version 18 or higher of node.js to be able to run the installer so I wanted to leave this in as a reminder that you'll need to be working with a version 18 or higher now for me personally I use NVM to manage my different versions of node to handle this this is the easiest way that I found to handle working with different versions of node so I can use my NVM command and then NVM use and then type 18 and this will let me use a version of node that is a 18. now I can also use NVM to install a version of node like 20 for example and that will go and install a different version of node that I could use at any time but in this case since I'm now using version 18 I can scroll back through my commands and run that same create command inside of my terminal now you see we get the really awesome animated experience where Astro is going to walk us through creating this new project so in this case we need to give it a folder that we're going to create the project in I'm going to call this FCC Astro crash course so you'll just do dot slash and then whatever the folder is of whatever the name is of the folder that you wanted to create in this case we're going to start with sample files you could also choose a Blog template where they'll have a lot of the stuff done that we will be building from scratch you could also additionally choose an empty project to just start completely from scratch in this case we'll accept the sample files and what it's doing now is it's going to start to copy over the sample files which is done and then it's going to ask whether or not we want it to install the dependencies and we can press enter on yes and let it go and run and install all of these dependencies so we'll let that run for a second and come back when it's finished all right so those dependencies have been installed and the next question is do we plan to write typescript which in this case we do so we'll click yes and then we'll choose the strict or recommended version of how strict with typescript we should be lastly the question is do we want this to initialize a new git repository in this case we'll say yes because we're going to use this repository to deploy this later on to netlify and versel so we'll click yes here and then we get our out animation from Houston which is the Astro mascot we'll come back to Houston in a little bit and the next thing I want to do is open this project inside of vs code so I can use the command code R which means to reuse the window that I'm currently in and then I'm going to choose my SEC Astro crash course window notice it pops up here with this intellisense if you're curious where this little window is coming from this is coming from an extension called fig dot IO which is really great to kind of supercharge your powers inside of your terminal so I'm going to press enter and then we'll open this up inside of that same window in vs code and now I'm going to go to the bottom and open my terminal again and inside of here I'm going to run npm run Dev and this should now start our Astro project and it will run it at Port 4321 they chose this port because it is kind of like four three two one blast off which is kind of neat so I'm going to open a new tab in my browser and open up my browser to localhost 4321 and you see this is the starter application that we get with Astro where we have a welcome to Astro we have a little code challenge of how to make an update to this which is right here then we have links to documentation integration themes Community Etc so we have our beginner Astro application created let's go and walk through the code and talk a little bit about what all is there so first off we have our public directory this is where we would store any public assets like images or other things that we want to be publicly available from our site now these are going to be directly available after the end of the URL so what this means is since we have favicon.svg we could come to the end of our URL and type in favacon.svg and now that'll take us to that file which is not going to show a whole lot because it's an SVG and we're not going to have good visibility here but we do have the access to be able to access that directly so anything that you put inside of the public directory will just be shipped with your built version of your site and included and would be available after the slash in your url after that we have our source directory this is where all of our code is really going to live and what Astro really depends on is this page based routing where we have different files under the Pages directory are going to represent as you might have guessed it different pages in your application so let's just open the index.astro file and take a look the first thing we'll notice is that it is a DOT ASTRO File it's not a DOT JS it's not a DOT TS this is dot Astro and this obviously is going to signify to the developer to yourself and to your editor we'll talk about this in a minute that this is an astro component now Astro components are made up of two different sections there is the kind of JavaScript section which goes in these three dash blocks we could call these front matter we'll talk more about front matter inside of markdown files but inside of these three dash blocks we can add any sort of JavaScript that we want including importing other components so you can see we import our layout and our card and in this case we can find both of these in their appropriate directories under layout is the first one if we scroll down we see a reference to slot now slot is where we're going to take whatever information is in between this component when we use it the layout component and then inject that right inside of the component that we have defined here so what this looks like if we come down to our index.astro since we wrap this entire page which has a lot of code in it since we wrap this entire page with this layout component all of the stuff in between the layout tags which is here all of that is considered the slot and that will be rendered inside of this layout component right here so inside of the body now inside of the layout you'll also see a few other things you'll see that we can Define typescript interfaces for our props after we Define those we can then destructure those properties and then use them inside of our application just like we're using the title inside of the title tag inside of the head for our application now notice we can use these JavaScript variables by putting them in between the two brackets so inside of these two brackets we're able to basically kind of write JavaScript here which enables us to use variables that we defined up above so in this layout file you'll also see the other components that make up a basic HTML file you'll see the doctype defined at the top you'll see the HTML tag you'll see head and we'll we'll see a few different of our meta tags here like description viewport Etc we'll also see a reference to our title and then if we scroll down we'll see a lot of CSS in here now Astro has a few different ways that you can write CSS one of the ways that you can do that is just by adding a style tag right inside of your Astro components now this may or may not make you excited this is something that gets debated about whether or not your style should be colocated with your actual markdown and with your JavaScript but in Astro you have the ability to write all three together so your JavaScript your markup or your HTML and then your Styles in here as well now style is typically in here are scoped to a given component so you can see here that we have an is global tag that's associated with this style which means all of these styles are going to be applied to every single page on our application versus if we go to our index.astro component and scroll down there's going to be Styles here and these styles are not Global they're only referencing material that's inside of the component that it's in which in this case is a page component which is the index.astro now we can see another good example of this with the actual card component you can see we Define our props here we destructure those props we have markup we reference those properties inside of our markup and then we also have style tags down here as well now again these styles are only applying to things that are inside of this card component and won't be applied anywhere else so an example of this is if I were to select the main tag and did a background color of red this actually won't appear to have any difference or make any difference on our application and that's because there's no main tag inside of this card component and these styles are only applied to that however if I went to the layout and I now chose to select the main tag and did a background of red now we'll see that this red color is going to come into play because these styles are Global and are going to be applied anywhere there is a main tag so really important to remember that the Styles inside of Astro by default are scoped to that component and won't be interfering with other styles that you have in other components now in this case in this crash course we're going to use Tailwind CSS to style our application so we're actually not going to worry about all these styles that are defined inside of here we'll come back and clean these out in a minute and kind of reset this with some beginner styles for us to work with but if you were building an Azure project yourself you do have a few different ways that you could choose to do CSS in this case we are just going to use Tailwind CSS which has become incredibly popular so that's the majority of the basics of the layout for your code inside of the source directory there's a few other files a git ignore file which is pretty standard there's also the astro.config file and this is really important because this is where we can add Integrations in Astro we can also Define different things about our project like how this project is going to be built and where it's going to be hosted so by default Astro is a statically generated site we'll talk more and more about this we don't have to configure anything for that to be supported but if we wanted to convert this to be a serverside rendered site we could configure this in here and then configure where and how we want to deploy this at the end of this video we'll talk about deploying this to both netlify and versel but in this case we don't have anything to change yet in the Azure config although we will come back to this shortly next up we have our package.json with a few commands on how to run the project we have the readme and then we have a TS config which just extends the typescript config that comes from Astro so is going to give us all the basic rules for working with typescript inside of our Astro project you could go and customize that in any way that you want to but in this case we don't need to now I want to take a few minutes to talk about setting up your vs code instance to work with Astro in the best way now the most important thing you'll need to install is the actual Astro extension which comes from Astro themselves now what this does is it allows these Astro components these Astro files to be recognized as Astro files so that we get appropriate intellisense coloring Etc so notice down at the bottom here that vs code is recognizing this as an astrophile and then based on that and based on this extension knows what to do and how to color this now if we were to disable this just to show you what this looks like and we restart this all of our code highlighting our syntax our intellisense Etc goes away inside of these Astro components and vs code considers this to be a plain text file which is obviously not what we on so you'll want to make sure to install the Astro extension to get all of the benefits that come along with it it's by far the best way to work with Astro so I'm going to enable that and notice all of that comes back now another one that I have installed is an astro Snippets extension there's lots that you can do with Astro in terms of different types of file different things you might want to do this is a great set of Snippets that you could start with that kind of help generate components quicker and easier for you as you're going along now there's one more extension from the Astro team which is the Houston extension now Houston is the actual mascot for Astro and they've built a lot of fun things around this so with the Houston extension you get the Astro vs code theme mimicking the colors from Houston which is pretty neat I like this a lot in addition to that inside of the file explorer you get a little Houston Tab and you get kind of an animated Houston icon that shows you whether or not your application is running well or not based on it being happy or sad so it's a nice little touch to kind of feel like you're inside of the Astro community so you can install this and kind of have some fun with that if you're interested now me personally I'm using my personal James Q Quick theme so if you're interested in having your colors look exactly like mine you can search James you quick to get set up there the last thing I want to show you is the Tailwind CSS intellisense extension this is one that I use all the time when working with Tailwind so that it helps me kind of auto complete or remember what all the different styles are that that I'm trying to work with so you'll see this more as we work work through this and start writing some code now with all of that set up let's go back to the Azure documentation and see how to install Tailwind so let's just search in the documentation for tailwind and we'll be taken to the Astro JS Tailwind extension or integration that we can add which is one of the really cool things about Astro is that it comes with Integrations which makes it really easy to add support for other UI Frameworks for example to be able to deploy SSR to different places and a bunch of other really neat things so let's scroll down we can kind of skip the why tailwind and let's come down to the npx Astro ad Tailwind command which allows us to add Tailwind in one command and be able to work with it right after that so let's stop our running application let's paste in our MPX Astro ad Tailwind command and this will kind of walk us through what it's going to do to make sure we're okay with it doing all of these things so do we want to allow it to install the Tailwind CSS extension and the astrojs Tailwind package yes absolutely in this case it says it's going to generate a tail 1 config file which we absolutely want so we'll say yes and then lastly it says it's going to update the Astro config file to be able to support Tailwind so we'll say yes to that as well now just to confirm what this did let's search for the Astro config file let's open this up and what it did is it added an integration section here and then inside of that array it added a call to the Tailwind function that gets imported from the astrojs Tailwind package so this in theory is how we would manually install Integrations into our applications but in this case Astro gives us this command the Astro add command to be able to do all this stuff for us which is really really nice so let's go into our layout file and let's get rid of all of the styles that are defined in here because we're going to use Tailwind for our Styles and not use the builtin styles that come with the application now just to make sure let's go ahead and run this to have this running we can make a few changes inside of this layout file to start to get the base of our application going now the first thing to notice is that we're only defining one property that could be passed in as props which is the title now we could additionally add extra ones like the description we can have this be optional so we'll have that be defined as a string so the optional question mark or the question mark denotes this as optional and we can also Define an image in here as well so now that we get all three of those we can destructure them so that we can be able to use these as well all right so we have these three properties but we're not using all of them just yet we're only referencing the title and not the description or the image yet so inside of the content for the description we could reset this to be description and we can also reference our image by using it for the OG image type now we're not going to get all the way into all the different OG tags that we could use let's start with a meta tag with a property of OG image and then we'll say the content is going to be that image property that we pass in so we'll put this in here as image now one thing you might be wondering is what if the description and the image are not passed in here we should probably have a default property that we can use so in this case for the description we can set the default right in line in here by doing equals and then assigning this to a string now what we're building is a an application called Rhythm Nation and this is a community of music producers and in enthusiasts and then we want to give a default value to the image as well now we'll come back to this in the images section but I'm going to set this to a default of Slash Images slash band dot jpeg now remember we talked about the public directory what this is referring to would be a file ban.jpg inside of an images directory inside of public but we'll come back to that in a little bit for now we're just kind of setting these by default now just to show that these are coming up we can come back to our running application which now looks a little bit different because we got rid of those Styles and if we look inside of the head we should see that we now see our description here we also see our OG image which if we try to access will not be available yet then we still have our same title which is great so all those things are working well there's a lot more that you could dive into with OG tags for helping your website show up on social media post for example or embeds and slack or Discord but that's a conversation for another day just know that you have complete control to add all of those inside of here now inside of the layout what I want to do is add some Tailwind classes in here and what we can start with is a Min height of screen so before we save that let's go and look at the body tag in here and if we see this body tag is not taking up the entire height so we can start to style that a little bit with Min h of screen and now we should see that this body is now taking up the entire height which also is confirming that our tail one classes are working now from here I want to add a header component that can show the basics of our application so in this case I'm going to copy a little bit of code but inside of components I'm going to create the header.astro component and I'm going to paste in some starter code for us to work with now we'll walk through the code that's here so we Define our header we give some Tailwind CSS classes again this is not a crash course on Tailwind specifically but we have some classes for our header we then have an image icon that we can have to show in the top left we'll come back to that in a second then we have a few links to the different pages on this application like the home page the about and the blog so from here what I want to do is import this into our body or into the body of the layout component so I can actually Open Bracket and start to type our header and then oftentimes I'll get intellisense for this but it looks like it's not opening for me so I can go and do a manual import up here instead so at the top of this we can import header from and then we'll go back a directory into the components directory and then grab the header.astro so we could save this and we should now see the basics of our application starting to come together we have our header up here we have a missing icon up here and we'll need to add that inside of our source code so that we can actually have this show up so one of the things that we can do is go ahead and go to the Astro course demo final source code and then inside of the public directory we have an images directory and we have a heartbeat.png both of which we're going to need so we can click on the heartbeat.png and we can download this so we can download that file and then additionally we're going to need the images directory as well so from the images directory we can download this directory as well all right so that should download all of those files and so what you'll need to do is go and find the heartbeat image and then that directory that we just downloaded and it will add that into our source code so in this case I'm going to take the heartbeat.png and I'm going to add this into the public directory so there that is there and if we look inside of our header it's referencing slash heartbeat.png which should reference a heartbeat image right inside of that public directory so now if we come back and go to our application and refresh we should see that heartbeat icon is starting to show up which is great now the other thing we wanted to do is take those images that we downloaded in the zip folder and add those to the public directory as well so inside of the public directory I'm going to create an images folder and I'm going to drag all those images that we just downloaded into that folder so into the images directory here now one additional benefit of that if we remember is back in the layout component we defined a default image for our OG image to be inside of the images directory just like we did and then the band.jpg so this now should be the default image that shows up for our OG image tags and actually we can test this by going directly to this inside of the URL so we go to slash images and then slash band dot uh not jog but JPEG and we should now see this entire image showing up so we know that that is working as well so we have our images copied over which is exactly what we want we have our header showing up up here above we have links to our different pages which we haven't created yet and now we can go into our index component that root page and we can get rid of all of the Styles so we can delete all of these Styles and we can delete all of the main content that's in here as well so let's just scroll all the way through and get rid of everything inside of Main and in this case we're going to update this title to be relevant to the blog post the blog site that we're working on which is the Rhythm Nation blog so it's just the demo idea here but let's go ahead and type that in Rhythm Nation blog and now we can add a title to this as well so I'm going to actually create a new component for an H1 that we can reuse so we'll create an H1 component dot Astro I'm going to copy over the tiny bit of code that we have for this where we Define our props we take a text property as our prop we destructure that and then we put it inside of an H1 that already has the Tailwind Styles created so I'm going to save this and then back inside of the index we can now reference our H1 component and we'll pass in a property of rhythm nation and then we'll need to import this component so that we can reference it so we'll import H1 from and then we'll go into that components directory and then we'll grab the H1 dot Astro and now we should see a basic title showing up now one thing you might notice is that we need some spacing on the outside of this so one more component that we're going to create is the main dot Astro component and what we're going to do is use this component to wrap all of the other things that we do so in this case I'm going to open up a main tag and then we'll pass in everything in between as the slot and then we'll just add some Tailwind classes in here so we'll have a px of 24 which is padding X we'll set a Max width of 7 XL we'll set MX to be Auto which is going to automatically Center everything horizontally and then we'll set the width to be full and then lastly we can set the padding to be 5 on screens that are at Max small size so this is saying that we'll have a padding X of 5 on screens extra small and small and then above that anything bigger will have a padding X of 24. now the last thing we'll need to do we can actually duplicate this import we can import the main component from that components directory and we can now use our main component instead of just the main tag and that should wrap everything and give some spacing on the outside so now we have a clean section here for our main content that has that padding on the outside we have our header we have our images loaded and we can start to do more with this application by building out blog functionality and leveraging the content collection feature in Astro which is one of my favorite features of Astro now if we look at the final demo from the full Astro course we can see we have a home page where we show a bunch of blog posts we have tags Etc but what I want to show you is that if we go to the slash Blog Page we can see a list of all these blog posts which is what we're going to start to work on now so we can see a list of all the blog posts in addition to all the images that are associated with them so if we scroll through we can see these blog posts and then if we click on one we'll actually be taken to the specific route for the individual page so notice inside of the URL we have our root URL slash blog and then slash the title of that blog post and a sluggified version which means having dashes in between all of the words so let's start to work on setting up our application in this crash course to be able to work with markdown using content collections in Astro so let's go over to the Astro documentation and let's search for Content collections so what content collections are are a way to organize and manage and author content in any Astro project and in my personal opinion this is the best experience for working with content specifically markdown and or MDX content that I've ever seen across any platform which gets me really really excited so our content collections again give us a way to organize all these inside of a special directory in Astro called content directory so under Source slash content we can then create a directory for each different type of content that we want to create in this case their demo they have newsletter in our case we will have blog and that's where all of our blog posts will live as markdown files inside of there now you can scroll down and find a lot more about this with multiple collections Etc but the one thing I do want to show you is how to define collections inside of the content config file which is a typescript file and allows you to Define types for your individual collections like the blog collection using Zod to have typescript type associated with each of your collections so you define a collection you define a schema and you can Define all the different properties that are going to be associated with each piece of content now before we actually get into the code the one thing we will need to do is go back to the Astro course demo and we'll need to download some sample markdown files that we have in here to reference inside of our application so inside of the Azure course demo there is the source directory and then inside of there just like we talked about is a Content directory and then inside of there is the post directory so what you'll want to do is go and download this entire directory of all of these posts now after you do that you'll want to make sure to extract all of those and then we'll go inside of our source directory we'll now create our content directory and then inside of there we'll create another new folder called posts and then we'll take all of that that we just copied and drag it into the post directory now one thing I did Skip from copying over is the images directory that you can see here but that's something we'll come back to when we get into image optimizations so let's just take a real quick look at what we have inside of this content so inside of here we have our front matter at the top of each one of these markdown files and we have an author we have categories we have a date we have whether or not this blog post is featured we have a cover image to be referenced and then we have a title now this is all the front matter what we're going to do with content collections is Define a data type that represents this and stores or or gives us intellisense inside of our Editor to know which of these properties to associate with our given blog posts specifically with a given collection which in this case is our blog post now at the bottom of this you can see all of the sample markdown that's included here so this is just some getting started markdown so we have something to render you could obviously go and create your own markdown with your own content if you wanted to now one thing I do want to change is the reference to where these images are stored so actually I'm going to select this whole thing and I'm going to do command shift F on Mac or Ctrl shift F on Windows and I'm going to change this slightly and I'm going to get rid of this leading dot in each one of these blog posts or each one of these markdown files and we'll come back to that again when we talk about updating our images to work with the image component that comes with Astro to optimize our images but right now I want this to point to the public images directory where those different images are again we'll come back to this in a minute so we have our sample markdown and now we need to go into the content directory and we need to create our config dot TS file so let's start to work on defining a Content collection inside of this config file now to start we're going to import the Define collection function and then the Z for Zod from the Astro content import so this is giving a little bit of an issue saying it cannot be found this should be okay so as we go through this we'll make sure to run it just to make sure and then from here I want to Define my post collection and this is going to call the Define collection function we'll call this and we'll pass it a config object now this config object will then have a schema and we'll say that the schema is going to be a z dot object which is a function and we'll pass that a configuration object as well so we're using Z dot object to say that this schema is going to be an object and then now we can Define the different properties that it's going to have so we can Define it to have a property of author and then using Z which is Zod we can say where this is going to be a string then we'll have a date which in this case is also a string will have an image which is a string we'll come back to this in a minute and then we'll have a title which is a string as well now the cool thing about Zod is that it has other data types that you can work with where you can add a lot of customization on what exactly these types should look like and then lastly what we want to do is export a variable called collections and this is going to be an object and we'll say a key is going to be post and then it's going to have a value of posts collection and it's really important that this word here match up with the name of the directory that that content is in so those two things should match which means our post collection should be inside of this post directory inside of content so now that we have our definitions for our content we want to start to query this content so that we can start to display this inside of our slash blog page so to do this we'll need to create another component inside of our Pages directory and we're going to create the blog Dot Astro component now in here we can start to query our content by referencing the get collection function that comes from that Astro content namespace so this is going to be a function that we can call to get the content associated with a specific collection so in this case we're going to assign this to a variable called post we're going to await a call to get collection and then inside of a string we're going to pass it the name of the content that we're looking for now notice it gives me intellisense in here because it knows what the different content collections are that I've defined so I can now query these posts inside of here and now we can be able we should be able to log the post to the console so important to note with Astro is all of this code is going to be run statically at build time so it won't quite look this way when we run this now but when this is deployed all of this content is going to be queried and generated at build time and then deployed statically we'll talk more about this as we convert to SSR later in this video but in this case we should be able to go back to our site we should be able to click on the blog page nothing will show up but if we go back to our logs we should see that this is actually querying all of this content which is pretty nice so what I want to do is start to be able to display the basics here so one thing I'm going to do is copy over the structure of a page from that root page and now we'll say this title is going to be a Blog and then Rhythm Nation maybe not Rhythm Nation blog because that's repetitive we also have missing Imports so I can do command and period and go to add all missing Imports this would be control period if you're on Windows machine now we have all of our Imports and then we can also update this to be blog so now we should at least have the basics of a page kind of showing here so Rhythm Nation blog so that's great but now we want to actually be able to display that content so one one of the things that we could do is we could iterate through our posts so we could say post Dot and then map and then get a reference to each post and then for each post what do we want to return so inside inside of here we could start with an H2 and then reference the post Dot data that's going to be all of our front matter and then inside of here when we press enter we now get intellisense for all those properties which in this case I'm going to choose the title so this is not going to look great but at least we have the ability to show that all these post titles are being queried here now the other thing we might want to do is wrap this all in an anchor tag so if we kind of stub out an anchor tag here and wrap our H2 what we want to do is we want to set the href to a particular URL that will take the user to that blog post so in this case we can Define this ourselves by using an ESX template literal string and we could say this is going to take the user to slash blog slash and then inside of our Temple literal string we can reference the post dot slug so this is going to be the sluggified version of that based on the name of that actual file so now each one of these should be a link to that blog post even though that page doesn't exist yet so if we hover on this on the bottom left you can see it links to slash bog slash blah blah if we click on this it doesn't exist and that's our responsibility to go and create that so we want to do a couple of things in here to make this look a little bit better we'll cheat a little bit and copy in some components to help us we'll start with the post list dot Astro component now in this case what we're going to to do is Define our props to take in a prop of post which is an array of a collection entry of the type of posts now again post is going back to that collection that we Define and we're just saying we have a an array of those posts that we're passing inside of here now then we have our Tailwind CSS to be able to display a CSS grid here with two columns on bigger screens and then go down to one column on smaller screens and then we display each individual post with a post component that we haven't created yet so inside of our post our inside of components we'll create one more component and this is going to be the post component that we can paste in all right so very similar we Define a prop in here where we're going to take one property which is a collection entry of posts so it's one post we then destructure that and now we can reference each piece of that data so notice we also have the same kind of Link in here with an H2 where we have the post.data.title then we have the link that's linking to slash blog and then the slug we also are referencing the body of our blog post but we're using a few CSS or Tailwind CSS classes or one and here to say line clamp of two this will give it a maximum line maximum display of two lines and then use ellipses to finish it out and then at the top of this we're also referencing our image which will come back to in a minute as we go and optimize these in a second so we can save this we can save the post list component let's go back to our Blog Page and let's get rid of this log and just make sure all this stuff looks good so let's scroll to the bottom of these logs in the terminal there we go and then now if we refresh our page here nothing looks different because we actually need to use that post list component so we'll replace the anchor tag that we wrote we'll reference the post list component and then we'll pass into that our post property that we queried above and then we'll need to also import this so I'm going to copy the layout import paste in and post list and then paste in or type in post list here as well and this is from the components not the layouts directory so now we should see that we're actually loading each of these posts and it's linking to the individual page for that post so notice this doesn't display yet because we haven't generated those pages but we do have the ability to link to each individual blog post which is pretty neat now let's go ahead and generate the pages for each one of these now to do this let's go to the Astro documentation really quick to kind of show you how we're going to so we can search for dynamic routes and in this case what we do is Define a file that basically is going to have a placeholder in the file name that tells us some property that we can use to then query and display the appropriate information for that post now in our case what we're going to reference is the slug of the blog post so inside of our Pages directory we can create a new folder slash or blog and then inside of here we're going to create a new file that says inside of brackets Slug and then dot Astro now what this means again is that we're going to be able to get the slug for each one of these posts by defining each one of the different routes that we have now the way we Define each one of these routes is we open up our JavaScript snippet here and then we're going to export a function called get static paths this is going to be an async function and then inside of here we want to query all of our posts so just like we did before we'll call git collection and we'll pass in the posts name and we'll need to import that git collection function so we'll import this git collection and we'll also import collection entry from Astro content and once we have each one of our posts what we want to use what we want to do is use those posts to be able to generate the path that should be created by Astro for each one of these different individual blog posts so we're going to create a paths property we'll take our post variable we'll map through it we'll get a reference to each post and then inside of here we want to return an object and this is going to have a couple of different properties the first one is params so now inside of our prams these are params that we can pass directly to this component so we want to pass in that slug property and it's going to come from post dot slug and then we want to pass in our props so our props is going to be the post itself so by the by exporting this get static pass function we're basically defining a path and a property for each one of these blog posts that will generate statically for application now from here we can kind of Define how this component is going to work so we'll Define the props type this is going to have one property of posts that's going to be a collection entry it's also going to be referencing that post collection so we'll have one post is being passed in we can then destructure this so we can get the post from Astro dot props and then from that post we can grab the content so we can destructure the content itself from the post.render function which is an async function now from here we want to kind of lay out a blog post page just like we've done a few times before so let's copy over a few of these different components and let's just paste this in so I have our layout we'll have our main and we'll have our H1 and we can import all of these at the top so we can import layout and we can import the H1 and lastly our main and so we've imported all three of the components that we're going to use in here and just to start we can now start to update a bit of information based on this individual blog post so in this title we want this to actually be the title of the blog post that we're on so we can take post dot data dot title and then inside of our H1 on the page we can do the same thing so we want to reference our post.data DOT title so what we should have done now is we should have generated a page for each one of our blog posts that will in this case just display the title of that blog post so if we click on one of these blog posts from the slash blog page it should take us to this page but it looks like we have some sort of error in how we defined our git static path function so it's expecting an array but got undefined so let's go back up and double check that so it looks like we defined our path but we didn't return this in the end so the most important part about the get static path function is it has to return those paths so that Astro knows what to do with them to generate the individual pages so hopefully that will handle this now if we refresh we see the title now coming up at the top and we have our individual blog post Pages for each of these individual blog posts so that's great we have each of those defined we can now kind of copy a little bit of code from the post component so if we go back to the post component and look at the image we can now copy this end just so we're starting to display some more things on here so if we paste this in under the H1 we should now see our images popping up so it looks like it's not quite the size that we want because we're now shrinking this to be a width of 600 so we can update this to be 1024 and I think that should give us now kind of the full screen or almost full screen page that we're looking for and then lastly we can render this content component that we got from the render function of our posts so up here we called post.render we got the content component we can render this but it's not going to look great so you can see we have all of our content here but this doesn't quite look great and that's because we don't have any Styles defined for this now in our case what we're going to use is the Tailwind CSS typography package to handle this for us so Tailwind CSS typography you can search this basically what we're going to do is install this plugin and then we'll be able to use this inside of our page to be able to display this stuff appropriately so I'm going to copy this install command let's go back let's paste this in this is going to install the Tailwind CSS typography package then inside of our Tailwind config we need to make sure to reference this so we're going to inside of this array require and then we're going to require the Tailwind CSS typography package and then lastly for this to work inside of where we render our content we're going to need to wrap this in a class or a div that has a few classes primarily the pros and Pros 2XL class so those are the classes that kind of activate this extension or to be able to use that plugin to be able to render all of our content so let's go ahead and run this with our run Dev command we can now come back to our application we can refresh this and we should see that this now is looking a lot better and this is starting to feel like a real blog so we have if we go back we have a list of all of our blog posts and then we can click on the individual Pages see the image and see all the content which is pretty neat now one thing that's interesting that's not very optimized on here is the way we're referencing our images so if we go into our Network Tab and just look at our images as they load in we'll notice a couple of things a couple of things we're loading all of these images even before we scroll down to see them so that's a little bit unnecessary it would be more optimal if we were only loading images as we're getting close to scrolling down to them then we'll also see that these are being loaded as JPEG files which are not the most optimal format webp would be a better format and see that these are really big images so six megabytes four megabytes Etc so we can use the Astro image component to make this a lot better and much more optimal so let's go back to the Azure documentation and let's just search for image and let's just go to the top level images here and let's go down to the actual image component which is what we're going to use to be able to do a lot of optimizations with our images so we can import the image component from the image assets namespace and basically just replace the regular IMG tag that we were already using we'll have to do a few more things in here but let's start with that so inside of our post component we can copy in the import for this image component and we can now replace that IMG with our image component now if we come back to our application we can see that this is going to work but nothing has really changed so we're still loading all of these files and they're still jpegs and they're still pretty big so one of the things we want to do is actually move this image's directory into our content directory and actually specifically we're going to move this into our slash post directory because these are going to be all the images that are associated with these posts now then inside of our markdown we're going to update if you remember we changed this at the beginning we're going to select this little bit and we'll do command shift F or Ctrl shift F to select all of that and what we want to do is we want to update this to go from slash to dot slash so slash implies that it should look at the root of the application which is at the end of the URL dot slash now means we should look relative to where the actual file is so in this case it's going to be relative to where this markdown file is and that's going to be inside of that post directory so I'm going to update each one of these posts to reference dot slash image and we would think that would work but we actually have an error in here of something isn't working that's because we need to go back to our config for Content Collections and we need to update our image property to actually use and image object that Astro gives to us so what we're going to do is turn instead of returning this object directly we're going to turn this schema value into a function and so this is going to then return that Z dot object but by defining this as an a function we can now destructure a property called image and now we can reference our image type to be of Type image or call that image function so this is going to more explicitly references as an image in a way that Astro can understand in a way that could also import those images from the content or inside of the source content directory so let's try this one more time run this again so the first thing that you notice so you might notice is that the URL for these images are looking kind of weird that's because Astro is using kind of internal URLs to Define how to render these images so if you look really closely you can see it defines the format and width and height Etc but we can see that these are loading webp images and that these are much smaller than what they were originally so our page now is going to load much faster because these images are much more optimized and they're a better format and they're much much smaller now if we click on one of these individual Pages notice that this isn't working and that's because we're referencing this using the old image IMG tag which can't be referenced here so let's go into the slug page and let's just update this to use the image component from Astro assets and we should be able to just say this as is and have this be working so now we're able to load this image and this should also be choosing a webp version of this which should be smaller than what it was originally so now we have a working list of all the blog posts we can then go to the individual page for a blog post we see an optimized image and we can see all the content associated with that blog post as well now with all this in place there's one really neat thing that we can add that's really easy in Astro and pretty amazing if we look at navigating between these Pages we see kind of this page refresh we actually don't have the about page created but we see kind of the page refresh as we go between individual pages and we can actually make this a little bit easier by using the view transitions API in Astro this will only take a second to add but it does make a big difference in how you can view and navigate through your application so inside of the view transitions API you can you can read a lot more about this we can basically import this component and then use it inside of the head of any page that we want to have those transitions between so since we want to by default use this on every single page we can actually just import this inside of our layout file and then somewhere in the head we can just reference this View transitions component and save and now we're actually going to be be able to see a difference between how we navigate our Pages this is pretty neat so let's go from this page to home notice we get kind of that animation we go to blog we get animation we see this page we get the animation so it looks like a much much better experience of navigating between pages with just one component that we can add now there's some additional ways that you can customize this you can also Pass State from one page to another which is pretty neat we won't go any deeper into this but it is nice to know that we can add this pretty easily to make the transitions that our application look look a lot better now one additional thing I wanted to show you is that you have the ability to not only use markdown inside of Astro for your content you can also add MDX and the support for this comes with a an integration that we can add with one of those npx Astro ad commands so let's go and add support for markdown by pasting in this command this will make a change to the Astro config and install that package so we'll just go ahead and say yes to all the things that it needs to do yes all right so that should be added and now we can do an npm run Dev to start this again and what we should see if we come back to our markdown files for example the behind the scenes is we can now rename this file and we could rename this to an MDX file and now all of this should still stay the same so if we come back to the application so if we refresh this we see this stays the exact same which is exactly what we wanted but now we can harness the power of MDX in addition to just the markdown that we were already using now if we scroll back up there's a quick section on why MDX so now we're not going to dive deep into this but there are lots of really cool things that you can do like MDX only features so you can use exported variables inside of MDX so if you wanted to create variables at the top you could then reference that you can also use your front matter variables so you could use those directly inside of here as well and the last thing is you can reference Astro components and UI components of other Frameworks like react view Etc inside of this as well so if we look in the example in here inside of the MDX part we're importing two different components one Astro component and one react component that we can then display right in line inside of our markdown content now this is really useful for as an example to do like a call out inside of your blog post if you want to customize a call out to send somebody to a newsletter or something else you could Define those components and bring those into your H to your MDX files anytime that you want or need so we're not going to dive any deeper into MDX that's kind of a section on its own but it is nice to know that you have the ability to work with both markdown and MDX files in your content with Astro now we can start to work on deploying this application so we initialize this initially as a GitHub or a git repository so we can now do a git status and we can see all the things that we've changed now in this case we can add everything with Git add star and then we can do a get commit Dash M to say initial commit and all of this stuff has been committed to this local git repository now the next step is we we need to connect this to a GitHub repository that we can then use to deploy to netlify or versal so on github.com you can go to the top right you can click new repository and then we can call this FCC Astro crash course test we'll have this be a public directory we don't want to add a readme because we'll take care of that ourselves we don't want to add it get ignore so we can create this very blank repository and then what we'll do is just take the code into our terminal that pushes from an existing repository to our local git repository to this GitHub repository so you can copy this section where it adds the origin and the remote or it adds the remote origin and then pushes everything locally to that remote project inside of GitHub all right so it looked like it pushed all of that code up if we come back to the GitHub repository we can come in here and see that this has been added and so now our next step is to go to we'll start with netlify we can do netlify and versal these are both free so you'll sign up with a free account after you do you can log in on netlify and basically what we're going to do is add a new site where we're going to import from an existing project we'll choose to deploy with GitHub and then what we'll need to do is go and choose that project that we just created so I can search FCC Dash and this should be enough to pull up that project all right so we can now pull this in we don't need to customize anything it should pick up on what the build command is automatically so we can go into go ahead and deploy this and it should run a build and then have the site ready for us to use after it's done all right so it looked like this build has finished you can now kind of choose the random URL that they gave you and we should see that this is deployed our application successfully so we can see our Blog Page we can go and click on individual ones as well so that is on netlify we could also choose to deploy this on Verso almost the exact same process you'll sign up for a free account you can then come and add a new project you're going to import this from a git repository choose from that FCC crash course project and GitHub choose all the defaults and then go and deploy and then after this is finished we should have this deployed on versel as well all right so it looks like this has finished on versel we can continue to the dashboard then we can visit this at the random URL that it's generated for us also now so far everything that we've done with Astro has been statically generated pages but we can start to look into the SSR capabilities of Astro so Astro actually has the ability to do a full back end if you so decide and you have the ability to Define what type of output your site is going to have so by default it is static which takes no additional configuration for us to do but there also is the ability to Define it as a server rendered application by default it says to use this one most or all of your sites should be server rendered you can also opt into prerendering or static Pages for individual Pages you also have the option to do hybrid which is basically saying it's going to prerender by default and then you can Define for individual pages to opt out of prerendering before we make this transition into serverside rendering in our code let's actually take a couple minutes to talk about the difference between static site generation or SSG versus SSR which is server side rendering and we'll talk about this while using diagrams to kind of explain the differences between the two so let's start with what we've already been using which is SSG or static site generation and this is what Astro does by default quick reminder if you want to follow up on this diagram later on you can find the link in the description below so what happens here is when we deploy our application we deploy this to something like netlify or versel or there's lots of other hosts that you could use as well so when this thing is deploying it actually runs a build and during that build process what happens is for each one of those individual pages that we have in our Astro application it actually generates the HTML file at build time for each one of those so we have one for our index.html page we have one for our blog.html page and then additionally we have a an HTML page created for each one of our blog posts and that's where we Define that export or we exported that get static paths function where we defined each one of the paths that we wanted to be able to support and then to generate the content for so the important part about this is SSG at build time is going to go ahead and create the content or the HTML Pages for each one of these Pages at build time so that it's ready and accessible by the time someone comes and tries to view one of these blog posts for example or one of these other pages and that's an important next step to talk about is the actual request time so what happens well these individual files that are generated during the build process are then saved to a CDN or a Content delivery Network that are replicated all across the world what this means is that those files now are very fast to access and return When a request comes in from the browser so let's say that you go to the browser and you type in local not localhost but you type in the URL of the application that you're trying to work on and you go to the index page that's going to make a request to the CDN it's going to now return that index.html page now let's say you then want to go to the blog page while you make another request to the CDN the CDN now is going to return blog.html or if you're going to one of the specific Pages for an individual blog post it's going to return those pages as well again because they've already been predefined now this starts to differ a lot when we look at SSR or serverside rendering so I've got almost an empty diagram here for SSR build time so with serverside rendering you're still going to have a build process to go through and run all of your code you may run tests if you have them but basically this is going to go through and do the build of your application and you may have some static Pages we'll talk about how to mix these in a second but for the most part what this is going to do is now kind of have that server configured so that it can handle those requests as it comes in so notice there's no predefined HTML pages that are already calculated for us that means if we scroll down now that something has to happen at request time when this request comes in from the browser so notice instead of having a CDN we now have an application server so requests will go from the browser to the application server now for this application server to respond back most likely specifically in this case with our blog post individual blog post Pages it's going to need to get the information necessary for those blog posts from the database now in our case we're not using a traditional database we're using embedded markdown in our source code but it basically works the same way so let's say that we make a request to slash blog slash blog dash one for example that's the website that we're trying to go to well this is going to now make a request to the database let's add a new piece of text in here and it's going to say give me all the information that you have about blog one so from the database the database is going to return back the data for blog one to the application server the application server is now going to turn that back into an HTML page which will look like if we add our corresponding piece of text to your slash blog slash blog1 Dot HTML we can move this up a little bit for readability so basically with SSR or server side generated Pages or applications every request that comes in is going to go to an application server it is it is then going to query the database or in whatever format it is which might be embedded markdown that will return the data the application server will then take that content and turn it into an HTML page that can be rendered on the browser and viewed by the user so that's a quick overview of the difference between SSG and SSR let's go back to our code and start to make this work inside of Astro so in this case we can start by going into the Astro config and we can choose the output property to be server now if we try to run this we should see that this is going to break and that's because we're doing a couple of things that are specifically geared towards statically generated pages so let's go to our running application and refresh and we see that we now are having an issue on the individual blog post pages and that's because the way that we're generating those pages is using this get static paths function and that doesn't exist inside of an SSR deployed application now one thing we could do is we could look in the documentation and we could see how to define this as a prerendered page that means it's going to generate this page statically so if we add this at the top of this file and refresh this actually will go back to working as we expect so now we see we have that blog post we can go back to all of them and go to another one Etc but just for practice and kind of experience let's go back and get rid of the prerender and let's see what it would take to actually figure out how to generate generate these Pages inside of an SSR environment now in this case what we're going to do is go back to our page and we can actually get rid of this entire get static paths function and we can start at the top here and most importantly what we're going to do is destructure a property called slug from Astro dot params now what Astro is going to do is because of this slug definition up here it's going to pass this log into the Astro dot params object to let us reference it and use that in here to dynamically query that post from Astro we can also get rid of our definition for the posts and our prop types and then what we're going to do is we're going to get that post from in a weighted call to git entry by slug now this is a function up here that comes from Astro content it's a function that they give us and we can say what content collection we want to get this from which in this case is post and then we can pass in the slug now in this case it's going to throw an error or show us the typescript error because slug could be potentially undefined so we're just going to say this is going to be a string so that we get our appropriate type in here now in this case it's throwing an error because it's saying that we might query for a post that also doesn't exist and what we could do we could say if that post doesn't exist we could do an astro redirect so we could return an astro redirect to the slash four or four four or four page just just to show that that thing wasn't found now we could go and customize this and do anything that we wanted to handle it but in this case this ought to be enough just to get this working and now have these dynamically generated Pages be dynamically generated with serverside rendering instead of statically generated pages so if we go back we should see that we have all of these showing up in our blog index page and then clicking on one should be able to show all the details for this blog post as well so we've now completely flipped how we're rendering these blog posts Pages now they're server side rendered and what this means just to clarify is as the request comes into this URL it's going to send a request to the server the server is going to query based on that URL the individual blog post return that back and then use that to render the page that shows up on the screen as opposed to previously we had each of these Pages generated statically at build time for all the blog posts that we have now the cool thing about this is we can still go back and configure individual pages to be configured as static so as an example on the home page there's no reason that this shouldn't just be a static page so we could still export a kant's pre render variable that's set to true and now we'll mark this index page as static so if we go back here this will be a static page versus this is server side rendered and this individual page or all the individual Pages for our blog post are server side rendered as well now I do want to show one more thing that you can do is when you have server side rendered enabled you can Define API endpoints so we can search for Server endpoints in here and basically what that allows us to do is have a file inside of our Pages directory that just basically serves as an API endpoint instead of actually returning an astro component so if we go into our Pages directory we could create a new folder slash or called API and then we can just create a test dot TS now notice this is a TS file instead of an astro component again because it only runs on the server and if we look in here just copied kind of the basic uh starter code that they give us but we're not going to reference any of this so we can kind of get rid of all of this information about products and then we can return back an object with a message that says hello world so this is how we Define a starter function four API endpoints so in this case we're also not referencing this params parameter so what we defined is a git endpoint where we're basically just going to return hello world as Json so we can save this we can then go back to our application we can then open the URL and go back to the root and then slash API slash test and we should get back that message with hello world now what's really cool is we can Define all of our HTTP endpoints with this as well so we could also export a post function if we wanted to we could return with the same thing now unfortunately there's not a way to be able to test this inside of the browser because the browser can only send git requests so I have the postman extension inside of vs code installed so if you wanted to follow along you can install the postman extension this has been kind of my default way of doing testing apis for a long time but now they have the the vs code extension to go with it so we can create a new HTTP request and we can now send a post request to the same general idea so localhost4321 and this will be slash API slash test and we'll send that and we'll get the same response that we just got back with the message of hello world now inside of handling our post requests we could also destructure the request as well and then we could get the body from that request by calling a weight request dot Json and then we could just return this just to show that we're actually getting it so let's just return that body which is going to be an object so we're destructuring this request notice we also don't have typescript types around this so we could Define this a little bit differently if we wanted to I'm just going to copy in a new kind of function definition here so this is going to use in Arrow function syntax where we Define now our posts to be an API route so we can add the missing import for that and now it's going to give us intellisense for the request so if we do dot we can see all the things that we have access to there we also then can see things that we might have on our params in here as well so we can now save this and what we should see is if we go back to our request this is a post request but it doesn't have a body so we can now inject in here a raw body with Json and we could have an object and we could have a property of a name we could say Astro crash course and then what this should return back with is that same object that we can see down here so we have the ability in Astro to Define any and all kind of server capabilities that we wanted we could handle form submissions we could Define API endpoints for all of our different methods which is really really cool and really really powerful so I think the only next step is to show how do we actually deploy this to netlify and versel now that we're doing server side rendering so inside of here we have a plugin or an integration for both netlify and versel so I'm going to copy and paste this command so here's the netlify one and let's paste this in here for netlify and this is going to add that package and then it's going to make an addition to our astro.config file to use netlify as the host so notice it says adapter is netlify we'll say yes and then if we look inside of the Astro config we should see that it's referencing adapter and netlify here so now what we want to do is we we will add everything we'll do a git commit with a message of added SSR and deploy to netlify and then since this is already connected to our netlify site we can push this and netlify ought to automatically pick this up pick up that change let's just log back in it should pick up that change automatically and it should be building a new version of that that now is going to be our serverside rendered version so we'll let this go through our build and then we'll open this up to make sure everything looks okay now as this is building one thing to notice it's referencing netlify functions I actually just missed it but inside of building you can see that it references deploying this to netlify functions so that's how it's actually able to deploy this it looks like everything is complete we should be able to open this production deploy hopefully everything now continues to look okay just like it did before and we can see the individual blog post Pages as well now next we'll need to do this for versel so we can copy in that same command and then add in versel and this is going to go through that same process add the versel package and then it's going to update the Astro config to reference that versl adapter so we can say yes to that as well so now this is updated we can add everything again we can commit and say hosting on versa then we can push this now do note that this deploy in netlify we're still connected to netlfi so this will kick off another build that next build will fail in netlify but what we do want to see is inside of our cell we should see that this is kicking off a new build and versaille so we can see under the building tab that it's going through and it's doing this so when that finishes we should see that we have the same deployed application hosted now on versel using SSR all right so it looks like it's finished we should now be able to visit this and we have the same experience where we can go to blog we can see all the pages we can go to the individual page Etc now going back to the idea of SSR inside of Astro one of the coolest things that you could do in addition to API endpoints and other things is you could start to incorporate authentication into your applications so you have the ability with Astro to create fullfledged full stack applications and you can do authentication in here by referencing cookies as an example so you could track a session in a cookie for a user and you could gate pages to prevent users from getting to certain pages if they're not logged in or if they don't have certain permissions or anything like that with authentication in that full Astro course we actually build a basic authentication strategy using SSR and Astro as well as taking advantages of taking advantage of cookies and then having that reference users that are saved inside of a Zeta database so another really cool full stack implication or example of what you can build with Astro now if you want a full overview of what we build in that course you can go to Astro core Dev and it breaks down everything that we're going to build inside of this full application including all the topics that are covered the pricing Etc so if you're interested in that you can find that at astrocourse.dev all in all I hope you're as excited about Astro as a framework as I am obviously I'm pretty excited so thanks for checking out this crash course and I really hope that you enjoyed it
