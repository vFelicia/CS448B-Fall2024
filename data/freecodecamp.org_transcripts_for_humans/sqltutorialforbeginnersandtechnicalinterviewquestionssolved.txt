With timestamps:

00:00 - welcome to this comprehensive sequel
00:02 - tutorial course designed for beginners
00:04 - and also those looking to prepare for
00:07 - technical interviews this course was
00:09 - developed by the team at Jovian who have
00:12 - created many popular courses for our
00:13 - channel in this course we'll cover the
00:16 - basics of relational databases and SQL
00:19 - including setting up MySQL inserting
00:22 - data and working with aggregation
00:24 - grouping and pagination and SQL queries
00:27 - the course also covers Advanced topics
00:30 - such as combining tables using joins
00:32 - executing SQL queries using Python and
00:35 - SQL Alchemy and solving technical
00:37 - interview questions by the end of the
00:39 - course you'll have the knowledge and
00:40 - confidence to excel in SQL is it SQL or
00:44 - SQL well it doesn't really matter
00:46 - because you need to learn it no matter
00:48 - what it's called hello and welcome to
00:51 - this tutorial on SQL where you will
00:54 - learn the basics of the structured query
00:56 - language which is used to fetch data
00:58 - from almost every database in the world
01:01 - no matter what you're doing in data
01:03 - science you will need to learn these
01:05 - skill and this will be part of your
01:06 - daily job and this course guides you
01:09 - step by step and you can follow along
01:11 - with everything that we do in this
01:13 - course to learn the basics of SQL and
01:15 - even learn how to crack interview
01:17 - questions from the top companies in the
01:20 - world
01:21 - so I hope you enjoyed this course leave
01:23 - a comment and subscribe to our Channel
01:25 - if you'd like to join more of these
01:26 - courses and let's get started the topic
01:29 - for today is relational databases and
01:31 - the structured query language or SQL and
01:33 - here's what we're going to talk about
01:35 - today
01:36 - first we will talk about some of the use
01:38 - cases and the design of relational
01:41 - databases and SQL what they are and why
01:44 - they are used
01:45 - we will see how to set up a database
01:47 - locally using the MySQL server
01:52 - we will create modify and delete
01:56 - databases and database tables we'll see
01:58 - how to do that
02:00 - we learn about the data types in SQL and
02:03 - some constraints like primary key
02:04 - foreign key Etc
02:06 - we will look at crud operations you will
02:09 - see this term a lot in relation to
02:12 - databases so create read update and
02:14 - delete operations on data stored in
02:16 - tables and then we'll also look at how
02:19 - data can be exported and imported
02:22 - from relational databases
02:24 - this is part one of two lessons on SQL
02:28 - so the next week will be an advanced
02:31 - lesson where we will look at
02:32 - aggregations we look at joins we look at
02:35 - indexes and we will also see how to use
02:40 - how to use Jupiter to get data out of a
02:44 - SQL database and how to work with it in
02:48 - Python so maybe how to do some analysis
02:50 - and how to do some visualization
02:52 - but today we are going to work in a more
02:54 - traditional setting where we are going
02:56 - to use some
02:57 - commonly used software like a MySQL
02:59 - server for working with SQL databases
03:02 - now we learn about relational databases
03:05 - in SQL by working through this problem
03:08 - this is a hypothetical scenario that
03:11 - we've set up and we'll try and
03:14 - understand in the context of this
03:15 - problem why we want to use a regulation
03:17 - database and how SQL is helpful
03:20 - so classic Models Incorporated is a
03:22 - manufacturer of manufacturer of small
03:25 - scale models of cars motorcycles planes
03:28 - ships trains Etc
03:30 - and products manufactured by classic
03:32 - models are sold in toy and gift stores
03:34 - around the world so this is what some of
03:37 - their products look like they are small
03:39 - scan models of
03:42 - various types of vehicles
03:45 - and classic models has offices around
03:48 - the world with dozens of employees
03:51 - and these are primarily sales offices so
03:54 - the customers of classic models are
03:55 - typically toy or Gift Stores and each
03:59 - customer typically has a designated
04:01 - sales representative uh in the same
04:04 - region who's also an employee of classic
04:07 - models
04:08 - and they interact with that sales
04:10 - representative directly
04:12 - then customers typically Place orders
04:14 - requesting several products in different
04:16 - quantities and then they pay for
04:18 - multiple orders at once via checks so
04:20 - this is typically how a business works
04:22 - you have you manufacture some products
04:25 - and then you have offices and then you
04:27 - sell your products to people and you
04:30 - have transactions with them and you have
04:32 - employees involved who are involved in
04:35 - managing these relationships and
04:37 - managing the offices that you run right
04:40 - now for an international organization
04:43 - like this it is important to record all
04:46 - of this information all of the
04:48 - activities in a single central place
04:50 - right so your task is to create a
04:54 - database some sort of a system where you
04:56 - can record and manage all of this above
04:58 - information so where do we have our
05:00 - offices who works at these different
05:02 - offices who are our customers how who is
05:06 - the sales representative for every
05:07 - customer what kind of orders are
05:10 - customer placing and what what are the
05:12 - payments from them what do the payments
05:15 - from them look like so we want to record
05:17 - and manage all of this information in a
05:19 - database in a central location and this
05:22 - database will also be used for
05:24 - day-to-day operations for example adding
05:25 - new customers placing orders recording
05:28 - payments hiring employees and things
05:31 - like that and also just querying
05:32 - information and getting analytics about
05:34 - how the business is doing
05:38 - so while there are many ways of storing
05:40 - data on a computer for example we could
05:42 - put this into a bunch of text files we
05:44 - could maybe open notepad create a few
05:47 - files and put in all this information
05:49 - there but looking it up is going to be
05:51 - very difficult we could use Json files
05:54 - we could use CSV files we could put
05:57 - maybe have a CSV file for customers one
05:59 - for products one for employees we could
06:01 - use spreadsheets things like Excel which
06:04 - a lot of businesses use but spreadsheets
06:06 - become a bit Limited in functionality as
06:10 - you deal with really large data sets and
06:13 - as you want to do some
06:16 - Advanced forms of querying and also as
06:19 - you want to integrate this with these
06:21 - systems with other systems for example
06:23 - you want to create forms for customers
06:25 - to sign up you want to create order
06:27 - forms you want to create a bunch of
06:28 - different things connecting forms with
06:30 - spreadsheets and writing custom business
06:33 - logic can be a bit tricky
06:36 - so this is where a relational database
06:38 - comes into picture a relational database
06:41 - is a data storage system
06:43 - typically which has the following
06:45 - properties so the first thing about a
06:47 - relational database is that data is
06:49 - stored in tables
06:51 - so each kind of entity that we are
06:54 - concerned with you have a table for it
06:56 - for example you have a table for
06:57 - customers
06:58 - and this is a snapshot of some data
07:01 - stored in a relational database so you
07:02 - have a table for customers and each
07:05 - customer has a customer ID they have a
07:07 - first name they have a last name they
07:08 - have a date created which means the date
07:11 - at which or the exact time at which that
07:13 - customer
07:14 - was added to your database and then you
07:17 - have a bunch of information maybe where
07:19 - they live etc etc right
07:22 - so that's one important piece that data
07:25 - stored in tables
07:27 - second each table has a set of columns
07:29 - as you can see here each stable has a
07:31 - set of columns and each column is used
07:33 - to store a specific type of data for
07:35 - example customer ID is going to be a
07:37 - number and it's in fact going to be a
07:38 - unique identifier for the customer first
07:41 - name and last name is their first and
07:42 - last name and then date created is going
07:44 - to store the date or the time exact time
07:47 - when they join and so on
07:50 - next data in the tables is stored as
07:53 - rows so each row of this data after this
07:56 - header row represents a customer and
07:59 - sometimes these rows are also called
08:00 - records so data stored using rows within
08:03 - database tables
08:05 - next table support crud operations on
08:09 - rows which means create read update and
08:13 - delete so you can add new rows into the
08:15 - table that's the create operation
08:17 - you can delete rows from the table
08:21 - you can delete rows from the table that
08:23 - is the delete operation you can get data
08:26 - out of the table let's say you want to
08:27 - figure out which customers you have in
08:29 - the United States then you can query
08:31 - that you can just type out some code and
08:34 - you will get back that information and
08:36 - you can update information because if a
08:38 - customer changes their address or their
08:40 - phone number or their email you should
08:41 - be able to change that then one
08:43 - important piece so a lot of databases
08:45 - support this but one important piece is
08:49 - relations between tables so tables can
08:52 - be connected to other tables using
08:54 - relationship constraints for example
08:58 - you have offices and you have employees
09:01 - we can say in the employees table that
09:03 - an employee works at a particular office
09:05 - so we can make a relationship between an
09:08 - employee record and an office record and
09:11 - there can be one-to-one relationships
09:12 - there can be one too many many-to-one
09:14 - relationships and we will talk about
09:16 - these in more detail when we talk about
09:17 - joins but at the moment the just the
09:20 - fact that you can link records across
09:22 - tables is an important piece to
09:24 - understand
09:26 - then relational databases typically
09:29 - allow you to retrieve data from the
09:31 - database using the structured query
09:33 - language or SQL which is what we will
09:35 - learn today
09:36 - and these databases can either be hosted
09:39 - locally on your computer
09:41 - or more commonly these are hosted
09:43 - somewhere on the cloud for distributed
09:45 - access for example for
09:47 - classic models it's possible that they
09:51 - have set up a database on the cloud and
09:54 - all the employees from all the different
09:57 - offices use this database
10:00 - through some browser-based application
10:03 - maybe they have Farms or maybe they have
10:05 - some kind of access-based system where
10:08 - different employees have different
10:09 - permissions and they use this database
10:10 - but everybody's ultimately making
10:13 - changes or getting information out of
10:15 - the same database right and this is how
10:17 - most modern applications work for
10:19 - example on Jovian we have a relational
10:21 - database sitting somewhere on the cloud
10:23 - and all of your account information is
10:26 - on in the relational database and when
10:28 - you open your profile we get data out of
10:30 - that relational database and we show it
10:32 - to you okay
10:34 - so that's relational databases the
10:37 - important pieces are that data stored in
10:39 - tables a set of columns each column has
10:42 - a specific type
10:43 - and then tables can be conducted using
10:46 - relationships and the data is queried
10:49 - using SQL or the structured query
10:51 - language
10:52 - now when
10:55 - you are setting up a relational database
10:57 - which you most likely won't have to do
10:59 - because in most cases whatever
11:01 - Corporation you work with or whatever
11:04 - client you work with in a project they
11:06 - will already have a database but when
11:09 - you're setting up a database it is
11:10 - common to First create an entity
11:12 - relationship diagram or it's called an
11:15 - ERD to describe all the tables within a
11:18 - data within the database and the
11:20 - relations between them
11:22 - so ERD this is what an ERD looks like an
11:25 - entity relationship diagram and they can
11:27 - be created using drawing tools like
11:29 - lucidchart so typically this is
11:31 - something an image like this is what you
11:33 - might be given when you join a company
11:37 - they may give you an image like this and
11:39 - they would tell you that this is what
11:41 - our data model looks like or this is
11:43 - what our database looks like
11:45 - and sometimes you may have multiple
11:47 - ersds because different teams or
11:50 - different or orgs or different
11:52 - departments when this in the same
11:53 - company may have their own separate
11:55 - database and sometimes you may have data
11:57 - duplicated across different databases
12:01 - and so on but let's just take a look at
12:04 - this ERD and understand what it
12:06 - represents
12:11 - so the first thing you will notice is we
12:12 - have these boxes we have this one box
12:14 - called payments we have this called
12:16 - offices
12:18 - we have employees customers product
12:21 - clients products orders and audits so
12:23 - each box in an entity relationship
12:25 - diagram shows you a table
12:28 - okay so for example offices is a table
12:31 - and then inside each box this is the
12:34 - list of columns in the table
12:36 - now the ERD does not contain any actual
12:39 - data it is sort of a blueprint for the
12:41 - database on what tables it contains and
12:45 - what are the fields within each table
12:47 - and how the tables are connected so the
12:50 - office is stable for example will
12:52 - contain an office code and you will see
12:54 - that this is you can see a key icon here
12:56 - if I zoom in a little bit
12:59 - so this is a key icon so that is simply
13:01 - to indicate that
13:04 - the office score is a unique identifier
13:07 - for the office and this is also called a
13:08 - primary key
13:09 - so the office code is the unique
13:11 - identifier or the ID just as on Jovian
13:14 - you have a unique ID which is your
13:16 - username so similarly office code is a
13:18 - unique ID and then the office is based
13:21 - in a certain city it has a certain phone
13:23 - number it has a certain address address
13:26 - line one address line two a state
13:28 - country postal code territory and maybe
13:30 - even a location a geo location for
13:33 - plotting on a map
13:35 - okay
13:38 - and different ways in which erds are
13:41 - created may or may not contain this
13:42 - additional information for example here
13:44 - what this blue square represents is that
13:47 - this is a required detail if it is
13:49 - filled in and if it is not filled in
13:50 - then that means that this is optional so
13:53 - you can have address line 2 may not be
13:55 - present for some offices because it's
13:57 - enough to summarize the address in one
13:59 - line but yeah you may not always have
14:01 - these details and this ERD does not
14:04 - contain information about the types of
14:06 - data you can probably guess office code
14:08 - would probably be either a string or a
14:10 - number a city would probably be a string
14:12 - phone would be a string all of these
14:14 - would mostly be strings
14:20 - then you have employees so for employees
14:22 - we have an employee number so that's the
14:24 - primary key and I think that is going to
14:26 - be a number then there is a last name
14:28 - first name extension so this is probably
14:33 - employees work at an office so at the
14:35 - office what is the extension to reach
14:37 - this person via phone you have an email
14:39 - for the employee and interestingly there
14:42 - is this reports to feed so most
14:44 - employees in most companies report to
14:47 - other employees of the company so this
14:49 - reports to is some sort of a link from
14:51 - employees to
14:54 - the same table of employees so reports
14:57 - to would probably contain an employee
14:59 - number of another employee in the
15:01 - company
15:02 - then you have job title and then you
15:04 - have something called office code so
15:06 - office code again is going to be the
15:09 - office code of the office where the
15:11 - employee works
15:15 - so you can already start to see these
15:17 - relationships employees work at an
15:18 - office so there is an office code in
15:20 - employee and that office code should
15:22 - match with the office code of a
15:23 - particular office and then you can do
15:25 - interesting things like find all the
15:27 - employees who work at a particular
15:28 - office or maybe given an employee find
15:32 - the full phone number which is the phone
15:34 - number of the office combined with the
15:36 - extension for this employee and
15:38 - similarly you will now see other
15:39 - relationships you have customers so
15:41 - customers have all this information and
15:42 - then in customers you have the sales rep
15:44 - employee number so this is going to be
15:47 - a reference from the customers table to
15:51 - the employee table
15:52 - the employee number should match up with
15:54 - an existing employee then you have
15:57 - payments done by customers so customers
15:59 - pay by check so you can see here there's
16:01 - a customer number which is a reference
16:03 - field
16:04 - then customers place order so there is a
16:07 - table where we are recording orders
16:08 - where we have an order number order date
16:10 - some information about the order some
16:12 - comments and there is a customer number
16:14 - indicating which customer has placed the
16:16 - order
16:17 - but of course an order can contain a lot
16:20 - of information so
16:22 - you can place you can have many products
16:24 - that you would have or that you can
16:26 - include in an order so we have a table
16:30 - for products like product code product
16:32 - name product code is the unique ID
16:34 - product name product vendor Etc
16:36 - and product code there is also a product
16:39 - line which itself is another table so
16:42 - you may have four or five product lines
16:44 - and in each product line let's say the
16:46 - product lines are cars motorcycles
16:48 - ships Etc remember
16:52 - this company creates
16:56 - small scale models of vehicles so
16:59 - product lines could be the different
17:00 - kinds of vehicles
17:02 - and the products could be then
17:04 - individual vehicles or individual actual
17:06 - products that they create and then there
17:09 - is this order details so an order can
17:11 - potentially have many products that were
17:14 - ordered so in order details
17:17 - so for one order you may have several
17:19 - records in order details and you may
17:22 - have the order number you may have the
17:24 - product code and then you may have the
17:25 - quantity ordered so let's say in order
17:27 - number one
17:29 - the customer customer number 10 creates
17:32 - order number one and in order number one
17:34 - they request product number five product
17:37 - number six product number seven
17:39 - and each with a different quantity so
17:41 - order details is used to track all that
17:43 - information okay so this is how all of
17:46 - this fits together you have tables with
17:49 - columns and then you have relationships
17:50 - between tables and
17:52 - uh understanding and entity relationship
17:55 - diagram is the first step towards
17:56 - understanding what a database contains
17:58 - and all these
18:01 - symbols have certain meaning which we
18:03 - will talk about the next time when we
18:05 - talk about joins in one to many and many
18:07 - to one relationships okay
18:12 - now there are several relationship there
18:14 - are several relational database
18:16 - software packages and some of them are
18:19 - free and some of them are open source
18:20 - While others are paid and proprietary
18:22 - and the most common ones are these MySQL
18:26 - is an open source and free option they
18:29 - also have a paid option but the free
18:31 - option does the job for most people then
18:34 - you have postgres you have sqlite you
18:37 - have Microsoft SQL Server Maria DB
18:40 - Oracle IBM db2 so some of these are
18:43 - proprietary
18:45 - so for this tutorial we will use MySQL a
18:48 - free and open source relational database
18:51 - software
18:52 - now the concepts that we learned today
18:55 - will be applicable across any of these
18:58 - but the syntax the actual code that you
19:01 - need to write May differ so just keep
19:03 - that in mind and just try to understand
19:05 - the the key Concepts
19:08 - and we'll talk about how you can look up
19:10 - the differences in code Maybe by
19:12 - comparing let's say with the postgres
19:15 - database and primarily it's simply a
19:17 - matter of looking it up on the
19:18 - documentation or finding a stack
19:20 - Overflow answer over time once you join
19:23 - a company most companies will only use
19:25 - one type of database so over time you
19:27 - will become comfortable in the flavor or
19:30 - in the kind of in the software package
19:34 - that your company uses and the
19:36 - variations in SQL in the SQL language
19:38 - that software package requires but your
19:41 - skills should be transferable across
19:43 - different
19:44 - SQL variants
19:48 - Okay so we've been saying SQL a lot or
19:50 - SQL what is it so SQL stands for
19:53 - structured query language and it is a
19:56 - programming language for interacting
19:57 - with relational databases now we've set
20:00 - up this database somewhere
20:02 - and now we need to put data into it and
20:04 - then we need to get data out of it maybe
20:06 - we need to change some data within it
20:08 - for doing all of those things you use
20:11 - the SQL programming language
20:13 - and unlike general purpose programming
20:16 - languages like python Java C plus Etc
20:18 - SQL has a very limited syntax and a very
20:21 - specific use case the specific use case
20:24 - is to interact with a relational
20:26 - database it's you cannot use SQL for
20:30 - data visualization for example you
20:33 - cannot use SQL for building software
20:35 - building
20:37 - web applications you cannot use SQL for
20:39 - creating scripts you cannot use SQL for
20:42 - machine learning it's that is not the
20:44 - purpose of SQL the purpose of SQL is to
20:47 - put data into tables into relational
20:51 - database tables and get data out of
20:53 - relational database tables and make
20:54 - changes so it's all about working with a
20:57 - database without a database there is no
20:59 - SQL
21:00 - and this is what its syntax looks like
21:03 - so this is all one single SQL statement
21:05 - it's split across multiple lines but you
21:08 - will see at the end there is a semicolon
21:10 - indicating the end so here what we're
21:12 - saying and SQL is a very readable
21:15 - language so here what we are saying is
21:17 - select top three so we want to select
21:20 - the top three
21:23 - products so we want to select product ID
21:26 - from the sales table
21:29 - and you wanna
21:31 - select the product name and you want to
21:34 - select the total quantity of products
21:35 - sold
21:36 - from the table sales and then you want
21:39 - to do a join so again there is some
21:41 - joining merging involved and then you're
21:43 - doing some kind of a grouping and then
21:46 - you're doing some kind of an order by
21:47 - and then you're doing some kind of a sum
21:49 - and then you are sorting it in
21:50 - descending order so you have all of
21:52 - these things that you're putting
21:53 - together there are many pieces that are
21:55 - coming together here and we will learn
21:56 - some of these pieces this week and some
21:58 - of this pieces next week but by the end
22:01 - of these two weeks you will be able to
22:03 - understand exactly what this statement
22:06 - does and you will be able to write
22:08 - statements like it and it's not too
22:11 - difficult it's just that you have to
22:12 - understand what each of these parts
22:14 - represents okay and that's what we will
22:17 - go over step by step
22:18 - so you type in a SQL query and you send
22:21 - it to the database and then the database
22:23 - gives you a result so typically it is
22:25 - some sort of a
22:27 - subset of the table like here we are
22:29 - selecting a certain set of rows so that
22:31 - so the database is given just three rows
22:33 - of data and it has given just three
22:36 - columns of data the actual table or
22:38 - tables that this information has been
22:39 - drawn from can contain several thousands
22:43 - or millions of rows and can contain
22:45 - several columns as well so you don't
22:47 - always want to see all the data
22:48 - sometimes you just want to see the data
22:50 - that you are concerned with and
22:51 - sometimes you want also want to
22:52 - summarize data by taking the sum Etc
22:54 - okay
22:58 - now a quick note on SQL statements there
23:01 - are three types of statements in SQL one
23:03 - is called the data definition language
23:05 - so there are three parts to setting up a
23:07 - database first or using a database first
23:10 - is to set it up which means
23:12 - taking the entity relationship diagram
23:14 - and converting it into an actual
23:18 - database with actual tables
23:22 - in your local copy of the software or
23:24 - somewhere in the cloud okay so here we
23:26 - are concerned with
23:27 - generating a table generating a database
23:30 - or modifying the structure of a table
23:32 - making connections between tables that
23:34 - is called the data definition language
23:36 - or that is one of the parts of SQL then
23:39 - you have the data control language the
23:42 - control language is primarily about
23:44 - managing user access rights so for any
23:47 - database system you have a way to assign
23:51 - permissions to users so you can create
23:53 - users and then you can give users
23:55 - permissions and some users may have read
23:56 - permission some users may have write
23:58 - permissions sometimes you can also
24:00 - control information per table so you can
24:03 - control who can write to let's say the
24:05 - employees table so only the
24:07 - administrator should be able to create
24:09 - new employees but maybe all employees
24:11 - should be allowed to create new
24:12 - customers right so you have all these
24:14 - rules and that is also something that
24:15 - you can do with SQL not something that
24:18 - we will cover extensively because
24:21 - this is not something that you will have
24:22 - to deal with maybe the database
24:24 - administrator will already set this up
24:26 - for you but the most important thing
24:29 - that we will deal with is the data
24:31 - manipulation language which talks about
24:35 - which is the most frequently used subset
24:38 - of SQL and it is used for searching data
24:41 - so if you have a database getting some
24:43 - data out inserting data into a database
24:45 - updating a database updating some
24:48 - information that's already there and
24:49 - deleting data right so the crowd
24:51 - operations create read update and delete
24:55 - those are the operations covered in the
24:57 - data manipulation language now you don't
24:59 - need to really worry about these terms
25:00 - ddl DCL DML you never have to deal with
25:03 - them but it's just that you have three
25:05 - there are three ways in which we use SQL
25:08 - statements to create a databases and set
25:11 - up the structure to manage permissions
25:13 - and most importantly to actually do
25:16 - crowd operations on the data
25:19 - and before we start writing some SQL
25:21 - code a quick note
25:23 - on the syntax so SQL syntax is case
25:27 - insensitive which means that you can
25:28 - type statements in uppercase lowercase
25:31 - or a mixture of both like here we have
25:33 - select top three sales dot product ID
25:35 - you can write select in lower case you
25:38 - can maybe write S as a
25:41 - a s and lowercase and E in uppercase l
25:44 - in lower case it won't matter same is
25:46 - true with all the column names most of
25:49 - the time in most SQL distributions they
25:52 - are case invariant so you can use
25:53 - uppercase lowercase whatever seems more
25:55 - convenient to you okay
25:58 - and
26:01 - one thing that you will notice is at
26:03 - certain places we will use these back
26:05 - ticks or back codes so this is called a
26:07 - back code especially for database names
26:09 - and column names and table names now
26:12 - these are optional so wherever you see
26:14 - this character it is completely optional
26:16 - the reason it's there is
26:18 - primarily just to differentiate between
26:20 - the SQL syntax and keywords and actual
26:23 - table names and and such can we see this
26:26 - in just a moment
26:28 - then SQL statements can span over
26:31 - multiple lines so you can write three
26:33 - four five ten lines in a sec in a SQL
26:37 - statement and you have to end it with a
26:38 - semicolon that's the important piece if
26:40 - you don't put in a semicolon then your
26:43 - statement may not get executed or the
26:45 - system is still keep waiting for some
26:47 - output
26:48 - and then finally all the statements that
26:51 - we are going to execute in today's
26:53 - tutorial
26:54 - can be executed on MySQL now this MySQL
26:58 - can be running
26:59 - on your computer it can be running
27:01 - somewhere on the server and it can be
27:04 - accessed in two ways which is the
27:05 - command line or the workbench and we
27:07 - look at both in just a moment okay
27:10 - now the SQL syntax as I mentioned for
27:12 - every relational database software
27:14 - package is slightly different so if
27:16 - you're using postgres or you're using a
27:18 - Microsoft SQL server or Oracle it's
27:21 - going to be slightly different so just
27:22 - check the official documentation of your
27:24 - database for details what we will learn
27:26 - is the kind of operations that you can
27:28 - do on database tables and the specific
27:30 - syntax is just a matter of looking it up
27:33 - all right so with that let us set up
27:36 - MySQL server locally now you don't need
27:38 - to do this right now but whenever you're
27:40 - following along with this notebook a
27:42 - definitely set it up locally on your
27:44 - computer and the download takes a while
27:46 - that's why I'm recommending you don't do
27:48 - it right now but do set it up locally on
27:50 - your computer and experiment with all of
27:53 - this code all of the things that we are
27:55 - doing
27:56 - to see the effect that these statements
27:59 - have okay
28:00 - so you can download you need two things
28:02 - you need to set up the MySQL server
28:06 - so here's the MySQL server you can go to
28:09 - dev.mysql.com download slash MySQL
28:12 - and select your operating system in my
28:14 - case it's Mac OS and then select the
28:16 - kind of archive you want to download you
28:18 - can see that this is a 415 MB file so it
28:21 - takes a while to download now I've
28:23 - already done the download so I don't
28:24 - need to do this again but if you're on
28:27 - Linux for instance then you may want to
28:30 - either download a tar archive or
28:34 - if you do download a tar archive then
28:36 - you may have to follow some additional
28:38 - instructions as well if you're on
28:40 - Windows I think you should be able to
28:41 - download yeah you should be able to
28:43 - download
28:45 - a zip archive that you can directly
28:48 - open up an Exe on
28:50 - I think on Lin on Ubuntu you should be
28:52 - able to download some kind of
28:53 - installable bundle so whatever operating
28:57 - system you're using you should be able
28:58 - to download one version
29:01 - now we just need the MySQL server we
29:03 - don't need anything more than that but
29:07 - and the MySQL server will set up a
29:09 - database for us and allow us to create
29:11 - tables within databases and query
29:13 - databases and so on and you can run it
29:15 - and we are going to run it locally but
29:17 - it can just as well be hosted on a
29:19 - server as well right so but we are going
29:21 - to run it locally
29:22 - to interact with the MySQL server one
29:25 - way is to use the
29:28 - command line interface so now in my case
29:31 - I have installed it on Mac so I'm just
29:33 - going to open up a terminal
29:36 - and let me zoom in this terminal a
29:38 - little bit
29:43 - yeah so now I have opened up a terminal
29:46 - and when I installed MySQL after
29:49 - downloading
29:50 - it created this folder slash USR slash
29:53 - local slash MySQL
29:56 - so it created this folder and you can
29:58 - see this folder here if I do LS
30:01 - and where did I find this well I just
30:03 - looked it up where does MySQL get
30:05 - installed on Mac OS and I got this
30:07 - response where it's in slash USR slash
30:09 - local MySQL in your case in your
30:13 - operating system this location may be
30:15 - different this may be in C program files
30:17 - or this may be in somewhere else on
30:18 - Ubuntu so you would have to look this up
30:21 - but in this folder slash user slash
30:24 - local MySQL there is a folder called bin
30:27 - so I'm just going to type slash bin here
30:29 - and then there is a folder called let me
30:32 - just check LS on bin so you have a lot
30:34 - of things inside bin but the one we
30:37 - should be concerned with is MySQL the
30:39 - command line interface
30:41 - so I'm just going to run slash user
30:44 - slash local slash bin slash
30:46 - MySQL so now this is a command line tool
30:50 - that I'm going to run
30:53 - okay and to run this the first thing
30:56 - that you will need to do is you will
30:57 - need to provide a username and by
31:00 - default when you install MySQL it will
31:02 - have the username root
31:05 - and then you also need to provide a
31:07 - password when you're installing so when
31:08 - you download this file and then you're
31:11 - set doing going through the installation
31:12 - steps it will ask you to set a root
31:14 - username and a root password in my case
31:17 - I set my root username to root that was
31:19 - the default option and I did set a
31:21 - password as well so here is how you
31:23 - specify the username and the password so
31:26 - you say
31:27 - you give the path to the MySQL binary or
31:30 - the MySQL command line tool and you
31:33 - specify using minus U which user is
31:36 - trying to access it and root was the
31:38 - default user that they had that it had
31:39 - set up and you specify minus p and it
31:42 - will prompt you for a password so I'm
31:44 - just going to type in the password Here
31:54 - yeah so I've just typed in the password
31:56 - now and now what has happened is MySQL
32:00 - was already running on my computer after
32:02 - I installed it
32:05 - but now I have logged in into this
32:08 - database server which is running on my
32:10 - computer as the user root okay and if
32:15 - MySQL is not already running on your
32:17 - computer then you will not be able to
32:20 - log in so if you get an error here that
32:22 - MySQL is not running then you would have
32:24 - to go and check in my case what happens
32:27 - is
32:28 - on Mac OS
32:33 - yeah so on Mac OS it creates a it
32:35 - creates this MySQL option in settings so
32:38 - if I go to my system preferences it
32:39 - creates this option
32:41 - MySQL and here I can actually stop and
32:44 - start my server here I can also just set
32:47 - up some configuration about where MySQL
32:49 - is going to store all of its data right
32:51 - so by default MySQL will start up
32:54 - whenever my computer starts up so I can
32:56 - set all these configurations right so
32:58 - the MySQL is is a application that is
33:01 - always running on my computer and it
33:04 - starts up when the computer starts up it
33:05 - shuts down when the computer shuts down
33:07 - you will have to set it up separately on
33:10 - Linux or on Windows and when you do
33:12 - install it normally it all of this
33:14 - should be taken care of automatically
33:17 - okay so make sure that MySQL server is
33:20 - running and find the path to this MySQL
33:23 - binary which is on Ubuntu also I think
33:26 - it's user local MySQL bin MySQL on
33:29 - Windows it might be slightly different
33:31 - and then login into MySQL so login into
33:34 - the server as the root user and once
33:37 - you've logged it into the root user you
33:39 - will see a welcome message and you will
33:42 - see the version of the MySQL server
33:45 - that's running on my computer
33:47 - and now I can start interacting with it
33:50 - on this prompt so as you see here it
33:52 - says MySQL and then I can start typing
33:54 - SQL commands here
33:57 - okay so that's one way to interact with
34:00 - this database and I am currently running
34:03 - on my local machine but
34:07 - if there was a MySQL server that was
34:10 - running somewhere on the cloud and I had
34:12 - the URL to that server so I could also
34:14 - put in the URL there's a way to specify
34:16 - the URL when running this tool and you
34:18 - can use this tool to connect to any
34:20 - mySQL database anywhere in the world as
34:23 - long as it is publicly accessible and
34:25 - you know the username and password for
34:27 - it okay so if you have the URL to a to
34:29 - mySQL server you can log in into that
34:31 - MySQL server as well like for example I
34:34 - from my computer can log in into the
34:36 - Jovian production MySQL server and maybe
34:40 - make changes to my username and things
34:43 - like that okay
34:49 - all right so that is one way to access
34:51 - MySQL that is one way we will look at
34:53 - today
34:54 - but another way to access MySQL is using
34:57 - the MySQL workbench so there is another
34:59 - installation link that we've included
35:01 - here this is to download the workbench
35:03 - which is basically this graphical user
35:05 - interface
35:08 - so you can download the workbench this
35:10 - is a again 100 MB download and the
35:13 - workbench also
35:15 - let me open it up the workbench also
35:18 - connects to a MySQL server so when you
35:21 - log in for the first time you will see
35:23 - that it automatically detects that you
35:24 - have a MySQL server running locally but
35:28 - if you want you can also connect to
35:29 - something that is running somewhere on
35:31 - the cloud so again if you have the IP
35:33 - address or if you have the host name if
35:35 - you have what port it is running at if
35:37 - you have the username and password for a
35:40 - database server running on the cloud
35:41 - then you can get those details and
35:43 - connect to that database so typically in
35:46 - a company setting what will happen is
35:49 - the team that you're working with or the
35:52 - person that you're reporting you that
35:54 - you're reporting to will tell you that
35:56 - here is where our database lives so you
35:59 - should set this IP for our database you
36:01 - should set this port you should use this
36:03 - username we've created a username for
36:04 - you you should set this password
36:07 - and then you should then you can click
36:09 - connect or you can even test the
36:11 - connection first and then you can click
36:12 - connect and then you will automatically
36:14 - get connected to the company database
36:17 - and then you can work on the company
36:19 - database or your teams database and get
36:21 - data out of it or write data into it do
36:23 - queries on it
36:25 - in our case today we are going to just
36:27 - use the local installation that we have
36:29 - of MySQL so I'm just going to connect
36:31 - MySQL workbench to the local
36:33 - installation
36:34 - all right so this is what it looks like
36:36 - and the kind of queries that you type
36:39 - here for example
36:41 - I can type a query
36:48 - so for example I can type a query here
36:50 - on the MySQL command line tool show
36:52 - databases
36:57 - and I can type the same query here in
37:00 - the MySQL workbench
37:03 - show databases
37:07 - and then I can run it so this is the way
37:09 - to run it
37:13 - or you can also press Ctrl enter or
37:15 - command enter to run it and it shows the
37:17 - same information so here it shows the
37:19 - information classic models information
37:21 - schema MySQL performance schema Etc
37:24 - and here it shows the same information
37:26 - as a table okay so it's just a little
37:28 - nicer here everything is shown as text
37:31 - here you can interact with it a little
37:32 - bit you can click on things and such
37:35 - so those they are just two different
37:37 - ways of interacting with the same
37:39 - underlying database that's running
37:42 - locally right now and both of these can
37:45 - also connect to things on the cloud
37:48 - okay so with that out of the way we can
37:51 - finally start working with databases
37:54 - so let us set up a database for classic
37:56 - models in my case I have already set up
37:59 - a database let me just remove that
38:01 - database for now
38:11 - okay all right so once you are connected
38:14 - either through the command line or using
38:17 - the
38:18 - MySQL workbench to a SQL Server so the
38:22 - server code again could be running
38:23 - locally or on the cloud you can start
38:25 - writing SQL statements so the first
38:28 - thing that you want to do as soon as
38:29 - you're connected to a database server is
38:31 - to just list the databases that are
38:33 - present on the server so I can just type
38:35 - show databases
38:38 - and put a semicolon
38:41 - and that is going to show me the list of
38:43 - databases that are present on the server
38:44 - so by default right now I've just set up
38:47 - this MySQL server on my computer so
38:50 - these are all some of the default
38:51 - databases that MySQL already has so we
38:53 - definitely don't want to disturb any of
38:55 - these switches information schema MySQL
38:57 - performance schema and sys okay but once
39:00 - you create more databases you will start
39:02 - to see those databases showing up here
39:06 - so that's the first thing show database
39:08 - is going to show you a list of databases
39:11 - then the next thing you can do is
39:16 - create you can create databases so here
39:19 - is how you create a database you type
39:21 - create database and then you type the
39:24 - database name so I'm going to create a
39:26 - database
39:27 - classic models
39:30 - and let me just run the statement so
39:32 - I've typed create I've typed database
39:34 - and I've typed the name of the database
39:35 - classic models
39:38 - and now the database is created and I
39:40 - can check show
39:41 - databases
39:44 - once again
39:45 - and now you see you have classic models
39:47 - here as a new database that has been
39:49 - created
39:51 - now
39:52 - in this notebook what you will see is
39:54 - the statements are typed in uppercase
39:57 - create databases uppercase and one other
40:00 - thing you will notice is that all
40:01 - database names column names table names
40:03 - all of these are lowercase and they are
40:05 - indicated with these back ticks this is
40:07 - called a back tick this is just for
40:09 - visual separation so that you know that
40:12 - this is this is a SQL keyword and this
40:15 - is the name of a column or a database or
40:18 - a table so this is just for that visual
40:20 - separation so that when you're going
40:21 - through this notebook it's clear to you
40:23 - and you can also run it like this you
40:25 - can take this code and you can run it
40:26 - exactly the same way as it is typed here
40:29 - or you can type it without any of the
40:31 - back text and just in lower case and
40:33 - this is also perfectly fine except that
40:35 - it's a bit difficult to read okay
40:39 - so now that we've created the the
40:40 - database we can now show the database as
40:42 - well
40:43 - grade and if we try to create it again
40:47 - MySQL will give us an error so you can
40:49 - see here we run create database classic
40:51 - models and it says it can't create a
40:54 - database because a database already
40:55 - exists
40:57 - so we can also specify a condition
41:00 - to create the database only if it or
41:02 - doesn't already exist so if we say
41:04 - create database if not exists classic
41:06 - models
41:10 - so this is when we don't know if the if
41:13 - the if there's already a database with
41:15 - that name on our server so
41:18 - then we can create that database if it
41:20 - does not exist if it does exist then
41:22 - nothing happens so if we type this
41:23 - create database if not exists you can
41:26 - say you can see that it says query okay
41:27 - one row affected but there was no real
41:29 - change like if we say just show
41:32 - databases you can see that we have
41:33 - classic models information schema MySQL
41:35 - performance schema and sys so no change
41:38 - here on the other hand if we had typed
41:40 - create database if not exist classic
41:42 - models too
41:43 - and by the way I'm using the up Arrow
41:45 - key to cycle back to older commands
41:48 - so up and down is how you cycle between
41:50 - older and your commands
41:54 - so if I type create database if not
41:56 - exist classic models 2 you will see now
42:02 - that we have classic models and classic
42:03 - models too which got created okay
42:07 - so now we have several databases on our
42:11 - server
42:13 - and typically for every project that
42:15 - you're working on you would create a
42:16 - database or sometimes every team would
42:18 - have a database on the database server
42:20 - so there are many different reasons for
42:22 - why you may want to have different
42:23 - databases but for classic models the
42:26 - company we're just going to create this
42:27 - one database okay
42:29 - and when you are connected on a server
42:32 - and you want to work with a certain
42:33 - database let's say you want to get data
42:34 - out of the database you want to add
42:36 - tables remove tables add rows remove
42:38 - rows you have to tell which database you
42:40 - want to use so we can say use classic
42:42 - models
42:46 - and once you say that then MySQL is
42:50 - going to change the database to use or
42:53 - is going to point to Classic models as
42:55 - the default database to which all
42:57 - operations will be applied so let's say
42:59 - now if we do something like a create
43:00 - table operation which we'll see now and
43:03 - then we type the name of a table and the
43:04 - columns that it has then that table will
43:07 - get created inside the classic models
43:09 - database okay so whenever you get
43:11 - started always make sure that you are
43:13 - running the use statement to select the
43:16 - database that you want to operate on
43:19 - typically MySQL remembers this so you
43:21 - won't have to do it over and over but
43:24 - whenever you log in it's always a good
43:25 - idea to just run use classic models
43:29 - all right so that's how you use a
43:31 - database and one last thing I want to
43:33 - cover is how to delete a database to
43:35 - delete a database you just type drop so
43:38 - we have currently classic models classic
43:40 - models two information schema Etc so I'm
43:43 - just going to do drop database
43:46 - classic models too
43:50 - and a semicolon
43:52 - and now if we check show databases
43:55 - you can see now we no longer have
43:57 - classic models too that database was
43:59 - deleted I can also go ahead and drop
44:02 - classic models and then you will see
44:05 - that now we no longer have classic
44:06 - models either
44:08 - okay now be careful about drop because
44:10 - as soon as you run the drop statement
44:12 - the data will be deleted permanently
44:14 - there is no trash and there is no
44:16 - warning there is no confirmation and
44:19 - typically your company will not give you
44:21 - access to drop databases for good reason
44:24 - but regardless you should be very very
44:27 - careful about running the drop database
44:29 - command okay
44:32 - so as an exercise you can now just try
44:34 - creating deleting using some databases
44:37 - using the commands that we've covered
44:38 - and also try and figure out how to
44:40 - rename a database so now you can try and
44:42 - look it up on the MySQL documentation or
44:45 - just by searching online how to rename a
44:47 - database okay next just before we move
44:49 - forward let's just recreate the database
44:51 - classic models because we are now going
44:53 - to create some tables with it so I'm
44:56 - just going to run create database if not
44:58 - exist classic models and use classic
45:00 - models
45:03 - all right so now our database is created
45:07 - and we can start using it okay let's now
45:11 - talk about how we can work with tables
45:13 - now
45:15 - we remember the entity relationship
45:17 - diagram that we created for the classic
45:20 - models company
45:24 - we can now start adding some tables
45:26 - based on the ERD and
45:30 - there are a few statements there are a
45:31 - few four or five statements that we need
45:33 - to understand to work with tables
45:36 - the first one is to list the tables in a
45:39 - database now once you select a database
45:41 - using the use command you can list the
45:43 - tables in a database using the show
45:45 - table statement
45:46 - so if we go here and we say use classic
45:49 - models
45:52 - and then we say show tables
45:56 - you can see that currently it says empty
45:58 - set because we've just created the
46:00 - classic models database so it does not
46:01 - have any tables but we know that it is
46:04 - empty so we know that much
46:07 - then to create a table
46:13 - we can use the create table statement
46:15 - and here's what the create table
46:17 - statement looks like you type create
46:19 - table and then you type the name of the
46:21 - table and then you have
46:23 - this you open these brackets or these
46:25 - parentheses and then you type the name
46:27 - of a column and then you type the data
46:29 - type of the column and then below it you
46:32 - also have some constraints about the
46:34 - tables or some other information that
46:36 - you want to specify about the table so I
46:38 - just want to show you an example of what
46:40 - a create table statement looks like so
46:42 - here is the ERD diagram for the offices
46:45 - table now for the offices table we have
46:48 - this office code which is the unique
46:51 - identifier for each office or this is
46:53 - also called the primary key in SQL then
46:56 - we have all this information City phone
46:58 - number address line one this is all
46:59 - required and then we have address line
47:01 - two State this is optional information
47:03 - then we have country postal code
47:05 - territory this is required and then we
47:07 - have office location which is optional
47:10 - so this is what the create table
47:12 - statement for office
47:15 - for offices looks like so we say create
47:18 - table offices and again you can skip
47:22 - these backticks these are just for
47:24 - convenience sometimes column names can
47:26 - have spaces so to handle things like
47:28 - spaces we have backticks but here you
47:32 - can just use you can just use it to
47:34 - visually identify what is a SQL
47:36 - statement and what is a name of a
47:38 - database or a column or a table so we
47:41 - say create table and then we type create
47:43 - table with the name offices and then we
47:45 - open up this bracket and we say office
47:48 - code so that is the name name of the
47:50 - first column
47:51 - and office code is going to be aware
47:54 - care so this is the data type and we'll
47:56 - talk about the data types and so it is
47:58 - going to be a
48:00 - character list or a variable number of
48:03 - characters that's what it means where
48:04 - care of up to size 10. so office code
48:07 - can be one one character two character
48:09 - three character up to 10 characters
48:12 - then we are specifying here a constraint
48:15 - that it is not null which means that it
48:17 - cannot be empty then we have City again
48:20 - which is a wirecare 50 so it can be a
48:22 - string where care simply corresponds to
48:25 - a string essentially it can be string up
48:27 - to 50 characters long again not null
48:29 - then it will have a phone number again
48:32 - it will be a string not null it will
48:34 - have an address line it will have a
48:36 - second address line and this time
48:39 - it will this can be null so we don't
48:41 - necessarily need to have a second
48:43 - address line it can have a state again
48:46 - this information can be null it can have
48:48 - a country
48:49 - this should be should we not null a
48:51 - postal code a territory okay so
48:54 - territory would typically be I think it
48:56 - would probably be country or maybe the
48:58 - territory which the office operates in
49:01 - okay so we'll see an example of this and
49:04 - finally at the end of specifying all the
49:07 - columns we are also specifying this
49:09 - constraint or this additional piece of
49:11 - information that we want office code to
49:15 - be the primary key for this column so
49:18 - what this does
49:20 - is the primary key constraint uniquely
49:23 - identifies each record in the table so
49:25 - the office code value in the office code
49:27 - column will uniquely identify each
49:29 - office and what that means is that
49:32 - you can only have
49:34 - one row with a specific office code you
49:36 - cannot have two offices or two rows of
49:38 - data with the same office code and it
49:42 - also cannot be null and that's why we
49:43 - have specified not null here already
49:45 - okay
49:47 - and a table can have only one primary
49:50 - key constraint so you you can select
49:53 - multiple columns you can say that the
49:54 - primary key is office code comma City
49:57 - although in this case it will not make
49:59 - sense sometimes it does so you can
50:01 - select multiple columns as the primary
50:03 - key so a primary key can consist of
50:05 - multiple columns but you should only
50:08 - have the statement written once so if
50:10 - you want to select office code comma
50:12 - City so both of those together as a
50:13 - primary key then you you should write
50:15 - primary key office code comma City and
50:17 - not primary key office code and in
50:19 - another line primary key City okay
50:21 - that's a more special case that doesn't
50:23 - really happen so for now let's just take
50:27 - this code
50:28 - and let us run it
50:30 - here
50:32 - in our MySQL command line
50:35 - okay and we run it and as soon as we run
50:38 - it it says query okay zero rows affected
50:41 - so whenever you see okay that means that
50:43 - it has had the intended effect so now if
50:45 - we run show tables again
50:50 - you will see now that there is one table
50:52 - in classic models the table is called
50:55 - offices
50:56 - okay now talking about
51:00 - the data types you see wire care if most
51:03 - of these are bad care but
51:05 - there are several supported data types
51:07 - in SQL so here are some of them you can
51:10 - have numeric data you can specify that a
51:12 - column is a bit bit means it's going to
51:14 - be a zero or one or a tiny integer I
51:17 - think that is going to be one byte which
51:19 - means it can take values from 0 to 64.
51:24 - a small integer I think that would be
51:26 - four bytes
51:28 - a normal integer I think that would be a
51:31 - small integer would be two bytes a
51:32 - normal integer would be four bytes a big
51:35 - integer would be eight bytes etcetera so
51:37 - the differences between all of this is
51:39 - simply in the
51:41 - range of values that they can hold bit
51:43 - Can Only Hold zero to one big end can
51:45 - probably hold from minus 2 billion to 2
51:48 - billion
51:49 - so depending on what range you think
51:52 - that your numbers can take you can
51:55 - choose the right data type and if you're
51:56 - unsure just go with int or begin just to
52:00 - be safe
52:01 - a lot of companies have had to change
52:03 - from int to begin once they hit maybe a
52:06 - billion users so not many such companies
52:08 - but that is what that was a real problem
52:10 - they probably didn't expect to hit a
52:12 - billion users and they had to change
52:14 - from in to begin for user IDs
52:17 - numeric user IDs
52:19 - then you have the decimal data type so
52:22 - if you're sure about how many digits of
52:24 - decimal you want then you can use the
52:25 - decimal data type as well or you can
52:27 - also use a numeric data type
52:29 - I think this allows you to put in any
52:31 - kind of data something that you would
52:33 - have to look up you can use the float
52:35 - data type to work with floating Point
52:37 - numbers here you can specify how many
52:39 - digits of precision you want and then
52:41 - you have the real data type as well so
52:43 - again not all of these data types are
52:45 - supported by all SQL software because
52:47 - every all companies have implemented
52:49 - their own version and they have their
52:51 - own optimizations so you would have to
52:53 - look up whichever package you're using
52:56 - like for MySQL you would have to look up
52:58 - which of these numeric types MySQL
53:00 - supports
53:01 - and then there are date related types so
53:04 - you typically have a date time and then
53:06 - a date time or a time stamp
53:09 - data type for working with dates then
53:12 - you have the character types so you can
53:15 - have a character which is a single
53:16 - character or you can also specify when
53:19 - creating a cad data type how many what
53:21 - is going to be the exact length so if
53:23 - you have if you are sure that you will
53:25 - always have five characters in a column
53:27 - you use care or care five so just as we
53:30 - have written wirecare 50 you can write
53:32 - five and then you always have to put in
53:35 - five characters or you can put in where
53:37 - care and wear care means that you can
53:41 - put up to 50 characters so if you type
53:43 - wirecare 50 that means you can put up to
53:45 - 50 characters
53:47 - and then you have the text data type
53:48 - which is typically used for very large
53:52 - strings so if you want unbounded if you
53:56 - don't want a limit on the number of
53:57 - characters then you can use the text
53:59 - data type
54:01 - now what is the benefit of
54:03 - not using text maybe using wire care it
54:06 - is efficiency when you can specify the
54:09 - number of characters your data can take
54:12 - based on that the database
54:14 - server can perform some optimizations to
54:17 - make queries faster but if you want to
54:19 - use the text data type then you are
54:20 - giving up on some performance
54:25 - then you have these Unicode characters
54:27 - which is a special case of characters
54:28 - you can also store some binary data and
54:31 - then you can also store something called
54:32 - a blob which is like a large binary
54:34 - object so you can store XML Json and
54:36 - these are more specialized types that
54:38 - are not supported by all SQL servers but
54:41 - numeric date and characters or strings
54:44 - are the most common data types okay
54:47 - so that was data types and next Once a
54:51 - table is created you can also check
54:54 - once the table is created you can also
54:56 - check
54:57 - the table that the table is created
54:59 - using show tables here we've typed show
55:01 - tables and we were able to see the table
55:03 - and if you want to get information about
55:05 - what columns the table contains you can
55:07 - use the describe
55:09 - command so let's type describe
55:12 - and let's type the name of the table the
55:14 - name of the table is offices
55:17 - and when you type describe offices you
55:19 - can see here these are all the fields
55:21 - office code city phone address line
55:23 - State country postal code territory all
55:26 - of these are where care some of these
55:28 - are nullable which means some of these
55:30 - can be null and some of these cannot
55:32 - should not be null and office code is
55:34 - the primary key okay so still this is
55:36 - still information about the table this
55:38 - is not information in the table it's
55:39 - just information about all the columns
55:41 - of the table
55:42 - and you can also specify default values
55:44 - for some of these columns let's say you
55:47 - want to specify a default value of phone
55:48 - number to the phone number of the
55:51 - headquarters so that there is always a
55:53 - number listed on your website so you
55:55 - could have specified that the way to
55:56 - specify your default is to say
56:00 - let's say phone number not null and
56:03 - you could instead say here phone number
56:07 - default
56:09 - and then you can give the phone number
56:10 - that you want to have as the default
56:12 - phone number okay maybe plus one
56:16 - that's the default phone number so that
56:18 - will be the default phone number that
56:19 - will be put in for any Row in the data
56:24 - okay
56:25 - so now we've created a table we have
56:27 - seen what its Fields look like we have
56:29 - seen that that table got created
56:31 - let's put some actual data into the
56:34 - table so to insert data into the table
56:36 - we use the insert into statement so
56:38 - here's how the insert into statement
56:39 - works you type insert
56:41 - into and then you type the name of the
56:44 - table so the name of the table is
56:45 - offices and then you type the columns
56:48 - the names of the columns that you want
56:50 - to specify so I want to provide the
56:52 - office code I want to provide the city I
56:55 - want to provide the phone I want to
56:56 - provide the address line one and maybe I
57:00 - won't provide address line 2 because I
57:03 - don't have that information I am not
57:04 - going to provide state I'm going to
57:06 - provide country I'm going to provide
57:08 - postal code and I'm going to provide
57:12 - territory okay so we say insert into
57:15 - offices and then we give the list of the
57:18 - column names that we are going to supply
57:19 - and then we say values and then we
57:22 - provide the values for these column
57:24 - names so okay now I'm going to insert
57:26 - create this new office with the office
57:27 - code AAA
57:30 - and it is going to be in Bengaluru
57:34 - and the phone number is going to be plus
57:37 - 9 1
57:40 - that and then the address line is just
57:43 - going to be
57:45 - well let's just put it as
57:47 - 1 mg Road
57:51 - and then we have a postal code let's
57:54 - just put that as
57:58 - five six
58:01 - zero zero one
58:06 - oh we also have to specify the country
58:08 - so the country is India
58:12 - and finally let us put in a territory
58:14 - here so I guess that this will probably
58:16 - serve the territory of Asia
58:20 - right so let's then put the semicolon
58:23 - here so what have we done insert into
58:25 - name of the table list of the columns
58:27 - that we want to supply information for
58:30 - put in then type values then give a list
58:34 - of the actual values for each of these
58:36 - columns and then we can hit enter and
58:38 - you can see query okay one row affected
58:40 - and now this is going to insert the data
58:42 - into the table
58:44 - how do you get data out of a table well
58:47 - the way you get data out of a table is
58:50 - by typing select you can type select
58:54 - and then after typing select you type
58:57 - which columns you want so let's say I
58:59 - just want to get the office code
59:02 - and I want I want to get the city
59:05 - from
59:06 - the name of the table the table name is
59:08 - offices
59:12 - and then I put in a semicolon
59:23 - yeah sorry no no brackets here so you
59:26 - type select and then you type the name
59:27 - of the columns that you want to select
59:29 - and then you say from offices okay and
59:32 - you can see that it starts to get a
59:33 - little bit confusing now because
59:34 - everything is written in lower case and
59:36 - that's why we often write
59:40 - the column names in lower case and we
59:43 - write the
59:44 - SQL commands in uppercase
59:47 - okay and sometimes we also put backticks
59:49 - just to make it super clear
59:51 - and especially if you have names in if
59:54 - we have spaces and column names okay so
59:56 - select office code comma City from
59:58 - offices so now it is giving us the
60:00 - office code and it is giving us the city
60:02 - for all the rows of data in the database
60:06 - in the
60:07 - table offices so we have inserted one
60:10 - row we inserted a row with all this
60:12 - information and then we viewed it using
60:15 - select now if we had inserted multiple
60:17 - rows we would be looking at the data for
60:19 - multiple
60:21 - rows of data how do you insert multiple
60:23 - rows inserting multiple rows is the same
60:25 - as inserting one row you just say insert
60:28 - into offices and then names of columns
60:30 - and then type values and then you give
60:31 - one set of values then you give a comma
60:34 - and you give the second set of values
60:36 - and so on so let's insert multiple rows
60:38 - I'm going to copy insert into offices
60:41 - and then I have a bunch of rows of data
60:43 - here
60:45 - so I'm going to copy all those rows of
60:46 - data
60:51 - okay it's going to be a bit difficult to
60:53 - copy this all right let's just copy it
60:56 - this way now this is a lot of code there
60:58 - so I am going to instead of using the
61:00 - MySQL command line which I can do I can
61:03 - just paste the command paste on the
61:04 - command line here I'm just going to show
61:06 - it to you on the workbench
61:13 - okay so I'm just going to type it here
61:14 - into the workbench
61:16 - you can always just click new query and
61:19 - oh sorry yeah you can just always click
61:21 - this new query here and then just type
61:23 - it
61:24 - so here now we have insert into offices
61:26 - we have all these columns that we want
61:28 - to insert and then the values we have on
61:31 - we have one one set of values two set of
61:34 - values three four five six all the way
61:35 - up to seven so we are inserting seven
61:37 - values and at the end you will notice a
61:39 - semicolon here at the end of the last
61:41 - statement and we can run this command
61:44 - and now we get a success result here
61:50 - oh we need to select a database first so
61:53 - let me cut this and let me say use
61:58 - classic models
62:01 - and let me run that so that has been
62:03 - selected the database is selected then
62:05 - let us paste it back
62:08 - okay now we have insert into offices and
62:11 - now we run insert into offices and you
62:13 - can see that it it executed successfully
62:16 - so now we have inserted into offices and
62:18 - I can create a new query here
62:20 - I can
62:25 - yeah so I can now remove this and I can
62:27 - type
62:31 - select
62:33 - and if I want all the columns I just
62:35 - type star so select star from offices
62:38 - and then I run it
62:40 - and that is going to now show this data
62:42 - in this tabular format okay so now you
62:45 - can see that we have all these offices
62:46 - San Francisco Boston NYC Paris Tokyo
62:49 - Sydney London Bengaluru and this is the
62:52 - same information that we had shown that
62:53 - we had inputted here that is also
62:55 - available so
62:57 - through the command line and through the
62:59 - workbench we are connecting to the same
63:00 - database and we can run these commands
63:02 - in either place and I can type it here
63:04 - as well select star from offices so now
63:08 - when I say star it is going to select
63:10 - all the columns
63:13 - and here's what that looks like it's a
63:16 - bit messed up the output because it's
63:17 - trying to display it all on one line but
63:20 - if I zoom out a little bit you should be
63:21 - able to see the output
63:23 - yeah
63:25 - so you can see the output now when I do
63:27 - select start from offices it is giving
63:29 - me the same table that I am able to see
63:32 - here on the workbench
63:39 - okay
63:40 - so that is insert and select
63:44 - just a quick reminder on how these work
63:47 - so you can say insert into and then
63:49 - provide the table name provide the names
63:51 - of the columns you want to insert
63:52 - provide the values and then provide
63:54 - lists of values to insert so list of
63:56 - rows and if you're providing data for
63:59 - all the columns then you can skip this
64:01 - part which is the column names so you
64:03 - can just say insert into table name
64:04 - values and then you can give lists of
64:07 - values and that will work fine too for
64:09 - example here when we are inserting
64:11 - offices we are using all the columns
64:13 - here so I can actually just completely
64:15 - skip this last thing I can skip this
64:18 - names of columns and I can just say
64:19 - insert into offices values and give it
64:21 - the list of values
64:24 - then to view the data the simplest way
64:26 - to view data is using the select
64:27 - statement so it has the syntax select
64:30 - column one comma column two comma so on
64:32 - from table name and you can also view
64:34 - the data from all the columns using
64:36 - simply saying select star from table
64:38 - name
64:39 - okay so that's how we put data and get
64:42 - data so now we've covered C and R create
64:45 - and read and we'll look at update and
64:47 - delete as well
64:49 - and here are some exercises for you try
64:51 - adding some more entries into the
64:53 - offices table
64:55 - using just the required column so an
64:58 - example that we typed out on the MySQL
65:00 - command line try typing it out yourself
65:02 - try doing it from the command line try
65:04 - doing it from the workbench
65:07 - and see what happens
65:08 - see what happens if you don't provide a
65:10 - value for a column marked as not null
65:13 - okay maybe here if I go back to one of
65:16 - these and if I try and change this
65:19 - let's say I changed the office code to
65:22 - aab and I provide I don't provide a
65:25 - value for territory which is supposed to
65:27 - be non-null
65:28 - let's see what it's going to give us so
65:30 - it's going to give us an error but you
65:31 - want to do you want to make these
65:33 - mistakes and you wanna
65:34 - understand what kind of Errors you get
65:36 - like here it says field territory
65:37 - doesn't have a default value so
65:40 - look through it and try to break things
65:42 - and try to become familiar with errors
65:44 - so that when you encounter them you will
65:46 - be able to debug them more easily so try
65:49 - adding an entry with the primary key
65:50 - matching an existing entry so maybe
65:52 - let's try that let's try putting in AAA
65:55 - again and let's just make it Bengaluru
65:58 - 2. and let's just put in
66:02 - territory Asia here
66:07 - and let's add back territory here
66:12 - so you will now see that
66:16 - okay I probably have
66:21 - yeah there's probably a syntax
66:23 - error here
66:27 - okay I made a syntax error here
66:28 - somewhere
66:30 - but if I just try to insert the same
66:33 - data again like a Bangalore root 2.
66:37 - you will see that now it says that
66:38 - there's a duplicate entry AAA for the
66:40 - key officers.primary and that data is
66:42 - not inserted okay
66:44 - so test these out the more you try the
66:46 - more the better you will understand how
66:47 - some of these things work and try and
66:49 - retrieve and display just the city and
66:51 - phone number information for each office
66:53 - that has been created so just do a
66:55 - select statement and try that out too
66:59 - and that's the first table that we've
67:01 - created we've put some data into the
67:03 - table we have looked at the structure of
67:05 - the table and we've retrieved some data
67:07 - from the table as well next is the
67:08 - employee stable so we've created one
67:10 - table and now we are creating a second
67:11 - table and we will connect this table to
67:13 - the first table
67:15 - and a quick note if you want to first
67:18 - delete a table then you can use drop
67:20 - table so if you type drop table that
67:22 - will delete the table with all its data
67:25 - like if I type
67:26 - drop table and then I type Offices here
67:29 - that's going to delete the offices table
67:31 - I don't want to do that right now
67:33 - because I've put some data into it and
67:36 - you can also have something like this
67:38 - that if the table exists you can drop it
67:40 - so if we type drop table if exists
67:42 - employees
67:44 - this is not going to make any change
67:46 - because if I do show tables
67:49 - there was no employee stable before and
67:51 - there's no employee stabled now but
67:53 - whenever you're creating a table you can
67:55 - always it's a good idea to First maybe
67:57 - drop the previous table if you're sure
67:59 - that you don't need the old data if you
68:01 - want to Fresh
68:02 - table to be created so you can just drop
68:05 - the previous table if you if you want
68:07 - right so that's why we have this
68:08 - statement here for you as well
68:11 - so okay let's talk about creating the
68:13 - table employees so let's copy this code
68:15 - and here we have an employee number so
68:17 - that's an integer our first encounter
68:19 - within teacher
68:21 - and here we're saying 11 so I think what
68:24 - we are specifying here is
68:26 - I I think it might be 11 bytes or 11
68:29 - digits I'm not sure I think it's going
68:30 - to be 11 bytes I'd have to look it up
68:33 - then we have the last name which is a
68:35 - wire care or a string a first name is a
68:37 - string extension this is their phone
68:40 - number extension so they will be at a
68:42 - certain office and that's why we have
68:44 - office code here and then we have an
68:46 - email which is again a wire care of a
68:49 - hundred and then we have a reports too
68:51 - so two interesting things here one is
68:54 - office code so we have now A office code
68:56 - column and this should ideally contain a
68:59 - value of a valid office code how are we
69:02 - going to ensure that we will see and
69:04 - second reports to and this can be null
69:06 - so office code should not be null every
69:08 - employee belongs to an office but
69:10 - reports to can be null because obviously
69:14 - there will be somebody in the company
69:15 - who does not report to anybody
69:19 - but otherwise reports to and maybe some
69:22 - people may not have been assigned a
69:24 - manager or a reporting person so reports
69:27 - to can be null but reports to should be
69:30 - somebody's employee number let's say you
69:33 - have
69:35 - siddhant and biraj and if barrage
69:39 - reports to siddhant then reports to in
69:42 - the entry for biraj
69:44 - should be the employee code or the
69:46 - employee number of Siddharth okay how do
69:49 - we ensure that we look at that then we
69:52 - have the job title this is just a simple
69:54 - string
69:55 - and we are setting here that primary key
69:57 - is employee number that makes sense we
70:00 - want to uniquely identify each employee
70:02 - with a primary key and
70:05 - this was going to be not null so that's
70:07 - fine too
70:09 - and then we have these two in two
70:11 - statements foreign key so here we are
70:13 - saying
70:14 - that reports to the column reports to
70:18 - references the table employees
70:22 - and in the table employees it references
70:24 - employee number
70:25 - okay that's one and then we have another
70:28 - foreign key office code so here we are
70:30 - saying that the tape the column office
70:32 - code
70:33 - in this table
70:35 - references
70:37 - the column office code from the offices
70:40 - table
70:41 - okay so there are two references here
70:44 - one is a
70:45 - one is a reference to another table
70:48 - one is the reference to this table
70:50 - itself but probably to a different
70:52 - record so what we are saying through
70:54 - this or through a foreign key in general
71:00 - is that we want to ensure that the
71:04 - office code column contains a value
71:07 - which matches a value
71:10 - in the office code column from the
71:12 - offices
71:14 - database now from the offices table
71:16 - right so for every employee there should
71:18 - be an office code and that office code
71:20 - should contain
71:22 - a valid value from the offices table and
71:26 - that is what the foreign key constraint
71:27 - ensures and we will test it out in just
71:29 - a bit
71:30 - and then similarly we have foreign key
71:33 - within the same table we want to say
71:35 - that the reports too for any employee
71:37 - should be a valid employee number
71:41 - from the employees table and it can be
71:42 - the employee number of a different
71:43 - employee so that is or enforced using a
71:46 - foreign key a foreign key is simply
71:48 - you're saying that this number or this
71:51 - column
71:52 - has a special property that it refers to
71:56 - a value from another
72:00 - table
72:02 - and there is one important constraint
72:04 - with foreign key the value that you
72:06 - reference to must be the primary key in
72:08 - that table so for example here we are
72:10 - referencing office code of offices so
72:13 - office code must be the primary key in
72:16 - the offices table now again this is not
72:18 - a criteria that all SQL software or all
72:21 - relational databases have sometimes they
72:23 - do sometimes they don't but in general
72:25 - just to be safe you should always assume
72:27 - that you should only reference primary
72:29 - keys okay
72:34 - so let's try it out let us insert a
72:36 - value into employees so let's just let
72:38 - me just grab this
72:40 - insert into employees the values one
72:44 - zero zero two so that's the employee
72:45 - code Murphy Diane x5800 and so this is
72:51 - what is this employee number last name
72:53 - first name so Diane
72:55 - murphy1002 and their extension is 5800
72:59 - and their email is D Murphy at
73:02 - classicmodelcars.com then their office
73:05 - code is
73:07 - one
73:09 - and do we have an office code one we do
73:12 - have an office code one one is San
73:13 - Francisco so that means they belong to
73:15 - the San Francisco office
73:17 - then reports To None So they do not
73:20 - report to anybody and in fact Diane
73:22 - Murphy is the president so they're the
73:24 - boss
73:25 - so let's run it
73:28 - oh it says
73:31 - employees doesn't exist or that's
73:33 - because I dropped the employees column
73:40 - I never created it in the first place
73:42 - all right so let's first create the
73:44 - employees column A create table
73:46 - employees let's take this and let us run
73:48 - it here so now the employees column is
73:50 - created and then let us insert some data
73:53 - into the employees column
73:54 - I am just going to insert this one
73:56 - person right now
73:58 - Diane Murphy
74:02 - and that's it and let me just put a
74:05 - semicolon here and insert the person so
74:08 - now if I do select star
74:13 - from employees
74:18 - you should be able to see
74:21 - sorry about the formatting
74:24 - but you should be able to see this
74:26 - information about this person Diane
74:28 - Murphy with the employee number one zero
74:30 - zero two
74:31 - as the office code 1 and reports to
74:33 - nobody
74:33 - let's add another
74:35 - employee maybe let us set their
74:40 - yeah let us set their office code let's
74:42 - set their employee code to 1002
74:46 - or 1003
74:48 - and
74:50 - let's call it
74:52 - Daniel
74:54 - and let's give an invalid office code
74:56 - here maybe let's give a hundred and
74:58 - let's see what happens
75:04 - so here you will see that it cannot add
75:07 - the child row so this is called a child
75:09 - so the employee is now called a child of
75:11 - office because it has a foreign key
75:13 - constraint and the foreign key
75:14 - constraint fails you can see that
75:18 - constraint that this should be a valid
75:20 - office ID fails and that's why you
75:22 - cannot add that row okay that's how the
75:24 - whole thing works
75:30 - all right so maybe let's add all these
75:32 - employees and then we will move forward
75:34 - but to add all these employees there are
75:36 - going to be some issues because I've
75:37 - already created an employee with the
75:39 - primary key one zero zero two so before
75:42 - that I'm just going to delete the
75:44 - employee that I've just created
75:51 - you see right now I have this one
75:53 - employee Diane Murphy so I'm going to
75:55 - delete the employee with employee number
75:56 - uh 102. so I can say this I can say
75:59 - delete
76:06 - well actually let's come back to delete
76:07 - later for now I'm just going to drop the
76:09 - table into entirely so drop table
76:13 - employees
76:16 - okay so now the table employees is gone
76:18 - if I do show tables once again
76:21 - and now I can create the table once
76:24 - again I will go create table employees
76:29 - and then let us
76:31 - insert all this data so we have a bunch
76:34 - of employees here I'm just going to
76:36 - capture cap copy all of this
76:39 - and paste this command
76:43 - if you want to do the insertion here so
76:45 - maybe let's just do the insertion here
76:49 - so we're just going to insert all of
76:50 - these employees how many of these we are
76:52 - going to insert about 23 employees
76:55 - using the MySQL workbench and now these
76:58 - should be created so now if we check
77:02 - select star
77:04 - from
77:06 - employees
77:11 - you should now be able to see
77:13 - all the employees that we've created
77:17 - okay
77:18 - now here are some exercises for you try
77:20 - inserting an entry
77:22 - into employees with an invalid office
77:23 - code you saw what happened but try it
77:25 - maybe from the workbench try inserting
77:28 - an entry into employees with an invalid
77:30 - value for reports too
77:31 - okay that is something that we haven't
77:33 - tried so reports too can either be null
77:35 - or it must be an existing employees
77:39 - ID or employees number
77:43 - and try this try creating a new office
77:46 - location first and then try adding some
77:48 - employees to the new location so when
77:49 - you open a new office first you will
77:51 - have to add a new office
77:53 - object or a new office record and then
77:55 - you will have to add an employee add a
77:57 - bunch of employees for those office
77:58 - records and maybe you will have one
78:00 - office manager and that office manager
78:03 - will probably report to the president
78:04 - and then you will have a bunch of
78:05 - employees at that office and they will
78:08 - report to that office manager
78:11 - okay do try out that exercise okay
78:13 - moving ahead now we have the customers
78:16 - table so now at the by this point you
78:18 - are probably getting the idea there is a
78:19 - primary key there are a bunch of
78:21 - required columns there are some optional
78:23 - columns and then there are there is some
78:25 - there is this foreign key so every
78:27 - customer has a sales rep optional sales
78:30 - rep
78:31 - so you can take this foreign key sales
78:34 - rep employee number and that should
78:36 - reference in the employees table some
78:37 - employee number and you can see here
78:39 - that sales rep is an integer but it can
78:42 - be null so I can just copy paste this I
78:45 - can take this create table if not exist
78:47 - so this is another way to go about it
78:49 - create a table only if it not it does
78:50 - not exist all of these are slightly
78:53 - different if you try to create a table
78:54 - without this so if you just say create
78:56 - table customers if there's already a
78:58 - table customers it's going to fail if
79:00 - you drop the table first then it's going
79:03 - to delete all the data if you say create
79:05 - table if not exist then if the table
79:07 - exists it won't do anything if the table
79:10 - does not exist
79:11 - it is going to then create the table so
79:13 - think about what is the right thing you
79:15 - want to do and based on that use these
79:18 - drop and not exist and does exist and
79:20 - play around with them and see what they
79:22 - do okay
79:24 - but I'm take I'm going to take this
79:26 - create table
79:28 - put it into my workbench
79:32 - and just execute it and this should
79:35 - create another table
79:40 - yeah this should create another another
79:42 - table customers and on the left if you
79:44 - just check the schemas tab you should be
79:46 - able to see all the
79:48 - tables that are present so now you see
79:50 - here you may have to refresh it a couple
79:51 - of times but you have this customers
79:53 - table you have employees and you have
79:55 - offices
79:56 - and when you click on a table you will
79:58 - also be able to see the information
79:59 - about that table like on customers you
80:03 - have customer number customer name last
80:05 - name first name so this is our MySQL
80:07 - workbench makes it a little easier for
80:09 - you you don't have to type a lot of
80:10 - commands like describe and such you can
80:12 - just browse the tables that are there
80:15 - you can also browse the information
80:18 - about tables you can in fact
80:21 - even check values within the table I
80:23 - believe if you just
80:26 - click this button it is going to
80:28 - automatically run this select star for
80:30 - you so if I just click this button here
80:32 - it's going to show all the employees by
80:34 - running a select star from classic
80:36 - from employees right and this is one
80:38 - other way to write something you will
80:40 - see often you can also type database
80:42 - name dot column name or sorry dot table
80:45 - name and then
80:47 - put a query so if you're not already set
80:49 - a default database using the use command
80:52 - like use classic models you can just put
80:54 - select star from classic models.employes
80:57 - so this is database dot table name
81:00 - okay
81:02 - so here's an exercise add some customers
81:05 - to the database
81:06 - using data from a SQL file so somebody
81:09 - asked what to can you get data at data
81:12 - programmatically can you add data which
81:14 - is already there somewhere else so let
81:16 - me open up the SQL file and this equal
81:18 - file contains code for everything that
81:21 - we are doing today of this classic
81:22 - models SQL file and in this SQL file you
81:26 - will find some rows for inserting data
81:29 - into the customer table so let's find it
81:32 - let's see so here we have a bunch of
81:35 - create table statements then you have
81:37 - these
81:39 - insert statements for customer for
81:41 - products
81:43 - and then you have an insert statement
81:44 - for offices employees and okay here is
81:46 - where we have an insert statement for
81:48 - customers so I'm just going to grab this
81:50 - this seems like a whole bunch of insert
81:52 - statements here so these are all the
81:54 - insert statements for customers I'm just
81:56 - going to go back to the workbench
81:58 - and I am going to do a new query
82:04 - think
82:05 - not sure
82:07 - which one it is
82:10 - never mind I'm just going to edit it
82:12 - here I'm just going to go to query one
82:14 - paste this all right so it seems like
82:16 - there's a lot of insert statements
82:18 - I'm not sure why they wrote it like this
82:20 - they could have written it all in a
82:21 - single insert statement too but in any
82:23 - case we have 125 customers you can see
82:27 - here you can see the details of these
82:28 - customers they are so these are
82:31 - typically customers are stores remember
82:33 - Gift Stores and toy stores by
82:36 - the products from classic
82:40 - from plastic models so customers are
82:43 - stores and then each customer has a
82:46 - point of contact if I go back here
82:48 - you will see you have a customer name
82:51 - and then you have a customer number
82:52 - customer name is the store name contact
82:54 - last name first name is the information
82:56 - about who to contact their phone number
82:58 - Etc
83:00 - so all that information is captured here
83:02 - you will also see an employee ID so this
83:04 - one is probably the employee ID and then
83:06 - you have
83:08 - okay so here there's also some kind of a
83:11 - location data you see sdg geom from text
83:15 - Etc so you can also put location data
83:17 - into MySQL that's pretty interesting
83:20 - so let's run this let's see if this
83:23 - gives a correct result yeah seems like
83:25 - it was able to insert data into
83:28 - the customers table all right so now
83:30 - we've inserted data for about 120
83:32 - customers and we should be able to see
83:34 - that
83:34 - here in the response
83:39 - yeah
83:40 - so you can see we have data for over 100
83:43 - customers and that's great and some of
83:46 - them have a sales rep some of them don't
83:48 - have a sales rep customers also have a
83:50 - credit limit and such
83:52 - okay so now when you start getting to
83:54 - this point where you have a lot of rows
83:56 - in your database then it may not make
83:58 - sense to look at all the data at once
84:00 - that is where you may want to select
84:03 - some data you may want to query some
84:05 - data you may want to filter out data
84:07 - based on a particular condition and that
84:09 - is where the where clause in the select
84:12 - statement becomes useful
84:15 - so you have this where clause
84:20 - so you have this Clause called where
84:21 - that you can include after your select
84:23 - So when you say select star or select
84:25 - some columns from the employees table
84:27 - you can say where job title equals sales
84:30 - rep now if you go back and check the
84:32 - employees table here
84:34 - you can see that employees table there
84:36 - is a job title here and let's say if you
84:38 - only want to get a list of the sales
84:40 - reps so we say select star from
84:42 - employees
84:45 - where
84:50 - job title
84:52 - equals and then whenever you want to put
84:55 - an actual value for comparison you use
84:57 - double quotes very important
84:59 - sales rep okay so select start from
85:03 - employees where job title sales rep and
85:04 - maybe I can also select specific columns
85:06 - so let's say I want I just want to
85:08 - select the last name
85:12 - and I want to select the
85:14 - extension
85:16 - actually let me just select the office
85:18 - code
85:20 - okay so last name first name last name
85:23 - and office code
85:25 - from employees where job title is sales
85:27 - rep
85:29 - and now it starts to become more useful
85:31 - so now we know that at office code one
85:34 - we have Leslie Jennings who is a sales
85:36 - rep at office code 2 we have Julie
85:38 - Farrell who's a sales rep at office code
85:41 - 3 we have George wanu who's a sales rep
85:43 - and so on so the where Clause supports a
85:46 - bunch of operations where supposed to
85:47 - equal to which is what we have used here
85:50 - it supports less than and greater than
85:52 - so both of these work with
85:55 - numbers and with strings and with dates
85:57 - so pretty much all data types with
86:00 - numbers they expect as expect they work
86:02 - as expected 3 is greater than 2 and 3 is
86:05 - less than 5.
86:08 - which strings they compare the
86:10 - alphabetical order so a is less than b
86:13 - and any string that starts with a is is
86:16 - less than any string that starts with b
86:18 - and any so let's say a a is less than a
86:22 - b and you can have this lexicographic or
86:24 - alphabetical order from A to Z is lower
86:27 - to higher you can also have less than
86:29 - equal to or greater than equal to and
86:31 - you can have not equal to now sum
86:33 - variations use this less than greater
86:36 - than some
86:37 - relational database software use this
86:39 - not equal to so let's see what MySQL
86:42 - uses
86:43 - how about we first try not equal to
86:47 - okay MySQL seems to support this but you
86:50 - could also have in some places this kind
86:53 - of a statement so seems like MySQL
86:54 - supports both right if I do star here we
86:57 - can verify if that is the actually the
86:59 - case
87:01 - yeah so we are now getting the list of
87:04 - people who are not sales reps by using
87:06 - less than greater than or we can also do
87:08 - are not equal to here
87:13 - all right
87:18 - so here's what that looks like you can
87:20 - also combine expressions in the where
87:22 - Clause using and and or so let's say you
87:24 - can say things like
87:26 - select column one column two comma from
87:30 - table name where condition 1 and
87:33 - condition 2 and condition three so for
87:35 - example if we want to select the sales
87:37 - rep in San Francisco so what San
87:39 - Francisco let's first open up offices
87:41 - and in offices let's check San Francisco
87:43 - that's office code one so if you want to
87:46 - get the sales reps in San Francisco so
87:48 - we say select start from employees where
87:49 - job title equals sales rep
87:52 - and
87:53 - we can put in the additional condition
87:56 - office code
87:57 - equals one and again we should put this
88:00 - in quotes ideally
88:05 - okay just a single equal to
88:08 - yeah
88:09 - so now you see here we have the data for
88:11 - Leslie Jennings and Leslie Thompson
88:15 - their extension and their email and both
88:17 - of them are in office code one which is
88:19 - San Francisco
88:21 - so that's how you filter data out like I
88:24 - can I'm just showing showing you here
88:25 - it's going to be a little bit bigger
88:27 - here so that's how you filter data out
88:29 - from a database table
88:32 - you use the where clause in where Clause
88:35 - you can have one of these conditions you
88:37 - can also have you can also do something
88:39 - like this you can use in between and
88:41 - like
88:42 - and then you also have this option to
88:43 - negate things so you can also negate a
88:45 - condition by saying where not condition
88:47 - that's another thing to just keep in
88:50 - mind and a where Clause can be used with
88:52 - select but they can it can also be used
88:54 - with update and delete statement so we
88:56 - were talking about delete earlier so
88:58 - maybe let's check out the delete
88:59 - statement once and now from this point
89:02 - on mostly you would just have to look up
89:05 - how certain statements work
89:08 - so here we say delete from table name
89:10 - where condition
89:12 - now remember we had this one office that
89:15 - I had inserted initially called
89:16 - Bengaluru
89:17 - and this side the office code AAA now if
89:20 - you want if I want to delete this office
89:22 - then here's one thing I can do let me go
89:26 - back here I say delete
89:30 - from
89:31 - offices
89:33 - where
89:35 - office code
89:37 - equals
89:39 - AAA
89:43 - and that should have deleted
89:47 - the Bengaluru office
89:54 - let's see
89:55 - so you know you can see that we no
89:57 - longer have the Bengaluru office anymore
89:59 - because we've just deleted it now here
90:01 - I've deleted exactly one column but I
90:03 - can delete multiple columns as well
90:05 - let's say if I wanted to delete
90:07 - if I want to fire the sales reps in San
90:09 - Francisco so then I would do
90:12 - delete from employees where job title
90:14 - equals sales rep and office code equals
90:16 - one right instead of Select star I would
90:18 - just type delete and then instead of
90:19 - just showing this information it would
90:21 - simply remove these rows of data from
90:23 - the database
90:25 - so that's that and let's also check
90:27 - update similar just like delete we have
90:29 - update
90:31 - so let's check update to
90:33 - now here's how update works you say
90:35 - update table name and then you set the
90:38 - value of column column one to Value one
90:40 - column two to Value two column three to
90:42 - Value three where a condition holds true
90:48 - so let's try update maybe let us change
90:52 - the
90:53 - reporting person for Jenny Leslie
90:56 - Jennings and Leslie Thompson so who are
90:59 - we going to set them to report to
91:02 - maybe let's set them to report directly
91:04 - to the president maybe Diane Murphy
91:06 - directly wants to talk to the sales
91:08 - people in San Francisco so we want to
91:11 - get
91:14 - these employees where job title sales
91:16 - rep and the office code is one
91:21 - and we want to update their values so
91:23 - let's see we say update
91:26 - what does that code look like
91:32 - update set column one equals value one
91:34 - column two equals value two okay so we
91:37 - want to set update employees
91:40 - and we want to set their
91:42 - reports to
91:44 - to one zero zero two
91:47 - again we should put in quotes here
91:53 - update employees set reports two to one
91:55 - zero zero two and then we want to have
91:57 - the WHERE and in the where Clause is
91:59 - where we want to add the selection where
92:01 - we are only selecting the sales reps
92:03 - from San Francisco so where job title
92:05 - equals sales rep and office code equals
92:07 - one okay
92:10 - all right so the good thing about SQL is
92:12 - that it's very readable so update the
92:14 - employees table and set reports 2 to 1 0
92:17 - 0 2 where job title is sales rep and
92:20 - office code is one so only for people in
92:23 - the San Francisco office or sales reps
92:26 - you want to update their employee
92:29 - we want to update their reports too and
92:32 - let's just do a select star and let's
92:34 - make sure that that was updated
92:41 - select star from
92:43 - employees
92:46 - yeah so now you can see with Leslie
92:49 - Jennings and Leslie Thompson they now
92:51 - report to one zero zero two
92:55 - okay if we remove this we can also see
92:57 - that no other rows were affected you can
93:00 - see that there are very few other people
93:02 - who actually report to one zero zero two
93:04 - all right
93:06 - so that is the select Clause the where
93:08 - close the update command and the delete
93:11 - command so here are some
93:14 - exercises for you
93:16 - try and list customers in the United
93:18 - States with a credit limit higher than
93:21 - a thousand dollars so you'd probably
93:23 - start out something like this you would
93:25 - say
93:25 - select star
93:29 - from customers
93:32 - where
93:35 - country
93:38 - equals I think it's USA
93:41 - you can check this out so these are all
93:43 - the customers in in the USA quite a few
93:45 - of them but we want customers with a
93:48 - credit limit higher than a thousand
93:51 - dollars
93:52 - maybe we probably want even an even
93:54 - higher credit limit but let's see let's
93:57 - try a credit limit higher than thousand
93:59 - dollars so here you would say country
94:00 - equals USA and then you would say and
94:02 - credit
94:04 - limit
94:05 - greater than
94:07 - a thousand
94:09 - or let's try ten thousand let's see if
94:10 - there are any more than ten thousand
94:14 - more than a hundred thousand
94:16 - yeah so there are nine rows with more
94:17 - than hundred thousand but with a
94:19 - thousand there are 35 rows so you can
94:22 - see that changing the credit limit is
94:24 - going to change the number of results
94:26 - all right then here's one more list the
94:29 - employee codes for the sales
94:30 - representatives of customers in Spain
94:33 - France and Italy
94:37 - okay how would you do that well you
94:39 - would say select
94:42 - sales
94:44 - first let's describe customers so let's
94:46 - say describe
94:49 - customers
94:50 - so we have the sales rep employee number
94:52 - so now we would say select
94:55 - sales rep employee number from
94:59 - customers
95:03 - and then we can put in a where
95:05 - and now we want the location of the
95:09 - customer or the country
95:11 - and we can put in an in and then I think
95:14 - we can given a give it a list of values
95:15 - so we are concerned with we are
95:17 - concerned with Spain France and Italy so
95:20 - we can now put in
95:21 - pain
95:23 - I think we have to use double quotes
95:25 - here so Spain
95:27 - France
95:29 - Italy okay so here is the list of all
95:32 - the sales reps
95:34 - who work with customers in Spain France
95:37 - and Italy okay now I can probably just
95:39 - put put together a list of these so
95:41 - there's one three seven zero one three
95:43 - one three three seven uh
95:46 - one seven zero two one four zero one and
95:50 - one four yeah that seems to be all so
95:52 - there are only about four or five such
95:55 - sales reps and then the question is make
95:57 - another query to list the names and
95:58 - email addresses of those employees so
96:01 - now we can do
96:02 - select
96:04 - let's say first name
96:08 - last name
96:10 - email from
96:12 - employees
96:14 - where
96:16 - employee number
96:21 - in
96:23 - and then give it this list
96:25 - okay so now we have Louis bondor Gerard
96:29 - Hernandez Pamela Castello and Martin
96:32 - Gerard so these are all the people who
96:34 - are selling to customers in Italy Spain
96:37 - and France
96:39 - so this is the kind of q a that you can
96:41 - do using
96:43 - SQL queries
96:45 - here's one more change the job title
96:47 - sales rep to sales representative I'll
96:49 - let you work on this you can use update
96:51 - to do this delete entries for the sales
96:53 - representatives working in London
96:56 - so first you find out the sales rep
96:58 - first you find out the code for the
97:00 - London office how do you do that well
97:02 - you can use a select statement to get
97:04 - the data for London then you use that
97:06 - code that office code to delete the
97:09 - entries for those sales representatives
97:11 - so you'll have a where Clause with
97:13 - delete then you have show list of
97:15 - employees who are not sales
97:16 - representatives I think we've already
97:18 - done that and here's one interesting one
97:20 - show a list of customers with toys in
97:22 - their name so this is where you would
97:24 - have to use the like
97:26 - statement so if I just click through
97:29 - here you can see this is how the like
97:31 - statement works
97:33 - so you can say select columns from table
97:37 - where a certain column is like a certain
97:40 - pattern
97:41 - and the pattern can be a string or the
97:45 - pattern can be something like this you
97:46 - can have a percentage or percentage a
97:50 - so whenever you have a percentage
97:53 - that means
97:55 - 0 or more
97:57 - characters so if you want to just check
98:00 - for a somewhere in between like if you
98:02 - just want to check for or somewhere in
98:03 - between then you have percentage or
98:06 - percentage
98:08 - so percentage represents zero or more
98:10 - characters and then underscore
98:12 - represents exactly one character okay so
98:15 - check out this reference on how exactly
98:17 - it works what I'm going to do is I'm
98:19 - going to just try and solve this answer
98:21 - show a list of customers with toys in
98:23 - their name so let me see select
98:26 - star from or maybe just select the
98:29 - customer name
98:30 - and the country
98:35 - from customers
98:41 - where
98:43 - customer name
98:45 - like
98:47 - and here is where we can put in
98:50 - percentage and then we want toys
98:53 - and percentage
98:57 - and let's run that
98:59 - oops I think I had to close it so let me
99:02 - just undo that
99:04 - percentage twice percentage and let's
99:07 - run that okay so it seems like you have
99:10 - land of toys Incorporated in the USA you
99:12 - have toys of Finland in Finland and you
99:14 - have toys for grown-ups in USA and
99:16 - boards and toys in USA so it's a very
99:18 - basic selection you can't do a lot of
99:20 - advanced regex kind of selection but a
99:23 - very basic selection can be done a very
99:25 - basic search can be done using like
99:29 - okay then you have product lines and
99:31 - products so you have a bunch of product
99:33 - lines like motorcycles flights uh planes
99:36 - cars Etc
99:38 - and then you also have products so you
99:40 - may have different models of motorcycles
99:42 - different makes for which you offer
99:44 - small scale models
99:46 - so here is what they look like product
99:48 - line is a very simple table it contains
99:50 - the product line it contains some
99:52 - description so it seems like it contains
99:54 - a text description here for some reason
99:56 - there's also an HTML description maybe
99:58 - this is going to be used on the website
100:00 - and there's also an image yeah so let's
100:04 - just take create the
100:05 - product line stable
100:09 - once again I'm just going to paste it
100:10 - here and that will create the product
100:11 - lines table
100:13 - and similarly we have the products table
100:15 - as well which has a product code product
100:17 - name product code is the primary key it
100:19 - has a product line which is a foreign
100:21 - key
100:22 - and it has a product vendor description
100:25 - it has a quantity in stock so that's a
100:27 - small integer
100:28 - then it has a Buy price so which is the
100:33 - price at which we are buying let's say
100:35 - the raw materials for the product or
100:37 - sort of the manufacturing price then we
100:39 - have the retail price so this is the
100:41 - price at which we are selling the
100:42 - product
100:44 - so that can be used to just determine
100:45 - the profit on the product
100:47 - so here's our product right
100:50 - and then once again you can use this
100:52 - link to
100:54 - download some products
100:56 - so here we have the SQL file and then
100:58 - from the SQL file let's see let's find
101:00 - some product lines and some products so
101:02 - let me get all these product lines I am
101:04 - going to come back here
101:06 - and I'm going to just put all these
101:08 - product lines in
101:10 - and I'm going to just run this
101:12 - so we have put in all the product lines
101:14 - classic cars motorcycles planes ships
101:16 - trains truck vintage cars
101:19 - and let's also put in a bunch of
101:20 - products let's get all of these products
101:24 - from this page
101:27 - okay quite a few products and let's put
101:29 - it in there
101:34 - there you go
101:35 - so now we should have a bunch of
101:37 - products and a bunch of product lines as
101:39 - well okay
101:41 - now once you have such huge tables and
101:44 - such huge such a large number of
101:45 - products and product lines and such you
101:48 - may want to do some sort of ordering and
101:50 - you may want to also limit the number of
101:51 - results you may not want to look at
101:53 - thousands of results all the time or
101:54 - even hundreds you may just want to look
101:56 - at the top five or top 10. so if you
101:58 - want to order data then you just include
102:01 - order by at the end of a select
102:03 - statement and you just mention which
102:06 - columns you want to alter by so column
102:08 - one column two so first it will try to
102:10 - order by column one if the values in
102:11 - column one are equal then it will try to
102:13 - order by column two and so on and then
102:15 - you have the ascending and descending
102:17 - for example if you want to list
102:19 - customers by country you would say
102:21 - select
102:22 - let's say customer name
102:25 - comma country
102:30 - from customers
102:33 - order by
102:35 - country
102:38 - and now you can see that you have
102:40 - customers ordered by country Australia
102:42 - Austria Belgium Canada Etc
102:46 - you can also then use a limit Clause if
102:48 - you just want to then see maybe just one
102:50 - page of data something that you can
102:52 - display it once so you can also type
102:54 - here limit 10.
102:57 - and now you just see 10 and of course
102:59 - you don't have to use order by with
103:00 - limit you can use a limit
103:03 - without order by as well
103:06 - so if I just do limit 10 so this is now
103:08 - the natural order or the order in which
103:10 - the data was inserted that is the most
103:12 - that is the default order that is used
103:14 - so this is how you combine order by
103:16 - limit and you then you can also combine
103:18 - it by where Clause maybe you can also
103:20 - only check for
103:22 - customers which have a credit limit
103:25 - greater than a thousand dollars so let's
103:26 - say
103:28 - select customer name country from
103:30 - customers where
103:33 - credit limit
103:34 - greater than
103:39 - a hundred thousand
103:41 - and
103:43 - order by
103:45 - country limit five
103:49 - right so maybe also get the credit limit
103:51 - here
103:53 - so that's how you combine all of these
103:54 - here we are combining select
103:57 - we are combining where we are combining
104:02 - order by and limit and this is what that
104:05 - looks like okay
104:08 - so here are some exercises for you
104:11 - identify the five most expensive
104:12 - products from the plane's product line
104:14 - identify the products that are about to
104:17 - run out of stock so products which have
104:19 - a quantity in stock less than 100.
104:22 - and list 10 products in the motorcycle
104:24 - category with the lowest Buy price
104:28 - and with more than a thousand units in
104:30 - stock okay so there are a lot of things
104:34 - you'll probably have to put together
104:35 - everything that we have covered so far
104:37 - order by and not order buy but you will
104:41 - have to put together a limit you will
104:42 - have to put together an order buy as
104:45 - well because the lowest Buy price and
104:46 - you have to put together a couple of
104:47 - conditions which is the category product
104:50 - line
104:51 - and for the product line you will have
104:53 - to figure out what the product line code
104:55 - for motorcycles is and you will also
104:57 - have to add a check on the units in
104:59 - stock
105:00 - okay
105:02 - then you have these orders order details
105:04 - and payments tables so I'll let you
105:07 - build these as an exercise you have the
105:09 - code you have all the information here
105:13 - so you can create the order order
105:14 - details and payments tables using the
105:16 - create table statement and include
105:18 - proper primary key and foreign key
105:20 - constraints so for example order has a
105:22 - customer number order details has a
105:24 - order number and a product code and then
105:27 - payments also has a customer number
105:30 - and the check number is the primary key
105:32 - and then you can use the same sample
105:34 - data that we've been using so far to
105:36 - populate this too okay
105:38 - next I just want to briefly touch on how
105:40 - you can modify the structure of a table
105:42 - not something that we will do right now
105:44 - but if you want to add a new column to a
105:47 - table here's how you do it you say alter
105:49 - table table name
105:52 - and then add and then the column name
105:54 - and the data type and that's going to
105:56 - add the column
105:57 - maybe let's do it very quickly for
105:59 - employees
106:02 - so alter table let's see employees the
106:06 - let's let's check the employees table
106:08 - first employees
106:10 - so describe employees and now let us
106:12 - maybe add the date that they were hired
106:15 - on
106:16 - so we will add we will say altered table
106:20 - employees
106:25 - what's that add yeah add and then the
106:28 - column name
106:29 - hired on
106:31 - and we want it to be a date
106:34 - okay seems like that was added
106:36 - so now if we check describe employees
106:38 - you should see that there is a
106:41 - hired on column and if I want to insert
106:44 - an employee
106:46 - insert into employees
106:53 - if I insert an employee now I can
106:55 - probably then I can probably then add
106:57 - some information let's say set employee
106:58 - reports to etc etc so we can probably
107:01 - set the hired information right
107:06 - so hired on to one zero zero two
107:10 - and
107:12 - let me change this to an actual date so
107:15 - 2020
107:16 - 12 0 1.
107:20 - okay so now if you check employees again
107:22 - let me just get these employees
107:25 - so select star
107:29 - select star from employees
107:35 - where job title is such and data search
107:38 - so you can see now with these employees
107:40 - we have a hired on column and in the
107:43 - hired on column the value is 2020 1201
107:46 - and for the other employees you will see
107:48 - that the hired on column does not have
107:49 - that value so that's how you add data
107:52 - nothing too special nothing too
107:54 - complicated it's just one more thing to
107:57 - know
108:00 - you add a column and similarly you can
108:03 - drop columns using the drop column
108:04 - command
108:06 - you can modify column using the modify
108:09 - column command
108:10 - you can rename column using the rename
108:12 - column command and here you say rename
108:15 - old name old column name to new column
108:17 - name after alter table
108:19 - so as an exercise try adding removing
108:22 - and modifying one column in each of the
108:24 - tables created and what happens check
108:26 - what happens when you remove or rename a
108:29 - column that is a primary key because
108:32 - that is the primary key which is also
108:33 - used as a foreign key
108:43 - yeah so do try that out so if you change
108:45 - the employee code for example the
108:47 - employee number now that is used in a
108:49 - bunch of different tables like the
108:52 - customer table
108:54 - so what happens when you change the
108:55 - employee number column try it out that's
108:58 - the best part about interactive
109:01 - environments like this you can try out
109:03 - things and you can break things and
109:04 - figure out what happens
109:07 - now you can also place a bunch of SQL
109:09 - commands into a DOT SQL file like this
109:12 - one that we've been looking at so far
109:14 - and then you can
109:18 - execute all of these commands together
109:20 - you can see that here we are dropping
109:21 - the database we are then creating a
109:23 - database we are then using that database
109:25 - then we are creating a table offices we
109:27 - are creating a table employees
109:29 - we are creating a table customers
109:31 - product clients products orders order
109:34 - details payments and then we are
109:36 - inserting data into each of these tables
109:38 - right so this SQL files is basically
109:40 - what's called a database dump that
109:43 - somebody had this database and then they
109:45 - exported it and we'll see how to export
109:47 - it as well but now you can take this
109:50 - data and import it into or just run all
109:52 - these SQL commands and automatically
109:54 - import the data into your
109:56 - SQL Server into your SQL database
109:59 - and here is how you do it so you there
110:02 - are two ways to do it one is through the
110:03 - command line now through the command
110:05 - line let's say go back here
110:08 - I exit I exit the actual command line
110:11 - and let me come to my desktop which is
110:13 - where I have this file database.sql
110:18 - so I have this file here database.sql
110:20 - and I can check this file
110:22 - it contains exactly what I was looking
110:24 - at I have just downloaded this file here
110:28 - so I find my MySQL binary which is in
110:30 - slash user slash local slash MySQL slash
110:34 - bin slash MySQL so this is the MySQL
110:37 - command line tool
110:38 - and then I say minus U root so I want to
110:41 - log in as the root user and then I also
110:43 - say minus P because I want to use a
110:45 - password and then this is the magic part
110:48 - where you use this less than symbol and
110:51 - I'll tell you how to think about this so
110:53 - you have this less than simple
110:54 - database.sql so what you're indicating
110:56 - here is take the data in database dot
110:59 - SQL and passes at pass it as inputs to
111:02 - this command
111:04 - so now we're no longer opening up the
111:06 - console but we are taking all of these
111:08 - commands inside the SQL file and passing
111:12 - it as inputs to mySQL which we are
111:14 - logging into as the root user so when I
111:17 - run this let me just just to make things
111:20 - very simple what I'll do is I'll first
111:22 - just open MySQL
111:25 - slash user slash local slash MySQL
111:32 - slash bin slash MySQL so I'm just going
111:35 - to open this first
111:37 - minus U
111:40 - root minus p
111:43 - I'm just going to open this first and
111:45 - I'm going to drop
111:47 - database
111:50 - classic models
111:53 - okay and let me just do show databases
111:58 - and you can see that we don't have
112:00 - classic models here
112:01 - so now we have we run this code MySQL
112:04 - minus U root minus p database.sql and
112:07 - this should take all those lines of code
112:09 - and it should execute them against this
112:12 - server
112:19 - yeah I'll take a minute or two but it's
112:21 - done
112:21 - and now if we come back here into this
112:24 - or if we just open up MySQL now and just
112:26 - log in
112:29 - and do show databases
112:33 - you can see that we now have classic
112:34 - models and it is now showing a showing
112:37 - up in a upper case because in this
112:39 - script file the database when it was
112:41 - created it was created with this
112:43 - uppercase in uppercase M but as such you
112:46 - can still just say use classic models
112:48 - without
112:49 - upper case we can just say classic
112:51 - models and it should work just fine
112:56 - and now you can do show tables
113:00 - and you have all these tables customers
113:01 - employees offices Etc and now we can do
113:04 - select
113:06 - star from
113:09 - offices
113:12 - and you can see that these are all the
113:13 - offices that we have right so even
113:15 - though it shows up as uppercase here
113:17 - because that's how it was created but
113:20 - you can still access it as lowercase
113:22 - uppercase or this title case or whatever
113:24 - right so we have taken all that
113:26 - information and then we have taken all
113:28 - these lines of SQL code and we have
113:30 - executed them on the database
113:32 - so that's how you execute data one other
113:35 - way to do it is you can also do it this
113:37 - way from MySQL workbench you can click
113:40 - on this or you can see open SQL page it
113:43 - open SQL
113:44 - button so you have this open SQL file
113:46 - button here the second button click on
113:48 - it and go to desktop and just open it up
113:50 - now depending on which database you're
113:53 - using the UI will be a little different
113:54 - but the concept here is that you can do
113:56 - this you can take a bunch of SQL code
113:59 - and then you can execute all at once and
114:02 - it should do the exact same thing
114:04 - so here it drops the database so it's
114:06 - going to empty the database and then
114:07 - it's going to add all this information
114:10 - and now if you just refresh here you
114:12 - should find classic models and inside it
114:15 - you should find these tables and then
114:16 - you can maybe click on employees and you
114:19 - can see all the employees
114:20 - so you have all the employees just fine
114:23 - one other thing you can do is you can
114:24 - export data out so there are a couple of
114:28 - ways to do this one is to
114:31 - use the MySQL dump utility so the same
114:34 - place where you have the MySQL
114:36 - utility which is at
114:39 - let me just exit here
114:43 - so we have at user local MySQL bin again
114:48 - this will be different on Windows or
114:50 - probably different on Linux as well but
114:52 - you can find it quite easily just look
114:54 - it up so user local MySQL bin MySQL
114:56 - right so this is how you open the
114:58 - command line this is what we have been
115:00 - looking at so far but you have a MySQL
115:03 - dump utility
115:04 - so you can call MySQL dump and I want to
115:09 - use the root user and I want to use a
115:11 - password
115:13 - and what is how does it work so we have
115:15 - to
115:19 - provided the name of the database
115:21 - so we provide the name of the database
115:23 - after minus U or even at the beginning
115:25 - so MySQL dump the database that we want
115:28 - to dump is called classic models
115:31 - and then there are certain options that
115:34 - you can specify that do you want to have
115:35 - these drop table lines so if you see
115:37 - here before every table creation there's
115:41 - no doubt there's no drop table statement
115:43 - but we can add that drop table statement
115:45 - as well by specifying this option and
115:48 - again you would just have to look up the
115:49 - documentation online to figure out how
115:51 - exactly this
115:53 - all these options work but yeah MySQL
115:56 - dump
115:57 - draw add drop table classic models minus
115:59 - U root minus p
116:04 - okay and that has created this
116:06 - SQL file
116:08 - oh but we forgot to write it to a file
116:09 - we want to actually write it to a file
116:11 - so right now it is just printed it out
116:13 - so what we want to do is instead of
116:14 - printing out all this information we
116:16 - want to write it into let's say
116:20 - DB dump dot SQL
116:24 - okay
116:30 - and just like that this should be now
116:33 - there should be now this file dbdump.sql
116:40 - we should have all the information that
116:42 - we're looking for
116:43 - so it has it has this drop table if
116:46 - exists customer then create table
116:49 - and then below it it has the data for
116:52 - customers so insert into customers and
116:54 - you have all this customer data
116:56 - and then you have data for employees
116:58 - then you have data for offices
117:01 - and so on okay now there seems to be
117:03 - some encoding error here for some reason
117:05 - this is treated as binary I think it's
117:06 - probably the office location that is
117:09 - causing an issue but as such everything
117:12 - seems to be just fine
117:15 - and then you can take this and then you
117:17 - can use that to reload the data now here
117:19 - it does not have the commands to
117:21 - actually create the database I'm sure
117:23 - there is some option that you can
117:24 - specify in SQL dump to create the
117:27 - database if it does not exist and drop
117:28 - an existing database as well so I'll let
117:31 - you figure that out
117:33 - but
117:34 - yeah but this is what we are interested
117:36 - in
117:37 - and this is something you can do if you
117:39 - connect to a remote database right now
117:40 - we are connecting to a local database
117:42 - but if you connect to a remote database
117:43 - on some server you can export all its
117:45 - data into a SQL file
117:48 - and then there are converters in in
117:50 - pandas what you can do is you can
117:51 - actually load up SQL files
117:53 - maybe let's try that maybe let's do file
117:56 - open here and
117:58 - let us upload
118:04 - I'm not too sure but I think this might
118:06 - work so let us upload database.sql
118:12 - yeah and you should be able to do
118:15 - something like this import pandas
118:19 - as PD
118:21 - and then PD dot read SQL
118:25 - and let's see
118:28 - oh I think this needs to be a SQL
118:30 - command and a connection so it's not
118:33 - going to work with a SQL file you need
118:34 - to actually connect to a database so we
118:36 - look at it the next time but yeah but
118:38 - there are ways to read that SQL file
118:40 - there are ways to convert SQL files into
118:41 - a bunch of CSV files I know that there
118:44 - are ways to convert that into a bunch of
118:45 - different formats so exporting it is
118:48 - useful because you can then load back
118:49 - that data into a new database server or
118:52 - you can also convert it into different
118:53 - formats
118:56 - so try this out on your own download the
118:59 - SQL file import the data from your local
119:01 - installation of MySQL server and
119:05 - then export the classic models database
119:08 - into a SQL file then drop the classic
119:10 - models database and then recreate it
119:11 - using your exported file so make sure
119:14 - that your exported file can actually
119:15 - recreate the data that's an important
119:18 - thing you should be able to do
119:20 - okay so with that we reach the end of
119:23 - today's lesson there's not much more
119:26 - that we're going to cover today there is
119:27 - a lot more that we need to cover in SQL
119:30 - but we'll talk about the next time
119:31 - but here are some challenges for you to
119:34 - try out so this classic models data set
119:36 - is taken from this website
119:38 - richardwatson.com this is I think this
119:40 - is a professor and they teach a database
119:43 - management course
119:44 - so you can and there are a bunch of
119:47 - exercises here so today what we've
119:49 - covered are mostly the single entity
119:51 - exercises but you also have these other
119:53 - exercises which require
119:56 - some joins and some other things which
119:59 - you have not covered yet
120:00 - so you may just want to try out
120:02 - this prepare a list of offices sorted by
120:05 - country state and city this should be
120:08 - straightforward how many employees are
120:10 - there in the company okay this will
120:11 - require some sort of aggregation
120:14 - or you can just look at the list of
120:16 - employees but yeah but one thing you
120:17 - should check out is
120:20 - you can check out things like count
120:23 - where's count
120:28 - yeah count average in sum
120:31 - so you can do something like this select
120:33 - count column name from table where
120:36 - condition
120:37 - and you can use that to answer this
120:38 - question how many employees are there in
120:40 - the company so here is how I would do it
120:44 - I would say
120:51 - select count
120:53 - star from
120:55 - employees
121:00 - and just use
121:04 - classic models okay
121:07 - select select count star from employees
121:09 - and it tells you that there are 23
121:11 - employees
121:12 - then here is a question what is the
121:14 - total of all the payments received so
121:16 - let's see select star from payments
121:22 - and you have all these payments
121:23 - and now among these payments there is
121:26 - this amount column so if you just want
121:28 - to get the total amount we say select
121:33 - amount and then we can do a sum how do
121:37 - we do a sum well I think it should be
121:39 - there here somewhere so we can just do a
121:41 - sum on the column
121:43 - so we do select
121:45 - sum of amount
121:49 - from payments
121:51 - so this is the total payment that we
121:52 - have received now you can do things like
121:54 - what is the total payment we have
121:56 - received from customers based in the USA
121:59 - or from a particular location and you
122:02 - can do like a group buy as well and
122:03 - we'll cover Group by and all the next
122:05 - time
122:07 - then you have questions like list of
122:09 - product lines that contain cars
122:12 - and Report total payments for October 28
122:15 - 2004 so here's a where Clause report
122:18 - those payments greater than a hundred
122:21 - thousand dollars
122:22 - list of products in each product line
122:24 - how many products in each product line
122:26 - okay
122:28 - so this might be worth figuring out you
122:30 - may have to
122:31 - use this as a reference w3schools is a
122:34 - good reference here you can check out
122:36 - and see which one of these might be
122:37 - useful for you
122:40 - then what is the average percentage
122:42 - markup on MSRP on the Buy price so now
122:45 - you are comparing you're doing
122:47 - arithmetic between two columns again
122:49 - something that we'll try and cover the
122:51 - next time
122:52 - how many distinct products does classic
122:54 - models sell
122:56 - report name and city of customers etc
122:59 - etc so a whole bunch of questions and
123:01 - whichever you are not able to figure out
123:03 - right now using what we have covered
123:05 - today just try and look through this
123:08 - documentation so this is everything that
123:10 - MySQL supports is listed here most
123:13 - likely you will everything that you need
123:14 - will be covered in this MySQL SQL
123:17 - section if you just go through most of
123:19 - these you should be able to answer these
123:21 - questions
123:22 - and then wherever we have more
123:24 - one-to-many relationships or any
123:26 - relationships between multiple tables we
123:28 - will look at the next time so the next
123:30 - time we will look at using functions for
123:34 - advanced querying on strings dates
123:36 - timestamps we will look at aggregating
123:39 - data using count average sum min max we
123:42 - will look at using joins to combine and
123:44 - query data from multiple tables at once
123:47 - we'll also see how to improve query
123:49 - performance with keys indexes and
123:51 - transactions and finally we will look at
123:53 - how you can connect to a SQL database
123:55 - from python for querying and
123:57 - visualization in Jupiter so we'll look
123:59 - at how to do it using pandas and we'll
124:01 - also briefly try and look at orms so
124:04 - there's a bunch of things to cover here
124:06 - but the more important thing in SQL is
124:08 - practice
124:10 - so you wanna definitely try out these
124:12 - challenges and there are solutions for
124:14 - these challenges as well you can click
124:17 - the solutions link and use that to check
124:20 - the solutions for example there was this
124:22 - query about
124:26 - what is the average percentage markup of
124:28 - the MSRP on Buy price
124:32 - this is question number 11. so let's see
124:35 - question number 11.
124:37 - okay so seems like we are doing some
124:39 - sort of a
124:40 - calculation here so average of MSRP
124:43 - minus Buy price divided by MSRP
124:45 - multiplied by 100 as the average
124:48 - percentage markup from products okay so
124:51 - we'll also talk about as the next time
124:55 - now a few resources for you one is the
124:58 - SQL challenges for sure then the other
125:00 - one is the W3 schools reference it's a
125:04 - great guide to just quickly look through
125:06 - all the different
125:07 - SQL
125:10 - all the different SQL
125:12 - commands and all the different SQL
125:14 - statements and keywords that are present
125:18 - then there is this book called
125:20 - dbbook.com so this is dbhyphenbook.com
125:23 - It's called database systems Concepts uh
125:25 - you can get this book if you wish it's a
125:27 - great book but you should also check out
125:30 - these slides so they have made the
125:32 - slides available for free online and
125:35 - these slides are a great comprehensive
125:37 - introduction to SQL and relational
125:39 - databases and
125:42 - pretty much everything to do with a
125:44 - relational databases so you can use
125:46 - these slides just whenever let's say
125:48 - you're preparing for interviews or if
125:50 - you want to get a deeper theoretical
125:52 - understanding of how the whole thing
125:53 - works
125:55 - do check out these slides I think you'll
125:57 - find them useful now you just need to
125:59 - look at part one relational languages
126:01 - where we talk about relational models
126:03 - introduction to SQL intermediate SQL
126:06 - Advanced SQL Advanced is already beyond
126:10 - what you will need to know but if you
126:11 - cover these four or five slide decks and
126:14 - maybe also the introduction
126:16 - then you will pretty much Master SQL at
126:20 - least you will know everything there is
126:21 - to know then you'll just need to
126:22 - practice
126:23 - then you also have these slides on
126:25 - database design which is about the
126:27 - entity relationship diagrams and models
126:31 - you don't need to know this as a data
126:33 - science practitioner generally somebody
126:35 - else is going to do the database design
126:36 - but if you want to interpret entity
126:38 - relationship diagrams correctly then you
126:42 - should check this out this might be
126:43 - useful for you the rest of it is not
126:46 - really that important not something that
126:48 - is relevant here it goes into the
126:51 - internals of databases but definitely
126:53 - check out chapters 2 to 5 of dbbook.com
126:57 - so you want to go to dbhyphenbook.com
127:00 - go to the seventh edition and click on
127:04 - slides
127:05 - and here you have
127:08 - um all these slides that you can access
127:09 - here they also have some sample tables
127:13 - just like we had this SQL file for
127:16 - creating the classic
127:18 - models data set similarly you have
127:20 - sample tables for creating this
127:24 - University data set so where you have
127:26 - departments and instructors and students
127:28 - and courses and prerequisites and
127:30 - students take courses and instructors
127:33 - teach courses and then each course is
127:35 - taught in a section with a certain time
127:37 - slot and then instructors are also
127:39 - advisors for students so it's a
127:41 - interesting data set it has about 2000
127:43 - rows of data and then there are a bunch
127:45 - of questions that you can try and answer
127:47 - on this data set as well I think they
127:49 - are mentioned somewhere here in the yeah
127:52 - exercises so you see there are some
127:54 - exercises here on accessing the database
127:56 - basic SQL intermediate SQL Advanced SQL
128:00 - yeah so here
128:03 - so there's a a SQL is all about
128:06 - exercising all about trying out these
128:08 - exercises so dude maybe we'll try and
128:10 - put all of this together into a single
128:12 - notebook and we will also see
128:15 - we'll also find a way to do it so that
128:17 - you can type all the code in Jupiter and
128:19 - get the results immediately in fact
128:21 - Jupiter just like python there is a way
128:23 - to type SQL directly into Jupiter and
128:25 - interact directly with the database so
128:27 - we'll try and set that up for the
128:29 - assignment but in the meantime do check
128:31 - out dbbook.com you also want to get
128:34 - familiar with the workbench or whatever
128:36 - tool your company is going to use so
128:39 - don't lean too much on Jupiter for this
128:41 - particular course especially and SQL in
128:43 - particular
128:44 - become used to this workbench become
128:47 - used to working with the command line
128:50 - and typing commands there because that
128:53 - is how you will be working with SQL
128:55 - databases in the real world okay and we
128:58 - will touch on how to access them using
128:59 - python 2.
129:02 - more SQL exercises on w3resource.com you
129:05 - have more exercises hundreds of
129:07 - exercises really and that's all SQL is
129:09 - about exercises and more and if you
129:11 - really want to read through my sequels
129:13 - reference manual then you can check that
129:14 - as well although you would almost never
129:16 - need to do that
129:18 - and that's it so we've just covered the
129:21 - use cases and the design of relational
129:23 - databases in SQL we've looked into the
129:25 - installation of MySQL and how to set up
129:27 - a database locally we looked at creating
129:30 - modifying and deleting databases and
129:32 - database tables
129:34 - we looked at SQL data types and
129:36 - constraints like primary key and foreign
129:37 - key we looked at the create read update
129:40 - and delete operations on database tables
129:43 - and we looked at exporting and importing
129:45 - data from relational databases
129:54 - the topic for today is aggregation and
129:56 - joins with SQL last time we looked at
129:58 - some basic SQL
130:00 - commands we saw how to create databases
130:03 - we saw how to create tables we saw how
130:05 - to put data into tables how to get data
130:08 - out of tables all the crad operations
130:10 - which is create read update and delete
130:14 - and we also looked at basic querying
130:17 - using select with some conditions
130:22 - today we are going to look at
130:23 - aggregation grouping and pagination in
130:26 - SQL queries then we will look at mapping
130:28 - functions arithmetic and how to work
130:31 - with dates
130:33 - we will also combine data from different
130:36 - tables using SQL joins and we learn how
130:40 - to improve query performances with
130:42 - indexes and views
130:45 - we will also talk about how we can
130:48 - execute SQL queries using Python and SQL
130:51 - Alchemy towards the very end
130:54 - and as I've said this is a continuation
130:56 - of the previous tutorial so do check out
130:58 - the previous tutorial if you haven't
130:59 - done that already
131:01 - this contains all the basics of SQL
131:07 - and we will be setting up a MySQL server
131:10 - locally so typically how a relational
131:12 - database works is you have to download
131:14 - this software called the server in a
131:17 - server in computer science is simply a
131:19 - program which runs in the background and
131:21 - listens for instructions so the MySQL
131:24 - server is something that you can
131:25 - download from dev.m.mysql.com
131:28 - this is just a package that you download
131:30 - to your computer and then you install it
131:32 - on your computer and once you install it
131:35 - on your computer
131:36 - you can start up a database server on
131:39 - your computer so that software is
131:41 - running now in the background and you
131:43 - can then issue instructions or send
131:45 - instructions to the database server in
131:48 - the form of SQL queries like creating
131:50 - databases creating tables putting data
131:53 - in taking data out Etc
131:55 - now depending on your operating system
131:57 - the way to start and stop this server is
132:00 - going to be different in my case
132:03 - what MySQL does is
132:06 - when I install MySQL Community server
132:09 - it adds a system preferences pane so
132:11 - inside my system preferences this is the
132:14 - Mac system preferences there is a MySQL
132:16 - page that gets added but in your case
132:19 - this could be different so make sure
132:21 - that you have downloaded MySQL server
132:24 - the software and then it is running on
132:26 - your computer
132:28 - and then
132:30 - anytime you have a server running you
132:32 - need a way to connect to that database
132:34 - server so there are multiple ways to
132:36 - connect to a database server one of them
132:38 - is to use
132:40 - the MySQL command line which is
132:43 - typically installed at some kind of a
132:45 - location like this slash user slash
132:47 - local MySQL this is on Mac again the
132:50 - MySQL command line tool based on your
132:53 - operating system will be at a different
132:54 - location so check out the documentation
132:58 - or search online on where you can find
132:59 - the MySQL command line tool once the
133:01 - community server is installed
133:05 - so one way you can connect to the server
133:07 - and issue commands to the server is by
133:09 - running the MySQL command line and here
133:11 - you specify that you want to log in as
133:13 - the user root so when you install the
133:15 - server you're asked to set up a password
133:17 - for the database server and a username
133:19 - so the default username is root and you
133:22 - have to set a password so in my case I
133:23 - have set up a certain password and now I
133:26 - am connected to
133:28 - the server and now I can issue commands
133:30 - to the server for example I can say show
133:32 - databases
133:36 - and that's going to show me the
133:37 - databases I have but what we're going to
133:40 - do is use
133:41 - software called the MySQL workbench so
133:44 - this is the second piece of software
133:45 - you'll have to install and I have given
133:48 - you a link here
133:49 - dev.m.mysql.com download slash workbench
133:52 - so go to this page and download the
133:54 - MySQL workbench for your computer for
133:57 - your laptop for your operating system
133:59 - and then open it up so now we have a
134:03 - server that's running on our computer
134:05 - and then we have this workbench which
134:07 - can connect to a server and gives you a
134:08 - graphical user interface to connect to
134:11 - that server so one way you can connect
134:15 - to your service click plus and here you
134:17 - can then provide
134:19 - this is a connection name that you can
134:21 - set but you have to provide some
134:23 - parameters by default this is set to
134:25 - connect to a local machine a local
134:27 - database server on your computer but
134:29 - again if you have a database server that
134:32 - is somewhere on the cloud you can simply
134:34 - ask for the host name Port username
134:37 - password
134:39 - and then you can connect to that server
134:41 - as well so MySQL workbench does not just
134:43 - collect connect to your local database
134:46 - it can connect to any database on the
134:49 - cloud if you have the credentials and
134:51 - when you join a company they will give
134:52 - you the credentials to the server
134:55 - in my case I already had the local
134:56 - instance set up here so I just clicked
134:58 - on it and now I'm connected to my local
135:00 - instance for example if I just type
135:08 - show databases
135:11 - that's going to show me the databases
135:13 - that I have here which is classic models
135:15 - information schema MySQL and performance
135:18 - schema and then I can run use database
135:20 - in all my select queries okay so that's
135:22 - the setup you need to do that's the
135:24 - software you need to have installed and
135:26 - let us know if you face issues and I
135:28 - hope the server and the workbench
135:31 - a separation is clear to you
135:34 - so here's the MySQL workbench we have
135:36 - that running and in this tutorial we
135:38 - will use the classic models database
135:40 - from the previous tutorial so classic
135:42 - models is a hypothetical company it's a
135:45 - distributor of small scale models of
135:46 - cars motorcycles planes ships trains Etc
135:51 - and the products that are manufactured
135:53 - by classic models are sold in toy and
135:55 - gift stores around the world so here are
135:57 - some of the
135:58 - products they sell and classic models
136:01 - has offices around the world with dozens
136:03 - of employees and the customers of
136:05 - classic models are typically toy or Gift
136:08 - Stores so each customer has a designated
136:11 - sales representative who is an employee
136:13 - of classic models that they interact
136:15 - with
136:16 - now customers typically Place orders
136:18 - requesting several products in different
136:20 - quantities and then they pay for
136:22 - multiple orders at once via checks all
136:25 - right so that's the setup here we have
136:27 - this com this hypothetical company which
136:29 - does all of these activities and we want
136:31 - to track all their activities in a
136:33 - relational database and to do that
136:37 - an entity relationship diagram has been
136:40 - given to us and this simply tells us
136:42 - what the different entities or what the
136:44 - different tables in the database are and
136:46 - what the different columns within those
136:47 - tables are so we have an offices table
136:50 - here it contains information about
136:52 - different offices or the primary key is
136:54 - office code which is the unique
136:55 - identifier
136:56 - then we have the employees table so we
136:58 - have an employee number last name first
137:00 - name extension email Etc and there are a
137:03 - couple of relationships here there is an
137:05 - office code in employees so for every
137:08 - employee there is an office code which
137:11 - is the office code of a certain office
137:13 - so this is called a foreign key because
137:15 - an employee cannot have an office code
137:17 - which is invalid
137:22 - and then you also have reports too so
137:25 - reports to tells you which employee and
137:28 - employee reports to so this is a foreign
137:31 - key from the employee table to itself
137:33 - right so reports too must be a valid
137:35 - employee number of another employee
137:39 - then you have customers and you have a
137:42 - bunch of information about customers
137:43 - customer number is the primary key and
137:45 - every customer has a sales rep employee
137:47 - number which is
137:50 - the employee number of a certain
137:51 - employee who's a sales rep
137:54 - and then for customers a customers can
137:56 - place orders
137:58 - so every order is placed by a customer
138:00 - that's why you have a customer number
138:01 - foreign key here but apart from that
138:04 - orders can have a lot of items so there
138:06 - is an order details table for each item
138:09 - each line item
138:11 - in the order
138:13 - let's say you've ordered five products
138:14 - you have five line items and you can
138:16 - have the quantity Etc of each one
138:19 - and then you have products as well so
138:22 - there's a table of products and there's
138:24 - a table of product clients because you
138:26 - need to track information about the
138:28 - product somewhere as well
138:30 - finally you have payments customer main
138:32 - customers make payments at separate
138:34 - times so this is a slightly different
138:36 - flow where you don't pay per order but
138:38 - customers have a credit limit which
138:40 - means they can make Place orders up to a
138:42 - certain amount and then they can clear
138:44 - all their pending payments at once using
138:47 - a check
138:48 - so that's the setup they have here and
138:50 - depending on how your company operates
138:52 - this system may be different it's
138:54 - possible that if you take payments up
138:57 - front then maybe the order details is
138:59 - connected to payments or the order is
139:01 - connected to a payment rather than a
139:02 - customer okay so that's the entity
139:05 - relationship diagram here and that's the
139:08 - sort of the overview of the database
139:10 - that we're working with now we will use
139:14 - we will set up this database locally
139:16 - with some sample data using a script so
139:19 - let me just set that up and then we will
139:21 - take some questions
139:23 - and by the way if you have any questions
139:24 - please post them in the zoom chat so to
139:27 - set up this database
139:29 - we first need to download the SQL script
139:31 - so I'm just going to open this in a new
139:33 - tab and that's going to try and download
139:35 - it
139:36 - and I'm just going to download it on my
139:37 - desktop here
139:41 - and you can see that now the SQL script
139:43 - is downloaded on the on my desktop and
139:46 - then once you have downloaded it
139:50 - you can go to file
139:51 - open SQL script in your MySQL workbench
139:55 - so open up MySQL workbench connect to
139:57 - the local database and click on this
140:00 - open SQL script
140:02 - and then here you can see the contents
140:04 - of the SQL script so this contains
140:06 - all the information to set up the
140:08 - database that we just saw the ERD for
140:11 - the entity relationship diagram for and
140:13 - it also contains a lot of sample data
140:15 - for example it's going to drop the
140:17 - database classic models if it exists
140:19 - it's going to then create a new database
140:21 - and it's going to use that database then
140:23 - it's going to create
140:25 - tables one by one for example here it's
140:27 - creating the offices table with all this
140:29 - information and then it is going to
140:31 - create employees
140:33 - customers etc etc
140:35 - once tables are created it is going to
140:37 - insert data into these tables like
140:40 - product lines products customers
140:42 - employees Etc okay so it's going to set
140:45 - up a database with a lot of information
140:46 - for us
140:48 - now once you have this SQL script loaded
140:51 - up you will see this run SQL
140:54 - so execute button which is like a
140:56 - lightning button here so you can just
140:58 - run a press that or you can just press
141:00 - command enter or control enter on
141:02 - windows so I'm just going to run
141:05 - command enter and now my previous
141:08 - classic models database has been removed
141:10 - and this new database has been set up so
141:12 - if I go to the left sidebar if your
141:14 - sidebar is not open you can click here
141:16 - and open up the left sidebar and just go
141:19 - to the schemas tab in the left sidebar
141:22 - I should be able to find
141:25 - a schema
141:31 - let me just connect again here
141:39 - okay let me just run that once again
141:43 - yep all right so now if I check the
141:47 - schemas here so I should be able to find
141:49 - in the schemas once I reload the schemas
141:51 - the classic models database
141:53 - now in the classic models database I can
141:56 - browse all the tables here you can see
141:57 - that we have tables customers employees
142:00 - offices order details payments product
142:02 - lines Etc
142:04 - and if you
142:06 - double click on a table or if you just
142:09 - click on this table click on this button
142:11 - which shows information from the table
142:12 - then it is you can view some information
142:15 - from each table all right so MySQL
142:17 - workbench gives you an easy way to
142:19 - browse the schema see different tables
142:21 - and actually look at information from
142:22 - different tables very easily
142:25 - okay
142:27 - so now we have just to recap we have
142:30 - downloaded the SQL script
142:32 - from this URL and then we have
142:36 - loaded it into MySQL workbench using
142:38 - file open SQL script
142:40 - then we have executed the script to
142:42 - create and populate the database this
142:44 - part can also be done using the MySQL
142:46 - command line tool it's simply a matter
142:49 - of passing the script to the command
142:50 - line tool and you can look up how to do
142:52 - that but once executed you should be
142:54 - able to view and browse all the tables
142:56 - in the schema section of the sidebar
143:00 - and if you face an error the most likely
143:03 - issue is that your MySQL server is not
143:05 - running so just because you have
143:06 - workbench open does not mean the server
143:09 - is running so make sure that the server
143:10 - is running and then you will be able to
143:13 - communicate with the database server all
143:17 - right so with that we have our database
143:19 - set up now ready to go and we have our
143:23 - MySQL workbench connected
143:25 - so let's get started
143:29 - the first topic we look at is
143:31 - aggregation grouping and aliases
143:34 - SQL provides several functions like
143:36 - count average sum Min and Max for
143:39 - aggregating the results of a query what
143:41 - do you mean by aggregating well it's
143:43 - combining the results that you get
143:46 - typically into a single number or maybe
143:48 - a one or one or more numbers so here's
143:51 - an example
143:52 - report the total number of payments
143:54 - received before October 28 2004.
143:58 - okay so this is the kind of question
144:00 - that will be posed to you or the kind of
144:02 - information that you will have to figure
144:04 - out now we know from the ER diagram and
144:06 - we know from
144:08 - let's maybe just copy the question and
144:09 - put it here
144:18 - yeah so this is the way to create a
144:21 - comment in a SQL file or a SQL query you
144:25 - just put in hyphen hyphen space and
144:27 - that's going to be a comment that is
144:29 - going to be ignored by the
144:31 - uh by the MySQL server
144:37 - okay so the question is report the total
144:40 - number of payments received before
144:41 - October 28 2004. so we have a table
144:45 - called payments
144:47 - so let me just do a select star
144:52 - from payments
144:54 - all right and once I run that I will get
144:57 - back
144:59 - a list of results
145:03 - yeah here's the list of results so these
145:05 - are all the payments in the database you
145:06 - have a check number you have a payment
145:09 - date you have an amount and you have a
145:10 - customer number the customer who made
145:12 - the payment all right but we are not
145:14 - interested in all the payments we are
145:16 - interested in payments received before
145:18 - October 28 2004. so there is a payment
145:22 - date here and it seems like this payment
145:24 - date is in this year month date format
145:30 - and in fact if you want to know the data
145:31 - type of this payment date you can just
145:34 - spin up a new query here and just type
145:36 - describe
145:38 - payments
145:40 - and you can see that the payment date is
145:42 - a date time okay now a date time is an
145:47 - ordered field obviously dates have a
145:49 - intrinsic order so here's what you can
145:51 - do you can say select start from
145:53 - payments where
145:56 - payment date
145:58 - is less than because we want payments
146:02 - before October 28 2004 and then you
146:04 - provide the date that you want to check
146:05 - here
146:06 - so that's 2004
146:09 - and then you have
146:12 - October that is the 10th month and then
146:14 - you have 28. so this should be enough
146:17 - you don't need to put in the time here
146:19 - so I'm just going to run that
146:21 - and if you see now we only have
146:25 - payments that have occurred before
146:27 - October 24 October 28 2004.
146:30 - and I recommend just going through this
146:32 - list manually if you want to verify this
146:34 - but
146:35 - that's that's how you get that all right
146:38 - but we don't want every single payment
146:40 - we want the total number of payments now
146:43 - if you want a total number of payments
146:45 - it's very simple to we simply want to
146:47 - count the number of rows that were
146:48 - returned by this query and the way to do
146:50 - that is just type count
146:52 - so count is a function in SQL and you
146:54 - can see it highlighted in green
146:57 - and typically this is what we do we put
147:00 - all the SQL
147:01 - commands in
147:04 - so typically this is what we do we put
147:06 - all the SQL keywords on the SQL
147:08 - functions in capital letters or
147:11 - uppercase and we put
147:13 - the column names in lowercase or
147:18 - whatever is the actual column name
147:20 - whether it uses lowercase uppercase or
147:22 - combination of both and this is just to
147:24 - visually separate actual keywords with
147:27 - column names but remember that SQL is
147:29 - completely
147:30 - case insensitive so you could type all
147:32 - of these in lowercase and you could type
147:34 - all of these in uppercase and it would
147:35 - work just fine okay
147:37 - and this is just for visual separation
147:40 - in any in any case we have the count
147:42 - function so you just put instead of
147:44 - Select count star uh use instead of
147:47 - Select star you just type select count
147:48 - star and run that
147:51 - and now you will see here that there are
147:53 - 189 payments that have been made before
147:56 - October 28 2004 and if you did not have
147:59 - this where Clause this filter then you
148:02 - can see that there are total of 273
148:04 - payments so out of 273 payments 100 and
148:08 - 89 payments were made before October 28
148:11 - 2004.
148:12 - so that's how you count the number of
148:14 - rows
148:15 - returned from a query just put in
148:18 - account
148:26 - located and there's a quick question
148:27 - here about payments where this payment
148:29 - stable come from so this is the table
148:31 - that we've just populated when we
148:33 - downloaded the SQL file classic
148:35 - models.sql and then we executed it
148:39 - that gave us this table and that gave us
148:41 - all the data inside this table
148:43 - okay
148:47 - so that's count just put count around
148:49 - the selection criteria and that will
148:51 - count the table that will count the rows
148:53 - for you
148:55 - next another common use case involves
148:58 - counting the number of distinct values
149:00 - in a column
149:02 - so here's a question report the number
149:04 - of customers who have made payments
149:06 - before October 28 2004. so now we are no
149:09 - longer interested in the number of
149:13 - now we are no longer interested in the
149:15 - number of payments that were made we are
149:17 - interested in the number of unique
149:18 - customers who have made payments and one
149:20 - customer can make multiple payments uh
149:23 - so number of customers who have made
149:24 - payments before October 28 2004.
149:27 - so once again maybe let's open up a new
149:29 - uh let's just continue typing here
149:32 - so here's my select query select star
149:36 - from
149:37 - payments and I can write payments or I
149:40 - can write payments or I can write
149:42 - payments and it will all be the same
149:44 - thing
149:45 - okay this is the name of the table so
149:47 - anything you see after from is a table
149:49 - name
149:49 - so select star from payments that gives
149:52 - us a list of all the payments and once
149:55 - again we want to select them
149:58 - and I'm just going to mix cases here but
150:01 - don't worry about it so let's just say
150:03 - select start from payments where
150:05 - payment date
150:08 - is less than
150:10 - 2004 10
150:13 - what's that October 28th so 2004 1028 so
150:17 - that gives us all the payments that have
150:19 - occurred before
150:20 - 2004 1028. now we are interested in the
150:23 - customer number we are interested in the
150:26 - unique customers who have made payments
150:28 - before the state
150:29 - so here's the first thing I'll do maybe
150:31 - I'll just select the customer number
150:32 - first
150:35 - okay so if I just select customer number
150:37 - now I have ignored all the other columns
150:40 - I have just selected the customer number
150:41 - column so now I have 2299 172 242 Etc
150:46 - but of course there are probably going
150:47 - to be repetitions here and you can go
150:49 - through this list and verify that there
150:51 - are some repetitions okay so if I did
150:54 - select count
150:56 - customer number
150:59 - this is giving me 189 which is actually
151:01 - the total number of rows returned
151:04 - but we want simply the number of unique
151:07 - customers who have made payments
151:09 - so what you do is you type distinct
151:13 - okay now when you type distinct
151:16 - repetitions from this list will go away
151:18 - so if I type distinct here
151:21 - now you can verify that this list is a
151:23 - bit smaller this list is not that big
151:25 - anymore
151:28 - and in fact if I type count now
151:34 - you will see that the count is only 98.
151:38 - so what distinct does when you type
151:40 - distinct before a column name it is
151:42 - going to just select distinct values of
151:45 - that column and if you type multiple
151:48 - column names after distinct it is going
151:50 - to just select all the distinct
151:51 - combinations but in this case we first
151:53 - get the list of all the distinct
151:55 - customer number which is a customer ID
151:57 - and then we count the number of rows
151:59 - okay so count is a function but distinct
152:02 - is still a keyword which is part of the
152:04 - SQL
152:05 - syntax
152:07 - okay so once again I'm just quickly
152:10 - going to repeat that we have select star
152:12 - from payments where payment date is less
152:14 - than October 28 2004 now instead of
152:17 - selecting all the columns I just select
152:18 - customer number
152:21 - and that gives me the customer number
152:23 - for each payment but I'm only interested
152:25 - in the distinct customer numbers I don't
152:27 - want to show I don't want customer
152:28 - numbers to show up again and again so I
152:30 - type distinct and then I want to count
152:32 - them so here is the count function which
152:35 - is going to count the customer numbers
152:36 - for me and there are 98 of them
152:40 - okay so that's how you solve any SQL
152:45 - query or solve any SQL question you just
152:47 - go step by step you start by looking at
152:49 - the table and then you simply keep
152:50 - adding in criteria one by one
152:53 - of course as I said District can be used
152:55 - can also be used without count so if you
152:57 - just wanted the list of customer numbers
152:59 - for customers who have made a payment
153:01 - before the 28th of October 2004 then you
153:05 - just type select distinct customer
153:06 - number from payments where payment date
153:09 - is less than 28th of October 2004.
153:13 - okay and you can use distinct with
153:15 - multiple columns as well so if you want
153:17 - to try out learn more and try out what
153:19 - distinct does
153:20 - check out some documentation here on
153:23 - w3schools
153:24 - and you can also practice this online
153:28 - okay now
153:32 - if I look back at this query just a
153:35 - distinct customer numbers
153:38 - this is just giving me a list of
153:40 - customer numbers right and this is not
153:42 - very informative because ideally what we
153:44 - want is details of those customers I
153:47 - want to know which people which
153:49 - stores have made payments before the
153:53 - 28th of October 2004. so how do you do
153:55 - that well here is one way to do that we
153:58 - know that this is a list
153:59 - and
154:02 - you can write a query
154:05 - which uses the result of this query okay
154:08 - and here's what we want to answer we
154:09 - want to retrieve the details
154:12 - for all the customers who have made a
154:14 - payment before October 28 2004 okay so
154:17 - how do we do that let me just put this
154:19 - query aside for a second and let me
154:21 - start typing
154:22 - and let's just comment it out here and
154:24 - let me start typing select
154:26 - star from customers
154:28 - okay
154:31 - I guess I'm just going to use lowercase
154:33 - here but select star from customers
154:38 - so now I have details of all the
154:39 - customers but I'm not interested in all
154:41 - the customers I am interested in simply
154:44 - the customers where
154:46 - the customer number
154:48 - is in this list that I had earlier and
154:51 - I'm just going to run this again here in
154:52 - a
154:53 - as a new query
154:55 - so I just want to
154:57 - get the details of customers who are in
154:59 - this list about 98 or so customers so
155:02 - what I can do is I can take this query
155:03 - without the semicolon
155:06 - and I can come back here
155:11 - I can come back here select start from
155:13 - customers where customer number
155:16 - in and then here I have to give a list
155:18 - so instead of giving this actual list I
155:21 - can give a query which generates that
155:23 - list so I can just put in a bracket here
155:26 - and type select distinct customer number
155:28 - from payments where payment date okay so
155:31 - we take the result of this query select
155:33 - distinct customer number from payments
155:35 - where payment date and then we run a
155:38 - second query which is going to select
155:40 - details from the customers table where
155:43 - the customer number
155:45 - lies in this list okay so if we run that
155:48 - now
155:50 - so now you will only get details of
155:53 - customers where the customer number is
155:55 - in this list and what is this list this
155:57 - list is simply then
155:59 - distinct customer numbers
156:02 - from the payments column where the
156:03 - payment date is less than 2004 1028 okay
156:07 - so that's how you change SQL queries you
156:10 - can take the result of one SQL query and
156:13 - use it in a where clause or you can even
156:15 - select from it again
156:17 - so you can treat a treat the result of a
156:20 - query as another table essentially
156:22 - and then write SQL queries on top of the
156:25 - results of other SQL queries okay
156:28 - so that's how you chain queries
156:36 - okay so here's an exercise for you
156:38 - retrieve the details of all the
156:40 - customers in the United States who have
156:43 - made payments between April 1st 2003 and
156:47 - March 31st 2004. so how would you do
156:50 - this you would first
156:52 - think about it the way you would do this
156:54 - is first you would just look at all the
156:55 - payments so you just do select star from
156:58 - payments and then you would look at
157:00 - payments
157:01 - between April 1st 2003 and March 31st
157:05 - 2004. so you would put some kind of a
157:08 - where Clause where you would combine two
157:10 - conditions using an and
157:12 - keyword and once you get the
157:15 - results for payments just between these
157:17 - two dates then you simply retrieve the
157:20 - customer ID for those payments
157:23 - and then once you have that list of
157:25 - customer IDs or the distinct list of
157:27 - customer IDs you can use that to get the
157:30 - details of customers
157:31 - and you add another where Clause where
157:34 - you will check
157:35 - whether the customer is in United States
157:37 - or not so it's going to get a little
157:39 - complex here but I will let you figure
157:41 - this out and if you are unable to do it
157:43 - uh do ask on the slack group and we'll
157:46 - help you out
157:48 - okay so let's talk about grouping then
157:52 - so here's a question
157:54 - find the total number of payments made
157:56 - by each customer before October 28 2004.
158:03 - all right let's go back and let's try
158:04 - and solve this
158:09 - so here's the question
158:12 - total number of payments made by each
158:13 - customer before October 28 2004.
158:19 - so we say select star from payments
158:21 - again
158:25 - so we were selecting we want to show all
158:27 - the columns from the payments table
158:30 - all right and we just want to look at
158:33 - payments before October 28 2004 so where
158:36 - payment date
158:38 - is less than
158:39 - 2004
158:42 - 1028
158:44 - and now
158:46 - we want to count the total number of
158:48 - payments so we could do this count
158:52 - but this is the total number of payments
158:54 - across all customers we want to count
158:56 - the number of payments made by each
158:57 - customer
158:58 - so here's what you can do
159:00 - you can provide a
159:05 - you can provide a group by Clause so you
159:07 - can type something like this you can say
159:09 - Group by
159:10 - well I believe it shows up after where
159:12 - so yeah this this can sometimes be
159:14 - confusing which clause comes after which
159:16 - but let's try here
159:22 - well actually let's start with that and
159:24 - then we'll see if that works so Group by
159:26 - so you type select count start from
159:28 - payments and group it by
159:31 - customer number
159:35 - so now you're just looking at
159:38 - count star of payments and grouping by
159:41 - customer numbers okay I think this this
159:43 - comes after
159:47 - yep
159:48 - so you type select count star from
159:50 - payments where payments date is less
159:52 - than to 20 2014 28 and you Group by the
159:55 - customer number so what happens here SQL
159:58 - first creates or groups of groups of
160:01 - rows for each customer number and then
160:04 - it computes the sum or it computes the
160:06 - count
160:07 - of the number of rows for each customer
160:09 - number so here it seems like for a
160:12 - certain customer there are two rows for
160:14 - a certain customer there are three rows
160:15 - for another customer there is one row
160:17 - Etc but of course we also want to see
160:20 - the customer number so what we can do is
160:22 - we can just take this customer number
160:23 - column and select that too okay so
160:26 - anytime you Group by a certain column
160:28 - you can also show that column in the
160:31 - result
160:33 - so here's what that looks like select
160:36 - count star
160:37 - from payments
160:39 - where payment date is less than a
160:40 - certain value
160:43 - select customer customer number comma
160:45 - count star from payments where payment
160:47 - data is less than a certain value and
160:49 - group this data by customer number first
160:51 - so first SQL creates groups for each
160:54 - customer number then it performs this
160:56 - count star and then it gives us a
160:58 - customer number and the count star okay
161:00 - now here's one other thing we can do
161:02 - this is not very informative because
161:04 - we're looking at count star here what we
161:06 - can do is we can just say uh
161:09 - number of payments
161:12 - we can rename this count the output of
161:15 - this count
161:16 - as number of payments
161:21 - okay this is called aliasing so now you
161:24 - have this table where it says customer
161:27 - number and it shows you the number of
161:29 - payments and you can see that the
161:30 - customer number 112 had two payments
161:33 - before the state customer number 114 had
161:35 - three payments and for each customer in
161:37 - the database you get how many payments
161:39 - they've made
161:40 - only the customers who have made
161:42 - payments before this particular date
161:45 - so this is how you use Group by grouping
161:48 - is very commonly used with aggregation
161:50 - in functions like count
161:59 - okay now apart from the count you can
162:03 - also compute the sum of values in a
162:05 - column so here's one thing you can try
162:07 - and figure out find the total amount
162:09 - paid by each customer which is the sum
162:11 - of all their payments
162:13 - before October 28 2004 so let's see if
162:16 - we can do that I'm just going to once
162:18 - again select
162:20 - I'm just going to select start from
162:22 - payment
162:23 - s here and just see
162:26 - what columns we have so we have a
162:29 - payment date which we have been looking
162:30 - at we've been looking at this customer
162:32 - number but there is also this amount
162:34 - so what we want to do is we want to
162:36 - total up the amount for each customer so
162:39 - let me go back here so now I have select
162:41 - customer number and instead of count
162:44 - star which is going to count the rows I
162:47 - am going to call sum
162:49 - and I'm going to sum the values in the
162:51 - amount column so count you generally put
162:54 - in Star because you're just counting the
162:56 - number of rows so you don't have to
162:57 - specify a column
162:59 - but
163:01 - when you want to compute the sum you
163:03 - specify the column for which you compute
163:04 - the sum so sum of amount and I'm going
163:07 - to call that as total amount
163:10 - okay so select customer number and some
163:13 - amount which I'm calling total amount
163:15 - from payments where payment date is less
163:17 - than
163:19 - 28 October 2004 and group by the
163:22 - customer number
163:23 - and that now gives you for each customer
163:25 - the total amount so all we've done is
163:27 - we've replaced count star with some
163:29 - amount
163:30 - okay so these functions are generally
163:34 - work all work in the same way some count
163:37 - and you can also use them together so
163:39 - here's an example find the total number
163:40 - of payments and the total payment amount
163:43 - for each customer for payments made
163:46 - between uh before October 28 2004.
163:50 - so how would we do that well we have
163:53 - select customer number uh and then we
163:56 - have the total amount already I'm just
163:58 - going to add another column here so I'm
164:00 - saying I'm going to say count star
164:02 - as
164:05 - number of payments
164:08 - comma
164:09 - yeah so we have select customer number
164:11 - count Star as number of payments some
164:13 - amount as total amount from payments
164:16 - where payment date is less than such and
164:18 - such and then we Group by customer name
164:20 - so now we have for each customer what is
164:23 - the number of payments they've made and
164:25 - what is the total amount that they've
164:26 - paid before this particular date and you
164:29 - can try and remove this where clause and
164:30 - see that the result actually changes and
164:33 - you see now that the result is different
164:34 - right
164:35 - so try and understand each part of the
164:37 - SQL query the same SQL queries mentioned
164:39 - here so try and understand each part of
164:41 - the query and if you can make sense of
164:43 - it then you're getting familiar with SQL
164:47 - and here's an exercise for you determine
164:50 - the total number of units sold for each
164:52 - product so there is a products column
164:54 - and then there is a
164:56 - so there is a order details column
164:59 - I think
165:00 - let's take a look at that quickly
165:05 - select star
165:07 - from order detail so there is an order
165:09 - details table
165:13 - and this contains the details of all the
165:15 - orders that have been placed and then
165:16 - here you have
165:18 - the product code and you have the
165:20 - quantity ordered
165:22 - of that product in that particular order
165:28 - and what we want to do is we want to
165:30 - find the total number of units sold for
165:33 - each product so if I simply do
165:36 - Group by
165:37 - product code
165:41 - and here if I do
165:43 - product code
165:46 - and I do a sum
165:48 - and in the sum I put in the quantity
165:51 - order
165:53 - so now what we're saying is we want to
165:56 - group the rows in order number in order
165:58 - details by the product code and for each
166:01 - product code we want to take a sum of
166:03 - the quantity ordered column
166:05 - and if we do that
166:08 - and run this query
166:10 - you should see here that we have the
166:11 - product code and then for each product
166:13 - code we have the quantity ordered okay
166:16 - and that's how you answer this question
166:20 - again becomes easier to understand once
166:23 - you try it yourself so here's how I
166:25 - would go about solving working through
166:27 - this notebook just read the question
166:28 - don't look at the answer just
166:30 - immediately go to your SQL workbench and
166:32 - then start typing out and start figuring
166:34 - out how to solve the question and if
166:37 - you're able to solve the question great
166:38 - if you're not then you can look at the
166:40 - answer and again don't copy paste the
166:42 - answer look at the answer maybe for a
166:44 - couple of minutes try and understand
166:46 - what it does and then go back and try to
166:48 - type it out again typing out code is a
166:50 - very important part of becoming familiar
166:52 - with
166:53 - SQL or python or coding in general
167:00 - okay
167:01 - now apart from sum and count you can
167:04 - also do the min max in average for
167:07 - example if you want to figure out
167:09 - what was the maximum payment made by
167:12 - each customer before a certain date you
167:15 - can do that all you need to do here is
167:17 - in this
167:19 - table you can maybe just add
167:21 - max amount
167:24 - as let's just call it largest payment
167:28 - so now you have for each customer what
167:30 - is the largest payment they've made
167:32 - and you can see this here the largest
167:34 - payment that they've made is a for this
167:36 - person has made is a fourteen thousand
167:37 - dollars they can also you can also add
167:39 - the minimum amount that they've paid
167:42 - so smallest payment
167:48 - so the smallest payment they've made is
167:50 - 32 000. so already we're getting some
167:52 - insights in it turns out that in this
167:54 - case customer number one zero three the
167:56 - largest num the largest payment is
167:58 - fourteen thousand dollars and the
167:59 - smallest is six thousand but for one one
168:01 - two the largest payment is thirty three
168:03 - thousand and the smallest is 32. so
168:05 - maybe this customer is just clearing uh
168:08 - bills as soon as they hit a certain
168:10 - amount right you can also then look at
168:12 - the average payment so what is the
168:13 - average order amount and think it is
168:16 - average okay
168:19 - so what is the average amount and this
168:22 - is the average payment
168:33 - okay I think there's a an issue here I'm
168:37 - not sure what the average is called but
168:38 - let's see average my sequel
168:42 - AV it's called AVG so let me just change
168:45 - that to AVG
168:47 - yeah so AVG is a function name here and
168:51 - you can see that the average payment for
168:52 - each customer is also shown here right
168:54 - so this is how you can do basic analysis
168:56 - directly within SQL you don't even have
168:58 - to export the data although if you want
169:00 - you could export it to a CSV file uh
169:03 - that's an option
169:04 - from the MySQL workbench but a lot of
169:06 - analysis can be done directly within SQL
169:11 - okay so let's talk about sorting and
169:13 - pagination
169:14 - now so far we've been doing all these
169:16 - queries and through these queries we get
169:18 - a lot of information but in a lot of
169:20 - cases we are looking we are interested
169:22 - in finding the a top 10 or top five or
169:25 - the maximum value
169:26 - so here's an example retrieve the
169:29 - customer numbers for the 10 customers
169:32 - who made the highest total payments in
169:34 - 2004.
169:37 - or actually let me change that to
169:41 - before October
169:44 - 28 2004 okay so retrieve the customer
169:48 - number for customer numbers for 10
169:50 - customers who made the highest payments
169:52 - total payment before October 28 2004. so
169:57 - let's try and answer this step by step
170:00 - we want
170:04 - to retrieve the customer number
170:06 - so we can say select
170:09 - star from payments
170:12 - and once again we are interested in
170:15 - payment date
170:17 - before
170:19 - 2004
170:21 - October 28th
170:24 - grade we have that information
170:26 - but now we want to retrieve uh
170:30 - we were interested in the highest total
170:32 - payment so before that we are interested
170:34 - in the total payment per customer so if
170:36 - we do this if we do a group by
170:39 - customer number
170:41 - and then we do uh we select the customer
170:44 - number for each group and then we do a
170:47 - sum of the amount column
170:53 - so now what that gives us is the total
170:55 - the total amount paid by each customer
170:58 - before October 28 2004 so we have that
171:02 - but now we are interested in the people
171:05 - who made the highest total payment so
171:07 - here's what we can do we can type at the
171:09 - end order by so we type order by
171:13 - and then we tell the column name that we
171:16 - want to order by so we want to order by
171:18 - this column which is the sum the total
171:20 - amount so let me just rename this as
171:23 - total payment
171:25 - so I'm going to call this column the sum
171:27 - column I'm going to call it total
171:29 - payment
171:31 - and I want to order it by total payment
171:35 - so let's run that
171:37 - and Order bike generally comes at the
171:39 - very end so now you have customer number
171:40 - 456 they have a total payment of 1679
171:45 - customer number 381 has 2755 and so on
171:47 - but of course we are interested not in
171:50 - the lowest so this is ordered in
171:51 - ascending order but we are interested in
171:53 - the highest so to do that you type desc
171:56 - descending so a ASC for ascending and
171:59 - desc for descending and let's run that
172:02 - so now you have the maximum value
172:05 - 31 33 sorry 331 256 dollars were spent
172:11 - by customer number 141.
172:13 - okay
172:16 - and we have this information for all the
172:18 - customers but the question asks only for
172:22 - the top 10 customers and typically
172:23 - anytime you issue queries like this in a
172:26 - very large database
172:27 - you probably only want to look at maybe
172:29 - the top 10 the top 50 or the top hundred
172:32 - so here's how you can do that you just
172:34 - call at the end you type limit
172:36 - and then you tell the number of rows
172:38 - that you want to see in the result
172:40 - okay so if I type limit a 10 at the very
172:43 - end so that's going to just give us 10
172:46 - results you can see these are the 10
172:48 - customers uh
172:49 - 141 124 148 151 and 320.
172:55 - okay and by the way limit Works without
172:58 - order by as well it you don't need an
173:00 - order you can do a limit just like this
173:02 - too so these are both independent but in
173:05 - general whenever you're doing an
173:06 - ordering it's common practice to also
173:08 - limit the number of results so as to not
173:10 - put a very heavy load on the database
173:16 - so that's what we created select
173:18 - customer number and some amount as total
173:19 - payment from payments where payment date
173:21 - is less than this value and we Group by
173:25 - customer number
173:26 - order by total payment descending and
173:28 - limit the results to 10.
173:34 - now if you want to see the next 10
173:37 - results because we've just limited the
173:39 - results to 10 all we need to do is add
173:41 - an offset so let's say we want to skip
173:43 - ahead we want to skip the first 10 rows
173:46 - and you want to see the next 10 rows we
173:47 - type offset 10.
173:49 - and just notice this number here 320 and
173:53 - 93565 if I type offset 10 you will see
173:56 - that now we have 386 Which is less than
174:00 - the previous value so now I'm no longer
174:01 - looking at the top 10 I'm looking at the
174:04 - next 10 so customer number 11 to 20 when
174:08 - they are sorted by the total payment and
174:12 - if it's let's say if I set the offset to
174:13 - 5
174:15 - if I if I set the offset to 5 so I'll
174:19 - just skip this query will just skip the
174:21 - first five rows and it'll show me from
174:23 - the sixth row onwards right so limit and
174:25 - offset can be set independently limit
174:28 - tells you how many rows you want offset
174:30 - tells you how many rows you want to skip
174:32 - now here I've skipped the first 50
174:34 - customers so I'm looking at
174:36 - customer number 51 to 60. okay and I
174:40 - could maybe even if I wanted I could
174:42 - look at
174:43 - just five of these
174:45 - so play around with limit and offset
174:47 - they are used to limit and paginate the
174:49 - queries
174:53 - SQL also provides mapping functions and
174:56 - these mapping functions are applied to
174:58 - individual values so now we're no longer
175:00 - combining multiple rows of data now we
175:04 - are just applying them to individual
175:05 - values
175:06 - so here is a question display the full
175:09 - name of the point of contact for each
175:12 - customer in the United States in upper
175:16 - case
175:16 - along with their phone number
175:19 - and we want this information to be
175:20 - sorted by the alphabetical order of
175:23 - customer name okay so there's a lot
175:25 - going on in this question and these are
175:27 - the kind of questions that you will see
175:28 - in interviews often and don't feel
175:30 - intimidated just go step by step
175:32 - the first thing here is we want
175:35 - information about customers
175:37 - so we go here and let's clear all this
175:40 - and we just type select star from
175:42 - customers
175:44 - great now we have information about
175:46 - customers
175:47 - next we want customers in the United
175:50 - States
175:52 - so we have
175:54 - what's that we have this country column
175:56 - and in country we have USA so if I just
175:58 - type where
176:00 - country equals USA
176:05 - so now I'm just looking at customers in
176:07 - the United States and you can check here
176:08 - then all of the all of them have Country
176:10 - USA
176:11 - okay great one more thing done next
176:16 - we want to display the full name of the
176:19 - point of contact for each customer
176:21 - so if you see here we have contact first
176:24 - name and we have contact last name so we
176:27 - could do this we could just say
176:30 - let's just print a customer name I think
176:33 - that is something that we should display
176:34 - and let us display
176:37 - contact first name
176:40 - and let us display contact
176:42 - last name
176:46 - okay
176:49 - all right so now we have the customer
176:51 - name we have the contact first name and
176:53 - contact last name only for those
176:55 - customers where country is set to USA
176:59 - okay so display the full name
177:02 - it's still not the full name we are
177:04 - showing two separate columns but we'll
177:05 - figure out that piece but here it says
177:07 - we want to display these in uppercase
177:09 - for some reason or maybe we want to
177:11 - print them somewhere or copy paste this
177:13 - information somewhere so how do you
177:15 - convert a string into uppercase well
177:17 - there's a function for that you just
177:18 - call you case
177:20 - so your case is going to make it
177:21 - uppercase and L case is going to make it
177:23 - lowercase
177:24 - so I just call you case on first name
177:26 - and let me maybe do L case for now on
177:30 - contact name
177:33 - and you can see here the first name
177:36 - becomes upper uppercase all capital
177:38 - letters or uppercase letters and the
177:41 - last name has become lowercase let me
177:43 - turn that into uppercase as well
177:49 - so now we have both an uppercase
177:52 - and notice that these are not
177:54 - aggregation functions they did not
177:56 - combine all the rows into a single value
177:57 - they applied this function uppercase to
178:01 - every individual value so this was
178:02 - applied to Susan it was applied to this
178:04 - row and this row and this row and so on
178:06 - okay so that's why these are called
178:08 - mapping values they take a column and
178:10 - they map that column onto a based on a
178:14 - function
178:16 - so that's why these are called mapping
178:18 - functions
178:19 - now last bit here is or maybe a couple
178:22 - more things left one is
178:25 - display the full name so we want to take
178:27 - the first name and last name and we want
178:30 - to combine them so there are certain
178:32 - functions which can combine columns and
178:35 - the combination that we want to use here
178:38 - is called concat concat is short for
178:40 - concatenation so I'm just going to call
178:42 - concat here
178:44 - c-o-n-c-a-t and let me drop this for a
178:47 - moment let me just get rid of these
178:50 - and I'm just going to do customer
178:52 - first name
178:54 - and oh sorry this is contact so contact
178:58 - first name and contact last name
179:03 - so now we've combined contact first name
179:05 - and contact last name but there's a
179:07 - problem here you see Susan Nelson this
179:10 - is there's no space between them
179:12 - well that's easy to fix you just add a
179:14 - space here
179:16 - and now you have Susan Nelson
179:18 - and we want to make this uppercase so
179:20 - now concat first name Etc is the uh
179:23 - string that we're dealing with or it's a
179:25 - column that we're dealing with so we
179:27 - just called you case here
179:29 - and that is going to now make that
179:31 - uppercase
179:33 - now you could do it two ways you could
179:34 - apply to each column first and then
179:36 - concatenate them or you could apply it
179:38 - outside both will do the same so now we
179:40 - have that one last piece of cleanup is
179:43 - let me just get this on a new line is to
179:46 - Simply get
179:47 - is to Simply rename this column so I'm
179:49 - just going to call this contact name
179:53 - okay
179:55 - so we concatenate first name and last
179:57 - name with the space between them convert
179:59 - that to uppercase call it concat contact
180:01 - name
180:02 - and list it out
180:05 - one last thing we also want to display
180:07 - their phone number and we want to sort
180:09 - by the alphabetical order of the
180:12 - customer name so let's display phone
180:14 - number here let's just put in comma
180:16 - phone number
180:19 - I think it's just called phone if I'm
180:21 - not mistaken
180:23 - yeah
180:25 - so now we have customer name contact
180:26 - name phone and we want to order them so
180:30 - we just put in order by
180:32 - and here we put in
180:35 - what was that number customer we want to
180:37 - order by customer name in alphabetical
180:39 - order so we can even just put in ASC
180:41 - here or ascending
180:43 - to mean increasing alphabetical order
180:45 - so now you see we have this customer
180:47 - name Americans souvenirs Automotive
180:49 - Classics board and toys Cambridge
180:52 - Collectibles classic gift ideas all of
180:54 - these are customers in the UK in the USA
180:56 - we have that contact name listed in
180:58 - uppercase we have the phone number of
181:00 - the contact and we have
181:03 - sorted this list in alphabetical order
181:07 - that's how you answer SQL queries and
181:09 - that's all we're going to do over and
181:10 - over for the rest of the session
181:12 - essentially
181:15 - here's another example display a
181:17 - paginated list of customers sorted by
181:19 - customer name with a country code column
181:23 - and the country code is simply the first
181:25 - three letters in the country name they
181:27 - should say country code
181:30 - so the country code is simply the first
181:32 - three letters in the country name in
181:34 - lower case
181:35 - so here's how you can do that
181:37 - we want to show customer so just
181:40 - paginated list of customers so let me
181:43 - just do
181:44 - let me open a new query here let me do
181:47 - select star from customers and we want
181:50 - to show a paginated list so we want to
181:52 - show where
181:55 - um sorry we want to limit to let's say
181:58 - 10 customers
182:00 - so these are 10 customers
182:02 - then we want to sort them by customer
182:05 - name so let's do order by
182:10 - all right it is sorted by customer name
182:12 - just fine
182:15 - and then we want to show country code
182:16 - column
182:18 - so maybe let's just show
182:20 - customer number
182:22 - and customer name
182:25 - and Country
182:27 - so now we have customer number name and
182:29 - Country but we are interested in
182:31 - something called a country code
182:33 - and what's a country code the country
182:35 - code is simply the first three letters
182:36 - in the country name in lower case so we
182:39 - want to get the first three letters out
182:41 - of every country name and that can be
182:43 - done using this substring function
182:46 - so instead of country we put in sub
182:48 - string
182:50 - country and in substring you specify
182:53 - where you want to start now in SQL
182:55 - numbering starts at one not at zero so
182:57 - just be careful about that and we want
183:00 - to take three values I think so we just
183:02 - say
183:03 - one comma three
183:05 - and yeah so that gives us just the first
183:08 - three characters of each country name
183:13 - and let me just clean that up here so
183:16 - that gives us the first three characters
183:17 - from each country name but we are
183:19 - interested in
183:22 - we want to make it lower case so we just
183:24 - type L case here and that's going to
183:26 - make it lowercase for us and let's just
183:28 - rename that using as to country code
183:34 - okay and there you go so now for each
183:36 - customer name we have a country code
183:39 - for whatever reason we need the country
183:41 - code
183:42 - all right
183:43 - so that's another function here's one
183:45 - last function
183:47 - display the list of the five most
183:49 - expensive products in the motorcycles
183:52 - product line with their price rounded to
183:55 - Dollars and the price is the MSRP column
183:58 - okay let's try and answer this to the
184:00 - five most expensive products in the
184:02 - motorcycles product line
184:04 - so let's get rid of some of these
184:16 - okay so let's see select star from
184:19 - products
184:22 - there's our products a list of all our
184:24 - products and here one thing you will see
184:26 - is a product line so we can we simply
184:28 - want to look at motorcycles so where
184:32 - product line
184:34 - the column product line has the value
184:36 - motorcycles
184:43 - okay now we're just looking at
184:44 - motorcycles here
184:46 - and we want to check the five most
184:48 - expensive products
184:51 - so we let's order them let's order by
184:56 - MSRP maximum sale retail price I guess
185:02 - so yeah and we ordered that by MSRP
185:05 - and we can also just type MSRP should
185:07 - not be a problem here
185:10 - okay now they're ordered by MSRP but of
185:12 - course we want the most expensive so we
185:13 - type the ESC descending
185:16 - so now you can see that we have only
185:17 - motorcycles and we have ordered them in
185:20 - the decreasing order by MSRP
185:23 - and
185:25 - we just want to see the top five
185:26 - products so I'm just going to add a
185:29 - limit here so let me just move this down
185:35 - yeah so let me just add a limit order by
185:37 - MSRP descending limit five
185:40 - so now we have the top five products and
185:42 - maybe we don't need all the columns
185:44 - mostly we just need let's say the
185:45 - product code
185:47 - and product name
185:49 - and MSRP
185:53 - all right this is the required
185:55 - information there is one last condition
185:57 - here we want to round the price to
185:59 - dollars maybe we're creating a report
186:00 - where we don't want to show the full
186:03 - price we just want to round it to
186:05 - Dollars and the way you do that is just
186:07 - type round
186:09 - so round function will do that for you
186:11 - so now this number is rounded to Dollars
186:13 - you also have a ceiling and a floor
186:15 - function so if you want to round down or
186:17 - round up you can use those but round
186:19 - does the job and in round you can also
186:21 - specify the number of decimal points
186:22 - that you're interested in for example if
186:24 - you want to see one decimal point just
186:25 - specify round one
186:27 - okay
186:29 - so that's how you answer this question
186:32 - five most expensive products in the
186:34 - motorcycle category
186:37 - so that was about the mapping functions
186:39 - you will not
186:43 - yeah there are a lot more mapping
186:45 - functions so you generally don't need to
186:46 - remember all of them although it will
186:48 - help again for interviews for exercises
186:51 - and as you solve more exercises you will
186:53 - automatically start memorizing them but
186:55 - there are a bunch of different functions
186:57 - that you can apply to dates and you can
186:59 - apply to numbers and you can apply to
187:01 - strings all of them
187:03 - and one other kind of
187:05 - function or operation we should look at
187:06 - is arithmetic you will often have to
187:08 - combine
187:10 - data from multiple columns
187:12 - using arithmetic operations
187:15 - so here's a question display the product
187:18 - code product name Buy price sale price
187:22 - and profit margin percentage
187:25 - so what's profit margin percentage will
187:27 - you buy the product or maybe you buy the
187:29 - parts for that product at a certain
187:30 - price and then you sell it at a certain
187:32 - price
187:36 - the difference is called the profit and
187:38 - or the margin and the percentage is
187:40 - basically the sale price MSRP minus the
187:43 - Buy price multiplied by 100 divided by
187:47 - the Buy price
187:48 - okay so that's the profit margin
187:51 - percentage sale price minus Buy price
187:53 - divided by Buy price and convert that to
187:55 - a percentage by multiplying with 100.
187:58 - for the 10 products with the highest
188:00 - profit margin so we want to show the 10
188:02 - products with the highest profit margin
188:04 - and we also want to round the profit
188:06 - margin to two decimals so there's a lot
188:08 - going on here let's go step by step here
188:11 - first thing is we want to get some
188:12 - information out of the products table
188:14 - right so
188:17 - let's go select star from products
188:23 - yep so now we select a bunch of products
188:26 - all right
188:27 - and what are we interested in product
188:29 - code product name by price sale price so
188:32 - let's get product code product name
188:36 - Buy price
188:39 - sell price
188:41 - uh okay is there a sale price I don't
188:43 - think so there's just an MSRP
188:48 - yeah
188:50 - okay so now we have the information that
188:52 - we're interested in but there is this
188:53 - last
188:55 - column that we need which is profit
188:57 - margin percentage and fortunately I have
188:59 - the formula here so here's what I can do
189:01 - I can simply put in the formula here
189:02 - comma
189:04 - um
189:05 - MSRP minus
189:08 - Buy price
189:10 - let's get these on different lines
189:15 - so MSRP minus Buy price
189:20 - and let's get that down as well yeah so
189:23 - this is the profit and if you divide
189:25 - that by Buy price
189:29 - so these are all column names right so
189:31 - you you're saying we want to take values
189:33 - in the MSRP column from them subtract
189:35 - the values in the Buy price column and
189:37 - then divide by the values in the Buy
189:39 - price column
189:40 - and we want to multiply that by 102 so
189:43 - let's just put in a multiplied by 100
189:44 - and let's put the entire thing within a
189:46 - bracket
189:48 - okay
189:49 - so now we have MSR
189:51 - oh yeah so now we have MSRP minus Buy
189:53 - price multiplied by 100 divided by Buy
189:55 - price and let's just call that profit
189:57 - margin
189:58 - so let's just rename that so that's our
190:01 - profit margin and you can see that the
190:03 - profit margin for this product since we
190:05 - buy it at 48 dollars and sell it at 95
190:08 - is 96 percent that is the amount of
190:11 - money that we've made on top of the Buy
190:13 - price
190:14 - and what do we want to do with the
190:16 - profit margin well we want to
190:20 - show the 10 products with the highest
190:22 - profit margin so let's add that so that
190:24 - will be a sort or an order by
190:28 - order by and now once we've created this
190:31 - column we can use it here so we can call
190:35 - ordered by profit margin
190:37 - and we want to limit it to 10.
190:39 - and we want to see the highest profit
190:41 - margin so we say desc descending limit
190:45 - 10. let's check that
190:48 - great so now we have this product the
190:50 - Chevrolet Impala on this product we are
190:53 - making a huge profit margin we're buying
190:55 - it for 32 dollars selling it for 80. so
190:58 - 150 percent profit
191:01 - actually maybe let me just call this
191:03 - profit margin percent so that it's not
191:05 - confusing
191:06 - with the actual number
191:09 - yep now the last thing we want to do is
191:12 - round the profit margin to two decimals
191:15 - and that's easy we just type around here
191:18 - and another bracket here well I guess we
191:22 - don't
191:23 - Let's see we probably don't need that
191:25 - bracket and we want to round it to two
191:27 - decimals so there you go now we have the
191:31 - profit margin rounded to two decimals
191:32 - and these are the 10 products with the
191:35 - highest profit margin percentage so
191:37 - these are the kind of queries that you
191:39 - should be able to answer by using
191:41 - arithmetic operations by using sorting
191:43 - grouping
191:44 - and aggregation
191:48 - and mapping functions
191:52 - you can check out what other operators
191:53 - are supported in SQL it's not just a
191:56 - Johan arithmetic you have add subtract
191:58 - multiplied divide you can divide and you
192:00 - also have this modulo function which is
192:02 - to compute the remainder so you can do
192:03 - that as well and then you have some
192:05 - bitwise operations and you're already
192:07 - familiar with comparison operations as
192:09 - well so comparison operations are
192:11 - typically used in the where Clause as we
192:13 - saw with the date
192:15 - talking about dates SQL also provides
192:19 - several
192:21 - functions for extracting information
192:23 - like the year month Etc out of date
192:25 - columns so let's look at an example list
192:29 - the largest single payment done by every
192:31 - customer in the year 2004 ordered by the
192:35 - transaction value highest to lowest okay
192:37 - again seems complex but let's break it
192:40 - down
192:42 - we are interested in payments that's
192:44 - what I can gather here list the largest
192:46 - single payment so I'm just gonna go here
192:48 - and first of all just to select star
192:51 - from payments
192:53 - okay we have payments now
192:56 - next
192:57 - we want
193:00 - the largest payment by each customer
193:04 - okay so we want basically the maximum
193:06 - payment by each customer so we can
193:08 - probably do a group by customer number
193:12 - and then for each group of rows for each
193:15 - customer
193:18 - we want the maximum payment that they've
193:20 - done so let's call amount max amount and
193:24 - let's rename that to
193:26 - largest
193:28 - payment okay all right so it's start
193:31 - starting to make sense now
193:34 - so we have we select customer number we
193:36 - select the maximum amount so for each
193:39 - customer we look at all the payments
193:40 - we've made and pick the one with the
193:42 - maximum amount or pick the maximum
193:45 - amount among those
193:47 - and of course for that we have to do a
193:48 - group by customer number
193:52 - but we want to look at this in the year
193:54 - 2004.
193:56 - how do we do that well we have a payment
193:58 - date
193:59 - and we could check if the payment date
194:02 - is greater than Jan first 2004 and less
194:06 - than January 2005 and things like that
194:09 - or we could simply do where and we could
194:12 - use this year function so here is all
194:14 - here is a function just like
194:16 - other mapping functions and into the
194:19 - year function pass in payment date
194:22 - and just check if the year of the
194:24 - payment date is 2004.
194:26 - okay
194:29 - so that's our query right here select
194:32 - customer number max amount as largest
194:34 - payment from payments where year of the
194:36 - payment date is 2004 and group by
194:39 - customer number
194:42 - and ordered by transaction value right
194:44 - so we want to order that by transaction
194:46 - value so we should also probably put in
194:50 - order by largest payment
194:56 - and let's run that
194:58 - so it turns out that customer number 161
195:04 - it turns out that customer number 161
195:07 - made the largest payment in the year
195:09 - 2004 and that payment was
195:12 - 2434 dollars
195:15 - oh well no
195:16 - we want to sort it in descending order
195:18 - yeah so customer number 141 the loyal
195:22 - customer made 116 000 200 in a single
195:27 - payment
195:28 - and that was the highest payment in 2004
195:30 - by a huge margin actually you had to 84
195:32 - 410 after that
195:35 - okay
195:37 - so that's how you pick out information
195:39 - from a year from a date
195:42 - here's another example
195:45 - show the total payments received month
195:47 - by month for every year
195:50 - okay this is interesting so
195:52 - you want to show the total payments
195:54 - month by month for every year so you
195:56 - want to see January 2003 February 2003
195:59 - uh March 2004 and so on
196:02 - so let's once again start with payments
196:05 - select start from select start from
196:08 - payments
196:10 - we have the data
196:11 - now we are interested in year and month
196:14 - so we have a payment date
196:16 - if we can just create a new column for
196:18 - ear and a new column for month I think
196:21 - that should just get us started so I'm
196:23 - just going to create a new column for
196:25 - here so I select star which means I
196:27 - select all the columns but apart from
196:29 - that I also select year
196:31 - of payment date
196:34 - as
196:36 - payment year
196:40 - and let's see that so now we have a
196:42 - payment here over here
196:44 - and let me just put that at the
196:45 - beginning
196:49 - and then we also want the payment month
196:51 - so we just type month
196:53 - and we type payment date so from the
196:55 - payment date we get the month and we
196:57 - call that payment month
197:00 - so let's put that on a new line here
197:03 - comma star so we still want the other
197:05 - columns or you know what maybe let's
197:07 - just keep the amounts now or maybe we
197:10 - don't need the other information
197:13 - so select payment
197:15 - date year as payment year month of
197:18 - payment date as payment month and then
197:20 - the amount from payments
197:24 - yep
197:26 - so now it tells us
197:28 - for every single payment we now have a
197:31 - year and a date in the amount but of
197:33 - course we don't want
197:37 - of course we don't want uh like this is
197:39 - still showing us every individual
197:41 - payment like if I put a comma star here
197:43 - you will see that we are still looking
197:45 - at
197:54 - yeah if I just instead of the amount if
197:55 - I put star here
198:00 - okay never mind
198:10 - yeah so you can see that we're still
198:12 - looking at every single payment even
198:13 - though we've created a payment here
198:15 - column and we have created a payment
198:17 - month column
198:18 - we are still looking at every single
198:20 - payment individually what we want is the
198:23 - totals for each month and for each year
198:26 - so how do we do that well
198:28 - you guessed it we want to total up the
198:30 - amounts so let's get rid of these other
198:32 - columns and let's just do a sum
198:36 - and we want to get the sum of the amount
198:39 - but of course just doing a sum is not
198:41 - enough because we also need to do a
198:43 - group by right because we want to First
198:45 - Define groups so for each month comma
198:48 - year we want to get a group of columns
198:49 - you want to get the group a group of
198:51 - rows so you want to get all the rows
198:53 - which were which belong to January of
198:56 - 2003 all the rows which belong to
198:58 - February of 2003 and then sum up each
199:00 - group so we type here Group by
199:05 - Group by and in group by you can
199:07 - actually provide multiple columns so we
199:09 - have this payment year column
199:11 - and we have this payment month column
199:15 - so now we have a payment here we have a
199:17 - payment month and we have the total sum
199:19 - so this is the sum of the amount of all
199:22 - the payments made in that particular
199:23 - month of that particular year and maybe
199:26 - we also want to order by these same
199:27 - criteria so that we can see it in a more
199:31 - understandable format so we also order
199:33 - by payment year and payment month
199:39 - and you don't need this comma here
199:41 - so now we have 2003 one and the sum is
199:45 - 26 000 and then 20032 which is February
199:49 - of 2003 and the sum is 144 000 and then
199:54 - 2003 March is 199
199:56 - 000 and so on
199:58 - seems like
199:59 - what is this August September of 2003
200:02 - was
200:03 - pretty good so this is how you can now
200:05 - start doing some basic analysis and
200:07 - interpretation so this is your Revenue
200:10 - growth or this this is your Revenue
200:12 - table so if your boss asks for a month's
200:14 - wise Revenue table this is what you give
200:15 - them
200:20 - but of course you probably don't want to
200:22 - show these numbers like this like it
200:24 - doesn't make sense to look at this zero
200:25 - zero zero zero three here and it's
200:27 - probably a floating point or a rounding
200:29 - error somewhere
200:30 - so let's make this a little prettier and
200:34 - here again it's a bit difficult to guess
200:36 - the month from month number going to the
200:38 - actual month can be a bit difficult so
200:41 - let's make this a little prettier
200:43 - now for the above query the query just
200:46 - that we just looked at let's format the
200:48 - amount properly with a dollar symbol and
200:50 - comma separation maybe show it something
200:52 - like this 26
200:54 - 267.62 and just two two decimal places
200:58 - and let's also show the month as a
201:00 - string okay
201:02 - so now we are
201:04 - in the territory of printing things
201:06 - nicely of making things look good so
201:09 - that's where you need these formatting
201:11 - functions there are two numbers two
201:13 - functions one is the format function for
201:15 - numbers and then the date format
201:17 - function for dates
201:18 - so let's first look at the format
201:20 - function for numbers now instead of
201:22 - showing the sum just the sum of amount I
201:24 - am going to call format here
201:27 - and
201:30 - I am simply going to put in
201:32 - I think you can to format you can
201:34 - mention how many decimal digits you want
201:37 - so I'm just going to put in 2 here and
201:39 - format is automatically going to add
201:41 - commas here
201:42 - so now you can see that
201:46 - you have 144 comma three eight four
201:48 - point three six just by adding this
201:51 - format keyword here and of course now
201:53 - it's no longer number nowadays become a
201:55 - string and let us also rename this
201:57 - column as Revenue
202:01 - so now we have revenues one four four
202:03 - three eight four point three six
202:05 - maybe let's go a step further let us add
202:07 - a dollar symbol here how do we add a
202:09 - dollar symbol well this is a string and
202:12 - we want to add a dollar symbol at the
202:14 - beginning of the string
202:16 - how do we combine two strings that is
202:18 - done using concatenation so let's call
202:21 - concat the concat function that we saw
202:23 - earlier but this time instead of
202:24 - concatenating two columns we are
202:26 - concatenating a string the dollar symbol
202:30 - with the column
202:31 - so now when we call concat we have
202:34 - dollar one four four three eight four
202:36 - point three six
202:37 - and
202:40 - that is called the revenue so that's how
202:42 - we format the numbers
202:45 - a little other a small cleanup that you
202:47 - can do here especially if you're sending
202:49 - it out to somebody this result is maybe
202:51 - you want to just clean up these call
202:54 - column names so if you want to just call
202:55 - it payment year but of course that's
202:57 - going to be a problem so whenever you
202:59 - have spaces within column names you can
203:01 - use these
203:03 - back codes so this is the code that is
203:06 - available on your keyboard just below
203:08 - the Escape key and let's call this
203:10 - payment month
203:18 - okay and then let's call this uh Revenue
203:21 - I think this should be fine just like
203:23 - this
203:24 - and once again let's just
203:27 - changed it here
203:32 - just cleaning it up a little bit to make
203:34 - it look nicer
203:36 - and then you can export it and send it
203:38 - as a CSV or something
203:40 - so now you have payment here you have
203:42 - payment month you have Revenue with
203:44 - dollars looking good but of course we
203:47 - still missing this piece we want to show
203:49 - things like January February Etc here
203:52 - so if you want to show Jan Feb Etc
203:53 - here's what we can do we can call date
203:56 - format so there is this function called
203:58 - date format
203:59 - and date format is something you will
204:01 - most likely have to look up
204:03 - so date format takes a date as an input
204:06 - and then it takes a certain format in
204:08 - which you want to see the date for
204:09 - example if you want to see the YY mmdd
204:11 - format then you put something like
204:13 - percentage y hyphen percentage M hyphen
204:16 - percentage D or or something and
204:20 - here are all the variables that you put
204:22 - in so inside these codes as the second
204:25 - argument you provide all the variables
204:27 - that you want to show and based on that
204:29 - it is going to show you that information
204:31 - so we are interested in we have a month
204:35 - here
204:36 - and we want to show that month
204:38 - um actually we just want to show the
204:40 - payment date as a month so I'm going to
204:43 - remove this month I'm just going to call
204:45 - date format here
204:47 - and how do I want to format it let's see
204:49 - let's see what options we have
204:52 - so there is this percent B here so I can
204:55 - take this percent B and if I just take
204:57 - this person B here
204:59 - let's see what happens
205:01 - so you see here now this has become
205:03 - August and in fact if I want to get the
205:05 - year name I think the year would be
205:07 - percent y
205:09 - so if I want to get the year name I
205:10 - would maybe just put this
205:13 - and now you can see August 2003 December
205:15 - 2003 Etc but I just want to keep the
205:18 - month name here
205:19 - so now we have the month name so we took
205:22 - the date called date format on it
205:25 - directly on the date and we just
205:27 - extracted out the month using this
205:29 - person B and that is something that I
205:32 - looked up in this table there's no way I
205:34 - can remember all of these so I just have
205:35 - to look these up each time
205:37 - and we saw that person B can give us the
205:39 - abbreviated month name if you want the
205:41 - full month name then we can use percent
205:43 - m that can give us the full month name
205:46 - let's try that too maybe
205:51 - okay so yeah so now you have the full
205:53 - month name
205:54 - but now we've run into a problem because
205:57 - now we have payment here and we have
205:59 - payment month but now because we are
206:01 - ordering by payment here and then
206:03 - payment month
206:05 - the ordering the ordering becomes
206:06 - alphabetical
206:08 - so we want to display the number we want
206:10 - to display the string but we want to
206:12 - order by the number how do we do that
206:15 - well here's one idea
206:17 - I create another column
206:20 - let me just call that let's use month
206:24 - and payment date so let's get the month
206:28 - from payment date and let's call this is
206:29 - called that as month number
206:35 - and I'm just going to instead of
206:38 - ordering by
206:40 - payment year and payment month I'm going
206:42 - to order by month number
206:45 - okay
206:46 - and let's try to run that so that gives
206:48 - us an error because
206:50 - now since I have this new column month
206:52 - number I should also be grouping by this
206:54 - column otherwise
206:56 - anything other than
206:58 - sorry anything other than the
207:01 - aggregation so here is where we are
207:03 - doing the aggregation anything other
207:04 - than the aggregation should show up in
207:07 - group by so let me just put month number
207:09 - here
207:11 - okay so now we have three columns which
207:13 - we have created we've created created a
207:15 - payment here that's fine and we have
207:18 - created a payment month grade and we've
207:21 - created a month number because we also
207:23 - want to track uh
207:25 - we also want to track numbers here
207:28 - and then we are grouping by payment year
207:30 - payment month and month number of course
207:32 - payment month and month number represent
207:34 - the same information so the same groups
207:36 - will be formed for every month of every
207:38 - year we will get a group of rows and
207:40 - then we are taking the sum of those rows
207:41 - uh some of those rows to get the sum of
207:43 - the amount then we are formatting it to
207:47 - add commas and show two decimals and
207:50 - then we are adding the dollar symbol and
207:51 - we are calling that column Revenue
207:54 - okay so this is looking good this is a
207:57 - pretty complex query at this point but
207:58 - it's looking good the only problem I
208:01 - have is that there is this last month
208:03 - number column here which I don't like
208:05 - this is not something I wanna
208:07 - send to the person who's asking for this
208:12 - information so how do we remove that so
208:14 - in some sense we want to use this column
208:16 - month number for grouping
208:19 - and for ordering but we don't want to
208:21 - display it
208:23 - here's how you can do it it's a very
208:25 - simple trick here just remove it from
208:28 - select so you select payment year
208:30 - payment month payment you select Revenue
208:32 - but you remove this from here remove the
208:35 - month number column and just put that
208:38 - here so just put it in group by
208:41 - and put it in order by
208:44 - okay so now we're saying we select year
208:46 - and we select this payment month which
208:50 - is nicely formatted and we select this
208:52 - sum which is nicely formatted as revenue
208:54 - from payments but in group by we are
208:57 - grouping by this additional condition
208:58 - this sort of hidden column which is the
209:01 - month payment date and we are also
209:03 - ordering by this additional hidden
209:04 - column
209:07 - which is a month payment date
209:09 - okay and now we finally have
209:12 - 2003 January 2003 February 2003 March
209:16 - 2004 January February March 2005 January
209:20 - February March okay now this is the
209:22 - perfectly formatted Revenue column
209:24 - Revenue table we exported put it into
209:27 - Excel or send the CSV to whoever needs
209:30 - it okay
209:32 - so that's the query there's a lot going
209:35 - on here so spend your time with it take
209:37 - go through each step and as I said what
209:40 - you want to do is you want to start with
209:41 - the table that seems the simplest
209:44 - uh just get all the data and keep adding
209:46 - in
209:47 - keep embellishing the query step by step
209:50 - to cover all the requirements and maybe
209:53 - also just make it look good
209:56 - so that's all about aggregation and
210:00 - mapping functions and
210:03 - arithmetic operators
210:06 - and dates
210:13 - so let's talk about combining tables
210:16 - using joins
210:18 - a join Clause is used to combine rows
210:20 - from two or more tables based on a
210:23 - related column between them
210:28 - so here for example you have table one
210:30 - which has three columns and you have
210:32 - table two which also has three columns
210:34 - and one of the columns
210:36 - let's say this is some sort of a
210:39 - shared column so one of the columns has
210:43 - is related and has the same or similar
210:46 - set of values so table one has one two
210:48 - and table two has one three four
210:52 - so what you can do is you can combine
210:54 - the two tables
210:56 - such that you have this one column and
211:00 - then for this Row one and then these two
211:02 - values
211:04 - you also get the information from this
211:06 - table these two values and that creates
211:09 - like a one big row so you can think of
211:12 - this like the result of the join
211:15 - so for the
211:16 - column for the value 1 we get the
211:19 - information from table one and we get
211:21 - the information from table two
211:24 - for the
211:27 - row with
211:29 - the value 2 we get the information from
211:31 - table one
211:33 - here and there is no information in
211:35 - table two
211:37 - so now what happens here whether we put
211:39 - empty values or we don't show this row
211:41 - depends on the kind of join
211:44 - so if it is an outer join then we just
211:46 - show empty values here for these columns
211:48 - from table two
211:52 - and then here there are no more values
211:54 - left in table one so we go through table
211:56 - two we pick these values and we just
211:58 - show empty values here so we show empty
212:00 - values for three for table for these two
212:03 - columns from table one and for the
212:05 - columns from table two we show these
212:07 - values
212:09 - and finally we have four for which we
212:11 - again show empty values from table one
212:15 - and we show these two values here for
212:18 - table two okay so that's outer join and
212:21 - then we have inner join which picks just
212:24 - the intersection of the values and then
212:26 - we have the left join and right join so
212:28 - let's maybe look at some examples and
212:29 - this will become a lot clearer the first
212:31 - thing we'll talk about is the inner join
212:33 - and this is the default join in MySQL so
212:35 - whenever you type join whenever you're
212:37 - trying to join two tables on a certain
212:39 - column then by default it is going to be
212:43 - an inner join
212:45 - and let's see it in the context of a
212:47 - problem and it will make more sense
212:49 - show the 10 most recent payments with
212:52 - customer details so name and phone
212:54 - number
212:55 - okay so let's go select star from
212:59 - payments
213:02 - these are all the payments that have
213:04 - been made
213:05 - now the trouble here is that in this
213:07 - result we only have the customer number
213:10 - what we'd like to show is the customer
213:13 - details as well
213:15 - who is this customer number 471
213:19 - and we all look at the most recent
213:21 - payments so let me just grab the most
213:22 - recent payments
213:25 - ordered by payment date
213:29 - or maybe let's do that part at the end
213:31 - maybe first let's get the customer
213:33 - details so we have select star from
213:35 - payments
213:36 - and we want to show customer details
213:38 - name and phone number
213:40 - how do we do that I know that there is a
213:43 - customer number field in the customer's
213:45 - table as well so if I do select star
213:48 - from customers
213:50 - there is a customer number table
213:52 - there's a customer number field or
213:55 - column
213:56 - so what I really want to do is I want to
213:58 - fetch the information for customer
214:00 - number 471 from the customer table how
214:04 - do I do that I type select star from
214:06 - payments join
214:10 - customer number
214:13 - okay so what did we just do we said that
214:17 - I want to get some information from the
214:20 - customer number table as well but how do
214:22 - I decide which how do I decide which
214:25 - rows are connected well I want to use
214:27 - the customer number right so by default
214:29 - SQL doesn't guess SQL requires you to
214:32 - provide how you want to match up the
214:34 - rows of the two different tables so you
214:36 - say join on on which column you want to
214:39 - join and then you provide the column
214:42 - from this table and the column from this
214:45 - table so you say payments join customer
214:47 - number on
214:50 - payments dot so now because there are
214:52 - two tables involved so that's why you
214:54 - have to specify the the table name
214:56 - before you specify the column name
214:58 - so payments Dot customer number
215:03 - equals
215:06 - customers Dot customer number
215:12 - okay so let's just try and make sense of
215:15 - this and maybe let's put this on
215:17 - different lines
215:24 - so we are saying that I am not happy
215:27 - with the information that I have from
215:28 - the payments table I also want to get
215:30 - information from the customer table I
215:32 - want to augment some information here
215:34 - for the customer using the customer
215:36 - table
215:39 - and how do I want to augment that
215:40 - information
215:41 - I want SQL or my database server to look
215:45 - at the customer number field
215:50 - in the payment table here so for this
215:52 - row look at the customer number field
215:55 - and find the row
215:57 - in the customers table
215:59 - which has the same customer number
216:01 - so find the row which has the customer
216:03 - number 471
216:05 - get all the information from that row
216:08 - and add it to this row
216:11 - okay similarly we want
216:15 - the server to look at the second row and
216:18 - see that we have customer number 299
216:20 - here
216:21 - find the row in the customers table
216:25 - which has the customer number set to 299
216:27 - so because we're comparing the customer
216:29 - number columns
216:30 - get all the information from that row
216:33 - and add it here
216:35 - and let's run that
216:41 - okay did that lead to an error
216:59 - let me just check this
217:01 - um
217:09 - maybe I have a
217:12 - maybe I have a typo here somewhere but
217:14 - yeah
217:16 - sorry I think I had a typo there but
217:18 - yeah just repeat select star from
217:21 - payments join customers so you want to
217:24 - join payments with customers on the
217:26 - column customer number and now what SQL
217:29 - is doing is it looks at a row in
217:31 - payments it sees a customer number there
217:35 - and when it sees a customer number from
217:37 - the payments column it looks for
217:40 - a row within the customers table with
217:42 - the same customer number so this
217:43 - customer number comes from payments and
217:46 - this customer number comes from
217:47 - customers and then it takes all the
217:50 - information for that row and it adds it
217:52 - to this row
217:54 - so now we have not just the payment
217:55 - information but we also have the
217:58 - customer information attached with each
218:00 - payment
218:01 - so that is join
218:03 - okay now
218:05 - we probably don't want all the rows here
218:07 - so that's why we may want to just select
218:09 - some rows so I'm just going to select
218:10 - check number payment date amount
218:14 - um customer number customer name and the
218:16 - phone number
218:18 - so I just keep the check number payment
218:19 - date amount and I just want to keep one
218:22 - of these columns because these columns
218:24 - are a bit ambiguous they come from both
218:25 - so I'll just keep customers Dot customer
218:27 - number
218:28 - which I know is going to be equal to
218:31 - equal to payments.customer numbers and
218:34 - then I'm just going to keep the customer
218:36 - name and phone number
218:39 - okay so now we have check number payment
218:41 - date amount customer number customer
218:43 - name phone number
218:45 - and then we can Now cover the additional
218:47 - criteria
218:48 - which is we want to show just the 10
218:50 - most recent payments so we want to order
218:53 - by
218:54 - order by payment date
218:57 - descending
218:58 - and limit it to 10.
219:03 - okay so now we have just 10
219:07 - now we have just 10
219:09 - payments the 10 most recent payments and
219:12 - you can verify this that these are the
219:14 - most recent payments
219:15 - six zero nine six zero three five twenty
219:17 - five and so on
219:19 - and then we have the amount customer
219:20 - number customer name and the phone
219:22 - number okay
219:24 - now the key thing for you to understand
219:26 - here is the join how it is how it how it
219:29 - works it looks at payments looks at the
219:32 - value of customer number and it picks a
219:35 - row from customer number which matches
219:37 - it okay
219:39 - inner join what does that mean
219:42 - well
219:44 - there are several customers
219:47 - who may not have made
219:49 - a payment in the last 10 days or who may
219:51 - not have made a payment at all
219:53 - so if I remove this for a moment order
219:55 - by Etc
219:58 - there are several customers who may not
220:00 - have made any payments
220:01 - so I probably don't want to show the
220:04 - information for those customers who have
220:06 - not made any payments right now if I do
220:09 - this inner join here or if I do this
220:11 - normal
220:12 - this is the inner join I can also type
220:14 - inner
220:16 - then what I'm telling SQL is don't show
220:18 - me customers for which I don't have any
220:21 - payment information but if I change this
220:22 - to Outer join
220:24 - now we are telling SQL
220:35 - okay maybe it's like a full
220:38 - outer join
220:41 - or let me look up the syntax but if we
220:43 - change this to a outer join then we
220:45 - would get information for all the
220:47 - customers right so we would not only get
220:49 - information for customers who have made
220:51 - payments but we would also get
220:52 - information for customers who have not
220:54 - made payments and what is going to be
220:57 - present in the check number payment date
220:59 - and amount columns empty it's just going
221:01 - to be empty so just going back here if
221:04 - table 1 is payments and table 2 is
221:06 - customers then when you do an inner join
221:09 - we only look at those rows
221:12 - where these values are present in both
221:15 - the columns for for example if customer
221:17 - number one and two occur in payments and
221:19 - customer number one three and four occur
221:21 - in customers then we will only pick one
221:24 - because that's the common column and
221:26 - that's what happens when you do an inner
221:27 - join it just picks the common values on
221:30 - the other end if you do an outer join
221:32 - then we're going to pick we're going to
221:34 - have a row of row for customer one we're
221:36 - going to have a row for customer two
221:37 - these two are in payments and we are
221:39 - going to have a have a row for customer
221:41 - three and four which don't really show
221:43 - up in the customers column in the
221:45 - payments table at all so this is what
221:47 - it's going to be and there is just going
221:49 - to be empty data here okay then there is
221:53 - the left join and right join
221:55 - so we look at these in a second too okay
221:59 - but
222:00 - before we look at left right and outer
222:02 - joins here are a couple of exercises for
222:04 - you
222:05 - show the full office address and phone
222:07 - number for each employee so once again
222:09 - you can guess what this will look like
222:12 - you will say select star from employees
222:18 - and of course now you want the full
222:22 - office data so you have an office code
222:23 - here so you want to do join with offices
222:26 - on
222:28 - employees DOT office code equals
222:33 - offices DOT office code
222:36 - and maybe let's just put the employee
222:38 - number here
222:45 - let's just put employee number and let's
222:47 - put maybe the last name
222:50 - first name
222:52 - and
222:54 - offices Dot
222:57 - address
223:02 - let's just put City right now
223:03 - offices.city so now you have employee
223:06 - number last name first name let's maybe
223:08 - also put office code
223:10 - so offices DOT office code
223:16 - okay so now we have employee number last
223:19 - name first name office code city city
223:22 - San Francisco and then we also want to
223:24 - show the full phone number so office has
223:26 - a phone number so office has a phone
223:33 - let's check what that is Select
223:36 - star from
223:41 - so office has a phone
223:43 - um so we want to show the offices
223:44 - offices.phone information as well
223:47 - so now we have the phone and then every
223:49 - employee has an extension so we can get
223:52 - the
223:54 - EXT column from employee that is the
223:56 - extension
223:59 - let's just check that select star from
224:04 - employees
224:07 - yeah extension so every every employer
224:09 - has an extension
224:12 - so now we have employee number last name
224:14 - first name office code
224:16 - we have the phone number we have the
224:19 - office City
224:20 - and we have this extension we can
224:23 - combine these two so we can say concat
224:27 - let's get that here
224:30 - so we can say concat and we can
224:32 - concatenate the office phone with the
224:35 - extension so now we are concatenating
224:37 - one column from the offices table and
224:39 - one column from the employee table
224:42 - and put those together and let's just
224:44 - call that
224:46 - um
224:47 - employee phone number
224:50 - or employee phone
224:53 - okay so now we have the employee number
224:55 - last name first name office code
224:58 - and employee phone number maybe let's
225:00 - just put that here
225:10 - okay so now we have an employee number
225:12 - last name first name and then we have
225:14 - the employee phone number which is a
225:16 - combination of the phone number from
225:17 - office and the extension from the
225:19 - employee
225:21 - table and then we have the office code
225:23 - and office City and we've been able to
225:25 - do this because we've done a join
225:26 - between employees and offices
225:29 - okay
225:31 - and that's what this looks like
225:36 - here's another example
225:39 - show the full order information and
225:41 - product details for the order number one
225:44 - zero one double zero so here you would
225:46 - have to look up the order details common
225:48 - or the order details uh table and then
225:52 - from the order details table
225:54 - you would have to join it with the
225:56 - orders table to get information about
225:59 - orders and you would have to join it
226:00 - with the product table to get
226:02 - information about the product and then
226:04 - you would simply have to select the data
226:06 - for a specific order number so here you
226:08 - are doing two joins or you're joining
226:11 - three tables so I'll let you figure that
226:13 - out
226:15 - it's not too difficult it is just
226:18 - it is just one more step removed from
226:20 - what we've done
226:22 - so that's basic joins and specifically
226:24 - that's inner joins
226:26 - now let's talk about left joint right
226:29 - join and full joints unfortunately in
226:31 - this data set
226:33 - there's not enough of an opportunity to
226:35 - demonstrate all three
226:39 - so we're just going to look at some
226:41 - examples online
226:43 - and specifically I recommend W3 schools
226:45 - if you're just looking at some SQL
226:46 - syntax or need some help with SQL they
226:49 - have pretty good documentation on all of
226:51 - these
226:52 - so let's talk about left join okay so
226:54 - here's how left joint works I'll you can
226:56 - look at this table and try look at this
226:58 - picture and try to understand what's
226:59 - happening
227:00 - but we have a demo database here so we
227:02 - have this customers table
227:04 - and in the customers table we have a
227:06 - customer ID one two three and then we
227:08 - have a customer name contact name Etc
227:11 - you have an orders table so the
227:14 - customers table will be on the left
227:17 - the customer's table will be on the left
227:18 - and the orders table will be on the
227:20 - right
227:21 - and what we want to do is we want to
227:23 - join customers table with the orders
227:25 - table on the customer ID column
227:29 - so we say select customers Dot customer
227:32 - name
227:33 - comma orders dot order ID so we want to
227:36 - look at for each customer what are all
227:39 - the orders they've placed right so we
227:41 - want to see customer name and we want to
227:42 - see the order ID
227:44 - from the customers table
227:46 - left joined on orders
227:51 - on customers Dot customer ID equals
227:54 - order Dot customer ID so we want to just
227:56 - combine on the customer ID column and we
227:58 - want to order by
228:00 - the customer name so let's run this on
228:03 - you can actually run this online and
228:05 - check so here's our database we have
228:08 - three customers and then we have three
228:10 - orders
228:12 - of course
228:15 - and okay actually there's there's more
228:17 - than that there are a bunch of customers
228:18 - and a bunch of orders so let's just run
228:20 - this and let's see the result
228:23 - okay in our database we have 91
228:25 - customers and we have 518 orders and not
228:29 - every customer has placed an order so
228:31 - when we do a left join between customers
228:33 - and orders here's what we get
228:36 - we get a customer name and then we get
228:39 - the order ID
228:40 - so it turns out that Alfred
228:43 - F hasn't hasn't put hasn't created any
228:46 - order so that's why we have null here
228:48 - and similarly this person
228:51 - hasn't created any orders that's why we
228:53 - have a null here
228:55 - so for every customer and every order we
228:57 - could find for every customer and Order
228:59 - combination we could find where the
229:02 - orders customer ID matched with the
229:04 - customers customer ID we have created a
229:06 - row
229:07 - and because this is a left join wherever
229:11 - there were certain customers for whom
229:13 - there were no orders
229:14 - there is still a single row that has
229:16 - been kept
229:18 - so Alfred has not ordered but we still
229:20 - have this null here
229:22 - now if we did not have this left join if
229:24 - we just had join here and let's run that
229:27 - you would see that now you no longer
229:29 - have those null columns so now you no
229:31 - longer have a customer name so if a
229:34 - customer does not have a matching order
229:36 - so if a customer column customer row
229:38 - does not have a matching order row then
229:40 - that will be skipped if you're doing a
229:42 - left join you are telling SQL that you
229:45 - want to keep all the rows from the left
229:49 - table which is the customers table and
229:52 - you don't care about all the rows from
229:53 - the order table but you do care about
229:55 - all the rows from the customers table so
229:57 - even if there is no matching Row from
229:59 - the orders table just show that customer
230:01 - name
230:02 - and then show a null there
230:05 - okay
230:06 - so that's left join
230:09 - then maybe let's look at right join
230:12 - so here's an example of right join here
230:15 - we have
230:17 - orders so we have one table of orders
230:20 - and then we have one table of employees
230:22 - okay now
230:25 - for every order that is placed by a
230:27 - customer there is also an employee that
230:29 - is assigned and then we have a table
230:30 - where we have details of employees
230:33 - so let's say we want to get for each
230:36 - order
230:37 - the names of employees
230:39 - who is assigned to that order
230:42 - and let's check it out
230:44 - so this time we are saying select orders
230:46 - dot order ID and employee last name
230:49 - employee first name from orders
230:52 - and we're saying right join with
230:54 - employees
230:55 - so let's run that and let's see what
230:57 - what happens we are matching on the
230:59 - employee ID column so we get the order
231:01 - right we get the order ID
231:04 - and we are also keeping the employee
231:07 - last name and first name so we for every
231:09 - order ID we get the last name and first
231:12 - name of an employee but of course there
231:14 - are certain employees who may not have
231:16 - been assigned any orders maybe certain
231:18 - employees just don't deal with orders
231:20 - they are into their managed people
231:23 - because we have done a right join we are
231:26 - telling SQL that
231:27 - you don't want to miss any rows from the
231:30 - right table from the employees table so
231:32 - you want to show employees even if they
231:34 - do not have any matching order columns
231:36 - so now west Adam West does not have any
231:40 - orders but we're still showing it here
231:41 - we're just showing a empty or null value
231:44 - here instead of course if we did not
231:46 - have
231:47 - joint right join here
231:49 - then you can see
231:59 - okay let's just do an inner join here
232:04 - yeah if we just did an inner join which
232:07 - means we did not do a right join if we
232:08 - just did an inner join here then
232:12 - we would only get those employee names
232:15 - who have valid orders right so just try
232:18 - to remember this picture where inner
232:20 - join means that the row must that that
232:22 - value must exist in both columns in both
232:25 - tables left join means that all the
232:27 - values that exist in the left table show
232:30 - up right join means all the values that
232:32 - exist in the right table show up an
232:35 - outer join
232:36 - a full outer join tells you that you
232:39 - want to maintain all the rows from the
232:41 - left left table you want to maintain all
232:43 - the rows from the right table as well
232:44 - and you want to fill in nulls wherever
232:46 - possible so here's an example
232:49 - we have a customer's table and then we
232:51 - have an orders table
232:52 - and
232:54 - I believe we are doing a full outer join
232:56 - on customers and
233:00 - orders and this time you will see that
233:02 - there are certain
233:04 - order ID table certain order IDs that
233:06 - may be null and sometimes a certain
233:08 - customer name may be null right so
233:10 - that's how an outer join works so just
233:12 - keep this picture in mind
233:14 - this one
233:16 - outer join means you want to retain all
233:18 - the values inner join means you want to
233:20 - retain just the intersection of the
233:21 - common values left join means you want
233:24 - to retain all the values from the left
233:25 - table right join means you want to
233:27 - retain all the values from the right
233:28 - table
233:29 - okay
233:30 - and one last thing a table can also be
233:34 - joined with itself you don't have to do
233:36 - a join between multiple tables and each
233:39 - instance of the table can be given a
233:41 - temporary Alias so you need to rename
233:43 - those tables because otherwise if you're
233:45 - just joining a table with itself it may
233:47 - get confusing when you are explaining
233:49 - which columns to join on so here's an
233:51 - example remember employees employees
233:54 - have this reports to
233:56 - field which reflect refers to another
233:58 - employee so let's say we want to show a
234:01 - list of employees with the name and
234:03 - employee number of their manager
234:06 - so let's do select star from
234:10 - employees
234:12 - okay so now we have all this information
234:15 - we have employee number
234:17 - employee last name employee first name
234:19 - and then a bunch of information and then
234:21 - we have this thing called reports too so
234:23 - every employee on most employees except
234:26 - the president I believe most employees
234:27 - report to another employee
234:30 - so now if you want to show who they
234:33 - report to we want to get information
234:34 - about who the report to what do we do
234:36 - well first let me just simplify this
234:38 - output a little bit let me just put in
234:40 - employee number
234:42 - and let me put in last name
234:45 - and first name
234:48 - and reports to so that we just have this
234:51 - information that we really need
234:55 - okay now I want to take the reports to
234:59 - number and get information from the
235:02 - employee table
235:04 - and insert that information here as new
235:06 - rows so we say from employees join
235:10 - employees
235:14 - but of course and this is an inner joint
235:16 - of course by default
235:18 - so first Let's do an inner join and then
235:20 - we'll see if this needs to be a
235:22 - different joint
235:23 - so we say employees join employees and
235:26 - now this can get confusing because your
235:28 - both of these are called employees so
235:29 - let's call up call one of these e so you
235:32 - just give a space and then type a
235:34 - temporary name you don't put as here you
235:37 - just put a space
235:38 - and
235:39 - let's call this m so E4 employees and M4
235:43 - manager
235:45 - okay so now we are joining and how are
235:47 - we joining we want to join now this gets
235:51 - interesting here from E from the first
235:53 - from the left table we want to look at
235:55 - reports to
235:57 - and from the right table M we want to
236:00 - locate the employee number
236:08 - so from the employees table we want to
236:11 - take the reports to information and we
236:13 - want to find
236:16 - the corresponding column where the
236:19 - employee number matches this reports to
236:22 - a number okay
236:23 - so think of employees and managers as
236:25 - different tables they are the same table
236:28 - but think of them conceptually as
236:29 - different tables we capture this number
236:31 - and we get that information from the M
236:35 - table so that's why we have reports to
236:37 - equals employee number and let's
236:39 - grab some information here from the
236:42 - other side as well so from m
236:44 - let's grab the first name
236:48 - and let's just call that
236:50 - manager first name
236:54 - and from M let us grab the last name as
236:57 - well
237:01 - m dot last name
237:02 - and let's call that manager last name
237:08 - and from M let's also grab the
237:11 - employee number
237:14 - well actually we have that already we
237:16 - have reports too
237:18 - so that's that
237:33 - there we go
237:37 - so we have select employee number first
237:39 - name reports to
237:41 - and we want to select
237:44 - okay now reports to let's just put in E
237:46 - dot because this is going to get
237:47 - confusing otherwise or SQL and we want
237:50 - to select m dot first name
237:51 - and we want to select m dot last name as
237:54 - manager last name
237:56 - from the employees table I think I may
237:59 - have a typo here let me just grab this
238:09 - okay I think I may have a typo here so
238:11 - I'm just going to
238:12 - fix this right now
238:14 - but yeah so we have e dot employee
238:17 - number and we have e DOT first name and
238:20 - we have I see what the issue is because
238:23 - we have
238:24 - all these columns in each of the tables
238:27 - so we just need to add e Dot
238:30 - so we say
238:32 - we have an employees table joined with
238:33 - the employees table one is called E1 is
238:35 - called M so we have e dot employee
238:37 - number e dot last name e DOT first name
238:40 - reports to
238:41 - m dot first name m dot last name
238:46 - from employees join employees
238:49 - on the reports to column joined with the
238:51 - employee number column okay
238:53 - so this is probably the most confusing
238:55 - part of it all so now for every single
238:57 - employee
238:59 - who has a manager because this is an
239:00 - inner join remember so for every single
239:03 - employee who has a manager we get their
239:05 - employee we get their manager
239:06 - information as well so we get the name
239:08 - and last name of their manager maybe we
239:11 - can concatenate this so let's maybe just
239:13 - do
239:14 - concat m dot first name and m dot last
239:19 - name
239:20 - as manager name
239:26 - so now we have this information about
239:29 - each employee they we have their last
239:32 - name first name employee number and then
239:34 - we have the employee number they report
239:35 - to and we have the name of the their
239:38 - manager let's just add a space here as
239:40 - well
239:41 - okay now one last thing here that we
239:44 - would want to just cover is there is a
239:48 - certain employee the president who does
239:50 - not report to anyone and we have not
239:52 - shown that information here because
239:56 - we are doing an inner join so because
239:58 - the president Diane Murphy does not
240:01 - report to anybody
240:04 - so that row gets skipped but instead if
240:07 - we do a right sorry if we do a left join
240:10 - what we're telling SQL is we want to
240:12 - maintain the list of all the employees
240:15 - from the left table e
240:18 - even if they do not have a person that
240:20 - they report to
240:22 - so now if you check you have an employee
240:24 - number one zero zero two Murphy Diane
240:27 - and for them reports to his null and of
240:30 - course null value doesn't show up in the
240:32 - other table so their manager name is
240:34 - also null
240:36 - okay so now you see that this is
240:37 - supposed to be a left join and why this
240:40 - is supposed to be a left turn left join
240:42 - and not an inner joint because you want
240:43 - to show all the employee numbers even if
240:45 - they don't have a manager
240:47 - now suppose instead of a left join you
240:50 - had done a right join what would happen
240:52 - now
240:53 - so now we're telling SQL that
240:56 - only show me employees from the left
240:58 - table who have a manager
241:00 - but on the other side on the right side
241:03 - if there are certain employees
241:10 - in the M table which do not feature in
241:13 - the reports to column you should still
241:15 - show them so let me run that and let me
241:17 - show you the result so it seems like the
241:19 - result hasn't changed so one thing that
241:21 - has happened is Diane Murphy has gone
241:23 - away but if I scroll down here you will
241:25 - see that now I have Leslie Jennings
241:28 - Leslie Thompson Julie farrelli all these
241:30 - people who do not have any reportees
241:32 - still show up
241:34 - this is because we are doing a right
241:35 - join we are saying that every Row from
241:37 - the M table should be represented even
241:40 - if they don't have any matching
241:42 - information in the e-table so that's the
241:44 - that's the issue with the right join and
241:46 - if we did a full outer join
241:50 - or I think it's just called an outer
241:52 - join
241:56 - okay I'm not sure what the
241:59 - outer join in MySQL is
242:05 - I guess it's just called full outer join
242:15 - okay I think I'll have to look it up but
242:17 - if we did the full outer join then we
242:19 - would see
242:22 - this we would see Diane Murphy
242:26 - and we would also see
242:28 - all this information
242:31 - Larry bolt Etc
242:39 - okay we'll check this out what how do
242:42 - you create a outer join in MySQL
242:51 - okay never mind
242:55 - so that's joins and here are some
242:58 - exercises for you to try out to become
243:00 - familiar with SQL joins report the
243:02 - account representative for each customer
243:06 - report the total payments for the
243:08 - Atelier graphic
243:10 - this is one of the I think this is one
243:12 - of the customers report the total
243:14 - payments by date report the products
243:16 - that have not been sold ever list the
243:19 - amount paid by each customer and so on
243:21 - so each of these will require a certain
243:23 - join not all of them may require joins
243:25 - and for some of these it's possible that
243:27 - you can do them without joins in some
243:30 - cases you will also have to do some
243:32 - other things like arithmetic operations
243:34 - etc for example list the names of
243:36 - products sold at less than 80 percent of
243:38 - the MSRP
243:46 - there are two ways to improve query
243:47 - performance in MySQL especially when
243:49 - you're working with really large data
243:52 - sets one is to create an index now if
243:55 - you often search or order data by a
243:57 - particular column that's not a primary
243:59 - key then you can add an index to make
244:02 - the query performance faster
244:04 - for example if you search by customers
244:07 - last name a lot or if you order by
244:09 - customers last name or not then you
244:11 - should do this you should run this
244:13 - command create index customer last name
244:15 - and give it whatever name you want so
244:17 - you say create index so and so on the
244:20 - table customers using the column contact
244:22 - last name so if we do this if we just
244:26 - run create index customer last name
244:28 - index on customers
244:30 - what we're telling SQL is that we want
244:32 - SQL to
244:34 - track the contact last name information
244:37 - the contact last name column in the
244:40 - customers table and set up a way for us
244:44 - to efficiently do queries on that column
244:47 - so what does this mean well the next
244:49 - time we do a query on the last name
244:51 - let's say we do something like this
244:54 - select star from customers where contact
244:56 - last name equals Lee because contact
244:59 - last name has an index this query will
245:01 - be very fast
245:02 - if the contact last name did not have an
245:04 - index then this query would be fairly
245:07 - slow and the difference would be if the
245:10 - contact class name did not have an index
245:11 - then
245:12 - SQL would have to search through all the
245:14 - rows but
245:16 - if the contact last name does have an
245:18 - index then SQL can actually
245:20 - avoid searching because it has set up
245:22 - some ways to
245:24 - efficiently track information and search
245:27 - information from the contact last name
245:29 - column in fact it is using a data
245:31 - structure called a b tree and you can
245:34 - see what kind of index is created or
245:36 - what kind of indexes you have on a table
245:37 - simply by typing show index from
245:41 - table name
245:43 - so you can see that we have the primary
245:45 - key which is tracked using an index
245:47 - because typically you extract
245:49 - information using fine primary key
245:51 - we have a foreign key so every foreign
245:54 - key also creates an index but then we
245:56 - also have this customer last name index
245:58 - which we just just created
246:00 - and this index is represented as a b
246:03 - tree which is a data structure an
246:05 - efficient data structure
246:07 - optimized for querying so whenever you
246:09 - query by last name that is very
246:11 - efficient
246:12 - not only querying but ordering by last
246:14 - name is also efficient so you could do
246:15 - something like this select start from
246:17 - customers order by contact last name
246:19 - limit 10. again if you have an index
246:22 - this is going to be fairly efficient
246:25 - if you don't have an index it's going to
246:26 - be slow it's not going to make a
246:28 - difference for this database the that we
246:30 - are working with right now but when you
246:32 - have a really large data set a really
246:34 - large database with millions of rows
246:37 - then this will start to make more sense
246:39 - so if you are doing some queries and
246:42 - those queries seem to be taking a long
246:43 - time maybe consider creating an index or
246:46 - maybe consider asking the database
246:48 - administrator to create indexes on the
246:51 - columns that you are ordering by or
246:52 - searching by most frequently
246:55 - okay
246:56 - and indexes can also be created on
246:58 - multiple columns if you put conditions
246:59 - on multiple columns frequently so you
247:01 - can check that out
247:03 - then another thing that you can do is
247:05 - create something called a view so if you
247:07 - perform a query
247:09 - or if you perform a query very often or
247:12 - if you very frequently join tables for
247:13 - querying
247:15 - then you can create a virtual table out
247:18 - of that query and this virtual table is
247:21 - called a view so here is how a view is
247:23 - created so we'll see how views created
247:25 - and how it's used and then you probably
247:27 - see more learn more about how it works
247:31 - so to create a view you say create view
247:33 - USA customers as
247:37 - you type the name of the view and you
247:39 - type as and then you type a query like
247:41 - you normally do so instead of doing
247:44 - select star from customers where country
247:46 - equals USA so this is all this is the
247:49 - information about all the American
247:50 - customers
247:52 - what we want to do is we want to take
247:53 - this query and we want to give it a name
247:57 - USA customers
248:00 - so let's say let's say create view USA
248:03 - customers and that is now going to
248:05 - represent this query the word USA
248:07 - customers
248:08 - how do we use it we use it just like a
248:10 - normal table now let's say we want to
248:12 - get just the customers who are in
248:15 - California
248:17 - so we can do this select star from USA
248:20 - customers so now we refer to this view
248:21 - which we have created
248:23 - already it's saved in the in the
248:26 - database that view
248:27 - so select start from USA customers
248:30 - customers who are from the USA where
248:32 - State equals CA
248:35 - and when we run this
248:37 - you can now see that we only have
248:39 - customers from USA of course that's
248:41 - because this the state is CA but you can
248:45 - see that USA customers actually used
248:48 - information
248:49 - from this query that we had defined
248:51 - earlier okay so conceptually what's
248:53 - happening is wherever
248:56 - the SQL Server sees USA customers it's
249:00 - simply going to replace this
249:02 - with this select start from customers
249:04 - where country equals USA
249:08 - and in fact you can also run this okay
249:11 - this is not going to work directly
249:13 - but yeah uni once you create a view and
249:19 - use the view so SQL is going to replace
249:22 - the view name with the actual query that
249:24 - you have provided
249:30 - now typically when you create a view no
249:33 - new data gets created it's simply that
249:35 - information that is tracked which
249:37 - queryer viewed
249:39 - represents but certain relational
249:41 - databases also support creation of
249:43 - materialized views so let's say you're
249:46 - doing joins between certain tables very
249:48 - often and then you are getting
249:49 - information about the from that joined
249:51 - table from that joined uh
249:54 - query
249:56 - then you can create a materialized view
249:58 - which is going to contain the joined
250:00 - version of the two tables so that
250:02 - whenever any of those two tables is
250:04 - updated the view gets recreated and that
250:07 - is uh like a separate table that is
250:09 - always tracking the latest version of
250:12 - the joins of the two tables and that
250:15 - takes up more space but that makes it
250:17 - very efficient to query so now whenever
250:20 - you make queries on that view instead of
250:22 - re-running the query that creates the
250:24 - view it it will have the view already as
250:27 - a table saved within the database
250:29 - and all that information will be cached
250:31 - so you can get that you can get the
250:33 - result out of the view very easily okay
250:35 - so right now by default
250:38 - we are not actually creating a table USA
250:40 - customers but if you make this a
250:42 - materialized view then
250:45 - the database is actually going to set up
250:46 - this
250:47 - table
250:49 - call USA customers somewhere and that is
250:52 - going to be kept up to date with the
250:54 - list of customers from the USA okay so
250:57 - that's materialized views not something
250:59 - you'll have to worry about or work with
251:00 - often but in case you come across the
251:02 - term that's what it means
251:05 - let's talk about executing SQL queries
251:08 - using python
251:12 - one way we've seen how to execute SQL
251:14 - queries is using
251:16 - the MySQL command line interface another
251:19 - way we've seen how to execute SQL
251:21 - queries is using the MySQL workbench and
251:25 - the Common Thread here is all you need
251:28 - is to connect to your SQL Server your
251:31 - database server that could be running
251:32 - locally that could be running on the
251:34 - cloud
251:35 - and once you have connected to that
251:37 - server you need to be able to send
251:40 - instructions to the server the queries
251:42 - that you wanted
251:43 - that you want to send that you want to
251:46 - perform and then the database server is
251:47 - going to give you back the results and
251:49 - you should be able to understand the
251:51 - results
251:53 - so this is something that you can do
251:54 - from any language every language has
251:57 - some libraries for working with SQL
251:59 - relational databases in Python one of
252:02 - the most popular libraries is the SQL
252:04 - Alchemy Library
252:06 - so you can look it up this is
252:09 - SQL Alchemy or SQL Alchemy and it's a
252:12 - very powerful toolkit for python that
252:15 - pretty much everybody who uses SQL
252:18 - databases and does some programming in
252:20 - Python
252:21 - uses this library in fact we use it on
252:23 - Jovian when
252:25 - you open your profile page
252:28 - to get the information for your profile
252:31 - we use the SQL Alchemy library to get
252:34 - information out of a mySQL database and
252:37 - then we display that information to you
252:40 - on the profile page
252:43 - okay so it's a very powerful and a very
252:45 - efficient Library as well it's as it
252:48 - says here
252:49 - it provides Enterprise level persistent
252:52 - patterns designed for efficient and high
252:54 - performing database access adapted into
252:56 - a simple pythonic domain language okay
253:02 - so that's the library we are going to
253:03 - use
253:07 - now here's the other thing
253:09 - there is not just a single relational
253:12 - database there are many in fact here are
253:15 - some so MySQL is one that we've looked
253:17 - at
253:18 - apart from that there is something
253:19 - called postgres
253:22 - so this is sort of a
253:25 - slightly more advanced version of MySQL
253:27 - where it also supports
253:29 - latitudes and longitudes is also
253:31 - supports like a Json column type it has
253:33 - more column types
253:35 - um then there is something called sqlite
253:40 - so sqlite is a less is a limited version
253:44 - of MySQL and sqlite is typically used
253:47 - for situations where you can possibly
253:49 - you possibly cannot set up a entire
253:51 - server and you just have to maybe work
253:54 - with something very light so sqlite
253:57 - instead of setting up a proper database
253:59 - server Etc simply uses a file on the
254:01 - disk and that file just works as a
254:04 - database of course everybody uses a disk
254:07 - but sqlite just makes it very efficient
254:10 - and very fast and very small so
254:12 - typically this is used in let's say in
254:15 - in your phones so any Android app or any
254:18 - IOS app that you use is if it stores any
254:22 - information on your device typically
254:23 - that store that information will be
254:25 - stored in a sqlite
254:27 - database because it has very low memory
254:30 - and CPU requirements of course
254:33 - it is it does not implement the entire
254:36 - SQL language it only implements parts of
254:40 - it and
254:42 - it sort of cuts Corners here and there
254:44 - to make it possible to use SQL in a very
254:46 - a low memory setting
254:49 - in fact in your in your assignment you
254:53 - will be using sqlite
254:55 - so that that is something that can run
254:57 - easily on binder setting up MySQL and
254:59 - binder is a big challenge so we're just
255:02 - going to use sqlite apart from that you
255:04 - have some
255:06 - proprietary databases like Oracle so
255:09 - Oracle has its own database again that
255:12 - has its own flavor of SQL then you have
255:14 - the Microsoft SQL Server
255:17 - so that has again its own version of SQL
255:20 - there are some changes not all the
255:22 - commands work work exactly the same way
255:23 - and in fact if you look up any SQL
255:26 - tutorial they will tell you what the
255:28 - differences between the different
255:29 - flavors of SQL are right for example
255:32 - w3schools is the one that I would
255:36 - recommend and here on the side you can
255:38 - see all the possible different
255:41 - um things that you do that you can do
255:42 - with SQL and if you open any specific
255:47 - example here like alter table you will
255:50 - see how these are different across
255:52 - different
255:53 - SQL databases so alter table which is to
255:56 - change the column name Etc this is how
255:59 - it works on SQL Server this is how it
256:00 - works on MySQL this is how it works on
256:03 - Oracle in this case I think they look
256:06 - the same there's no change here but
256:07 - there are other things probably with
256:09 - constraints where
256:10 - things would be different yeah so you
256:13 - see here this is how it works with SQL
256:15 - Server this is how it works with mySQL
256:17 - so if you're putting some sort of a
256:19 - unique constraint in SQL Server you put
256:22 - it here in MySQL you put it at the end
256:24 - and so on
256:25 - so just look things up don't worry about
256:28 - knowing all the different variants of
256:30 - SQL
256:31 - but the way it is relevant for us here
256:33 - is SQL Alchemy
256:35 - does not include all of these connectors
256:38 - to all of the different types of
256:40 - relational databases so what you'll have
256:42 - to do is maybe you'll have to use some
256:44 - kind of a connector a connecting Library
256:45 - so for example if you are connecting to
256:48 - mySQL then MySQL python is a commonly
256:52 - used
256:53 - connector so you will have to either use
256:55 - MySQL python or there's another
256:57 - connector called Pi MySQL so there are
257:00 - several connectors for MySQL right so
257:02 - SQL Alchemy gives us the python
257:05 - interface for writing SQL queries and
257:08 - then internally it uses one of these
257:10 - libraries to connect to the specific
257:12 - kind of database that you want to work
257:13 - with so you'll need to install both so
257:15 - now we are going to install SQL Alchemy
257:17 - and we are going to install Pi MySQL
257:20 - so let's install both of them
257:23 - SQL Alchemy handles the python Side by
257:25 - MySQL handles the MySQL side
257:29 - and I'm just going to create clear
257:31 - output here
257:34 - and let's import so here's how you
257:36 - connect to a SQL database the first
257:38 - thing you do is you say from SQL Alchemy
257:40 - import create engine
257:42 - so import create engine and create
257:45 - engine takes a
257:47 - string a connection string
257:50 - so what you do is you say create engine
257:52 - and then you give it this string this
257:55 - database connection string which
257:57 - contains all the information required to
257:59 - connect to the database now remember
258:01 - MySQL workbench here when we try to
258:05 - connect to a new database we would have
258:07 - to provide a hostname we would have to
258:09 - provide a port we would have to provide
258:11 - a username and a password so it works
258:13 - exactly the same way here
258:15 - we say uh what kind of database we want
258:18 - to connect to so we want to connect to a
258:20 - mySQL database so that's why we have
258:21 - MySQL here
258:23 - we say what connector we are using now
258:25 - even for MySQL there are several
258:27 - connectors that people have written for
258:29 - SQL Alchemy so we we are using the pi
258:33 - MySQL connector if we were using the
258:35 - MySQL python connector then this value
258:37 - would be different but in any case we
258:40 - want to use the mySQL database so this
258:42 - is the kind of database that we are
258:43 - using plus this is the kind of connector
258:47 - we are using pi my SQL
258:49 - then we say colon dot dot and this is
258:51 - just a standard syntax then we provide
258:53 - the username
258:55 - and after the username you provide the
258:57 - password so
258:59 - normally you shouldn't type passwords
259:00 - out but let's say if you wanted to
259:02 - provide the password directly you would
259:03 - say
259:04 - username colon password
259:07 - then you Pro then you type at
259:10 - and then you type the server so the host
259:13 - name that you put here
259:15 - 127.0.0.1 which means the local computer
259:18 - this is just short for the local
259:20 - computer is a standard host name
259:24 - um and that is also known as localhost
259:26 - so this could be 127.001. this could be
259:29 - localhost both of those mean connect to
259:31 - a database on this computer
259:33 - but if you are connecting to a database
259:35 - somewhere on the cloud then you should
259:37 - get the username and the password
259:40 - and the host name for that cloud
259:43 - database
259:45 - next you provide the port so for every
259:47 - database there are certain Port that you
259:49 - connect at 3306 is the default Port that
259:52 - is used in most databases but if there
259:55 - is a different port then you can ask
259:56 - your database admin to give you the port
259:59 - so once again you get the type of
260:01 - database that you're connecting to the
260:02 - type of connector you're using colon
260:04 - slash slash the username password at
260:07 - localhost colon the port slash
260:11 - the name of the database that you're
260:12 - connecting to okay this is not something
260:15 - you have to remember you can always just
260:16 - look up
260:17 - SQL Alchemy
260:20 - connection string
260:23 - and let's say you want to look it up for
260:25 - SQL Server so you can just search
260:26 - connection string for SQL Server
260:28 - and you can see what that connection
260:31 - string will look like so for SQL Server
260:33 - this is what it will look like my seek
260:35 - Ms SQL plus pyo DBC so the pyo DBC is
260:38 - the connector and then username password
260:40 - add server
260:41 - so server would be localhost colon 3306
260:44 - or some other online server slash
260:46 - database okay
260:48 - now one thing I've done here is instead
260:50 - of putting the password
260:52 - I want I don't want to type my password
260:53 - into a jupyter notebook
260:55 - so I have just imported get pass and I'm
260:59 - going to run get pass I'm going to type
261:01 - the password Here
261:03 - so now the variable password contains
261:06 - the value of the password that I just
261:08 - typed in but I'm not going to display it
261:10 - in front of you because I don't want you
261:12 - to show you I don't want to show you I
261:14 - don't want you to see my password
261:17 - so
261:19 - what I'm then going to do is use string
261:22 - formatting to insert the password
261:25 - into this string so now I have the
261:27 - connection string inside which I have
261:29 - this Gap using these quotations using
261:32 - these brackets and then I'm calling dot
261:34 - format password and that's going to put
261:36 - the password into that Gap okay
261:39 - so never put your password directly into
261:41 - your jupyter notebook especially at work
261:44 - because that's going to be very bad
261:46 - because then anybody who has your
261:48 - jupyter notebook will be able to use
261:49 - your account always use get pass so just
261:52 - put the password into a variable and
261:55 - then
261:56 - pass that variable using string
261:59 - formatting into the
262:02 - connection string and that then creates
262:05 - this engine
262:06 - okay so now we've created this engine so
262:09 - what has happened so far nothing really
262:10 - it we've just set up this object and
262:12 - we've given all this information to SQL
262:15 - Alchemy then we actually connect to the
262:18 - engine we say with engine.connect as con
262:21 - c-o-n-n
262:24 - and then we can execute SQL queries
262:28 - okay so we connect to the engine as con
262:31 - and why do we have this width well this
262:33 - automatically takes care of closing the
262:35 - connection once we get the result so we
262:37 - say c o n n dot execute and now I'm
262:41 - connecting to my local database so make
262:42 - sure that if you are running this on
262:44 - your computer you have the SQL Server
262:46 - MySQL server running and if you're
262:49 - running this on binder obviously it's
262:50 - not going to be able to connect to your
262:52 - local computer so make sure that you're
262:54 - running this locally on your computer
262:56 - okay so now we say connection dot
262:59 - execute and we have a query so we have
263:01 - select office code comma City comma
263:04 - phone from offices so let's see what
263:06 - this query gives us in the SQL workbench
263:15 - okay maybe first I should do use
263:19 - database
263:22 - classic models
263:24 - or just use classic models
263:28 - yep and now I can select office code
263:31 - city phone number so expect to see
263:32 - information like this seven office codes
263:34 - and then the city and phone number
263:38 - so I get the result from con.execute and
263:41 - let's look at the result the result is
263:44 - this Legacy cursor result it doesn't
263:47 - give me much but you can convert that
263:50 - result into a list
263:52 - so you just call list on it and that
263:54 - gives you this list of offices or list
263:56 - of results and let's check that so here
263:58 - now you get one San Francisco plus one
264:01 - six five zero two one nine to Boston
264:04 - plus one two one five and you can match
264:06 - that information up here okay
264:08 - so quick recap
264:10 - install SQL Alchemy install the
264:13 - connector import create engine
264:16 - then create the engine using this
264:18 - connection string which contains
264:20 - information about the kind of server the
264:23 - kind of database you're using the kind
264:24 - of connector you're using the username
264:26 - password
264:28 - hostname and port and database name
264:31 - of course don't type your password
264:34 - directly get it using get pass once the
264:37 - engine is created
264:38 - connect
264:40 - like this and then get the result
264:43 - and now you have this result here so now
264:46 - once you have this result this is a
264:48 - python list and it's a list of tuples
264:51 - the idea I wanted to take away is that
264:53 - you can create this engine create a
264:55 - connection and then get data out of a
264:57 - SQL database using python now of course
265:00 - this is a lot of work and that is where
265:04 - you have this nice neat little Library
265:06 - called IPython SQL probably one of the
265:09 - most wonderful libraries I've come
265:11 - across because it takes away so much of
265:14 - the complexity that you have to take
265:16 - care of when you're connecting to SQL
265:17 - databases
265:20 - so the IPython SQL Library provides
265:22 - something called Magic commands to write
265:24 - raw SQL queries in Jupiter so you just
265:26 - type raw see you just type a SQL query
265:29 - within Jupiter and that will execute and
265:33 - that will get you the results and it'll
265:35 - give you the results in a nice tabular
265:36 - format something that you can use within
265:39 - Python and in fact it uses SQL Alchemy
265:42 - under the hood so you want to have SQL
265:44 - Alchemy installed and you want to have
265:46 - the right connector installed so for
265:48 - example in this case I'm using pi MySQL
265:50 - so I have SQL Alchemy installed I have
265:52 - Pi MySQL installed and now I'm going to
265:55 - install IPython SQL so install the
265:58 - IPython SQL Library
266:00 - and now it really is Magic because and
266:03 - these are called Magic commands the
266:05 - first thing you do is you have to load
266:06 - this extension within the jupyter
266:08 - notebook so you say load EXT so you type
266:11 - this percentage symbol you type load EXT
266:13 - and then the extension that we're
266:15 - loading in is called SQL
266:17 - and once you type this once you run this
266:19 - cell low dxt SQL then
266:22 - you will be able to start using this new
266:25 - command called SQL so anything that
266:27 - starts with a percentage is called a
266:29 - magic command in Jupiter this is no
266:31 - longer plain python now this is some
266:33 - instruction that we are sending to
266:35 - Jupiter
266:36 - so here's what you can do you can type
266:38 - percentage SQL
266:41 - okay and then you give it a connection
266:43 - string so for example if you give it
266:45 - MySQL Plus
266:47 - Pi my SQL
266:51 - root colon and then you put in the
266:54 - password here let's say the password is
266:56 - just password
266:58 - at localhost
266:59 - colon 3306 and slash classic models
267:04 - okay
267:05 - and I'm just going to reveal my password
267:07 - here for a second so I'm just going to
267:09 - the password is well it's akash123 so if
267:13 - I run this
267:18 - classic models yeah
267:21 - so if I run this now I am connected to
267:23 - the
267:24 - now I'm connected to them to the
267:26 - database right I have just typed MySQL
267:28 - plus pi my SQL colon root so username
267:31 - slash password so this is a SQL Alchemy
267:34 - collection string now instead of having
267:36 - to do import engine create engine etc
267:38 - etc I can just type colon SQL give it
267:41 - the connection string
267:42 - and that is just going to connect to the
267:44 - to the database now what to do if I
267:47 - don't want to reveal my password I would
267:49 - do from a get pass import get pass
267:54 - and then I would run get pass
267:57 - and okay maybe I should
268:01 - put the result into password
268:04 - okay and then I type my password
268:09 - so now this variable password has my
268:12 - password and then I can take this and
268:13 - just put it into a string so I create a
268:16 - normal
268:19 - connections Str I create a normal python
268:22 - variable and I just insert the password
268:25 - here so I do dot format
268:30 - password
268:32 - and now I've created this connection
268:34 - string so now I want to instead of
268:36 - typing out the full connection string I
268:38 - want to pass the variable connection
268:40 - string and we do that by in Magic
268:43 - commands we pass value from variables
268:45 - using these
268:47 - brackets
268:50 - okay so when we type this when when we
268:53 - have when Jupiter sees this bracket it
268:56 - says okay
268:57 - let me take the value of connection Str
269:00 - which is all of this with the password
269:03 - replaced here and let me replace this
269:05 - with that value uh sorry with with all
269:08 - of this stuff
269:10 - okay so this is all a roundabout way of
269:13 - hiding my password but in any case the
269:16 - the point being
269:17 - you just provide the connection string
269:19 - either you type out the entire string
269:21 - including your password or you put the
269:22 - connection string into a variable and
269:24 - you pass it using this bracket but just
269:28 - with this one line of code we are now
269:29 - connected to the database
269:31 - and we can now execute queries and
269:34 - here's how you execute queries you type
269:36 - percentage SQL and then you just type
269:38 - the query like select office code city
269:40 - phone from offices
269:43 - so there you go so now you can see that
269:45 - it's telling me that I'm connected
269:47 - on using this connection root and it
269:51 - hides a password thankfully so yeah so
269:54 - we've typed this query and here is the
269:56 - result of the query so the result is
269:58 - office code city phone one two three
270:00 - four five six seven San Francisco Boston
270:02 - Etc and the phone numbers
270:04 - if you have a multi-line query something
270:07 - that you need to split across multiple
270:08 - lines then just put a double percentage
270:10 - and when you put a double percentage
270:12 - then this entire cell is passed to this
270:14 - magic command when you put a single
270:17 - percentage that just works for a line
270:18 - the double percentage works for an
270:20 - entire cell
270:21 - so let's run that
270:23 - so now here we are doing the same thing
270:25 - remember for every year and every month
270:27 - we want to get the total payments so
270:30 - that's what we have here year month
270:31 - total payments by as a result of this
270:35 - complex SQL query percentage percentage
270:37 - SQL and then you type the name they type
270:40 - the query
270:42 - and that's the data
270:44 - here's when it gets even a more
270:47 - interesting you can actually combine
270:48 - python code and SQL code so here's what
270:51 - I'm doing I'm saying earnings result
270:54 - equals
270:56 - and then from this point on once I type
270:58 - percentage SQL jupyter detects that this
271:01 - is a magic command and it's going to
271:03 - read all of this as SQL code okay so
271:06 - what's happening is that all of this is
271:08 - being passed into this magic command
271:10 - percentage SQL and that magic command is
271:14 - going to under the hood use SQL Alchemy
271:17 - create a connection using the connection
271:18 - string that we had set up and pass this
271:21 - SQL query to that connection and from
271:24 - that connection get some results and
271:26 - then take those results and convert that
271:28 - into this format okay
271:30 - and then that data frame kind of format
271:33 - is going to be put into this variable
271:34 - earnings result so you type the variable
271:37 - name you type equals and then you type
271:39 - percent SQL and then you simply type the
271:40 - query
271:42 - and now you have earnings result
271:53 - that was the topic for today as I've
271:56 - said W3 schools is a good resource and I
272:00 - would just go through all of these just
272:01 - to get a sense of everything SQL has to
272:03 - offer
272:04 - and use this notebook to learn how all
272:07 - of these things fit together so we
272:09 - looked at aggregation grouping
272:11 - pagination in SQL queries we looked at
272:13 - mapping functions arithmetic and working
272:16 - with dates
272:17 - we looked at how to combine data from
272:19 - different tables using SQL joins we
272:22 - looked at improving query performance
272:23 - with indexes and queues
272:25 - we looked at how to use Python to
272:27 - execute SQL queries which is to get SQL
272:30 - Alchemy get a connector created
272:32 - connection string pass put the password
272:35 - into it securely create an engine runs
272:38 - queries or we could just use the IPython
272:42 - SQL magic commands and simply
272:46 - use direct raw SQL statements inside a
272:49 - jupyter notebook
272:51 - so what should you do next you should
272:53 - definitely check out some of these other
272:55 - challenges on the classic models
272:57 - database this is from
273:00 - this professor his name is Richard T
273:02 - Watson it's a great database and he has
273:04 - also given you a lot of questions to
273:07 - solve so there are what about a 100 or
273:09 - 120 questions that you could
273:12 - um try and solve
273:14 - so
273:16 - the more it's all about exercise SQL
273:18 - there's no other way to become an expert
273:20 - at SQL and I wouldn't say I am because I
273:23 - haven't done enough exercises
273:25 - here's one more set a different database
273:27 - that you should look at is the
273:29 - database system Concepts book in on this
273:33 - book page on dbbook.com you have a bunch
273:37 - of exercises
273:38 - so you can check here
273:40 - Sam sample lab exercises and term
273:42 - projects so here you can figure out
273:45 - there is a basic SQL file just like the
273:48 - classic models database and there are a
273:50 - bunch of exercises like here are some
273:53 - Advanced SQL exercises
273:55 - and this is all based on a university
273:57 - database so here you have all these
273:59 - questions the university allows an f
274:01 - grade to be overridden by any pass grade
274:03 - create a view that lists information
274:05 - about all fail grades that have not been
274:07 - overridden and the view should contain
274:09 - all attributes from all the tech all the
274:11 - takes from the takes relation right so
274:14 - there's a lot
274:16 - going on here and of course this is more
274:18 - advanced and then you have some more
274:20 - basic and intermediate questions as well
274:22 - right
274:23 - so these are two good databases the
274:25 - classic models database and then the
274:28 - student University database you also
274:31 - have solutions for the classic models
274:33 - database so if you want to check out
274:35 - Solutions this person is very kindly put
274:38 - up their Solutions so you can look up
274:40 - the solutions to the different Channel
274:41 - challenges here
274:45 - yeah so these are some of the solutions
274:47 - for the classic models database
274:49 - try that out then you have these
274:51 - interview questions with SQL
274:53 - this is a
274:56 - this repository has been created by
274:58 - Alexi grigurev he actually did a webinar
275:00 - recently a few weeks ago with us webinar
275:04 - on machine learning but he has created
275:06 - this repository called data science
275:07 - interviews and specifically in this
275:09 - repository you have under technical
275:13 - questions yeah under technical.md you
275:17 - have SQL so just check out SQL and here
275:20 - you have a bunch of questions I think
275:22 - probably over 50 or 60 Questions and in
275:26 - you can see some of these get pretty big
275:28 - but the concepts are the same you see
275:31 - select order by join and then you're
275:34 - taking the result of one query and then
275:36 - using that as a table in another query
275:38 - and so on
275:42 - okay so that's SQL for you
275:46 - yeah I think there are about
275:48 - what's this 11 questions here but they
275:51 - cover a lot of different use cases
275:54 - then w3schools is a great place to learn
275:57 - SQL Alchemy is again if you want to
276:00 - learn more about SQL Alchemy the object
276:01 - relationship mapping here's one tutorial
276:04 - that I found and went through it seemed
276:06 - good otherwise reading the official
276:09 - documentation is always a the best way
276:11 - in the most comprehensive resource I
276:14 - wouldn't worry too much about this right
276:16 - now as long as you can just connect to
276:18 - databases and make some queries you
276:20 - should be fine and finally if you really
276:22 - want to get a book then the this is the
276:24 - book I would recommend this is the book
276:26 - so one of the authors is
276:28 - the professor who I learned SQL under
276:33 - he was my college professor but yeah
276:35 - this book overall is still great and
276:37 - even if you don't want to get the book I
276:39 - would definitely check out the slides
276:42 - whenever you want to get deeper into SQL
276:44 - I would definitely encourage you to
276:46 - check out the slides on this book for
276:49 - sure
276:57 - hello everyone this is Samantha and
277:00 - welcome to the series solving SQL
277:02 - interview questions and the series we'll
277:04 - be covering four SQL interview questions
277:06 - that were asked at Amazon Netflix Uber
277:08 - and Google Now before we go ahead and
277:10 - start solving these SQL interview
277:12 - questions this is something that I'd
277:13 - like to introduce you to First and that
277:15 - is three-step approach for solving any
277:18 - SQL interview questions generally in an
277:21 - interview you're not always expected to
277:23 - give the correct answer but the
277:24 - interviewer would like to know what is
277:26 - the approach that you have tried for
277:27 - solving a particular problem and this is
277:30 - where a three-step approach might help
277:31 - you
277:32 - step one of our approach is
277:34 - understanding the inputs and the outputs
277:36 - do not jump into solving the query as
277:39 - soon as you see the question understand
277:40 - what are the inputs that you should be
277:42 - using and what are the outputs that your
277:44 - final result should be containing step
277:46 - two articulate Your solution verbally
277:48 - once you've decided what are the inputs
277:50 - and the outputs explain your interviewer
277:53 - what is the approach verbally get a
277:55 - confirmation of your understanding and
277:57 - then start writing your query step 3
278:00 - construct the query step by step once
278:03 - you've decided what are the inputs and
278:04 - the outputs once you've gotten a
278:05 - confirmation of your approach break down
278:07 - your SQL query into steps and print out
278:10 - the results of these intermediate
278:12 - queries and then improve your final
278:15 - result so now that you've gotten an idea
278:17 - on how to approach an SQL interview
278:19 - question let's go ahead and solve one as
278:22 - you can see on the screen the platform
278:25 - that we'll be using in the entire series
278:27 - for solving the interview questions is
278:29 - known as the strata scratch and if you
278:31 - look at the screen on the left side you
278:33 - can see the questions and all the
278:35 - required information that you need to
278:37 - know and on the right side you can start
278:39 - writing the query now make sure that
278:41 - you're signed into stratascrash.com
278:43 - before you actually run the code or else
278:45 - you will not be able to run the code
278:46 - unfortunately you'll not be able to
278:48 - check whether the solution is correct or
278:50 - wrong but we'll be sharing all the
278:52 - required links for practice and to check
278:54 - whether your solution is correct or
278:56 - wrong down in the description so do not
278:58 - worry much about it in this video we'll
279:00 - be solving an SQL interview question
279:02 - asked at Apple as you can see on the
279:04 - screen the problem that we'll be solving
279:06 - today is customer details find the
279:09 - details of each customer regardless of
279:11 - whether the customer made an order
279:13 - output the customer's first name last
279:15 - name in the city along with the order
279:17 - details you may have duplicate rows in
279:20 - your results due to a customer ordering
279:22 - several of the same items sword records
279:25 - based on the customer's first name and
279:27 - the order details in ascending order as
279:29 - you can see we have two tables customers
279:32 - and orders let me just quickly have a
279:34 - look at all the columns that are present
279:36 - in both the tables customer stable
279:38 - contains ID the first name last name
279:41 - city which we want and the order stable
279:44 - contains ID customer ID which I believe
279:46 - this customer ID is the same as the ID
279:48 - present in the customers table and Order
279:51 - date and Order details which again is
279:53 - something that we want according to our
279:55 - approach the first step of solving an
279:57 - interview question is understanding the
279:59 - inputs and the outputs now what are our
280:02 - inputs since they said find the details
280:04 - for each customer regardless of whether
280:06 - the customer made an order I am going to
280:08 - use the customer ID as one of the inputs
280:11 - and they have mentioned what the output
280:13 - should contain and they've mentioned
280:14 - that it will contain some duplicates now
280:16 - they also set to sort records based on
280:18 - the customer's first name and the order
280:20 - details so my inputs will also contain
280:22 - customers first name and Order leaders
280:24 - to perform the sorting and the output
280:27 - should contain customers first name last
280:29 - name and the city along with the order
280:31 - details so these are going to be my
280:33 - inputs and the outputs the second step
280:36 - of our approach is articulating the
280:38 - solution verbally to the interviewer in
280:40 - our approach we have established that
280:42 - the output should contain first name
280:44 - last name city which is coming from the
280:46 - customers table and it should also
280:48 - contain order details which is coming
280:50 - from the orders table which means we
280:52 - have to combine both of the table
280:54 - results to get the final output and for
280:56 - that I can perform a join now what join
281:00 - do I have to perform given that I am
281:02 - joining customers table on the orders
281:05 - table I'll have to use a left join so
281:08 - that I'll get all the customer details
281:11 - present in the customers table
281:12 - irrespective of whether they've made an
281:14 - order or not and that's what the
281:15 - question States so I'll be performing a
281:17 - left join on the customer's tables with
281:19 - respect to the orders table to get the
281:21 - final output result finally they've also
281:23 - meant mention that we have to order it
281:26 - by first name
281:28 - and also order details
281:32 - so this is going to be my Approach now
281:36 - the third step of our approach is
281:38 - constructing the query step by step and
281:40 - the first part of our query construction
281:42 - is performing the join select since my
281:45 - output should contain first name last
281:47 - name City and the order details these
281:49 - are the column names that will be
281:50 - present in the select statement
281:52 - first name last name
281:55 - City order details
282:00 - prom customers
282:03 - left join
282:06 - orders
282:08 - on
282:10 - customers dot ID is equal to orders dot
282:14 - cast ID because we have established that
282:17 - customer ID is the ID that is common and
282:20 - similar to the ID in the customers table
282:22 - so let me just run this as you can see
282:26 - the left join has been performed and
282:28 - whenever there is a customer who made an
282:30 - order the order details value is filled
282:32 - and if that customer has not made any
282:34 - order that order detail section is empty
282:38 - now the second part of our query
282:39 - construction is ordering this by order
282:43 - details and the customer's first name so
282:45 - I'm just going to say order by
282:48 - first name comma order
282:52 - details and I'm going to run this
282:56 - as you can see this has been ordered
282:58 - according to the first name and Then
283:00 - followed by the order details
283:05 - so yeah that's what they've been asking
283:06 - us in the question thank you so much for
283:08 - watching welcome to the series solving
283:10 - SQL interview questions in this video
283:13 - we'll be solving an SQL interview
283:15 - question asked at LinkedIn
283:17 - the problem that we are solving today is
283:20 - salaries differences
283:21 - write a query that calculates the
283:23 - difference between the highest salaries
283:25 - found in the marketing and Engineering
283:27 - departments output just the absolute
283:29 - difference in salaries and the tables
283:31 - that are given to us are DB employee and
283:34 - DB Department according to our approach
283:36 - the first step of solving the SQL
283:38 - question is understanding the inputs and
283:41 - the outputs for that I quickly just want
283:43 - to have a look at all the columns that
283:45 - are present in these two tables so that
283:47 - I'll know what inputs I have to give to
283:49 - the table to get the salaries difference
283:51 - output
283:53 - as you can see it contains ID first name
283:56 - last name salary so since they asked us
283:59 - to calculate the highest difference
284:00 - between the salaries I'm going to use
284:03 - the salary column as my input and this
284:05 - department ID and in the DB Department
284:07 - table I have ID and the department I
284:11 - believe this ID is similar to the
284:12 - department ID present in the employees
284:14 - table and as they mentioned in the
284:17 - question they want specifically for
284:18 - marketing and Engineering departments
284:20 - department is going to be my other input
284:23 - what is going to be my output output
284:26 - just the absolute difference in salaries
284:29 - so these are my inputs and the outputs
284:31 - now the second step of our approach is
284:34 - articulating a solution verbally to the
284:36 - interviewer as we've discussed that the
284:38 - columns that we'll be using are salary
284:40 - and the department
284:43 - and what they've asked us to calculate
284:45 - is the highest difference of the
284:47 - salaries between the Department's
284:49 - marketing and Engineering so when
284:51 - they're saying highest you probably are
284:53 - expected to use the aggregation function
284:55 - Max in the each department and calculate
284:58 - the difference between them so my
285:00 - Approach is probably going to be first
285:02 - thing I'll perform a join between the DB
285:05 - employee and DB Department
285:07 - so that I can get the Department name
285:09 - and the first thing I'll do is write a
285:12 - select statement
285:14 - which will get me the maximum salary
285:16 - from the Department marketing
285:20 - and I'll write another select statement
285:22 - which will get me the maximum salary
285:26 - from the Department engineering
285:29 - and then I'll calculate the difference
285:31 - between this select statement and the
285:33 - other select statement get the absolute
285:35 - difference and that's what they're
285:37 - looking for there's also another way
285:39 - that you can approach this problem
285:40 - without having to use two select
285:42 - statements and that is by using a self
285:44 - join with the help of table aliases now
285:48 - right now we are performing a join of DB
285:50 - employee with DB department so that we
285:53 - can get the Department name right what
285:55 - if we know what is the department ID of
285:58 - the department names marketing and
286:00 - Engineering we can simply just use this
286:02 - department ID within this table
286:04 - calculate the maximum salary of that
286:07 - particular department and minus it with
286:10 - the maximum salary of the other
286:12 - department by performing a self join now
286:15 - the third step of our approach is
286:16 - constructing the query step by step in
286:19 - the first part of our query construction
286:20 - is calculating the maximum salary for
286:23 - the Department's marketing and
286:25 - engineering
286:26 - so for that I'm just going to say select
286:30 - Max of salary
286:32 - from DB employee
286:36 - join with DB Department
286:39 - on
286:41 - DB employee dot Department ID is equal
286:47 - to DB department DOT
286:50 - ID I'm going to give the where clause
286:52 - for the department so that I'll get that
286:55 - specific Department maximum salary where
286:58 - DB department is a code
287:01 - okay so I think I should say
287:04 - DB department DOT department is equal to
287:07 - marketing
287:11 - so let me just execute this
287:15 - and as you can see INF got the maximum
287:18 - salary for the Department marketing
287:20 - similarly I'll also be calculating the
287:22 - maximum salary of the department
287:24 - engineering and then I'll get the
287:26 - absolute difference between these two
287:27 - select statements
287:29 - so for that what I'm going to do is
287:33 - I'm going to put this entire statement
287:35 - in one bracket
287:37 - and I'm going to do minus then I'm going
287:42 - to copy paste the same syntax here
287:44 - because it's almost the same thing
287:46 - except for the
287:48 - marketing name instead I'm going to say
287:51 - engineering so these are the two select
287:54 - statements and I'm going to perform
287:56 - absolute difference between these select
287:58 - statements so that I will get the
288:00 - difference between the highest salaries
288:02 - of the Departments
288:04 - so I'm going to say
288:05 - select
288:07 - absolute
288:10 - difference of these and I'm going to
288:11 - give this an Aliyah's name as
288:15 - salary Tiff
288:18 - and then I'm going to execute this
288:23 - as you can see we now have got the
288:27 - absolute highest salary difference of
288:29 - the Departments
288:31 - marketing and engineering
288:34 - so this is one way of our approach as
288:37 - we've discussed is another way of
288:39 - approaching the same problem which is by
288:40 - using a self join first let me just see
288:43 - what are the department IDs
288:46 - for the Department names
288:49 - marketing and Engineering so I am just
288:52 - simply going to run this
288:55 - and as you can see engineering is having
288:57 - the department id1 and marketing is
289:00 - having the department id4 so using these
289:03 - numbers in the department ID column of
289:06 - the DB employee I will perform a search
289:08 - join to calculate the highest difference
289:10 - so for that I am going to say
289:14 - select
289:17 - Max of a DOT salary
289:22 - minus Max of B dot salary
289:26 - and I'm going to give this as
289:30 - salary difference
289:33 - from
289:35 - DB employee a
289:38 - and I'm performing the self join here DB
289:40 - employee B using table aliasis
289:44 - where
289:46 - a DOT Department ID which is equal to 1
289:53 - and
289:55 - B Dot
289:57 - Department
289:58 - ID is equal to 4.
290:01 - one is for engineering and four is for
290:05 - marketing and I'm calculating the
290:07 - maximum salary of the engineering and
290:11 - maximum salary of the marketing and I'm
290:13 - performing the difference and since they
290:15 - said they want the absolute difference
290:16 - I'm going to say absolute of
290:19 - this
290:21 - and then run the score and as you can
290:24 - see we got the same answers so yeah that
290:27 - is how you approach these kind of SQL
290:30 - interview questions thank you so much
290:32 - for watching in this video we'll be
290:34 - solving an SQL interview question asked
290:36 - at Facebook which is a part of meta
290:39 - let's go ahead and start solving
290:41 - as you can see on the screen the problem
290:43 - that we'll be solving today is
290:45 - popularity percentage
290:48 - find the popularity percentage for each
290:50 - user on meta Facebook the popularity
290:53 - percentage is defined as the total
290:55 - number of friends the user has divided
290:57 - by the total number of users on the
291:00 - platform then converted into percentage
291:03 - by multiplying by 100.
291:05 - output each user With their popularity
291:08 - percentage order records in ascending
291:10 - order by user ID the user run and user
291:13 - to column are page of friends so
291:16 - according to our approach the first step
291:19 - of our query construction is
291:20 - understanding the inputs and the outputs
291:22 - let's go ahead and take a quick look at
291:24 - the table and we can see that it is user
291:27 - 1 and user 2 and these user run and user
291:30 - 2 columns are paste of friends so we
291:32 - have to use both user1 and user 2 as our
291:34 - input columns and the output should be
291:37 - each user Along With their popularity
291:39 - percentage now the second step of our
291:41 - approach is articulating a solution
291:43 - verbally to the interviewer according to
291:46 - our approach they've asked us to
291:48 - calculate the popularity percentage
291:50 - right which is basically
291:53 - total number of
291:55 - friends
291:57 - a user has
292:00 - divided by total number of users on the
292:04 - platform
292:06 - into hundred
292:08 - before we actually multiply with 100 and
292:10 - get the percentage we first need to
292:12 - figure out how to calculate the total
292:13 - number of friends a user has and also
292:16 - the total number of users on the
292:18 - platform before I figure out what method
292:20 - or function I need to use to calculate
292:22 - the total number of friends a user has
292:24 - or the total number of users I just want
292:26 - to have a quick look at how the data is
292:28 - in the table for that I'm just going to
292:31 - come back here and see
292:33 - select start from Facebook
292:39 - I'm going to run this
292:42 - and as you can see there is user1 and
292:44 - user 2 where user one two is friends
292:47 - with user two one and one is friends
292:50 - with three and four is friends with one
292:52 - this seems to be a little confusing for
292:54 - me to calculate a total number of
292:56 - friends a user has because seems like
292:59 - one is spread across both the columns
293:01 - and I can understand that the rest of
293:03 - the you know users are also spread
293:04 - across like that so for my better
293:06 - understanding what I want is if I can
293:08 - have all the ones on the left side and
293:11 - their friends on the right side and all
293:13 - the twos on the left side and their
293:14 - friends at the right side it is easier
293:16 - for me to calculate the total number of
293:19 - friends a user has
293:21 - and for that
293:23 - the thing that comes to my head is Union
293:25 - so Union is basically a method used for
293:29 - you to combine the results of two select
293:32 - statements and removes any duplicates
293:33 - present in it so that's how Union works
293:36 - so that is going to buy my Approach for
293:38 - calculating the total number of friends
293:39 - a user has now the second step is
293:42 - calculating the total number of users so
293:45 - if I'm having all the users on the left
293:47 - side and their friends on the right side
293:49 - I can just simply say distinct
293:52 - of user one right that should probably
293:56 - give me the all existing users on the
293:58 - platform now the third step of our
294:00 - approach is constructing the query step
294:02 - by step and the first part of our query
294:04 - construction is calculating the total
294:06 - number of friends a user has let me just
294:09 - go back to my query editor who write
294:11 - that query I already have Select Staff
294:13 - from Facebook friends I'm going to say
294:16 - Union
294:18 - it equal to as your one user
294:32 - I'm going to order this by user run
294:34 - because they wanted the final result to
294:36 - be ordered by the user I'm just going to
294:38 - run this query
294:41 - as you can see we are now having it in
294:44 - the format of all the one on the left
294:46 - side and its friends on the right side
294:48 - all twos on the left side and it's free
294:50 - on the right this is how that Union is
294:53 - working but what exactly is happening
294:55 - here so when you see the first part of a
294:58 - query was Select Staff from Facebook
295:00 - friends right and this is the result
295:04 - now the second part is we are saying use
295:07 - user 2 as user 1 and user 1 as user two
295:10 - so now this column will become user1 and
295:13 - this column will become as user 2. so
295:16 - the union basically combines these two
295:18 - results and removes if there are any
295:20 - duplicates present there so let's just
295:22 - see if there are any duplicates or not
295:23 - as I can see is there any barrage on
295:25 - Akash no and then we are saying biraj
295:28 - and himani so there's already a biraj
295:29 - and himani here so we can remove this
295:32 - and I'm also looking at Akash and himani
295:35 - is there any Akash and himani somewhere
295:36 - here no it's going to stay and there's
295:39 - also something called as himani and
295:40 - biraj there's himani and biraj already
295:43 - here I'm just simply going to exclude
295:45 - this so it is now in the format right on
295:48 - how we wanted it which is all the users
295:50 - on the left side and the respective
295:52 - friends on the right side now this
295:53 - explains the first part of our approach
295:55 - which is calculating the total number of
295:57 - friends a user has now all I have to do
295:59 - is just group it by the user one and do
296:02 - the count of the user too to get how
296:04 - many friends each user has so the second
296:06 - step is of our query construction is
296:09 - calculating a total number of users on
296:12 - the platform so for that what I can do
296:13 - is I can just simply calculate the
296:16 - unique
296:17 - entry of each user 1 in this table right
296:22 - all I have to now do is use this as the
296:26 - input for select
296:29 - distinct
296:32 - user one
296:35 - from this sub query
296:42 - I'm going to give this stabilizer
296:46 - thanks
296:48 - I run this
296:50 - as you can see now
296:53 - these are all the distinct users now I
296:56 - just have to say
297:00 - and oh
297:06 - you can see there are a total of nine
297:08 - distinct users on the platform I just
297:10 - now have to divide the count of each
297:12 - user's number of friends by this into
297:15 - 100 to get the popularity percentage but
297:18 - as you notice here the total number of
297:20 - users on a platform is using this as the
297:22 - input for it to calculate the total
297:25 - number of uses now for me to divide this
297:28 - by this I have to store this result in
297:31 - something so that I can use this as the
297:33 - input for this to calculate the
297:34 - popularity percentage so for that I'm
297:36 - going to use a Common Table expression
297:39 - width is a keyword which indicates that
297:41 - you're writing a Common Table expression
297:42 - and I'm going to give this commentable
297:43 - expression a name with friends as this
297:47 - let me just
297:49 - I'm going to remove this
297:54 - this is my Common Table expression and
297:56 - I'm going to use this as the input for
297:59 - my next query which is calculating the
298:01 - popularity person I'm going to say
298:02 - select user1 which is basically the one
298:05 - for each user the popularity percentage
298:07 - so I'm going to select user one and I'm
298:09 - going to say
298:12 - count of user 2 because count of user 2
298:15 - is the one which will tell you the total
298:16 - number of friends a user has and I'm
298:19 - going to divide this by
298:21 - select
298:23 - found
298:25 - distinct
298:27 - user one because that is the section
298:29 - which will give us the total number of
298:31 - users on the platform and this entire
298:34 - beta is
298:36 - um the friends
298:38 - comment table expression
298:47 - group it by user one because we want it
298:50 - for each
298:52 - as you can see
298:54 - we now have
298:56 - the popularity now I just simply have to
299:01 - write this with 100
299:04 - this is the popularity percentage of
299:07 - each user
299:09 - so yeah that is basically how you solve
299:12 - this popularity percentage question
299:14 - thank you so much for watching I will
299:16 - see you guys next time
299:18 - in this video we'll be covering an SQL
299:20 - interview question asked at Uber so
299:23 - let's go ahead and start solving
299:25 - the problem that we'll be solving today
299:27 - is distance per dollar
299:30 - as you can look at the screen you're
299:32 - given a data set of uber rights with the
299:34 - traveling distance distance to travel
299:36 - column and cost monetary cost column for
299:39 - each ride for each date find the
299:42 - difference between the distance per
299:43 - dollar for that date and the average
299:45 - distance per dollar for that year month
299:47 - distance per dollar is defined as the
299:49 - distance traveled divided by the cost of
299:52 - the right the output should include the
299:54 - year month and the absolute average
299:56 - difference in the distance per dollar
299:58 - absolute value to be rounded to the
300:00 - second decimal you should also count
300:02 - both sexes and failed request status as
300:05 - the distance in the cost values are
300:07 - populated for all the requests also
300:09 - assume that all the dates are unique in
300:11 - the data set order your result by the
300:13 - earliest request date first so this is
300:16 - our question and according to our
300:18 - approach the first step is understanding
300:21 - the inputs and the outputs so for that
300:23 - I'm just going back to the question
300:24 - again and they're saying for each state
300:27 - find the difference between the distance
300:29 - per dollar for that rate and the average
300:31 - distance per dollar for that year month
300:33 - so I see that they're asking us to
300:35 - calculate something called as the
300:36 - distance per dollar per each date so I
300:40 - see that we have to use a date time
300:42 - column which I know by looking at the
300:44 - table it has something called as the
300:46 - request State so my input is going to be
300:48 - requested and for calculating the
300:50 - distance per dollar I need to divide the
300:52 - distance traveled by the cost of the
300:54 - right so I'm going to use the columns
300:56 - distance to travel and monetary cost
300:59 - so my inputs are going to be these three
301:03 - request date distance to travel and
301:06 - monetary cost now my outputs are going
301:08 - to be as they explicitly mentioned in
301:10 - the question the output should include
301:12 - year month and the absolute average
301:14 - difference in the distance per dollar
301:16 - and the absolute value to be rounded of
301:18 - two decimals so now the second step of
301:22 - our approach is going to be articulating
301:24 - a solution verbally to the interviewer
301:26 - which is basically explaining our
301:27 - approach and getting a confirmation of
301:29 - our understanding so from the question
301:32 - we understand that they want us to
301:34 - include the year and month which means
301:37 - we are basically expected to extract the
301:39 - year and month from the daytime column
301:41 - which is requested so for that I'm going
301:43 - to use the date format
301:45 - in this way so that it will extract the
301:48 - year and month for me
301:50 - and the second thing they want from us
301:52 - is the absolute average difference in
301:54 - the distance per dollar so for actually
301:56 - calculating the difference first you
301:58 - need to calculate the average right so
302:00 - I'm going to use the average window
302:02 - function so that it is calculated for
302:04 - each and every row then I'm going to use
302:07 - the absolute function so that I'll get
302:09 - the absolute value of the difference
302:11 - that I'm getting then I'm going to use
302:13 - the round with 2 as the input because
302:15 - they've mentioned that they want the
302:17 - final output to be rounded off to two
302:19 - decimals then finally I'm going to group
302:22 - by the year and the month because they
302:24 - specifically said that they want the
302:26 - output for each year and month and also
302:29 - they finally mentioned that order your
302:31 - results by the earliest request date
302:33 - first so I'm going to order this by this
302:36 - date format that we are creating
302:40 - for year and month
302:42 - so this is basically going to be my
302:44 - Approach now the third step of our
302:46 - approach is constructing the query step
302:48 - by step and the first part of our query
302:51 - construction is extracting the year and
302:53 - month out of the daytime column
302:56 - so I'm going to say select
302:59 - date
303:00 - format
303:02 - and our column name is request date and
303:07 - the format that we want is year and
303:10 - month
303:12 - sorry and I'm going to give this entire
303:15 - extracted column a name probably year
303:18 - month and I'm getting this entire data
303:21 - from the
303:24 - request
303:27 - logs table and since they want this for
303:30 - each year month I'm going to group by
303:33 - year month
303:35 - and I'm going to order by
303:38 - year month
303:40 - so this is our code I'm going to execute
303:42 - now
303:45 - and as you can see on the screen we can
303:48 - now see the output for each and every
303:50 - year and month
303:53 - now the next step of our query
303:55 - construction is calculating that
303:56 - difference between the average distance
303:58 - per dollar which is absolute value
304:00 - rounded off to two decimals so for that
304:03 - as we've established in our explanation
304:05 - that we'll be using the average window
304:07 - function so it has partitioned for that
304:09 - each year and month so I'm going to say
304:12 - average
304:15 - distance per
304:17 - okay I think it's distance to
304:19 - travel
304:21 - divided by
304:25 - morning 30 cost so they have mentioned
304:29 - in a question that uh the distance for
304:32 - calculating the distance per dollar it
304:34 - is distance to travel divided by the
304:36 - cost so I've given that now I'm going to
304:39 - minus this by average of
304:42 - distance to
304:44 - travel
304:47 - divided by monetary
304:51 - cost
304:53 - over
304:58 - Partition by since they want this to be
305:01 - partitioned by the year end month which
305:03 - is our
305:05 - date
305:07 - format
305:10 - request State
305:13 - of
305:15 - this
305:17 - year month
305:20 - so the reason why we are using this year
305:23 - month column directly instead of giving
305:25 - it a column name which is year month
305:27 - window function will not be able to
305:29 - identify this prior so we need to
305:31 - specify the entire thing
305:35 - so this is done now I'm going to give
305:37 - this entire column name of function
305:40 - which is probably called as the
305:42 - average
305:44 - difference
305:45 - so this entire thing is again coming
305:48 - from the Uber request logs and order by
305:50 - human Group by your month so I'm simply
305:53 - going to run this query now
305:55 - as you can see
305:59 - it you now have
306:01 - the year month and the average
306:03 - difference but in the question that
306:05 - specified that they want it explicitly
306:07 - as the absolute value right so you now
306:09 - have to use the absolute function and
306:10 - that's what I'm going to do now
306:14 - so I'm going to say absolute value
306:20 - of this entire
306:23 - thing
306:24 - and I'm going to run it
306:28 - differences
306:31 - as you can see this has been rounded off
306:33 - to absolute value which is basically
306:36 - it's returning your positive value now
306:38 - they also want this to be rounded off to
306:40 - two decimals so I'm now also going to
306:42 - use
306:44 - round method
306:46 - so I'm going to say
306:51 - round and then I'm going to come back
306:53 - here
306:55 - and say two
306:58 - and then I'm going to run the code
307:03 - as you can see now this is rounded off
307:05 - to two decimals so that's basically what
307:09 - they're looking for the output should
307:11 - contain the year month and the average
307:13 - difference between the distance per
307:14 - dollar the absolute value rounded off to
307:17 - two decimals
307:19 - so yeah that's how you solve these kind
307:21 - of SQL interview questions thank you so
307:24 - much for watching I'll see you guys next
307:26 - time bye in this video we'll be covering
307:28 - an SQL interview question asked at
307:30 - Amazon so let's go ahead and start
307:33 - solving
307:34 - the problem that we'll be solving today
307:36 - is monthly percentage difference given a
307:40 - table of purchases by date calculate the
307:42 - month over month percentage change in
307:44 - Revenue the output should include the
307:47 - year month date in this particular
307:49 - format and percentage change rounded to
307:52 - the second decimal point and sorted from
307:54 - the beginning of the year to the end of
307:55 - the year
307:56 - the percentage change column will be
307:59 - populated from the second month forward
308:00 - and can be calculated as this month's
308:04 - Revenue minus last month's Revenue
308:05 - divided by last month's Revenue in 200.
308:08 - so they're also giving an idea on how to
308:10 - calculate this percentage change column
308:12 - according to our approach the first step
308:14 - is to understand the inputs and the
308:16 - outputs and we can do that by reading
308:18 - the question clearly once again
308:21 - since they're saying given a table of
308:23 - purchases by date calculate month over
308:25 - month percentage change in Revenue there
308:28 - is some day time column involved here so
308:30 - for me to confirm whether we have a date
308:32 - time column or not I need to have a
308:34 - closer look at all the columns in the
308:35 - table so if I scroll down I can see all
308:39 - the available columns in that particular
308:40 - table which is named as the SF
308:42 - transaction so I see ID created at Value
308:46 - purchase ID so my input is going to be
308:49 - the date time column which is created at
308:51 - and since they are wanting the
308:53 - percentage change in the revenue I'm
308:55 - guessing the value is the one which
308:57 - contains the revenue number so my inputs
309:00 - are going to be created at Value and
309:03 - they say the output should include the
309:05 - month year date and percentage change
309:08 - so my output are simply going to be that
309:10 - month year column and also the
309:12 - percentage change column that will be
309:14 - calculating using the formula that they
309:16 - have mentioned in the question
309:18 - so the second step of our approach is
309:21 - articulating a solution verbally to the
309:23 - interviewer which is basically
309:24 - explaining our approach and getting a
309:26 - confirmation of our understanding
309:28 - specified in our question the output
309:31 - should contain the daytime column in a
309:33 - particular format which is basically in
309:35 - the year and month I'm going to use the
309:37 - date format function in MySQL which will
309:40 - help me extract the year and also the
309:43 - month
309:44 - for that particular output column and
309:47 - they are also asking us to calculate the
309:49 - percentage change in the revenue before
309:50 - we calculate the percentage change in
309:52 - the revenue we first need to calculate
309:54 - the revenue right and for that I'm going
309:56 - to use the sum for the entire value
309:59 - column and group it by the month and
310:01 - year column that we are extracting so
310:03 - that we can get the month wise Revenue
310:06 - and this will generate the revenue for
310:07 - us
310:09 - so once the revenue is generated I am
310:11 - going to now calculate the percentage
310:13 - change in the revenue using the formula
310:17 - described in the question so in that
310:19 - question they are using the terms such
310:21 - as previous month and current month and
310:23 - one function that comes to my head for
310:25 - calculating the percentage change is the
310:27 - lag which is a window function and I'm
310:30 - going to use the lag for that
310:32 - now they've also explicitly mentioned
310:34 - that they want us to round off the
310:36 - entire percentage change to two decimal
310:39 - points and for that I'm going to use the
310:41 - round function with the input as 2 so
310:43 - that the decimal points are rounded off
310:45 - at 2. and finally they want us to order
310:48 - this as per the starting year so I'm
310:50 - going to order it by the month year
310:53 - column that we are generating so this is
310:56 - basically going to be my Approach
310:59 - now the third step of our approach is
311:01 - constructing the query step by step the
311:04 - first step of our query was extracting
311:06 - the month and the Year from the date
311:08 - time column using the date format
311:09 - function
311:11 - so select date format
311:16 - from the created add column it has to be
311:21 - in the format percentage y percentage m
311:26 - and I'm going to give this column a name
311:28 - as your month
311:31 - and this data is coming from SF
311:34 - transactions
311:37 - so I'm going to now run the query
311:40 - as you can see on the screen we have
311:42 - extracted the year and month column
311:45 - using the date format now the second
311:47 - step is calculating the total revenue so
311:51 - for that I'm just going to check
311:54 - sum of
311:57 - value
312:01 - and give this a revenue name
312:05 - and I'm going to
312:07 - group it
312:09 - by
312:12 - this column year one so that I get the
312:16 - monthly Revenue
312:17 - so I'm now going to run the query again
312:20 - as you can see in the output we now have
312:22 - the monthly Revenue
312:25 - now our next step in constructing our
312:27 - query is calculating the percentage
312:29 - change in the revenue using the lag
312:32 - window function and we are going to use
312:34 - the formula that has been described in
312:36 - the question
312:39 - so as described in the question I am
312:43 - going to first use the formula this
312:45 - month's Revenue minus last month's
312:46 - Revenue which is for this month's
312:48 - Revenue I'm simply just going to say sum
312:50 - of value and for last month's revenue is
312:52 - where I'm going to use lag of
312:55 - sum of value
312:58 - okay
312:59 - and since this is a window function to
313:01 - indicate the SQL that this is a window
313:03 - function I'm going to use the over class
313:04 - and I'm going to put this entire thing
313:08 - in Brackets and divide this entire thing
313:11 - Pi last month's Revenue again which is
313:13 - where I'm going to use the lag sum of
313:16 - value and I'm going to indicate that
313:20 - this is a window function and I'm going
313:23 - to multiply this with 100 I'm going to
313:26 - give this column a name percentage
313:30 - Revenue
313:32 - I'm going to run this
313:35 - as you can see the output now we have
313:38 - the year month revenue and percentage
313:40 - Revenue now this next step is rounding
313:43 - up this entire thing to two decimals so
313:46 - I'm now going to use round
313:49 - function
313:50 - and then
313:57 - commit by 2 and then going to run this
314:01 - code again
314:03 - and you should be able to see that this
314:05 - is now rounded off into two decimals now
314:09 - the last step that we need to do is
314:11 - basically ordering this by the year
314:13 - month I'm now just simply going to say
314:16 - order by
314:19 - year month
314:23 - and then I'm going to run
314:26 - and you can see that again this has been
314:28 - ordered
314:30 - so this is our output
314:32 - since our question says that the output
314:34 - should only include the Year date month
314:36 - and the percentage change I no longer
314:38 - need to show this Revenue column so I'm
314:40 - just simply going to remove this
314:43 - or you just simply have
314:47 - the ear and the percentage Revenue
314:50 - so yeah that's how you approach this
314:52 - particular SQL problem thank you so much
314:54 - for watching I'll see you guys next time
314:56 - hello everyone welcome back to the
314:58 - series solving SQL interview questions
315:01 - in our last video we've sold an SQL
315:03 - interview question asked at Google using
315:05 - our three-step approach in this video
315:08 - we'll be solving an SQL interview
315:09 - question asked at Netflix so let's go
315:12 - ahead and start solving as on the screen
315:15 - the problem that we'll be solving today
315:16 - is top percentile fraud on the same
315:19 - platform status crash that we'll be
315:21 - using throughout this series let's take
315:23 - a look at the question now ABC Corp is a
315:26 - mid-sized insurer in the U.S and in the
315:29 - recent past the fraudulent claims have
315:31 - increased significantly for their
315:32 - personal auto insurance portfolio they
315:35 - have developed a ml based predictive
315:37 - model to identify propensity of
315:39 - fraudulent claims now they assign highly
315:42 - experienced claim adjusters for top five
315:44 - percentile of claims identified by the
315:46 - model your objective is to identify the
315:49 - top five percentile of claims for each
315:52 - state your output should be policy
315:54 - number state claim cost and fraud score
315:57 - but before we get into that I'm seeing
315:59 - terms such as person type so what
316:02 - exactly does this percentile mean
316:04 - percentile is simply a value under which
316:07 - a percentage of data falls into so if
316:10 - you look at the screen we have data
316:12 - points such as 40 50 60 so on total 10
316:16 - data points and we are being asked to
316:18 - calculate the 30th percentile so the
316:21 - first step of calculating a percentile
316:22 - is arranging the data points in
316:24 - ascending order that is from lowest to
316:27 - the highest the next step of calculating
316:29 - that particular value under which 30
316:31 - percent of the data Falls is you have to
316:34 - count the numbers from left to right
316:37 - 482 is the number under which 30 percent
316:41 - of the data falls into now coming back
316:44 - to our question where they asked us to
316:46 - identify the top five percentile what
316:48 - they meant is basically finding all the
316:51 - values that fall under the top five
316:52 - percent of the fraudulent claims the
316:54 - first step of our solution is
316:56 - identifying the inputs and the outputs
316:58 - so let me take a look at all the columns
317:00 - that are present in the table to see
317:02 - which will give me the
317:03 - fraud claim so I can see that there's a
317:06 - column called as frog score so I'm going
317:08 - to use this as the input for calculating
317:10 - the fraud claim and since they're saying
317:12 - that they want it for each state I'm
317:15 - going to use the column called as state
317:17 - as mentioned here so my inputs are going
317:19 - to be fraud score and State
317:21 - what are my outputs going to be here
317:23 - they explicitly mentioned that it should
317:25 - contain policy number state claim cost
317:28 - and fraud score now the second step of
317:30 - our approach is articulating a solution
317:32 - verbally which is basically explaining
317:34 - your approach to your interviewer and
317:36 - getting a confirmation so in our
317:39 - questions since they are asking us to
317:40 - identify the top five percentile of
317:42 - claims from each state the thing that
317:44 - comes to my head for calculating the
317:46 - percentile is a window function end tile
317:49 - which will help you calculate percentile
317:50 - squat tiles Etc so my input for the
317:53 - entire function is going to be 100 so
317:55 - that it divides the entire data into 100
317:57 - equal parts which is what percentile is
317:59 - and then I'm going to use a filtering
318:01 - technique for filtering out the top five
318:03 - percentage now when they said from each
318:06 - state I am using a window function here
318:08 - right and in window function you have a
318:10 - clause called as Partition by which will
318:12 - help you create Windows as per the
318:15 - column that you mentioned in it and
318:16 - since the question says from each state
318:18 - I'm going to say Partition by each state
318:21 - in my window function so that for each
318:23 - state I'm going to get the top five
318:25 - percentile now the third step of our
318:27 - approach is constructing the query step
318:29 - by step I'm going to say select star
318:32 - since they want almost all the columns
318:34 - in the output and tile is the function
318:36 - that I'm using to calculate the
318:37 - percentile with the input as 100 so that
318:39 - the data is divided into 100 equal parts
318:42 - I'm going to use the over class used to
318:44 - indicate that you're using a window
318:46 - function and I want each of this Windows
318:48 - to be partitioned by State since the
318:52 - question States they wanted from each
318:53 - state then I'm going to order this by
318:56 - fraud score the column which contains
318:59 - the fraudulent claims
319:01 - and since they want top five percent I'm
319:03 - going to order this by descending order
319:06 - and I'm going to give this entire entire
319:08 - function column a name which is
319:11 - percentile since that's what we are
319:13 - calculating and this entire data is
319:14 - coming from the
319:16 - so I'm running it okay great I now can
319:20 - see that it is ordered by the fraud
319:22 - score and divided into 100 equal parts
319:25 - now the next step is for me to
319:28 - filter out the top five percentile from
319:31 - this entire query so this table has to
319:34 - be an input for another table so that I
319:36 - can filter it out using the where Clause
319:38 - so that's what I'm going to do now this
319:40 - table is going to be
319:42 - one and I'm going to
319:46 - select star
319:49 - from this table
319:51 - I'm going to give this table a name
319:52 - called as
319:54 - percentile table and filter out where
319:59 - percentile is less than or equal to 5
320:01 - because we are looking for the top five
320:03 - percentile
320:04 - so I'm going to run this query now
320:10 - and there you go you now have as stated
320:13 - it should contain policy numbers state
320:15 - claim cost fraud score percentile and
320:19 - then you're containing top five
320:20 - percentile for the each state since they
320:22 - said the output should only contain
320:24 - these and you don't want it to show the
320:26 - percentile you can explicitly mention
320:28 - here what are the column names that
320:29 - you're looking for so I can simply say
320:32 - policy num
320:35 - state
320:36 - claim cost comma
320:40 - fraud score
320:43 - from this table and then I'm going to
320:44 - run it so there you go policy number
320:46 - state so these are the top five
320:48 - percentiles of fraud cases from each
320:51 - state here that's how you go ahead and
320:53 - solve this particular kind of questions
320:55 - we will see you guys next time bye let's
320:58 - take a look at the question now find IDs
321:00 - of companies that have more than two
321:02 - users who speak English German French or
321:04 - Spanish
321:06 - so according to our approach our first
321:08 - step is to understand the inputs and the
321:10 - outputs clearly now for me to understand
321:13 - the inputs clearly I need to know what
321:15 - are the columns present in the table
321:16 - Playbook users if you scroll down you
321:19 - will see the inputs that are given to
321:20 - you which is user ID created at Company
321:23 - ID language activated it and state now
321:25 - among these what should be my inputs and
321:28 - how will I know that by reading the
321:29 - question clearly which is find IDs of
321:32 - the companies so I need to use the
321:34 - company ID that have more than two users
321:37 - so when they are talking about users
321:38 - which means I'll also have to use user
321:40 - ID who speak English German French and
321:43 - Spanish so I don't see any columns with
321:45 - respect to this but I can see that there
321:47 - is a column known as language so I now
321:50 - need to filter out these languages from
321:52 - the column language so what are my
321:55 - inputs Company ID user ID and the
321:59 - language Now what are my outputs since
322:01 - the questions only simply States find
322:04 - the IDS of the companies my output will
322:06 - only Simply Be Company ID so my inputs
322:09 - are Company ID user ID language and my
322:12 - output is only simply Company ID now
322:15 - step two of our approach is explain your
322:16 - approach verbally now that you've
322:19 - understood what are the inputs and the
322:20 - outputs you now have to explain to your
322:22 - interviewer what is the approach
322:24 - if you look at the question it says find
322:26 - the IDS of the company so they want you
322:29 - to find for each company which means you
322:31 - have to use a group by Clause known as
322:33 - Company ID and then since they're
322:36 - talking about that have more than two
322:38 - users they want to perform some
322:40 - aggregation function in this case which
322:42 - is count so you're going to have to
322:44 - perform an aggregation function count
322:46 - for finding out more than two users
322:49 - and since they want it for each company
322:51 - you'll have to do something called as
322:52 - Group by for each company who speak XYZ
322:56 - languages so you now need to filter out
322:59 - these languages from the column language
323:01 - so one operator that comes to my mind as
323:04 - soon as I'm checking for a string value
323:06 - is in so I'm going to check whether this
323:09 - particular language is present in the
323:11 - language column or not for that
323:13 - particular user now that I've explained
323:15 - my approach to my interviewer verbally
323:17 - the third step is basically constructing
323:20 - my query step by step and that's what
323:21 - I'm going to do now the first step of
323:24 - constructing my query is filtering out
323:26 - the users who are speaking the languages
323:28 - x y z
323:30 - select
323:32 - since my output should only contain
323:34 - Company ID I'm only going to give
323:36 - Company ID from the
323:41 - table Playbook users
323:43 - where
323:46 - language in
323:49 - I'm going to give
323:52 - English
323:55 - German
323:58 - French and Spanish
324:02 - so I'm just going to turn this code okay
324:05 - now it's showing me all the company IDs
324:07 - where these languages are presenting but
324:10 - since I want for each Company ID I'm
324:13 - going to do Guru by
324:15 - company
324:17 - ID
324:20 - great now the classes they want the
324:23 - users who are more than two in number
324:25 - this is where I'm going to use my having
324:27 - Clause having
324:30 - count or user ID greater than two and
324:35 - now a company might contain like
324:37 - multiple entries I want distinct user ID
324:40 - unique user ID I'm going to say since
324:43 - this side it has to have more than two
324:45 - I'm saying greater than 2 and then
324:46 - executing my query
324:48 - and it says there is some error which
324:50 - says having count oh seems like I have a
324:55 - typo here so I'm going to say distinct
325:00 - and then I'm going to run my code and
325:02 - there you go so these are the companies
325:05 - where there are more than two users who
325:07 - speak the languages English German
325:09 - French and Spanish so this is how you
325:12 - approach in solving an SQL query so keep
325:15 - three things in mind which is basically
325:17 - understanding your inputs and outputs
325:19 - explaining your approach verbally third
325:21 - thing is constructing your query step by
325:24 - step that's it for this video guys I
325:26 - will see you next time bye will you
325:31 - [Music]
325:34 - come back

Cleaned transcript:

welcome to this comprehensive sequel tutorial course designed for beginners and also those looking to prepare for technical interviews this course was developed by the team at Jovian who have created many popular courses for our channel in this course we'll cover the basics of relational databases and SQL including setting up MySQL inserting data and working with aggregation grouping and pagination and SQL queries the course also covers Advanced topics such as combining tables using joins executing SQL queries using Python and SQL Alchemy and solving technical interview questions by the end of the course you'll have the knowledge and confidence to excel in SQL is it SQL or SQL well it doesn't really matter because you need to learn it no matter what it's called hello and welcome to this tutorial on SQL where you will learn the basics of the structured query language which is used to fetch data from almost every database in the world no matter what you're doing in data science you will need to learn these skill and this will be part of your daily job and this course guides you step by step and you can follow along with everything that we do in this course to learn the basics of SQL and even learn how to crack interview questions from the top companies in the world so I hope you enjoyed this course leave a comment and subscribe to our Channel if you'd like to join more of these courses and let's get started the topic for today is relational databases and the structured query language or SQL and here's what we're going to talk about today first we will talk about some of the use cases and the design of relational databases and SQL what they are and why they are used we will see how to set up a database locally using the MySQL server we will create modify and delete databases and database tables we'll see how to do that we learn about the data types in SQL and some constraints like primary key foreign key Etc we will look at crud operations you will see this term a lot in relation to databases so create read update and delete operations on data stored in tables and then we'll also look at how data can be exported and imported from relational databases this is part one of two lessons on SQL so the next week will be an advanced lesson where we will look at aggregations we look at joins we look at indexes and we will also see how to use how to use Jupiter to get data out of a SQL database and how to work with it in Python so maybe how to do some analysis and how to do some visualization but today we are going to work in a more traditional setting where we are going to use some commonly used software like a MySQL server for working with SQL databases now we learn about relational databases in SQL by working through this problem this is a hypothetical scenario that we've set up and we'll try and understand in the context of this problem why we want to use a regulation database and how SQL is helpful so classic Models Incorporated is a manufacturer of manufacturer of small scale models of cars motorcycles planes ships trains Etc and products manufactured by classic models are sold in toy and gift stores around the world so this is what some of their products look like they are small scan models of various types of vehicles and classic models has offices around the world with dozens of employees and these are primarily sales offices so the customers of classic models are typically toy or Gift Stores and each customer typically has a designated sales representative uh in the same region who's also an employee of classic models and they interact with that sales representative directly then customers typically Place orders requesting several products in different quantities and then they pay for multiple orders at once via checks so this is typically how a business works you have you manufacture some products and then you have offices and then you sell your products to people and you have transactions with them and you have employees involved who are involved in managing these relationships and managing the offices that you run right now for an international organization like this it is important to record all of this information all of the activities in a single central place right so your task is to create a database some sort of a system where you can record and manage all of this above information so where do we have our offices who works at these different offices who are our customers how who is the sales representative for every customer what kind of orders are customer placing and what what are the payments from them what do the payments from them look like so we want to record and manage all of this information in a database in a central location and this database will also be used for daytoday operations for example adding new customers placing orders recording payments hiring employees and things like that and also just querying information and getting analytics about how the business is doing so while there are many ways of storing data on a computer for example we could put this into a bunch of text files we could maybe open notepad create a few files and put in all this information there but looking it up is going to be very difficult we could use Json files we could use CSV files we could put maybe have a CSV file for customers one for products one for employees we could use spreadsheets things like Excel which a lot of businesses use but spreadsheets become a bit Limited in functionality as you deal with really large data sets and as you want to do some Advanced forms of querying and also as you want to integrate this with these systems with other systems for example you want to create forms for customers to sign up you want to create order forms you want to create a bunch of different things connecting forms with spreadsheets and writing custom business logic can be a bit tricky so this is where a relational database comes into picture a relational database is a data storage system typically which has the following properties so the first thing about a relational database is that data is stored in tables so each kind of entity that we are concerned with you have a table for it for example you have a table for customers and this is a snapshot of some data stored in a relational database so you have a table for customers and each customer has a customer ID they have a first name they have a last name they have a date created which means the date at which or the exact time at which that customer was added to your database and then you have a bunch of information maybe where they live etc etc right so that's one important piece that data stored in tables second each table has a set of columns as you can see here each stable has a set of columns and each column is used to store a specific type of data for example customer ID is going to be a number and it's in fact going to be a unique identifier for the customer first name and last name is their first and last name and then date created is going to store the date or the time exact time when they join and so on next data in the tables is stored as rows so each row of this data after this header row represents a customer and sometimes these rows are also called records so data stored using rows within database tables next table support crud operations on rows which means create read update and delete so you can add new rows into the table that's the create operation you can delete rows from the table you can delete rows from the table that is the delete operation you can get data out of the table let's say you want to figure out which customers you have in the United States then you can query that you can just type out some code and you will get back that information and you can update information because if a customer changes their address or their phone number or their email you should be able to change that then one important piece so a lot of databases support this but one important piece is relations between tables so tables can be connected to other tables using relationship constraints for example you have offices and you have employees we can say in the employees table that an employee works at a particular office so we can make a relationship between an employee record and an office record and there can be onetoone relationships there can be one too many manytoone relationships and we will talk about these in more detail when we talk about joins but at the moment the just the fact that you can link records across tables is an important piece to understand then relational databases typically allow you to retrieve data from the database using the structured query language or SQL which is what we will learn today and these databases can either be hosted locally on your computer or more commonly these are hosted somewhere on the cloud for distributed access for example for classic models it's possible that they have set up a database on the cloud and all the employees from all the different offices use this database through some browserbased application maybe they have Farms or maybe they have some kind of accessbased system where different employees have different permissions and they use this database but everybody's ultimately making changes or getting information out of the same database right and this is how most modern applications work for example on Jovian we have a relational database sitting somewhere on the cloud and all of your account information is on in the relational database and when you open your profile we get data out of that relational database and we show it to you okay so that's relational databases the important pieces are that data stored in tables a set of columns each column has a specific type and then tables can be conducted using relationships and the data is queried using SQL or the structured query language now when you are setting up a relational database which you most likely won't have to do because in most cases whatever Corporation you work with or whatever client you work with in a project they will already have a database but when you're setting up a database it is common to First create an entity relationship diagram or it's called an ERD to describe all the tables within a data within the database and the relations between them so ERD this is what an ERD looks like an entity relationship diagram and they can be created using drawing tools like lucidchart so typically this is something an image like this is what you might be given when you join a company they may give you an image like this and they would tell you that this is what our data model looks like or this is what our database looks like and sometimes you may have multiple ersds because different teams or different or orgs or different departments when this in the same company may have their own separate database and sometimes you may have data duplicated across different databases and so on but let's just take a look at this ERD and understand what it represents so the first thing you will notice is we have these boxes we have this one box called payments we have this called offices we have employees customers product clients products orders and audits so each box in an entity relationship diagram shows you a table okay so for example offices is a table and then inside each box this is the list of columns in the table now the ERD does not contain any actual data it is sort of a blueprint for the database on what tables it contains and what are the fields within each table and how the tables are connected so the office is stable for example will contain an office code and you will see that this is you can see a key icon here if I zoom in a little bit so this is a key icon so that is simply to indicate that the office score is a unique identifier for the office and this is also called a primary key so the office code is the unique identifier or the ID just as on Jovian you have a unique ID which is your username so similarly office code is a unique ID and then the office is based in a certain city it has a certain phone number it has a certain address address line one address line two a state country postal code territory and maybe even a location a geo location for plotting on a map okay and different ways in which erds are created may or may not contain this additional information for example here what this blue square represents is that this is a required detail if it is filled in and if it is not filled in then that means that this is optional so you can have address line 2 may not be present for some offices because it's enough to summarize the address in one line but yeah you may not always have these details and this ERD does not contain information about the types of data you can probably guess office code would probably be either a string or a number a city would probably be a string phone would be a string all of these would mostly be strings then you have employees so for employees we have an employee number so that's the primary key and I think that is going to be a number then there is a last name first name extension so this is probably employees work at an office so at the office what is the extension to reach this person via phone you have an email for the employee and interestingly there is this reports to feed so most employees in most companies report to other employees of the company so this reports to is some sort of a link from employees to the same table of employees so reports to would probably contain an employee number of another employee in the company then you have job title and then you have something called office code so office code again is going to be the office code of the office where the employee works so you can already start to see these relationships employees work at an office so there is an office code in employee and that office code should match with the office code of a particular office and then you can do interesting things like find all the employees who work at a particular office or maybe given an employee find the full phone number which is the phone number of the office combined with the extension for this employee and similarly you will now see other relationships you have customers so customers have all this information and then in customers you have the sales rep employee number so this is going to be a reference from the customers table to the employee table the employee number should match up with an existing employee then you have payments done by customers so customers pay by check so you can see here there's a customer number which is a reference field then customers place order so there is a table where we are recording orders where we have an order number order date some information about the order some comments and there is a customer number indicating which customer has placed the order but of course an order can contain a lot of information so you can place you can have many products that you would have or that you can include in an order so we have a table for products like product code product name product code is the unique ID product name product vendor Etc and product code there is also a product line which itself is another table so you may have four or five product lines and in each product line let's say the product lines are cars motorcycles ships Etc remember this company creates small scale models of vehicles so product lines could be the different kinds of vehicles and the products could be then individual vehicles or individual actual products that they create and then there is this order details so an order can potentially have many products that were ordered so in order details so for one order you may have several records in order details and you may have the order number you may have the product code and then you may have the quantity ordered so let's say in order number one the customer customer number 10 creates order number one and in order number one they request product number five product number six product number seven and each with a different quantity so order details is used to track all that information okay so this is how all of this fits together you have tables with columns and then you have relationships between tables and uh understanding and entity relationship diagram is the first step towards understanding what a database contains and all these symbols have certain meaning which we will talk about the next time when we talk about joins in one to many and many to one relationships okay now there are several relationship there are several relational database software packages and some of them are free and some of them are open source While others are paid and proprietary and the most common ones are these MySQL is an open source and free option they also have a paid option but the free option does the job for most people then you have postgres you have sqlite you have Microsoft SQL Server Maria DB Oracle IBM db2 so some of these are proprietary so for this tutorial we will use MySQL a free and open source relational database software now the concepts that we learned today will be applicable across any of these but the syntax the actual code that you need to write May differ so just keep that in mind and just try to understand the the key Concepts and we'll talk about how you can look up the differences in code Maybe by comparing let's say with the postgres database and primarily it's simply a matter of looking it up on the documentation or finding a stack Overflow answer over time once you join a company most companies will only use one type of database so over time you will become comfortable in the flavor or in the kind of in the software package that your company uses and the variations in SQL in the SQL language that software package requires but your skills should be transferable across different SQL variants Okay so we've been saying SQL a lot or SQL what is it so SQL stands for structured query language and it is a programming language for interacting with relational databases now we've set up this database somewhere and now we need to put data into it and then we need to get data out of it maybe we need to change some data within it for doing all of those things you use the SQL programming language and unlike general purpose programming languages like python Java C plus Etc SQL has a very limited syntax and a very specific use case the specific use case is to interact with a relational database it's you cannot use SQL for data visualization for example you cannot use SQL for building software building web applications you cannot use SQL for creating scripts you cannot use SQL for machine learning it's that is not the purpose of SQL the purpose of SQL is to put data into tables into relational database tables and get data out of relational database tables and make changes so it's all about working with a database without a database there is no SQL and this is what its syntax looks like so this is all one single SQL statement it's split across multiple lines but you will see at the end there is a semicolon indicating the end so here what we're saying and SQL is a very readable language so here what we are saying is select top three so we want to select the top three products so we want to select product ID from the sales table and you wanna select the product name and you want to select the total quantity of products sold from the table sales and then you want to do a join so again there is some joining merging involved and then you're doing some kind of a grouping and then you're doing some kind of an order by and then you're doing some kind of a sum and then you are sorting it in descending order so you have all of these things that you're putting together there are many pieces that are coming together here and we will learn some of these pieces this week and some of this pieces next week but by the end of these two weeks you will be able to understand exactly what this statement does and you will be able to write statements like it and it's not too difficult it's just that you have to understand what each of these parts represents okay and that's what we will go over step by step so you type in a SQL query and you send it to the database and then the database gives you a result so typically it is some sort of a subset of the table like here we are selecting a certain set of rows so that so the database is given just three rows of data and it has given just three columns of data the actual table or tables that this information has been drawn from can contain several thousands or millions of rows and can contain several columns as well so you don't always want to see all the data sometimes you just want to see the data that you are concerned with and sometimes you want also want to summarize data by taking the sum Etc okay now a quick note on SQL statements there are three types of statements in SQL one is called the data definition language so there are three parts to setting up a database first or using a database first is to set it up which means taking the entity relationship diagram and converting it into an actual database with actual tables in your local copy of the software or somewhere in the cloud okay so here we are concerned with generating a table generating a database or modifying the structure of a table making connections between tables that is called the data definition language or that is one of the parts of SQL then you have the data control language the control language is primarily about managing user access rights so for any database system you have a way to assign permissions to users so you can create users and then you can give users permissions and some users may have read permission some users may have write permissions sometimes you can also control information per table so you can control who can write to let's say the employees table so only the administrator should be able to create new employees but maybe all employees should be allowed to create new customers right so you have all these rules and that is also something that you can do with SQL not something that we will cover extensively because this is not something that you will have to deal with maybe the database administrator will already set this up for you but the most important thing that we will deal with is the data manipulation language which talks about which is the most frequently used subset of SQL and it is used for searching data so if you have a database getting some data out inserting data into a database updating a database updating some information that's already there and deleting data right so the crowd operations create read update and delete those are the operations covered in the data manipulation language now you don't need to really worry about these terms ddl DCL DML you never have to deal with them but it's just that you have three there are three ways in which we use SQL statements to create a databases and set up the structure to manage permissions and most importantly to actually do crowd operations on the data and before we start writing some SQL code a quick note on the syntax so SQL syntax is case insensitive which means that you can type statements in uppercase lowercase or a mixture of both like here we have select top three sales dot product ID you can write select in lower case you can maybe write S as a a s and lowercase and E in uppercase l in lower case it won't matter same is true with all the column names most of the time in most SQL distributions they are case invariant so you can use uppercase lowercase whatever seems more convenient to you okay and one thing that you will notice is at certain places we will use these back ticks or back codes so this is called a back code especially for database names and column names and table names now these are optional so wherever you see this character it is completely optional the reason it's there is primarily just to differentiate between the SQL syntax and keywords and actual table names and and such can we see this in just a moment then SQL statements can span over multiple lines so you can write three four five ten lines in a sec in a SQL statement and you have to end it with a semicolon that's the important piece if you don't put in a semicolon then your statement may not get executed or the system is still keep waiting for some output and then finally all the statements that we are going to execute in today's tutorial can be executed on MySQL now this MySQL can be running on your computer it can be running somewhere on the server and it can be accessed in two ways which is the command line or the workbench and we look at both in just a moment okay now the SQL syntax as I mentioned for every relational database software package is slightly different so if you're using postgres or you're using a Microsoft SQL server or Oracle it's going to be slightly different so just check the official documentation of your database for details what we will learn is the kind of operations that you can do on database tables and the specific syntax is just a matter of looking it up all right so with that let us set up MySQL server locally now you don't need to do this right now but whenever you're following along with this notebook a definitely set it up locally on your computer and the download takes a while that's why I'm recommending you don't do it right now but do set it up locally on your computer and experiment with all of this code all of the things that we are doing to see the effect that these statements have okay so you can download you need two things you need to set up the MySQL server so here's the MySQL server you can go to dev.mysql.com download slash MySQL and select your operating system in my case it's Mac OS and then select the kind of archive you want to download you can see that this is a 415 MB file so it takes a while to download now I've already done the download so I don't need to do this again but if you're on Linux for instance then you may want to either download a tar archive or if you do download a tar archive then you may have to follow some additional instructions as well if you're on Windows I think you should be able to download yeah you should be able to download a zip archive that you can directly open up an Exe on I think on Lin on Ubuntu you should be able to download some kind of installable bundle so whatever operating system you're using you should be able to download one version now we just need the MySQL server we don't need anything more than that but and the MySQL server will set up a database for us and allow us to create tables within databases and query databases and so on and you can run it and we are going to run it locally but it can just as well be hosted on a server as well right so but we are going to run it locally to interact with the MySQL server one way is to use the command line interface so now in my case I have installed it on Mac so I'm just going to open up a terminal and let me zoom in this terminal a little bit yeah so now I have opened up a terminal and when I installed MySQL after downloading it created this folder slash USR slash local slash MySQL so it created this folder and you can see this folder here if I do LS and where did I find this well I just looked it up where does MySQL get installed on Mac OS and I got this response where it's in slash USR slash local MySQL in your case in your operating system this location may be different this may be in C program files or this may be in somewhere else on Ubuntu so you would have to look this up but in this folder slash user slash local MySQL there is a folder called bin so I'm just going to type slash bin here and then there is a folder called let me just check LS on bin so you have a lot of things inside bin but the one we should be concerned with is MySQL the command line interface so I'm just going to run slash user slash local slash bin slash MySQL so now this is a command line tool that I'm going to run okay and to run this the first thing that you will need to do is you will need to provide a username and by default when you install MySQL it will have the username root and then you also need to provide a password when you're installing so when you download this file and then you're set doing going through the installation steps it will ask you to set a root username and a root password in my case I set my root username to root that was the default option and I did set a password as well so here is how you specify the username and the password so you say you give the path to the MySQL binary or the MySQL command line tool and you specify using minus U which user is trying to access it and root was the default user that they had that it had set up and you specify minus p and it will prompt you for a password so I'm just going to type in the password Here yeah so I've just typed in the password now and now what has happened is MySQL was already running on my computer after I installed it but now I have logged in into this database server which is running on my computer as the user root okay and if MySQL is not already running on your computer then you will not be able to log in so if you get an error here that MySQL is not running then you would have to go and check in my case what happens is on Mac OS yeah so on Mac OS it creates a it creates this MySQL option in settings so if I go to my system preferences it creates this option MySQL and here I can actually stop and start my server here I can also just set up some configuration about where MySQL is going to store all of its data right so by default MySQL will start up whenever my computer starts up so I can set all these configurations right so the MySQL is is a application that is always running on my computer and it starts up when the computer starts up it shuts down when the computer shuts down you will have to set it up separately on Linux or on Windows and when you do install it normally it all of this should be taken care of automatically okay so make sure that MySQL server is running and find the path to this MySQL binary which is on Ubuntu also I think it's user local MySQL bin MySQL on Windows it might be slightly different and then login into MySQL so login into the server as the root user and once you've logged it into the root user you will see a welcome message and you will see the version of the MySQL server that's running on my computer and now I can start interacting with it on this prompt so as you see here it says MySQL and then I can start typing SQL commands here okay so that's one way to interact with this database and I am currently running on my local machine but if there was a MySQL server that was running somewhere on the cloud and I had the URL to that server so I could also put in the URL there's a way to specify the URL when running this tool and you can use this tool to connect to any mySQL database anywhere in the world as long as it is publicly accessible and you know the username and password for it okay so if you have the URL to a to mySQL server you can log in into that MySQL server as well like for example I from my computer can log in into the Jovian production MySQL server and maybe make changes to my username and things like that okay all right so that is one way to access MySQL that is one way we will look at today but another way to access MySQL is using the MySQL workbench so there is another installation link that we've included here this is to download the workbench which is basically this graphical user interface so you can download the workbench this is a again 100 MB download and the workbench also let me open it up the workbench also connects to a MySQL server so when you log in for the first time you will see that it automatically detects that you have a MySQL server running locally but if you want you can also connect to something that is running somewhere on the cloud so again if you have the IP address or if you have the host name if you have what port it is running at if you have the username and password for a database server running on the cloud then you can get those details and connect to that database so typically in a company setting what will happen is the team that you're working with or the person that you're reporting you that you're reporting to will tell you that here is where our database lives so you should set this IP for our database you should set this port you should use this username we've created a username for you you should set this password and then you should then you can click connect or you can even test the connection first and then you can click connect and then you will automatically get connected to the company database and then you can work on the company database or your teams database and get data out of it or write data into it do queries on it in our case today we are going to just use the local installation that we have of MySQL so I'm just going to connect MySQL workbench to the local installation all right so this is what it looks like and the kind of queries that you type here for example I can type a query so for example I can type a query here on the MySQL command line tool show databases and I can type the same query here in the MySQL workbench show databases and then I can run it so this is the way to run it or you can also press Ctrl enter or command enter to run it and it shows the same information so here it shows the information classic models information schema MySQL performance schema Etc and here it shows the same information as a table okay so it's just a little nicer here everything is shown as text here you can interact with it a little bit you can click on things and such so those they are just two different ways of interacting with the same underlying database that's running locally right now and both of these can also connect to things on the cloud okay so with that out of the way we can finally start working with databases so let us set up a database for classic models in my case I have already set up a database let me just remove that database for now okay all right so once you are connected either through the command line or using the MySQL workbench to a SQL Server so the server code again could be running locally or on the cloud you can start writing SQL statements so the first thing that you want to do as soon as you're connected to a database server is to just list the databases that are present on the server so I can just type show databases and put a semicolon and that is going to show me the list of databases that are present on the server so by default right now I've just set up this MySQL server on my computer so these are all some of the default databases that MySQL already has so we definitely don't want to disturb any of these switches information schema MySQL performance schema and sys okay but once you create more databases you will start to see those databases showing up here so that's the first thing show database is going to show you a list of databases then the next thing you can do is create you can create databases so here is how you create a database you type create database and then you type the database name so I'm going to create a database classic models and let me just run the statement so I've typed create I've typed database and I've typed the name of the database classic models and now the database is created and I can check show databases once again and now you see you have classic models here as a new database that has been created now in this notebook what you will see is the statements are typed in uppercase create databases uppercase and one other thing you will notice is that all database names column names table names all of these are lowercase and they are indicated with these back ticks this is called a back tick this is just for visual separation so that you know that this is this is a SQL keyword and this is the name of a column or a database or a table so this is just for that visual separation so that when you're going through this notebook it's clear to you and you can also run it like this you can take this code and you can run it exactly the same way as it is typed here or you can type it without any of the back text and just in lower case and this is also perfectly fine except that it's a bit difficult to read okay so now that we've created the the database we can now show the database as well grade and if we try to create it again MySQL will give us an error so you can see here we run create database classic models and it says it can't create a database because a database already exists so we can also specify a condition to create the database only if it or doesn't already exist so if we say create database if not exists classic models so this is when we don't know if the if the if there's already a database with that name on our server so then we can create that database if it does not exist if it does exist then nothing happens so if we type this create database if not exists you can say you can see that it says query okay one row affected but there was no real change like if we say just show databases you can see that we have classic models information schema MySQL performance schema and sys so no change here on the other hand if we had typed create database if not exist classic models too and by the way I'm using the up Arrow key to cycle back to older commands so up and down is how you cycle between older and your commands so if I type create database if not exist classic models 2 you will see now that we have classic models and classic models too which got created okay so now we have several databases on our server and typically for every project that you're working on you would create a database or sometimes every team would have a database on the database server so there are many different reasons for why you may want to have different databases but for classic models the company we're just going to create this one database okay and when you are connected on a server and you want to work with a certain database let's say you want to get data out of the database you want to add tables remove tables add rows remove rows you have to tell which database you want to use so we can say use classic models and once you say that then MySQL is going to change the database to use or is going to point to Classic models as the default database to which all operations will be applied so let's say now if we do something like a create table operation which we'll see now and then we type the name of a table and the columns that it has then that table will get created inside the classic models database okay so whenever you get started always make sure that you are running the use statement to select the database that you want to operate on typically MySQL remembers this so you won't have to do it over and over but whenever you log in it's always a good idea to just run use classic models all right so that's how you use a database and one last thing I want to cover is how to delete a database to delete a database you just type drop so we have currently classic models classic models two information schema Etc so I'm just going to do drop database classic models too and a semicolon and now if we check show databases you can see now we no longer have classic models too that database was deleted I can also go ahead and drop classic models and then you will see that now we no longer have classic models either okay now be careful about drop because as soon as you run the drop statement the data will be deleted permanently there is no trash and there is no warning there is no confirmation and typically your company will not give you access to drop databases for good reason but regardless you should be very very careful about running the drop database command okay so as an exercise you can now just try creating deleting using some databases using the commands that we've covered and also try and figure out how to rename a database so now you can try and look it up on the MySQL documentation or just by searching online how to rename a database okay next just before we move forward let's just recreate the database classic models because we are now going to create some tables with it so I'm just going to run create database if not exist classic models and use classic models all right so now our database is created and we can start using it okay let's now talk about how we can work with tables now we remember the entity relationship diagram that we created for the classic models company we can now start adding some tables based on the ERD and there are a few statements there are a few four or five statements that we need to understand to work with tables the first one is to list the tables in a database now once you select a database using the use command you can list the tables in a database using the show table statement so if we go here and we say use classic models and then we say show tables you can see that currently it says empty set because we've just created the classic models database so it does not have any tables but we know that it is empty so we know that much then to create a table we can use the create table statement and here's what the create table statement looks like you type create table and then you type the name of the table and then you have this you open these brackets or these parentheses and then you type the name of a column and then you type the data type of the column and then below it you also have some constraints about the tables or some other information that you want to specify about the table so I just want to show you an example of what a create table statement looks like so here is the ERD diagram for the offices table now for the offices table we have this office code which is the unique identifier for each office or this is also called the primary key in SQL then we have all this information City phone number address line one this is all required and then we have address line two State this is optional information then we have country postal code territory this is required and then we have office location which is optional so this is what the create table statement for office for offices looks like so we say create table offices and again you can skip these backticks these are just for convenience sometimes column names can have spaces so to handle things like spaces we have backticks but here you can just use you can just use it to visually identify what is a SQL statement and what is a name of a database or a column or a table so we say create table and then we type create table with the name offices and then we open up this bracket and we say office code so that is the name name of the first column and office code is going to be aware care so this is the data type and we'll talk about the data types and so it is going to be a character list or a variable number of characters that's what it means where care of up to size 10. so office code can be one one character two character three character up to 10 characters then we are specifying here a constraint that it is not null which means that it cannot be empty then we have City again which is a wirecare 50 so it can be a string where care simply corresponds to a string essentially it can be string up to 50 characters long again not null then it will have a phone number again it will be a string not null it will have an address line it will have a second address line and this time it will this can be null so we don't necessarily need to have a second address line it can have a state again this information can be null it can have a country this should be should we not null a postal code a territory okay so territory would typically be I think it would probably be country or maybe the territory which the office operates in okay so we'll see an example of this and finally at the end of specifying all the columns we are also specifying this constraint or this additional piece of information that we want office code to be the primary key for this column so what this does is the primary key constraint uniquely identifies each record in the table so the office code value in the office code column will uniquely identify each office and what that means is that you can only have one row with a specific office code you cannot have two offices or two rows of data with the same office code and it also cannot be null and that's why we have specified not null here already okay and a table can have only one primary key constraint so you you can select multiple columns you can say that the primary key is office code comma City although in this case it will not make sense sometimes it does so you can select multiple columns as the primary key so a primary key can consist of multiple columns but you should only have the statement written once so if you want to select office code comma City so both of those together as a primary key then you you should write primary key office code comma City and not primary key office code and in another line primary key City okay that's a more special case that doesn't really happen so for now let's just take this code and let us run it here in our MySQL command line okay and we run it and as soon as we run it it says query okay zero rows affected so whenever you see okay that means that it has had the intended effect so now if we run show tables again you will see now that there is one table in classic models the table is called offices okay now talking about the data types you see wire care if most of these are bad care but there are several supported data types in SQL so here are some of them you can have numeric data you can specify that a column is a bit bit means it's going to be a zero or one or a tiny integer I think that is going to be one byte which means it can take values from 0 to 64. a small integer I think that would be four bytes a normal integer I think that would be a small integer would be two bytes a normal integer would be four bytes a big integer would be eight bytes etcetera so the differences between all of this is simply in the range of values that they can hold bit Can Only Hold zero to one big end can probably hold from minus 2 billion to 2 billion so depending on what range you think that your numbers can take you can choose the right data type and if you're unsure just go with int or begin just to be safe a lot of companies have had to change from int to begin once they hit maybe a billion users so not many such companies but that is what that was a real problem they probably didn't expect to hit a billion users and they had to change from in to begin for user IDs numeric user IDs then you have the decimal data type so if you're sure about how many digits of decimal you want then you can use the decimal data type as well or you can also use a numeric data type I think this allows you to put in any kind of data something that you would have to look up you can use the float data type to work with floating Point numbers here you can specify how many digits of precision you want and then you have the real data type as well so again not all of these data types are supported by all SQL software because every all companies have implemented their own version and they have their own optimizations so you would have to look up whichever package you're using like for MySQL you would have to look up which of these numeric types MySQL supports and then there are date related types so you typically have a date time and then a date time or a time stamp data type for working with dates then you have the character types so you can have a character which is a single character or you can also specify when creating a cad data type how many what is going to be the exact length so if you have if you are sure that you will always have five characters in a column you use care or care five so just as we have written wirecare 50 you can write five and then you always have to put in five characters or you can put in where care and wear care means that you can put up to 50 characters so if you type wirecare 50 that means you can put up to 50 characters and then you have the text data type which is typically used for very large strings so if you want unbounded if you don't want a limit on the number of characters then you can use the text data type now what is the benefit of not using text maybe using wire care it is efficiency when you can specify the number of characters your data can take based on that the database server can perform some optimizations to make queries faster but if you want to use the text data type then you are giving up on some performance then you have these Unicode characters which is a special case of characters you can also store some binary data and then you can also store something called a blob which is like a large binary object so you can store XML Json and these are more specialized types that are not supported by all SQL servers but numeric date and characters or strings are the most common data types okay so that was data types and next Once a table is created you can also check once the table is created you can also check the table that the table is created using show tables here we've typed show tables and we were able to see the table and if you want to get information about what columns the table contains you can use the describe command so let's type describe and let's type the name of the table the name of the table is offices and when you type describe offices you can see here these are all the fields office code city phone address line State country postal code territory all of these are where care some of these are nullable which means some of these can be null and some of these cannot should not be null and office code is the primary key okay so still this is still information about the table this is not information in the table it's just information about all the columns of the table and you can also specify default values for some of these columns let's say you want to specify a default value of phone number to the phone number of the headquarters so that there is always a number listed on your website so you could have specified that the way to specify your default is to say let's say phone number not null and you could instead say here phone number default and then you can give the phone number that you want to have as the default phone number okay maybe plus one that's the default phone number so that will be the default phone number that will be put in for any Row in the data okay so now we've created a table we have seen what its Fields look like we have seen that that table got created let's put some actual data into the table so to insert data into the table we use the insert into statement so here's how the insert into statement works you type insert into and then you type the name of the table so the name of the table is offices and then you type the columns the names of the columns that you want to specify so I want to provide the office code I want to provide the city I want to provide the phone I want to provide the address line one and maybe I won't provide address line 2 because I don't have that information I am not going to provide state I'm going to provide country I'm going to provide postal code and I'm going to provide territory okay so we say insert into offices and then we give the list of the column names that we are going to supply and then we say values and then we provide the values for these column names so okay now I'm going to insert create this new office with the office code AAA and it is going to be in Bengaluru and the phone number is going to be plus 9 1 that and then the address line is just going to be well let's just put it as 1 mg Road and then we have a postal code let's just put that as five six zero zero one oh we also have to specify the country so the country is India and finally let us put in a territory here so I guess that this will probably serve the territory of Asia right so let's then put the semicolon here so what have we done insert into name of the table list of the columns that we want to supply information for put in then type values then give a list of the actual values for each of these columns and then we can hit enter and you can see query okay one row affected and now this is going to insert the data into the table how do you get data out of a table well the way you get data out of a table is by typing select you can type select and then after typing select you type which columns you want so let's say I just want to get the office code and I want I want to get the city from the name of the table the table name is offices and then I put in a semicolon yeah sorry no no brackets here so you type select and then you type the name of the columns that you want to select and then you say from offices okay and you can see that it starts to get a little bit confusing now because everything is written in lower case and that's why we often write the column names in lower case and we write the SQL commands in uppercase okay and sometimes we also put backticks just to make it super clear and especially if you have names in if we have spaces and column names okay so select office code comma City from offices so now it is giving us the office code and it is giving us the city for all the rows of data in the database in the table offices so we have inserted one row we inserted a row with all this information and then we viewed it using select now if we had inserted multiple rows we would be looking at the data for multiple rows of data how do you insert multiple rows inserting multiple rows is the same as inserting one row you just say insert into offices and then names of columns and then type values and then you give one set of values then you give a comma and you give the second set of values and so on so let's insert multiple rows I'm going to copy insert into offices and then I have a bunch of rows of data here so I'm going to copy all those rows of data okay it's going to be a bit difficult to copy this all right let's just copy it this way now this is a lot of code there so I am going to instead of using the MySQL command line which I can do I can just paste the command paste on the command line here I'm just going to show it to you on the workbench okay so I'm just going to type it here into the workbench you can always just click new query and oh sorry yeah you can just always click this new query here and then just type it so here now we have insert into offices we have all these columns that we want to insert and then the values we have on we have one one set of values two set of values three four five six all the way up to seven so we are inserting seven values and at the end you will notice a semicolon here at the end of the last statement and we can run this command and now we get a success result here oh we need to select a database first so let me cut this and let me say use classic models and let me run that so that has been selected the database is selected then let us paste it back okay now we have insert into offices and now we run insert into offices and you can see that it it executed successfully so now we have inserted into offices and I can create a new query here I can yeah so I can now remove this and I can type select and if I want all the columns I just type star so select star from offices and then I run it and that is going to now show this data in this tabular format okay so now you can see that we have all these offices San Francisco Boston NYC Paris Tokyo Sydney London Bengaluru and this is the same information that we had shown that we had inputted here that is also available so through the command line and through the workbench we are connecting to the same database and we can run these commands in either place and I can type it here as well select star from offices so now when I say star it is going to select all the columns and here's what that looks like it's a bit messed up the output because it's trying to display it all on one line but if I zoom out a little bit you should be able to see the output yeah so you can see the output now when I do select start from offices it is giving me the same table that I am able to see here on the workbench okay so that is insert and select just a quick reminder on how these work so you can say insert into and then provide the table name provide the names of the columns you want to insert provide the values and then provide lists of values to insert so list of rows and if you're providing data for all the columns then you can skip this part which is the column names so you can just say insert into table name values and then you can give lists of values and that will work fine too for example here when we are inserting offices we are using all the columns here so I can actually just completely skip this last thing I can skip this names of columns and I can just say insert into offices values and give it the list of values then to view the data the simplest way to view data is using the select statement so it has the syntax select column one comma column two comma so on from table name and you can also view the data from all the columns using simply saying select star from table name okay so that's how we put data and get data so now we've covered C and R create and read and we'll look at update and delete as well and here are some exercises for you try adding some more entries into the offices table using just the required column so an example that we typed out on the MySQL command line try typing it out yourself try doing it from the command line try doing it from the workbench and see what happens see what happens if you don't provide a value for a column marked as not null okay maybe here if I go back to one of these and if I try and change this let's say I changed the office code to aab and I provide I don't provide a value for territory which is supposed to be nonnull let's see what it's going to give us so it's going to give us an error but you want to do you want to make these mistakes and you wanna understand what kind of Errors you get like here it says field territory doesn't have a default value so look through it and try to break things and try to become familiar with errors so that when you encounter them you will be able to debug them more easily so try adding an entry with the primary key matching an existing entry so maybe let's try that let's try putting in AAA again and let's just make it Bengaluru 2. and let's just put in territory Asia here and let's add back territory here so you will now see that okay I probably have yeah there's probably a syntax error here okay I made a syntax error here somewhere but if I just try to insert the same data again like a Bangalore root 2. you will see that now it says that there's a duplicate entry AAA for the key officers.primary and that data is not inserted okay so test these out the more you try the more the better you will understand how some of these things work and try and retrieve and display just the city and phone number information for each office that has been created so just do a select statement and try that out too and that's the first table that we've created we've put some data into the table we have looked at the structure of the table and we've retrieved some data from the table as well next is the employee stable so we've created one table and now we are creating a second table and we will connect this table to the first table and a quick note if you want to first delete a table then you can use drop table so if you type drop table that will delete the table with all its data like if I type drop table and then I type Offices here that's going to delete the offices table I don't want to do that right now because I've put some data into it and you can also have something like this that if the table exists you can drop it so if we type drop table if exists employees this is not going to make any change because if I do show tables there was no employee stable before and there's no employee stabled now but whenever you're creating a table you can always it's a good idea to First maybe drop the previous table if you're sure that you don't need the old data if you want to Fresh table to be created so you can just drop the previous table if you if you want right so that's why we have this statement here for you as well so okay let's talk about creating the table employees so let's copy this code and here we have an employee number so that's an integer our first encounter within teacher and here we're saying 11 so I think what we are specifying here is I I think it might be 11 bytes or 11 digits I'm not sure I think it's going to be 11 bytes I'd have to look it up then we have the last name which is a wire care or a string a first name is a string extension this is their phone number extension so they will be at a certain office and that's why we have office code here and then we have an email which is again a wire care of a hundred and then we have a reports too so two interesting things here one is office code so we have now A office code column and this should ideally contain a value of a valid office code how are we going to ensure that we will see and second reports to and this can be null so office code should not be null every employee belongs to an office but reports to can be null because obviously there will be somebody in the company who does not report to anybody but otherwise reports to and maybe some people may not have been assigned a manager or a reporting person so reports to can be null but reports to should be somebody's employee number let's say you have siddhant and biraj and if barrage reports to siddhant then reports to in the entry for biraj should be the employee code or the employee number of Siddharth okay how do we ensure that we look at that then we have the job title this is just a simple string and we are setting here that primary key is employee number that makes sense we want to uniquely identify each employee with a primary key and this was going to be not null so that's fine too and then we have these two in two statements foreign key so here we are saying that reports to the column reports to references the table employees and in the table employees it references employee number okay that's one and then we have another foreign key office code so here we are saying that the tape the column office code in this table references the column office code from the offices table okay so there are two references here one is a one is a reference to another table one is the reference to this table itself but probably to a different record so what we are saying through this or through a foreign key in general is that we want to ensure that the office code column contains a value which matches a value in the office code column from the offices database now from the offices table right so for every employee there should be an office code and that office code should contain a valid value from the offices table and that is what the foreign key constraint ensures and we will test it out in just a bit and then similarly we have foreign key within the same table we want to say that the reports too for any employee should be a valid employee number from the employees table and it can be the employee number of a different employee so that is or enforced using a foreign key a foreign key is simply you're saying that this number or this column has a special property that it refers to a value from another table and there is one important constraint with foreign key the value that you reference to must be the primary key in that table so for example here we are referencing office code of offices so office code must be the primary key in the offices table now again this is not a criteria that all SQL software or all relational databases have sometimes they do sometimes they don't but in general just to be safe you should always assume that you should only reference primary keys okay so let's try it out let us insert a value into employees so let's just let me just grab this insert into employees the values one zero zero two so that's the employee code Murphy Diane x5800 and so this is what is this employee number last name first name so Diane murphy1002 and their extension is 5800 and their email is D Murphy at classicmodelcars.com then their office code is one and do we have an office code one we do have an office code one one is San Francisco so that means they belong to the San Francisco office then reports To None So they do not report to anybody and in fact Diane Murphy is the president so they're the boss so let's run it oh it says employees doesn't exist or that's because I dropped the employees column I never created it in the first place all right so let's first create the employees column A create table employees let's take this and let us run it here so now the employees column is created and then let us insert some data into the employees column I am just going to insert this one person right now Diane Murphy and that's it and let me just put a semicolon here and insert the person so now if I do select star from employees you should be able to see sorry about the formatting but you should be able to see this information about this person Diane Murphy with the employee number one zero zero two as the office code 1 and reports to nobody let's add another employee maybe let us set their yeah let us set their office code let's set their employee code to 1002 or 1003 and let's call it Daniel and let's give an invalid office code here maybe let's give a hundred and let's see what happens so here you will see that it cannot add the child row so this is called a child so the employee is now called a child of office because it has a foreign key constraint and the foreign key constraint fails you can see that constraint that this should be a valid office ID fails and that's why you cannot add that row okay that's how the whole thing works all right so maybe let's add all these employees and then we will move forward but to add all these employees there are going to be some issues because I've already created an employee with the primary key one zero zero two so before that I'm just going to delete the employee that I've just created you see right now I have this one employee Diane Murphy so I'm going to delete the employee with employee number uh 102. so I can say this I can say delete well actually let's come back to delete later for now I'm just going to drop the table into entirely so drop table employees okay so now the table employees is gone if I do show tables once again and now I can create the table once again I will go create table employees and then let us insert all this data so we have a bunch of employees here I'm just going to capture cap copy all of this and paste this command if you want to do the insertion here so maybe let's just do the insertion here so we're just going to insert all of these employees how many of these we are going to insert about 23 employees using the MySQL workbench and now these should be created so now if we check select star from employees you should now be able to see all the employees that we've created okay now here are some exercises for you try inserting an entry into employees with an invalid office code you saw what happened but try it maybe from the workbench try inserting an entry into employees with an invalid value for reports too okay that is something that we haven't tried so reports too can either be null or it must be an existing employees ID or employees number and try this try creating a new office location first and then try adding some employees to the new location so when you open a new office first you will have to add a new office object or a new office record and then you will have to add an employee add a bunch of employees for those office records and maybe you will have one office manager and that office manager will probably report to the president and then you will have a bunch of employees at that office and they will report to that office manager okay do try out that exercise okay moving ahead now we have the customers table so now at the by this point you are probably getting the idea there is a primary key there are a bunch of required columns there are some optional columns and then there are there is some there is this foreign key so every customer has a sales rep optional sales rep so you can take this foreign key sales rep employee number and that should reference in the employees table some employee number and you can see here that sales rep is an integer but it can be null so I can just copy paste this I can take this create table if not exist so this is another way to go about it create a table only if it not it does not exist all of these are slightly different if you try to create a table without this so if you just say create table customers if there's already a table customers it's going to fail if you drop the table first then it's going to delete all the data if you say create table if not exist then if the table exists it won't do anything if the table does not exist it is going to then create the table so think about what is the right thing you want to do and based on that use these drop and not exist and does exist and play around with them and see what they do okay but I'm take I'm going to take this create table put it into my workbench and just execute it and this should create another table yeah this should create another another table customers and on the left if you just check the schemas tab you should be able to see all the tables that are present so now you see here you may have to refresh it a couple of times but you have this customers table you have employees and you have offices and when you click on a table you will also be able to see the information about that table like on customers you have customer number customer name last name first name so this is our MySQL workbench makes it a little easier for you you don't have to type a lot of commands like describe and such you can just browse the tables that are there you can also browse the information about tables you can in fact even check values within the table I believe if you just click this button it is going to automatically run this select star for you so if I just click this button here it's going to show all the employees by running a select star from classic from employees right and this is one other way to write something you will see often you can also type database name dot column name or sorry dot table name and then put a query so if you're not already set a default database using the use command like use classic models you can just put select star from classic models.employes so this is database dot table name okay so here's an exercise add some customers to the database using data from a SQL file so somebody asked what to can you get data at data programmatically can you add data which is already there somewhere else so let me open up the SQL file and this equal file contains code for everything that we are doing today of this classic models SQL file and in this SQL file you will find some rows for inserting data into the customer table so let's find it let's see so here we have a bunch of create table statements then you have these insert statements for customer for products and then you have an insert statement for offices employees and okay here is where we have an insert statement for customers so I'm just going to grab this this seems like a whole bunch of insert statements here so these are all the insert statements for customers I'm just going to go back to the workbench and I am going to do a new query think not sure which one it is never mind I'm just going to edit it here I'm just going to go to query one paste this all right so it seems like there's a lot of insert statements I'm not sure why they wrote it like this they could have written it all in a single insert statement too but in any case we have 125 customers you can see here you can see the details of these customers they are so these are typically customers are stores remember Gift Stores and toy stores by the products from classic from plastic models so customers are stores and then each customer has a point of contact if I go back here you will see you have a customer name and then you have a customer number customer name is the store name contact last name first name is the information about who to contact their phone number Etc so all that information is captured here you will also see an employee ID so this one is probably the employee ID and then you have okay so here there's also some kind of a location data you see sdg geom from text Etc so you can also put location data into MySQL that's pretty interesting so let's run this let's see if this gives a correct result yeah seems like it was able to insert data into the customers table all right so now we've inserted data for about 120 customers and we should be able to see that here in the response yeah so you can see we have data for over 100 customers and that's great and some of them have a sales rep some of them don't have a sales rep customers also have a credit limit and such okay so now when you start getting to this point where you have a lot of rows in your database then it may not make sense to look at all the data at once that is where you may want to select some data you may want to query some data you may want to filter out data based on a particular condition and that is where the where clause in the select statement becomes useful so you have this where clause so you have this Clause called where that you can include after your select So when you say select star or select some columns from the employees table you can say where job title equals sales rep now if you go back and check the employees table here you can see that employees table there is a job title here and let's say if you only want to get a list of the sales reps so we say select star from employees where job title equals and then whenever you want to put an actual value for comparison you use double quotes very important sales rep okay so select start from employees where job title sales rep and maybe I can also select specific columns so let's say I want I just want to select the last name and I want to select the extension actually let me just select the office code okay so last name first name last name and office code from employees where job title is sales rep and now it starts to become more useful so now we know that at office code one we have Leslie Jennings who is a sales rep at office code 2 we have Julie Farrell who's a sales rep at office code 3 we have George wanu who's a sales rep and so on so the where Clause supports a bunch of operations where supposed to equal to which is what we have used here it supports less than and greater than so both of these work with numbers and with strings and with dates so pretty much all data types with numbers they expect as expect they work as expected 3 is greater than 2 and 3 is less than 5. which strings they compare the alphabetical order so a is less than b and any string that starts with a is is less than any string that starts with b and any so let's say a a is less than a b and you can have this lexicographic or alphabetical order from A to Z is lower to higher you can also have less than equal to or greater than equal to and you can have not equal to now sum variations use this less than greater than some relational database software use this not equal to so let's see what MySQL uses how about we first try not equal to okay MySQL seems to support this but you could also have in some places this kind of a statement so seems like MySQL supports both right if I do star here we can verify if that is the actually the case yeah so we are now getting the list of people who are not sales reps by using less than greater than or we can also do are not equal to here all right so here's what that looks like you can also combine expressions in the where Clause using and and or so let's say you can say things like select column one column two comma from table name where condition 1 and condition 2 and condition three so for example if we want to select the sales rep in San Francisco so what San Francisco let's first open up offices and in offices let's check San Francisco that's office code one so if you want to get the sales reps in San Francisco so we say select start from employees where job title equals sales rep and we can put in the additional condition office code equals one and again we should put this in quotes ideally okay just a single equal to yeah so now you see here we have the data for Leslie Jennings and Leslie Thompson their extension and their email and both of them are in office code one which is San Francisco so that's how you filter data out like I can I'm just showing showing you here it's going to be a little bit bigger here so that's how you filter data out from a database table you use the where clause in where Clause you can have one of these conditions you can also have you can also do something like this you can use in between and like and then you also have this option to negate things so you can also negate a condition by saying where not condition that's another thing to just keep in mind and a where Clause can be used with select but they can it can also be used with update and delete statement so we were talking about delete earlier so maybe let's check out the delete statement once and now from this point on mostly you would just have to look up how certain statements work so here we say delete from table name where condition now remember we had this one office that I had inserted initially called Bengaluru and this side the office code AAA now if you want if I want to delete this office then here's one thing I can do let me go back here I say delete from offices where office code equals AAA and that should have deleted the Bengaluru office let's see so you know you can see that we no longer have the Bengaluru office anymore because we've just deleted it now here I've deleted exactly one column but I can delete multiple columns as well let's say if I wanted to delete if I want to fire the sales reps in San Francisco so then I would do delete from employees where job title equals sales rep and office code equals one right instead of Select star I would just type delete and then instead of just showing this information it would simply remove these rows of data from the database so that's that and let's also check update similar just like delete we have update so let's check update to now here's how update works you say update table name and then you set the value of column column one to Value one column two to Value two column three to Value three where a condition holds true so let's try update maybe let us change the reporting person for Jenny Leslie Jennings and Leslie Thompson so who are we going to set them to report to maybe let's set them to report directly to the president maybe Diane Murphy directly wants to talk to the sales people in San Francisco so we want to get these employees where job title sales rep and the office code is one and we want to update their values so let's see we say update what does that code look like update set column one equals value one column two equals value two okay so we want to set update employees and we want to set their reports to to one zero zero two again we should put in quotes here update employees set reports two to one zero zero two and then we want to have the WHERE and in the where Clause is where we want to add the selection where we are only selecting the sales reps from San Francisco so where job title equals sales rep and office code equals one okay all right so the good thing about SQL is that it's very readable so update the employees table and set reports 2 to 1 0 0 2 where job title is sales rep and office code is one so only for people in the San Francisco office or sales reps you want to update their employee we want to update their reports too and let's just do a select star and let's make sure that that was updated select star from employees yeah so now you can see with Leslie Jennings and Leslie Thompson they now report to one zero zero two okay if we remove this we can also see that no other rows were affected you can see that there are very few other people who actually report to one zero zero two all right so that is the select Clause the where close the update command and the delete command so here are some exercises for you try and list customers in the United States with a credit limit higher than a thousand dollars so you'd probably start out something like this you would say select star from customers where country equals I think it's USA you can check this out so these are all the customers in in the USA quite a few of them but we want customers with a credit limit higher than a thousand dollars maybe we probably want even an even higher credit limit but let's see let's try a credit limit higher than thousand dollars so here you would say country equals USA and then you would say and credit limit greater than a thousand or let's try ten thousand let's see if there are any more than ten thousand more than a hundred thousand yeah so there are nine rows with more than hundred thousand but with a thousand there are 35 rows so you can see that changing the credit limit is going to change the number of results all right then here's one more list the employee codes for the sales representatives of customers in Spain France and Italy okay how would you do that well you would say select sales first let's describe customers so let's say describe customers so we have the sales rep employee number so now we would say select sales rep employee number from customers and then we can put in a where and now we want the location of the customer or the country and we can put in an in and then I think we can given a give it a list of values so we are concerned with we are concerned with Spain France and Italy so we can now put in pain I think we have to use double quotes here so Spain France Italy okay so here is the list of all the sales reps who work with customers in Spain France and Italy okay now I can probably just put put together a list of these so there's one three seven zero one three one three three seven uh one seven zero two one four zero one and one four yeah that seems to be all so there are only about four or five such sales reps and then the question is make another query to list the names and email addresses of those employees so now we can do select let's say first name last name email from employees where employee number in and then give it this list okay so now we have Louis bondor Gerard Hernandez Pamela Castello and Martin Gerard so these are all the people who are selling to customers in Italy Spain and France so this is the kind of q a that you can do using SQL queries here's one more change the job title sales rep to sales representative I'll let you work on this you can use update to do this delete entries for the sales representatives working in London so first you find out the sales rep first you find out the code for the London office how do you do that well you can use a select statement to get the data for London then you use that code that office code to delete the entries for those sales representatives so you'll have a where Clause with delete then you have show list of employees who are not sales representatives I think we've already done that and here's one interesting one show a list of customers with toys in their name so this is where you would have to use the like statement so if I just click through here you can see this is how the like statement works so you can say select columns from table where a certain column is like a certain pattern and the pattern can be a string or the pattern can be something like this you can have a percentage or percentage a so whenever you have a percentage that means 0 or more characters so if you want to just check for a somewhere in between like if you just want to check for or somewhere in between then you have percentage or percentage so percentage represents zero or more characters and then underscore represents exactly one character okay so check out this reference on how exactly it works what I'm going to do is I'm going to just try and solve this answer show a list of customers with toys in their name so let me see select star from or maybe just select the customer name and the country from customers where customer name like and here is where we can put in percentage and then we want toys and percentage and let's run that oops I think I had to close it so let me just undo that percentage twice percentage and let's run that okay so it seems like you have land of toys Incorporated in the USA you have toys of Finland in Finland and you have toys for grownups in USA and boards and toys in USA so it's a very basic selection you can't do a lot of advanced regex kind of selection but a very basic selection can be done a very basic search can be done using like okay then you have product lines and products so you have a bunch of product lines like motorcycles flights uh planes cars Etc and then you also have products so you may have different models of motorcycles different makes for which you offer small scale models so here is what they look like product line is a very simple table it contains the product line it contains some description so it seems like it contains a text description here for some reason there's also an HTML description maybe this is going to be used on the website and there's also an image yeah so let's just take create the product line stable once again I'm just going to paste it here and that will create the product lines table and similarly we have the products table as well which has a product code product name product code is the primary key it has a product line which is a foreign key and it has a product vendor description it has a quantity in stock so that's a small integer then it has a Buy price so which is the price at which we are buying let's say the raw materials for the product or sort of the manufacturing price then we have the retail price so this is the price at which we are selling the product so that can be used to just determine the profit on the product so here's our product right and then once again you can use this link to download some products so here we have the SQL file and then from the SQL file let's see let's find some product lines and some products so let me get all these product lines I am going to come back here and I'm going to just put all these product lines in and I'm going to just run this so we have put in all the product lines classic cars motorcycles planes ships trains truck vintage cars and let's also put in a bunch of products let's get all of these products from this page okay quite a few products and let's put it in there there you go so now we should have a bunch of products and a bunch of product lines as well okay now once you have such huge tables and such huge such a large number of products and product lines and such you may want to do some sort of ordering and you may want to also limit the number of results you may not want to look at thousands of results all the time or even hundreds you may just want to look at the top five or top 10. so if you want to order data then you just include order by at the end of a select statement and you just mention which columns you want to alter by so column one column two so first it will try to order by column one if the values in column one are equal then it will try to order by column two and so on and then you have the ascending and descending for example if you want to list customers by country you would say select let's say customer name comma country from customers order by country and now you can see that you have customers ordered by country Australia Austria Belgium Canada Etc you can also then use a limit Clause if you just want to then see maybe just one page of data something that you can display it once so you can also type here limit 10. and now you just see 10 and of course you don't have to use order by with limit you can use a limit without order by as well so if I just do limit 10 so this is now the natural order or the order in which the data was inserted that is the most that is the default order that is used so this is how you combine order by limit and you then you can also combine it by where Clause maybe you can also only check for customers which have a credit limit greater than a thousand dollars so let's say select customer name country from customers where credit limit greater than a hundred thousand and order by country limit five right so maybe also get the credit limit here so that's how you combine all of these here we are combining select we are combining where we are combining order by and limit and this is what that looks like okay so here are some exercises for you identify the five most expensive products from the plane's product line identify the products that are about to run out of stock so products which have a quantity in stock less than 100. and list 10 products in the motorcycle category with the lowest Buy price and with more than a thousand units in stock okay so there are a lot of things you'll probably have to put together everything that we have covered so far order by and not order buy but you will have to put together a limit you will have to put together an order buy as well because the lowest Buy price and you have to put together a couple of conditions which is the category product line and for the product line you will have to figure out what the product line code for motorcycles is and you will also have to add a check on the units in stock okay then you have these orders order details and payments tables so I'll let you build these as an exercise you have the code you have all the information here so you can create the order order details and payments tables using the create table statement and include proper primary key and foreign key constraints so for example order has a customer number order details has a order number and a product code and then payments also has a customer number and the check number is the primary key and then you can use the same sample data that we've been using so far to populate this too okay next I just want to briefly touch on how you can modify the structure of a table not something that we will do right now but if you want to add a new column to a table here's how you do it you say alter table table name and then add and then the column name and the data type and that's going to add the column maybe let's do it very quickly for employees so alter table let's see employees the let's let's check the employees table first employees so describe employees and now let us maybe add the date that they were hired on so we will add we will say altered table employees what's that add yeah add and then the column name hired on and we want it to be a date okay seems like that was added so now if we check describe employees you should see that there is a hired on column and if I want to insert an employee insert into employees if I insert an employee now I can probably then I can probably then add some information let's say set employee reports to etc etc so we can probably set the hired information right so hired on to one zero zero two and let me change this to an actual date so 2020 12 0 1. okay so now if you check employees again let me just get these employees so select star select star from employees where job title is such and data search so you can see now with these employees we have a hired on column and in the hired on column the value is 2020 1201 and for the other employees you will see that the hired on column does not have that value so that's how you add data nothing too special nothing too complicated it's just one more thing to know you add a column and similarly you can drop columns using the drop column command you can modify column using the modify column command you can rename column using the rename column command and here you say rename old name old column name to new column name after alter table so as an exercise try adding removing and modifying one column in each of the tables created and what happens check what happens when you remove or rename a column that is a primary key because that is the primary key which is also used as a foreign key yeah so do try that out so if you change the employee code for example the employee number now that is used in a bunch of different tables like the customer table so what happens when you change the employee number column try it out that's the best part about interactive environments like this you can try out things and you can break things and figure out what happens now you can also place a bunch of SQL commands into a DOT SQL file like this one that we've been looking at so far and then you can execute all of these commands together you can see that here we are dropping the database we are then creating a database we are then using that database then we are creating a table offices we are creating a table employees we are creating a table customers product clients products orders order details payments and then we are inserting data into each of these tables right so this SQL files is basically what's called a database dump that somebody had this database and then they exported it and we'll see how to export it as well but now you can take this data and import it into or just run all these SQL commands and automatically import the data into your SQL Server into your SQL database and here is how you do it so you there are two ways to do it one is through the command line now through the command line let's say go back here I exit I exit the actual command line and let me come to my desktop which is where I have this file database.sql so I have this file here database.sql and I can check this file it contains exactly what I was looking at I have just downloaded this file here so I find my MySQL binary which is in slash user slash local slash MySQL slash bin slash MySQL so this is the MySQL command line tool and then I say minus U root so I want to log in as the root user and then I also say minus P because I want to use a password and then this is the magic part where you use this less than symbol and I'll tell you how to think about this so you have this less than simple database.sql so what you're indicating here is take the data in database dot SQL and passes at pass it as inputs to this command so now we're no longer opening up the console but we are taking all of these commands inside the SQL file and passing it as inputs to mySQL which we are logging into as the root user so when I run this let me just just to make things very simple what I'll do is I'll first just open MySQL slash user slash local slash MySQL slash bin slash MySQL so I'm just going to open this first minus U root minus p I'm just going to open this first and I'm going to drop database classic models okay and let me just do show databases and you can see that we don't have classic models here so now we have we run this code MySQL minus U root minus p database.sql and this should take all those lines of code and it should execute them against this server yeah I'll take a minute or two but it's done and now if we come back here into this or if we just open up MySQL now and just log in and do show databases you can see that we now have classic models and it is now showing a showing up in a upper case because in this script file the database when it was created it was created with this uppercase in uppercase M but as such you can still just say use classic models without upper case we can just say classic models and it should work just fine and now you can do show tables and you have all these tables customers employees offices Etc and now we can do select star from offices and you can see that these are all the offices that we have right so even though it shows up as uppercase here because that's how it was created but you can still access it as lowercase uppercase or this title case or whatever right so we have taken all that information and then we have taken all these lines of SQL code and we have executed them on the database so that's how you execute data one other way to do it is you can also do it this way from MySQL workbench you can click on this or you can see open SQL page it open SQL button so you have this open SQL file button here the second button click on it and go to desktop and just open it up now depending on which database you're using the UI will be a little different but the concept here is that you can do this you can take a bunch of SQL code and then you can execute all at once and it should do the exact same thing so here it drops the database so it's going to empty the database and then it's going to add all this information and now if you just refresh here you should find classic models and inside it you should find these tables and then you can maybe click on employees and you can see all the employees so you have all the employees just fine one other thing you can do is you can export data out so there are a couple of ways to do this one is to use the MySQL dump utility so the same place where you have the MySQL utility which is at let me just exit here so we have at user local MySQL bin again this will be different on Windows or probably different on Linux as well but you can find it quite easily just look it up so user local MySQL bin MySQL right so this is how you open the command line this is what we have been looking at so far but you have a MySQL dump utility so you can call MySQL dump and I want to use the root user and I want to use a password and what is how does it work so we have to provided the name of the database so we provide the name of the database after minus U or even at the beginning so MySQL dump the database that we want to dump is called classic models and then there are certain options that you can specify that do you want to have these drop table lines so if you see here before every table creation there's no doubt there's no drop table statement but we can add that drop table statement as well by specifying this option and again you would just have to look up the documentation online to figure out how exactly this all these options work but yeah MySQL dump draw add drop table classic models minus U root minus p okay and that has created this SQL file oh but we forgot to write it to a file we want to actually write it to a file so right now it is just printed it out so what we want to do is instead of printing out all this information we want to write it into let's say DB dump dot SQL okay and just like that this should be now there should be now this file dbdump.sql we should have all the information that we're looking for so it has it has this drop table if exists customer then create table and then below it it has the data for customers so insert into customers and you have all this customer data and then you have data for employees then you have data for offices and so on okay now there seems to be some encoding error here for some reason this is treated as binary I think it's probably the office location that is causing an issue but as such everything seems to be just fine and then you can take this and then you can use that to reload the data now here it does not have the commands to actually create the database I'm sure there is some option that you can specify in SQL dump to create the database if it does not exist and drop an existing database as well so I'll let you figure that out but yeah but this is what we are interested in and this is something you can do if you connect to a remote database right now we are connecting to a local database but if you connect to a remote database on some server you can export all its data into a SQL file and then there are converters in in pandas what you can do is you can actually load up SQL files maybe let's try that maybe let's do file open here and let us upload I'm not too sure but I think this might work so let us upload database.sql yeah and you should be able to do something like this import pandas as PD and then PD dot read SQL and let's see oh I think this needs to be a SQL command and a connection so it's not going to work with a SQL file you need to actually connect to a database so we look at it the next time but yeah but there are ways to read that SQL file there are ways to convert SQL files into a bunch of CSV files I know that there are ways to convert that into a bunch of different formats so exporting it is useful because you can then load back that data into a new database server or you can also convert it into different formats so try this out on your own download the SQL file import the data from your local installation of MySQL server and then export the classic models database into a SQL file then drop the classic models database and then recreate it using your exported file so make sure that your exported file can actually recreate the data that's an important thing you should be able to do okay so with that we reach the end of today's lesson there's not much more that we're going to cover today there is a lot more that we need to cover in SQL but we'll talk about the next time but here are some challenges for you to try out so this classic models data set is taken from this website richardwatson.com this is I think this is a professor and they teach a database management course so you can and there are a bunch of exercises here so today what we've covered are mostly the single entity exercises but you also have these other exercises which require some joins and some other things which you have not covered yet so you may just want to try out this prepare a list of offices sorted by country state and city this should be straightforward how many employees are there in the company okay this will require some sort of aggregation or you can just look at the list of employees but yeah but one thing you should check out is you can check out things like count where's count yeah count average in sum so you can do something like this select count column name from table where condition and you can use that to answer this question how many employees are there in the company so here is how I would do it I would say select count star from employees and just use classic models okay select select count star from employees and it tells you that there are 23 employees then here is a question what is the total of all the payments received so let's see select star from payments and you have all these payments and now among these payments there is this amount column so if you just want to get the total amount we say select amount and then we can do a sum how do we do a sum well I think it should be there here somewhere so we can just do a sum on the column so we do select sum of amount from payments so this is the total payment that we have received now you can do things like what is the total payment we have received from customers based in the USA or from a particular location and you can do like a group buy as well and we'll cover Group by and all the next time then you have questions like list of product lines that contain cars and Report total payments for October 28 2004 so here's a where Clause report those payments greater than a hundred thousand dollars list of products in each product line how many products in each product line okay so this might be worth figuring out you may have to use this as a reference w3schools is a good reference here you can check out and see which one of these might be useful for you then what is the average percentage markup on MSRP on the Buy price so now you are comparing you're doing arithmetic between two columns again something that we'll try and cover the next time how many distinct products does classic models sell report name and city of customers etc etc so a whole bunch of questions and whichever you are not able to figure out right now using what we have covered today just try and look through this documentation so this is everything that MySQL supports is listed here most likely you will everything that you need will be covered in this MySQL SQL section if you just go through most of these you should be able to answer these questions and then wherever we have more onetomany relationships or any relationships between multiple tables we will look at the next time so the next time we will look at using functions for advanced querying on strings dates timestamps we will look at aggregating data using count average sum min max we will look at using joins to combine and query data from multiple tables at once we'll also see how to improve query performance with keys indexes and transactions and finally we will look at how you can connect to a SQL database from python for querying and visualization in Jupiter so we'll look at how to do it using pandas and we'll also briefly try and look at orms so there's a bunch of things to cover here but the more important thing in SQL is practice so you wanna definitely try out these challenges and there are solutions for these challenges as well you can click the solutions link and use that to check the solutions for example there was this query about what is the average percentage markup of the MSRP on Buy price this is question number 11. so let's see question number 11. okay so seems like we are doing some sort of a calculation here so average of MSRP minus Buy price divided by MSRP multiplied by 100 as the average percentage markup from products okay so we'll also talk about as the next time now a few resources for you one is the SQL challenges for sure then the other one is the W3 schools reference it's a great guide to just quickly look through all the different SQL all the different SQL commands and all the different SQL statements and keywords that are present then there is this book called dbbook.com so this is dbhyphenbook.com It's called database systems Concepts uh you can get this book if you wish it's a great book but you should also check out these slides so they have made the slides available for free online and these slides are a great comprehensive introduction to SQL and relational databases and pretty much everything to do with a relational databases so you can use these slides just whenever let's say you're preparing for interviews or if you want to get a deeper theoretical understanding of how the whole thing works do check out these slides I think you'll find them useful now you just need to look at part one relational languages where we talk about relational models introduction to SQL intermediate SQL Advanced SQL Advanced is already beyond what you will need to know but if you cover these four or five slide decks and maybe also the introduction then you will pretty much Master SQL at least you will know everything there is to know then you'll just need to practice then you also have these slides on database design which is about the entity relationship diagrams and models you don't need to know this as a data science practitioner generally somebody else is going to do the database design but if you want to interpret entity relationship diagrams correctly then you should check this out this might be useful for you the rest of it is not really that important not something that is relevant here it goes into the internals of databases but definitely check out chapters 2 to 5 of dbbook.com so you want to go to dbhyphenbook.com go to the seventh edition and click on slides and here you have um all these slides that you can access here they also have some sample tables just like we had this SQL file for creating the classic models data set similarly you have sample tables for creating this University data set so where you have departments and instructors and students and courses and prerequisites and students take courses and instructors teach courses and then each course is taught in a section with a certain time slot and then instructors are also advisors for students so it's a interesting data set it has about 2000 rows of data and then there are a bunch of questions that you can try and answer on this data set as well I think they are mentioned somewhere here in the yeah exercises so you see there are some exercises here on accessing the database basic SQL intermediate SQL Advanced SQL yeah so here so there's a a SQL is all about exercising all about trying out these exercises so dude maybe we'll try and put all of this together into a single notebook and we will also see we'll also find a way to do it so that you can type all the code in Jupiter and get the results immediately in fact Jupiter just like python there is a way to type SQL directly into Jupiter and interact directly with the database so we'll try and set that up for the assignment but in the meantime do check out dbbook.com you also want to get familiar with the workbench or whatever tool your company is going to use so don't lean too much on Jupiter for this particular course especially and SQL in particular become used to this workbench become used to working with the command line and typing commands there because that is how you will be working with SQL databases in the real world okay and we will touch on how to access them using python 2. more SQL exercises on w3resource.com you have more exercises hundreds of exercises really and that's all SQL is about exercises and more and if you really want to read through my sequels reference manual then you can check that as well although you would almost never need to do that and that's it so we've just covered the use cases and the design of relational databases in SQL we've looked into the installation of MySQL and how to set up a database locally we looked at creating modifying and deleting databases and database tables we looked at SQL data types and constraints like primary key and foreign key we looked at the create read update and delete operations on database tables and we looked at exporting and importing data from relational databases the topic for today is aggregation and joins with SQL last time we looked at some basic SQL commands we saw how to create databases we saw how to create tables we saw how to put data into tables how to get data out of tables all the crad operations which is create read update and delete and we also looked at basic querying using select with some conditions today we are going to look at aggregation grouping and pagination in SQL queries then we will look at mapping functions arithmetic and how to work with dates we will also combine data from different tables using SQL joins and we learn how to improve query performances with indexes and views we will also talk about how we can execute SQL queries using Python and SQL Alchemy towards the very end and as I've said this is a continuation of the previous tutorial so do check out the previous tutorial if you haven't done that already this contains all the basics of SQL and we will be setting up a MySQL server locally so typically how a relational database works is you have to download this software called the server in a server in computer science is simply a program which runs in the background and listens for instructions so the MySQL server is something that you can download from dev.m.mysql.com this is just a package that you download to your computer and then you install it on your computer and once you install it on your computer you can start up a database server on your computer so that software is running now in the background and you can then issue instructions or send instructions to the database server in the form of SQL queries like creating databases creating tables putting data in taking data out Etc now depending on your operating system the way to start and stop this server is going to be different in my case what MySQL does is when I install MySQL Community server it adds a system preferences pane so inside my system preferences this is the Mac system preferences there is a MySQL page that gets added but in your case this could be different so make sure that you have downloaded MySQL server the software and then it is running on your computer and then anytime you have a server running you need a way to connect to that database server so there are multiple ways to connect to a database server one of them is to use the MySQL command line which is typically installed at some kind of a location like this slash user slash local MySQL this is on Mac again the MySQL command line tool based on your operating system will be at a different location so check out the documentation or search online on where you can find the MySQL command line tool once the community server is installed so one way you can connect to the server and issue commands to the server is by running the MySQL command line and here you specify that you want to log in as the user root so when you install the server you're asked to set up a password for the database server and a username so the default username is root and you have to set a password so in my case I have set up a certain password and now I am connected to the server and now I can issue commands to the server for example I can say show databases and that's going to show me the databases I have but what we're going to do is use software called the MySQL workbench so this is the second piece of software you'll have to install and I have given you a link here dev.m.mysql.com download slash workbench so go to this page and download the MySQL workbench for your computer for your laptop for your operating system and then open it up so now we have a server that's running on our computer and then we have this workbench which can connect to a server and gives you a graphical user interface to connect to that server so one way you can connect to your service click plus and here you can then provide this is a connection name that you can set but you have to provide some parameters by default this is set to connect to a local machine a local database server on your computer but again if you have a database server that is somewhere on the cloud you can simply ask for the host name Port username password and then you can connect to that server as well so MySQL workbench does not just collect connect to your local database it can connect to any database on the cloud if you have the credentials and when you join a company they will give you the credentials to the server in my case I already had the local instance set up here so I just clicked on it and now I'm connected to my local instance for example if I just type show databases that's going to show me the databases that I have here which is classic models information schema MySQL and performance schema and then I can run use database in all my select queries okay so that's the setup you need to do that's the software you need to have installed and let us know if you face issues and I hope the server and the workbench a separation is clear to you so here's the MySQL workbench we have that running and in this tutorial we will use the classic models database from the previous tutorial so classic models is a hypothetical company it's a distributor of small scale models of cars motorcycles planes ships trains Etc and the products that are manufactured by classic models are sold in toy and gift stores around the world so here are some of the products they sell and classic models has offices around the world with dozens of employees and the customers of classic models are typically toy or Gift Stores so each customer has a designated sales representative who is an employee of classic models that they interact with now customers typically Place orders requesting several products in different quantities and then they pay for multiple orders at once via checks all right so that's the setup here we have this com this hypothetical company which does all of these activities and we want to track all their activities in a relational database and to do that an entity relationship diagram has been given to us and this simply tells us what the different entities or what the different tables in the database are and what the different columns within those tables are so we have an offices table here it contains information about different offices or the primary key is office code which is the unique identifier then we have the employees table so we have an employee number last name first name extension email Etc and there are a couple of relationships here there is an office code in employees so for every employee there is an office code which is the office code of a certain office so this is called a foreign key because an employee cannot have an office code which is invalid and then you also have reports too so reports to tells you which employee and employee reports to so this is a foreign key from the employee table to itself right so reports too must be a valid employee number of another employee then you have customers and you have a bunch of information about customers customer number is the primary key and every customer has a sales rep employee number which is the employee number of a certain employee who's a sales rep and then for customers a customers can place orders so every order is placed by a customer that's why you have a customer number foreign key here but apart from that orders can have a lot of items so there is an order details table for each item each line item in the order let's say you've ordered five products you have five line items and you can have the quantity Etc of each one and then you have products as well so there's a table of products and there's a table of product clients because you need to track information about the product somewhere as well finally you have payments customer main customers make payments at separate times so this is a slightly different flow where you don't pay per order but customers have a credit limit which means they can make Place orders up to a certain amount and then they can clear all their pending payments at once using a check so that's the setup they have here and depending on how your company operates this system may be different it's possible that if you take payments up front then maybe the order details is connected to payments or the order is connected to a payment rather than a customer okay so that's the entity relationship diagram here and that's the sort of the overview of the database that we're working with now we will use we will set up this database locally with some sample data using a script so let me just set that up and then we will take some questions and by the way if you have any questions please post them in the zoom chat so to set up this database we first need to download the SQL script so I'm just going to open this in a new tab and that's going to try and download it and I'm just going to download it on my desktop here and you can see that now the SQL script is downloaded on the on my desktop and then once you have downloaded it you can go to file open SQL script in your MySQL workbench so open up MySQL workbench connect to the local database and click on this open SQL script and then here you can see the contents of the SQL script so this contains all the information to set up the database that we just saw the ERD for the entity relationship diagram for and it also contains a lot of sample data for example it's going to drop the database classic models if it exists it's going to then create a new database and it's going to use that database then it's going to create tables one by one for example here it's creating the offices table with all this information and then it is going to create employees customers etc etc once tables are created it is going to insert data into these tables like product lines products customers employees Etc okay so it's going to set up a database with a lot of information for us now once you have this SQL script loaded up you will see this run SQL so execute button which is like a lightning button here so you can just run a press that or you can just press command enter or control enter on windows so I'm just going to run command enter and now my previous classic models database has been removed and this new database has been set up so if I go to the left sidebar if your sidebar is not open you can click here and open up the left sidebar and just go to the schemas tab in the left sidebar I should be able to find a schema let me just connect again here okay let me just run that once again yep all right so now if I check the schemas here so I should be able to find in the schemas once I reload the schemas the classic models database now in the classic models database I can browse all the tables here you can see that we have tables customers employees offices order details payments product lines Etc and if you double click on a table or if you just click on this table click on this button which shows information from the table then it is you can view some information from each table all right so MySQL workbench gives you an easy way to browse the schema see different tables and actually look at information from different tables very easily okay so now we have just to recap we have downloaded the SQL script from this URL and then we have loaded it into MySQL workbench using file open SQL script then we have executed the script to create and populate the database this part can also be done using the MySQL command line tool it's simply a matter of passing the script to the command line tool and you can look up how to do that but once executed you should be able to view and browse all the tables in the schema section of the sidebar and if you face an error the most likely issue is that your MySQL server is not running so just because you have workbench open does not mean the server is running so make sure that the server is running and then you will be able to communicate with the database server all right so with that we have our database set up now ready to go and we have our MySQL workbench connected so let's get started the first topic we look at is aggregation grouping and aliases SQL provides several functions like count average sum Min and Max for aggregating the results of a query what do you mean by aggregating well it's combining the results that you get typically into a single number or maybe a one or one or more numbers so here's an example report the total number of payments received before October 28 2004. okay so this is the kind of question that will be posed to you or the kind of information that you will have to figure out now we know from the ER diagram and we know from let's maybe just copy the question and put it here yeah so this is the way to create a comment in a SQL file or a SQL query you just put in hyphen hyphen space and that's going to be a comment that is going to be ignored by the uh by the MySQL server okay so the question is report the total number of payments received before October 28 2004. so we have a table called payments so let me just do a select star from payments all right and once I run that I will get back a list of results yeah here's the list of results so these are all the payments in the database you have a check number you have a payment date you have an amount and you have a customer number the customer who made the payment all right but we are not interested in all the payments we are interested in payments received before October 28 2004. so there is a payment date here and it seems like this payment date is in this year month date format and in fact if you want to know the data type of this payment date you can just spin up a new query here and just type describe payments and you can see that the payment date is a date time okay now a date time is an ordered field obviously dates have a intrinsic order so here's what you can do you can say select start from payments where payment date is less than because we want payments before October 28 2004 and then you provide the date that you want to check here so that's 2004 and then you have October that is the 10th month and then you have 28. so this should be enough you don't need to put in the time here so I'm just going to run that and if you see now we only have payments that have occurred before October 24 October 28 2004. and I recommend just going through this list manually if you want to verify this but that's that's how you get that all right but we don't want every single payment we want the total number of payments now if you want a total number of payments it's very simple to we simply want to count the number of rows that were returned by this query and the way to do that is just type count so count is a function in SQL and you can see it highlighted in green and typically this is what we do we put all the SQL commands in so typically this is what we do we put all the SQL keywords on the SQL functions in capital letters or uppercase and we put the column names in lowercase or whatever is the actual column name whether it uses lowercase uppercase or combination of both and this is just to visually separate actual keywords with column names but remember that SQL is completely case insensitive so you could type all of these in lowercase and you could type all of these in uppercase and it would work just fine okay and this is just for visual separation in any in any case we have the count function so you just put instead of Select count star uh use instead of Select star you just type select count star and run that and now you will see here that there are 189 payments that have been made before October 28 2004 and if you did not have this where Clause this filter then you can see that there are total of 273 payments so out of 273 payments 100 and 89 payments were made before October 28 2004. so that's how you count the number of rows returned from a query just put in account located and there's a quick question here about payments where this payment stable come from so this is the table that we've just populated when we downloaded the SQL file classic models.sql and then we executed it that gave us this table and that gave us all the data inside this table okay so that's count just put count around the selection criteria and that will count the table that will count the rows for you next another common use case involves counting the number of distinct values in a column so here's a question report the number of customers who have made payments before October 28 2004. so now we are no longer interested in the number of now we are no longer interested in the number of payments that were made we are interested in the number of unique customers who have made payments and one customer can make multiple payments uh so number of customers who have made payments before October 28 2004. so once again maybe let's open up a new uh let's just continue typing here so here's my select query select star from payments and I can write payments or I can write payments or I can write payments and it will all be the same thing okay this is the name of the table so anything you see after from is a table name so select star from payments that gives us a list of all the payments and once again we want to select them and I'm just going to mix cases here but don't worry about it so let's just say select start from payments where payment date is less than 2004 10 what's that October 28th so 2004 1028 so that gives us all the payments that have occurred before 2004 1028. now we are interested in the customer number we are interested in the unique customers who have made payments before the state so here's the first thing I'll do maybe I'll just select the customer number first okay so if I just select customer number now I have ignored all the other columns I have just selected the customer number column so now I have 2299 172 242 Etc but of course there are probably going to be repetitions here and you can go through this list and verify that there are some repetitions okay so if I did select count customer number this is giving me 189 which is actually the total number of rows returned but we want simply the number of unique customers who have made payments so what you do is you type distinct okay now when you type distinct repetitions from this list will go away so if I type distinct here now you can verify that this list is a bit smaller this list is not that big anymore and in fact if I type count now you will see that the count is only 98. so what distinct does when you type distinct before a column name it is going to just select distinct values of that column and if you type multiple column names after distinct it is going to just select all the distinct combinations but in this case we first get the list of all the distinct customer number which is a customer ID and then we count the number of rows okay so count is a function but distinct is still a keyword which is part of the SQL syntax okay so once again I'm just quickly going to repeat that we have select star from payments where payment date is less than October 28 2004 now instead of selecting all the columns I just select customer number and that gives me the customer number for each payment but I'm only interested in the distinct customer numbers I don't want to show I don't want customer numbers to show up again and again so I type distinct and then I want to count them so here is the count function which is going to count the customer numbers for me and there are 98 of them okay so that's how you solve any SQL query or solve any SQL question you just go step by step you start by looking at the table and then you simply keep adding in criteria one by one of course as I said District can be used can also be used without count so if you just wanted the list of customer numbers for customers who have made a payment before the 28th of October 2004 then you just type select distinct customer number from payments where payment date is less than 28th of October 2004. okay and you can use distinct with multiple columns as well so if you want to try out learn more and try out what distinct does check out some documentation here on w3schools and you can also practice this online okay now if I look back at this query just a distinct customer numbers this is just giving me a list of customer numbers right and this is not very informative because ideally what we want is details of those customers I want to know which people which stores have made payments before the 28th of October 2004. so how do you do that well here is one way to do that we know that this is a list and you can write a query which uses the result of this query okay and here's what we want to answer we want to retrieve the details for all the customers who have made a payment before October 28 2004 okay so how do we do that let me just put this query aside for a second and let me start typing and let's just comment it out here and let me start typing select star from customers okay I guess I'm just going to use lowercase here but select star from customers so now I have details of all the customers but I'm not interested in all the customers I am interested in simply the customers where the customer number is in this list that I had earlier and I'm just going to run this again here in a as a new query so I just want to get the details of customers who are in this list about 98 or so customers so what I can do is I can take this query without the semicolon and I can come back here I can come back here select start from customers where customer number in and then here I have to give a list so instead of giving this actual list I can give a query which generates that list so I can just put in a bracket here and type select distinct customer number from payments where payment date okay so we take the result of this query select distinct customer number from payments where payment date and then we run a second query which is going to select details from the customers table where the customer number lies in this list okay so if we run that now so now you will only get details of customers where the customer number is in this list and what is this list this list is simply then distinct customer numbers from the payments column where the payment date is less than 2004 1028 okay so that's how you change SQL queries you can take the result of one SQL query and use it in a where clause or you can even select from it again so you can treat a treat the result of a query as another table essentially and then write SQL queries on top of the results of other SQL queries okay so that's how you chain queries okay so here's an exercise for you retrieve the details of all the customers in the United States who have made payments between April 1st 2003 and March 31st 2004. so how would you do this you would first think about it the way you would do this is first you would just look at all the payments so you just do select star from payments and then you would look at payments between April 1st 2003 and March 31st 2004. so you would put some kind of a where Clause where you would combine two conditions using an and keyword and once you get the results for payments just between these two dates then you simply retrieve the customer ID for those payments and then once you have that list of customer IDs or the distinct list of customer IDs you can use that to get the details of customers and you add another where Clause where you will check whether the customer is in United States or not so it's going to get a little complex here but I will let you figure this out and if you are unable to do it uh do ask on the slack group and we'll help you out okay so let's talk about grouping then so here's a question find the total number of payments made by each customer before October 28 2004. all right let's go back and let's try and solve this so here's the question total number of payments made by each customer before October 28 2004. so we say select star from payments again so we were selecting we want to show all the columns from the payments table all right and we just want to look at payments before October 28 2004 so where payment date is less than 2004 1028 and now we want to count the total number of payments so we could do this count but this is the total number of payments across all customers we want to count the number of payments made by each customer so here's what you can do you can provide a you can provide a group by Clause so you can type something like this you can say Group by well I believe it shows up after where so yeah this this can sometimes be confusing which clause comes after which but let's try here well actually let's start with that and then we'll see if that works so Group by so you type select count start from payments and group it by customer number so now you're just looking at count star of payments and grouping by customer numbers okay I think this this comes after yep so you type select count star from payments where payments date is less than to 20 2014 28 and you Group by the customer number so what happens here SQL first creates or groups of groups of rows for each customer number and then it computes the sum or it computes the count of the number of rows for each customer number so here it seems like for a certain customer there are two rows for a certain customer there are three rows for another customer there is one row Etc but of course we also want to see the customer number so what we can do is we can just take this customer number column and select that too okay so anytime you Group by a certain column you can also show that column in the result so here's what that looks like select count star from payments where payment date is less than a certain value select customer customer number comma count star from payments where payment data is less than a certain value and group this data by customer number first so first SQL creates groups for each customer number then it performs this count star and then it gives us a customer number and the count star okay now here's one other thing we can do this is not very informative because we're looking at count star here what we can do is we can just say uh number of payments we can rename this count the output of this count as number of payments okay this is called aliasing so now you have this table where it says customer number and it shows you the number of payments and you can see that the customer number 112 had two payments before the state customer number 114 had three payments and for each customer in the database you get how many payments they've made only the customers who have made payments before this particular date so this is how you use Group by grouping is very commonly used with aggregation in functions like count okay now apart from the count you can also compute the sum of values in a column so here's one thing you can try and figure out find the total amount paid by each customer which is the sum of all their payments before October 28 2004 so let's see if we can do that I'm just going to once again select I'm just going to select start from payment s here and just see what columns we have so we have a payment date which we have been looking at we've been looking at this customer number but there is also this amount so what we want to do is we want to total up the amount for each customer so let me go back here so now I have select customer number and instead of count star which is going to count the rows I am going to call sum and I'm going to sum the values in the amount column so count you generally put in Star because you're just counting the number of rows so you don't have to specify a column but when you want to compute the sum you specify the column for which you compute the sum so sum of amount and I'm going to call that as total amount okay so select customer number and some amount which I'm calling total amount from payments where payment date is less than 28 October 2004 and group by the customer number and that now gives you for each customer the total amount so all we've done is we've replaced count star with some amount okay so these functions are generally work all work in the same way some count and you can also use them together so here's an example find the total number of payments and the total payment amount for each customer for payments made between uh before October 28 2004. so how would we do that well we have select customer number uh and then we have the total amount already I'm just going to add another column here so I'm saying I'm going to say count star as number of payments comma yeah so we have select customer number count Star as number of payments some amount as total amount from payments where payment date is less than such and such and then we Group by customer name so now we have for each customer what is the number of payments they've made and what is the total amount that they've paid before this particular date and you can try and remove this where clause and see that the result actually changes and you see now that the result is different right so try and understand each part of the SQL query the same SQL queries mentioned here so try and understand each part of the query and if you can make sense of it then you're getting familiar with SQL and here's an exercise for you determine the total number of units sold for each product so there is a products column and then there is a so there is a order details column I think let's take a look at that quickly select star from order detail so there is an order details table and this contains the details of all the orders that have been placed and then here you have the product code and you have the quantity ordered of that product in that particular order and what we want to do is we want to find the total number of units sold for each product so if I simply do Group by product code and here if I do product code and I do a sum and in the sum I put in the quantity order so now what we're saying is we want to group the rows in order number in order details by the product code and for each product code we want to take a sum of the quantity ordered column and if we do that and run this query you should see here that we have the product code and then for each product code we have the quantity ordered okay and that's how you answer this question again becomes easier to understand once you try it yourself so here's how I would go about solving working through this notebook just read the question don't look at the answer just immediately go to your SQL workbench and then start typing out and start figuring out how to solve the question and if you're able to solve the question great if you're not then you can look at the answer and again don't copy paste the answer look at the answer maybe for a couple of minutes try and understand what it does and then go back and try to type it out again typing out code is a very important part of becoming familiar with SQL or python or coding in general okay now apart from sum and count you can also do the min max in average for example if you want to figure out what was the maximum payment made by each customer before a certain date you can do that all you need to do here is in this table you can maybe just add max amount as let's just call it largest payment so now you have for each customer what is the largest payment they've made and you can see this here the largest payment that they've made is a for this person has made is a fourteen thousand dollars they can also you can also add the minimum amount that they've paid so smallest payment so the smallest payment they've made is 32 000. so already we're getting some insights in it turns out that in this case customer number one zero three the largest num the largest payment is fourteen thousand dollars and the smallest is six thousand but for one one two the largest payment is thirty three thousand and the smallest is 32. so maybe this customer is just clearing uh bills as soon as they hit a certain amount right you can also then look at the average payment so what is the average order amount and think it is average okay so what is the average amount and this is the average payment okay I think there's a an issue here I'm not sure what the average is called but let's see average my sequel AV it's called AVG so let me just change that to AVG yeah so AVG is a function name here and you can see that the average payment for each customer is also shown here right so this is how you can do basic analysis directly within SQL you don't even have to export the data although if you want you could export it to a CSV file uh that's an option from the MySQL workbench but a lot of analysis can be done directly within SQL okay so let's talk about sorting and pagination now so far we've been doing all these queries and through these queries we get a lot of information but in a lot of cases we are looking we are interested in finding the a top 10 or top five or the maximum value so here's an example retrieve the customer numbers for the 10 customers who made the highest total payments in 2004. or actually let me change that to before October 28 2004 okay so retrieve the customer number for customer numbers for 10 customers who made the highest payments total payment before October 28 2004. so let's try and answer this step by step we want to retrieve the customer number so we can say select star from payments and once again we are interested in payment date before 2004 October 28th grade we have that information but now we want to retrieve uh we were interested in the highest total payment so before that we are interested in the total payment per customer so if we do this if we do a group by customer number and then we do uh we select the customer number for each group and then we do a sum of the amount column so now what that gives us is the total the total amount paid by each customer before October 28 2004 so we have that but now we are interested in the people who made the highest total payment so here's what we can do we can type at the end order by so we type order by and then we tell the column name that we want to order by so we want to order by this column which is the sum the total amount so let me just rename this as total payment so I'm going to call this column the sum column I'm going to call it total payment and I want to order it by total payment so let's run that and Order bike generally comes at the very end so now you have customer number 456 they have a total payment of 1679 customer number 381 has 2755 and so on but of course we are interested not in the lowest so this is ordered in ascending order but we are interested in the highest so to do that you type desc descending so a ASC for ascending and desc for descending and let's run that so now you have the maximum value 31 33 sorry 331 256 dollars were spent by customer number 141. okay and we have this information for all the customers but the question asks only for the top 10 customers and typically anytime you issue queries like this in a very large database you probably only want to look at maybe the top 10 the top 50 or the top hundred so here's how you can do that you just call at the end you type limit and then you tell the number of rows that you want to see in the result okay so if I type limit a 10 at the very end so that's going to just give us 10 results you can see these are the 10 customers uh 141 124 148 151 and 320. okay and by the way limit Works without order by as well it you don't need an order you can do a limit just like this too so these are both independent but in general whenever you're doing an ordering it's common practice to also limit the number of results so as to not put a very heavy load on the database so that's what we created select customer number and some amount as total payment from payments where payment date is less than this value and we Group by customer number order by total payment descending and limit the results to 10. now if you want to see the next 10 results because we've just limited the results to 10 all we need to do is add an offset so let's say we want to skip ahead we want to skip the first 10 rows and you want to see the next 10 rows we type offset 10. and just notice this number here 320 and 93565 if I type offset 10 you will see that now we have 386 Which is less than the previous value so now I'm no longer looking at the top 10 I'm looking at the next 10 so customer number 11 to 20 when they are sorted by the total payment and if it's let's say if I set the offset to 5 if I if I set the offset to 5 so I'll just skip this query will just skip the first five rows and it'll show me from the sixth row onwards right so limit and offset can be set independently limit tells you how many rows you want offset tells you how many rows you want to skip now here I've skipped the first 50 customers so I'm looking at customer number 51 to 60. okay and I could maybe even if I wanted I could look at just five of these so play around with limit and offset they are used to limit and paginate the queries SQL also provides mapping functions and these mapping functions are applied to individual values so now we're no longer combining multiple rows of data now we are just applying them to individual values so here is a question display the full name of the point of contact for each customer in the United States in upper case along with their phone number and we want this information to be sorted by the alphabetical order of customer name okay so there's a lot going on in this question and these are the kind of questions that you will see in interviews often and don't feel intimidated just go step by step the first thing here is we want information about customers so we go here and let's clear all this and we just type select star from customers great now we have information about customers next we want customers in the United States so we have what's that we have this country column and in country we have USA so if I just type where country equals USA so now I'm just looking at customers in the United States and you can check here then all of the all of them have Country USA okay great one more thing done next we want to display the full name of the point of contact for each customer so if you see here we have contact first name and we have contact last name so we could do this we could just say let's just print a customer name I think that is something that we should display and let us display contact first name and let us display contact last name okay all right so now we have the customer name we have the contact first name and contact last name only for those customers where country is set to USA okay so display the full name it's still not the full name we are showing two separate columns but we'll figure out that piece but here it says we want to display these in uppercase for some reason or maybe we want to print them somewhere or copy paste this information somewhere so how do you convert a string into uppercase well there's a function for that you just call you case so your case is going to make it uppercase and L case is going to make it lowercase so I just call you case on first name and let me maybe do L case for now on contact name and you can see here the first name becomes upper uppercase all capital letters or uppercase letters and the last name has become lowercase let me turn that into uppercase as well so now we have both an uppercase and notice that these are not aggregation functions they did not combine all the rows into a single value they applied this function uppercase to every individual value so this was applied to Susan it was applied to this row and this row and this row and so on okay so that's why these are called mapping values they take a column and they map that column onto a based on a function so that's why these are called mapping functions now last bit here is or maybe a couple more things left one is display the full name so we want to take the first name and last name and we want to combine them so there are certain functions which can combine columns and the combination that we want to use here is called concat concat is short for concatenation so I'm just going to call concat here concat and let me drop this for a moment let me just get rid of these and I'm just going to do customer first name and oh sorry this is contact so contact first name and contact last name so now we've combined contact first name and contact last name but there's a problem here you see Susan Nelson this is there's no space between them well that's easy to fix you just add a space here and now you have Susan Nelson and we want to make this uppercase so now concat first name Etc is the uh string that we're dealing with or it's a column that we're dealing with so we just called you case here and that is going to now make that uppercase now you could do it two ways you could apply to each column first and then concatenate them or you could apply it outside both will do the same so now we have that one last piece of cleanup is let me just get this on a new line is to Simply get is to Simply rename this column so I'm just going to call this contact name okay so we concatenate first name and last name with the space between them convert that to uppercase call it concat contact name and list it out one last thing we also want to display their phone number and we want to sort by the alphabetical order of the customer name so let's display phone number here let's just put in comma phone number I think it's just called phone if I'm not mistaken yeah so now we have customer name contact name phone and we want to order them so we just put in order by and here we put in what was that number customer we want to order by customer name in alphabetical order so we can even just put in ASC here or ascending to mean increasing alphabetical order so now you see we have this customer name Americans souvenirs Automotive Classics board and toys Cambridge Collectibles classic gift ideas all of these are customers in the UK in the USA we have that contact name listed in uppercase we have the phone number of the contact and we have sorted this list in alphabetical order that's how you answer SQL queries and that's all we're going to do over and over for the rest of the session essentially here's another example display a paginated list of customers sorted by customer name with a country code column and the country code is simply the first three letters in the country name they should say country code so the country code is simply the first three letters in the country name in lower case so here's how you can do that we want to show customer so just paginated list of customers so let me just do let me open a new query here let me do select star from customers and we want to show a paginated list so we want to show where um sorry we want to limit to let's say 10 customers so these are 10 customers then we want to sort them by customer name so let's do order by all right it is sorted by customer name just fine and then we want to show country code column so maybe let's just show customer number and customer name and Country so now we have customer number name and Country but we are interested in something called a country code and what's a country code the country code is simply the first three letters in the country name in lower case so we want to get the first three letters out of every country name and that can be done using this substring function so instead of country we put in sub string country and in substring you specify where you want to start now in SQL numbering starts at one not at zero so just be careful about that and we want to take three values I think so we just say one comma three and yeah so that gives us just the first three characters of each country name and let me just clean that up here so that gives us the first three characters from each country name but we are interested in we want to make it lower case so we just type L case here and that's going to make it lowercase for us and let's just rename that using as to country code okay and there you go so now for each customer name we have a country code for whatever reason we need the country code all right so that's another function here's one last function display the list of the five most expensive products in the motorcycles product line with their price rounded to Dollars and the price is the MSRP column okay let's try and answer this to the five most expensive products in the motorcycles product line so let's get rid of some of these okay so let's see select star from products there's our products a list of all our products and here one thing you will see is a product line so we can we simply want to look at motorcycles so where product line the column product line has the value motorcycles okay now we're just looking at motorcycles here and we want to check the five most expensive products so we let's order them let's order by MSRP maximum sale retail price I guess so yeah and we ordered that by MSRP and we can also just type MSRP should not be a problem here okay now they're ordered by MSRP but of course we want the most expensive so we type the ESC descending so now you can see that we have only motorcycles and we have ordered them in the decreasing order by MSRP and we just want to see the top five products so I'm just going to add a limit here so let me just move this down yeah so let me just add a limit order by MSRP descending limit five so now we have the top five products and maybe we don't need all the columns mostly we just need let's say the product code and product name and MSRP all right this is the required information there is one last condition here we want to round the price to dollars maybe we're creating a report where we don't want to show the full price we just want to round it to Dollars and the way you do that is just type round so round function will do that for you so now this number is rounded to Dollars you also have a ceiling and a floor function so if you want to round down or round up you can use those but round does the job and in round you can also specify the number of decimal points that you're interested in for example if you want to see one decimal point just specify round one okay so that's how you answer this question five most expensive products in the motorcycle category so that was about the mapping functions you will not yeah there are a lot more mapping functions so you generally don't need to remember all of them although it will help again for interviews for exercises and as you solve more exercises you will automatically start memorizing them but there are a bunch of different functions that you can apply to dates and you can apply to numbers and you can apply to strings all of them and one other kind of function or operation we should look at is arithmetic you will often have to combine data from multiple columns using arithmetic operations so here's a question display the product code product name Buy price sale price and profit margin percentage so what's profit margin percentage will you buy the product or maybe you buy the parts for that product at a certain price and then you sell it at a certain price the difference is called the profit and or the margin and the percentage is basically the sale price MSRP minus the Buy price multiplied by 100 divided by the Buy price okay so that's the profit margin percentage sale price minus Buy price divided by Buy price and convert that to a percentage by multiplying with 100. for the 10 products with the highest profit margin so we want to show the 10 products with the highest profit margin and we also want to round the profit margin to two decimals so there's a lot going on here let's go step by step here first thing is we want to get some information out of the products table right so let's go select star from products yep so now we select a bunch of products all right and what are we interested in product code product name by price sale price so let's get product code product name Buy price sell price uh okay is there a sale price I don't think so there's just an MSRP yeah okay so now we have the information that we're interested in but there is this last column that we need which is profit margin percentage and fortunately I have the formula here so here's what I can do I can simply put in the formula here comma um MSRP minus Buy price let's get these on different lines so MSRP minus Buy price and let's get that down as well yeah so this is the profit and if you divide that by Buy price so these are all column names right so you you're saying we want to take values in the MSRP column from them subtract the values in the Buy price column and then divide by the values in the Buy price column and we want to multiply that by 102 so let's just put in a multiplied by 100 and let's put the entire thing within a bracket okay so now we have MSR oh yeah so now we have MSRP minus Buy price multiplied by 100 divided by Buy price and let's just call that profit margin so let's just rename that so that's our profit margin and you can see that the profit margin for this product since we buy it at 48 dollars and sell it at 95 is 96 percent that is the amount of money that we've made on top of the Buy price and what do we want to do with the profit margin well we want to show the 10 products with the highest profit margin so let's add that so that will be a sort or an order by order by and now once we've created this column we can use it here so we can call ordered by profit margin and we want to limit it to 10. and we want to see the highest profit margin so we say desc descending limit 10. let's check that great so now we have this product the Chevrolet Impala on this product we are making a huge profit margin we're buying it for 32 dollars selling it for 80. so 150 percent profit actually maybe let me just call this profit margin percent so that it's not confusing with the actual number yep now the last thing we want to do is round the profit margin to two decimals and that's easy we just type around here and another bracket here well I guess we don't Let's see we probably don't need that bracket and we want to round it to two decimals so there you go now we have the profit margin rounded to two decimals and these are the 10 products with the highest profit margin percentage so these are the kind of queries that you should be able to answer by using arithmetic operations by using sorting grouping and aggregation and mapping functions you can check out what other operators are supported in SQL it's not just a Johan arithmetic you have add subtract multiplied divide you can divide and you also have this modulo function which is to compute the remainder so you can do that as well and then you have some bitwise operations and you're already familiar with comparison operations as well so comparison operations are typically used in the where Clause as we saw with the date talking about dates SQL also provides several functions for extracting information like the year month Etc out of date columns so let's look at an example list the largest single payment done by every customer in the year 2004 ordered by the transaction value highest to lowest okay again seems complex but let's break it down we are interested in payments that's what I can gather here list the largest single payment so I'm just gonna go here and first of all just to select star from payments okay we have payments now next we want the largest payment by each customer okay so we want basically the maximum payment by each customer so we can probably do a group by customer number and then for each group of rows for each customer we want the maximum payment that they've done so let's call amount max amount and let's rename that to largest payment okay all right so it's start starting to make sense now so we have we select customer number we select the maximum amount so for each customer we look at all the payments we've made and pick the one with the maximum amount or pick the maximum amount among those and of course for that we have to do a group by customer number but we want to look at this in the year 2004. how do we do that well we have a payment date and we could check if the payment date is greater than Jan first 2004 and less than January 2005 and things like that or we could simply do where and we could use this year function so here is all here is a function just like other mapping functions and into the year function pass in payment date and just check if the year of the payment date is 2004. okay so that's our query right here select customer number max amount as largest payment from payments where year of the payment date is 2004 and group by customer number and ordered by transaction value right so we want to order that by transaction value so we should also probably put in order by largest payment and let's run that so it turns out that customer number 161 it turns out that customer number 161 made the largest payment in the year 2004 and that payment was 2434 dollars oh well no we want to sort it in descending order yeah so customer number 141 the loyal customer made 116 000 200 in a single payment and that was the highest payment in 2004 by a huge margin actually you had to 84 410 after that okay so that's how you pick out information from a year from a date here's another example show the total payments received month by month for every year okay this is interesting so you want to show the total payments month by month for every year so you want to see January 2003 February 2003 uh March 2004 and so on so let's once again start with payments select start from select start from payments we have the data now we are interested in year and month so we have a payment date if we can just create a new column for ear and a new column for month I think that should just get us started so I'm just going to create a new column for here so I select star which means I select all the columns but apart from that I also select year of payment date as payment year and let's see that so now we have a payment here over here and let me just put that at the beginning and then we also want the payment month so we just type month and we type payment date so from the payment date we get the month and we call that payment month so let's put that on a new line here comma star so we still want the other columns or you know what maybe let's just keep the amounts now or maybe we don't need the other information so select payment date year as payment year month of payment date as payment month and then the amount from payments yep so now it tells us for every single payment we now have a year and a date in the amount but of course we don't want of course we don't want uh like this is still showing us every individual payment like if I put a comma star here you will see that we are still looking at yeah if I just instead of the amount if I put star here okay never mind yeah so you can see that we're still looking at every single payment even though we've created a payment here column and we have created a payment month column we are still looking at every single payment individually what we want is the totals for each month and for each year so how do we do that well you guessed it we want to total up the amounts so let's get rid of these other columns and let's just do a sum and we want to get the sum of the amount but of course just doing a sum is not enough because we also need to do a group by right because we want to First Define groups so for each month comma year we want to get a group of columns you want to get the group a group of rows so you want to get all the rows which were which belong to January of 2003 all the rows which belong to February of 2003 and then sum up each group so we type here Group by Group by and in group by you can actually provide multiple columns so we have this payment year column and we have this payment month column so now we have a payment here we have a payment month and we have the total sum so this is the sum of the amount of all the payments made in that particular month of that particular year and maybe we also want to order by these same criteria so that we can see it in a more understandable format so we also order by payment year and payment month and you don't need this comma here so now we have 2003 one and the sum is 26 000 and then 20032 which is February of 2003 and the sum is 144 000 and then 2003 March is 199 000 and so on seems like what is this August September of 2003 was pretty good so this is how you can now start doing some basic analysis and interpretation so this is your Revenue growth or this this is your Revenue table so if your boss asks for a month's wise Revenue table this is what you give them but of course you probably don't want to show these numbers like this like it doesn't make sense to look at this zero zero zero zero three here and it's probably a floating point or a rounding error somewhere so let's make this a little prettier and here again it's a bit difficult to guess the month from month number going to the actual month can be a bit difficult so let's make this a little prettier now for the above query the query just that we just looked at let's format the amount properly with a dollar symbol and comma separation maybe show it something like this 26 267.62 and just two two decimal places and let's also show the month as a string okay so now we are in the territory of printing things nicely of making things look good so that's where you need these formatting functions there are two numbers two functions one is the format function for numbers and then the date format function for dates so let's first look at the format function for numbers now instead of showing the sum just the sum of amount I am going to call format here and I am simply going to put in I think you can to format you can mention how many decimal digits you want so I'm just going to put in 2 here and format is automatically going to add commas here so now you can see that you have 144 comma three eight four point three six just by adding this format keyword here and of course now it's no longer number nowadays become a string and let us also rename this column as Revenue so now we have revenues one four four three eight four point three six maybe let's go a step further let us add a dollar symbol here how do we add a dollar symbol well this is a string and we want to add a dollar symbol at the beginning of the string how do we combine two strings that is done using concatenation so let's call concat the concat function that we saw earlier but this time instead of concatenating two columns we are concatenating a string the dollar symbol with the column so now when we call concat we have dollar one four four three eight four point three six and that is called the revenue so that's how we format the numbers a little other a small cleanup that you can do here especially if you're sending it out to somebody this result is maybe you want to just clean up these call column names so if you want to just call it payment year but of course that's going to be a problem so whenever you have spaces within column names you can use these back codes so this is the code that is available on your keyboard just below the Escape key and let's call this payment month okay and then let's call this uh Revenue I think this should be fine just like this and once again let's just changed it here just cleaning it up a little bit to make it look nicer and then you can export it and send it as a CSV or something so now you have payment here you have payment month you have Revenue with dollars looking good but of course we still missing this piece we want to show things like January February Etc here so if you want to show Jan Feb Etc here's what we can do we can call date format so there is this function called date format and date format is something you will most likely have to look up so date format takes a date as an input and then it takes a certain format in which you want to see the date for example if you want to see the YY mmdd format then you put something like percentage y hyphen percentage M hyphen percentage D or or something and here are all the variables that you put in so inside these codes as the second argument you provide all the variables that you want to show and based on that it is going to show you that information so we are interested in we have a month here and we want to show that month um actually we just want to show the payment date as a month so I'm going to remove this month I'm just going to call date format here and how do I want to format it let's see let's see what options we have so there is this percent B here so I can take this percent B and if I just take this person B here let's see what happens so you see here now this has become August and in fact if I want to get the year name I think the year would be percent y so if I want to get the year name I would maybe just put this and now you can see August 2003 December 2003 Etc but I just want to keep the month name here so now we have the month name so we took the date called date format on it directly on the date and we just extracted out the month using this person B and that is something that I looked up in this table there's no way I can remember all of these so I just have to look these up each time and we saw that person B can give us the abbreviated month name if you want the full month name then we can use percent m that can give us the full month name let's try that too maybe okay so yeah so now you have the full month name but now we've run into a problem because now we have payment here and we have payment month but now because we are ordering by payment here and then payment month the ordering the ordering becomes alphabetical so we want to display the number we want to display the string but we want to order by the number how do we do that well here's one idea I create another column let me just call that let's use month and payment date so let's get the month from payment date and let's call this is called that as month number and I'm just going to instead of ordering by payment year and payment month I'm going to order by month number okay and let's try to run that so that gives us an error because now since I have this new column month number I should also be grouping by this column otherwise anything other than sorry anything other than the aggregation so here is where we are doing the aggregation anything other than the aggregation should show up in group by so let me just put month number here okay so now we have three columns which we have created we've created created a payment here that's fine and we have created a payment month grade and we've created a month number because we also want to track uh we also want to track numbers here and then we are grouping by payment year payment month and month number of course payment month and month number represent the same information so the same groups will be formed for every month of every year we will get a group of rows and then we are taking the sum of those rows uh some of those rows to get the sum of the amount then we are formatting it to add commas and show two decimals and then we are adding the dollar symbol and we are calling that column Revenue okay so this is looking good this is a pretty complex query at this point but it's looking good the only problem I have is that there is this last month number column here which I don't like this is not something I wanna send to the person who's asking for this information so how do we remove that so in some sense we want to use this column month number for grouping and for ordering but we don't want to display it here's how you can do it it's a very simple trick here just remove it from select so you select payment year payment month payment you select Revenue but you remove this from here remove the month number column and just put that here so just put it in group by and put it in order by okay so now we're saying we select year and we select this payment month which is nicely formatted and we select this sum which is nicely formatted as revenue from payments but in group by we are grouping by this additional condition this sort of hidden column which is the month payment date and we are also ordering by this additional hidden column which is a month payment date okay and now we finally have 2003 January 2003 February 2003 March 2004 January February March 2005 January February March okay now this is the perfectly formatted Revenue column Revenue table we exported put it into Excel or send the CSV to whoever needs it okay so that's the query there's a lot going on here so spend your time with it take go through each step and as I said what you want to do is you want to start with the table that seems the simplest uh just get all the data and keep adding in keep embellishing the query step by step to cover all the requirements and maybe also just make it look good so that's all about aggregation and mapping functions and arithmetic operators and dates so let's talk about combining tables using joins a join Clause is used to combine rows from two or more tables based on a related column between them so here for example you have table one which has three columns and you have table two which also has three columns and one of the columns let's say this is some sort of a shared column so one of the columns has is related and has the same or similar set of values so table one has one two and table two has one three four so what you can do is you can combine the two tables such that you have this one column and then for this Row one and then these two values you also get the information from this table these two values and that creates like a one big row so you can think of this like the result of the join so for the column for the value 1 we get the information from table one and we get the information from table two for the row with the value 2 we get the information from table one here and there is no information in table two so now what happens here whether we put empty values or we don't show this row depends on the kind of join so if it is an outer join then we just show empty values here for these columns from table two and then here there are no more values left in table one so we go through table two we pick these values and we just show empty values here so we show empty values for three for table for these two columns from table one and for the columns from table two we show these values and finally we have four for which we again show empty values from table one and we show these two values here for table two okay so that's outer join and then we have inner join which picks just the intersection of the values and then we have the left join and right join so let's maybe look at some examples and this will become a lot clearer the first thing we'll talk about is the inner join and this is the default join in MySQL so whenever you type join whenever you're trying to join two tables on a certain column then by default it is going to be an inner join and let's see it in the context of a problem and it will make more sense show the 10 most recent payments with customer details so name and phone number okay so let's go select star from payments these are all the payments that have been made now the trouble here is that in this result we only have the customer number what we'd like to show is the customer details as well who is this customer number 471 and we all look at the most recent payments so let me just grab the most recent payments ordered by payment date or maybe let's do that part at the end maybe first let's get the customer details so we have select star from payments and we want to show customer details name and phone number how do we do that I know that there is a customer number field in the customer's table as well so if I do select star from customers there is a customer number table there's a customer number field or column so what I really want to do is I want to fetch the information for customer number 471 from the customer table how do I do that I type select star from payments join customer number okay so what did we just do we said that I want to get some information from the customer number table as well but how do I decide which how do I decide which rows are connected well I want to use the customer number right so by default SQL doesn't guess SQL requires you to provide how you want to match up the rows of the two different tables so you say join on on which column you want to join and then you provide the column from this table and the column from this table so you say payments join customer number on payments dot so now because there are two tables involved so that's why you have to specify the the table name before you specify the column name so payments Dot customer number equals customers Dot customer number okay so let's just try and make sense of this and maybe let's put this on different lines so we are saying that I am not happy with the information that I have from the payments table I also want to get information from the customer table I want to augment some information here for the customer using the customer table and how do I want to augment that information I want SQL or my database server to look at the customer number field in the payment table here so for this row look at the customer number field and find the row in the customers table which has the same customer number so find the row which has the customer number 471 get all the information from that row and add it to this row okay similarly we want the server to look at the second row and see that we have customer number 299 here find the row in the customers table which has the customer number set to 299 so because we're comparing the customer number columns get all the information from that row and add it here and let's run that okay did that lead to an error let me just check this um maybe I have a maybe I have a typo here somewhere but yeah sorry I think I had a typo there but yeah just repeat select star from payments join customers so you want to join payments with customers on the column customer number and now what SQL is doing is it looks at a row in payments it sees a customer number there and when it sees a customer number from the payments column it looks for a row within the customers table with the same customer number so this customer number comes from payments and this customer number comes from customers and then it takes all the information for that row and it adds it to this row so now we have not just the payment information but we also have the customer information attached with each payment so that is join okay now we probably don't want all the rows here so that's why we may want to just select some rows so I'm just going to select check number payment date amount um customer number customer name and the phone number so I just keep the check number payment date amount and I just want to keep one of these columns because these columns are a bit ambiguous they come from both so I'll just keep customers Dot customer number which I know is going to be equal to equal to payments.customer numbers and then I'm just going to keep the customer name and phone number okay so now we have check number payment date amount customer number customer name phone number and then we can Now cover the additional criteria which is we want to show just the 10 most recent payments so we want to order by order by payment date descending and limit it to 10. okay so now we have just 10 now we have just 10 payments the 10 most recent payments and you can verify this that these are the most recent payments six zero nine six zero three five twenty five and so on and then we have the amount customer number customer name and the phone number okay now the key thing for you to understand here is the join how it is how it how it works it looks at payments looks at the value of customer number and it picks a row from customer number which matches it okay inner join what does that mean well there are several customers who may not have made a payment in the last 10 days or who may not have made a payment at all so if I remove this for a moment order by Etc there are several customers who may not have made any payments so I probably don't want to show the information for those customers who have not made any payments right now if I do this inner join here or if I do this normal this is the inner join I can also type inner then what I'm telling SQL is don't show me customers for which I don't have any payment information but if I change this to Outer join now we are telling SQL okay maybe it's like a full outer join or let me look up the syntax but if we change this to a outer join then we would get information for all the customers right so we would not only get information for customers who have made payments but we would also get information for customers who have not made payments and what is going to be present in the check number payment date and amount columns empty it's just going to be empty so just going back here if table 1 is payments and table 2 is customers then when you do an inner join we only look at those rows where these values are present in both the columns for for example if customer number one and two occur in payments and customer number one three and four occur in customers then we will only pick one because that's the common column and that's what happens when you do an inner join it just picks the common values on the other end if you do an outer join then we're going to pick we're going to have a row of row for customer one we're going to have a row for customer two these two are in payments and we are going to have a have a row for customer three and four which don't really show up in the customers column in the payments table at all so this is what it's going to be and there is just going to be empty data here okay then there is the left join and right join so we look at these in a second too okay but before we look at left right and outer joins here are a couple of exercises for you show the full office address and phone number for each employee so once again you can guess what this will look like you will say select star from employees and of course now you want the full office data so you have an office code here so you want to do join with offices on employees DOT office code equals offices DOT office code and maybe let's just put the employee number here let's just put employee number and let's put maybe the last name first name and offices Dot address let's just put City right now offices.city so now you have employee number last name first name let's maybe also put office code so offices DOT office code okay so now we have employee number last name first name office code city city San Francisco and then we also want to show the full phone number so office has a phone number so office has a phone let's check what that is Select star from so office has a phone um so we want to show the offices offices.phone information as well so now we have the phone and then every employee has an extension so we can get the EXT column from employee that is the extension let's just check that select star from employees yeah extension so every every employer has an extension so now we have employee number last name first name office code we have the phone number we have the office City and we have this extension we can combine these two so we can say concat let's get that here so we can say concat and we can concatenate the office phone with the extension so now we are concatenating one column from the offices table and one column from the employee table and put those together and let's just call that um employee phone number or employee phone okay so now we have the employee number last name first name office code and employee phone number maybe let's just put that here okay so now we have an employee number last name first name and then we have the employee phone number which is a combination of the phone number from office and the extension from the employee table and then we have the office code and office City and we've been able to do this because we've done a join between employees and offices okay and that's what this looks like here's another example show the full order information and product details for the order number one zero one double zero so here you would have to look up the order details common or the order details uh table and then from the order details table you would have to join it with the orders table to get information about orders and you would have to join it with the product table to get information about the product and then you would simply have to select the data for a specific order number so here you are doing two joins or you're joining three tables so I'll let you figure that out it's not too difficult it is just it is just one more step removed from what we've done so that's basic joins and specifically that's inner joins now let's talk about left joint right join and full joints unfortunately in this data set there's not enough of an opportunity to demonstrate all three so we're just going to look at some examples online and specifically I recommend W3 schools if you're just looking at some SQL syntax or need some help with SQL they have pretty good documentation on all of these so let's talk about left join okay so here's how left joint works I'll you can look at this table and try look at this picture and try to understand what's happening but we have a demo database here so we have this customers table and in the customers table we have a customer ID one two three and then we have a customer name contact name Etc you have an orders table so the customers table will be on the left the customer's table will be on the left and the orders table will be on the right and what we want to do is we want to join customers table with the orders table on the customer ID column so we say select customers Dot customer name comma orders dot order ID so we want to look at for each customer what are all the orders they've placed right so we want to see customer name and we want to see the order ID from the customers table left joined on orders on customers Dot customer ID equals order Dot customer ID so we want to just combine on the customer ID column and we want to order by the customer name so let's run this on you can actually run this online and check so here's our database we have three customers and then we have three orders of course and okay actually there's there's more than that there are a bunch of customers and a bunch of orders so let's just run this and let's see the result okay in our database we have 91 customers and we have 518 orders and not every customer has placed an order so when we do a left join between customers and orders here's what we get we get a customer name and then we get the order ID so it turns out that Alfred F hasn't hasn't put hasn't created any order so that's why we have null here and similarly this person hasn't created any orders that's why we have a null here so for every customer and every order we could find for every customer and Order combination we could find where the orders customer ID matched with the customers customer ID we have created a row and because this is a left join wherever there were certain customers for whom there were no orders there is still a single row that has been kept so Alfred has not ordered but we still have this null here now if we did not have this left join if we just had join here and let's run that you would see that now you no longer have those null columns so now you no longer have a customer name so if a customer does not have a matching order so if a customer column customer row does not have a matching order row then that will be skipped if you're doing a left join you are telling SQL that you want to keep all the rows from the left table which is the customers table and you don't care about all the rows from the order table but you do care about all the rows from the customers table so even if there is no matching Row from the orders table just show that customer name and then show a null there okay so that's left join then maybe let's look at right join so here's an example of right join here we have orders so we have one table of orders and then we have one table of employees okay now for every order that is placed by a customer there is also an employee that is assigned and then we have a table where we have details of employees so let's say we want to get for each order the names of employees who is assigned to that order and let's check it out so this time we are saying select orders dot order ID and employee last name employee first name from orders and we're saying right join with employees so let's run that and let's see what what happens we are matching on the employee ID column so we get the order right we get the order ID and we are also keeping the employee last name and first name so we for every order ID we get the last name and first name of an employee but of course there are certain employees who may not have been assigned any orders maybe certain employees just don't deal with orders they are into their managed people because we have done a right join we are telling SQL that you don't want to miss any rows from the right table from the employees table so you want to show employees even if they do not have any matching order columns so now west Adam West does not have any orders but we're still showing it here we're just showing a empty or null value here instead of course if we did not have joint right join here then you can see okay let's just do an inner join here yeah if we just did an inner join which means we did not do a right join if we just did an inner join here then we would only get those employee names who have valid orders right so just try to remember this picture where inner join means that the row must that that value must exist in both columns in both tables left join means that all the values that exist in the left table show up right join means all the values that exist in the right table show up an outer join a full outer join tells you that you want to maintain all the rows from the left left table you want to maintain all the rows from the right table as well and you want to fill in nulls wherever possible so here's an example we have a customer's table and then we have an orders table and I believe we are doing a full outer join on customers and orders and this time you will see that there are certain order ID table certain order IDs that may be null and sometimes a certain customer name may be null right so that's how an outer join works so just keep this picture in mind this one outer join means you want to retain all the values inner join means you want to retain just the intersection of the common values left join means you want to retain all the values from the left table right join means you want to retain all the values from the right table okay and one last thing a table can also be joined with itself you don't have to do a join between multiple tables and each instance of the table can be given a temporary Alias so you need to rename those tables because otherwise if you're just joining a table with itself it may get confusing when you are explaining which columns to join on so here's an example remember employees employees have this reports to field which reflect refers to another employee so let's say we want to show a list of employees with the name and employee number of their manager so let's do select star from employees okay so now we have all this information we have employee number employee last name employee first name and then a bunch of information and then we have this thing called reports too so every employee on most employees except the president I believe most employees report to another employee so now if you want to show who they report to we want to get information about who the report to what do we do well first let me just simplify this output a little bit let me just put in employee number and let me put in last name and first name and reports to so that we just have this information that we really need okay now I want to take the reports to number and get information from the employee table and insert that information here as new rows so we say from employees join employees but of course and this is an inner joint of course by default so first Let's do an inner join and then we'll see if this needs to be a different joint so we say employees join employees and now this can get confusing because your both of these are called employees so let's call up call one of these e so you just give a space and then type a temporary name you don't put as here you just put a space and let's call this m so E4 employees and M4 manager okay so now we are joining and how are we joining we want to join now this gets interesting here from E from the first from the left table we want to look at reports to and from the right table M we want to locate the employee number so from the employees table we want to take the reports to information and we want to find the corresponding column where the employee number matches this reports to a number okay so think of employees and managers as different tables they are the same table but think of them conceptually as different tables we capture this number and we get that information from the M table so that's why we have reports to equals employee number and let's grab some information here from the other side as well so from m let's grab the first name and let's just call that manager first name and from M let us grab the last name as well m dot last name and let's call that manager last name and from M let's also grab the employee number well actually we have that already we have reports too so that's that there we go so we have select employee number first name reports to and we want to select okay now reports to let's just put in E dot because this is going to get confusing otherwise or SQL and we want to select m dot first name and we want to select m dot last name as manager last name from the employees table I think I may have a typo here let me just grab this okay I think I may have a typo here so I'm just going to fix this right now but yeah so we have e dot employee number and we have e DOT first name and we have I see what the issue is because we have all these columns in each of the tables so we just need to add e Dot so we say we have an employees table joined with the employees table one is called E1 is called M so we have e dot employee number e dot last name e DOT first name reports to m dot first name m dot last name from employees join employees on the reports to column joined with the employee number column okay so this is probably the most confusing part of it all so now for every single employee who has a manager because this is an inner join remember so for every single employee who has a manager we get their employee we get their manager information as well so we get the name and last name of their manager maybe we can concatenate this so let's maybe just do concat m dot first name and m dot last name as manager name so now we have this information about each employee they we have their last name first name employee number and then we have the employee number they report to and we have the name of the their manager let's just add a space here as well okay now one last thing here that we would want to just cover is there is a certain employee the president who does not report to anyone and we have not shown that information here because we are doing an inner join so because the president Diane Murphy does not report to anybody so that row gets skipped but instead if we do a right sorry if we do a left join what we're telling SQL is we want to maintain the list of all the employees from the left table e even if they do not have a person that they report to so now if you check you have an employee number one zero zero two Murphy Diane and for them reports to his null and of course null value doesn't show up in the other table so their manager name is also null okay so now you see that this is supposed to be a left join and why this is supposed to be a left turn left join and not an inner joint because you want to show all the employee numbers even if they don't have a manager now suppose instead of a left join you had done a right join what would happen now so now we're telling SQL that only show me employees from the left table who have a manager but on the other side on the right side if there are certain employees in the M table which do not feature in the reports to column you should still show them so let me run that and let me show you the result so it seems like the result hasn't changed so one thing that has happened is Diane Murphy has gone away but if I scroll down here you will see that now I have Leslie Jennings Leslie Thompson Julie farrelli all these people who do not have any reportees still show up this is because we are doing a right join we are saying that every Row from the M table should be represented even if they don't have any matching information in the etable so that's the that's the issue with the right join and if we did a full outer join or I think it's just called an outer join okay I'm not sure what the outer join in MySQL is I guess it's just called full outer join okay I think I'll have to look it up but if we did the full outer join then we would see this we would see Diane Murphy and we would also see all this information Larry bolt Etc okay we'll check this out what how do you create a outer join in MySQL okay never mind so that's joins and here are some exercises for you to try out to become familiar with SQL joins report the account representative for each customer report the total payments for the Atelier graphic this is one of the I think this is one of the customers report the total payments by date report the products that have not been sold ever list the amount paid by each customer and so on so each of these will require a certain join not all of them may require joins and for some of these it's possible that you can do them without joins in some cases you will also have to do some other things like arithmetic operations etc for example list the names of products sold at less than 80 percent of the MSRP there are two ways to improve query performance in MySQL especially when you're working with really large data sets one is to create an index now if you often search or order data by a particular column that's not a primary key then you can add an index to make the query performance faster for example if you search by customers last name a lot or if you order by customers last name or not then you should do this you should run this command create index customer last name and give it whatever name you want so you say create index so and so on the table customers using the column contact last name so if we do this if we just run create index customer last name index on customers what we're telling SQL is that we want SQL to track the contact last name information the contact last name column in the customers table and set up a way for us to efficiently do queries on that column so what does this mean well the next time we do a query on the last name let's say we do something like this select star from customers where contact last name equals Lee because contact last name has an index this query will be very fast if the contact last name did not have an index then this query would be fairly slow and the difference would be if the contact class name did not have an index then SQL would have to search through all the rows but if the contact last name does have an index then SQL can actually avoid searching because it has set up some ways to efficiently track information and search information from the contact last name column in fact it is using a data structure called a b tree and you can see what kind of index is created or what kind of indexes you have on a table simply by typing show index from table name so you can see that we have the primary key which is tracked using an index because typically you extract information using fine primary key we have a foreign key so every foreign key also creates an index but then we also have this customer last name index which we just just created and this index is represented as a b tree which is a data structure an efficient data structure optimized for querying so whenever you query by last name that is very efficient not only querying but ordering by last name is also efficient so you could do something like this select start from customers order by contact last name limit 10. again if you have an index this is going to be fairly efficient if you don't have an index it's going to be slow it's not going to make a difference for this database the that we are working with right now but when you have a really large data set a really large database with millions of rows then this will start to make more sense so if you are doing some queries and those queries seem to be taking a long time maybe consider creating an index or maybe consider asking the database administrator to create indexes on the columns that you are ordering by or searching by most frequently okay and indexes can also be created on multiple columns if you put conditions on multiple columns frequently so you can check that out then another thing that you can do is create something called a view so if you perform a query or if you perform a query very often or if you very frequently join tables for querying then you can create a virtual table out of that query and this virtual table is called a view so here is how a view is created so we'll see how views created and how it's used and then you probably see more learn more about how it works so to create a view you say create view USA customers as you type the name of the view and you type as and then you type a query like you normally do so instead of doing select star from customers where country equals USA so this is all this is the information about all the American customers what we want to do is we want to take this query and we want to give it a name USA customers so let's say let's say create view USA customers and that is now going to represent this query the word USA customers how do we use it we use it just like a normal table now let's say we want to get just the customers who are in California so we can do this select star from USA customers so now we refer to this view which we have created already it's saved in the in the database that view so select start from USA customers customers who are from the USA where State equals CA and when we run this you can now see that we only have customers from USA of course that's because this the state is CA but you can see that USA customers actually used information from this query that we had defined earlier okay so conceptually what's happening is wherever the SQL Server sees USA customers it's simply going to replace this with this select start from customers where country equals USA and in fact you can also run this okay this is not going to work directly but yeah uni once you create a view and use the view so SQL is going to replace the view name with the actual query that you have provided now typically when you create a view no new data gets created it's simply that information that is tracked which queryer viewed represents but certain relational databases also support creation of materialized views so let's say you're doing joins between certain tables very often and then you are getting information about the from that joined table from that joined uh query then you can create a materialized view which is going to contain the joined version of the two tables so that whenever any of those two tables is updated the view gets recreated and that is uh like a separate table that is always tracking the latest version of the joins of the two tables and that takes up more space but that makes it very efficient to query so now whenever you make queries on that view instead of rerunning the query that creates the view it it will have the view already as a table saved within the database and all that information will be cached so you can get that you can get the result out of the view very easily okay so right now by default we are not actually creating a table USA customers but if you make this a materialized view then the database is actually going to set up this table call USA customers somewhere and that is going to be kept up to date with the list of customers from the USA okay so that's materialized views not something you'll have to worry about or work with often but in case you come across the term that's what it means let's talk about executing SQL queries using python one way we've seen how to execute SQL queries is using the MySQL command line interface another way we've seen how to execute SQL queries is using the MySQL workbench and the Common Thread here is all you need is to connect to your SQL Server your database server that could be running locally that could be running on the cloud and once you have connected to that server you need to be able to send instructions to the server the queries that you wanted that you want to send that you want to perform and then the database server is going to give you back the results and you should be able to understand the results so this is something that you can do from any language every language has some libraries for working with SQL relational databases in Python one of the most popular libraries is the SQL Alchemy Library so you can look it up this is SQL Alchemy or SQL Alchemy and it's a very powerful toolkit for python that pretty much everybody who uses SQL databases and does some programming in Python uses this library in fact we use it on Jovian when you open your profile page to get the information for your profile we use the SQL Alchemy library to get information out of a mySQL database and then we display that information to you on the profile page okay so it's a very powerful and a very efficient Library as well it's as it says here it provides Enterprise level persistent patterns designed for efficient and high performing database access adapted into a simple pythonic domain language okay so that's the library we are going to use now here's the other thing there is not just a single relational database there are many in fact here are some so MySQL is one that we've looked at apart from that there is something called postgres so this is sort of a slightly more advanced version of MySQL where it also supports latitudes and longitudes is also supports like a Json column type it has more column types um then there is something called sqlite so sqlite is a less is a limited version of MySQL and sqlite is typically used for situations where you can possibly you possibly cannot set up a entire server and you just have to maybe work with something very light so sqlite instead of setting up a proper database server Etc simply uses a file on the disk and that file just works as a database of course everybody uses a disk but sqlite just makes it very efficient and very fast and very small so typically this is used in let's say in in your phones so any Android app or any IOS app that you use is if it stores any information on your device typically that store that information will be stored in a sqlite database because it has very low memory and CPU requirements of course it is it does not implement the entire SQL language it only implements parts of it and it sort of cuts Corners here and there to make it possible to use SQL in a very a low memory setting in fact in your in your assignment you will be using sqlite so that that is something that can run easily on binder setting up MySQL and binder is a big challenge so we're just going to use sqlite apart from that you have some proprietary databases like Oracle so Oracle has its own database again that has its own flavor of SQL then you have the Microsoft SQL Server so that has again its own version of SQL there are some changes not all the commands work work exactly the same way and in fact if you look up any SQL tutorial they will tell you what the differences between the different flavors of SQL are right for example w3schools is the one that I would recommend and here on the side you can see all the possible different um things that you do that you can do with SQL and if you open any specific example here like alter table you will see how these are different across different SQL databases so alter table which is to change the column name Etc this is how it works on SQL Server this is how it works on MySQL this is how it works on Oracle in this case I think they look the same there's no change here but there are other things probably with constraints where things would be different yeah so you see here this is how it works with SQL Server this is how it works with mySQL so if you're putting some sort of a unique constraint in SQL Server you put it here in MySQL you put it at the end and so on so just look things up don't worry about knowing all the different variants of SQL but the way it is relevant for us here is SQL Alchemy does not include all of these connectors to all of the different types of relational databases so what you'll have to do is maybe you'll have to use some kind of a connector a connecting Library so for example if you are connecting to mySQL then MySQL python is a commonly used connector so you will have to either use MySQL python or there's another connector called Pi MySQL so there are several connectors for MySQL right so SQL Alchemy gives us the python interface for writing SQL queries and then internally it uses one of these libraries to connect to the specific kind of database that you want to work with so you'll need to install both so now we are going to install SQL Alchemy and we are going to install Pi MySQL so let's install both of them SQL Alchemy handles the python Side by MySQL handles the MySQL side and I'm just going to create clear output here and let's import so here's how you connect to a SQL database the first thing you do is you say from SQL Alchemy import create engine so import create engine and create engine takes a string a connection string so what you do is you say create engine and then you give it this string this database connection string which contains all the information required to connect to the database now remember MySQL workbench here when we try to connect to a new database we would have to provide a hostname we would have to provide a port we would have to provide a username and a password so it works exactly the same way here we say uh what kind of database we want to connect to so we want to connect to a mySQL database so that's why we have MySQL here we say what connector we are using now even for MySQL there are several connectors that people have written for SQL Alchemy so we we are using the pi MySQL connector if we were using the MySQL python connector then this value would be different but in any case we want to use the mySQL database so this is the kind of database that we are using plus this is the kind of connector we are using pi my SQL then we say colon dot dot and this is just a standard syntax then we provide the username and after the username you provide the password so normally you shouldn't type passwords out but let's say if you wanted to provide the password directly you would say username colon password then you Pro then you type at and then you type the server so the host name that you put here 127.0.0.1 which means the local computer this is just short for the local computer is a standard host name um and that is also known as localhost so this could be 127.001. this could be localhost both of those mean connect to a database on this computer but if you are connecting to a database somewhere on the cloud then you should get the username and the password and the host name for that cloud database next you provide the port so for every database there are certain Port that you connect at 3306 is the default Port that is used in most databases but if there is a different port then you can ask your database admin to give you the port so once again you get the type of database that you're connecting to the type of connector you're using colon slash slash the username password at localhost colon the port slash the name of the database that you're connecting to okay this is not something you have to remember you can always just look up SQL Alchemy connection string and let's say you want to look it up for SQL Server so you can just search connection string for SQL Server and you can see what that connection string will look like so for SQL Server this is what it will look like my seek Ms SQL plus pyo DBC so the pyo DBC is the connector and then username password add server so server would be localhost colon 3306 or some other online server slash database okay now one thing I've done here is instead of putting the password I want I don't want to type my password into a jupyter notebook so I have just imported get pass and I'm going to run get pass I'm going to type the password Here so now the variable password contains the value of the password that I just typed in but I'm not going to display it in front of you because I don't want you to show you I don't want to show you I don't want you to see my password so what I'm then going to do is use string formatting to insert the password into this string so now I have the connection string inside which I have this Gap using these quotations using these brackets and then I'm calling dot format password and that's going to put the password into that Gap okay so never put your password directly into your jupyter notebook especially at work because that's going to be very bad because then anybody who has your jupyter notebook will be able to use your account always use get pass so just put the password into a variable and then pass that variable using string formatting into the connection string and that then creates this engine okay so now we've created this engine so what has happened so far nothing really it we've just set up this object and we've given all this information to SQL Alchemy then we actually connect to the engine we say with engine.connect as con conn and then we can execute SQL queries okay so we connect to the engine as con and why do we have this width well this automatically takes care of closing the connection once we get the result so we say c o n n dot execute and now I'm connecting to my local database so make sure that if you are running this on your computer you have the SQL Server MySQL server running and if you're running this on binder obviously it's not going to be able to connect to your local computer so make sure that you're running this locally on your computer okay so now we say connection dot execute and we have a query so we have select office code comma City comma phone from offices so let's see what this query gives us in the SQL workbench okay maybe first I should do use database classic models or just use classic models yep and now I can select office code city phone number so expect to see information like this seven office codes and then the city and phone number so I get the result from con.execute and let's look at the result the result is this Legacy cursor result it doesn't give me much but you can convert that result into a list so you just call list on it and that gives you this list of offices or list of results and let's check that so here now you get one San Francisco plus one six five zero two one nine to Boston plus one two one five and you can match that information up here okay so quick recap install SQL Alchemy install the connector import create engine then create the engine using this connection string which contains information about the kind of server the kind of database you're using the kind of connector you're using the username password hostname and port and database name of course don't type your password directly get it using get pass once the engine is created connect like this and then get the result and now you have this result here so now once you have this result this is a python list and it's a list of tuples the idea I wanted to take away is that you can create this engine create a connection and then get data out of a SQL database using python now of course this is a lot of work and that is where you have this nice neat little Library called IPython SQL probably one of the most wonderful libraries I've come across because it takes away so much of the complexity that you have to take care of when you're connecting to SQL databases so the IPython SQL Library provides something called Magic commands to write raw SQL queries in Jupiter so you just type raw see you just type a SQL query within Jupiter and that will execute and that will get you the results and it'll give you the results in a nice tabular format something that you can use within Python and in fact it uses SQL Alchemy under the hood so you want to have SQL Alchemy installed and you want to have the right connector installed so for example in this case I'm using pi MySQL so I have SQL Alchemy installed I have Pi MySQL installed and now I'm going to install IPython SQL so install the IPython SQL Library and now it really is Magic because and these are called Magic commands the first thing you do is you have to load this extension within the jupyter notebook so you say load EXT so you type this percentage symbol you type load EXT and then the extension that we're loading in is called SQL and once you type this once you run this cell low dxt SQL then you will be able to start using this new command called SQL so anything that starts with a percentage is called a magic command in Jupiter this is no longer plain python now this is some instruction that we are sending to Jupiter so here's what you can do you can type percentage SQL okay and then you give it a connection string so for example if you give it MySQL Plus Pi my SQL root colon and then you put in the password here let's say the password is just password at localhost colon 3306 and slash classic models okay and I'm just going to reveal my password here for a second so I'm just going to the password is well it's akash123 so if I run this classic models yeah so if I run this now I am connected to the now I'm connected to them to the database right I have just typed MySQL plus pi my SQL colon root so username slash password so this is a SQL Alchemy collection string now instead of having to do import engine create engine etc etc I can just type colon SQL give it the connection string and that is just going to connect to the to the database now what to do if I don't want to reveal my password I would do from a get pass import get pass and then I would run get pass and okay maybe I should put the result into password okay and then I type my password so now this variable password has my password and then I can take this and just put it into a string so I create a normal connections Str I create a normal python variable and I just insert the password here so I do dot format password and now I've created this connection string so now I want to instead of typing out the full connection string I want to pass the variable connection string and we do that by in Magic commands we pass value from variables using these brackets okay so when we type this when when we have when Jupiter sees this bracket it says okay let me take the value of connection Str which is all of this with the password replaced here and let me replace this with that value uh sorry with with all of this stuff okay so this is all a roundabout way of hiding my password but in any case the the point being you just provide the connection string either you type out the entire string including your password or you put the connection string into a variable and you pass it using this bracket but just with this one line of code we are now connected to the database and we can now execute queries and here's how you execute queries you type percentage SQL and then you just type the query like select office code city phone from offices so there you go so now you can see that it's telling me that I'm connected on using this connection root and it hides a password thankfully so yeah so we've typed this query and here is the result of the query so the result is office code city phone one two three four five six seven San Francisco Boston Etc and the phone numbers if you have a multiline query something that you need to split across multiple lines then just put a double percentage and when you put a double percentage then this entire cell is passed to this magic command when you put a single percentage that just works for a line the double percentage works for an entire cell so let's run that so now here we are doing the same thing remember for every year and every month we want to get the total payments so that's what we have here year month total payments by as a result of this complex SQL query percentage percentage SQL and then you type the name they type the query and that's the data here's when it gets even a more interesting you can actually combine python code and SQL code so here's what I'm doing I'm saying earnings result equals and then from this point on once I type percentage SQL jupyter detects that this is a magic command and it's going to read all of this as SQL code okay so what's happening is that all of this is being passed into this magic command percentage SQL and that magic command is going to under the hood use SQL Alchemy create a connection using the connection string that we had set up and pass this SQL query to that connection and from that connection get some results and then take those results and convert that into this format okay and then that data frame kind of format is going to be put into this variable earnings result so you type the variable name you type equals and then you type percent SQL and then you simply type the query and now you have earnings result that was the topic for today as I've said W3 schools is a good resource and I would just go through all of these just to get a sense of everything SQL has to offer and use this notebook to learn how all of these things fit together so we looked at aggregation grouping pagination in SQL queries we looked at mapping functions arithmetic and working with dates we looked at how to combine data from different tables using SQL joins we looked at improving query performance with indexes and queues we looked at how to use Python to execute SQL queries which is to get SQL Alchemy get a connector created connection string pass put the password into it securely create an engine runs queries or we could just use the IPython SQL magic commands and simply use direct raw SQL statements inside a jupyter notebook so what should you do next you should definitely check out some of these other challenges on the classic models database this is from this professor his name is Richard T Watson it's a great database and he has also given you a lot of questions to solve so there are what about a 100 or 120 questions that you could um try and solve so the more it's all about exercise SQL there's no other way to become an expert at SQL and I wouldn't say I am because I haven't done enough exercises here's one more set a different database that you should look at is the database system Concepts book in on this book page on dbbook.com you have a bunch of exercises so you can check here Sam sample lab exercises and term projects so here you can figure out there is a basic SQL file just like the classic models database and there are a bunch of exercises like here are some Advanced SQL exercises and this is all based on a university database so here you have all these questions the university allows an f grade to be overridden by any pass grade create a view that lists information about all fail grades that have not been overridden and the view should contain all attributes from all the tech all the takes from the takes relation right so there's a lot going on here and of course this is more advanced and then you have some more basic and intermediate questions as well right so these are two good databases the classic models database and then the student University database you also have solutions for the classic models database so if you want to check out Solutions this person is very kindly put up their Solutions so you can look up the solutions to the different Channel challenges here yeah so these are some of the solutions for the classic models database try that out then you have these interview questions with SQL this is a this repository has been created by Alexi grigurev he actually did a webinar recently a few weeks ago with us webinar on machine learning but he has created this repository called data science interviews and specifically in this repository you have under technical questions yeah under technical.md you have SQL so just check out SQL and here you have a bunch of questions I think probably over 50 or 60 Questions and in you can see some of these get pretty big but the concepts are the same you see select order by join and then you're taking the result of one query and then using that as a table in another query and so on okay so that's SQL for you yeah I think there are about what's this 11 questions here but they cover a lot of different use cases then w3schools is a great place to learn SQL Alchemy is again if you want to learn more about SQL Alchemy the object relationship mapping here's one tutorial that I found and went through it seemed good otherwise reading the official documentation is always a the best way in the most comprehensive resource I wouldn't worry too much about this right now as long as you can just connect to databases and make some queries you should be fine and finally if you really want to get a book then the this is the book I would recommend this is the book so one of the authors is the professor who I learned SQL under he was my college professor but yeah this book overall is still great and even if you don't want to get the book I would definitely check out the slides whenever you want to get deeper into SQL I would definitely encourage you to check out the slides on this book for sure hello everyone this is Samantha and welcome to the series solving SQL interview questions and the series we'll be covering four SQL interview questions that were asked at Amazon Netflix Uber and Google Now before we go ahead and start solving these SQL interview questions this is something that I'd like to introduce you to First and that is threestep approach for solving any SQL interview questions generally in an interview you're not always expected to give the correct answer but the interviewer would like to know what is the approach that you have tried for solving a particular problem and this is where a threestep approach might help you step one of our approach is understanding the inputs and the outputs do not jump into solving the query as soon as you see the question understand what are the inputs that you should be using and what are the outputs that your final result should be containing step two articulate Your solution verbally once you've decided what are the inputs and the outputs explain your interviewer what is the approach verbally get a confirmation of your understanding and then start writing your query step 3 construct the query step by step once you've decided what are the inputs and the outputs once you've gotten a confirmation of your approach break down your SQL query into steps and print out the results of these intermediate queries and then improve your final result so now that you've gotten an idea on how to approach an SQL interview question let's go ahead and solve one as you can see on the screen the platform that we'll be using in the entire series for solving the interview questions is known as the strata scratch and if you look at the screen on the left side you can see the questions and all the required information that you need to know and on the right side you can start writing the query now make sure that you're signed into stratascrash.com before you actually run the code or else you will not be able to run the code unfortunately you'll not be able to check whether the solution is correct or wrong but we'll be sharing all the required links for practice and to check whether your solution is correct or wrong down in the description so do not worry much about it in this video we'll be solving an SQL interview question asked at Apple as you can see on the screen the problem that we'll be solving today is customer details find the details of each customer regardless of whether the customer made an order output the customer's first name last name in the city along with the order details you may have duplicate rows in your results due to a customer ordering several of the same items sword records based on the customer's first name and the order details in ascending order as you can see we have two tables customers and orders let me just quickly have a look at all the columns that are present in both the tables customer stable contains ID the first name last name city which we want and the order stable contains ID customer ID which I believe this customer ID is the same as the ID present in the customers table and Order date and Order details which again is something that we want according to our approach the first step of solving an interview question is understanding the inputs and the outputs now what are our inputs since they said find the details for each customer regardless of whether the customer made an order I am going to use the customer ID as one of the inputs and they have mentioned what the output should contain and they've mentioned that it will contain some duplicates now they also set to sort records based on the customer's first name and the order details so my inputs will also contain customers first name and Order leaders to perform the sorting and the output should contain customers first name last name and the city along with the order details so these are going to be my inputs and the outputs the second step of our approach is articulating the solution verbally to the interviewer in our approach we have established that the output should contain first name last name city which is coming from the customers table and it should also contain order details which is coming from the orders table which means we have to combine both of the table results to get the final output and for that I can perform a join now what join do I have to perform given that I am joining customers table on the orders table I'll have to use a left join so that I'll get all the customer details present in the customers table irrespective of whether they've made an order or not and that's what the question States so I'll be performing a left join on the customer's tables with respect to the orders table to get the final output result finally they've also meant mention that we have to order it by first name and also order details so this is going to be my Approach now the third step of our approach is constructing the query step by step and the first part of our query construction is performing the join select since my output should contain first name last name City and the order details these are the column names that will be present in the select statement first name last name City order details prom customers left join orders on customers dot ID is equal to orders dot cast ID because we have established that customer ID is the ID that is common and similar to the ID in the customers table so let me just run this as you can see the left join has been performed and whenever there is a customer who made an order the order details value is filled and if that customer has not made any order that order detail section is empty now the second part of our query construction is ordering this by order details and the customer's first name so I'm just going to say order by first name comma order details and I'm going to run this as you can see this has been ordered according to the first name and Then followed by the order details so yeah that's what they've been asking us in the question thank you so much for watching welcome to the series solving SQL interview questions in this video we'll be solving an SQL interview question asked at LinkedIn the problem that we are solving today is salaries differences write a query that calculates the difference between the highest salaries found in the marketing and Engineering departments output just the absolute difference in salaries and the tables that are given to us are DB employee and DB Department according to our approach the first step of solving the SQL question is understanding the inputs and the outputs for that I quickly just want to have a look at all the columns that are present in these two tables so that I'll know what inputs I have to give to the table to get the salaries difference output as you can see it contains ID first name last name salary so since they asked us to calculate the highest difference between the salaries I'm going to use the salary column as my input and this department ID and in the DB Department table I have ID and the department I believe this ID is similar to the department ID present in the employees table and as they mentioned in the question they want specifically for marketing and Engineering departments department is going to be my other input what is going to be my output output just the absolute difference in salaries so these are my inputs and the outputs now the second step of our approach is articulating a solution verbally to the interviewer as we've discussed that the columns that we'll be using are salary and the department and what they've asked us to calculate is the highest difference of the salaries between the Department's marketing and Engineering so when they're saying highest you probably are expected to use the aggregation function Max in the each department and calculate the difference between them so my Approach is probably going to be first thing I'll perform a join between the DB employee and DB Department so that I can get the Department name and the first thing I'll do is write a select statement which will get me the maximum salary from the Department marketing and I'll write another select statement which will get me the maximum salary from the Department engineering and then I'll calculate the difference between this select statement and the other select statement get the absolute difference and that's what they're looking for there's also another way that you can approach this problem without having to use two select statements and that is by using a self join with the help of table aliases now right now we are performing a join of DB employee with DB department so that we can get the Department name right what if we know what is the department ID of the department names marketing and Engineering we can simply just use this department ID within this table calculate the maximum salary of that particular department and minus it with the maximum salary of the other department by performing a self join now the third step of our approach is constructing the query step by step in the first part of our query construction is calculating the maximum salary for the Department's marketing and engineering so for that I'm just going to say select Max of salary from DB employee join with DB Department on DB employee dot Department ID is equal to DB department DOT ID I'm going to give the where clause for the department so that I'll get that specific Department maximum salary where DB department is a code okay so I think I should say DB department DOT department is equal to marketing so let me just execute this and as you can see INF got the maximum salary for the Department marketing similarly I'll also be calculating the maximum salary of the department engineering and then I'll get the absolute difference between these two select statements so for that what I'm going to do is I'm going to put this entire statement in one bracket and I'm going to do minus then I'm going to copy paste the same syntax here because it's almost the same thing except for the marketing name instead I'm going to say engineering so these are the two select statements and I'm going to perform absolute difference between these select statements so that I will get the difference between the highest salaries of the Departments so I'm going to say select absolute difference of these and I'm going to give this an Aliyah's name as salary Tiff and then I'm going to execute this as you can see we now have got the absolute highest salary difference of the Departments marketing and engineering so this is one way of our approach as we've discussed is another way of approaching the same problem which is by using a self join first let me just see what are the department IDs for the Department names marketing and Engineering so I am just simply going to run this and as you can see engineering is having the department id1 and marketing is having the department id4 so using these numbers in the department ID column of the DB employee I will perform a search join to calculate the highest difference so for that I am going to say select Max of a DOT salary minus Max of B dot salary and I'm going to give this as salary difference from DB employee a and I'm performing the self join here DB employee B using table aliasis where a DOT Department ID which is equal to 1 and B Dot Department ID is equal to 4. one is for engineering and four is for marketing and I'm calculating the maximum salary of the engineering and maximum salary of the marketing and I'm performing the difference and since they said they want the absolute difference I'm going to say absolute of this and then run the score and as you can see we got the same answers so yeah that is how you approach these kind of SQL interview questions thank you so much for watching in this video we'll be solving an SQL interview question asked at Facebook which is a part of meta let's go ahead and start solving as you can see on the screen the problem that we'll be solving today is popularity percentage find the popularity percentage for each user on meta Facebook the popularity percentage is defined as the total number of friends the user has divided by the total number of users on the platform then converted into percentage by multiplying by 100. output each user With their popularity percentage order records in ascending order by user ID the user run and user to column are page of friends so according to our approach the first step of our query construction is understanding the inputs and the outputs let's go ahead and take a quick look at the table and we can see that it is user 1 and user 2 and these user run and user 2 columns are paste of friends so we have to use both user1 and user 2 as our input columns and the output should be each user Along With their popularity percentage now the second step of our approach is articulating a solution verbally to the interviewer according to our approach they've asked us to calculate the popularity percentage right which is basically total number of friends a user has divided by total number of users on the platform into hundred before we actually multiply with 100 and get the percentage we first need to figure out how to calculate the total number of friends a user has and also the total number of users on the platform before I figure out what method or function I need to use to calculate the total number of friends a user has or the total number of users I just want to have a quick look at how the data is in the table for that I'm just going to come back here and see select start from Facebook I'm going to run this and as you can see there is user1 and user 2 where user one two is friends with user two one and one is friends with three and four is friends with one this seems to be a little confusing for me to calculate a total number of friends a user has because seems like one is spread across both the columns and I can understand that the rest of the you know users are also spread across like that so for my better understanding what I want is if I can have all the ones on the left side and their friends on the right side and all the twos on the left side and their friends at the right side it is easier for me to calculate the total number of friends a user has and for that the thing that comes to my head is Union so Union is basically a method used for you to combine the results of two select statements and removes any duplicates present in it so that's how Union works so that is going to buy my Approach for calculating the total number of friends a user has now the second step is calculating the total number of users so if I'm having all the users on the left side and their friends on the right side I can just simply say distinct of user one right that should probably give me the all existing users on the platform now the third step of our approach is constructing the query step by step and the first part of our query construction is calculating the total number of friends a user has let me just go back to my query editor who write that query I already have Select Staff from Facebook friends I'm going to say Union it equal to as your one user I'm going to order this by user run because they wanted the final result to be ordered by the user I'm just going to run this query as you can see we are now having it in the format of all the one on the left side and its friends on the right side all twos on the left side and it's free on the right this is how that Union is working but what exactly is happening here so when you see the first part of a query was Select Staff from Facebook friends right and this is the result now the second part is we are saying use user 2 as user 1 and user 1 as user two so now this column will become user1 and this column will become as user 2. so the union basically combines these two results and removes if there are any duplicates present there so let's just see if there are any duplicates or not as I can see is there any barrage on Akash no and then we are saying biraj and himani so there's already a biraj and himani here so we can remove this and I'm also looking at Akash and himani is there any Akash and himani somewhere here no it's going to stay and there's also something called as himani and biraj there's himani and biraj already here I'm just simply going to exclude this so it is now in the format right on how we wanted it which is all the users on the left side and the respective friends on the right side now this explains the first part of our approach which is calculating the total number of friends a user has now all I have to do is just group it by the user one and do the count of the user too to get how many friends each user has so the second step is of our query construction is calculating a total number of users on the platform so for that what I can do is I can just simply calculate the unique entry of each user 1 in this table right all I have to now do is use this as the input for select distinct user one from this sub query I'm going to give this stabilizer thanks I run this as you can see now these are all the distinct users now I just have to say and oh you can see there are a total of nine distinct users on the platform I just now have to divide the count of each user's number of friends by this into 100 to get the popularity percentage but as you notice here the total number of users on a platform is using this as the input for it to calculate the total number of uses now for me to divide this by this I have to store this result in something so that I can use this as the input for this to calculate the popularity percentage so for that I'm going to use a Common Table expression width is a keyword which indicates that you're writing a Common Table expression and I'm going to give this commentable expression a name with friends as this let me just I'm going to remove this this is my Common Table expression and I'm going to use this as the input for my next query which is calculating the popularity person I'm going to say select user1 which is basically the one for each user the popularity percentage so I'm going to select user one and I'm going to say count of user 2 because count of user 2 is the one which will tell you the total number of friends a user has and I'm going to divide this by select found distinct user one because that is the section which will give us the total number of users on the platform and this entire beta is um the friends comment table expression group it by user one because we want it for each as you can see we now have the popularity now I just simply have to write this with 100 this is the popularity percentage of each user so yeah that is basically how you solve this popularity percentage question thank you so much for watching I will see you guys next time in this video we'll be covering an SQL interview question asked at Uber so let's go ahead and start solving the problem that we'll be solving today is distance per dollar as you can look at the screen you're given a data set of uber rights with the traveling distance distance to travel column and cost monetary cost column for each ride for each date find the difference between the distance per dollar for that date and the average distance per dollar for that year month distance per dollar is defined as the distance traveled divided by the cost of the right the output should include the year month and the absolute average difference in the distance per dollar absolute value to be rounded to the second decimal you should also count both sexes and failed request status as the distance in the cost values are populated for all the requests also assume that all the dates are unique in the data set order your result by the earliest request date first so this is our question and according to our approach the first step is understanding the inputs and the outputs so for that I'm just going back to the question again and they're saying for each state find the difference between the distance per dollar for that rate and the average distance per dollar for that year month so I see that they're asking us to calculate something called as the distance per dollar per each date so I see that we have to use a date time column which I know by looking at the table it has something called as the request State so my input is going to be requested and for calculating the distance per dollar I need to divide the distance traveled by the cost of the right so I'm going to use the columns distance to travel and monetary cost so my inputs are going to be these three request date distance to travel and monetary cost now my outputs are going to be as they explicitly mentioned in the question the output should include year month and the absolute average difference in the distance per dollar and the absolute value to be rounded of two decimals so now the second step of our approach is going to be articulating a solution verbally to the interviewer which is basically explaining our approach and getting a confirmation of our understanding so from the question we understand that they want us to include the year and month which means we are basically expected to extract the year and month from the daytime column which is requested so for that I'm going to use the date format in this way so that it will extract the year and month for me and the second thing they want from us is the absolute average difference in the distance per dollar so for actually calculating the difference first you need to calculate the average right so I'm going to use the average window function so that it is calculated for each and every row then I'm going to use the absolute function so that I'll get the absolute value of the difference that I'm getting then I'm going to use the round with 2 as the input because they've mentioned that they want the final output to be rounded off to two decimals then finally I'm going to group by the year and the month because they specifically said that they want the output for each year and month and also they finally mentioned that order your results by the earliest request date first so I'm going to order this by this date format that we are creating for year and month so this is basically going to be my Approach now the third step of our approach is constructing the query step by step and the first part of our query construction is extracting the year and month out of the daytime column so I'm going to say select date format and our column name is request date and the format that we want is year and month sorry and I'm going to give this entire extracted column a name probably year month and I'm getting this entire data from the request logs table and since they want this for each year month I'm going to group by year month and I'm going to order by year month so this is our code I'm going to execute now and as you can see on the screen we can now see the output for each and every year and month now the next step of our query construction is calculating that difference between the average distance per dollar which is absolute value rounded off to two decimals so for that as we've established in our explanation that we'll be using the average window function so it has partitioned for that each year and month so I'm going to say average distance per okay I think it's distance to travel divided by morning 30 cost so they have mentioned in a question that uh the distance for calculating the distance per dollar it is distance to travel divided by the cost so I've given that now I'm going to minus this by average of distance to travel divided by monetary cost over Partition by since they want this to be partitioned by the year end month which is our date format request State of this year month so the reason why we are using this year month column directly instead of giving it a column name which is year month window function will not be able to identify this prior so we need to specify the entire thing so this is done now I'm going to give this entire column name of function which is probably called as the average difference so this entire thing is again coming from the Uber request logs and order by human Group by your month so I'm simply going to run this query now as you can see it you now have the year month and the average difference but in the question that specified that they want it explicitly as the absolute value right so you now have to use the absolute function and that's what I'm going to do now so I'm going to say absolute value of this entire thing and I'm going to run it differences as you can see this has been rounded off to absolute value which is basically it's returning your positive value now they also want this to be rounded off to two decimals so I'm now also going to use round method so I'm going to say round and then I'm going to come back here and say two and then I'm going to run the code as you can see now this is rounded off to two decimals so that's basically what they're looking for the output should contain the year month and the average difference between the distance per dollar the absolute value rounded off to two decimals so yeah that's how you solve these kind of SQL interview questions thank you so much for watching I'll see you guys next time bye in this video we'll be covering an SQL interview question asked at Amazon so let's go ahead and start solving the problem that we'll be solving today is monthly percentage difference given a table of purchases by date calculate the month over month percentage change in Revenue the output should include the year month date in this particular format and percentage change rounded to the second decimal point and sorted from the beginning of the year to the end of the year the percentage change column will be populated from the second month forward and can be calculated as this month's Revenue minus last month's Revenue divided by last month's Revenue in 200. so they're also giving an idea on how to calculate this percentage change column according to our approach the first step is to understand the inputs and the outputs and we can do that by reading the question clearly once again since they're saying given a table of purchases by date calculate month over month percentage change in Revenue there is some day time column involved here so for me to confirm whether we have a date time column or not I need to have a closer look at all the columns in the table so if I scroll down I can see all the available columns in that particular table which is named as the SF transaction so I see ID created at Value purchase ID so my input is going to be the date time column which is created at and since they are wanting the percentage change in the revenue I'm guessing the value is the one which contains the revenue number so my inputs are going to be created at Value and they say the output should include the month year date and percentage change so my output are simply going to be that month year column and also the percentage change column that will be calculating using the formula that they have mentioned in the question so the second step of our approach is articulating a solution verbally to the interviewer which is basically explaining our approach and getting a confirmation of our understanding specified in our question the output should contain the daytime column in a particular format which is basically in the year and month I'm going to use the date format function in MySQL which will help me extract the year and also the month for that particular output column and they are also asking us to calculate the percentage change in the revenue before we calculate the percentage change in the revenue we first need to calculate the revenue right and for that I'm going to use the sum for the entire value column and group it by the month and year column that we are extracting so that we can get the month wise Revenue and this will generate the revenue for us so once the revenue is generated I am going to now calculate the percentage change in the revenue using the formula described in the question so in that question they are using the terms such as previous month and current month and one function that comes to my head for calculating the percentage change is the lag which is a window function and I'm going to use the lag for that now they've also explicitly mentioned that they want us to round off the entire percentage change to two decimal points and for that I'm going to use the round function with the input as 2 so that the decimal points are rounded off at 2. and finally they want us to order this as per the starting year so I'm going to order it by the month year column that we are generating so this is basically going to be my Approach now the third step of our approach is constructing the query step by step the first step of our query was extracting the month and the Year from the date time column using the date format function so select date format from the created add column it has to be in the format percentage y percentage m and I'm going to give this column a name as your month and this data is coming from SF transactions so I'm going to now run the query as you can see on the screen we have extracted the year and month column using the date format now the second step is calculating the total revenue so for that I'm just going to check sum of value and give this a revenue name and I'm going to group it by this column year one so that I get the monthly Revenue so I'm now going to run the query again as you can see in the output we now have the monthly Revenue now our next step in constructing our query is calculating the percentage change in the revenue using the lag window function and we are going to use the formula that has been described in the question so as described in the question I am going to first use the formula this month's Revenue minus last month's Revenue which is for this month's Revenue I'm simply just going to say sum of value and for last month's revenue is where I'm going to use lag of sum of value okay and since this is a window function to indicate the SQL that this is a window function I'm going to use the over class and I'm going to put this entire thing in Brackets and divide this entire thing Pi last month's Revenue again which is where I'm going to use the lag sum of value and I'm going to indicate that this is a window function and I'm going to multiply this with 100 I'm going to give this column a name percentage Revenue I'm going to run this as you can see the output now we have the year month revenue and percentage Revenue now this next step is rounding up this entire thing to two decimals so I'm now going to use round function and then commit by 2 and then going to run this code again and you should be able to see that this is now rounded off into two decimals now the last step that we need to do is basically ordering this by the year month I'm now just simply going to say order by year month and then I'm going to run and you can see that again this has been ordered so this is our output since our question says that the output should only include the Year date month and the percentage change I no longer need to show this Revenue column so I'm just simply going to remove this or you just simply have the ear and the percentage Revenue so yeah that's how you approach this particular SQL problem thank you so much for watching I'll see you guys next time hello everyone welcome back to the series solving SQL interview questions in our last video we've sold an SQL interview question asked at Google using our threestep approach in this video we'll be solving an SQL interview question asked at Netflix so let's go ahead and start solving as on the screen the problem that we'll be solving today is top percentile fraud on the same platform status crash that we'll be using throughout this series let's take a look at the question now ABC Corp is a midsized insurer in the U.S and in the recent past the fraudulent claims have increased significantly for their personal auto insurance portfolio they have developed a ml based predictive model to identify propensity of fraudulent claims now they assign highly experienced claim adjusters for top five percentile of claims identified by the model your objective is to identify the top five percentile of claims for each state your output should be policy number state claim cost and fraud score but before we get into that I'm seeing terms such as person type so what exactly does this percentile mean percentile is simply a value under which a percentage of data falls into so if you look at the screen we have data points such as 40 50 60 so on total 10 data points and we are being asked to calculate the 30th percentile so the first step of calculating a percentile is arranging the data points in ascending order that is from lowest to the highest the next step of calculating that particular value under which 30 percent of the data Falls is you have to count the numbers from left to right 482 is the number under which 30 percent of the data falls into now coming back to our question where they asked us to identify the top five percentile what they meant is basically finding all the values that fall under the top five percent of the fraudulent claims the first step of our solution is identifying the inputs and the outputs so let me take a look at all the columns that are present in the table to see which will give me the fraud claim so I can see that there's a column called as frog score so I'm going to use this as the input for calculating the fraud claim and since they're saying that they want it for each state I'm going to use the column called as state as mentioned here so my inputs are going to be fraud score and State what are my outputs going to be here they explicitly mentioned that it should contain policy number state claim cost and fraud score now the second step of our approach is articulating a solution verbally which is basically explaining your approach to your interviewer and getting a confirmation so in our questions since they are asking us to identify the top five percentile of claims from each state the thing that comes to my head for calculating the percentile is a window function end tile which will help you calculate percentile squat tiles Etc so my input for the entire function is going to be 100 so that it divides the entire data into 100 equal parts which is what percentile is and then I'm going to use a filtering technique for filtering out the top five percentage now when they said from each state I am using a window function here right and in window function you have a clause called as Partition by which will help you create Windows as per the column that you mentioned in it and since the question says from each state I'm going to say Partition by each state in my window function so that for each state I'm going to get the top five percentile now the third step of our approach is constructing the query step by step I'm going to say select star since they want almost all the columns in the output and tile is the function that I'm using to calculate the percentile with the input as 100 so that the data is divided into 100 equal parts I'm going to use the over class used to indicate that you're using a window function and I want each of this Windows to be partitioned by State since the question States they wanted from each state then I'm going to order this by fraud score the column which contains the fraudulent claims and since they want top five percent I'm going to order this by descending order and I'm going to give this entire entire function column a name which is percentile since that's what we are calculating and this entire data is coming from the so I'm running it okay great I now can see that it is ordered by the fraud score and divided into 100 equal parts now the next step is for me to filter out the top five percentile from this entire query so this table has to be an input for another table so that I can filter it out using the where Clause so that's what I'm going to do now this table is going to be one and I'm going to select star from this table I'm going to give this table a name called as percentile table and filter out where percentile is less than or equal to 5 because we are looking for the top five percentile so I'm going to run this query now and there you go you now have as stated it should contain policy numbers state claim cost fraud score percentile and then you're containing top five percentile for the each state since they said the output should only contain these and you don't want it to show the percentile you can explicitly mention here what are the column names that you're looking for so I can simply say policy num state claim cost comma fraud score from this table and then I'm going to run it so there you go policy number state so these are the top five percentiles of fraud cases from each state here that's how you go ahead and solve this particular kind of questions we will see you guys next time bye let's take a look at the question now find IDs of companies that have more than two users who speak English German French or Spanish so according to our approach our first step is to understand the inputs and the outputs clearly now for me to understand the inputs clearly I need to know what are the columns present in the table Playbook users if you scroll down you will see the inputs that are given to you which is user ID created at Company ID language activated it and state now among these what should be my inputs and how will I know that by reading the question clearly which is find IDs of the companies so I need to use the company ID that have more than two users so when they are talking about users which means I'll also have to use user ID who speak English German French and Spanish so I don't see any columns with respect to this but I can see that there is a column known as language so I now need to filter out these languages from the column language so what are my inputs Company ID user ID and the language Now what are my outputs since the questions only simply States find the IDS of the companies my output will only Simply Be Company ID so my inputs are Company ID user ID language and my output is only simply Company ID now step two of our approach is explain your approach verbally now that you've understood what are the inputs and the outputs you now have to explain to your interviewer what is the approach if you look at the question it says find the IDS of the company so they want you to find for each company which means you have to use a group by Clause known as Company ID and then since they're talking about that have more than two users they want to perform some aggregation function in this case which is count so you're going to have to perform an aggregation function count for finding out more than two users and since they want it for each company you'll have to do something called as Group by for each company who speak XYZ languages so you now need to filter out these languages from the column language so one operator that comes to my mind as soon as I'm checking for a string value is in so I'm going to check whether this particular language is present in the language column or not for that particular user now that I've explained my approach to my interviewer verbally the third step is basically constructing my query step by step and that's what I'm going to do now the first step of constructing my query is filtering out the users who are speaking the languages x y z select since my output should only contain Company ID I'm only going to give Company ID from the table Playbook users where language in I'm going to give English German French and Spanish so I'm just going to turn this code okay now it's showing me all the company IDs where these languages are presenting but since I want for each Company ID I'm going to do Guru by company ID great now the classes they want the users who are more than two in number this is where I'm going to use my having Clause having count or user ID greater than two and now a company might contain like multiple entries I want distinct user ID unique user ID I'm going to say since this side it has to have more than two I'm saying greater than 2 and then executing my query and it says there is some error which says having count oh seems like I have a typo here so I'm going to say distinct and then I'm going to run my code and there you go so these are the companies where there are more than two users who speak the languages English German French and Spanish so this is how you approach in solving an SQL query so keep three things in mind which is basically understanding your inputs and outputs explaining your approach verbally third thing is constructing your query step by step that's it for this video guys I will see you next time bye will you come back
