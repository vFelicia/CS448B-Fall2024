With timestamps:

00:00 - frank dvorak teaches this javascript
00:02 - game development crash course you will
00:04 - learn how to create a 2d game using
00:06 - javascript html css and object oriented
00:09 - programming and frank provides a lot of
00:12 - free sprites and game art assets so you
00:14 - can follow along frank is a popular
00:16 - teacher who creates super creative
00:18 - courses
00:20 - what a strange planet it's completely
00:22 - covered in a thick layer of smoke
00:24 - initial scans indicate there are no
00:26 - organic life forms present but i
00:27 - register a lot of movement coders hope
00:30 - you like making games let's make a 2d
00:32 - steampunk game completely from scratch
00:34 - with html css and javascript no
00:37 - frameworks and no libraries i will give
00:40 - you a lot of premium art assets for
00:42 - characters environments and props and
00:45 - you can do whatever you want with them
00:46 - you can use them in your projects and
00:48 - you can modify them i will show you how
00:50 - to create gameplay variety by giving
00:52 - different enemy types different
00:53 - mechanics that the player can interact
00:55 - with or has to deal with for example if
00:58 - you destroy a hive well a bunch of small
01:00 - drones will come after you let me show
01:01 - you how to give your games beautiful
01:03 - visuals and how to apply many special
01:05 - features i came up with specifically for
01:07 - this class let's go
01:09 - these creatures have very similar
01:10 - physiology to the earth's seahorses body
01:13 - shape like this can cut easily through
01:14 - the thick atmosphere of this planet they
01:16 - can move very fast seahorse hive is
01:19 - being attacked by something this one has
01:21 - been damaged i wonder if we can hug this
01:23 - creature's central computer to control
01:24 - it for a while it is surprisingly easy
01:27 - to override its circuits seems like
01:29 - these machines are not used to our
01:30 - technology i'm getting a lot of new data
01:33 - ok explorers we are getting a stream of
01:35 - data about multiple different species we
01:37 - will convert their source code into html
01:40 - css and javascript let's analyze it line
01:42 - by line and see how it works we have a
01:44 - lot to learn i will answer all your
01:46 - questions as we discover more about
01:48 - their movement special abilities and how
01:50 - they interact with their planet's
01:52 - environment let's look under the hood of
01:54 - this alien ecosystem the atmosphere is
01:56 - thick enough to allow heavy silicon
01:58 - based lifeforms to float but smoke is
02:00 - blocking most of the sunlight many
02:02 - creatures developed artificial lights
02:04 - and glowing appendages to see through
02:06 - the heavy clouds
02:07 - seahorse sentinel has a basic attack
02:09 - that's powerful against weak enemies but
02:12 - if it absorbs energy from one of the
02:13 - overcharged creatures it gets additional
02:15 - firepower for a short period of time and
02:17 - it instantly replenishes its ammo ammo
02:20 - also automatically recharges over time
02:22 - it seems we just need to help it to get
02:24 - through these aggressive swarms in time
02:26 - so it can join its hive if this is your
02:28 - first time discovering javascript you
02:30 - should try some beginner classes first
02:32 - today's coding will be beginner friendly
02:34 - but i expect some basic knowledge of
02:36 - javascript when you get more comfortable
02:37 - with objects arrays and for loops come
02:40 - join me in this class
02:45 - so after a simple basic setup inside
02:47 - index.html and style css we move into
02:50 - script.js all javascript logic for this
02:53 - game will be written here inside this
02:55 - file i create an event listener for load
02:57 - event notice that we call it on built in
03:00 - javascript window object which
03:02 - represents the browser's window load
03:04 - event fires when the whole page has been
03:06 - loaded including all dependent resources
03:08 - such as style sheets and images we need
03:11 - to do this because we will use a lot of
03:12 - graphics in this project and they can
03:14 - take some time to load if you're trying
03:16 - to draw an image with the javascript
03:18 - remember that you always have to wait
03:20 - for that image to be fully loaded before
03:22 - you run the javascript code that depends
03:24 - on that image i usually like to do html
03:26 - kind of a setup like this custom
03:28 - variable i call for example canvas will
03:30 - store the reference to canvas element i
03:32 - point it towards that element using
03:34 - getelementbyid
03:36 - i give it an id of canvas1
03:39 - now i need so-called drawing context it
03:41 - is a built-in object that contains all
03:44 - methods and properties that allow us to
03:46 - draw and animate colors shapes and other
03:49 - graphics on html canvas to create it we
03:52 - need to call a special built-in
03:53 - getcontext method on a variable that
03:55 - holds a reference to canvas element so i
03:58 - say canvas dot get context and then i
04:02 - need to pass it identifier sometimes we
04:04 - call this argument a context type we can
04:07 - pass it 2d or webgl here webgl
04:09 - represents three-dimensional rendering
04:11 - context today we will work with 2d
04:14 - now i access width property on canvas
04:16 - from line 3 and i set it to 500 pixels
04:20 - height will be 500 as well
04:22 - as you can see 500 pixels is wider than
04:24 - my current browser size for that reason
04:26 - i also like to declare max with property
04:29 - and i set it to 100 percent that way the
04:32 - element will scale down until it's fully
04:34 - visible in the available browser area i
04:37 - also declare max height in case the
04:38 - restricting factor is the height of
04:40 - browser window doing this will make sure
04:42 - we can always see the entire canvas
04:44 - element even when the browser window is
04:46 - too small i will zoom out a bit to
04:49 - adjust my workplace for this tutorial
04:52 - i set canvas width to a larger value and
04:54 - keep my browser window small canvas
04:56 - element will scale down to make sure
04:58 - it's fully visible
05:04 - to build our game today we will use
05:06 - object oriented programming which means
05:08 - we will wrap variables and functions in
05:10 - objects javascript is a prototype-based
05:13 - object-oriented language which means it
05:15 - doesn't have classes it has prototypes
05:18 - but we can use modern javascript syntax
05:20 - that introduced classes as so-called
05:22 - syntactical sugar simplified clean
05:25 - syntax that mimics classes from other
05:27 - programming languages still under the
05:29 - hood it's just working with
05:30 - prototype-based inheritance one of the
05:33 - four main principles of object-oriented
05:35 - programming is encapsulation
05:37 - encapsulation is the bundling of data
05:39 - and the methods that act on that data in
05:42 - objects access to that data can be
05:44 - restricted from outside the bundle in
05:47 - this project i will encapsulate our data
05:49 - into multiple classes each class will
05:51 - have its special purpose the challenge
05:53 - for beginners will be to keep track of
05:55 - how these classes communicate with each
05:57 - other i will explain everything step by
05:59 - step as we write the code to help you
06:01 - understand we need to declare our
06:03 - classes in a specific order class
06:05 - declarations are hoisted in javascript
06:07 - but they stay uninitialized when hosted
06:10 - that means while javascript will be able
06:12 - to find the reference for a class name
06:14 - we create it cannot use the class before
06:17 - it is defined in the code this means
06:19 - that i need to declare input handler
06:21 - class first because i will need to use
06:23 - it inside player class and so on input
06:25 - handle class will keep track of
06:27 - specified user inputs for example arrow
06:29 - keys
06:30 - projectile class will handle player
06:32 - lasers particle class will deal with
06:34 - falling screws and bolts that come
06:37 - from damaged enemies
06:38 - player class will control the main
06:40 - character it will animate player sprite
06:42 - sheet and so on enemy class will be the
06:44 - main blueprint handling many different
06:46 - enemy types
06:47 - layer class will handle individual
06:49 - background layers in our parallax
06:51 - seamlessly scrolling multi-layered
06:53 - background and background class will
06:55 - pull all layer objects together to
06:58 - animate the entire game world
07:00 - ui class will draw score timer and other
07:03 - information that needs to be displayed
07:05 - for the user
07:06 - and the main game class will come last
07:08 - inside this game class all logic will
07:10 - come together this will be the brain of
07:12 - our project i hope this gives you a map
07:14 - of what we need to do to complete our
07:16 - game let's write javascript logic inside
07:19 - individual classes and connect them
07:21 - together i will explain everything step
07:22 - by step as we go along
07:25 - [Music]
07:31 - constructor is a special method on
07:33 - javascript class when i call this
07:35 - javascript class later using the new
07:36 - keyword constructor will create one new
07:39 - blank javascript object and it will
07:41 - assign its properties and values based
07:44 - on the blueprint inside player will need
07:46 - access to game weight and height and
07:48 - other properties that will be stored on
07:50 - the main game object so i will pass it
07:52 - the main game object as an argument like
07:54 - this
07:55 - i convert that game object into class
07:57 - property on player class like this
08:00 - i'm saying take this game object that
08:02 - was passed as an argument to the class
08:05 - constructor and turn it into class
08:07 - property called this dot game keep in
08:10 - mind that by doing this i'm not creating
08:12 - a copy of the main game object and
08:14 - placing it on player objects in
08:16 - javascript are so called reference data
08:18 - types which means that unlike primitive
08:20 - data types objects are dynamic in nature
08:24 - i'm just creating a reference that is
08:26 - pointing to the place in memory that
08:28 - stores the main game object so when the
08:30 - values and properties on the main game
08:32 - object get updated those changes will be
08:35 - immediately visible from this dot game
08:37 - reference inside this player class
08:40 - i made the size of player sprite sheet
08:42 - the same size as we will draw them in
08:44 - game it's a good practice i know that
08:46 - the width of a single frame in my sprite
08:48 - sheet is 120 pixels and height is 190.
08:52 - if you are a beginner it's best if you
08:54 - use the same sprites and images i'm
08:56 - using it will make the debugging easier
08:58 - in case you run into problems you can
09:00 - always check my code to find the problem
09:02 - all art assets i'm using are linked
09:04 - below you can download them from the
09:06 - project section starting horizontal x
09:08 - coordinate on the player will be 20
09:10 - pixels and vertical y position is 100
09:13 - player will also need an update method
09:15 - to move it around and draw a method that
09:17 - will draw graphics representing the
09:19 - player
09:22 - for now let's start by increasing
09:24 - vertical y position on the player by
09:26 - speed y i need to declare that property
09:28 - here it will be 0 at first so no
09:31 - vertical movement
09:33 - draw method will take context as an
09:35 - argument this will specify which canvas
09:37 - element we want to draw on in case our
09:39 - game has multiple layers with multiple
09:41 - canvas elements it's also a good
09:43 - practice to use context argument like
09:45 - this rather than pulling ctx variable
09:47 - from the outside directly into our
09:49 - objects
09:50 - at first i will just draw a simple black
09:52 - rectangle representing the player so
09:55 - built in canvas fill rectangle method
09:57 - and i want to draw the rectangle at
09:59 - player's current x and y position and it
10:02 - will have players with and height
10:04 - so we have our player object how do we
10:07 - include it inside game logic and draw it
10:09 - on canvas as i said the main game class
10:11 - from line 45 will be the brain of our
10:14 - entire project all the logic will
10:16 - somehow go through it again i will give
10:19 - it a constructor constructor will need
10:21 - width and height of canvas as arguments
10:23 - and inside we convert them into class
10:26 - properties this will make sure
10:28 - that the width and height of the game
10:30 - matches the size of canvas element
10:33 - constructor on javascript class is a
10:35 - special type of method that will run
10:37 - once when we instantiate the class using
10:39 - the new keyword it will create one new
10:42 - blank object and it will give it values
10:44 - and properties as defined inside the
10:47 - blueprint here
10:48 - i can take an advantage of the fact that
10:51 - all the code inside the constructor gets
10:54 - automatically executed like this and any
10:56 - code i put inside the constructor on
10:58 - game class will automatically run when i
11:01 - instantiate my game in a minute so when
11:04 - i instantiate game class i want it to
11:06 - automatically create an instance of
11:08 - player class and i want that instance to
11:10 - become class property on game class
11:13 - called this dot player so this.player is
11:16 - equal to new player like this the new
11:20 - keyword is a special command in
11:21 - javascript it will look for class with
11:24 - this name in this case player and it
11:26 - will run its constructor method to
11:28 - create one instance of it based on the
11:30 - blueprint inside so by calling new
11:32 - player online 49 javascript will find
11:35 - player class up here on line 17 and it
11:38 - will run all the code inside its
11:39 - constructor i can see that constructor
11:42 - method on player class needs game as an
11:44 - argument down here we are inside that
11:46 - game class so i pass it this keyword
11:49 - this keyword used inside this class
11:52 - refers to this entire game object
11:55 - our game will also need update and draw
11:57 - methods
11:58 - update method will take this.player
12:00 - property from line 49 which holds an
12:02 - instance of player object and it will
12:05 - call its update method we defined online
12:07 - 26.
12:08 - inside draw method we will render the
12:10 - player on canvas by calling draw method
12:12 - from line 29. i can see that it expects
12:15 - context as an argument so i pass it
12:17 - context like this and that value will be
12:20 - passed along here
12:22 - now i create an instance of this new
12:24 - game class we just wrote and i save it
12:26 - in a variable i call for example game
12:28 - it's equal to new game like this again
12:31 - new keyword will look for class with
12:33 - that name it will find it on line 45 and
12:36 - it will run its constructor method to
12:38 - create one new blank javascript object
12:41 - and assign it values and properties
12:43 - based on the blueprint here
12:45 - on line 46 i can see that game class
12:47 - constructor expects width and height as
12:50 - arguments so i pass it canvas width from
12:52 - line 5 and canvas height from line 6.
12:57 - so the new keyword triggers a class
12:59 - constructor as the constructor gets
13:01 - executed we hit this line which will
13:04 - automatically create an instance of
13:06 - player class from line 17.
13:08 - so this is how by creating the main game
13:10 - object we also automatically create
13:12 - player object and now it sits as a
13:14 - property on the game class on line 49
13:18 - perfect
13:19 - [Music]
13:23 - we will also need animation loop that
13:25 - will run update and draw methods over
13:27 - and over 60 times per second updating
13:30 - positions and redrawing our game i
13:32 - create a custom function i call for
13:34 - example animate inside i take the
13:36 - instance of game class from line 59 and
13:39 - i call its associated update method we
13:41 - declared on line 51. i will also call
13:44 - draw method from line 54 like this i can
13:47 - see it expects context as an argument to
13:49 - specify which canvas element we are
13:51 - drawing on so
13:53 - i pass it ctx from line 4
13:56 - this means that this ctx variable will
13:58 - be passed here and it will get passed
14:00 - along to draw method on player object
14:02 - here
14:03 - now the player knows where we want to
14:05 - draw it
14:06 - after we called update and draw we want
14:08 - to trigger the next animation frame so i
14:10 - call built in request animation frame
14:13 - request animation frame method sits on
14:15 - the window object but we can also call
14:17 - it just like this
14:19 - it tells the browser that we wish to
14:20 - perform an animation and it requests
14:23 - that the browser calls a specified
14:25 - function to update an animation before
14:28 - the next repaint
14:29 - so we need to pass it one argument and
14:31 - it will be the method we want to call
14:33 - before the repaint before browser window
14:35 - gets updated and redrawn on screen
14:38 - i pass it animate the name of its parent
14:40 - function to create an endless animation
14:43 - loop request animation frame has two
14:45 - special features it adjusts the user's
14:48 - screen refresh rate for most of us it
14:50 - will be 60 frames per second it also
14:52 - auto generates a timestamp argument and
14:55 - passes that as an argument to its
14:56 - callback function a little bit later i
14:58 - will show you how to use this feature to
15:00 - create periodic events in our project
15:02 - events that repeat in a certain interval
15:07 - i get an error because i misspelled the
15:09 - word constructor here i'm using vs code
15:11 - editor it highlights syntax in different
15:14 - colors which makes it easier to notice
15:15 - typos like this we have our main game
15:18 - logic and we are drawing this black
15:20 - rectangle representing our player
15:22 - it looks static but it's actually
15:24 - animating we can test that by giving
15:26 - players some value here in speed y
15:28 - property
15:30 - the reason the rectangle gets longer now
15:33 - is because we can see old paint we can
15:35 - see old black rectangles that were drawn
15:38 - in the previous animation loops i can
15:40 - fix that by deleting all canvas drawings
15:42 - between each animation frame between
15:45 - every animation loop i call built in
15:47 - clear rectangle method and i want to
15:49 - clear canvas from coordinates 0 0 to
15:51 - canvas with canvas height like this now
15:54 - you can see that because player speed y
15:56 - property is set to plus 1 the player
15:58 - moves by 1 pixel per frame in positive
16:01 - direction on vertical y axis if speed y
16:05 - is -1 player will move upwards if speed
16:07 - y is 0 the player will not move at all
16:10 - it's all because for every animation
16:12 - frame we are adding speed y property to
16:14 - player's vertical y coordinate here on
16:16 - line 27 we know that everything is
16:18 - working well it's good to test your code
16:20 - as you go step by step to discover
16:22 - potential problems i want the player to
16:24 - be controlled by keyboard when i press
16:26 - up arrow we set speed y to -1 and player
16:30 - will move up when i press down arrow we
16:32 - set speed wire to plus 1 and player will
16:34 - move down
16:37 - [Music]
16:42 - we will handle all player input up here
16:44 - inside input handler class constructor
16:46 - will take a game as an argument same as
16:49 - we did with the player i converted into
16:51 - this.gameclass property as we said
16:54 - before when we create an instance of a
16:56 - class all the code inside class
16:58 - constructor gets executed we can take
17:00 - advantage of that and i can even apply
17:03 - event listeners from here i simply
17:05 - choose apply event listener like this we
17:07 - will listen for key down event callback
17:09 - function on event listener has a special
17:12 - auto generated argument that contains
17:14 - all kinds of additional details about
17:16 - the event that just happened if i want
17:18 - more details about the keydown event i
17:20 - just need to pick a variable name and i
17:22 - pass it as an argument to the callback
17:25 - usually we use letter e or the word
17:27 - event but you can also type abc whatever
17:30 - you put here will become a custom
17:31 - variable name containing a special
17:34 - object with additional information about
17:36 - the keydown event that just happened i
17:38 - will save it in a variable i call e and
17:41 - i will console log it if you choose
17:43 - console.log e you will get the full
17:44 - event object with many properties i've
17:47 - done this before so i know i want a
17:49 - specific property called key so i
17:51 - console e dot key this will contain a
17:54 - string with the name of the key that was
17:56 - pressed let me show you
17:58 - i need to create an instance of input
18:00 - handle class so as we did with the
18:02 - player i want my input class to be
18:04 - instantiated automatically as i create
18:07 - my main game class so here inside the
18:10 - game class constructor i create a
18:12 - property i call for example this dot
18:14 - input i set it the new input handler and
18:17 - i know its constructor expects game as
18:20 - an argument so same as we did with the
18:22 - player i pass it this referring to this
18:25 - entire game class so now as i create
18:27 - game object down here it automatically
18:30 - creates player object on line 54 and
18:32 - input object on line 55. as we call the
18:36 - new keyword on line 55 javascript will
18:39 - jump to line 9 and it will run input
18:42 - handler class constructor which will
18:44 - among other things apply this key down
18:46 - event listener that's console login the
18:48 - current key that is pressed i open
18:50 - browser console i click on canvas
18:52 - element so it starts registering events
18:54 - and now when i press keys on my keyboard
18:57 - you can see we are console logging the
18:58 - key property
19:02 - inside key down event listener i say if
19:05 - e.k is arrow up
19:08 - take keys array on the game object
19:13 - we will create that array in a second
19:15 - and push that key into the array
19:22 - i create that array here on line 59
19:24 - inside game class constructor its job
19:27 - will be to keep track of all keys that
19:29 - are currently active that are currently
19:31 - being pressed down
19:33 - i will console.log this.game.keys from
19:35 - here to check if arrow up key is being
19:37 - correctly added i get a console error
19:40 - that is saying that the variable name
19:42 - i'm calling keys from is undefined by
19:45 - the time this callback function is
19:46 - executed javascript forgot what
19:48 - this.game stands for which object it
19:51 - points towards
19:52 - we want javascript to remember that this
19:54 - code initially sits inside this object
19:57 - so that it can see and remember
19:59 - this.game property even when we call it
20:01 - later as we play our game
20:03 - if you are a beginner don't worry about
20:05 - fully understanding this yet all you
20:06 - need to know here is that if javascript
20:08 - forgets what this keyword stands for we
20:11 - need to bind that code to the
20:13 - surrounding codes context
20:15 - we can use built in javascript bind
20:17 - method or even simpler we can use es6
20:20 - arrow function syntax here
20:23 - a special feature of arrow function is
20:25 - that this keyword inside arrow function
20:27 - always represents the object in which
20:29 - the arrow function is defined arrow
20:31 - function will never forget that it was
20:33 - originally defined inside constructor on
20:36 - input handler class and it will always
20:38 - see this reference for this.game from
20:40 - line 10. therefore it will be able to
20:43 - access this.game.keys and push keys
20:45 - inside now everything is working when i
20:48 - press up arrow key it gets added into
20:50 - this.game.keys
20:52 - and if i press it multiple times it
20:54 - keeps adding more and more so i create
20:55 - another event listener
21:00 - this time for keyup event
21:02 - when we release the key i want to remove
21:04 - it from the array i do that by checking
21:06 - if the array contains that key so built
21:08 - in index of array method
21:11 - the indexof method returns the first
21:13 - index at which a given element can be
21:16 - found in the array or it returns -1 if
21:19 - the element is not present so if
21:22 - this.game.key's index off is more than
21:24 - -1 meaning if key's array contains the
21:27 - key that is currently being released in
21:29 - this key up event take this.game.keys
21:32 - array and remove that element from the
21:34 - array using splice method the splice
21:37 - method changes the contents of an array
21:39 - by removing or replacing existing
21:42 - elements
21:43 - splice method needs at least two
21:45 - arguments the first argument is the
21:47 - index at which we want to start changing
21:49 - the array so it will be the index of
21:51 - that key we want to remove like this
21:54 - and the second argument is delete count
21:57 - an integer indicating the number of
21:59 - elements in the array we want to remove
22:01 - from that starting index
22:04 - so i call splice i want to remove
22:06 - elements starting from this index and i
22:09 - want to remove only one element at that
22:11 - index
22:12 - i put the same counter lock inside key
22:14 - up event you can see that it works well
22:17 - when i press up arrow it gets added when
22:19 - i release it it gets removed added
22:22 - removed nice the problem is when i hold
22:24 - up arrow key down for too long key down
22:27 - event will start firing over and over
22:29 - but key up event doesn't fire so we are
22:31 - not removing those keys we are adding
22:33 - multiple keys we are adding the same key
22:35 - over and over increasing the size of the
22:37 - array this can also be fixed easily i
22:39 - only want to add that key into this.keys
22:42 - array if it's not already present in
22:44 - there so additional condition here
22:47 - if this.game.keys
22:50 - index off the key that was just pressed
22:53 - is -1
22:56 - now when i press and hold the key gets
22:58 - added only once when i release the
23:00 - button the key gets removed perfect on
23:03 - keydown event i check if key that was
23:05 - pressed is arrow up and at the same time
23:08 - i check if arrow up is not yet in the
23:10 - array only then i push arrow up into
23:13 - this dot keys array
23:15 - on key up event i check if the key that
23:17 - we are releasing is present in the array
23:20 - if it is i remove it using splice method
23:23 - we have the main logic now and adding
23:24 - more keys is easy just be careful about
23:27 - brackets here it's easy to miss
23:28 - something and get an error
23:30 - i wrap this part in another set of
23:32 - brackets and i check if key that is
23:34 - pressed is arrow up or arrow down like
23:37 - this
23:43 - now keys array on the main object can
23:45 - contain nothing and can be empty or it
23:48 - can contain up arrow key or arrow down
23:51 - key and it can even contain multiple
23:53 - keys at the same time in our case both
23:55 - arrow up and arrow down so now keys
23:58 - property on the main game object is an
24:00 - array that always keeps track of presses
24:02 - and releases of up and down arrow keys
24:06 - i store this array on the main game
24:08 - object on line 67 so the information of
24:11 - what keys are currently pressed is
24:13 - available all over our code base it's
24:15 - also available inside our player class
24:18 - because player has this dot game
24:19 - property here on line 35 pointing
24:22 - towards the main game object
24:24 - i can simply check if this.game.keys
24:26 - includes a specific key and i can change
24:29 - player behavior from here i check if
24:32 - this.game.keys includes arrow up notice
24:35 - that before i use index of method to
24:37 - check if element can be found in the
24:39 - array i can also alternatively use built
24:41 - in javascript includes method to do the
24:44 - same thing
24:45 - the includes method determines whether
24:47 - an array includes a certain value among
24:49 - its entries returning true or false as
24:52 - appropriate
24:53 - if this line returns true we want player
24:55 - to move up so we set speed y from line
24:58 - 40 to -1 else if keys array includes
25:01 - arrow down we set speed y to plus 1.
25:06 - i save changes and click canvas and now
25:09 - i can move player up and down by
25:10 - pressing up and down arrow keys the only
25:13 - problem is that player will never stop
25:15 - moving we need to add one more small
25:17 - condition so else meaning this.game.keys
25:20 - array doesn't include arrow up or arrow
25:23 - down we set speed y to zero
25:26 - instead of hard coding minus one and
25:28 - plus one here maybe player speed is
25:30 - dynamic and player can speed up during a
25:32 - power up for that purpose it's better to
25:34 - save max speed in a variable like this
25:37 - so we have current player speed on line
25:39 - 40 and maximum player speed on line 41.
25:42 - let's try 2 pixels per frame and i
25:45 - replace hard-coded values with variables
25:47 - on lines 44 and 45.
25:50 - if we press arrow up speed y is minus
25:52 - max speed if we press arrow down speed y
25:55 - is plus max speed like this now we can
25:58 - change player movement speed if we need
26:00 - to by changing max speed value on line
26:02 - 41 and this is one of the techniques i
26:05 - like to use to handle keyboard inputs in
26:07 - my games if you have any questions or
26:09 - any suggestions how to improve this code
26:10 - let me know by leaving a comment
26:16 - [Music]
26:23 - player will be shooting lasers at
26:24 - enemies we will create them by using a
26:27 - class i call projectile constructor will
26:29 - need three arguments the main game
26:31 - object so that this class has access to
26:34 - game properties when it needs them and
26:36 - starting x and y coordinates those need
26:38 - to be dynamic passed as arguments from
26:40 - here because starting coordinates of
26:42 - each projectile will depend on player's
26:44 - current position as usual i convert the
26:47 - arguments past to class constructor into
26:50 - class properties
26:51 - width will be 10 pixels
26:55 - height will be 3 pixels
27:00 - speed will be 3 pixels per frame
27:04 - update method will also increase
27:05 - horizontal x coordinate from line 30 by
27:08 - speed from line 34.
27:11 - i will also need marked for deletion
27:13 - property which will be initially set to
27:14 - false
27:16 - and if horizontal x coordinate of this
27:19 - projectile object is more than width of
27:21 - the game meaning it has moved across the
27:23 - game area this object can be deleted
27:26 - i will actually set it to 80 of the game
27:29 - area so projectiles will be coming from
27:31 - player here to somewhere around here
27:33 - because i don't want enemies to be hit
27:35 - and destroyed off screen let's say that
27:37 - the lasers have limited range so if
27:40 - horizontal coordinate of the projectile
27:42 - is more than 80 of width of the main
27:45 - game area said they're marked for
27:47 - deletion property from line 35 to true
27:50 - this will flag that projectile as ready
27:52 - to be deleted and removed from the game
27:54 - we will remove them in a moment before
27:56 - we do that we will also have a simple
27:58 - draw method that will take context as an
28:00 - argument and i call built in fill
28:02 - rectangle method that will represent the
28:04 - projectile i want to draw that rectangle
28:06 - at coordinates this dot x this dot y and
28:09 - i pass it this dot with this dot height
28:11 - from lines 32 and 33 we will use images
28:14 - and animations for everything soon but
28:16 - first let's set fill style to yellow and
28:18 - draw yellow rectangles for our lasers
28:24 - i will also have to define fill style
28:26 - here on the player a device that yellow
28:28 - color will apply on it as well
28:30 - i can set it to green or black like this
28:35 - so we have our projectile class ready
28:37 - how do we add them into our game
28:39 - one way to do it is by creating a
28:41 - special custom asset on player class
28:44 - player will have two different attack
28:46 - modes so i will call the basic one shoot
28:48 - top in this mode the lasers will be
28:50 - coming out from the mouth of our
28:52 - mechanical seahorse when shoot top
28:54 - method is triggered i take this dot
28:57 - projectiles array i will create in a
28:58 - minute and i will push new projectile
29:01 - inside using the class we just defined
29:03 - on line 27.
29:05 - i created this dot projectiles array on
29:07 - player class this will hold all
29:09 - currently active projectile objects up
29:12 - here i can see that class constructor
29:14 - expects game x and y as arguments so i
29:17 - pass it this.game from line 51 and the
29:20 - current player coordinates so this.x
29:23 - from 954 and dot y from line 55
29:28 - i want player to shoot when we press a
29:30 - key so i go up to input handler class
29:33 - and here i will make it very simple
29:35 - i go inside key down event and i say
29:38 - else if key is space bar so just space
29:41 - like this
29:42 - you can also use enter or any other key
29:44 - if you want when we press space bar use
29:47 - distort game reference from line 10 and
29:50 - navigate to its player property and from
29:53 - there call shoot top method we just
29:55 - defined
29:56 - since i'm holding all projectiles here
29:58 - on line 60 on player class i will handle
30:01 - projectiles here inside update method
30:04 - i take this dot projectiles array and
30:06 - for each element in that array i call
30:08 - update method we defined on line 39
30:16 - inside that method i have this check
30:19 - if the projectile moves across the
30:21 - screen we set its marked for deletion
30:23 - property to true i want to remove those
30:25 - elements from projectiles array i will
30:27 - do it using javascript filter method
30:29 - like this the filter method creates a
30:32 - new array with all elements that pass
30:34 - the test implemented by the provided
30:36 - function so here i'm taking projectiles
30:38 - array i call filter on it and the test
30:42 - is that i want all elements to have
30:43 - marked for deletion properties set to
30:45 - false
30:46 - so exclamation mark here
30:49 - this will filter out and remove all
30:51 - elements with marked for deletion
30:53 - properties set to true and since we just
30:55 - said that filter creates a new array we
30:58 - want to override the original array with
31:00 - the new one that was filtered here
31:03 - with this line of code in place every
31:05 - time we set marked for deletion property
31:07 - to true on any projectile object it will
31:09 - get removed from projectiles array i
31:12 - will check if it works by console log in
31:14 - this dot projectiles from inside shoot
31:16 - top method i will also call for each on
31:19 - all projectiles from inside draw method
31:21 - and i trigger draw method from line 43
31:23 - on each one i remember that i need to
31:25 - pass it context so i pass it along the
31:28 - value from here like this i save changes
31:31 - and run my code and i can see we have an
31:33 - error on line 45
31:35 - i go up to line 45 and i forgot to call
31:38 - fill rectangle from context so
31:40 - javascript doesn't know what to do with
31:42 - it i fix it like this
31:45 - now i click on canvas and i can move up
31:47 - and down using keyboard arrow keys and i
31:49 - can shoot using spacebar in browser
31:52 - console i can see that projectile
31:53 - objects are being correctly added and
31:55 - removed from projectiles array perfect
32:00 - let's remove these two console logs to
32:02 - clean up our code
32:05 - now the console is cleaner and it's
32:06 - easier to see how projectile array adds
32:09 - and removes objects nice
32:12 - right now we can shoot without limits i
32:14 - want the player to have limited ammo
32:16 - that slowly recharges over time it will
32:19 - also get completely refilled when we
32:21 - collect a special power up fish
32:25 - down here i say if this.game.amo which
32:27 - we will create in a minute
32:30 - is more than zero
32:32 - only then create new projectile object
32:38 - i go down here to line 104 and i create
32:41 - this new ammo property initially we will
32:44 - start with 20 ammo for example
32:50 - every time we create a new projectile we
32:52 - decrease that value by 1.
32:55 - now i can do it 20 times and then it
32:57 - stops even if i keep pressing spacebar
32:59 - we run out of ammo here on line 80 i can
33:02 - change which coordinates the projectiles
33:05 - start from in relation to the current
33:07 - player position
33:09 - we will match it even better when we
33:10 - apply player sprite sheet a bit later to
33:12 - make sure it comes out from the mouth of
33:15 - our steampunk seahorse we will get back
33:17 - to this i can offset it here or i can
33:19 - also do it inside projectile class
33:22 - itself
33:23 - [Music]
33:29 - when we use all 20 projectiles we
33:31 - completely run out of ammo i want it to
33:33 - slowly recharge over time to do that i
33:36 - want to run a periodic event in our code
33:38 - base and i want to be able to measure
33:40 - time in milliseconds and say for example
33:43 - every 500 milliseconds every half second
33:46 - automatically recharge one ammo to do
33:49 - that is easy if you know this technique
33:50 - with timestamps and delta time let me
33:53 - quickly explain how it works here on
33:55 - line 116 i create a variable i call for
33:58 - example last time its job will be to
34:00 - store a value of timestamp from the
34:03 - previous animation loop so that we can
34:05 - compare it against the value of
34:06 - timestamp from this animation loop
34:09 - this difference will give us delta time
34:11 - the difference in milliseconds between
34:13 - the timestamp from this loop and the
34:15 - timestamp from the previous loop like
34:17 - this
34:18 - where does this timestamp value come
34:20 - from request animationframe method has a
34:22 - special feature it automatically passes
34:25 - a timestamp as an argument to the
34:27 - function it calls in our case animate i
34:30 - can use it simply by giving it a
34:31 - variable name here you can call it
34:33 - whatever you want as long as you keep
34:35 - referring to that value using the same
34:37 - variable name i will call it timestamp
34:40 - spelled like this and i will use it to
34:42 - calculate delta time here on line 119
34:46 - after we used last time to calculate
34:48 - delta time for this animation loop we
34:50 - reassign last time to the timestamp from
34:53 - the current loop so that it can be used
34:55 - to calculate delta time in the next loop
34:58 - so request animation frame auto
35:00 - generates a timestamp value
35:02 - which is a number in milliseconds since
35:04 - this loop started we access it here in
35:07 - animate assign it a variable name for
35:09 - example timestamp like this we calculate
35:12 - the delta time which is the difference
35:14 - in milliseconds between the timestamp
35:16 - from this animation loop and the
35:18 - timestamp from the previous animation
35:20 - loop and then we set last time to
35:22 - timestamp from this loop so that it can
35:25 - be used to calculate delta time in the
35:27 - next loop don't worry if this is a bit
35:29 - complicated to understand at first it's
35:31 - a very common technique and it will
35:32 - become more intuitive as you use it in
35:34 - multiple projects
35:38 - i can control delta time to check if
35:40 - it's working my delta time is around
35:42 - 16.6 milliseconds thousand milliseconds
35:46 - one second divided by 16.6 is around 60
35:49 - so i can see that my game is animating
35:51 - at 60 frames per second let me know if
35:54 - you get the same value or something else
35:56 - if you had an old computer delta time
35:58 - value might be higher because it takes
36:00 - your computer more milliseconds to
36:02 - render animation frame if you have high
36:04 - refresh gaming screen delta time value
36:06 - could be lower for you i wonder if we
36:08 - have any coders here who use that type
36:11 - of screen remember to remove your
36:13 - console locks when you don't need them
36:14 - especially this one that runs 60 times
36:16 - per second it could affect the
36:18 - performance of our game if i just leave
36:20 - it here so we calculated delta time we
36:23 - know how many milliseconds it takes for
36:25 - a computer to render one animation frame
36:28 - to run one animation loop i will pass it
36:30 - to update method here and we can use
36:32 - that value to run periodic events in our
36:34 - game or to measure game time the
36:37 - advantage of this technique is that it
36:38 - doesn't matter if you have strong super
36:40 - computer or a very old slow one delta
36:43 - time measures actual milliseconds in
36:45 - real time so periodic events will happen
36:47 - roughly at the same time on slow and
36:49 - fast machines regardless of their
36:51 - ability to animate our game slow or fast
36:54 - to trigger periodic events in our game i
36:56 - need two helper variables one will be
36:58 - timer that will go between zero and some
37:01 - kind of predefined limit each time it
37:03 - reaches that limit it will trigger some
37:05 - kind of event and it will reset back to
37:07 - 0 to count again for the next loop
37:11 - the second helper variable will be that
37:13 - limit that interval value that timer
37:15 - needs to reach so i want to replenish
37:17 - some ammo every half second 500
37:19 - milliseconds i will also introduce some
37:22 - hard limit i want the ammo to
37:23 - automatically replenish only up to this
37:26 - value not endlessly so starting ammo
37:29 - will be 20 maximum ammo will be 50 for
37:31 - example
37:33 - inside update method on game class i
37:35 - will use ammo timer and ammo interval
37:37 - helper variables and also delta time to
37:39 - trigger this periodic event that
37:41 - replenishes ammo every 500 milliseconds
37:44 - i say if ammo timer from line 107 is
37:47 - more than ammo interval so 500
37:49 - milliseconds
37:51 - inside i will also check if ammo is less
37:53 - than max ammo like this
37:59 - only then i will increase ammo by 1.
38:02 - then i reset ammo timer back to 0 so
38:05 - that it can count again
38:08 - else keep increasing ammo timer by delta
38:10 - time
38:13 - i am calculating delta time on line 128
38:16 - and i'm passing it to update method on
38:19 - game class online 131 i make sure update
38:22 - method expects that value here on line
38:24 - 110 and that delta time value will get
38:27 - passed along here
38:35 - our ammo is already recharging but it's
38:37 - not easy to check and see i can console
38:39 - these values but it would be nice to
38:41 - have some visual representation of our
38:43 - available projectiles as part of our
38:45 - game screen
38:47 - i have user interface class here online
38:49 - 95. i will use it to draw messages and
38:52 - game statuses that player needs to be
38:53 - aware of
38:55 - this class will be very simple a
38:57 - constructor will take a game as an
38:59 - argument so we convert it to a class
39:00 - property as usual we will define font
39:03 - size
39:05 - and font family we will need it later to
39:07 - draw some score and game timers
39:12 - i will also define color and i set it to
39:14 - white for example
39:16 - it doesn't need update method it just
39:18 - needs a draw method
39:20 - it will expect context as an argument
39:22 - and here i will draw a small bar for
39:24 - each available projectile i create for
39:27 - loop it will run as many times depending
39:29 - on the amount of ammo we currently have
39:35 - i will set fill style to this.color
39:40 - this should actually be outside the for
39:42 - loop like this
39:44 - for each available projectile i will
39:46 - draw a small rectangle
39:48 - so fill a rectangle method add
39:49 - coordinates 2050 width 3 pixels and
39:53 - height 20 pixels
39:55 - let's draw what we have so far and then
39:56 - we can finish it once we can see what we
39:58 - are doing
39:59 - same as we did with player and input
40:01 - handler classes i create an instance of
40:03 - user interface class here on line 116
40:07 - inside game class constructor
40:09 - it expects game as an argument so i pass
40:12 - it this keyword
40:14 - now i use this dot ui property and i
40:16 - call its associated draw method we
40:18 - defined on line 102 and i pass it
40:21 - context
40:24 - nice right now we are drawing all 20
40:26 - available projectiles on top of each
40:28 - other here to make them align next to
40:30 - each other i just multiply them by the
40:32 - index from the for loop like this
40:35 - 20 pixels spacing is too much how about
40:37 - a spacing of 5 pixels
40:43 - plus 20 pixels left margin like this
40:47 - that's better now we can see how our
40:49 - ammo is slowly recharging
40:53 - i can change the color here on line 100
40:58 - i can test it and it's working really
41:00 - well
41:04 - it will keep recharging until it reaches
41:06 - max ammo value of 50 and then it should
41:09 - stop
41:12 - yes
41:14 - we will apply better visuals to our game
41:15 - in a moment i just want to have a
41:17 - complete functional game skeleton first
41:21 - [Music]
41:25 - we are missing one last important
41:27 - element in our main game loop enemies
41:29 - and some enemies will also work as power
41:31 - ups in this game we will have multiple
41:34 - enemy types in our game with different
41:36 - visuals and behaviors let's take it step
41:38 - by step to make sure we understand how
41:40 - everything works and how the player
41:42 - projectiles enemies and power-ups
41:44 - interact with each other enemy class
41:46 - will just contain the main blueprint the
41:48 - properties and methods shared between
41:50 - all enemy types we will then extend this
41:53 - class into multiple small subclasses
41:55 - each enemy type will have a separate
41:57 - child class that inherits from this main
42:00 - enemy parent class all enemies will need
42:02 - access to the main game object so i do
42:04 - this as usual all enemies will also have
42:07 - the same starting horizontal
42:08 - x-coordinate
42:10 - they will go from right to left starting
42:12 - just behind the right edge of game area
42:14 - so this.game.width horizontal speed of
42:17 - each enemy will be a random number
42:19 - between -0.5
42:21 - and -2 pixels because i want them to
42:23 - move in minus direction to the left on
42:25 - horizontal x-axis
42:27 - marked for deletion will be set to false
42:29 - initially
42:34 - update method will adjust horizontal x
42:36 - coordinate by the amount of speed x
42:37 - value for each animation frame moving
42:40 - enemies from right to left
42:42 - i check if enemy moved completely off
42:44 - screen all the way behind the left edge
42:46 - of game area so if x coordinate of the
42:49 - enemy plus its width is less than 0 we
42:52 - will set its marked for deletion
42:54 - property to true
42:56 - draw method will take context as an
42:58 - argument at first i will just draw red
43:01 - rectangles representing enemies so fill
43:03 - style right
43:05 - and fill rectangle at enemies x and y
43:07 - coordinates
43:09 - and its width and height like this
43:13 - we will have multiple enemy types let's
43:15 - start with the basic simple anime
43:17 - angular fish i call that class for
43:19 - example angular 1 and it extends enemy
43:22 - class from line 86 in this scenario we
43:25 - have a parent anime class also called a
43:27 - super class and we have child angular
43:30 - class also called a sub class
43:32 - this is a good example of the second
43:34 - principle of object oriented programming
43:36 - called inheritance angler is a child of
43:39 - parent enemy class and it has access to
43:42 - its methods such as this update and draw
43:44 - as well as these properties
43:46 - if i call a property or a method on
43:48 - angle class and javascript can't find it
43:50 - on angular it will automatically travel
43:52 - to the parent enemy class and it will
43:54 - look for it there inheritance is used to
43:57 - reduce code repetition instead of
43:59 - re-declaring the same methods and
44:00 - properties on each class i can just
44:02 - declare them once on parent class and
44:05 - all child classes will inherit them
44:07 - automatically
44:08 - we can also do other things here using a
44:10 - special super keyword i will show you as
44:12 - we write the code angle class will have
44:15 - its own constructor because some
44:16 - properties will be specific only to
44:18 - angular fish enemies in our game if i
44:21 - don't declare constructor on angular
44:22 - class at all it will automatically use
44:24 - constructor from anime class from line
44:26 - 87.
44:28 - in this case i want the code from parent
44:30 - class constructor online 87 to run and i
44:33 - want to add some additional properties
44:35 - here if i just declare constructor on
44:37 - angular it will completely override
44:40 - parent class constructor and this code
44:41 - would be ignored
44:43 - so i have to use a special syntax to
44:45 - kind of merge them i want first this
44:48 - code to run and i want to add a little
44:50 - bit of it here
44:52 - i do it by calling super which refers to
44:55 - super class parent class constructor
44:58 - this line of code will make sure that
45:00 - the constructor on the parent gets
45:01 - executed now i can add some more
45:04 - properties that will be specific only
45:05 - for angular remember that if you want to
45:08 - combine constructors like this you have
45:10 - to call super first before you use this
45:12 - keyword doing it the other way around
45:14 - will give you an error
45:16 - i have specific sprite sheets ready for
45:18 - our project so i know that width of a
45:20 - single frame in our angular sprite sheet
45:22 - is 228 pixels and height is 169 pixels i
45:27 - want vertical y position to start from
45:29 - here and go 90 from the top because we
45:32 - will have some ground graphics in our
45:34 - game environment layer these are flying
45:36 - fish machines they need to be above
45:38 - ground rectangles and images on canvas
45:41 - are drawn from the top left corner so i
45:43 - want the starting vertical position on
45:45 - each enemy to be between 0 here and 90
45:49 - of game height here but i need to offset
45:51 - it by the actual height of the enemy
45:53 - otherwise they will be drawn too low
45:55 - down here
45:56 - that's why i define x coordinate on the
45:58 - parent enemy class on line 89 but i had
46:01 - to wait declaring vertical y coordinate
46:03 - until i had height of that specific
46:05 - enemy type it will all work together
46:07 - well now you'll see
46:09 - inside update method on the main game
46:11 - class i will cycle through all enemies
46:13 - and for each enemy object inside enemies
46:15 - array i will call their update method
46:19 - i also need to define this.enemies array
46:22 - here it will hold all currently active
46:24 - anime objects
46:27 - i will again use filter method to filter
46:29 - out all anime objects that have marked
46:32 - for deletion properties set to true the
46:34 - same thing we did with projectiles
46:39 - and i will cycle through all enemy
46:40 - objects here call their draw method and
46:43 - pass it context
46:45 - so we have anime class we are updating
46:48 - drawing and removing old ones we need to
46:51 - figure out how to add new enemies into
46:53 - our game
46:54 - i will have a special method on the game
46:56 - class called add anime every time this
46:59 - method is called it will push one new
47:01 - anime object inside this dot enemies
47:03 - array notice that i'm not calling the
47:05 - parent anime class i'm calling the child
47:08 - angular 1 class here
47:11 - on line 103 i can see it expects game as
47:14 - an argument so
47:16 - i pass it this keyword because we are
47:18 - inside that game class
47:23 - now i want to call add enemy in a
47:25 - specific interval we will use the same
47:27 - technique we used to periodically
47:29 - recharge ammo and it will be much easier
47:31 - because we are already calculating delta
47:33 - time
47:34 - i will need two helper variables enemy
47:36 - timer that will count between zero and
47:38 - enemy interval i want to add new enemy
47:41 - into our game every one second every
47:43 - thousand milliseconds
47:47 - same as we did with recharging
47:48 - projectiles i say if this.enemy timer
47:51 - which starts from 0 is more than anime
47:53 - interval
47:56 - let's go up here and also declare
47:57 - gameover property and initially set it
48:00 - to false
48:03 - back here on 962 i say
48:06 - and at the same time this dot game over
48:09 - is false because i don't want to be
48:10 - adding new enemies when the game ended
48:13 - and we call at enemy method from here we
48:16 - will also reset enemy timer back to zero
48:18 - so that it can count again else meaning
48:20 - enemy timer is less than enemy interval
48:23 - we will keep increasing enemy timer by
48:24 - delta time which is already being passed
48:27 - to update method here
48:31 - nice we are adding big red enemies to
48:33 - our game i go up to 105 and i make the
48:37 - width and also height smaller just for
48:39 - now before we start animating sprites i
48:42 - will make the entire game wider when we
48:44 - get to later stages for now we are just
48:46 - building the main logic loop we have
48:49 - player that can move and shoot
48:50 - projectiles we have recharging ammo and
48:53 - there are swarms of enemies coming at us
48:55 - nice work if you are following along
48:58 - as usual i want to check if enemies are
49:00 - being correctly added and removed from
49:02 - the array so i consoled this.enemies
49:05 - array here i want to make sure that
49:07 - filter method on line 161 does its job
49:10 - and we don't have endlessly growing
49:12 - array
49:13 - it works well enemies that moved off
49:15 - screen to the left are being removed
49:17 - perfect
49:24 - it's time to add some interactions i
49:27 - need to check if enemies collide with
49:29 - player and also if projectiles collide
49:31 - with enemies to save ourselves code
49:33 - repetition i will create a reusable
49:35 - collision detection method on the main
49:37 - game object i call for example check
49:39 - collisions this method will take two
49:42 - arguments two objects i will call them
49:45 - rectangle one and rectangle two and it
49:47 - will return true if they collide and
49:50 - false if they don't
49:52 - it will be a reusable function so we can
49:54 - use it later and pass it player and
49:56 - enemy as rectangle 1 and 2 and we can
49:59 - also pass it anime and projectile to
50:01 - check if they collide let me show you
50:03 - exactly how to do that right now when
50:06 - checking if two rectangles collide we
50:08 - compare their x y width and height in a
50:10 - specific way so all objects we are
50:13 - comparing need to have x y width and
50:15 - height properties for this to work
50:17 - i will return a statement in brackets
50:20 - like this so if the code in brackets
50:21 - evaluates true or false it will
50:23 - immediately be returned by this function
50:25 - quick and easy to check if two
50:28 - rectangles collide we need to run four
50:30 - checks
50:31 - we need to check if a horizontal x
50:33 - position of rectangle one is less than
50:35 - horizontal position of rectangle two
50:37 - plus its width if this side is to the
50:41 - left of this side
50:43 - i will comment out line 196 just for a
50:46 - moment so the movement doesn't distract
50:48 - us
50:50 - at the same time we need to check if
50:52 - horizontal position of rectangle 1 plus
50:54 - the width of rectangle 1 is more than
50:56 - horizontal position of rectangle 2 if
50:59 - this side is to the right of this side
51:02 - if both of these statements are true we
51:04 - know they're in the same space on
51:05 - horizontal x-axis but it still doesn't
51:08 - mean they collide they can be far away
51:10 - vertically because of that we need two
51:12 - more checks we need to check if vertical
51:14 - position of rectangle one is less than
51:16 - vertical position of rectangle two plus
51:19 - the height of rectangle two if this side
51:22 - is above this side and finally we check
51:24 - if the height of rectangle 1 plus its y
51:27 - position is more than vertical y
51:29 - position of rectangle 2 if this side is
51:32 - below this side
51:34 - if all 4 of these checks are true this
51:36 - entire statement will evaluate to true
51:39 - and check collision function will return
51:41 - true if at least one of these is false
51:44 - the entire statement will be false and
51:46 - we know these two rectangles don't
51:48 - collide
51:50 - we stay inside the main game class and
51:52 - go to its update method in this for each
51:55 - call we cycle through every object
51:57 - inside enemiesarray from 941
52:00 - and we call their update method
52:02 - as we go through that array one enemy
52:05 - object at the time we will check
52:06 - collision between player object from 937
52:13 - and that particular enemy rectangle
52:16 - i do this by calling our custom check
52:18 - collision method we just wrote and i
52:21 - pass it player as rectangle one and
52:23 - enemy as rectangle two if this message
52:26 - returns true we know we are colliding
52:28 - and i will set marked for deletion on
52:31 - that animator true i go down to line 200
52:34 - and i uncomment request animation frame
52:36 - again so that we can test it
52:42 - i can see that whenever player collides
52:44 - with an enemy that enemy gets deleted
52:47 - perfect we have some interactions in the
52:50 - same for each method i will also check
52:52 - each anime against all currently active
52:54 - projectiles they are stored inside
52:57 - this.player.projectiles and i call for
53:00 - each on that array as well like this
53:03 - for each enemy inside enemies array we
53:06 - check against every single projectile in
53:08 - projectiles array
53:10 - i say if this.check collision between
53:13 - projectile from this iteration of this
53:16 - for each
53:17 - and enemy from this iteration from this
53:20 - for each
53:21 - if check collision is true decrease
53:23 - enemy life by one
53:27 - at the same time set marked for deletion
53:30 - on that projectile that collided to true
53:32 - so it gets deleted
53:34 - then i check if enemy lives are less or
53:37 - equal to zero
53:40 - and if they are set marked for deletion
53:42 - on that enemy to true as well
53:45 - and lastly i will increase score by plus
53:48 - one
53:49 - actually i want each enemy to give
53:51 - different amount of score points when
53:53 - defeated so we will increase game score
53:55 - by score property on that enemy
53:58 - now i used three properties that don't
54:00 - exist yet i go up to parent enemy class
54:03 - and i declare them here i set lives to 5
54:07 - and score that this enemy rewards will
54:09 - be equal to the number of its lives like
54:11 - this
54:12 - i will also draw that number on top of
54:14 - each anime for debugging purposes by
54:16 - calling fill text here i pass it distort
54:19 - lives from line 92 and x and y
54:22 - coordinates of that enemy it's very
54:24 - small so i will set fill style to black
54:28 - and font property will be set to 20
54:30 - pixels helvetica for now
54:37 - [Music]
54:44 - i need to define score on the main game
54:46 - class here on line 154
54:50 - and i will also define winning score
54:53 - let's set it to 10 points for now so
54:55 - it's easy to test
54:58 - every time we increase score here we
55:00 - check if the current score is more than
55:03 - winning score and if it is game over
55:05 - from line 153 is true
55:10 - i go up to line 130 inside draw method
55:13 - on ui class in this area i will write
55:16 - code to display the current score to the
55:18 - user i call build in fill text method
55:21 - again and i pass it the text i want to
55:23 - draw so this.game.score
55:25 - and i want to draw it at coordinates
55:27 - 2040. i set font property to this.font
55:31 - size from line 126 plus pixels space
55:35 - plus this.font family from line 127.
55:40 - i put a string that says score colon
55:42 - space here plus we will concatenate
55:44 - this.game.score
55:46 - let's see if everything works
55:48 - all seems to be fine except for the text
55:50 - colors jumping around i will move this
55:52 - fill style declaration up here and i set
55:55 - this dot color to white
56:00 - i can also do other adjustments to the
56:02 - text for example shadows if i want the
56:04 - shadows to apply only to the text and
56:06 - not all the shapes on canvas i will put
56:08 - it between built in save and restore
56:10 - canvas methods
56:12 - save method of canvas 2d api saves the
56:14 - entire state of canvas at that point in
56:17 - time that includes settings like stroke
56:19 - style fill style line width global alpha
56:22 - all shadow settings we will use in a
56:24 - minute as well as other things like
56:26 - clipping region or the current
56:28 - transformation matrix so whatever we do
56:30 - with scale translate and rotate canvas
56:32 - methods then we can change the state of
56:35 - canvas however we want and we call
56:37 - restore canvas restore method restores
56:40 - the most recently saved canvas state if
56:42 - there is no saved state this method does
56:45 - nothing so save and restore only work
56:47 - when used together i will start applying
56:50 - canvas shadows if i did that outside
56:52 - save and restore shadows would get
56:54 - applied to everything including player
56:56 - and enemies but in our case these
56:58 - shadows will only affect shapes and text
57:00 - we draw in this area between this save
57:03 - and this restore shadow offset x defines
57:06 - the distance that shadow will be offset
57:08 - horizontally it can be positive or
57:10 - negative depending on if you want the
57:12 - shadow to be to the left or to the right
57:14 - from the source element shadow offset y
57:16 - defines vertical distance of the shadow
57:19 - i set shadow color to black i could also
57:21 - set shadow blur but i don't need it at
57:23 - this time so by wrapping code in save
57:26 - and restore i make sure that canvas
57:27 - shadows and this fill style property
57:30 - affect only this drawing code and not
57:32 - other shapes and graphics we are drawing
57:34 - on the same canvas element this is a
57:36 - pretty solid code base you can use this
57:38 - as a base boilerplate for many different
57:40 - games maybe some of you want to make a
57:42 - copy of this project at this state and
57:44 - save it in a different folder so you can
57:46 - experiment with it later and use it as a
57:48 - starting point of a different game
57:50 - project
57:51 - [Music]
57:57 - win and lose condition in our game will
57:59 - depend on how many score points can the
58:01 - player get in a specific time window we
58:03 - are going to handle those game over
58:05 - messages here before we call restore
58:08 - so if game over property on the main
58:10 - game object is true we set text align to
58:13 - center
58:14 - we are going to display message 1 in
58:16 - larger letters and under that there will
58:18 - be message 2 and smaller font what these
58:21 - two messages say will depend on how many
58:23 - score points we managed to get in a
58:25 - specified game time
58:28 - i check if game score is more than
58:30 - winning score
58:33 - message 1 will say
58:35 - you win
58:39 - and message two will say well done
58:44 - so that's our winning message else we
58:46 - display the losing message so message
58:48 - one is you lost
58:52 - message two is try again next time
58:55 - [Music]
58:57 - now we actually need to draw these
58:58 - messages on canvas so font for the first
59:01 - message will be 50 pixels space plus
59:04 - font family
59:05 - then i call fill text and we draw
59:07 - message 1 in the center of the screen
59:10 - so x coordinate will be game with times
59:12 - 0.5 vertical y coordinate will be game
59:16 - height times 0.5
59:20 - i copy these two lines of code and i
59:22 - change some things to draw message to in
59:24 - smaller letters 25 pixels here and
59:27 - message 2 here
59:31 - i try to play the game and win
59:35 - nice we get a winning message i need to
59:37 - create some space between the lines so
59:39 - first message will be minus 40 pixels
59:41 - vertically and the second message plus
59:44 - 40 pixels vertically
59:46 - let's see
59:50 - yeah this is fine for now
59:52 - [Music]
59:58 - we need a time limit for our game on the
60:00 - main game object i create two helper
60:02 - variables i call them for example game
60:05 - time which will start at 0 milliseconds
60:07 - and time limit for testing purposes time
60:10 - limit will be 5000 milliseconds 5
60:12 - seconds after 5 seconds the game will
60:15 - end and depending on how many score
60:17 - points we managed to get we will display
60:19 - winning or losing message
60:21 - in update method i say if game over is
60:23 - false take game time from line 181 and
60:27 - increase it by delta time delta time is
60:29 - the difference in milliseconds between
60:31 - timestamp from this animation loop and
60:34 - the timestamp from the previous loop so
60:36 - it's the amount of milliseconds between
60:38 - frames by adding delta time to game time
60:41 - every time we draw a new frame we are
60:43 - keeping track of how many milliseconds
60:45 - passed since the game started game time
60:47 - variable is simply just accumulating
60:49 - milliseconds since the game started
60:52 - if game time is more than time limit
60:54 - from line 182
60:56 - so when the game has been running for
60:58 - 5000 milliseconds we set game over to
61:00 - true the final game will run longer i
61:03 - just use 5 seconds time limit here so
61:05 - it's easy to test
61:06 - up inside ui class we want to draw game
61:09 - timer on screen let's do it in this area
61:11 - on line 143
61:14 - i call fill text and the text will say
61:16 - timer colon plus this dot game.time
61:21 - add coordinates 20 100.
61:24 - actually the variable we just created
61:26 - was called game time like this and i
61:28 - need to add space here
61:33 - nice
61:34 - so we can see game timer i want to
61:36 - format that value so it looks a bit
61:38 - cleaner i create a temporary helper
61:40 - variable called formatted time
61:43 - i want to move the decimal point to show
61:45 - seconds so
61:47 - this.game.gametime times 0.001
61:53 - that works i also want to display only
61:56 - one digit after the decimal point so i
61:58 - use built in two fixed method and i pass
62:01 - it one two fixed method formats a number
62:04 - using fixed point notation we can use it
62:07 - to define the number of digits we want
62:08 - to appear after the decimal point
62:12 - perfect we have game time functionality
62:14 - i'm getting a buck when i get a losing
62:16 - message and then i defeat a couple of
62:18 - remaining enemies and that message
62:20 - switches to the winning message i want
62:22 - to make sure that after game over
62:24 - message appears we are no longer able to
62:26 - gain more score points down here inside
62:28 - update method on game class i only want
62:30 - to increase score if game over is false
62:38 - i get an error it's supposed to be
62:40 - this.gameover like this
62:42 - this will fix the bug
62:45 - we have the base game we have player
62:47 - enemies and projectiles we have
62:49 - recharging ammo score timer and win and
62:53 - lose condition you can save this code in
62:55 - a separate folder and use it as a base
62:57 - skeleton for many different games if you
62:59 - want from this point i will start adding
63:01 - graphics and features that will be
63:02 - specific to our steampunk alien game
63:05 - this will be the fun part let's go
63:08 - [Music]
63:13 - we will be using large detailed images
63:15 - and graphics today i will put all of
63:16 - them here inside index html and because
63:19 - all the code in script.js is inside
63:21 - event listener for load event javascript
63:24 - will only run after all our images have
63:26 - been fully loaded this will prevent
63:27 - errors
63:29 - i will separate art assets in this
63:31 - project into three different categories
63:33 - characters which will include player and
63:35 - enemies props which will include things
63:37 - like mechanical parts that fall from
63:39 - enemies when we damage them and game
63:42 - environment
63:43 - let's start by creating the game world
63:45 - first img element with an id of layer 1
63:48 - and source will point towards that png
63:51 - file you can download all project images
63:53 - in the description i will put all my
63:54 - images into a project folder i call
63:57 - assets our game world will be made out
63:59 - of four separate layers for parallax
64:01 - scrolling effect layer one two three and
64:04 - four like this
64:06 - i don't really want to draw these images
64:08 - on the web page like this i only want to
64:11 - draw them on canvas with the javascript
64:13 - so inside style css i set all of them to
64:16 - display none
64:21 - in script js on line 116 we have a
64:24 - custom class i called layer its job will
64:27 - be to set up each individual layer
64:29 - object constructor will expect three
64:31 - arguments coming from the outside game
64:34 - image and speed modifier
64:38 - i convert those arguments into class
64:40 - properties like this
64:47 - the width of the images we are using is
64:50 - 1768 pixels and the height is 500 pixels
64:54 - horizontal x coordinate will start at
64:56 - zero
64:58 - and y will also be zero
65:02 - we will need update method to move the
65:04 - background layers from right to left as
65:06 - the game scrolls if horizontal x
65:09 - coordinate is less or equal to minus
65:11 - width from line 121 meaning the
65:14 - background image has moved across the
65:16 - screen and is now fully hidden behind
65:18 - the left edge of canvas we set x back to
65:21 - zero so that it can scroll again
65:23 - else decrease x by game speed times
65:26 - speed modifier each layer object will
65:29 - have different speed modifier to create
65:31 - parallax but all will depend on the main
65:33 - game speed variable so that all four
65:35 - layers can be controlled from one place
65:37 - gamespeed variable doesn't exist yet so
65:39 - i created on the main game class here
65:43 - initially i set it to 1.
65:45 - layer class will also need a draw method
65:47 - it will take context as an argument i
65:50 - call built in draw image method this
65:52 - method needs at least three arguments
65:54 - image we want to draw so this dot image
65:56 - from line 119 and where on canvas we
65:59 - want to draw it so i want to draw it at
66:02 - this dot x this dot y from lines 123 and
66:05 - 124 so we have our layer class which
66:08 - will handle individual background layers
66:11 - we will also need background class that
66:13 - will put all four layer objects together
66:15 - to create the game world constructor
66:17 - will take the main game object as an
66:19 - argument i convert it into a class
66:21 - property like this
66:24 - here we will grab all four images for
66:26 - each layer with javascript so
66:28 - this.image1 will be
66:31 - by document.getelementbyid and i pass it
66:33 - layer one the id i gave it in index html
66:37 - this.layer1 property will be an object
66:39 - that holds an instance of layer class
66:41 - from line 116 so new layer like this
66:45 - on line 117 i can see that layer class
66:48 - constructor expects game image and speed
66:50 - modifier arguments so i pass it this dot
66:53 - game from line 137
66:55 - this look image 1 from 938 and speed
66:58 - modifier will be one for now
67:02 - update method will move all the layer
67:04 - objects
67:08 - and draw method will draw all of them
67:10 - we will hold all layer objects inside
67:12 - this dot layer's property it will be an
67:15 - array let's start with just layer one
67:21 - inside update method i take these dot
67:23 - layers and i call for each
67:26 - method for each layer object call their
67:29 - associated update method we declared on
67:31 - line 126
67:33 - draw method will expect context as an
67:35 - argument to specify which canvas we want
67:38 - to draw on
67:39 - inside we will do the same thing call
67:42 - for each on layers array and for each
67:44 - layer object trigger its draw method and
67:46 - pass it that context value because we
67:48 - know that the draw method on line 130
67:51 - expects that argument
67:53 - so background will handle all layers to
67:56 - create the game world layer class will
67:58 - handle logic for each individual
68:00 - background layer object separately
68:04 - now to animate the background i just
68:05 - need to create an instance of background
68:07 - class inside game class constructor same
68:10 - as we did before with player and input
68:12 - handler classes background class expects
68:14 - game as an argument so i pass it this
68:16 - keyword because i am inside that game
68:19 - class right now
68:22 - inside blade method on game class i take
68:24 - this new background property and i call
68:26 - its update method
68:29 - inside the draw method on game class i
68:31 - call draw method on the background
68:32 - object and i pass it context along here
68:36 - notice that i am drawing background
68:38 - first then the player this will make
68:40 - sure that the background is behind the
68:42 - player and doesn't cover it
68:44 - i'm getting an error
68:46 - i go back to my background class and i
68:48 - want to put this layer 1 object into the
68:50 - array so i have to use this keyword
68:56 - nice we are animating layer 1 of our
68:58 - background
69:01 - i can change scrolling speed by changing
69:03 - the value i pass as a speed modifier if
69:05 - i pass it 5 the game speed is 1 because
69:08 - i'm multiplying game speed times speed
69:10 - modifier 1 times 5 is 5 so background
69:14 - will scroll at the speed of 5 pixels per
69:16 - frame
69:17 - i will bring all other layers into the
69:19 - project
69:20 - i bring their images first then for each
69:22 - one i create an instance of layer class
69:29 - and i put all of them inside this dot
69:31 - layers array
69:41 - okay now we see all four layers
69:43 - i give each layer a different speed
69:45 - modifier
69:46 - these values are passed as speed
69:48 - modifier and they will be multiplied by
69:50 - the current game speed you can control
69:52 - scrolling speed of each layer
69:54 - individually like this
69:56 - for now i will set speed modifier to 1
69:58 - on all 4 layers
70:01 - you can see that because of line 128 as
70:03 - soon as the layer images slide
70:05 - completely off screen they reset back to
70:07 - x position of 0 so that they can slide
70:10 - again we are getting this gap to get a
70:13 - seamless scrolling background effect we
70:15 - can use a simple trick we can place a
70:17 - second identical image next to the first
70:19 - one so at the point where the first
70:21 - image doesn't fill the entire game area
70:23 - the second image comes in to fill the
70:25 - gap the second image will never be fully
70:28 - visible it will be filling in just for
70:30 - that short period of time before the
70:31 - first image can reset to its starting
70:33 - position again reset to the original
70:35 - position happens in one frame so it's
70:37 - not visible by naked eye it will create
70:40 - an illusion that we have one endless
70:42 - seamless background how do i apply that
70:45 - in code i simply draw a second identical
70:48 - image but i need to make sure it is next
70:50 - to the first one the second image will
70:52 - start where the first image ends so its
70:55 - horizontal x position will be this dot x
70:58 - plus this dot width like this
71:01 - and that's it we have endless parallax
71:03 - background implemented in our game
71:06 - i can change its scrolling speed by
71:07 - adjusting speed property on the main
71:09 - game object or i can change speed
71:11 - modifier values i pass as arguments when
71:13 - i create individual layer objects
71:16 - i'm getting a small stutter when the
71:18 - background image is reset back to
71:20 - position 0. i fix that by removing this
71:22 - else statement here
71:27 - now the reset should be smooth and not
71:29 - noticeable
71:30 - i can also use small values as speed
71:32 - modifiers
71:35 - i want the back layer to scroll very
71:37 - slowly if i use speed modifier 0.2 and
71:40 - base game speed is 1 that layer will
71:42 - scroll by 0.2 pixels per frame because
71:45 - we are multiplying game speed by speed
71:47 - modifier
71:49 - i will try 0.2
71:51 - 0.4
71:53 - 1 because layer 3 is this ground image
71:55 - so that it should scroll the same speed
71:57 - as the rest of the main game objects and
71:59 - layer 4 are these items in the
72:01 - foreground so i will make them scroll at
72:03 - 1.5 base game speed
72:06 - the issue we have right now is that
72:08 - layer 4 these foreground objects should
72:10 - be in front of the player but right now
72:12 - they are behind because in the main
72:14 - animation loop i'm drawing all four
72:16 - background layers before i draw the
72:17 - player there are multiple ways to solve
72:20 - this i'll use the simplest possible
72:22 - solution
72:23 - i will draw only layer 1 2 and 3 here as
72:26 - part of the background class and remove
72:29 - layer 4 to draw it separately later
72:31 - because i removed layer 4 from the array
72:33 - i need to call its update method first
72:35 - from inside update method on the main
72:37 - game class here on line 226 i'm calling
72:41 - background.update which updates layers 1
72:43 - 2 and 3 and i will also call update on
72:46 - layer 4 like this
72:49 - inside draw method we are redrawing all
72:51 - elements that make up our game for every
72:53 - animation frame first we draw the
72:55 - background which now contains only layer
72:57 - 1 2 and 3. then we draw the player on
73:00 - top of that then we draw ui then enemies
73:02 - and on top of everything we will draw
73:04 - background layer 4 to make it appear in
73:06 - front of all other game objects
73:08 - the thing to understand is that since we
73:10 - are drawing everything on the same
73:11 - canvas element what is drawn first will
73:14 - be drawn behind the thing that is drawn
73:16 - after
73:17 - background will be behind the player
73:26 - time to draw the player we start by
73:28 - bringing player image into the project
73:30 - here in index html i created this
73:32 - seahorse sprite sheet that you can
73:34 - download and use we will have basic
73:36 - swimming animation and we will have
73:38 - power up animation row because when the
73:40 - player collects a special overcharged
73:42 - fish it will absorb its energy the
73:44 - player's eyes and chest will light up
73:46 - and player will shoot two lasers instead
73:48 - of one in script.js i go to line 59
73:51 - inside player class constructor and i
73:53 - bring the image into the project using
73:55 - getelementbyid same as we did with
73:57 - background images
73:59 - in style css i give player image display
74:02 - none
74:06 - we are bringing the image into
74:07 - javascript project here on line 59.
74:10 - inside the draw method currently we are
74:12 - drawing a black rectangle representing
74:14 - the player to draw the sprite sheet i
74:16 - will use built in canvas draw image
74:18 - method
74:19 - i pass it the image i want to draw so
74:21 - this dot image from line 59 and x and y
74:24 - coordinates where i want to draw it i
74:26 - want to draw it at player's current x
74:28 - and y position from lines 54 and 55. you
74:31 - can see we are drawing the entire sprite
74:33 - sheet with all its frames and rows draw
74:36 - image method can accept three arguments
74:38 - like this we can also give it five
74:40 - arguments by adding width and height
74:42 - in case of a sprite sheet like this it
74:44 - will just squeeze all frames into an
74:46 - area of one frame we don't really want
74:48 - that
74:49 - what we need is the longest version of
74:50 - draw image method that expects nine
74:52 - arguments and it gives us the most
74:54 - control over the image we want to draw
74:56 - on canvas those nine arguments are image
74:59 - we want to draw source x source y source
75:02 - width and source height of the area we
75:04 - want to crop out from the source image
75:06 - and destination x destination y
75:09 - destination with and destination height
75:11 - to specify where we want to draw that
75:13 - cropped out piece of image on
75:15 - destination canvas we will need some
75:17 - helper variables as well frame x will
75:20 - cycle through the sprite sheet
75:21 - horizontally frame y will determine row
75:23 - of the sprite sheet in this case row 0
75:26 - or row 1.
75:29 - i need to crop out just one frame from
75:31 - the source sprite sheet image so source
75:33 - x will be frame x times width of a
75:35 - single frame which in our case is the
75:37 - width of player because i like to size
75:39 - my images to the same size we will draw
75:41 - them in game
75:43 - when frame x is 0 we display this frame
75:46 - when frame x is 1 1 times width of 120
75:49 - pixels is 120 so we will draw this frame
75:52 - frame x 2 will be 2 x 120 so 240 pixels
75:56 - this frame and so on it will work the
75:59 - same with frame y vertically frame y
76:01 - times height of the player which is
76:03 - identical to the height of the sprite
76:05 - sheet frame source width is width of a
76:07 - single frame
76:10 - source height is height of a single
76:12 - frame
76:13 - now we are cropping out just one frame
76:15 - perfect
76:16 - [Music]
76:17 - i will animate the sprite sheet by
76:19 - cycling between frames horizontally from
76:21 - 0 to max frame in the case of player
76:24 - sprite sheet max frame is 37 we count
76:27 - from 0.
76:29 - i will handle sprite animation logic
76:31 - down here it's simple if frame x from
76:34 - line 56 is less than max frame from line
76:37 - 58 increase frame x by 1.
76:40 - else reset frame x back to zero
76:44 - if you prepare your sprite sheets well
76:46 - in graphics editor the way i prepared
76:48 - the sea horse for you you only need very
76:50 - little code to get the animation
76:53 - if i set frame y to 1 we will see the
76:55 - second row in the sprite sheet we will
76:57 - use that for power up state for now i
77:00 - set it back to 0.
77:03 - [Music]
77:10 - at this point i no longer need the black
77:12 - rectangle that represents the player but
77:14 - it is still useful to keep track of that
77:16 - area because it will be player's hitbox
77:19 - used for collision detection i replace
77:21 - fill rectangle with stroke rectangle i
77:24 - remove this fill style declaration
77:26 - stroke style will be black by default
77:28 - unless we set it to a different color
77:31 - i want to have a debug mode in my game
77:33 - when i press letter d the game will show
77:35 - hitboxes and maybe other things like
77:37 - enemy hit points player hitbox is this
77:40 - black rectangle we are outlining so i
77:42 - only want to draw that if game.debug is
77:45 - true
77:49 - i need to create that property so down
77:50 - here inside game class constructor i say
77:53 - this.debug is true
77:56 - the last thing i need is to create a
77:57 - switch that will allow the user to
77:59 - toggle debug mode on and off by pressing
78:01 - letter d
78:03 - to create a toggle with javascript is
78:05 - simple i go up inside our input handler
78:08 - class and inside key down event listener
78:10 - i create an else if statement and i
78:12 - check if the key that was pressed is
78:14 - letter d
78:15 - if it is i set the new debug property we
78:18 - just created on the game object to its
78:20 - opposite value so if it's true i set it
78:23 - to false if it's false i set it to true
78:26 - now when i play my game i can toggle
78:28 - debug mode on and off by pressing the
78:30 - letter d at this point debug mode only
78:33 - shows and hides player hitbox but we
78:35 - will attach more functionality to it a
78:37 - bit later
78:43 - nice we are making a lot of progress
78:45 - let's add more characters to the game
78:47 - the base game loop will have three enemy
78:49 - types i created multiple animations for
78:51 - each enemy type to give our game more
78:53 - variety and i will show you how easy it
78:55 - is to swap between them you can download
78:57 - all our datasets in the project files in
78:59 - the section below i made these
79:01 - characters spreadsheets for you so feel
79:03 - free to keep them for your personal
79:04 - projects you can modify them and do
79:06 - whatever you want with them you can
79:07 - credit me if you use it for your
79:09 - personal projects but only if you want
79:11 - also if you want the base photoshop
79:12 - files or separate pieces in png format
79:15 - for all these characters so that you can
79:17 - animate them and turn them into
79:18 - spreadsheets yourself let me know the
79:20 - best free software to create custom
79:22 - sprite animations is dragonbones if you
79:24 - want more advanced features there is
79:26 - also a paid software called spine you
79:28 - don't need any of that because i'm
79:29 - already giving you complete ready to use
79:31 - sprite sheets this is just for those of
79:33 - you who want to learn more and create
79:34 - custom animations or different
79:36 - animations than the ones i created for
79:38 - you so i'm bringing three new images
79:39 - into the project
79:41 - angular 1 will be the most basic
79:42 - anglerfish anime type the sprite sheet
79:45 - has multiple different animations for
79:46 - the same character model and we will use
79:49 - all of them in a minute
79:50 - the second character is a different type
79:52 - of angler fish with more gears and
79:54 - chimney
79:55 - these are steampunk machines that come
79:57 - to life i gave them a lot of mechanical
79:59 - parts these two anglerfish enemies will
80:02 - be just a simple basic enemy type that
80:04 - comes at the player trying to eat it
80:06 - they are not very resistant and they are
80:08 - easy to deal with using our seahorse
80:10 - sentinel lasers the only advantage they
80:12 - have is that they can come in big
80:14 - numbers sometimes to deal with that we
80:16 - have to be smart and use our slowly
80:18 - recharging ammo wisely we can use the
80:21 - third enemy type to help us i call this
80:23 - third enemy type luckyface because it
80:25 - will be an enemy but also a power up at
80:28 - the same time it will have two different
80:30 - models different skins that we will use
80:32 - randomly when we create a new one and
80:34 - the way we use this enemy type to make
80:36 - gameplay more interesting is that the
80:37 - player can do two things when this enemy
80:39 - appears we can shoot it for a lot of
80:42 - score points or we can collide with it
80:44 - to collect it as a power up it doesn't
80:46 - have many life so players also have to
80:48 - be careful not to destroy it
80:50 - accidentally before they can collect it
80:51 - and activate the power up the story is
80:54 - that this is an overcharged fish and
80:56 - when the sentinel sea horse collides
80:58 - with it it absorbs its light and power
81:00 - to activate its ultimate offensive mode
81:03 - for a short period of time it will all
81:05 - be represented by graphics to make it
81:07 - clear to the user what's happening so
81:09 - here is the parent anime class and here
81:11 - we have a child angle 1 class that
81:13 - extends it and inherits from it
81:16 - i will add this.image property and i
81:19 - point it towards the sprite sheet we
81:20 - just included in index.html like this
81:23 - we have three different animations that
81:26 - loop and when we create a new angular
81:28 - fish we will assign it one of these
81:30 - three randomly by setting this dot frame
81:32 - y property to a random number between
81:34 - zero or one or two so mass at random
81:38 - times three
81:40 - wrapped in math floor
81:44 - like this
81:45 - right now we have these small red
81:47 - rectangles representing each anglerfish
81:49 - enemy same as i did with player i
81:51 - replace fill rectangle with stroke
81:54 - rectangle and i remove this fill style
81:56 - declaration
82:00 - and also this one
82:02 - the draw enemy sprite sheet same as we
82:04 - did with player sprite sheet i use
82:06 - built-in canvas draw image method i pass
82:09 - it image i want to draw so this dot
82:11 - image from line 124
82:14 - if i just pass it x and y coordinates it
82:16 - will draw the entire big sprite sheet
82:18 - with all frames and all rows i declare
82:21 - frame x that will help us to navigate in
82:23 - the spreadsheet horizontally
82:26 - frame y will navigate vertically
82:28 - [Music]
82:31 - max frame will be the maximum horizontal
82:33 - frame which is 37 for this particular
82:35 - sprite sheet
82:37 - i only want to draw enemy hitboxes when
82:39 - debug mode is active so this line will
82:41 - run only if this.game.debug is true
82:45 - i want to draw them at the original full
82:47 - size so i remove this temporary size
82:50 - modifier we created earlier
82:52 - if i pass a draw image method additional
82:54 - width and height we will squeeze all
82:56 - frames into an area of one frame
82:59 - so i will add four more to define an
83:02 - area i want to crop out same as we did
83:04 - with the player so source x source y
83:07 - source with and source height
83:09 - so image i want to draw four arguments
83:12 - for the area i want to crop out from the
83:14 - source image and four arguments for
83:17 - where to place that cropped out image on
83:19 - destination canvas
83:21 - source x will handle horizontal cycling
83:23 - through the sprite sheet and it will be
83:25 - frame x from line 106 times width from
83:28 - line 124. we keep width property on a
83:31 - subclass because it will be different
83:33 - for each enemy type
83:35 - source y will be frame y from 107
83:38 - times height from line 125.
83:41 - source width will be this.wave
83:46 - source height is this.height
83:49 - i'm giving you sprite sheets that are
83:50 - already sized exactly as they will be
83:52 - drawn in the game so we don't have to do
83:54 - any scaling with code here it's simpler
83:56 - and it's more performance efficient to
83:58 - do it this way
84:00 - the sprite animation itself will be
84:02 - simply going between frame x0 and max
84:04 - frame over and over
84:06 - we will handle it here inside update
84:08 - method if frame x from 106 is less than
84:12 - max frame from line 108 increase frame x
84:15 - by one else reset frame x back to zero
84:20 - and we are animating our first enemy
84:22 - type the final game will be wider i just
84:24 - keep the game area smaller so that i can
84:26 - show you everything on one screen
84:30 - in style css i hide images with id angle
84:33 - 1 angle 2
84:36 - and lucky
84:37 - [Music]
84:39 - i can set the game width to 700 pixels
84:42 - so that the large enemies fit better
84:44 - you can see that each enemy fish has
84:46 - been randomly assigned one of the three
84:48 - possible animations i prepared for you
84:51 - it gives our game a nice variety
84:53 - a needs to account for game scrolling
84:55 - speed when calculating anime positions
84:57 - so down here inside update method on
85:00 - enemy class i say this dot x plus equals
85:03 - this dot speed x minus
85:06 - this.game.speed
85:07 - this way we can have dynamic events that
85:09 - change game speed and enemies will
85:11 - always be correctly positioned in
85:13 - relation to our scrolling game world
85:16 - [Music]
85:21 - let's add the second type of angularfish
85:24 - i created for you i copy this child
85:26 - class that extends the parent enemy
85:28 - class and i call it angular 2.
85:32 - width of a single frame is 213 pixels
85:35 - and height is 165 pixels
85:40 - for this anime model i created two
85:42 - different animations so frame y can be
85:45 - row 0 or row 1.
85:49 - so now we have two different anime types
85:51 - i want to have a simple functionality
85:53 - where i say something like when you
85:55 - create a new enemy in the game in 50 of
85:58 - cases make that enemy angular 1
86:01 - otherwise make it angular 2. we will
86:03 - handle that logic inside add nme method
86:06 - we will do it by rolling dice once every
86:09 - time we create a new enemy so helper
86:11 - variable i call randomize
86:13 - is math.random math at random declared
86:17 - like this will generate a random number
86:18 - between 0 and 1. if that random number
86:21 - is less than 0.5 create angular 1 enemy
86:25 - type
86:30 - else create angular 2.
86:36 - up here on line 249 i increase game
86:39 - limit to 15 seconds so we have some more
86:41 - time to test everything before game over
86:43 - is triggered immediately i can see the
86:45 - new angular 2 enemy type
86:47 - and i can see we are playing both
86:49 - animations perfect
86:51 - giving graphics like this for your game
86:53 - will go a long way to help you create
86:54 - unique stories and adventures for your
86:56 - players if you are interested how to
86:58 - take drawings of static characters and
87:00 - turn them into animated sprite sheets
87:02 - with free dragon bone software like i
87:04 - did with this seahorse and angular for
87:06 - this class let me know and i might make
87:08 - a course on that
87:10 - on enemy class i have this dot lives and
87:12 - this dot score properties i want each
87:14 - enemy to have different values here so i
87:16 - cut it here and i paste it on each enemy
87:19 - type individually
87:22 - angular 1 will have 2 lives and when we
87:24 - defeat it we will get 2 score points
87:26 - angle 2 will have 3 lives and it will
87:28 - give 3 score points quick test to see if
87:31 - everything works i can see enemy lives
87:33 - and it gives the correct amount of score
87:35 - points
87:36 - don't worry about the color of the
87:37 - numbers right now we will fix that later
87:40 - [Music]
87:46 - let's create a third enemy type i copy
87:48 - this code block and i will call this
87:50 - subclass luckyfish for example
87:55 - width will be 99 pixels and height 95.
88:01 - this fish will have three lives and if
88:03 - destroyed it will award 15 score points
88:06 - i will give it a property i call type
88:09 - and i will set it to lucky we will use
88:11 - this to check which enemy type player
88:13 - collided with
88:14 - down on line 314 inside add anime method
88:18 - i add another else if statement like
88:21 - this
88:22 - if random number is less than 0.3 we
88:24 - create angular 1 else if it's less than
88:27 - 0.6 we create angular 2. when the random
88:30 - value is between 0.6 and 1 we create
88:33 - luckyfish using the new class we just
88:35 - wrote
88:38 - there's something strange happening with
88:39 - the animation i go up to luckyfish class
88:41 - to see what's wrong
88:43 - i can see that on line 153 i need to
88:46 - point
88:47 - this dot image property to the correct
88:49 - sprite sheet
88:50 - and we are animating our special
88:52 - luckyfish powerup
88:54 - there are two models because the sprite
88:55 - sheet has two rows and we are
88:56 - randomizing vertical coordinate with
88:58 - frame y here on line 154
89:02 - [Music]
89:07 - when the player collides with one of
89:09 - these special overcharged fish it enters
89:11 - a powerup mode let's write that code now
89:14 - we start by declaring this.powerup
89:16 - property on the player up here on line
89:18 - 65. initially i set it to false powerup
89:22 - will last for a while and then the
89:24 - player will go back to the normal state
89:26 - so we will need another timer
89:28 - we can use delta time for it
89:30 - we will have two helper variables called
89:32 - powerup timer and powerup limit powerup
89:36 - timer will be count in milliseconds
89:38 - when it reaches power up limit of 10 000
89:40 - milliseconds 10 seconds powerup state
89:43 - will end
89:44 - we will handle that logic here in update
89:46 - method on player class i say if this dot
89:49 - power up from line 65 is true we enter
89:52 - this code block
89:54 - inside we check if powerup timer is more
89:57 - than powerup limit
90:03 - and if it is we set powerup timer back
90:06 - to 0
90:09 - and power up to false
90:12 - we will also set player sprite sheet to
90:14 - frame y 0 so normal default animation
90:18 - else meaning power up is true and power
90:20 - up timer is not yet higher than power up
90:23 - limit the player is in power up mode and
90:25 - powerup timer is counted in milliseconds
90:28 - by adding delta time we calculated delta
90:31 - time before inside the main animation
90:33 - loop is the difference in milliseconds
90:35 - between timestamp from previous and the
90:37 - current loop we need to make sure update
90:39 - method expects delta time as an argument
90:42 - on line 69
90:46 - and we pass it to this method inside
90:48 - update method on the main game class
90:50 - here on line 286
90:57 - so we are counting timer and frame y is
91:00 - on the second row so value is one we
91:02 - come from zero that will give us a
91:04 - special animation with light coming from
91:06 - chest and eyes and also tail will
91:08 - animate differently because while in
91:10 - this state we will shoot two lasers one
91:12 - from the nose and one from the tail at
91:14 - the same time two lasers for the price
91:16 - of one ammo
91:18 - at the same time we will be recharging
91:20 - ammo by 0.1 per frame and this will be
91:23 - on top of the regular recharging speed
91:25 - so ammo will be recharging very fast
91:27 - while in power up mode so when powerup
91:31 - is set to true we enter this code block
91:33 - powerup timer is increasing by delta
91:36 - time counting how many milliseconds we
91:38 - are in powerup mode frame y is animating
91:41 - special overcharged animation and ammo
91:43 - is recharging fast
91:45 - as soon as power up timer increases over
91:48 - the value in power up limit which will
91:50 - happen after 10 seconds 10 000
91:52 - milliseconds we set power up timer back
91:54 - to 0 we set power up to false and we set
91:58 - animation rule back to normal regular
92:00 - floating animation
92:06 - inside update method on game class
92:08 - in this area where we check for
92:10 - collision between player and enemies we
92:12 - check if type property on that enemy is
92:14 - set to lucky
92:23 - if it is we call a special method on the
92:25 - player object called enter powerup we
92:28 - will write it in a minute
92:31 - else if we collided with another anime
92:33 - that is not luckyfish we decrease score
92:36 - by 1 as a penalty to the player this
92:38 - will encourage player to collide with
92:40 - power up fish and avoid regular enemies
92:42 - to get maximum possible score
92:48 - i go up to player class here on line 111
92:51 - i create that method so enter power up
92:54 - its job will be to set everything up
92:56 - when player enters power up state
92:58 - i could have used state design pattern
93:00 - but we don't have that many player
93:02 - states so we can do it simply like this
93:04 - when we enter power up we set power
93:06 - powerup timer back to zero in case we
93:09 - collided with powerupfish while we are
93:11 - already in powerup state this will make
93:13 - sure the time resets and we get full 10
93:15 - seconds from that second collision
93:18 - we set powerup property on player object
93:20 - to true we will also recharge the ammo
93:23 - to its maximum possible value
93:29 - i test it
93:32 - i collide with our special overcharged
93:34 - fish and player gets overcharged we are
93:37 - in powerup mode and ammo is instantly
93:39 - refilled and it's recharging very fast
93:42 - perfect after 10 seconds power up ends
93:45 - ammo stops recharging because we are
93:47 - well over max ammo value and player
93:50 - sprite sheet switched to the basic
93:51 - floating animation
93:53 - great
93:54 - so when we are in powerup mode our
93:57 - sentinel seahorse will shoot defensive
93:59 - lasers from mouth and tail at the same
94:01 - time
94:02 - it's overflowing with energy and it can
94:04 - shoot extra free projectiles from tail
94:07 - every time it shoots one from the mouth
94:10 - we can handle that functionality with
94:11 - javascript very easily by declaring
94:13 - additional method i call should bottom
94:16 - in shoot top we handle shooting from the
94:18 - mouth and shoot bottom we will handle
94:20 - logic for tail lasers
94:22 - so inside i check if ammo is more than
94:25 - zero and we just push new projectile
94:28 - into projectiles array
94:33 - i adjust its horizontal and vertical
94:35 - starting position because i want it to
94:37 - be coming out from the tail
94:39 - i will call this method from inside
94:41 - shoot top like this while we are running
94:43 - the code in shoot top we check if we are
94:46 - in power up mode
94:49 - and if we are we execute shoot bottom
94:51 - method as well to add that extra free
94:54 - projectile
94:56 - i tested lasers are just coming out from
94:58 - sears's mouth in basic floating state
95:01 - if we collect the power up fish we enter
95:03 - power up mode and both should stop and
95:05 - shoot bottom methods are running we are
95:08 - shooting two projectiles but it costs
95:10 - only one ammo
95:12 - getting overcharged makes the player
95:14 - very powerful maybe we need some bigger
95:16 - bulkier enemies so we get more challenge
95:18 - i made two types of mechanical whales
95:20 - for player to defeat probably you will
95:22 - need these power apps to do so
95:23 - [Music]
95:25 - i want the projectiles to come from
95:27 - behind the player we are drawing
95:28 - projectiles inside a draw method on
95:30 - player class if i want them to be drawn
95:33 - behind i need to make sure we draw
95:35 - projectiles first and the player second
95:38 - like this
95:41 - i want to make it even more visually
95:43 - clear when powerup mode is active for
95:45 - example i can make this ammo display up
95:48 - here different color while in powerup we
95:51 - draw all these ui elements in our custom
95:53 - ui class
95:55 - on line 243 before i draw all these
95:58 - small rectangles representing ammo i
96:00 - check if power up property on player
96:02 - class is true if it is i set fill style
96:05 - to a different color i want that color
96:08 - to be similar to the glow effect we have
96:09 - on our sprite sheets so maybe this
96:15 - it works the problem is that it also
96:17 - recolors the timer text because we
96:19 - define fill style here we draw ammo and
96:22 - then we draw the timer
96:24 - i can keep drawing ammo at the same
96:26 - coordinates in our game and i can move
96:28 - this entire code block further down
96:30 - [Music]
96:33 - that way this white fill style will
96:35 - apply to timer and the other color will
96:38 - apply only to ammo like this
96:51 - [Music]
96:56 - instead of drawing a rectangle
96:58 - representing a laser projectile we can
97:01 - also use an image i bring it into the
97:03 - project here in props section in index
97:06 - html you can download it in the video
97:08 - description or you can use your own
97:10 - image i give it an id of projectile
97:15 - i bring it into the project here on line
97:17 - 38 inside projectile class constructor
97:21 - this dot image equals to
97:24 - document.getelementbyid and i use the id
97:26 - i just gave it so right now we are
97:28 - drawing yellow rectangles representing
97:30 - our projectiles i delete that and
97:32 - instead i will use draw image method
97:34 - this time it's simple because the image
97:36 - is already the right size
97:39 - i just give it three arguments the image
97:42 - i want to draw and x and y coordinates
97:44 - where to draw it on canvas
97:49 - nice we are drawing images these
97:51 - projectiles can also be animated either
97:53 - using a special sprite sheet or all
97:55 - different kinds of particle effects we
97:57 - will use sprite sheet to animate
97:58 - projectiles in a bonus section of this
98:00 - course
98:01 - [Music]
98:07 - let's add a web font to make the text
98:09 - look better
98:10 - adding a font to a canvas game is very
98:12 - simple i go to google phones and i
98:15 - search for bangers i like this comic
98:17 - book style
98:19 - when you have your font you click select
98:21 - your style here you can select multiple
98:23 - different fonts like this if you want
98:25 - then we go up here to view selected
98:27 - families if you choose more than one
98:29 - this code will be adjusted to contain
98:31 - all of them as part of a single
98:33 - declaration all we need to do to bring
98:35 - the font to our project is to copy these
98:37 - link tags and paste them up here in
98:40 - index html ideally above the main css
98:43 - style sheet to make sure the fonts are
98:45 - available from there as the code gets
98:47 - executed line by line from top to bottom
98:50 - i go back to google phone's website and
98:52 - here it also gives us a ready-made css
98:55 - font family declaration i copy it and i
98:58 - put it inside our style css file here on
99:00 - canvas element
99:03 - now my font is available so i go to
99:05 - script js inside ui class i set this
99:08 - custom font family property we wrote
99:10 - before to bangers and now all the texts
99:13 - drawn by ui class so score timer and
99:16 - game over messages will use the new font
99:19 - let's adjust the winning text to
99:20 - something less boring i want to keep the
99:22 - victorian steampunk explorer theme going
99:25 - for this game so winning message will
99:26 - say most wonders in big letters
99:30 - and with an exclamation mark
99:32 - secondary smaller message will say well
99:35 - done explorer
99:36 - for the losing message let's use another
99:38 - old phrase i will say blazes with an
99:41 - exclamation mark it's a word for when
99:43 - something goes wrong in old english
99:47 - secondary small message will say
99:50 - get my repair kit and try again for
99:53 - example
99:54 - you can come up with your own messages
99:56 - here if you want now i have my messages
99:58 - in a new font so i can adjust the sizing
100:00 - and spacing
100:02 - i want the main message one to be much
100:04 - bigger i try 150 pixels
100:09 - well that's way too big we could also
100:11 - adjust the text size to match the width
100:13 - of canvas but let's keep it simple for
100:15 - now and set it to 100 pixels
100:20 - hm i think i will go with 70 pixels
100:28 - i want the messages to be closer
100:30 - together so instead of 40 pixels offset
100:32 - i tried 20 for both of them
100:40 - i'm happy with the spacing and font size
100:42 - for now
100:47 - i can see that we still have the
100:49 - projectile image visible in the top left
100:51 - corner of the browser window so install
100:53 - css i set it to display none
100:56 - we can also see the spacing of the
100:57 - losing message now looks good
101:02 - i would also like the little numbers
101:03 - above each enemy that represent their
101:05 - lives to be only visible when debug mode
101:08 - is active to do that i go up to enemy
101:10 - class and inside draw method i only want
101:13 - to call that fill text method if debug
101:15 - mode is active if debug property on the
101:18 - main game object is true
101:25 - let's test it
101:31 - yes i can only see hitboxes and enemy
101:34 - lives when in debug mode perfect
101:39 - i want to make sure that player cannot
101:40 - leave the screen right now if you press
101:42 - up or down arrow for long enough player
101:44 - will move completely off screen inside
101:47 - update method on player class we will
101:48 - handle vertical boundaries
101:52 - let's start with the bottom boundary if
101:54 - this dot y vertical position of the
101:56 - player is more than the height of the
101:58 - game minus the height of the player
102:01 - meaning that the bottom edge of the
102:02 - player is touching the bottom edge of
102:04 - the game area make sure we cannot move
102:07 - past this point
102:09 - like this
102:10 - i actually want the player to disappear
102:12 - halfway so that it can avoid very big
102:14 - dangerous enemies we will add soon i
102:17 - will do that by multiplying player
102:18 - height times 0.5 here and here now we
102:22 - can move half the sea horse's body
102:23 - outside the screen and then we hit the
102:26 - boundary we just defined
102:28 - i will do the same thing for the top
102:29 - boundary else if player's current
102:32 - vertical y coordinate is less than minus
102:34 - player height times 0.5 meaning that the
102:38 - top half of the seahorse is off screen
102:40 - make sure it cannot move any further up
102:43 - like this i test it
102:45 - top boundary works
102:48 - bottom boundary works perfect
102:52 - [Music]
102:57 - up on line 48 we have a particle class i
103:00 - will use it to create broken parts
103:02 - falling from enemies every time we hit
103:04 - them and for a big spray of spare parts
103:06 - when we completely destroy an enemy we
103:09 - will also make those parts bounce from
103:11 - the floor for a specific number of times
103:13 - before they fall off screen particle
103:15 - class constructor will need a reference
103:17 - to the main game object start in
103:19 - horizontal x coordinate and start in
103:21 - vertical y coordinate i convert those
103:24 - arguments into class properties as usual
103:26 - we will use a sprite sheet with nine
103:28 - images in a grid each particle object
103:31 - will randomly choose one of these images
103:33 - so that we have some variety
103:36 - this dot image is documented to the
103:38 - getelementbyid
103:41 - and id will be gears
103:44 - in index.html i bring it into the
103:46 - project here in the props section id is
103:49 - gears and file name is gears.png you can
103:53 - download it in the project section as
103:54 - usual
103:58 - install css i hide it by giving it
104:00 - display none
104:04 - here we are referencing that image with
104:06 - javascript i will need some helper
104:08 - variables to navigate around the sprite
104:10 - sheet each particle object each spare
104:12 - part flying from the enemy will have a
104:14 - random image assigned from these nine
104:17 - available options frame x will be a
104:19 - random number between 0 and 2 so column
104:21 - 0 or 1 or 2.
104:26 - frame y will be the same so row 0 or 1
104:28 - or 2. combination of frame x and frame y
104:31 - value for each particle object will
104:33 - point to a specific image in the grid
104:35 - for example frame x2 frame y1 will be
104:38 - here
104:39 - sprite size will be the size of
104:41 - individual frame in this case frames are
104:43 - squares 50 x 50 pixels i want each
104:46 - particle to have a different size when
104:48 - drawn on canvas so we will create size
104:50 - modifier and we will set it to be a
104:52 - random number between 0.5 and 1. i will
104:55 - set it to one number after decimal point
104:58 - to reduce artifacts
105:00 - so particle size will be sprite size
105:04 - multiplied by size modifier to make sure
105:07 - every particle is a different random
105:09 - size when drawn on canvas
105:11 - i want particles to fall in both
105:13 - directions horizontally from the enemy
105:15 - so speed x will be a random number
105:17 - between -3 and plus 3. if it's minus it
105:20 - will move to the left if it's plus value
105:22 - it will move to the right on the
105:24 - positive direction on horizontal x-axis
105:28 - speed y vertical speed will be a random
105:31 - number between 0 and -15 so particles
105:34 - will always start moving upwards on the
105:36 - negative direction on the vertical
105:38 - y-axis before they start being pulled
105:40 - down towards the ground by gravity
105:43 - i set gravity to 0.5 let's see what kind
105:46 - of curved movement we get we can adjust
105:49 - it later
105:50 - marked for deletion will initially be
105:52 - false
105:54 - i want the corks wheels and spare parts
105:57 - to rotate as they fall so i will have an
105:59 - angle property storing rotation angle
106:01 - for each particle separately starting at
106:04 - 0
106:05 - and the speed of that rotation will also
106:07 - be randomized in this dot va property
106:10 - velocity of angle rotation speed will be
106:12 - random value between minus 0.1 and plus
106:15 - 0.1 radians per animation frame
106:23 - in update method we will increase the
106:24 - rotation angle by va
106:28 - speed y will increase by gravity which
106:30 - will give it a nice curve let's say the
106:32 - particle will start moving upwards
106:34 - because starting speed y is -15 as we
106:37 - increase speed y by gravity from line 61
106:40 - that -15 value goes closer to zero at
106:43 - that point when it reaches zero it will
106:45 - stop moving and it will be at its peak
106:47 - height as speed y further increases by
106:50 - gravity value into positive numbers it
106:52 - increases by 0.5 per animation frame
106:55 - that particle will start falling down
106:58 - faster and faster until it disappears
107:00 - below the bottom edge of canvas
107:02 - this dot x minus equals speed x to move
107:05 - particles horizontally
107:07 - this dot y plus equals speed y to
107:09 - actually apply that speed y value
107:11 - affected by gravity to the vertical
107:13 - coordinate of each particle
107:16 - if the particle fell off screen
107:18 - vertically so its y coordinate is more
107:20 - than game height plus size of the
107:22 - particle or if the game scrolled past
107:25 - the particle so its x position is less
107:28 - than zero minus particle size set its
107:30 - marked variation property to
107:34 - true draw method will take context as an
107:37 - argument
107:39 - we call draw image method
107:40 - pass it the image we want to draw
107:44 - and x y
107:45 - width and height where to draw it on
107:47 - canvas
107:49 - since the particle image is a grid of
107:51 - frames it's a sprite sheet we only want
107:53 - to crop out one individual frame for
107:55 - each particle object i will also need to
107:58 - specify cropping position so source x
108:01 - source y source width and source height
108:04 - source x is this dot frame x from 954
108:07 - times this dot sprite size from line 56
108:12 - source y is frame y times sprite size
108:18 - source width and source height will be
108:20 - this dot sprite size like this we want
108:22 - to crop out a frame 50 times 50 pixels
108:25 - from the source sprite sheet
108:27 - then we multiply that by size modifier
108:30 - and we draw it at that scaled size
108:35 - we will need an array that holds all
108:37 - active particle objects i will create it
108:39 - here as this.particles property on the
108:42 - main game object
108:48 - for each particle in that array we call
108:49 - their update method like this
108:52 - using es6 arrow function syntax to keep
108:55 - the code cleaner
108:59 - after that i call built-in filter method
109:01 - on that array and i replace that
109:03 - original array with a different one that
109:05 - contains only particles that have marked
109:07 - for deletion property set to false
109:10 - all the particles with marked for
109:11 - deletion properties set to true will be
109:13 - removed
109:17 - inside the draw method again we call for
109:19 - each on each particle object we call its
109:22 - draw method and we pass it context as an
109:24 - argument
109:25 - as it expects up here on line 73
109:31 - we have our particle class ready we just
109:33 - need to find a good place in our code to
109:35 - add these particles i go down to update
109:38 - method on game class and here where we
109:40 - check for collisions between projectiles
109:42 - and enemies i create a for loop
109:46 - this for loop will run 10 times
109:52 - and each time it runs it takes this dot
109:54 - particles array and it will push new
109:56 - particle object inside
109:58 - i know that particle class constructor
110:00 - expects a reference to the main game
110:02 - object as the first argument so i pass
110:04 - it this because right now in our code we
110:07 - are inside that game object
110:10 - each particle also needs starting x and
110:12 - y coordinates so i pass it x and y of
110:15 - the enemy that just collided with the
110:16 - projectile
110:18 - i don't want the particles to come from
110:20 - the top left corner of each enemy i want
110:22 - them to come from the middle so i add
110:24 - enemy width times 0.5 horizontally and
110:27 - enemy height times 0.5 vertically
110:34 - i copy this for loop
110:36 - i actually want 10 particle spare parts
110:38 - to fall from the enemy when it collides
110:40 - with the player and gets destroyed
110:46 - down here i remove the for loop and just
110:48 - push one particle
110:50 - i test it
110:55 - nice we have a splash of spare parts
110:57 - coming out of anime when they are
110:59 - destroyed by colliding with the player
111:01 - player in this game is indestructible we
111:03 - will make that clear by giving it a
111:04 - special animated shield later in the
111:06 - bonus section
111:09 - i copy this code that adds just one
111:11 - particle and i actually want to put it
111:13 - here so that every time projectile
111:15 - collides with enemy one particle follows
111:17 - out
111:18 - nice so now every time enemy gets hit by
111:21 - a projectile one particle spare part
111:23 - falls
111:24 - if enemy is destroyed by colliding with
111:26 - the player 10 particles come out in all
111:28 - directions
111:30 - i want the particles to bounce off the
111:32 - floor for a specific number of times
111:34 - before they fall off screen to make this
111:36 - effect even more intense
111:38 - i go up to our particle class and here
111:40 - on line 65 i create a helper variable
111:44 - i call it bounced and initially i set it
111:47 - to false
111:48 - i also want to define a margin from the
111:51 - bottom end of canvas from which point
111:53 - the particles will bounce so i call it
111:55 - for example bottom bound boundary
111:59 - like this and i set it to 100 pixels if
112:02 - particle reaches this point i want it to
112:04 - bounce so i will switch its speed y
112:07 - value to its opposite
112:11 - if vertical position of the particle is
112:13 - more than game height minus bottom bound
112:15 - boundary so somewhere around this point
112:20 - and at the same time if this dot bounce
112:22 - from line 65 is false
112:25 - set bounced to true so that it doesn't
112:27 - bounce again after this and set speed y
112:31 - to its opposite value by multiplying it
112:33 - times 0.5
112:39 - so particles fall in it reaches this
112:41 - point and its current speed is for
112:43 - example plus 5. we switch it to minus
112:46 - 2.5 making it bounce moving upwards
112:49 - again still line 70 keeps applying
112:51 - gravity so eventually we reach zero and
112:54 - go into positive numbers making the
112:56 - particle curve towards the ground again
112:58 - and eventually fall off screen it
113:00 - bounces once sets bounced to true so
113:03 - this if statement check will fail for
113:05 - the second bounce and particle will just
113:07 - fall off screen
113:11 - maybe i don't want particles to all
113:13 - bounce from the same vertical point on
113:15 - the ground how about they bounce from a
113:17 - range between this and this point
113:19 - roughly to match our ground level image
113:22 - so bottom bounds boundary will be a
113:24 - random value between 60 and 160 pixels
113:28 - from the bottom edge of canvas area
113:31 - what about if we want to specify how
113:33 - many times each spare part bounces from
113:35 - the ground rather than having them
113:37 - bounce just once
113:39 - line 65 i set the initial bounced
113:42 - property to zero in this check on line
113:44 - 74 i check if bounced is less than two
113:50 - and each time we bounce i increase
113:52 - bounced by 1 here on line 75.
113:55 - now each particle bounces twice before
113:58 - it falls off screen
114:21 - down here where we create particles i
114:22 - copy this for loop that creates 10
114:24 - particles
114:25 - we create one particle when anime
114:27 - collides with the projectile i paste
114:30 - that for loop here to create 10
114:31 - particles when enemy is destroyed by a
114:33 - projectile
114:35 - so particles will come out of enemies
114:37 - after three different events when enemy
114:39 - collides with the player and is
114:40 - destroyed we get 10 particles
114:43 - when projectile collides with an enemy
114:45 - we get one particle
114:47 - when enemy is destroyed by projectile we
114:50 - get 10 particles
114:52 - so we know how to create particles when
114:54 - certain events happen in our game we
114:56 - know how to bounce them off floor and we
114:58 - know how to control how many times they
115:00 - bounce
115:04 - [Music]
115:09 - we also have this angle property that is
115:12 - increasing by va on line 69. if you've
115:15 - never done rotation on canvas this part
115:17 - might be a little bit challenging but i
115:19 - will try to explain each particle has a
115:21 - different angle value that's increasing
115:23 - by va value that's also randomized for
115:26 - each particle object it means that at
115:29 - any point each particle is at a
115:30 - different rotation their angles have
115:33 - different values
115:34 - to make sure that rotation angle only
115:36 - affects one specific particle and
115:39 - doesn't spill out and affect other
115:40 - objects we draw on canvas i will wrap
115:43 - the entire drawing code between save and
115:45 - restore
115:46 - save method takes note of the current
115:48 - canvas state when we call restore later
115:51 - that restore will look for its
115:53 - associated save method and it will reset
115:56 - all canvas settings back to that point
115:58 - in time anything done between save and
116:01 - restore will just affect the code the
116:03 - drawing code in between after we call
116:06 - restore everything will be reset to its
116:08 - original state
116:09 - to rotate something on canvas we first
116:12 - have to move rotation center point the
116:14 - point that is normally considered
116:16 - coordinates 0 0 on canvas so the top
116:18 - left corner we have to translate that
116:21 - point over the object we are rotating so
116:23 - translate to the current x and y
116:26 - position of the particle
116:28 - calling translate like this moved
116:30 - rotation center point from top left
116:32 - corner to this dot x this dot y
116:34 - coordinates of this particle
116:36 - then we call built in rotate method that
116:39 - takes angle value in radians i pass it
116:42 - the angle property that is increasing
116:43 - for every animation frame by va here on
116:46 - line 69.
116:48 - not sure if you can see but particles
116:50 - are currently making very large circles
116:52 - around their x and y coordinates it is
116:54 - because we are going to another distance
116:56 - of x and y from these coordinates
116:59 - because of the fact that we translated
117:01 - point zero zero and rotation center
117:03 - point to these coordinates for all
117:05 - intents and purposes this dot x and this
117:08 - dot y between the save and restore in
117:10 - this area of our code is considered
117:12 - point zero zero on canvas and then i'm
117:15 - drawing this particle at this dot x this
117:17 - dot y from that translated point
117:20 - further and i'm rotating it making it go
117:22 - in larger circles around that center
117:24 - point i fix it by changing x and y to
117:27 - zero here
117:29 - because position of that particle is
117:31 - already defined on line 81 in translate
117:34 - call
117:40 - now the particles are rotating from
117:42 - their top left corner so i shift them a
117:44 - little bit by half of their width
117:46 - and half of their height to rotate
117:48 - around the center point of each particle
117:54 - i have other classes about rotation for
117:56 - now let's just move on if you don't
117:58 - fully understand some things about
117:59 - rotation don't worry it will become more
118:01 - clear as you use these techniques more
118:03 - often in the future we are getting a lot
118:05 - of particles now if you are on a very
118:07 - old computer you can reduce the amounts
118:09 - of particles to get better performance i
118:11 - don't have any performance issues on my
118:13 - computer let me know if it runs smoothly
118:15 - for you or if you had to decrease the
118:17 - number of particles to get a good frame
118:18 - rate
118:22 - the particles don't move correctly in
118:24 - relation to the ground artwork i need to
118:26 - go here and include the game's scrolling
118:29 - speed in the horizontal position
118:30 - calculation
118:36 - so this actually has to be plus
118:42 - yes now it works awesome
118:48 - [Music]
118:53 - time for a small cleanup first of all i
118:56 - want the debug mode to be disabled by
118:58 - default we can still press letter d on
119:00 - keyboard to toggle it on and off but
119:02 - when the game first loads i want player
119:05 - and enemy hitboxes and enemy lives to be
119:07 - hidden by default
119:09 - we have a bug in our game when the
119:11 - player collides with any enemy type it
119:13 - goes into a power up mode that would
119:15 - make the game too easy we only want the
119:17 - player to enter power up when it
119:19 - collides with power up fish and later in
119:21 - the bonus section there will be another
119:23 - way to enter power up for skilled and
119:25 - fast players who can shoot fast and big
119:28 - moonfish before it comes too close
119:31 - to make sure the power up works
119:32 - correctly i just need to fix this
119:34 - comparison operator on line 357
119:37 - like this
119:39 - now our sentinel sea horse only enters
119:41 - power up if it collides with lucky fish
119:45 - another bug is when we enter power up
119:47 - player's ammo gets automatically
119:49 - assigned to max ammo this is meant to
119:51 - refill the ammo but if the player saved
119:53 - up and has current ammo higher than
119:55 - maximum ammo entering power up will
119:58 - actually reduce the total amount of ammo
120:00 - they have i fix it here on line 159
120:04 - inside enter power up method on the
120:06 - player class we only refill ammo to max
120:08 - ammo if the current ammo is less than
120:11 - max ammo
120:14 - like this
120:19 - that works
120:20 - i'm using vs code editor when i press
120:23 - ctrl
120:24 - f i can look for all console logs i want
120:26 - to delete them let's keep our code and
120:28 - console clean
120:30 - particle spare parts falling from the
120:32 - enemies are not bouncing from the
120:33 - correct area i want the bounce area
120:35 - range to match the ground artwork a bit
120:37 - closer here on line 66 inside particle
120:40 - class constructor i set bottom bounds
120:43 - boundary to a range between 60 and 140
120:46 - pixels
120:50 - i want to change the order in which we
120:51 - draw our game elements because we are
120:53 - drawing everything on a single canvas
120:55 - element the order in which we call draw
120:57 - methods will determine what is behind
120:59 - and what's on top
121:01 - i go down here inside the main draw
121:03 - method on game class and i want to draw
121:06 - the background first then ui elements so
121:09 - score ammo timer and game over messages
121:13 - then we draw player projectiles
121:14 - particles and enemies on top of that you
121:17 - can play with the draw order here if you
121:19 - want if you want ui to be on top of
121:21 - everything for example just draw it last
121:23 - i think it looks better like this
121:25 - because it's a bit 3d or 2 and a half d
121:28 - when it's slotted between the game world
121:30 - and game characters like this we can do
121:32 - many other things to make the ui feel
121:34 - like a part of the game world i have
121:35 - lots of ideas maybe in the next class
121:37 - i'll show you more game text can be
121:39 - floating moving changing colors it's
121:41 - easy to do it if you follow my other
121:43 - coding tutorials and you understand
121:44 - canvas animation well
121:52 - we have a power up mode so the game
121:54 - currently is very easy when we are in
121:56 - power up enemies have no chance let's
121:58 - add a massive enemy type that when
122:00 - defeated splits into five smaller
122:02 - enemies that should give the player some
122:04 - challenge hope you like teeth and
122:06 - tentacles
122:07 - it will also introduce some tactical
122:09 - decisions into the game maybe sometimes
122:12 - it's better to avoid the enemy
122:13 - altogether if we are low on ammo when we
122:15 - know we can't deal with the little
122:17 - enemies that come out of it when we
122:18 - destroy the big one
122:20 - i copy luckyfish class that extends the
122:23 - main parent enemy class
122:25 - and i rename that copy hive whale this
122:28 - is a massive mechanical whale that
122:30 - serves the enemy swarm as a hive vessel
122:32 - containing a lot of aggressive and fast
122:34 - drones width is 400 pixels and height is
122:38 - 227 pixels
122:40 - this dot image will be looking for an id
122:42 - of hive whale
122:44 - i need to go to index.html to bring that
122:46 - spreadsheet into the project you can
122:48 - download it in the project files section
122:51 - i made just one animation row for this
122:52 - anime type it's a lot of work animating
122:54 - all these tentacles and creating this
122:56 - sprite sheet and also it's already a big
122:58 - image file image with an id of hive
123:01 - whale and source is assets slash hive
123:04 - whale png
123:06 - in style css i give that image display
123:08 - none
123:10 - frame y will be zero because this sprite
123:12 - sheet only has one animation row
123:16 - it will have 15 lives it can take a lot
123:18 - of damage when defeated it will give
123:20 - player 15 score points
123:23 - type is hive like this and it will move
123:25 - very slow so here i will override the
123:27 - default speed x property from the parent
123:30 - enemy class and i set it to a random
123:32 - number between minus 0.2 and minus 1.4
123:36 - pixels per frame
123:37 - i want the enemies to be spread a bit
123:39 - more down not all the way to the bottom
123:41 - of the game area but maybe 95 percent of
123:44 - the game height i do it by replacing
123:46 - this vertical position calculation on
123:48 - angular 1 angular 2 luckyfish and hive
123:51 - whale with
123:53 - 0.95
123:54 - position where enemies can spawn in the
123:56 - game can be anywhere between 0 and 95
123:59 - percent of game height we need this
124:01 - extra space there are some large enemies
124:03 - incoming
124:06 - we add hive whale into the project down
124:08 - here inside add enemy method on the main
124:11 - game class i copy this line and i say if
124:13 - randomize is between 0.6 and 0.8 add new
124:18 - hive whale enemy type
124:25 - and here they come i can enable debug
124:27 - mode by pressing letter d to see its
124:29 - massive hitbox and its current lives we
124:32 - need to hit the whale with 15
124:33 - projectiles to destroy it but that's not
124:35 - all when destroyed 5 smaller fast and
124:39 - aggressive drones come out of it and
124:41 - they will go straight for our sentinel
124:43 - seahorse character let's create that
124:45 - enemy type
124:47 - [Music]
124:54 - drones are small fast and aggressive
124:56 - creatures they live inside hive wells
124:58 - where they collect resources and feed on
125:01 - whatever the hive will swallows let's
125:03 - make sure that sentinel seahorse is not
125:05 - their next meal
125:07 - i copy this code block and i will name
125:09 - it drone
125:12 - this enemy type is different they are
125:14 - ambush predators and they always hide
125:16 - inside the hive whale ready to jump out
125:18 - and attack their prey they will not be
125:20 - coming at player from the right side of
125:22 - the screen like the other enemy types do
125:24 - we will only see them when we destroy a
125:26 - hive whale for that reason when we
125:28 - create a new drone using this class we
125:30 - need to pass a game object as usual but
125:33 - also we need to pass it the current x
125:35 - and y position it will be the current
125:37 - position of the hive while we just
125:38 - destroyed
125:41 - i convert x and y into class properties
125:43 - as we always do
125:48 - image will be looking for an element
125:49 - with an id of a drone
125:54 - i bring it into the project here in
125:56 - index html id is a drone source is
125:59 - assets
126:00 - drone png i created two different
126:02 - animation rows each one will be moving
126:04 - differently so we get some variety
126:07 - frame y will be a random number either
126:09 - row 0 or row 1.
126:13 - each drone will have 3 lives and will
126:15 - award player with 3 score points if
126:18 - destroyed i will give it type drone i'm
126:20 - not sure if i will use this type
126:22 - property for something but might as well
126:24 - declare it we might need it later
126:26 - this enemy can move very fast if it
126:28 - wants to it will have a random speed
126:31 - range from a minus 0.5 to minus 4.7
126:35 - pixels per frame
126:39 - the way i want this to work is when we
126:41 - destroy hive whale with projectiles it
126:43 - will spawn 5 drones
126:46 - in star css i give the drone image
126:48 - display none
126:50 - if the hive whale gets destroyed by
126:51 - colliding with the player there will be
126:53 - no drones because the drones would spawn
126:55 - too close to the player and there will
126:57 - be no time to try and aim and target
126:59 - them properly it would not be a good
127:01 - gameplay experience having enemies spawn
127:03 - so close to the player
127:06 - if projectile collides with an enemy and
127:09 - if lives of that enemy are less or equal
127:11 - to zero that enemy is destroyed
127:14 - we check if the enemy that was just
127:16 - destroyed has type property set to hive
127:20 - if it is a hive whale we take enemies
127:22 - array and push one new drone enemy
127:24 - object inside if you remember drone
127:27 - class expects game and x and y position
127:30 - were to appear in the game world i want
127:32 - it to appear under the destroyed hive
127:34 - whale so i pass it x and y of that
127:36 - destroyed enemy
127:38 - let's test it i destroy a hive whale and
127:42 - we have one drone coming out of it nice
127:45 - let's put this code into a for loop that
127:47 - runs five times to create five drones
127:59 - we have five drones but they all appear
128:01 - on top of each other in the top left
128:03 - corner of the hive whale that's not
128:05 - ideal let's spread them around a bit
128:09 - starting position of the drone will be
128:10 - horizontal exposition of the hive whale
128:13 - that was just destroyed plus a random
128:15 - number between zero and the width of the
128:17 - hive whale enemy
128:19 - starting vertical position of each drone
128:21 - will be vertical y position of the hive
128:23 - well plus a random number between zero
128:26 - and height of the hive whale like this
128:35 - maybe just height times 0.5
128:42 - nice now the drones are more spread out
128:45 - some move very fast some move slower
128:48 - this is good
128:49 - we get too many particles i don't want
128:51 - each drone to burst into 10 particles
128:53 - when destroyed what if we make the
128:55 - number of particles spare parts that
128:57 - fall from enemies when destroyed to be
128:59 - equal to the score that enemy gives
129:05 - i also make the same change here on line
129:08 - 383 when enemies get destroyed by
129:10 - colliding with the player
129:13 - now hive whale should burst into 15
129:15 - particles because when defeated it gives
129:17 - 15 score points
129:19 - each drone will turn into three spare
129:21 - parts that way we won't get a massive
129:23 - flood of 50 cogs and wheels when we
129:25 - destroy 5 drones
129:30 - [Music]
129:36 - i want the game to feel good when we
129:37 - score some points and destroy an enemy i
129:40 - want that enemy to really pop so not
129:42 - only we will turn it into spare parts
129:44 - that bounce around we will also play a
129:46 - dust or fire explosion from a sprite
129:48 - sheet i have two special sprite sheets
129:50 - for this purpose you can take them and
129:52 - use them in your other projects as well
129:53 - if you want many games need dust and
129:56 - fire effects like this all art assets
129:58 - for this episode were custom made by me
130:00 - or artists i hired so there is no
130:02 - copyright you can use them however you
130:04 - want enjoy
130:07 - we will have the parent explosion class
130:09 - and we will extend it into two child
130:11 - classes dust explosion and fire
130:14 - explosion parent explosion class will
130:16 - contain methods and properties shared
130:18 - for all explosion types it will expect
130:21 - game x and y as arguments because i want
130:23 - the animation to play over the enemy
130:26 - that was just destroyed so that x and y
130:28 - position will be passed from the outside
130:30 - each time we create a new explosion
130:32 - object both fire and smoke explosion
130:35 - will be single row sprite sheets i could
130:37 - also have placed them into a single
130:39 - image we will cover compact sprite sheet
130:41 - animation in later class not today i
130:43 - will cycle through them from left to
130:45 - right from frame x0 to max frame
130:50 - sprite height is the height of a single
130:52 - animation frame in the sprite sheet and
130:54 - it will be the same for both explosion
130:56 - types
130:57 - i made both sprite sheets the same
130:58 - height of 200 pixels so that property
131:01 - can be on the parent class it's a
131:03 - property shared between all explosion
131:04 - types
131:05 - sprite with the width of a single
131:07 - animation frame in the sprite sheet will
131:09 - be different for each type because of
131:11 - that it will sit on each subclass
131:13 - separately we will define that in a
131:14 - minute
131:16 - the sprite sheets have only 8 frames so
131:18 - they will animate very fast i want us to
131:20 - be able to control fps frames per second
131:22 - on this animation and i want that fps to
131:25 - be independent of animation speed of the
131:27 - rest of the game we will do that using
131:29 - delta time again and we will need 2
131:32 - helper variables timer that will count
131:34 - from 0 adding delta time over and over
131:36 - until it reaches interval value when we
131:39 - reach it we will serve the next
131:41 - animation frame in the sprite sheet
131:43 - interval will be 1000 milliseconds 1
131:45 - second divided by 15 so the animation
131:48 - will run at 15 fps i can also put frames
131:51 - per second in a separate property if i
131:53 - want to we can control fps by adjusting
131:55 - that property instead
131:58 - marked for deletion will be initially
131:59 - set to false as usual
132:03 - we will need update method and it will
132:04 - expect delta time value as an argument
132:07 - we calculate delta time in the main
132:09 - animation loop draw method will expect
132:11 - context as an argument to specify which
132:13 - canvas element we want to draw on
132:16 - update method will simply animate the
132:18 - sprite sheet by increasing frame x
132:19 - property from line 302
132:23 - draw method will draw currently active
132:24 - animation frame cropped out from the
132:26 - sprite sheet let's start by just giving
132:28 - it image we want to draw
132:30 - and x and y coordinates where to draw it
132:35 - so this is the parent explosion class it
132:37 - contains properties and methods shared
132:39 - between all explosion types we will have
132:42 - two child classes smoke explosion and
132:45 - fire explosion i say class smoke
132:48 - explosion extends explosion that extends
132:51 - keyword creates a relationship between
132:53 - these two classes and it sets up
132:55 - prototype-based inheritance behind the
132:57 - scenes for us smoke explosion subclass
133:00 - now has access to properties and methods
133:02 - that sit on explosion super class we
133:05 - will also have fire explosion subclass
133:08 - constructor will expect game and x and y
133:11 - coordinates in index html i bring the
133:14 - sprite sheets into the project here in
133:16 - the props section
133:20 - ids will be smoke explosion
133:26 - and fire explosion
133:30 - install css we give both of them display
133:33 - none
133:38 - i point the subclass towards that image
133:41 - using getelementbyid
133:43 - i'm placing this.image property on the
133:45 - subclass because that image is specific
133:47 - only for this subclass parent superclass
133:50 - contains only properties and methods
133:52 - that are shared between all subclasses
133:55 - sprite width the width of a single frame
133:58 - will be 200 pixels
133:59 - both sprite sheets have 8 frames so max
134:02 - frame will be 8.
134:04 - rectangles on canvas are drawn from the
134:07 - top left corner i want the explosion
134:09 - animation rectangle to be coming from
134:10 - the exact center of the anime rectangle
134:13 - i can do it like this i'm going to give
134:15 - it width and height property and i set
134:17 - it to be equal to sprite with and sprite
134:20 - height
134:21 - i take x and y properties from the
134:23 - parent class and i place them on the
134:24 - child class once we have a width
134:27 - property here i offset x position by
134:29 - half of its width moving its center
134:31 - point to the middle of the image
134:32 - horizontally i will also move the
134:34 - vertical y position into the middle of
134:36 - the image vertically
134:38 - like this
134:40 - down here inside game class constructor
134:42 - i create an array that will hold all
134:44 - currently active explosion objects
134:50 - inside update method same as we do for
134:53 - particles i will call for each
134:58 - and for each explosion object in
135:00 - explosions array i call its update
135:02 - method we will also use filter method to
135:05 - remove all explosion objects that have
135:07 - marked for deletion properties set to
135:09 - true
135:12 - inside the draw method i call for each
135:14 - on each explosion object again and i
135:17 - draw them passing it context notice i
135:20 - draw explosions after i draw enemies so
135:22 - they will be drawn on top of enemies the
135:24 - order in which we call draw methods here
135:26 - matters we will have two different
135:28 - explosion types so same as we did with
135:30 - adding different types of enemies to the
135:32 - game on the main game class i define a
135:34 - custom method i call add explosion we
135:37 - will have a variable that will randomize
135:39 - a number between 0 and 1 like this if
135:42 - that random number is less than 1 for
135:45 - now
135:49 - take this explosions array and push new
135:51 - smoke explosion inside i pass it game so
135:54 - this keyword it will also need a
135:56 - position so we will take it from the
135:58 - anime we just collided with we will add
136:01 - a reference pointing to that entire
136:03 - enemy object here as an argument
136:05 - x and y of this explosion will be x and
136:07 - y properties from that enemy object that
136:10 - is passed here let's try to add it into
136:12 - the game and see what we've got so far
136:16 - up here on line 419 we check if player
136:19 - collided with an enemy that enemy will
136:21 - be destroyed and we want to animate an
136:23 - explosion at that position so i will
136:26 - call this dot at explosion like this i
136:29 - pass it the enemy player just collided
136:31 - with and destroyed as an argument
136:34 - i also want the explosion animation to
136:36 - play when we destroy enemy with
136:38 - projectiles so here we check if
136:39 - projectile collided with an enemy if
136:42 - that enemy's lives are less or equal to
136:44 - zero it will be destroyed and we animate
136:46 - a splash of spare parts we set marked
136:49 - for deletion on that animator true and
136:51 - we will add explosion here as well like
136:53 - this
136:55 - i test it and we are getting no
136:57 - explosion animations i don't see any
136:59 - console errors
137:01 - let's debug it by console login
137:02 - explosions array from inside add
137:04 - explosions method every time we add one
137:07 - we consolidate the entire array
137:10 - i can see that add explosion method runs
137:12 - and creates the console log for us but
137:14 - the array remains empty let's see what i
137:16 - did wrong probably i made a typo
137:18 - somewhere
137:22 - oh i see this if statement never runs
137:24 - because there is no this.randomized
137:26 - property easy fix we need to refer to
137:29 - this temporary helper variable like this
137:36 - now i'm getting a console error which is
137:38 - better because this error will guide us
137:40 - to where the problem is the error says
137:43 - we must call constructor in derived
137:44 - class before accessing this now i know
137:47 - the problem is inside smoke explosion
137:49 - class constructor this is a so-called
137:52 - derived class when i create a new smoke
137:54 - explosion object i want the parent class
137:56 - constructor to run first creating
137:58 - properties and values shared for all
138:00 - child classes and then i want to add
138:03 - this little bit of code that's specific
138:05 - only for smoke explosion class to do
138:07 - that i have to call the parent class
138:09 - constructor
138:10 - using a special super keyword i know
138:13 - that parent class constructor expects
138:15 - game x and y so i pass these arguments
138:18 - along
138:19 - it's a good lesson for me to remember on
138:21 - a child class we must always call super
138:23 - class constructor before using this
138:26 - keyword otherwise we will get a
138:27 - reference error
138:29 - now when i create a new smoke explosion
138:31 - we create one new blank object this
138:33 - constructor will run first creating
138:35 - these properties and then these
138:37 - properties will be added on top of that
138:40 - smoke explosion will also have access to
138:42 - update and draw methods because of the
138:44 - inheritance that was set up behind the
138:46 - scenes by the special extents keyword we
138:48 - used we fixed all the bugs and typos
138:51 - when i test it i can see that everything
138:53 - works and we are adding smoke explosion
138:56 - into the explosions array and we are
138:58 - drawing the entire sprite sheet at that
139:00 - position perfect let's clean it up and
139:02 - make it into a proper sprite animation
139:04 - now this dust cloud is a sprite sheet we
139:07 - are drawing it using built-in draw image
139:09 - method on line 312. as we already did
139:12 - multiple times in this class we know
139:14 - that to animate a sprite sheet we need
139:16 - to crop out individual frames and swap
139:19 - through them one by one we do it by
139:21 - passing draw image method nine arguments
139:24 - image we want to draw source x source y
139:27 - source width and source height to
139:29 - specify area we want to crop out we want
139:32 - to crop out one sprite sheet frame at a
139:34 - time and destination x destination y
139:37 - destination with and destination height
139:39 - to tell javascript where we want to draw
139:41 - that cropped out image on destination
139:44 - canvas
139:45 - we already have the values for
139:47 - destination we just need to specify the
139:49 - crop area
139:50 - source x will be frame x from line 300
139:53 - times sprite width from line 320. source
139:57 - y will always be 0 because this sprite
139:59 - sheet has only one row of frames width
140:01 - of the cropped area will be sprite width
140:04 - height will be sprite height
140:07 - so now because frame x times sprite
140:09 - width determines horizontal cropping
140:11 - coordinate as we increase frame x inside
140:14 - update method the frames will cycle and
140:16 - animate now it works but the animation
140:19 - is coming from the top left corner of
140:20 - each enemy and it plays very fast also
140:23 - we are not removing all the explosion
140:25 - objects that already animated and we
140:27 - have an ever increasing array i will
140:30 - check if frame x is more than max frame
140:34 - and if it is i know that entire
140:36 - animation played at that point it's safe
140:39 - to set marked for deletion property to
140:41 - true and that explosion object will be
140:43 - removed by filter method we already
140:45 - defined earlier
140:48 - in the browser console i can see that
140:49 - the old explosion objects are being
140:51 - correctly removed nice
140:54 - i want the animation to run at 15 frames
140:56 - per second i do it by creating a
140:58 - periodic event again
141:00 - timer will be counting from 0 to the
141:02 - value of milliseconds defined in
141:04 - interval whenever it reaches that value
141:06 - it will trigger next frame in the sprite
141:08 - sheet and resets back to 0 so that it
141:11 - can count again
141:13 - so if this dot timer from line 303 is
141:16 - more than this slot interval from line
141:18 - 304 increase frame x by one else keep
141:22 - increasing timer by delta time
141:24 - accumulating milliseconds until it
141:26 - reaches the interval
141:30 - this will serve only the first frame is
141:32 - because after timer reaches interval it
141:34 - needs to be reset back to zero so that
141:36 - it can count again for the next
141:38 - animation frame
141:41 - it still doesn't work i can see that
141:43 - update method expects delta time as an
141:45 - argument to be used to increase timer
141:47 - value online 313. i have a feeling i'm
141:51 - not passing it that value when i call it
141:54 - i go down to line 422
142:00 - and i pass update method on explosion
142:02 - object delta time
142:05 - now we are animating the explosions at
142:08 - 15 frames per second structuring your
142:10 - code like this will allow you to set
142:11 - different fps for different objects in
142:13 - your game
142:14 - in this case we did it because player
142:16 - and enemy sprite sheets are optimized
142:19 - for high frame rate but explosion
142:21 - animation has only 8 frames so it looks
142:23 - better if we stagger the animation speed
142:26 - if you want to turn this into a mobile
142:28 - game you would have to do this for all
142:30 - objects player and enemies you would
142:31 - have to delete some frames and stagger
142:33 - their animation because current mobile
142:35 - phones will struggle to surf sprite
142:37 - sheets with so many frames we are using
142:39 - for our characters if you want lower
142:41 - frame rate spreadsheets for these
142:42 - characters let me know i can easily make
142:44 - them for you
142:46 - the explosions are animated in the top
142:48 - left corner of each enemy i want them to
142:50 - be in the middle so i adjust the initial
142:52 - x coordinate we pass it by half of enemy
142:55 - wave
143:00 - and the vertical coordinate will be
143:01 - adjusted by a half of enemy height
143:04 - like this
143:07 - this looks good
143:08 - i'm noticing that we are not showing the
143:10 - first animation frame of our smoke
143:12 - explosion sprite sheet it's because we
143:14 - first call the update method that
143:16 - increases frame x by 1 and then we draw
143:19 - it i can fix it by calling draw first
143:21 - and then i call update
143:25 - like this
143:29 - now we can see the first sprite frame as
143:31 - well and it stays long enough so we can
143:33 - actually notice it nice
143:38 - let's delete this console log we don't
143:40 - need it anymore
143:41 - i can change the animation speed of dust
143:43 - clouds by changing the value here in fps
143:46 - property
143:47 - when i set it to a very low value like 5
143:50 - frames per second it becomes obvious
143:52 - that they are not being correctly placed
143:54 - within the game world they are static
143:56 - but they should be scrolling along with
143:58 - the game world for the positioning to
144:00 - look right
144:02 - i fix it by accounting for the current
144:04 - game speed in their horizontal
144:06 - coordinate calculation like this
144:09 - now they scroll with the game world and
144:10 - it looks as it should
144:18 - i think a good fps for the sprite sheet
144:20 - is around 30 frames per second
144:27 - yes i'm happy with this for now
144:40 - let's create a fire explosion this time
144:43 - it will be very simple i copy all the
144:45 - code inside the constructor into the
144:47 - other child class
144:49 - image will have id of fire explosion
144:51 - like this i actually decided to refactor
144:54 - the fire sprite sheet and now both smoke
144:56 - and fire sprite sheets have frames 200
144:59 - times 200 pixels in that case i can
145:02 - remove sprite with on child class and i
145:04 - can place it on the parent explosion
145:06 - class because now it's shared for both
145:08 - explosion types
145:11 - in that case i can actually take all
145:12 - these properties and add them on the
145:14 - parent class as well
145:21 - i remove them here since they will be
145:22 - automatically inherited
145:24 - nice that's cleaner so only the images
145:26 - are specific for each class all other
145:28 - properties and methods will be shared
145:30 - and inherited from the parent class
145:36 - down here inside add explosion method i
145:39 - say if randomize is less than 0.5 create
145:42 - smoke explosion else
145:45 - careful about the brackets and syntax
145:47 - here
145:50 - else create fire explosion
145:54 - nice work now sometimes we get a fire
145:56 - effect sometimes we get a smoke effect
146:04 - [Music]
146:10 - inside game class constructor i adjust
146:12 - time limit to 30 seconds
146:15 - winning score will be 100 so the player
146:18 - needs to get at least 100 score points
146:20 - in 30 seconds to see the winning message
146:23 - i set ammo interval to 350 milliseconds
146:26 - so that ammo recharges a bit faster
146:30 - and i set enemy interval to 2 seconds
146:33 - let's test it
146:39 - we have a bug i got a winning message
146:42 - and there were some leftover enemies and
146:44 - colliding with them reduced my score
146:46 - below 100 and losing message was
146:48 - displayed instead i need to make sure
146:50 - that after the winning or losing message
146:52 - appears colliding with enemies doesn't
146:54 - affect the score
146:59 - i do it here online 437 only decrease
147:03 - score when we collide with an enemy if
147:05 - game over is false
147:12 - let's tune the game into a more playable
147:14 - and challenging state
147:16 - i make heath whale less likely to appear
147:18 - in our game and luckyfish more likely
147:22 - like this
147:25 - i give hive whale 20 lives
147:30 - luckyfish will have five lives
147:32 - angler two will have six lives angular
147:35 - one will have five lives for example
147:38 - i said game with 2000 pixels this will
147:41 - make the game easier as we can see
147:43 - enemies coming sooner and we can plan
147:45 - and manage our moves and ammo better
147:48 - i try to play to get a better idea of
147:50 - how much score i can get in 30 seconds
147:54 - okay the game ended because we reached
147:56 - winning score 100 in 25.1 seconds
148:01 - let's set winning score to 80.
148:05 - i can strategize now i can see there is
148:07 - a lucky fish come in that will replenish
148:09 - my ammo so i will use as much as my ammo
148:11 - as possible before i get the refill now
148:14 - i get a refill and i can go crazy with
148:16 - my lasers i will be careful not to hit
148:19 - the lucky fish coming at the bottom so
148:20 - that i can collect it and make my power
148:22 - up state longer
148:28 - okay it took 24 seconds to get the score
148:30 - over 80. game has a time limit of 30 000
148:33 - milliseconds 30 seconds if the game runs
148:36 - for that amount of time it will end we
148:38 - need to get enough score points in that
148:40 - time period
148:41 - this is just my choice you don't have to
148:43 - do this but i want the game to always
148:45 - run for 30 seconds i don't want it to
148:47 - end as soon as we get over the winning
148:49 - score so i will comment out line 456
148:52 - game will only end when time limit is
148:54 - over 30 seconds
148:56 - and based on how much score we managed
148:58 - to get we will see a winning or losing
149:00 - message
149:01 - there is an element of luck in the game
149:02 - we designed because it is very dependent
149:04 - on which type of enemy spawns if we get
149:07 - just lucky fish and hive wales we will
149:09 - get a lot of score points fast if we get
149:11 - only anglers it will be very hard to win
149:13 - the game i gave you all the tools and
149:15 - techniques you need to understand you
149:17 - can now adjust the game time enemy
149:19 - health and winning score yourself to
149:21 - make the game as easy or as difficult as
149:23 - you want it to be
149:30 - the game runs well on my gaming pc but
149:32 - if you have a chromebook or some very
149:34 - old laptop you might be experiencing
149:36 - performance issues i focused this class
149:38 - mostly on handling graphics and
149:40 - animation there is a whole other set of
149:42 - optimizations we can do to make this run
149:45 - even on the oldest machines but that's
149:47 - beyond the scope of this class notable
149:49 - optimizations would be for example to
149:51 - draw on multiple canvas elements and
149:53 - only clear parts of canvas that actually
149:55 - update it
149:56 - object pooling technique would also have
149:58 - a massive positive effect on the
150:00 - performance it means that we create a
150:02 - pool of particle and projectile objects
150:04 - and we just reuse them over and over
150:07 - rather than creating new ones and
150:08 - discarding them after one use for this
150:11 - project the quick changes you can make
150:13 - to improve performance would be to
150:14 - increase enemy interval property to make
150:16 - enemies spawn slower if your computer is
150:19 - not keeping up you can also remove all
150:21 - shadow properties inside ui class canvas
150:24 - shadows are still not well supported and
150:26 - optimized in some browsers especially in
150:28 - firefox we can reduce the number of
150:30 - particle spare parts that fall from
150:32 - enemies when damaged and we can also
150:34 - make sure they only bounce off the floor
150:36 - once or that they don't bounce at all if
150:39 - you are still getting performance issues
150:41 - you can also merge all background layers
150:43 - into one image and just animate that one
150:46 - layer that will increase performance
150:47 - massively same goes for our sprite
150:50 - sheets i gave you sprite sheets with 37
150:52 - animation frames which looks really good
150:54 - and smooth in motion but if you struggle
150:56 - to get 60 fps reducing the number of
150:58 - frames and have each animation to be
151:00 - just around 15 frames let's say and
151:03 - staggering animation speed with delta
151:05 - time like we did with animated
151:06 - explosions would make the performance
151:08 - better as well i will probably release a
151:10 - version of sprite sheets with lower
151:12 - frame rate for each character so you
151:13 - don't have to do it manually yourself
151:15 - bonus extended lesson where i add more
151:17 - enemy types animated projectiles shield
151:20 - and simple sound design is linked in the
151:22 - video description but feel free to play
151:24 - with the code and add your own features
151:26 - with the techniques we learned today let
151:28 - me know if you finish this project by
151:30 - typing i did it in the comments if you
151:32 - want more vanilla javascript game dev
151:34 - come and build this game with me i will
151:36 - show you how to use state design pattern
151:38 - for more complex player controls and
151:40 - movement and how to split our code into
151:42 - individual modules click like please
151:44 - i'll see you there

Cleaned transcript:

frank dvorak teaches this javascript game development crash course you will learn how to create a 2d game using javascript html css and object oriented programming and frank provides a lot of free sprites and game art assets so you can follow along frank is a popular teacher who creates super creative courses what a strange planet it's completely covered in a thick layer of smoke initial scans indicate there are no organic life forms present but i register a lot of movement coders hope you like making games let's make a 2d steampunk game completely from scratch with html css and javascript no frameworks and no libraries i will give you a lot of premium art assets for characters environments and props and you can do whatever you want with them you can use them in your projects and you can modify them i will show you how to create gameplay variety by giving different enemy types different mechanics that the player can interact with or has to deal with for example if you destroy a hive well a bunch of small drones will come after you let me show you how to give your games beautiful visuals and how to apply many special features i came up with specifically for this class let's go these creatures have very similar physiology to the earth's seahorses body shape like this can cut easily through the thick atmosphere of this planet they can move very fast seahorse hive is being attacked by something this one has been damaged i wonder if we can hug this creature's central computer to control it for a while it is surprisingly easy to override its circuits seems like these machines are not used to our technology i'm getting a lot of new data ok explorers we are getting a stream of data about multiple different species we will convert their source code into html css and javascript let's analyze it line by line and see how it works we have a lot to learn i will answer all your questions as we discover more about their movement special abilities and how they interact with their planet's environment let's look under the hood of this alien ecosystem the atmosphere is thick enough to allow heavy silicon based lifeforms to float but smoke is blocking most of the sunlight many creatures developed artificial lights and glowing appendages to see through the heavy clouds seahorse sentinel has a basic attack that's powerful against weak enemies but if it absorbs energy from one of the overcharged creatures it gets additional firepower for a short period of time and it instantly replenishes its ammo ammo also automatically recharges over time it seems we just need to help it to get through these aggressive swarms in time so it can join its hive if this is your first time discovering javascript you should try some beginner classes first today's coding will be beginner friendly but i expect some basic knowledge of javascript when you get more comfortable with objects arrays and for loops come join me in this class so after a simple basic setup inside index.html and style css we move into script.js all javascript logic for this game will be written here inside this file i create an event listener for load event notice that we call it on built in javascript window object which represents the browser's window load event fires when the whole page has been loaded including all dependent resources such as style sheets and images we need to do this because we will use a lot of graphics in this project and they can take some time to load if you're trying to draw an image with the javascript remember that you always have to wait for that image to be fully loaded before you run the javascript code that depends on that image i usually like to do html kind of a setup like this custom variable i call for example canvas will store the reference to canvas element i point it towards that element using getelementbyid i give it an id of canvas1 now i need socalled drawing context it is a builtin object that contains all methods and properties that allow us to draw and animate colors shapes and other graphics on html canvas to create it we need to call a special builtin getcontext method on a variable that holds a reference to canvas element so i say canvas dot get context and then i need to pass it identifier sometimes we call this argument a context type we can pass it 2d or webgl here webgl represents threedimensional rendering context today we will work with 2d now i access width property on canvas from line 3 and i set it to 500 pixels height will be 500 as well as you can see 500 pixels is wider than my current browser size for that reason i also like to declare max with property and i set it to 100 percent that way the element will scale down until it's fully visible in the available browser area i also declare max height in case the restricting factor is the height of browser window doing this will make sure we can always see the entire canvas element even when the browser window is too small i will zoom out a bit to adjust my workplace for this tutorial i set canvas width to a larger value and keep my browser window small canvas element will scale down to make sure it's fully visible to build our game today we will use object oriented programming which means we will wrap variables and functions in objects javascript is a prototypebased objectoriented language which means it doesn't have classes it has prototypes but we can use modern javascript syntax that introduced classes as socalled syntactical sugar simplified clean syntax that mimics classes from other programming languages still under the hood it's just working with prototypebased inheritance one of the four main principles of objectoriented programming is encapsulation encapsulation is the bundling of data and the methods that act on that data in objects access to that data can be restricted from outside the bundle in this project i will encapsulate our data into multiple classes each class will have its special purpose the challenge for beginners will be to keep track of how these classes communicate with each other i will explain everything step by step as we write the code to help you understand we need to declare our classes in a specific order class declarations are hoisted in javascript but they stay uninitialized when hosted that means while javascript will be able to find the reference for a class name we create it cannot use the class before it is defined in the code this means that i need to declare input handler class first because i will need to use it inside player class and so on input handle class will keep track of specified user inputs for example arrow keys projectile class will handle player lasers particle class will deal with falling screws and bolts that come from damaged enemies player class will control the main character it will animate player sprite sheet and so on enemy class will be the main blueprint handling many different enemy types layer class will handle individual background layers in our parallax seamlessly scrolling multilayered background and background class will pull all layer objects together to animate the entire game world ui class will draw score timer and other information that needs to be displayed for the user and the main game class will come last inside this game class all logic will come together this will be the brain of our project i hope this gives you a map of what we need to do to complete our game let's write javascript logic inside individual classes and connect them together i will explain everything step by step as we go along constructor is a special method on javascript class when i call this javascript class later using the new keyword constructor will create one new blank javascript object and it will assign its properties and values based on the blueprint inside player will need access to game weight and height and other properties that will be stored on the main game object so i will pass it the main game object as an argument like this i convert that game object into class property on player class like this i'm saying take this game object that was passed as an argument to the class constructor and turn it into class property called this dot game keep in mind that by doing this i'm not creating a copy of the main game object and placing it on player objects in javascript are so called reference data types which means that unlike primitive data types objects are dynamic in nature i'm just creating a reference that is pointing to the place in memory that stores the main game object so when the values and properties on the main game object get updated those changes will be immediately visible from this dot game reference inside this player class i made the size of player sprite sheet the same size as we will draw them in game it's a good practice i know that the width of a single frame in my sprite sheet is 120 pixels and height is 190. if you are a beginner it's best if you use the same sprites and images i'm using it will make the debugging easier in case you run into problems you can always check my code to find the problem all art assets i'm using are linked below you can download them from the project section starting horizontal x coordinate on the player will be 20 pixels and vertical y position is 100 player will also need an update method to move it around and draw a method that will draw graphics representing the player for now let's start by increasing vertical y position on the player by speed y i need to declare that property here it will be 0 at first so no vertical movement draw method will take context as an argument this will specify which canvas element we want to draw on in case our game has multiple layers with multiple canvas elements it's also a good practice to use context argument like this rather than pulling ctx variable from the outside directly into our objects at first i will just draw a simple black rectangle representing the player so built in canvas fill rectangle method and i want to draw the rectangle at player's current x and y position and it will have players with and height so we have our player object how do we include it inside game logic and draw it on canvas as i said the main game class from line 45 will be the brain of our entire project all the logic will somehow go through it again i will give it a constructor constructor will need width and height of canvas as arguments and inside we convert them into class properties this will make sure that the width and height of the game matches the size of canvas element constructor on javascript class is a special type of method that will run once when we instantiate the class using the new keyword it will create one new blank object and it will give it values and properties as defined inside the blueprint here i can take an advantage of the fact that all the code inside the constructor gets automatically executed like this and any code i put inside the constructor on game class will automatically run when i instantiate my game in a minute so when i instantiate game class i want it to automatically create an instance of player class and i want that instance to become class property on game class called this dot player so this.player is equal to new player like this the new keyword is a special command in javascript it will look for class with this name in this case player and it will run its constructor method to create one instance of it based on the blueprint inside so by calling new player online 49 javascript will find player class up here on line 17 and it will run all the code inside its constructor i can see that constructor method on player class needs game as an argument down here we are inside that game class so i pass it this keyword this keyword used inside this class refers to this entire game object our game will also need update and draw methods update method will take this.player property from line 49 which holds an instance of player object and it will call its update method we defined online 26. inside draw method we will render the player on canvas by calling draw method from line 29. i can see that it expects context as an argument so i pass it context like this and that value will be passed along here now i create an instance of this new game class we just wrote and i save it in a variable i call for example game it's equal to new game like this again new keyword will look for class with that name it will find it on line 45 and it will run its constructor method to create one new blank javascript object and assign it values and properties based on the blueprint here on line 46 i can see that game class constructor expects width and height as arguments so i pass it canvas width from line 5 and canvas height from line 6. so the new keyword triggers a class constructor as the constructor gets executed we hit this line which will automatically create an instance of player class from line 17. so this is how by creating the main game object we also automatically create player object and now it sits as a property on the game class on line 49 perfect we will also need animation loop that will run update and draw methods over and over 60 times per second updating positions and redrawing our game i create a custom function i call for example animate inside i take the instance of game class from line 59 and i call its associated update method we declared on line 51. i will also call draw method from line 54 like this i can see it expects context as an argument to specify which canvas element we are drawing on so i pass it ctx from line 4 this means that this ctx variable will be passed here and it will get passed along to draw method on player object here now the player knows where we want to draw it after we called update and draw we want to trigger the next animation frame so i call built in request animation frame request animation frame method sits on the window object but we can also call it just like this it tells the browser that we wish to perform an animation and it requests that the browser calls a specified function to update an animation before the next repaint so we need to pass it one argument and it will be the method we want to call before the repaint before browser window gets updated and redrawn on screen i pass it animate the name of its parent function to create an endless animation loop request animation frame has two special features it adjusts the user's screen refresh rate for most of us it will be 60 frames per second it also auto generates a timestamp argument and passes that as an argument to its callback function a little bit later i will show you how to use this feature to create periodic events in our project events that repeat in a certain interval i get an error because i misspelled the word constructor here i'm using vs code editor it highlights syntax in different colors which makes it easier to notice typos like this we have our main game logic and we are drawing this black rectangle representing our player it looks static but it's actually animating we can test that by giving players some value here in speed y property the reason the rectangle gets longer now is because we can see old paint we can see old black rectangles that were drawn in the previous animation loops i can fix that by deleting all canvas drawings between each animation frame between every animation loop i call built in clear rectangle method and i want to clear canvas from coordinates 0 0 to canvas with canvas height like this now you can see that because player speed y property is set to plus 1 the player moves by 1 pixel per frame in positive direction on vertical y axis if speed y is 1 player will move upwards if speed y is 0 the player will not move at all it's all because for every animation frame we are adding speed y property to player's vertical y coordinate here on line 27 we know that everything is working well it's good to test your code as you go step by step to discover potential problems i want the player to be controlled by keyboard when i press up arrow we set speed y to 1 and player will move up when i press down arrow we set speed wire to plus 1 and player will move down we will handle all player input up here inside input handler class constructor will take a game as an argument same as we did with the player i converted into this.gameclass property as we said before when we create an instance of a class all the code inside class constructor gets executed we can take advantage of that and i can even apply event listeners from here i simply choose apply event listener like this we will listen for key down event callback function on event listener has a special auto generated argument that contains all kinds of additional details about the event that just happened if i want more details about the keydown event i just need to pick a variable name and i pass it as an argument to the callback usually we use letter e or the word event but you can also type abc whatever you put here will become a custom variable name containing a special object with additional information about the keydown event that just happened i will save it in a variable i call e and i will console log it if you choose console.log e you will get the full event object with many properties i've done this before so i know i want a specific property called key so i console e dot key this will contain a string with the name of the key that was pressed let me show you i need to create an instance of input handle class so as we did with the player i want my input class to be instantiated automatically as i create my main game class so here inside the game class constructor i create a property i call for example this dot input i set it the new input handler and i know its constructor expects game as an argument so same as we did with the player i pass it this referring to this entire game class so now as i create game object down here it automatically creates player object on line 54 and input object on line 55. as we call the new keyword on line 55 javascript will jump to line 9 and it will run input handler class constructor which will among other things apply this key down event listener that's console login the current key that is pressed i open browser console i click on canvas element so it starts registering events and now when i press keys on my keyboard you can see we are console logging the key property inside key down event listener i say if e.k is arrow up take keys array on the game object we will create that array in a second and push that key into the array i create that array here on line 59 inside game class constructor its job will be to keep track of all keys that are currently active that are currently being pressed down i will console.log this.game.keys from here to check if arrow up key is being correctly added i get a console error that is saying that the variable name i'm calling keys from is undefined by the time this callback function is executed javascript forgot what this.game stands for which object it points towards we want javascript to remember that this code initially sits inside this object so that it can see and remember this.game property even when we call it later as we play our game if you are a beginner don't worry about fully understanding this yet all you need to know here is that if javascript forgets what this keyword stands for we need to bind that code to the surrounding codes context we can use built in javascript bind method or even simpler we can use es6 arrow function syntax here a special feature of arrow function is that this keyword inside arrow function always represents the object in which the arrow function is defined arrow function will never forget that it was originally defined inside constructor on input handler class and it will always see this reference for this.game from line 10. therefore it will be able to access this.game.keys and push keys inside now everything is working when i press up arrow key it gets added into this.game.keys and if i press it multiple times it keeps adding more and more so i create another event listener this time for keyup event when we release the key i want to remove it from the array i do that by checking if the array contains that key so built in index of array method the indexof method returns the first index at which a given element can be found in the array or it returns 1 if the element is not present so if this.game.key's index off is more than 1 meaning if key's array contains the key that is currently being released in this key up event take this.game.keys array and remove that element from the array using splice method the splice method changes the contents of an array by removing or replacing existing elements splice method needs at least two arguments the first argument is the index at which we want to start changing the array so it will be the index of that key we want to remove like this and the second argument is delete count an integer indicating the number of elements in the array we want to remove from that starting index so i call splice i want to remove elements starting from this index and i want to remove only one element at that index i put the same counter lock inside key up event you can see that it works well when i press up arrow it gets added when i release it it gets removed added removed nice the problem is when i hold up arrow key down for too long key down event will start firing over and over but key up event doesn't fire so we are not removing those keys we are adding multiple keys we are adding the same key over and over increasing the size of the array this can also be fixed easily i only want to add that key into this.keys array if it's not already present in there so additional condition here if this.game.keys index off the key that was just pressed is 1 now when i press and hold the key gets added only once when i release the button the key gets removed perfect on keydown event i check if key that was pressed is arrow up and at the same time i check if arrow up is not yet in the array only then i push arrow up into this dot keys array on key up event i check if the key that we are releasing is present in the array if it is i remove it using splice method we have the main logic now and adding more keys is easy just be careful about brackets here it's easy to miss something and get an error i wrap this part in another set of brackets and i check if key that is pressed is arrow up or arrow down like this now keys array on the main object can contain nothing and can be empty or it can contain up arrow key or arrow down key and it can even contain multiple keys at the same time in our case both arrow up and arrow down so now keys property on the main game object is an array that always keeps track of presses and releases of up and down arrow keys i store this array on the main game object on line 67 so the information of what keys are currently pressed is available all over our code base it's also available inside our player class because player has this dot game property here on line 35 pointing towards the main game object i can simply check if this.game.keys includes a specific key and i can change player behavior from here i check if this.game.keys includes arrow up notice that before i use index of method to check if element can be found in the array i can also alternatively use built in javascript includes method to do the same thing the includes method determines whether an array includes a certain value among its entries returning true or false as appropriate if this line returns true we want player to move up so we set speed y from line 40 to 1 else if keys array includes arrow down we set speed y to plus 1. i save changes and click canvas and now i can move player up and down by pressing up and down arrow keys the only problem is that player will never stop moving we need to add one more small condition so else meaning this.game.keys array doesn't include arrow up or arrow down we set speed y to zero instead of hard coding minus one and plus one here maybe player speed is dynamic and player can speed up during a power up for that purpose it's better to save max speed in a variable like this so we have current player speed on line 40 and maximum player speed on line 41. let's try 2 pixels per frame and i replace hardcoded values with variables on lines 44 and 45. if we press arrow up speed y is minus max speed if we press arrow down speed y is plus max speed like this now we can change player movement speed if we need to by changing max speed value on line 41 and this is one of the techniques i like to use to handle keyboard inputs in my games if you have any questions or any suggestions how to improve this code let me know by leaving a comment player will be shooting lasers at enemies we will create them by using a class i call projectile constructor will need three arguments the main game object so that this class has access to game properties when it needs them and starting x and y coordinates those need to be dynamic passed as arguments from here because starting coordinates of each projectile will depend on player's current position as usual i convert the arguments past to class constructor into class properties width will be 10 pixels height will be 3 pixels speed will be 3 pixels per frame update method will also increase horizontal x coordinate from line 30 by speed from line 34. i will also need marked for deletion property which will be initially set to false and if horizontal x coordinate of this projectile object is more than width of the game meaning it has moved across the game area this object can be deleted i will actually set it to 80 of the game area so projectiles will be coming from player here to somewhere around here because i don't want enemies to be hit and destroyed off screen let's say that the lasers have limited range so if horizontal coordinate of the projectile is more than 80 of width of the main game area said they're marked for deletion property from line 35 to true this will flag that projectile as ready to be deleted and removed from the game we will remove them in a moment before we do that we will also have a simple draw method that will take context as an argument and i call built in fill rectangle method that will represent the projectile i want to draw that rectangle at coordinates this dot x this dot y and i pass it this dot with this dot height from lines 32 and 33 we will use images and animations for everything soon but first let's set fill style to yellow and draw yellow rectangles for our lasers i will also have to define fill style here on the player a device that yellow color will apply on it as well i can set it to green or black like this so we have our projectile class ready how do we add them into our game one way to do it is by creating a special custom asset on player class player will have two different attack modes so i will call the basic one shoot top in this mode the lasers will be coming out from the mouth of our mechanical seahorse when shoot top method is triggered i take this dot projectiles array i will create in a minute and i will push new projectile inside using the class we just defined on line 27. i created this dot projectiles array on player class this will hold all currently active projectile objects up here i can see that class constructor expects game x and y as arguments so i pass it this.game from line 51 and the current player coordinates so this.x from 954 and dot y from line 55 i want player to shoot when we press a key so i go up to input handler class and here i will make it very simple i go inside key down event and i say else if key is space bar so just space like this you can also use enter or any other key if you want when we press space bar use distort game reference from line 10 and navigate to its player property and from there call shoot top method we just defined since i'm holding all projectiles here on line 60 on player class i will handle projectiles here inside update method i take this dot projectiles array and for each element in that array i call update method we defined on line 39 inside that method i have this check if the projectile moves across the screen we set its marked for deletion property to true i want to remove those elements from projectiles array i will do it using javascript filter method like this the filter method creates a new array with all elements that pass the test implemented by the provided function so here i'm taking projectiles array i call filter on it and the test is that i want all elements to have marked for deletion properties set to false so exclamation mark here this will filter out and remove all elements with marked for deletion properties set to true and since we just said that filter creates a new array we want to override the original array with the new one that was filtered here with this line of code in place every time we set marked for deletion property to true on any projectile object it will get removed from projectiles array i will check if it works by console log in this dot projectiles from inside shoot top method i will also call for each on all projectiles from inside draw method and i trigger draw method from line 43 on each one i remember that i need to pass it context so i pass it along the value from here like this i save changes and run my code and i can see we have an error on line 45 i go up to line 45 and i forgot to call fill rectangle from context so javascript doesn't know what to do with it i fix it like this now i click on canvas and i can move up and down using keyboard arrow keys and i can shoot using spacebar in browser console i can see that projectile objects are being correctly added and removed from projectiles array perfect let's remove these two console logs to clean up our code now the console is cleaner and it's easier to see how projectile array adds and removes objects nice right now we can shoot without limits i want the player to have limited ammo that slowly recharges over time it will also get completely refilled when we collect a special power up fish down here i say if this.game.amo which we will create in a minute is more than zero only then create new projectile object i go down here to line 104 and i create this new ammo property initially we will start with 20 ammo for example every time we create a new projectile we decrease that value by 1. now i can do it 20 times and then it stops even if i keep pressing spacebar we run out of ammo here on line 80 i can change which coordinates the projectiles start from in relation to the current player position we will match it even better when we apply player sprite sheet a bit later to make sure it comes out from the mouth of our steampunk seahorse we will get back to this i can offset it here or i can also do it inside projectile class itself when we use all 20 projectiles we completely run out of ammo i want it to slowly recharge over time to do that i want to run a periodic event in our code base and i want to be able to measure time in milliseconds and say for example every 500 milliseconds every half second automatically recharge one ammo to do that is easy if you know this technique with timestamps and delta time let me quickly explain how it works here on line 116 i create a variable i call for example last time its job will be to store a value of timestamp from the previous animation loop so that we can compare it against the value of timestamp from this animation loop this difference will give us delta time the difference in milliseconds between the timestamp from this loop and the timestamp from the previous loop like this where does this timestamp value come from request animationframe method has a special feature it automatically passes a timestamp as an argument to the function it calls in our case animate i can use it simply by giving it a variable name here you can call it whatever you want as long as you keep referring to that value using the same variable name i will call it timestamp spelled like this and i will use it to calculate delta time here on line 119 after we used last time to calculate delta time for this animation loop we reassign last time to the timestamp from the current loop so that it can be used to calculate delta time in the next loop so request animation frame auto generates a timestamp value which is a number in milliseconds since this loop started we access it here in animate assign it a variable name for example timestamp like this we calculate the delta time which is the difference in milliseconds between the timestamp from this animation loop and the timestamp from the previous animation loop and then we set last time to timestamp from this loop so that it can be used to calculate delta time in the next loop don't worry if this is a bit complicated to understand at first it's a very common technique and it will become more intuitive as you use it in multiple projects i can control delta time to check if it's working my delta time is around 16.6 milliseconds thousand milliseconds one second divided by 16.6 is around 60 so i can see that my game is animating at 60 frames per second let me know if you get the same value or something else if you had an old computer delta time value might be higher because it takes your computer more milliseconds to render animation frame if you have high refresh gaming screen delta time value could be lower for you i wonder if we have any coders here who use that type of screen remember to remove your console locks when you don't need them especially this one that runs 60 times per second it could affect the performance of our game if i just leave it here so we calculated delta time we know how many milliseconds it takes for a computer to render one animation frame to run one animation loop i will pass it to update method here and we can use that value to run periodic events in our game or to measure game time the advantage of this technique is that it doesn't matter if you have strong super computer or a very old slow one delta time measures actual milliseconds in real time so periodic events will happen roughly at the same time on slow and fast machines regardless of their ability to animate our game slow or fast to trigger periodic events in our game i need two helper variables one will be timer that will go between zero and some kind of predefined limit each time it reaches that limit it will trigger some kind of event and it will reset back to 0 to count again for the next loop the second helper variable will be that limit that interval value that timer needs to reach so i want to replenish some ammo every half second 500 milliseconds i will also introduce some hard limit i want the ammo to automatically replenish only up to this value not endlessly so starting ammo will be 20 maximum ammo will be 50 for example inside update method on game class i will use ammo timer and ammo interval helper variables and also delta time to trigger this periodic event that replenishes ammo every 500 milliseconds i say if ammo timer from line 107 is more than ammo interval so 500 milliseconds inside i will also check if ammo is less than max ammo like this only then i will increase ammo by 1. then i reset ammo timer back to 0 so that it can count again else keep increasing ammo timer by delta time i am calculating delta time on line 128 and i'm passing it to update method on game class online 131 i make sure update method expects that value here on line 110 and that delta time value will get passed along here our ammo is already recharging but it's not easy to check and see i can console these values but it would be nice to have some visual representation of our available projectiles as part of our game screen i have user interface class here online 95. i will use it to draw messages and game statuses that player needs to be aware of this class will be very simple a constructor will take a game as an argument so we convert it to a class property as usual we will define font size and font family we will need it later to draw some score and game timers i will also define color and i set it to white for example it doesn't need update method it just needs a draw method it will expect context as an argument and here i will draw a small bar for each available projectile i create for loop it will run as many times depending on the amount of ammo we currently have i will set fill style to this.color this should actually be outside the for loop like this for each available projectile i will draw a small rectangle so fill a rectangle method add coordinates 2050 width 3 pixels and height 20 pixels let's draw what we have so far and then we can finish it once we can see what we are doing same as we did with player and input handler classes i create an instance of user interface class here on line 116 inside game class constructor it expects game as an argument so i pass it this keyword now i use this dot ui property and i call its associated draw method we defined on line 102 and i pass it context nice right now we are drawing all 20 available projectiles on top of each other here to make them align next to each other i just multiply them by the index from the for loop like this 20 pixels spacing is too much how about a spacing of 5 pixels plus 20 pixels left margin like this that's better now we can see how our ammo is slowly recharging i can change the color here on line 100 i can test it and it's working really well it will keep recharging until it reaches max ammo value of 50 and then it should stop yes we will apply better visuals to our game in a moment i just want to have a complete functional game skeleton first we are missing one last important element in our main game loop enemies and some enemies will also work as power ups in this game we will have multiple enemy types in our game with different visuals and behaviors let's take it step by step to make sure we understand how everything works and how the player projectiles enemies and powerups interact with each other enemy class will just contain the main blueprint the properties and methods shared between all enemy types we will then extend this class into multiple small subclasses each enemy type will have a separate child class that inherits from this main enemy parent class all enemies will need access to the main game object so i do this as usual all enemies will also have the same starting horizontal xcoordinate they will go from right to left starting just behind the right edge of game area so this.game.width horizontal speed of each enemy will be a random number between 0.5 and 2 pixels because i want them to move in minus direction to the left on horizontal xaxis marked for deletion will be set to false initially update method will adjust horizontal x coordinate by the amount of speed x value for each animation frame moving enemies from right to left i check if enemy moved completely off screen all the way behind the left edge of game area so if x coordinate of the enemy plus its width is less than 0 we will set its marked for deletion property to true draw method will take context as an argument at first i will just draw red rectangles representing enemies so fill style right and fill rectangle at enemies x and y coordinates and its width and height like this we will have multiple enemy types let's start with the basic simple anime angular fish i call that class for example angular 1 and it extends enemy class from line 86 in this scenario we have a parent anime class also called a super class and we have child angular class also called a sub class this is a good example of the second principle of object oriented programming called inheritance angler is a child of parent enemy class and it has access to its methods such as this update and draw as well as these properties if i call a property or a method on angle class and javascript can't find it on angular it will automatically travel to the parent enemy class and it will look for it there inheritance is used to reduce code repetition instead of redeclaring the same methods and properties on each class i can just declare them once on parent class and all child classes will inherit them automatically we can also do other things here using a special super keyword i will show you as we write the code angle class will have its own constructor because some properties will be specific only to angular fish enemies in our game if i don't declare constructor on angular class at all it will automatically use constructor from anime class from line 87. in this case i want the code from parent class constructor online 87 to run and i want to add some additional properties here if i just declare constructor on angular it will completely override parent class constructor and this code would be ignored so i have to use a special syntax to kind of merge them i want first this code to run and i want to add a little bit of it here i do it by calling super which refers to super class parent class constructor this line of code will make sure that the constructor on the parent gets executed now i can add some more properties that will be specific only for angular remember that if you want to combine constructors like this you have to call super first before you use this keyword doing it the other way around will give you an error i have specific sprite sheets ready for our project so i know that width of a single frame in our angular sprite sheet is 228 pixels and height is 169 pixels i want vertical y position to start from here and go 90 from the top because we will have some ground graphics in our game environment layer these are flying fish machines they need to be above ground rectangles and images on canvas are drawn from the top left corner so i want the starting vertical position on each enemy to be between 0 here and 90 of game height here but i need to offset it by the actual height of the enemy otherwise they will be drawn too low down here that's why i define x coordinate on the parent enemy class on line 89 but i had to wait declaring vertical y coordinate until i had height of that specific enemy type it will all work together well now you'll see inside update method on the main game class i will cycle through all enemies and for each enemy object inside enemies array i will call their update method i also need to define this.enemies array here it will hold all currently active anime objects i will again use filter method to filter out all anime objects that have marked for deletion properties set to true the same thing we did with projectiles and i will cycle through all enemy objects here call their draw method and pass it context so we have anime class we are updating drawing and removing old ones we need to figure out how to add new enemies into our game i will have a special method on the game class called add anime every time this method is called it will push one new anime object inside this dot enemies array notice that i'm not calling the parent anime class i'm calling the child angular 1 class here on line 103 i can see it expects game as an argument so i pass it this keyword because we are inside that game class now i want to call add enemy in a specific interval we will use the same technique we used to periodically recharge ammo and it will be much easier because we are already calculating delta time i will need two helper variables enemy timer that will count between zero and enemy interval i want to add new enemy into our game every one second every thousand milliseconds same as we did with recharging projectiles i say if this.enemy timer which starts from 0 is more than anime interval let's go up here and also declare gameover property and initially set it to false back here on 962 i say and at the same time this dot game over is false because i don't want to be adding new enemies when the game ended and we call at enemy method from here we will also reset enemy timer back to zero so that it can count again else meaning enemy timer is less than enemy interval we will keep increasing enemy timer by delta time which is already being passed to update method here nice we are adding big red enemies to our game i go up to 105 and i make the width and also height smaller just for now before we start animating sprites i will make the entire game wider when we get to later stages for now we are just building the main logic loop we have player that can move and shoot projectiles we have recharging ammo and there are swarms of enemies coming at us nice work if you are following along as usual i want to check if enemies are being correctly added and removed from the array so i consoled this.enemies array here i want to make sure that filter method on line 161 does its job and we don't have endlessly growing array it works well enemies that moved off screen to the left are being removed perfect it's time to add some interactions i need to check if enemies collide with player and also if projectiles collide with enemies to save ourselves code repetition i will create a reusable collision detection method on the main game object i call for example check collisions this method will take two arguments two objects i will call them rectangle one and rectangle two and it will return true if they collide and false if they don't it will be a reusable function so we can use it later and pass it player and enemy as rectangle 1 and 2 and we can also pass it anime and projectile to check if they collide let me show you exactly how to do that right now when checking if two rectangles collide we compare their x y width and height in a specific way so all objects we are comparing need to have x y width and height properties for this to work i will return a statement in brackets like this so if the code in brackets evaluates true or false it will immediately be returned by this function quick and easy to check if two rectangles collide we need to run four checks we need to check if a horizontal x position of rectangle one is less than horizontal position of rectangle two plus its width if this side is to the left of this side i will comment out line 196 just for a moment so the movement doesn't distract us at the same time we need to check if horizontal position of rectangle 1 plus the width of rectangle 1 is more than horizontal position of rectangle 2 if this side is to the right of this side if both of these statements are true we know they're in the same space on horizontal xaxis but it still doesn't mean they collide they can be far away vertically because of that we need two more checks we need to check if vertical position of rectangle one is less than vertical position of rectangle two plus the height of rectangle two if this side is above this side and finally we check if the height of rectangle 1 plus its y position is more than vertical y position of rectangle 2 if this side is below this side if all 4 of these checks are true this entire statement will evaluate to true and check collision function will return true if at least one of these is false the entire statement will be false and we know these two rectangles don't collide we stay inside the main game class and go to its update method in this for each call we cycle through every object inside enemiesarray from 941 and we call their update method as we go through that array one enemy object at the time we will check collision between player object from 937 and that particular enemy rectangle i do this by calling our custom check collision method we just wrote and i pass it player as rectangle one and enemy as rectangle two if this message returns true we know we are colliding and i will set marked for deletion on that animator true i go down to line 200 and i uncomment request animation frame again so that we can test it i can see that whenever player collides with an enemy that enemy gets deleted perfect we have some interactions in the same for each method i will also check each anime against all currently active projectiles they are stored inside this.player.projectiles and i call for each on that array as well like this for each enemy inside enemies array we check against every single projectile in projectiles array i say if this.check collision between projectile from this iteration of this for each and enemy from this iteration from this for each if check collision is true decrease enemy life by one at the same time set marked for deletion on that projectile that collided to true so it gets deleted then i check if enemy lives are less or equal to zero and if they are set marked for deletion on that enemy to true as well and lastly i will increase score by plus one actually i want each enemy to give different amount of score points when defeated so we will increase game score by score property on that enemy now i used three properties that don't exist yet i go up to parent enemy class and i declare them here i set lives to 5 and score that this enemy rewards will be equal to the number of its lives like this i will also draw that number on top of each anime for debugging purposes by calling fill text here i pass it distort lives from line 92 and x and y coordinates of that enemy it's very small so i will set fill style to black and font property will be set to 20 pixels helvetica for now i need to define score on the main game class here on line 154 and i will also define winning score let's set it to 10 points for now so it's easy to test every time we increase score here we check if the current score is more than winning score and if it is game over from line 153 is true i go up to line 130 inside draw method on ui class in this area i will write code to display the current score to the user i call build in fill text method again and i pass it the text i want to draw so this.game.score and i want to draw it at coordinates 2040. i set font property to this.font size from line 126 plus pixels space plus this.font family from line 127. i put a string that says score colon space here plus we will concatenate this.game.score let's see if everything works all seems to be fine except for the text colors jumping around i will move this fill style declaration up here and i set this dot color to white i can also do other adjustments to the text for example shadows if i want the shadows to apply only to the text and not all the shapes on canvas i will put it between built in save and restore canvas methods save method of canvas 2d api saves the entire state of canvas at that point in time that includes settings like stroke style fill style line width global alpha all shadow settings we will use in a minute as well as other things like clipping region or the current transformation matrix so whatever we do with scale translate and rotate canvas methods then we can change the state of canvas however we want and we call restore canvas restore method restores the most recently saved canvas state if there is no saved state this method does nothing so save and restore only work when used together i will start applying canvas shadows if i did that outside save and restore shadows would get applied to everything including player and enemies but in our case these shadows will only affect shapes and text we draw in this area between this save and this restore shadow offset x defines the distance that shadow will be offset horizontally it can be positive or negative depending on if you want the shadow to be to the left or to the right from the source element shadow offset y defines vertical distance of the shadow i set shadow color to black i could also set shadow blur but i don't need it at this time so by wrapping code in save and restore i make sure that canvas shadows and this fill style property affect only this drawing code and not other shapes and graphics we are drawing on the same canvas element this is a pretty solid code base you can use this as a base boilerplate for many different games maybe some of you want to make a copy of this project at this state and save it in a different folder so you can experiment with it later and use it as a starting point of a different game project win and lose condition in our game will depend on how many score points can the player get in a specific time window we are going to handle those game over messages here before we call restore so if game over property on the main game object is true we set text align to center we are going to display message 1 in larger letters and under that there will be message 2 and smaller font what these two messages say will depend on how many score points we managed to get in a specified game time i check if game score is more than winning score message 1 will say you win and message two will say well done so that's our winning message else we display the losing message so message one is you lost message two is try again next time now we actually need to draw these messages on canvas so font for the first message will be 50 pixels space plus font family then i call fill text and we draw message 1 in the center of the screen so x coordinate will be game with times 0.5 vertical y coordinate will be game height times 0.5 i copy these two lines of code and i change some things to draw message to in smaller letters 25 pixels here and message 2 here i try to play the game and win nice we get a winning message i need to create some space between the lines so first message will be minus 40 pixels vertically and the second message plus 40 pixels vertically let's see yeah this is fine for now we need a time limit for our game on the main game object i create two helper variables i call them for example game time which will start at 0 milliseconds and time limit for testing purposes time limit will be 5000 milliseconds 5 seconds after 5 seconds the game will end and depending on how many score points we managed to get we will display winning or losing message in update method i say if game over is false take game time from line 181 and increase it by delta time delta time is the difference in milliseconds between timestamp from this animation loop and the timestamp from the previous loop so it's the amount of milliseconds between frames by adding delta time to game time every time we draw a new frame we are keeping track of how many milliseconds passed since the game started game time variable is simply just accumulating milliseconds since the game started if game time is more than time limit from line 182 so when the game has been running for 5000 milliseconds we set game over to true the final game will run longer i just use 5 seconds time limit here so it's easy to test up inside ui class we want to draw game timer on screen let's do it in this area on line 143 i call fill text and the text will say timer colon plus this dot game.time add coordinates 20 100. actually the variable we just created was called game time like this and i need to add space here nice so we can see game timer i want to format that value so it looks a bit cleaner i create a temporary helper variable called formatted time i want to move the decimal point to show seconds so this.game.gametime times 0.001 that works i also want to display only one digit after the decimal point so i use built in two fixed method and i pass it one two fixed method formats a number using fixed point notation we can use it to define the number of digits we want to appear after the decimal point perfect we have game time functionality i'm getting a buck when i get a losing message and then i defeat a couple of remaining enemies and that message switches to the winning message i want to make sure that after game over message appears we are no longer able to gain more score points down here inside update method on game class i only want to increase score if game over is false i get an error it's supposed to be this.gameover like this this will fix the bug we have the base game we have player enemies and projectiles we have recharging ammo score timer and win and lose condition you can save this code in a separate folder and use it as a base skeleton for many different games if you want from this point i will start adding graphics and features that will be specific to our steampunk alien game this will be the fun part let's go we will be using large detailed images and graphics today i will put all of them here inside index html and because all the code in script.js is inside event listener for load event javascript will only run after all our images have been fully loaded this will prevent errors i will separate art assets in this project into three different categories characters which will include player and enemies props which will include things like mechanical parts that fall from enemies when we damage them and game environment let's start by creating the game world first img element with an id of layer 1 and source will point towards that png file you can download all project images in the description i will put all my images into a project folder i call assets our game world will be made out of four separate layers for parallax scrolling effect layer one two three and four like this i don't really want to draw these images on the web page like this i only want to draw them on canvas with the javascript so inside style css i set all of them to display none in script js on line 116 we have a custom class i called layer its job will be to set up each individual layer object constructor will expect three arguments coming from the outside game image and speed modifier i convert those arguments into class properties like this the width of the images we are using is 1768 pixels and the height is 500 pixels horizontal x coordinate will start at zero and y will also be zero we will need update method to move the background layers from right to left as the game scrolls if horizontal x coordinate is less or equal to minus width from line 121 meaning the background image has moved across the screen and is now fully hidden behind the left edge of canvas we set x back to zero so that it can scroll again else decrease x by game speed times speed modifier each layer object will have different speed modifier to create parallax but all will depend on the main game speed variable so that all four layers can be controlled from one place gamespeed variable doesn't exist yet so i created on the main game class here initially i set it to 1. layer class will also need a draw method it will take context as an argument i call built in draw image method this method needs at least three arguments image we want to draw so this dot image from line 119 and where on canvas we want to draw it so i want to draw it at this dot x this dot y from lines 123 and 124 so we have our layer class which will handle individual background layers we will also need background class that will put all four layer objects together to create the game world constructor will take the main game object as an argument i convert it into a class property like this here we will grab all four images for each layer with javascript so this.image1 will be by document.getelementbyid and i pass it layer one the id i gave it in index html this.layer1 property will be an object that holds an instance of layer class from line 116 so new layer like this on line 117 i can see that layer class constructor expects game image and speed modifier arguments so i pass it this dot game from line 137 this look image 1 from 938 and speed modifier will be one for now update method will move all the layer objects and draw method will draw all of them we will hold all layer objects inside this dot layer's property it will be an array let's start with just layer one inside update method i take these dot layers and i call for each method for each layer object call their associated update method we declared on line 126 draw method will expect context as an argument to specify which canvas we want to draw on inside we will do the same thing call for each on layers array and for each layer object trigger its draw method and pass it that context value because we know that the draw method on line 130 expects that argument so background will handle all layers to create the game world layer class will handle logic for each individual background layer object separately now to animate the background i just need to create an instance of background class inside game class constructor same as we did before with player and input handler classes background class expects game as an argument so i pass it this keyword because i am inside that game class right now inside blade method on game class i take this new background property and i call its update method inside the draw method on game class i call draw method on the background object and i pass it context along here notice that i am drawing background first then the player this will make sure that the background is behind the player and doesn't cover it i'm getting an error i go back to my background class and i want to put this layer 1 object into the array so i have to use this keyword nice we are animating layer 1 of our background i can change scrolling speed by changing the value i pass as a speed modifier if i pass it 5 the game speed is 1 because i'm multiplying game speed times speed modifier 1 times 5 is 5 so background will scroll at the speed of 5 pixels per frame i will bring all other layers into the project i bring their images first then for each one i create an instance of layer class and i put all of them inside this dot layers array okay now we see all four layers i give each layer a different speed modifier these values are passed as speed modifier and they will be multiplied by the current game speed you can control scrolling speed of each layer individually like this for now i will set speed modifier to 1 on all 4 layers you can see that because of line 128 as soon as the layer images slide completely off screen they reset back to x position of 0 so that they can slide again we are getting this gap to get a seamless scrolling background effect we can use a simple trick we can place a second identical image next to the first one so at the point where the first image doesn't fill the entire game area the second image comes in to fill the gap the second image will never be fully visible it will be filling in just for that short period of time before the first image can reset to its starting position again reset to the original position happens in one frame so it's not visible by naked eye it will create an illusion that we have one endless seamless background how do i apply that in code i simply draw a second identical image but i need to make sure it is next to the first one the second image will start where the first image ends so its horizontal x position will be this dot x plus this dot width like this and that's it we have endless parallax background implemented in our game i can change its scrolling speed by adjusting speed property on the main game object or i can change speed modifier values i pass as arguments when i create individual layer objects i'm getting a small stutter when the background image is reset back to position 0. i fix that by removing this else statement here now the reset should be smooth and not noticeable i can also use small values as speed modifiers i want the back layer to scroll very slowly if i use speed modifier 0.2 and base game speed is 1 that layer will scroll by 0.2 pixels per frame because we are multiplying game speed by speed modifier i will try 0.2 0.4 1 because layer 3 is this ground image so that it should scroll the same speed as the rest of the main game objects and layer 4 are these items in the foreground so i will make them scroll at 1.5 base game speed the issue we have right now is that layer 4 these foreground objects should be in front of the player but right now they are behind because in the main animation loop i'm drawing all four background layers before i draw the player there are multiple ways to solve this i'll use the simplest possible solution i will draw only layer 1 2 and 3 here as part of the background class and remove layer 4 to draw it separately later because i removed layer 4 from the array i need to call its update method first from inside update method on the main game class here on line 226 i'm calling background.update which updates layers 1 2 and 3 and i will also call update on layer 4 like this inside draw method we are redrawing all elements that make up our game for every animation frame first we draw the background which now contains only layer 1 2 and 3. then we draw the player on top of that then we draw ui then enemies and on top of everything we will draw background layer 4 to make it appear in front of all other game objects the thing to understand is that since we are drawing everything on the same canvas element what is drawn first will be drawn behind the thing that is drawn after background will be behind the player time to draw the player we start by bringing player image into the project here in index html i created this seahorse sprite sheet that you can download and use we will have basic swimming animation and we will have power up animation row because when the player collects a special overcharged fish it will absorb its energy the player's eyes and chest will light up and player will shoot two lasers instead of one in script.js i go to line 59 inside player class constructor and i bring the image into the project using getelementbyid same as we did with background images in style css i give player image display none we are bringing the image into javascript project here on line 59. inside the draw method currently we are drawing a black rectangle representing the player to draw the sprite sheet i will use built in canvas draw image method i pass it the image i want to draw so this dot image from line 59 and x and y coordinates where i want to draw it i want to draw it at player's current x and y position from lines 54 and 55. you can see we are drawing the entire sprite sheet with all its frames and rows draw image method can accept three arguments like this we can also give it five arguments by adding width and height in case of a sprite sheet like this it will just squeeze all frames into an area of one frame we don't really want that what we need is the longest version of draw image method that expects nine arguments and it gives us the most control over the image we want to draw on canvas those nine arguments are image we want to draw source x source y source width and source height of the area we want to crop out from the source image and destination x destination y destination with and destination height to specify where we want to draw that cropped out piece of image on destination canvas we will need some helper variables as well frame x will cycle through the sprite sheet horizontally frame y will determine row of the sprite sheet in this case row 0 or row 1. i need to crop out just one frame from the source sprite sheet image so source x will be frame x times width of a single frame which in our case is the width of player because i like to size my images to the same size we will draw them in game when frame x is 0 we display this frame when frame x is 1 1 times width of 120 pixels is 120 so we will draw this frame frame x 2 will be 2 x 120 so 240 pixels this frame and so on it will work the same with frame y vertically frame y times height of the player which is identical to the height of the sprite sheet frame source width is width of a single frame source height is height of a single frame now we are cropping out just one frame perfect i will animate the sprite sheet by cycling between frames horizontally from 0 to max frame in the case of player sprite sheet max frame is 37 we count from 0. i will handle sprite animation logic down here it's simple if frame x from line 56 is less than max frame from line 58 increase frame x by 1. else reset frame x back to zero if you prepare your sprite sheets well in graphics editor the way i prepared the sea horse for you you only need very little code to get the animation if i set frame y to 1 we will see the second row in the sprite sheet we will use that for power up state for now i set it back to 0. at this point i no longer need the black rectangle that represents the player but it is still useful to keep track of that area because it will be player's hitbox used for collision detection i replace fill rectangle with stroke rectangle i remove this fill style declaration stroke style will be black by default unless we set it to a different color i want to have a debug mode in my game when i press letter d the game will show hitboxes and maybe other things like enemy hit points player hitbox is this black rectangle we are outlining so i only want to draw that if game.debug is true i need to create that property so down here inside game class constructor i say this.debug is true the last thing i need is to create a switch that will allow the user to toggle debug mode on and off by pressing letter d to create a toggle with javascript is simple i go up inside our input handler class and inside key down event listener i create an else if statement and i check if the key that was pressed is letter d if it is i set the new debug property we just created on the game object to its opposite value so if it's true i set it to false if it's false i set it to true now when i play my game i can toggle debug mode on and off by pressing the letter d at this point debug mode only shows and hides player hitbox but we will attach more functionality to it a bit later nice we are making a lot of progress let's add more characters to the game the base game loop will have three enemy types i created multiple animations for each enemy type to give our game more variety and i will show you how easy it is to swap between them you can download all our datasets in the project files in the section below i made these characters spreadsheets for you so feel free to keep them for your personal projects you can modify them and do whatever you want with them you can credit me if you use it for your personal projects but only if you want also if you want the base photoshop files or separate pieces in png format for all these characters so that you can animate them and turn them into spreadsheets yourself let me know the best free software to create custom sprite animations is dragonbones if you want more advanced features there is also a paid software called spine you don't need any of that because i'm already giving you complete ready to use sprite sheets this is just for those of you who want to learn more and create custom animations or different animations than the ones i created for you so i'm bringing three new images into the project angular 1 will be the most basic anglerfish anime type the sprite sheet has multiple different animations for the same character model and we will use all of them in a minute the second character is a different type of angler fish with more gears and chimney these are steampunk machines that come to life i gave them a lot of mechanical parts these two anglerfish enemies will be just a simple basic enemy type that comes at the player trying to eat it they are not very resistant and they are easy to deal with using our seahorse sentinel lasers the only advantage they have is that they can come in big numbers sometimes to deal with that we have to be smart and use our slowly recharging ammo wisely we can use the third enemy type to help us i call this third enemy type luckyface because it will be an enemy but also a power up at the same time it will have two different models different skins that we will use randomly when we create a new one and the way we use this enemy type to make gameplay more interesting is that the player can do two things when this enemy appears we can shoot it for a lot of score points or we can collide with it to collect it as a power up it doesn't have many life so players also have to be careful not to destroy it accidentally before they can collect it and activate the power up the story is that this is an overcharged fish and when the sentinel sea horse collides with it it absorbs its light and power to activate its ultimate offensive mode for a short period of time it will all be represented by graphics to make it clear to the user what's happening so here is the parent anime class and here we have a child angle 1 class that extends it and inherits from it i will add this.image property and i point it towards the sprite sheet we just included in index.html like this we have three different animations that loop and when we create a new angular fish we will assign it one of these three randomly by setting this dot frame y property to a random number between zero or one or two so mass at random times three wrapped in math floor like this right now we have these small red rectangles representing each anglerfish enemy same as i did with player i replace fill rectangle with stroke rectangle and i remove this fill style declaration and also this one the draw enemy sprite sheet same as we did with player sprite sheet i use builtin canvas draw image method i pass it image i want to draw so this dot image from line 124 if i just pass it x and y coordinates it will draw the entire big sprite sheet with all frames and all rows i declare frame x that will help us to navigate in the spreadsheet horizontally frame y will navigate vertically max frame will be the maximum horizontal frame which is 37 for this particular sprite sheet i only want to draw enemy hitboxes when debug mode is active so this line will run only if this.game.debug is true i want to draw them at the original full size so i remove this temporary size modifier we created earlier if i pass a draw image method additional width and height we will squeeze all frames into an area of one frame so i will add four more to define an area i want to crop out same as we did with the player so source x source y source with and source height so image i want to draw four arguments for the area i want to crop out from the source image and four arguments for where to place that cropped out image on destination canvas source x will handle horizontal cycling through the sprite sheet and it will be frame x from line 106 times width from line 124. we keep width property on a subclass because it will be different for each enemy type source y will be frame y from 107 times height from line 125. source width will be this.wave source height is this.height i'm giving you sprite sheets that are already sized exactly as they will be drawn in the game so we don't have to do any scaling with code here it's simpler and it's more performance efficient to do it this way the sprite animation itself will be simply going between frame x0 and max frame over and over we will handle it here inside update method if frame x from 106 is less than max frame from line 108 increase frame x by one else reset frame x back to zero and we are animating our first enemy type the final game will be wider i just keep the game area smaller so that i can show you everything on one screen in style css i hide images with id angle 1 angle 2 and lucky i can set the game width to 700 pixels so that the large enemies fit better you can see that each enemy fish has been randomly assigned one of the three possible animations i prepared for you it gives our game a nice variety a needs to account for game scrolling speed when calculating anime positions so down here inside update method on enemy class i say this dot x plus equals this dot speed x minus this.game.speed this way we can have dynamic events that change game speed and enemies will always be correctly positioned in relation to our scrolling game world let's add the second type of angularfish i created for you i copy this child class that extends the parent enemy class and i call it angular 2. width of a single frame is 213 pixels and height is 165 pixels for this anime model i created two different animations so frame y can be row 0 or row 1. so now we have two different anime types i want to have a simple functionality where i say something like when you create a new enemy in the game in 50 of cases make that enemy angular 1 otherwise make it angular 2. we will handle that logic inside add nme method we will do it by rolling dice once every time we create a new enemy so helper variable i call randomize is math.random math at random declared like this will generate a random number between 0 and 1. if that random number is less than 0.5 create angular 1 enemy type else create angular 2. up here on line 249 i increase game limit to 15 seconds so we have some more time to test everything before game over is triggered immediately i can see the new angular 2 enemy type and i can see we are playing both animations perfect giving graphics like this for your game will go a long way to help you create unique stories and adventures for your players if you are interested how to take drawings of static characters and turn them into animated sprite sheets with free dragon bone software like i did with this seahorse and angular for this class let me know and i might make a course on that on enemy class i have this dot lives and this dot score properties i want each enemy to have different values here so i cut it here and i paste it on each enemy type individually angular 1 will have 2 lives and when we defeat it we will get 2 score points angle 2 will have 3 lives and it will give 3 score points quick test to see if everything works i can see enemy lives and it gives the correct amount of score points don't worry about the color of the numbers right now we will fix that later let's create a third enemy type i copy this code block and i will call this subclass luckyfish for example width will be 99 pixels and height 95. this fish will have three lives and if destroyed it will award 15 score points i will give it a property i call type and i will set it to lucky we will use this to check which enemy type player collided with down on line 314 inside add anime method i add another else if statement like this if random number is less than 0.3 we create angular 1 else if it's less than 0.6 we create angular 2. when the random value is between 0.6 and 1 we create luckyfish using the new class we just wrote there's something strange happening with the animation i go up to luckyfish class to see what's wrong i can see that on line 153 i need to point this dot image property to the correct sprite sheet and we are animating our special luckyfish powerup there are two models because the sprite sheet has two rows and we are randomizing vertical coordinate with frame y here on line 154 when the player collides with one of these special overcharged fish it enters a powerup mode let's write that code now we start by declaring this.powerup property on the player up here on line 65. initially i set it to false powerup will last for a while and then the player will go back to the normal state so we will need another timer we can use delta time for it we will have two helper variables called powerup timer and powerup limit powerup timer will be count in milliseconds when it reaches power up limit of 10 000 milliseconds 10 seconds powerup state will end we will handle that logic here in update method on player class i say if this dot power up from line 65 is true we enter this code block inside we check if powerup timer is more than powerup limit and if it is we set powerup timer back to 0 and power up to false we will also set player sprite sheet to frame y 0 so normal default animation else meaning power up is true and power up timer is not yet higher than power up limit the player is in power up mode and powerup timer is counted in milliseconds by adding delta time we calculated delta time before inside the main animation loop is the difference in milliseconds between timestamp from previous and the current loop we need to make sure update method expects delta time as an argument on line 69 and we pass it to this method inside update method on the main game class here on line 286 so we are counting timer and frame y is on the second row so value is one we come from zero that will give us a special animation with light coming from chest and eyes and also tail will animate differently because while in this state we will shoot two lasers one from the nose and one from the tail at the same time two lasers for the price of one ammo at the same time we will be recharging ammo by 0.1 per frame and this will be on top of the regular recharging speed so ammo will be recharging very fast while in power up mode so when powerup is set to true we enter this code block powerup timer is increasing by delta time counting how many milliseconds we are in powerup mode frame y is animating special overcharged animation and ammo is recharging fast as soon as power up timer increases over the value in power up limit which will happen after 10 seconds 10 000 milliseconds we set power up timer back to 0 we set power up to false and we set animation rule back to normal regular floating animation inside update method on game class in this area where we check for collision between player and enemies we check if type property on that enemy is set to lucky if it is we call a special method on the player object called enter powerup we will write it in a minute else if we collided with another anime that is not luckyfish we decrease score by 1 as a penalty to the player this will encourage player to collide with power up fish and avoid regular enemies to get maximum possible score i go up to player class here on line 111 i create that method so enter power up its job will be to set everything up when player enters power up state i could have used state design pattern but we don't have that many player states so we can do it simply like this when we enter power up we set power powerup timer back to zero in case we collided with powerupfish while we are already in powerup state this will make sure the time resets and we get full 10 seconds from that second collision we set powerup property on player object to true we will also recharge the ammo to its maximum possible value i test it i collide with our special overcharged fish and player gets overcharged we are in powerup mode and ammo is instantly refilled and it's recharging very fast perfect after 10 seconds power up ends ammo stops recharging because we are well over max ammo value and player sprite sheet switched to the basic floating animation great so when we are in powerup mode our sentinel seahorse will shoot defensive lasers from mouth and tail at the same time it's overflowing with energy and it can shoot extra free projectiles from tail every time it shoots one from the mouth we can handle that functionality with javascript very easily by declaring additional method i call should bottom in shoot top we handle shooting from the mouth and shoot bottom we will handle logic for tail lasers so inside i check if ammo is more than zero and we just push new projectile into projectiles array i adjust its horizontal and vertical starting position because i want it to be coming out from the tail i will call this method from inside shoot top like this while we are running the code in shoot top we check if we are in power up mode and if we are we execute shoot bottom method as well to add that extra free projectile i tested lasers are just coming out from sears's mouth in basic floating state if we collect the power up fish we enter power up mode and both should stop and shoot bottom methods are running we are shooting two projectiles but it costs only one ammo getting overcharged makes the player very powerful maybe we need some bigger bulkier enemies so we get more challenge i made two types of mechanical whales for player to defeat probably you will need these power apps to do so i want the projectiles to come from behind the player we are drawing projectiles inside a draw method on player class if i want them to be drawn behind i need to make sure we draw projectiles first and the player second like this i want to make it even more visually clear when powerup mode is active for example i can make this ammo display up here different color while in powerup we draw all these ui elements in our custom ui class on line 243 before i draw all these small rectangles representing ammo i check if power up property on player class is true if it is i set fill style to a different color i want that color to be similar to the glow effect we have on our sprite sheets so maybe this it works the problem is that it also recolors the timer text because we define fill style here we draw ammo and then we draw the timer i can keep drawing ammo at the same coordinates in our game and i can move this entire code block further down that way this white fill style will apply to timer and the other color will apply only to ammo like this instead of drawing a rectangle representing a laser projectile we can also use an image i bring it into the project here in props section in index html you can download it in the video description or you can use your own image i give it an id of projectile i bring it into the project here on line 38 inside projectile class constructor this dot image equals to document.getelementbyid and i use the id i just gave it so right now we are drawing yellow rectangles representing our projectiles i delete that and instead i will use draw image method this time it's simple because the image is already the right size i just give it three arguments the image i want to draw and x and y coordinates where to draw it on canvas nice we are drawing images these projectiles can also be animated either using a special sprite sheet or all different kinds of particle effects we will use sprite sheet to animate projectiles in a bonus section of this course let's add a web font to make the text look better adding a font to a canvas game is very simple i go to google phones and i search for bangers i like this comic book style when you have your font you click select your style here you can select multiple different fonts like this if you want then we go up here to view selected families if you choose more than one this code will be adjusted to contain all of them as part of a single declaration all we need to do to bring the font to our project is to copy these link tags and paste them up here in index html ideally above the main css style sheet to make sure the fonts are available from there as the code gets executed line by line from top to bottom i go back to google phone's website and here it also gives us a readymade css font family declaration i copy it and i put it inside our style css file here on canvas element now my font is available so i go to script js inside ui class i set this custom font family property we wrote before to bangers and now all the texts drawn by ui class so score timer and game over messages will use the new font let's adjust the winning text to something less boring i want to keep the victorian steampunk explorer theme going for this game so winning message will say most wonders in big letters and with an exclamation mark secondary smaller message will say well done explorer for the losing message let's use another old phrase i will say blazes with an exclamation mark it's a word for when something goes wrong in old english secondary small message will say get my repair kit and try again for example you can come up with your own messages here if you want now i have my messages in a new font so i can adjust the sizing and spacing i want the main message one to be much bigger i try 150 pixels well that's way too big we could also adjust the text size to match the width of canvas but let's keep it simple for now and set it to 100 pixels hm i think i will go with 70 pixels i want the messages to be closer together so instead of 40 pixels offset i tried 20 for both of them i'm happy with the spacing and font size for now i can see that we still have the projectile image visible in the top left corner of the browser window so install css i set it to display none we can also see the spacing of the losing message now looks good i would also like the little numbers above each enemy that represent their lives to be only visible when debug mode is active to do that i go up to enemy class and inside draw method i only want to call that fill text method if debug mode is active if debug property on the main game object is true let's test it yes i can only see hitboxes and enemy lives when in debug mode perfect i want to make sure that player cannot leave the screen right now if you press up or down arrow for long enough player will move completely off screen inside update method on player class we will handle vertical boundaries let's start with the bottom boundary if this dot y vertical position of the player is more than the height of the game minus the height of the player meaning that the bottom edge of the player is touching the bottom edge of the game area make sure we cannot move past this point like this i actually want the player to disappear halfway so that it can avoid very big dangerous enemies we will add soon i will do that by multiplying player height times 0.5 here and here now we can move half the sea horse's body outside the screen and then we hit the boundary we just defined i will do the same thing for the top boundary else if player's current vertical y coordinate is less than minus player height times 0.5 meaning that the top half of the seahorse is off screen make sure it cannot move any further up like this i test it top boundary works bottom boundary works perfect up on line 48 we have a particle class i will use it to create broken parts falling from enemies every time we hit them and for a big spray of spare parts when we completely destroy an enemy we will also make those parts bounce from the floor for a specific number of times before they fall off screen particle class constructor will need a reference to the main game object start in horizontal x coordinate and start in vertical y coordinate i convert those arguments into class properties as usual we will use a sprite sheet with nine images in a grid each particle object will randomly choose one of these images so that we have some variety this dot image is documented to the getelementbyid and id will be gears in index.html i bring it into the project here in the props section id is gears and file name is gears.png you can download it in the project section as usual install css i hide it by giving it display none here we are referencing that image with javascript i will need some helper variables to navigate around the sprite sheet each particle object each spare part flying from the enemy will have a random image assigned from these nine available options frame x will be a random number between 0 and 2 so column 0 or 1 or 2. frame y will be the same so row 0 or 1 or 2. combination of frame x and frame y value for each particle object will point to a specific image in the grid for example frame x2 frame y1 will be here sprite size will be the size of individual frame in this case frames are squares 50 x 50 pixels i want each particle to have a different size when drawn on canvas so we will create size modifier and we will set it to be a random number between 0.5 and 1. i will set it to one number after decimal point to reduce artifacts so particle size will be sprite size multiplied by size modifier to make sure every particle is a different random size when drawn on canvas i want particles to fall in both directions horizontally from the enemy so speed x will be a random number between 3 and plus 3. if it's minus it will move to the left if it's plus value it will move to the right on the positive direction on horizontal xaxis speed y vertical speed will be a random number between 0 and 15 so particles will always start moving upwards on the negative direction on the vertical yaxis before they start being pulled down towards the ground by gravity i set gravity to 0.5 let's see what kind of curved movement we get we can adjust it later marked for deletion will initially be false i want the corks wheels and spare parts to rotate as they fall so i will have an angle property storing rotation angle for each particle separately starting at 0 and the speed of that rotation will also be randomized in this dot va property velocity of angle rotation speed will be random value between minus 0.1 and plus 0.1 radians per animation frame in update method we will increase the rotation angle by va speed y will increase by gravity which will give it a nice curve let's say the particle will start moving upwards because starting speed y is 15 as we increase speed y by gravity from line 61 that 15 value goes closer to zero at that point when it reaches zero it will stop moving and it will be at its peak height as speed y further increases by gravity value into positive numbers it increases by 0.5 per animation frame that particle will start falling down faster and faster until it disappears below the bottom edge of canvas this dot x minus equals speed x to move particles horizontally this dot y plus equals speed y to actually apply that speed y value affected by gravity to the vertical coordinate of each particle if the particle fell off screen vertically so its y coordinate is more than game height plus size of the particle or if the game scrolled past the particle so its x position is less than zero minus particle size set its marked variation property to true draw method will take context as an argument we call draw image method pass it the image we want to draw and x y width and height where to draw it on canvas since the particle image is a grid of frames it's a sprite sheet we only want to crop out one individual frame for each particle object i will also need to specify cropping position so source x source y source width and source height source x is this dot frame x from 954 times this dot sprite size from line 56 source y is frame y times sprite size source width and source height will be this dot sprite size like this we want to crop out a frame 50 times 50 pixels from the source sprite sheet then we multiply that by size modifier and we draw it at that scaled size we will need an array that holds all active particle objects i will create it here as this.particles property on the main game object for each particle in that array we call their update method like this using es6 arrow function syntax to keep the code cleaner after that i call builtin filter method on that array and i replace that original array with a different one that contains only particles that have marked for deletion property set to false all the particles with marked for deletion properties set to true will be removed inside the draw method again we call for each on each particle object we call its draw method and we pass it context as an argument as it expects up here on line 73 we have our particle class ready we just need to find a good place in our code to add these particles i go down to update method on game class and here where we check for collisions between projectiles and enemies i create a for loop this for loop will run 10 times and each time it runs it takes this dot particles array and it will push new particle object inside i know that particle class constructor expects a reference to the main game object as the first argument so i pass it this because right now in our code we are inside that game object each particle also needs starting x and y coordinates so i pass it x and y of the enemy that just collided with the projectile i don't want the particles to come from the top left corner of each enemy i want them to come from the middle so i add enemy width times 0.5 horizontally and enemy height times 0.5 vertically i copy this for loop i actually want 10 particle spare parts to fall from the enemy when it collides with the player and gets destroyed down here i remove the for loop and just push one particle i test it nice we have a splash of spare parts coming out of anime when they are destroyed by colliding with the player player in this game is indestructible we will make that clear by giving it a special animated shield later in the bonus section i copy this code that adds just one particle and i actually want to put it here so that every time projectile collides with enemy one particle follows out nice so now every time enemy gets hit by a projectile one particle spare part falls if enemy is destroyed by colliding with the player 10 particles come out in all directions i want the particles to bounce off the floor for a specific number of times before they fall off screen to make this effect even more intense i go up to our particle class and here on line 65 i create a helper variable i call it bounced and initially i set it to false i also want to define a margin from the bottom end of canvas from which point the particles will bounce so i call it for example bottom bound boundary like this and i set it to 100 pixels if particle reaches this point i want it to bounce so i will switch its speed y value to its opposite if vertical position of the particle is more than game height minus bottom bound boundary so somewhere around this point and at the same time if this dot bounce from line 65 is false set bounced to true so that it doesn't bounce again after this and set speed y to its opposite value by multiplying it times 0.5 so particles fall in it reaches this point and its current speed is for example plus 5. we switch it to minus 2.5 making it bounce moving upwards again still line 70 keeps applying gravity so eventually we reach zero and go into positive numbers making the particle curve towards the ground again and eventually fall off screen it bounces once sets bounced to true so this if statement check will fail for the second bounce and particle will just fall off screen maybe i don't want particles to all bounce from the same vertical point on the ground how about they bounce from a range between this and this point roughly to match our ground level image so bottom bounds boundary will be a random value between 60 and 160 pixels from the bottom edge of canvas area what about if we want to specify how many times each spare part bounces from the ground rather than having them bounce just once line 65 i set the initial bounced property to zero in this check on line 74 i check if bounced is less than two and each time we bounce i increase bounced by 1 here on line 75. now each particle bounces twice before it falls off screen down here where we create particles i copy this for loop that creates 10 particles we create one particle when anime collides with the projectile i paste that for loop here to create 10 particles when enemy is destroyed by a projectile so particles will come out of enemies after three different events when enemy collides with the player and is destroyed we get 10 particles when projectile collides with an enemy we get one particle when enemy is destroyed by projectile we get 10 particles so we know how to create particles when certain events happen in our game we know how to bounce them off floor and we know how to control how many times they bounce we also have this angle property that is increasing by va on line 69. if you've never done rotation on canvas this part might be a little bit challenging but i will try to explain each particle has a different angle value that's increasing by va value that's also randomized for each particle object it means that at any point each particle is at a different rotation their angles have different values to make sure that rotation angle only affects one specific particle and doesn't spill out and affect other objects we draw on canvas i will wrap the entire drawing code between save and restore save method takes note of the current canvas state when we call restore later that restore will look for its associated save method and it will reset all canvas settings back to that point in time anything done between save and restore will just affect the code the drawing code in between after we call restore everything will be reset to its original state to rotate something on canvas we first have to move rotation center point the point that is normally considered coordinates 0 0 on canvas so the top left corner we have to translate that point over the object we are rotating so translate to the current x and y position of the particle calling translate like this moved rotation center point from top left corner to this dot x this dot y coordinates of this particle then we call built in rotate method that takes angle value in radians i pass it the angle property that is increasing for every animation frame by va here on line 69. not sure if you can see but particles are currently making very large circles around their x and y coordinates it is because we are going to another distance of x and y from these coordinates because of the fact that we translated point zero zero and rotation center point to these coordinates for all intents and purposes this dot x and this dot y between the save and restore in this area of our code is considered point zero zero on canvas and then i'm drawing this particle at this dot x this dot y from that translated point further and i'm rotating it making it go in larger circles around that center point i fix it by changing x and y to zero here because position of that particle is already defined on line 81 in translate call now the particles are rotating from their top left corner so i shift them a little bit by half of their width and half of their height to rotate around the center point of each particle i have other classes about rotation for now let's just move on if you don't fully understand some things about rotation don't worry it will become more clear as you use these techniques more often in the future we are getting a lot of particles now if you are on a very old computer you can reduce the amounts of particles to get better performance i don't have any performance issues on my computer let me know if it runs smoothly for you or if you had to decrease the number of particles to get a good frame rate the particles don't move correctly in relation to the ground artwork i need to go here and include the game's scrolling speed in the horizontal position calculation so this actually has to be plus yes now it works awesome time for a small cleanup first of all i want the debug mode to be disabled by default we can still press letter d on keyboard to toggle it on and off but when the game first loads i want player and enemy hitboxes and enemy lives to be hidden by default we have a bug in our game when the player collides with any enemy type it goes into a power up mode that would make the game too easy we only want the player to enter power up when it collides with power up fish and later in the bonus section there will be another way to enter power up for skilled and fast players who can shoot fast and big moonfish before it comes too close to make sure the power up works correctly i just need to fix this comparison operator on line 357 like this now our sentinel sea horse only enters power up if it collides with lucky fish another bug is when we enter power up player's ammo gets automatically assigned to max ammo this is meant to refill the ammo but if the player saved up and has current ammo higher than maximum ammo entering power up will actually reduce the total amount of ammo they have i fix it here on line 159 inside enter power up method on the player class we only refill ammo to max ammo if the current ammo is less than max ammo like this that works i'm using vs code editor when i press ctrl f i can look for all console logs i want to delete them let's keep our code and console clean particle spare parts falling from the enemies are not bouncing from the correct area i want the bounce area range to match the ground artwork a bit closer here on line 66 inside particle class constructor i set bottom bounds boundary to a range between 60 and 140 pixels i want to change the order in which we draw our game elements because we are drawing everything on a single canvas element the order in which we call draw methods will determine what is behind and what's on top i go down here inside the main draw method on game class and i want to draw the background first then ui elements so score ammo timer and game over messages then we draw player projectiles particles and enemies on top of that you can play with the draw order here if you want if you want ui to be on top of everything for example just draw it last i think it looks better like this because it's a bit 3d or 2 and a half d when it's slotted between the game world and game characters like this we can do many other things to make the ui feel like a part of the game world i have lots of ideas maybe in the next class i'll show you more game text can be floating moving changing colors it's easy to do it if you follow my other coding tutorials and you understand canvas animation well we have a power up mode so the game currently is very easy when we are in power up enemies have no chance let's add a massive enemy type that when defeated splits into five smaller enemies that should give the player some challenge hope you like teeth and tentacles it will also introduce some tactical decisions into the game maybe sometimes it's better to avoid the enemy altogether if we are low on ammo when we know we can't deal with the little enemies that come out of it when we destroy the big one i copy luckyfish class that extends the main parent enemy class and i rename that copy hive whale this is a massive mechanical whale that serves the enemy swarm as a hive vessel containing a lot of aggressive and fast drones width is 400 pixels and height is 227 pixels this dot image will be looking for an id of hive whale i need to go to index.html to bring that spreadsheet into the project you can download it in the project files section i made just one animation row for this anime type it's a lot of work animating all these tentacles and creating this sprite sheet and also it's already a big image file image with an id of hive whale and source is assets slash hive whale png in style css i give that image display none frame y will be zero because this sprite sheet only has one animation row it will have 15 lives it can take a lot of damage when defeated it will give player 15 score points type is hive like this and it will move very slow so here i will override the default speed x property from the parent enemy class and i set it to a random number between minus 0.2 and minus 1.4 pixels per frame i want the enemies to be spread a bit more down not all the way to the bottom of the game area but maybe 95 percent of the game height i do it by replacing this vertical position calculation on angular 1 angular 2 luckyfish and hive whale with 0.95 position where enemies can spawn in the game can be anywhere between 0 and 95 percent of game height we need this extra space there are some large enemies incoming we add hive whale into the project down here inside add enemy method on the main game class i copy this line and i say if randomize is between 0.6 and 0.8 add new hive whale enemy type and here they come i can enable debug mode by pressing letter d to see its massive hitbox and its current lives we need to hit the whale with 15 projectiles to destroy it but that's not all when destroyed 5 smaller fast and aggressive drones come out of it and they will go straight for our sentinel seahorse character let's create that enemy type drones are small fast and aggressive creatures they live inside hive wells where they collect resources and feed on whatever the hive will swallows let's make sure that sentinel seahorse is not their next meal i copy this code block and i will name it drone this enemy type is different they are ambush predators and they always hide inside the hive whale ready to jump out and attack their prey they will not be coming at player from the right side of the screen like the other enemy types do we will only see them when we destroy a hive whale for that reason when we create a new drone using this class we need to pass a game object as usual but also we need to pass it the current x and y position it will be the current position of the hive while we just destroyed i convert x and y into class properties as we always do image will be looking for an element with an id of a drone i bring it into the project here in index html id is a drone source is assets drone png i created two different animation rows each one will be moving differently so we get some variety frame y will be a random number either row 0 or row 1. each drone will have 3 lives and will award player with 3 score points if destroyed i will give it type drone i'm not sure if i will use this type property for something but might as well declare it we might need it later this enemy can move very fast if it wants to it will have a random speed range from a minus 0.5 to minus 4.7 pixels per frame the way i want this to work is when we destroy hive whale with projectiles it will spawn 5 drones in star css i give the drone image display none if the hive whale gets destroyed by colliding with the player there will be no drones because the drones would spawn too close to the player and there will be no time to try and aim and target them properly it would not be a good gameplay experience having enemies spawn so close to the player if projectile collides with an enemy and if lives of that enemy are less or equal to zero that enemy is destroyed we check if the enemy that was just destroyed has type property set to hive if it is a hive whale we take enemies array and push one new drone enemy object inside if you remember drone class expects game and x and y position were to appear in the game world i want it to appear under the destroyed hive whale so i pass it x and y of that destroyed enemy let's test it i destroy a hive whale and we have one drone coming out of it nice let's put this code into a for loop that runs five times to create five drones we have five drones but they all appear on top of each other in the top left corner of the hive whale that's not ideal let's spread them around a bit starting position of the drone will be horizontal exposition of the hive whale that was just destroyed plus a random number between zero and the width of the hive whale enemy starting vertical position of each drone will be vertical y position of the hive well plus a random number between zero and height of the hive whale like this maybe just height times 0.5 nice now the drones are more spread out some move very fast some move slower this is good we get too many particles i don't want each drone to burst into 10 particles when destroyed what if we make the number of particles spare parts that fall from enemies when destroyed to be equal to the score that enemy gives i also make the same change here on line 383 when enemies get destroyed by colliding with the player now hive whale should burst into 15 particles because when defeated it gives 15 score points each drone will turn into three spare parts that way we won't get a massive flood of 50 cogs and wheels when we destroy 5 drones i want the game to feel good when we score some points and destroy an enemy i want that enemy to really pop so not only we will turn it into spare parts that bounce around we will also play a dust or fire explosion from a sprite sheet i have two special sprite sheets for this purpose you can take them and use them in your other projects as well if you want many games need dust and fire effects like this all art assets for this episode were custom made by me or artists i hired so there is no copyright you can use them however you want enjoy we will have the parent explosion class and we will extend it into two child classes dust explosion and fire explosion parent explosion class will contain methods and properties shared for all explosion types it will expect game x and y as arguments because i want the animation to play over the enemy that was just destroyed so that x and y position will be passed from the outside each time we create a new explosion object both fire and smoke explosion will be single row sprite sheets i could also have placed them into a single image we will cover compact sprite sheet animation in later class not today i will cycle through them from left to right from frame x0 to max frame sprite height is the height of a single animation frame in the sprite sheet and it will be the same for both explosion types i made both sprite sheets the same height of 200 pixels so that property can be on the parent class it's a property shared between all explosion types sprite with the width of a single animation frame in the sprite sheet will be different for each type because of that it will sit on each subclass separately we will define that in a minute the sprite sheets have only 8 frames so they will animate very fast i want us to be able to control fps frames per second on this animation and i want that fps to be independent of animation speed of the rest of the game we will do that using delta time again and we will need 2 helper variables timer that will count from 0 adding delta time over and over until it reaches interval value when we reach it we will serve the next animation frame in the sprite sheet interval will be 1000 milliseconds 1 second divided by 15 so the animation will run at 15 fps i can also put frames per second in a separate property if i want to we can control fps by adjusting that property instead marked for deletion will be initially set to false as usual we will need update method and it will expect delta time value as an argument we calculate delta time in the main animation loop draw method will expect context as an argument to specify which canvas element we want to draw on update method will simply animate the sprite sheet by increasing frame x property from line 302 draw method will draw currently active animation frame cropped out from the sprite sheet let's start by just giving it image we want to draw and x and y coordinates where to draw it so this is the parent explosion class it contains properties and methods shared between all explosion types we will have two child classes smoke explosion and fire explosion i say class smoke explosion extends explosion that extends keyword creates a relationship between these two classes and it sets up prototypebased inheritance behind the scenes for us smoke explosion subclass now has access to properties and methods that sit on explosion super class we will also have fire explosion subclass constructor will expect game and x and y coordinates in index html i bring the sprite sheets into the project here in the props section ids will be smoke explosion and fire explosion install css we give both of them display none i point the subclass towards that image using getelementbyid i'm placing this.image property on the subclass because that image is specific only for this subclass parent superclass contains only properties and methods that are shared between all subclasses sprite width the width of a single frame will be 200 pixels both sprite sheets have 8 frames so max frame will be 8. rectangles on canvas are drawn from the top left corner i want the explosion animation rectangle to be coming from the exact center of the anime rectangle i can do it like this i'm going to give it width and height property and i set it to be equal to sprite with and sprite height i take x and y properties from the parent class and i place them on the child class once we have a width property here i offset x position by half of its width moving its center point to the middle of the image horizontally i will also move the vertical y position into the middle of the image vertically like this down here inside game class constructor i create an array that will hold all currently active explosion objects inside update method same as we do for particles i will call for each and for each explosion object in explosions array i call its update method we will also use filter method to remove all explosion objects that have marked for deletion properties set to true inside the draw method i call for each on each explosion object again and i draw them passing it context notice i draw explosions after i draw enemies so they will be drawn on top of enemies the order in which we call draw methods here matters we will have two different explosion types so same as we did with adding different types of enemies to the game on the main game class i define a custom method i call add explosion we will have a variable that will randomize a number between 0 and 1 like this if that random number is less than 1 for now take this explosions array and push new smoke explosion inside i pass it game so this keyword it will also need a position so we will take it from the anime we just collided with we will add a reference pointing to that entire enemy object here as an argument x and y of this explosion will be x and y properties from that enemy object that is passed here let's try to add it into the game and see what we've got so far up here on line 419 we check if player collided with an enemy that enemy will be destroyed and we want to animate an explosion at that position so i will call this dot at explosion like this i pass it the enemy player just collided with and destroyed as an argument i also want the explosion animation to play when we destroy enemy with projectiles so here we check if projectile collided with an enemy if that enemy's lives are less or equal to zero it will be destroyed and we animate a splash of spare parts we set marked for deletion on that animator true and we will add explosion here as well like this i test it and we are getting no explosion animations i don't see any console errors let's debug it by console login explosions array from inside add explosions method every time we add one we consolidate the entire array i can see that add explosion method runs and creates the console log for us but the array remains empty let's see what i did wrong probably i made a typo somewhere oh i see this if statement never runs because there is no this.randomized property easy fix we need to refer to this temporary helper variable like this now i'm getting a console error which is better because this error will guide us to where the problem is the error says we must call constructor in derived class before accessing this now i know the problem is inside smoke explosion class constructor this is a socalled derived class when i create a new smoke explosion object i want the parent class constructor to run first creating properties and values shared for all child classes and then i want to add this little bit of code that's specific only for smoke explosion class to do that i have to call the parent class constructor using a special super keyword i know that parent class constructor expects game x and y so i pass these arguments along it's a good lesson for me to remember on a child class we must always call super class constructor before using this keyword otherwise we will get a reference error now when i create a new smoke explosion we create one new blank object this constructor will run first creating these properties and then these properties will be added on top of that smoke explosion will also have access to update and draw methods because of the inheritance that was set up behind the scenes by the special extents keyword we used we fixed all the bugs and typos when i test it i can see that everything works and we are adding smoke explosion into the explosions array and we are drawing the entire sprite sheet at that position perfect let's clean it up and make it into a proper sprite animation now this dust cloud is a sprite sheet we are drawing it using builtin draw image method on line 312. as we already did multiple times in this class we know that to animate a sprite sheet we need to crop out individual frames and swap through them one by one we do it by passing draw image method nine arguments image we want to draw source x source y source width and source height to specify area we want to crop out we want to crop out one sprite sheet frame at a time and destination x destination y destination with and destination height to tell javascript where we want to draw that cropped out image on destination canvas we already have the values for destination we just need to specify the crop area source x will be frame x from line 300 times sprite width from line 320. source y will always be 0 because this sprite sheet has only one row of frames width of the cropped area will be sprite width height will be sprite height so now because frame x times sprite width determines horizontal cropping coordinate as we increase frame x inside update method the frames will cycle and animate now it works but the animation is coming from the top left corner of each enemy and it plays very fast also we are not removing all the explosion objects that already animated and we have an ever increasing array i will check if frame x is more than max frame and if it is i know that entire animation played at that point it's safe to set marked for deletion property to true and that explosion object will be removed by filter method we already defined earlier in the browser console i can see that the old explosion objects are being correctly removed nice i want the animation to run at 15 frames per second i do it by creating a periodic event again timer will be counting from 0 to the value of milliseconds defined in interval whenever it reaches that value it will trigger next frame in the sprite sheet and resets back to 0 so that it can count again so if this dot timer from line 303 is more than this slot interval from line 304 increase frame x by one else keep increasing timer by delta time accumulating milliseconds until it reaches the interval this will serve only the first frame is because after timer reaches interval it needs to be reset back to zero so that it can count again for the next animation frame it still doesn't work i can see that update method expects delta time as an argument to be used to increase timer value online 313. i have a feeling i'm not passing it that value when i call it i go down to line 422 and i pass update method on explosion object delta time now we are animating the explosions at 15 frames per second structuring your code like this will allow you to set different fps for different objects in your game in this case we did it because player and enemy sprite sheets are optimized for high frame rate but explosion animation has only 8 frames so it looks better if we stagger the animation speed if you want to turn this into a mobile game you would have to do this for all objects player and enemies you would have to delete some frames and stagger their animation because current mobile phones will struggle to surf sprite sheets with so many frames we are using for our characters if you want lower frame rate spreadsheets for these characters let me know i can easily make them for you the explosions are animated in the top left corner of each enemy i want them to be in the middle so i adjust the initial x coordinate we pass it by half of enemy wave and the vertical coordinate will be adjusted by a half of enemy height like this this looks good i'm noticing that we are not showing the first animation frame of our smoke explosion sprite sheet it's because we first call the update method that increases frame x by 1 and then we draw it i can fix it by calling draw first and then i call update like this now we can see the first sprite frame as well and it stays long enough so we can actually notice it nice let's delete this console log we don't need it anymore i can change the animation speed of dust clouds by changing the value here in fps property when i set it to a very low value like 5 frames per second it becomes obvious that they are not being correctly placed within the game world they are static but they should be scrolling along with the game world for the positioning to look right i fix it by accounting for the current game speed in their horizontal coordinate calculation like this now they scroll with the game world and it looks as it should i think a good fps for the sprite sheet is around 30 frames per second yes i'm happy with this for now let's create a fire explosion this time it will be very simple i copy all the code inside the constructor into the other child class image will have id of fire explosion like this i actually decided to refactor the fire sprite sheet and now both smoke and fire sprite sheets have frames 200 times 200 pixels in that case i can remove sprite with on child class and i can place it on the parent explosion class because now it's shared for both explosion types in that case i can actually take all these properties and add them on the parent class as well i remove them here since they will be automatically inherited nice that's cleaner so only the images are specific for each class all other properties and methods will be shared and inherited from the parent class down here inside add explosion method i say if randomize is less than 0.5 create smoke explosion else careful about the brackets and syntax here else create fire explosion nice work now sometimes we get a fire effect sometimes we get a smoke effect inside game class constructor i adjust time limit to 30 seconds winning score will be 100 so the player needs to get at least 100 score points in 30 seconds to see the winning message i set ammo interval to 350 milliseconds so that ammo recharges a bit faster and i set enemy interval to 2 seconds let's test it we have a bug i got a winning message and there were some leftover enemies and colliding with them reduced my score below 100 and losing message was displayed instead i need to make sure that after the winning or losing message appears colliding with enemies doesn't affect the score i do it here online 437 only decrease score when we collide with an enemy if game over is false let's tune the game into a more playable and challenging state i make heath whale less likely to appear in our game and luckyfish more likely like this i give hive whale 20 lives luckyfish will have five lives angler two will have six lives angular one will have five lives for example i said game with 2000 pixels this will make the game easier as we can see enemies coming sooner and we can plan and manage our moves and ammo better i try to play to get a better idea of how much score i can get in 30 seconds okay the game ended because we reached winning score 100 in 25.1 seconds let's set winning score to 80. i can strategize now i can see there is a lucky fish come in that will replenish my ammo so i will use as much as my ammo as possible before i get the refill now i get a refill and i can go crazy with my lasers i will be careful not to hit the lucky fish coming at the bottom so that i can collect it and make my power up state longer okay it took 24 seconds to get the score over 80. game has a time limit of 30 000 milliseconds 30 seconds if the game runs for that amount of time it will end we need to get enough score points in that time period this is just my choice you don't have to do this but i want the game to always run for 30 seconds i don't want it to end as soon as we get over the winning score so i will comment out line 456 game will only end when time limit is over 30 seconds and based on how much score we managed to get we will see a winning or losing message there is an element of luck in the game we designed because it is very dependent on which type of enemy spawns if we get just lucky fish and hive wales we will get a lot of score points fast if we get only anglers it will be very hard to win the game i gave you all the tools and techniques you need to understand you can now adjust the game time enemy health and winning score yourself to make the game as easy or as difficult as you want it to be the game runs well on my gaming pc but if you have a chromebook or some very old laptop you might be experiencing performance issues i focused this class mostly on handling graphics and animation there is a whole other set of optimizations we can do to make this run even on the oldest machines but that's beyond the scope of this class notable optimizations would be for example to draw on multiple canvas elements and only clear parts of canvas that actually update it object pooling technique would also have a massive positive effect on the performance it means that we create a pool of particle and projectile objects and we just reuse them over and over rather than creating new ones and discarding them after one use for this project the quick changes you can make to improve performance would be to increase enemy interval property to make enemies spawn slower if your computer is not keeping up you can also remove all shadow properties inside ui class canvas shadows are still not well supported and optimized in some browsers especially in firefox we can reduce the number of particle spare parts that fall from enemies when damaged and we can also make sure they only bounce off the floor once or that they don't bounce at all if you are still getting performance issues you can also merge all background layers into one image and just animate that one layer that will increase performance massively same goes for our sprite sheets i gave you sprite sheets with 37 animation frames which looks really good and smooth in motion but if you struggle to get 60 fps reducing the number of frames and have each animation to be just around 15 frames let's say and staggering animation speed with delta time like we did with animated explosions would make the performance better as well i will probably release a version of sprite sheets with lower frame rate for each character so you don't have to do it manually yourself bonus extended lesson where i add more enemy types animated projectiles shield and simple sound design is linked in the video description but feel free to play with the code and add your own features with the techniques we learned today let me know if you finish this project by typing i did it in the comments if you want more vanilla javascript game dev come and build this game with me i will show you how to use state design pattern for more complex player controls and movement and how to split our code into individual modules click like please i'll see you there
