With timestamps:

00:00 - this comprehensive C course will take
00:02 - you from the basics of C programming to
00:04 - advanced concepts all while integrating
00:07 - exciting mini projects to solidify your
00:09 - learning this course offers a structured
00:12 - path through essential topics such as
00:14 - syntax object oriented programming data
00:16 - structures and more ABA teaches this
00:19 - course and he will help you understand C
00:21 - both theoretically and also gain
00:24 - practical experience in applying your
00:25 - knowledge to real world scenarios hey
00:28 - there free Corum ABA here join me in
00:30 - Walking you through everything you need
00:32 - to get a setup with cop let's have a
00:34 - quick walk through the course contents
00:35 - to let you know what to install for you
00:37 - we'll start with installing the visual
00:38 - studio program required to develop cop
00:40 - applications you'll learn about data
00:42 - types including integers strings and
00:44 - many more and how to manipulate them
00:46 - inside your code next we'll dive into
00:48 - control flow you'll discover how to use
00:50 - conditional statements and Loops to
00:51 - control the flow of your program's
00:53 - execution strings are essential in many
00:55 - applications you'll Master powerful
00:57 - string functions in C allowing you to
00:59 - manipulate and transform Text
01:01 - effortlessly data structures are crucial
01:03 - for organizing and managing data from
01:05 - arrays to collections you'll explore
01:07 - various data structures in C and learn
01:09 - how to use them effectively functions
01:11 - are the backbone of any program you'll
01:13 - uncover the power of functions in C
01:15 - including how to create and call them to
01:17 - organize your code no program is immune
01:19 - to errors you'll learn how to handle
01:21 - exceptions gracefully in C ensuring that
01:23 - your applications remain robust and
01:25 - reliable debugging is a crucial skill
01:27 - for any developer you'll discover how to
01:29 - use visual Studio's powerful debugging
01:31 - tools to identify and fix bugs in your C
01:34 - code efficiently finally we'll delve
01:36 - into objectoriented programming you'll
01:38 - learn the principles of object-oriented
01:40 - programming how to use classes objects
01:42 - inheritance and polymorphism to create
01:44 - modular and maintainable code by the end
01:46 - of this course you'll have a solid
01:48 - understanding of C programming and be
01:50 - well equipped to tackle a wide range of
01:52 - software development challenges thanks
01:54 - for tuning in let's get
01:56 - started so in order to start developing
01:58 - with C we need to install install the
02:00 - latest version of visual studio in this
02:01 - case it's currently 2022 so let's head
02:04 - over Google and type in Visual Studio
02:06 - 2022 download we will be presented with
02:08 - two links we have this one and this one
02:11 - we want to use a second one which says
02:12 - download visual studio tools so if you
02:14 - press on that and now we present it with
02:16 - the download area we have three
02:18 - additions Community professional
02:20 - Enterprise Community is free for
02:22 - students open source contributors and
02:24 - individuals which is exactly what we
02:25 - need for the content of this course we
02:27 - have the professional Enterprise Edition
02:29 - which paed for and only used by bigger
02:31 - companies or smaller teams so let's go
02:33 - ahead and press free download the
02:35 - download will start straight
02:37 - away after the download is complete
02:39 - let's start the installer so double
02:41 - click on the executable and press yes to
02:43 - allow it for admin permissions it'll pop
02:45 - up like this Visual Studio installer
02:47 - before you get started we need to set up
02:48 - a few things you can configure your
02:50 - installation you can read the privacy
02:52 - policy in the software terms if you'd
02:53 - like or you can just press continue so
02:55 - it's getting the visual studio installed
02:58 - already so so when you get to this
03:00 - section everything here is all the
03:01 - different packages and tools you can
03:03 - install within Visual Studio 2022 the
03:06 - main one that we're concerned within the
03:07 - content to this cause is the neck
03:09 - desktop environment so you can go ahead
03:11 - and press this one it will then tell you
03:13 - in the bottom right hand corner the
03:14 - total space required is 6.52 GB please
03:18 - make sure you have enough storage space
03:20 - available for this and then you can go
03:21 - ahead and press install if you want to
03:23 - check out other packages you can have a
03:24 - scroll through and read any other
03:26 - packages you may need and may want to
03:28 - install like I said the the only one
03:30 - required for this course is the net
03:31 - desktop environment you can also deal
03:34 - with noj development python development
03:36 - web
03:36 - development if you need to deal with
03:38 - individual components like specific
03:40 - versions you can access it here if you
03:42 - need some more languages installed you
03:44 - can access it here this should
03:45 - automatically select your default
03:47 - language for you that's based on your
03:48 - systems language and if you want it to
03:51 - you can also change the installation
03:52 - location in case you want to install it
03:54 - on a different drive or you just want it
03:56 - in a different folder so now that we
03:58 - selected the neck desktop environment
03:59 - ment we can go ahead and press the
04:01 - installation button we do have two
04:03 - options down here we have it install
04:05 - while downloading and it download all
04:06 - then install if you have a reasonably
04:09 - fast computer you can stick with the
04:10 - install while downloading and it will do
04:12 - the installation and the downloading at
04:14 - the same time if you have a slow
04:16 - computer it's preferred that you use
04:17 - this option to download it first and
04:19 - then install it just means that it won't
04:21 - slow down your computer too much so you
04:23 - can go for this one and press install
04:26 - now the installation will begin so now
04:28 - that visual studi finish installing it
04:30 - will say done installing Visual Studio
04:32 - has been successfully installed we
04:34 - recommend rebooting soon to clean up any
04:36 - remaining files so this just means
04:37 - restart on your computer just so it has
04:39 - a chance to clean up any files that were
04:40 - kept during the installation process so
04:43 - we can just press okay if you have any
04:45 - other versions of Visual Studio
04:47 - installed they'll also show up down here
04:49 - now that Visual Studio Community 2022 is
04:51 - installed we can just press
04:55 - launch so now it'll prompt you to sign
04:57 - into Visual Studio we should definitely
04:59 - sign in but just for now I'm going to
05:00 - skip but feel free to create an account
05:02 - or sign in if you already have one
05:04 - existing we can skip this and then we
05:06 - get to choose your theme I personally
05:08 - prefer the Dark theme but you can go
05:09 - with blue blue extra contrast or the
05:11 - light mode so let's select dark and hit
05:13 - start Visual Studio it will do a first
05:16 - time
05:17 - setup and it's already done and we're
05:19 - already inside Visual Studio 2022 so
05:22 - that's it for the visual studio
05:25 - installation so now that we got Visual
05:27 - Studio 2022 installed let's let's see
05:29 - how to create your first project so once
05:31 - you've opened Visual Studio 2022 you'll
05:33 - see this window popping up you can clone
05:35 - a repository from things like GI Hub in
05:37 - as you devops or open a project that you
05:39 - already have or open a folder which may
05:42 - have projects inside or you can create
05:43 - one from scratch if you don't want to do
05:45 - any of these options you can just open
05:47 - the visual studio program just on its
05:49 - own by clicking continue without code so
05:51 - let's go down the create a project path
05:53 - so click on create a new project and
05:54 - we'll get a list of all these different
05:56 - projects inside our system to be able to
05:58 - use the ones we going to be focusing on
06:00 - on this course is going to be C in the
06:02 - languages dropdown box and the platform
06:04 - is going to be windows and the project
06:06 - type is going to be console and they
06:09 - have one that uses net core which is for
06:11 - Linux Mac and windows and one that uses
06:12 - the Net Framework which is Windows so we
06:15 - want to go for this one so press on this
06:17 - one and then press
06:18 - next here we have our project name our
06:21 - location and our console app so we can
06:23 - start with the project name and say my
06:26 - first
06:27 - project as you can see it start copying
06:30 - over to the solution name as well and it
06:31 - tells you where the project will be
06:33 - created into so I'll be creating a
06:34 - folder called my first project which is
06:37 - the solution name plus my first project
06:39 - which is the project name inside that
06:41 - folder if we change the solution name
06:43 - you'll see update you can see here now
06:45 - we have multiple T's because we appended
06:47 - the solution name the solution name is
06:49 - almost like a folder that holds lots of
06:51 - projects inside so to begin with we'll
06:53 - have one solution that has one project
06:56 - inside and then later on in the course
06:57 - if you feel like you want to add more
06:59 - project projects to it you can just add
07:00 - more to this solution so let's get
07:02 - started and press
07:08 - create so now we've created our very
07:10 - first project and just to explain what's
07:12 - here we have a static main void which is
07:15 - the main entry point to our program if
07:17 - you do a lowercase M then the system is
07:19 - not going to recognize this main
07:21 - function because the down NET Framework
07:23 - requires this function to be found in
07:24 - order to run a c console app and you can
07:27 - see here in the errors the program does
07:29 - not contain a static main function and
07:32 - you can see it's capital M and C
07:34 - programming language is K sensitive so
07:36 - make sure to include it so now you
07:38 - understand how to use Visual Studio 2022
07:40 - to create a project and also know where
07:41 - the main entry point is in C let's get
07:44 - started with Hello World example to kick
07:46 - off this
07:48 - course so as we know our main entry
07:50 - point to our application is the static
07:52 - void main if we go inside here and press
07:54 - enter then we can actually start writing
07:56 - some code inside here just a quick note
07:59 - before we
08:00 - continue static void main is inside the
08:03 - class program and the class program is
08:06 - inside the namespace hello world and the
08:08 - reason why you can tell this is because
08:10 - of the curly braces the curly braces of
08:12 - hello world begins here and ends here
08:15 - and Within These curly braces we have a
08:17 - class program and also within the class
08:19 - program we have the styo
08:22 - men so just between these curly braces
08:25 - we want to type console. right line open
08:29 - the brackets and we can type in some
08:31 - speech marks and we can simply Type
08:33 - Hello
08:34 - World there you go so as you can see now
08:37 - system has actually been highlighted so
08:40 - if we just delete this
08:42 - line you can see now system has been gr
08:44 - out and the reason why is it says it's
08:46 - unnecessary because it hasn't been
08:50 - used so if you undo it then this comes
08:55 - up because I showed you before that
08:57 - console right line is actually within
08:59 - the system Library what happens if we
09:01 - delete
09:02 - it if we delete it then it doesn't know
09:05 - where console exists from and because
09:07 - that just said system we can actually
09:09 - just use system. console. right line and
09:12 - then open the brackets and type in hello
09:14 - world and now this works again and the
09:17 - reason why this works it's because we
09:19 - don't have to Define that we're using
09:21 - system we could just use it straight in
09:24 - here if you have multiple lines like
09:27 - this then you don't want to be using
09:28 - syst right at the start ideally you want
09:31 - to have the reference to it at the top
09:32 - of the screen and then use it
09:35 - throughout so now that we've included
09:37 - back in the project you can see that now
09:39 - these have turned gray and it says that
09:41 - it can be simplified if we press the
09:43 - light bulb and we can say simplify
09:45 - member and it doesn't really matter
09:47 - because we can just delete the rest now
09:50 - so now that we've WR hello world let's
09:51 - press F5 which is a shortcut to the
09:53 - start
09:55 - button as you can see well you couldn't
09:58 - really see because the program closed
09:59 - too quickly and the reason for that is
10:02 - printed hello world to the console and
10:04 - then it didn't do anything else CU
10:05 - there's nothing else for it to do so the
10:07 - console simply
10:08 - closed we can use another command called
10:12 - console read Line open the brackets and
10:14 - close the brackets and have a semicolon
10:16 - at the end all this does is it waits
10:18 - here until the user inputs something
10:21 - reads the next line of characters from
10:22 - the standard input
10:25 - stream so although the program will
10:27 - actually be reading stuff we you just
10:29 - want this line to stop the application
10:31 - from closing so now if you press F5 and
10:33 - run the program you can see it actually
10:35 - says hello world and it's just waiting
10:37 - here
10:38 - flushing and this flashing means it just
10:41 - started this console read line so it
10:42 - doesn't matter what we type into here it
10:44 - just waits for us to press enter and as
10:46 - soon as we press enter this line
10:48 - executes and the program finishes
10:50 - congratulations you just wrote your
10:52 - first C program welcome to the amazing
10:55 - journey of
10:56 - programming so let's look at how to make
10:59 - variables in our C codee let's start
11:01 - every code with a console read line and
11:04 - then we can hit F5 just to make sure our
11:06 - console doesn't
11:07 - close so let's begin with an integer so
11:11 - integers are whole numbers so we can
11:13 - just say int age equals
11:15 - 23 so what we've actually done here is
11:18 - we've said we want an INT we want to
11:20 - call it age already made it equal to
11:24 - 23 this is called initializing and
11:27 - declaring in the same line line so what
11:30 - you could do alternatively is you can
11:31 - end the semicolon here and it just says
11:33 - int Edge and then on the next line you
11:36 - can write ede equals 23 so this is
11:39 - declaring it in the first line and then
11:40 - give it an initial value in the second
11:42 - line if they're right underneath each
11:44 - other like this case then you may as
11:46 - well just make it together because then
11:48 - you have less lines of code the reason
11:49 - why it says it's a green under line it's
11:51 - because there the unnecessary assignment
11:53 - because we're not actually using age so
11:55 - let's just print ede to the console if
11:57 - we make some new lines and we can type
11:59 - in console. right line and then press
12:01 - tab to finish it we can write Edge and
12:04 - if we run our code using F5 we can see
12:07 - that 23 gets print out to the
12:09 - screen so now that we've worked on the
12:11 - Edge Let's explore all data types so
12:14 - let's define a long variable so let's
12:15 - start with the type long followed by
12:18 - space and then the variable name that we
12:19 - want and let's add equals and type in a
12:22 - very big
12:23 - number so now if we hover over it it
12:25 - says it's a system int32 and int32 2 is
12:29 - actually an integer but we're telling it
12:31 - it's a long which makes no sense we have
12:34 - an in 64 here but when we hover over the
12:36 - number it comes up as
12:38 - n32 and the reason for that is when C
12:41 - sees that you just have a number typed
12:43 - in like this it will always assume that
12:45 - it is an integer to tell the compiler
12:48 - that you indeed want this to be
12:49 - processed as a long number then you can
12:51 - put a capital l right at the end now if
12:54 - we hover over it it says
12:56 - N64 and this says in 64 so so now we've
12:59 - got it working and we've got the long
13:01 - there so now we can take another console
13:03 - right line and just print this out to
13:04 - the screen and just a helpful tip if you
13:06 - type in CW and press tab twice then you
13:09 - get the console right line it's very
13:11 - easy to write your code and then you can
13:13 - type in big Follow by a tab and it'll
13:15 - come up straight away so as you can see
13:17 - they're both being printed to the
13:18 - console
13:19 - now so now that we've made positive
13:21 - numbers we can also make these negative
13:24 - by simply just putting a negative sign
13:26 - behind them there we go and just to show
13:29 - you how big these numbers are what we
13:31 - can do we can type in int. max value and
13:34 - then make another one using contr D and
13:36 - type an int. Min
13:38 - value so you can see integers can be
13:41 - positive 2.1 billion or negative - 2.1
13:46 - billion and if we do the same for
13:52 - long you can see that long is a very
13:55 - very big number because instead of being
13:56 - an INT 32 it's an int64 which takes up a
13:59 - lot more memory so now we've covered
14:02 - whole numbers let's have a look at
14:04 - decimals so we can have a double
14:07 - negative for example and we can say it's
14:09 - minus
14:10 - 55.2 and in this case when you just have
14:13 - a number typed in like this and it's got
14:15 - a decimal point in it it will always
14:17 - register it as a double but just to make
14:20 - sure just as we're doing with the long
14:22 - you can actually just put a capital D at
14:24 - the
14:25 - end now if we print this out to the
14:27 - screen and also print out how big these
14:30 - numbers can
14:31 - be max value and Min value and print
14:36 - this out so we get our minus 55.2 and
14:39 - you can see that these numbers can be
14:40 - very big e + 308 means it's this number
14:45 - times by 10 to the^ of 308 which is a
14:48 - very big number and we also have that as
14:51 - a negative so we have float let's call
14:53 - this precision and make equal
14:57 - 5.1 and then put a semic call at the end
15:00 - now we've got a problem here this is
15:01 - trying to register as a double but we
15:03 - don't want to register double we want to
15:05 - register as a float and this is the same
15:07 - issue we have the long so when you type
15:09 - any number that has a decimal point in
15:11 - it the C compiler will always register
15:13 - as a double the same way when you type
15:15 - in a whole number it'll always register
15:17 - as an INT so in this case we need to put
15:20 - a capital f at the end and it'll process
15:22 - this as a
15:24 - Flo so now we can print this
15:27 - out and then let's just print out the
15:29 - max values and the Min values just to
15:33 - show you what that looks
15:34 - like so as you can see here we have our
15:36 - number printed out and again we have
15:38 - quite a big number 3.4 * 10 to the^ of
15:42 - 38 so again it's a big number and we
15:44 - have that positive and negative so quite
15:46 - a big range of
15:48 - numbers and the last one we're going to
15:50 - cover is decimal for things like money
15:53 - and currency
15:55 - 14.99 and again in this case it's trying
15:58 - to assign a double into a decimal so in
16:01 - order to denote what a decimal is you
16:03 - can put a capital M right at the
16:05 - end and for one last time let's print
16:08 - out the
16:09 - money and the decimal. max value contrl
16:13 - D and then we'll do Min
16:17 - value and you can see here that this is
16:19 - a really big number as well and it's
16:21 - even bigger than the
16:23 - long so we have our number printed and
16:25 - the Max and the minimum values so now
16:27 - that we've understood that how to
16:29 - declare a variable I have an extra
16:31 - little tip for you so if we had three
16:33 - variables int X and int Y and in in Z
16:38 - and let's say you're always going to
16:39 - declare them together like this you can
16:41 - actually miss out and do X comma y comma
16:44 - Z and that will do exactly the same
16:47 - thing there you go and that's really
16:50 - neat and it's a lot better let's say for
16:52 - example you had these variables but you
16:55 - actually had them set to something like
16:56 - equals 10 = 20 = 30 this is still
17:02 - practical but it might look a little
17:04 - uglier so you can actually type them in
17:06 - straight into here and if you comment
17:09 - these out again then it still works you
17:12 - can even put these onto new lines like
17:13 - this just so it looks a bit neater just
17:16 - prevent you from typing the additional
17:18 - int each time if they're all going to be
17:20 - the same variable type so that's it for
17:22 - the numbers inside our code so let's
17:24 - just have a quick recap so in order to
17:27 - Define a variable you want use the data
17:29 - type in this case an integer followed by
17:32 - the variable name and then you can
17:33 - either add a semicolon at that point or
17:36 - you can add a equals to give it a value
17:38 - this is just called declaring a value
17:40 - and this is called initializing a value
17:43 - if you want to decide you want to change
17:44 - the variable further down your program
17:47 - for example age equals 50 here then this
17:50 - is fine and this is now called an
17:53 - assignment it's called initialization
17:56 - because as soon as you make it you give
17:57 - it a value value and then in later on in
18:00 - the code if you give it another value
18:02 - this is called simply assigning a value
18:04 - this is just called assigning it a
18:08 - value so now that we can store numbers
18:10 - in C let's see how we can store
18:12 - characters and letters so as you know
18:15 - from the introduction we have a string
18:16 - variable so let's call that name and
18:19 - make it equal to
18:20 - Aba please note that when you're
18:22 - defining a string and giving it a value
18:25 - that this value needs to be in speech
18:28 - mark if you put it in quotation marks it
18:30 - will not accept this because that's the
18:32 - notation to declare a Char which we'll
18:35 - get on to next so on the next line we
18:37 - can do a Char letter equals and we can't
18:40 - have something like this because the
18:42 - Char will only accept One Singular
18:44 - character so we have to wrap it around
18:46 - the quotation mark once you've wrapped
18:49 - it around the quotation mark then it
18:50 - will accept it so let's print these two
18:52 - to the screen so CW tab tab and we can
18:56 - just print these to the screen and if we
18:58 - just run the code you can see that we've
19:00 - got the values entered in
19:03 - here we can start to write
19:05 - stuff your name
19:08 - is and then we can output this and we
19:11 - can also put it on one
19:13 - line if we do a console right and a
19:16 - console right then maybe we can take the
19:18 - callon off and just have it space and we
19:20 - can say your name is ABBA and we've seen
19:22 - that additional a because that's the
19:24 - right line for the letter so we can
19:26 - space it out with an empty conso right
19:28 - line and they'll add a gap between them
19:30 - both there we
19:32 - go so now we know how to declare a
19:34 - string variable and give it a value and
19:36 - we can declare a Char variable and also
19:38 - give it a value just a quick recap when
19:41 - you're declaring and initializing string
19:43 - variables you need to put the value in
19:45 - speech marks but when you're declaring
19:47 - and initializing a Char you don't have
19:49 - to put it in speech marks you put them
19:50 - in apostrophes whenever you see
19:52 - apostrophes that that can only ever
19:53 - refer to One Singular character when you
19:55 - see a speech mark it could be one or
19:57 - more characters also things can be empty
20:01 - this just means the string is empty this
20:03 - is also a valid character it just means
20:05 - that we're storing a string but it has
20:07 - no value with a Char that's not exactly
20:09 - the same you can't store an empty
20:11 - character literal it has to be given
20:13 - something Charles get defaulted at back
20:15 - sl0 which is just a default character
20:18 - but don't worry about that too much now
20:20 - we'll go into Escape characters which is
20:21 - the back SL later on in the course for
20:23 - now just knowe that whenever you declare
20:25 - a string variable we need to put it in
20:27 - the speech marks and when we're
20:28 - declaring a Char variable we need the
20:30 - quotation
20:32 - mark So now that we know how to define
20:34 - numbers in C and to also Define strings
20:37 - and characters then let's look at how to
20:39 - convert between them both so let's take
20:41 - some similar code from our first video
20:43 - and we can Define it age the number the
20:45 - negative the Precision and the money and
20:47 - we give it the same values from the
20:49 - first video we simply just print them
20:51 - out to the console here and if we just
20:53 - run we can see them all but this doesn't
20:55 - help us cuz we're just statically typing
20:57 - in the numbers what if these were
20:58 - actually processed as string and we want
21:00 - to convert them into an INT so just
21:02 - above each of the variables we're going
21:04 - to make another variable so we can say a
21:06 - string text age equals
21:08 - -23 and then for the age what we're
21:11 - going to use is this function called
21:12 - convert to in32 and we can put in the
21:16 - string inside the brackets and what this
21:18 - is now saying is we're taking our string
21:21 - text Edge which is equal to -23 and
21:24 - we're passing it into this function
21:25 - convert to in32 and the reason why in32
21:29 - is because an INT is by definition an
21:31 - in32 which is a 32bit signed integer so
21:35 - what we want to do here is convert for
21:37 - our text age into an int32 and store it
21:41 - back into our int and hopefully we
21:43 - should see the same value when we hit
21:46 - run 23 so now that's actually went from
21:49 - a string variable and then went into our
21:52 - integer and we've printed out as an
21:54 - integer and it's no longer a string
21:56 - variable now we can do the same for the
21:58 - other ones so we can have a string text
22:01 - big number and make it equal to this
22:04 - value just in the quotation
22:07 - marks now we're typing this value in the
22:09 - quotation marks we don't need to put the
22:11 - L at the end the L is just to tell the
22:13 - compiler that we want to use N64 if we
22:15 - take the L away then it's going to think
22:17 - it wants in32 this is not re applicable
22:20 - when it comes to text because we're
22:21 - going to explicitly stay on the next
22:23 - line we want to convert to N64 so the
22:26 - compiler already knows that it's in 64
22:28 - and we don't need to put an L at the end
22:30 - now let's make sure this works and there
22:32 - we go so what we should end up with is
22:35 - the console should look exactly the same
22:37 - as how we had it at the start of the
22:38 - video but actually what we're doing is
22:40 - converting it from a string into the
22:42 - applicable value
22:44 - string text negative = -
22:49 - 55.2 and then in here we can do convert
22:53 - to double add the text negative inside
22:56 - here and let's just run it to check and
22:59 - we still have the same value so it's
23:01 - going well okay a string text
23:07 - Precision make it equal to
23:10 - this and then instead of this we can
23:13 - have a convert to and in this case it's
23:16 - actually going to be a single and the
23:18 - reason why it's a single when you hover
23:20 - of a float the definition for a float is
23:22 - indeed a single so we can add that in
23:25 - text precision and we're just going to
23:27 - do the last one just check it all
23:28 - together text money equals
23:33 - 14.99 and then instead of this we can
23:35 - have a
23:36 - convert and let's have a look at this a
23:38 - decimal is indeed a decimal so we can
23:40 - say two decimal and then add the text
23:43 - money
23:43 - in perfect now if you run the line of
23:46 - code we can see that all of these values
23:48 - are exactly as we had them now they're
23:50 - being represented by their official
23:52 - descriptions Based On A String
23:54 - conversion as I mentioned before in the
23:56 - error video the problem you'll have with
23:58 - this is if this value actually has a
24:00 - character inside you will get a runtime
24:03 - error this can be fixed in the future
24:05 - when we look at how to resolve these
24:07 - errors and we can have exception
24:09 - handling and use functions like trass so
24:12 - we can try and avoid these exceptions
24:14 - occurring because when these exceptions
24:16 - occur the rest of our code does not run
24:18 - and it becomes fatal at this
24:20 - point but for now don't worry about this
24:22 - too much just get used to the notation
24:25 - and how these things
24:26 - work so this video we're going to focus
24:29 - on the booing data type so we can make a
24:31 - Boolean data type by saying Bo value
24:34 - equals
24:36 - true this Boolean value is literally
24:38 - just a true or false value we can store
24:41 - anything in here and maybe something
24:42 - like bull is male and we can just say it
24:45 - true and later on our code booleans are
24:47 - used to make decisions we'll cover this
24:50 - in the next section of this course but
24:52 - boings are mainly used for making
24:54 - decisions if one thing is equal to
24:56 - another thing then we can take another
24:58 - path or if something is true or
24:59 - something is false then we can do
25:01 - another path for example if you make an
25:03 - output to the user you could check if
25:05 - this value is true and if the value is
25:07 - true then you can address the user as a
25:09 - male and if the value is false then you
25:11 - can address the user as a female these
25:13 - are the kind of things that booleans can
25:15 - help us with and just like any variable
25:17 - if you want to assign it later on you
25:18 - can just assign it again and if we print
25:20 - these out to the
25:24 - screen just like that you'll just see
25:26 - the value is true and the values false
25:28 - appear on the screen as of right now in
25:30 - the course there's not a whole lot to do
25:32 - with booing just understand that they
25:33 - can hold a true or false
25:36 - value so now that we know how to define
25:38 - different variables and how to convert
25:40 - between them let's see how we can
25:42 - perform operations on different data
25:44 - types let's say we could have an INT age
25:47 - equals 23 and then what we can do to
25:49 - that age is we can say Age ++ and what
25:53 - this age will do is it will actually
25:54 - just increment age by one and if we do
25:57 - age minus minus it will decrement it by
25:59 - one so if we just print it out after and
26:01 - after this as well what we'll notice is
26:03 - there'll be no change CU it'll go
26:05 - forward one and then back one there we
26:07 - go went from 23 plus plus to 24 and then
26:10 - minus minus to
26:12 - 23 that's one of the important operators
26:15 - that you'll see a lot especially during
26:17 - the next section of this course so
26:19 - another way to be able to add one to a
26:21 - variable or anything to a variable we
26:23 - can replace this with age equals age + 1
26:28 - and what we're seeing here we want age
26:30 - to have the value of itself added to one
26:34 - which will give us the same result is
26:35 - doing h++ another way of writing this is
26:38 - a quick shorthand is you can say age
26:41 - plus equals 1 these three things are
26:44 - doing exactly the same thing when you do
26:46 - an age Plus+ you can only increment by
26:49 - one and only one these two options give
26:52 - you the flexibility of having something
26:54 - like 10 these two are doing exactly the
26:56 - same age equals age + 10 and this is
27:00 - going to read exactly the same thing
27:01 - it's is when you use plus equals it will
27:04 - take the value of the current variable
27:06 - and add it to 10 which exactly what this
27:08 - line does to make it a lot shorter you
27:10 - can use age plus equals and then just
27:12 - put the value at the end just in case
27:14 - you forget to mention age twice so now
27:16 - if we just get rid of these two lines of
27:18 - code and we can just have a look and see
27:20 - if this runs so now the value should be
27:22 - 33 perfect and now as we said we're
27:25 - going to cover plus minus times and
27:28 - divide so just as you did with plus
27:31 - equals you can actually do a minus
27:32 - equals as well which will give us 13 and
27:35 - you can do a times equals which should
27:37 - give us
27:39 - 230 now if we try to do divide equals
27:42 - we're going to run into an
27:43 - issue it says
27:46 - 2 23 / 10 is
27:50 - 2.3 and when you take 2.3 and make it
27:53 - into an integer it's just going to
27:55 - truncate the3 and leave you with two
27:58 - with integers if you add two integers or
28:00 - take away two integers or times them
28:02 - you'll always end up with an integer if
28:05 - you divide two integers you don't know
28:07 - what you'll end with for example if you
28:09 - make this into 20 then you'll always end
28:11 - up with two but that's not always the
28:13 - case as you just saw 23 / 10 is 2.3 so
28:17 - if you're ever going to do any division
28:19 - it's best to actually make this a double
28:22 - cuz now that we do the division we
28:23 - actually get 2.3 which is technically
28:25 - the right value so you can add minus
28:28 - times and divide any variables that you
28:30 - want these are just demonstrated in int
28:32 - and double but you can do this the Flor
28:34 - the decimal Etc so let's have a look and
28:36 - see what the plus and the minus
28:37 - operators do when you've got a string
28:39 - variable so we can have a string name
28:41 - equals
28:43 - abber and then we can say the name plus
28:48 - equals is
28:51 - programming and then we can just print
28:53 - out name to the screen and see what
28:54 - happens so there you go you've actually
28:56 - just joined two strings together they're
28:58 - completely separate from each other and
28:59 - we've made them string
29:03 - together so if we try to do a minus
29:05 - equals you can't really remove from a
29:07 - string because a string is just text
29:09 - it'll be very difficult for the compiler
29:11 - and for the C language to be able to
29:13 - determine what's currently in the string
29:15 - and whether you can remove it or not
29:17 - this is not something that's built into
29:18 - the language this is not something
29:20 - that's built into the language so let's
29:22 - remove that and we can have the same
29:23 - thing with the
29:26 - TR now the problem with the Char is if
29:29 - we add a to B then let's see what
29:31 - happens to the
29:36 - output what it will try and do is
29:38 - actually get the uni code values for
29:40 - both of these items and try and add them
29:43 - together as integer
29:45 - variables so when you add a and b it
29:48 - will take the unic code value and you
29:49 - will actually get a capital A with a
29:51 - squiggle at the top and if we open
29:53 - character map you can see that this
29:54 - squiggle at the top is right here here
29:57 - which is unic codee 61 and 61 actually
30:00 - means 97 because it's 6 * by 16 + the 1
30:05 - and b means it's 6 * 16 which is 96 +
30:08 - the 2 so you have 97 and 98 and if you
30:12 - add them two values together you'll get
30:14 - the hex code which is C3 just for this
30:17 - character so what you're doing is you're
30:18 - kind of adding them both together and
30:20 - you're producing weird results so unless
30:23 - you really want to do this then you
30:24 - should be worried about adding two
30:26 - characters together
30:28 - one more thing to note about when you're
30:29 - doing Plus+ let's bring another int
30:32 - variable we just say int I equal Z then
30:35 - we can do i++ and then if we print out I
30:38 - the value should be one which is fine
30:41 - what if we did
30:44 - i++ but we did Plus+ I so the value is
30:47 - still going to be one but what happens
30:49 - if we put this i+ plus straight into
30:52 - these brackets let's try and run it and
30:54 - you'll still get the value is zero
30:57 - that's strange because we've said I ++
31:00 - and what happens when you do Plus+ at
31:01 - the front it will actually execute this
31:04 - and return the value of I and then do
31:07 - the Plus+ so if you actually print the
31:09 - value of I after you'll realize that now
31:12 - it becomes one after if you have had a
31:15 - situation where you need to increment
31:17 - first and then use the value you can use
31:19 - plus plus I now if you run it you should
31:22 - see the value is one twice the
31:24 - difference is that as the plus pluses
31:26 - before the VAR aable name it tells the
31:28 - compiler please do this action first and
31:31 - then return back the I if you don't want
31:33 - that behavior then use
31:37 - i++ finding the remainder between the
31:39 - division of two integer variables can be
31:41 - very handy when you're determining
31:43 - whether a number is even or odd let's
31:45 - look at an example let's have it in
31:48 - first Nome design the value of 10 and in
31:51 - second n and give it the value of three
31:53 - now if we just printed the screen first
31:55 - n divided by second n what do you think
31:57 - you'll get so the value of this in the
31:59 - calculator would be 3.3 reoccurring so
32:02 - we'd actually just get three because
32:04 - it's truncating it because of the
32:08 - integer so now what happens if we need
32:10 - the remainder between both of these you
32:12 - could actually work this out by seeing
32:14 - how many times three would be divided by
32:16 - 10 as close as possible and you'll see
32:19 - is the value is three and then 3 * 3 is
32:22 - 9 which will give you one left over for
32:24 - the 10 but that's a bit too long in our
32:27 - code so we have something called a
32:28 - modulus operator so we can actually
32:31 - change this divide for a percentage sign
32:34 - and what this will outut is it will only
32:35 - give us the remainder so let's say 10 /
32:39 - 3 is
32:42 - 3.3 as we've just said but the remainder
32:45 - is different remainder is exactly how
32:46 - you learned it at
32:48 - school 10 / 3 is actually three
32:52 - remainder 1 because 3 * 3 is 9 and then
32:56 - you have one left over to get to 10 so
32:59 - that'll be 3 * 3 which is equal to 9 and
33:02 - then one left over to get to 10 so now
33:05 - let's run our code and see if we do
33:07 - actually get one there we go so the best
33:10 - way to determine if a value is actually
33:13 - odd or even is to divide it by two so we
33:16 - can say 10 modulus 2 and if the value is
33:21 - zero then that means the value for first
33:23 - num is actually even if the value is one
33:27 - one then it's odd let's see how this
33:29 - works out if we had 10 modulus 2 then
33:32 - the value is zero because 10 can be
33:34 - divisible by two perfectly let's say we
33:37 - had 11 modulus 2 the closest multiple to
33:41 - 11 is 10 which is five and then we have
33:44 - one left over so you just have the
33:47 - remainder is equal to one and if we just
33:50 - keep going up in the chain we'll realize
33:51 - that it's the same pattern every single
33:54 - time you go up a value the value just
33:56 - toggles
33:59 - so when we print this out to the console
34:01 - and the value is actually zero that
34:03 - means the number is even and if we make
34:06 - the number odd on purpose and then rerun
34:08 - the code you can see that it's a number
34:10 - one now which means this value is now
34:12 - odd so let's look at a couple of
34:14 - examples and see if you can figure out
34:15 - the answer if we do a th000 modulus 90
34:20 - what do you think the value will be and
34:22 - let's write a couple more if we do 100
34:24 - modulus 90 and maybe something like like
34:27 - 71 modulus 10 so have a think about this
34:30 - in your head and see if you can figure
34:32 - out the answers pause the video and see
34:34 - if you were
34:35 - correct let's take a look at the
34:38 - answers so we can see we have 10 10 and
34:41 - 1 so the closest multiple to 1,000 from
34:44 - 90 is
34:45 - 990 so we have 10 left over to get to
34:49 - 1,000 and the same goes here the closest
34:51 - multiple of 100 to 90 is just indeed 90
34:55 - so we only have 10 to get from 90 to 100
34:58 - and in this case the closest multiple of
35:00 - 71 to 10 is 70 and we have one to get up
35:04 - to 71 therefore these two answers are
35:06 - indeed
35:08 - correct so now that we know how to
35:10 - really Define a variable by specifying
35:12 - that type followed by the name and given
35:14 - it a value let's see how we can do a
35:16 - very easy way of defining a variable so
35:19 - normally we would type in Edge but we
35:21 - can use this VAR keyword and what this
35:24 - means is the compiler will figure out
35:25 - what type it needs to be based on the
35:27 - value we initialize it with so if we
35:30 - just make a variable called age then
35:32 - it's not going to like it because you
35:33 - need to give it a value this doesn't
35:35 - give the compiler enough information to
35:37 - figure out what this variable is going
35:39 - to be just because it says age this is
35:41 - just text to the compiler this does not
35:43 - mean anything so if you make it equal to
35:45 - 23 then the compiler can see that this
35:48 - is indeed int 32 because it knows that
35:51 - so now if you hover over VAR it says
35:54 - in32 now let's try and do this for the
35:57 - big
35:58 - number our big number equals
36:02 - 90,000 and what will happen now is
36:05 - because it's defined as in32 it's going
36:07 - to say this is in32 as well and this is
36:10 - the same issue we had we'll move first
36:11 - def finding the long variable in the
36:13 - first video we need to explicitly give
36:15 - it an L just so this knows that it's N64
36:18 - and now the VAR has updated to an in
36:21 - 64 instead of rewriting each one we can
36:24 - just change each to V and inspect what
36:26 - happens double double and now we have a
36:30 - float single single and finally the
36:34 - decimal we have a decimal and we have a
36:36 - decimal and the same thing goes for a
36:38 - string we can say V name equals ABA and
36:42 - we can have a v letter equals a there we
36:45 - go and they'll both register as there
36:47 - pickable data types as a string and as a
36:50 - CH and if we just print this out to the
36:53 - screen to make sure everything's working
36:54 - fine and run the code you can see that
36:57 - everything is exactly how we'd expect so
37:00 - just a quick recap you don't have to do
37:02 - this at the end of the day this will be
37:03 - exactly the same as writing this because
37:06 - when our code gets compiled down it
37:07 - doesn't matter what these things are cuz
37:09 - the compiler will deal with it however
37:11 - way it wants to this is just for us to
37:13 - read it in some cases if the value is
37:15 - very obvious like as we know an age
37:18 - cannot really be a point 23.1 years old
37:21 - no one says that in real life when you
37:23 - get asked your age so we can just assume
37:25 - that this value is going to be an
37:27 - integer and that's fine because that's
37:29 - an easy number that's an easy example
37:32 - but if we say we want a negative or a
37:34 - big number then it doesn't really tell
37:36 - us what we're meant to be like this big
37:38 - number could be somewhere up to 2.1
37:40 - billion which is what an integer
37:42 - supports but in this case if it's going
37:44 - to be a big number and we specified the
37:46 - L then we're going to need a really big
37:48 - number bigger than 2.1 billion so in my
37:51 - honest opinion it would be very
37:52 - beneficial to only use VAR if it's very
37:55 - obvious what the variable is going to be
37:57 - and what it's been assigned to using VAR
37:59 - too much might hurt the readability of
38:01 - your code in the future because you have
38:04 - to inspect each variable individually to
38:06 - read what the type is going to be if
38:08 - you're scrolling through your code and
38:09 - you can see that this is along very
38:11 - quickly and you don't have to hover over
38:13 - it then it can improve your read time
38:15 - this is really important as readability
38:17 - of code will make more sense when it
38:18 - comes to Big projects when you have 20
38:20 - 30 lines just like this project then it
38:22 - makes almost no difference cuz it only
38:24 - takes a couple of seconds when you have
38:26 - big functions and big software when you
38:28 - work at a job then it's going to be very
38:31 - difficult to be able to find your way
38:32 - around and to understand what's going on
38:34 - especially if you're new to the code
38:37 - something very simple like this where
38:38 - you know you're defining a name it's
38:40 - very obvious and V will be accepted fine
38:43 - because you can tell that this is always
38:44 - going to be a string there's no other
38:46 - data type in C gets specified by a
38:49 - speech mark whereas when you're defining
38:51 - numbers it can be very very hard to
38:53 - understand what different data types
38:55 - that people are using throughout the
38:57 - code especially when these numbers are
38:59 - not statically typed in they might be
39:01 - inputs from the console from the user
39:03 - from a different function from anywhere
39:05 - so having good variable names along with
39:08 - their explicit types will be very handy
39:10 - to understand code in the
39:13 - future so now that you've understood how
39:15 - to make a variable let's look at a
39:17 - concept called constants so we defined a
39:19 - variable called vat and we set it to 20
39:22 - just to represent the 20% vat in the UK
39:25 - now later on in the program we can
39:27 - actually change it to anything we want
39:29 - and that's because it's a variable
39:30 - variables can change in certain
39:32 - circumstances like vat you might not
39:34 - want to change it and you want to
39:35 - disable the ability to change it to out
39:37 - the code if it's done accidentally let's
39:39 - say for example you're making a banking
39:41 - application and you want to fix the vat
39:43 - and you don't want anyone else to change
39:45 - it you can add this keyword called const
39:48 - right before the Declaration and now
39:49 - when you go to reassign it you'll get an
39:51 - error message and it says at the left
39:53 - hand side of the assignment so anything
39:55 - before the equal sign has to be a
39:57 - variable property or indexer and in this
39:59 - case if you hover over vat it states
40:02 - that it's a local constant local because
40:04 - there's no access modifier before it and
40:06 - constant because we specified the cons
40:08 - keyword so now if we try and run the
40:10 - code we'll actually get a compile error
40:12 - because the vat cannot be changed so if
40:15 - we remove that and then we just print
40:17 - out to the console using CW tab tab and
40:19 - then we can put V8 in the brackets and
40:21 - press F5 and now we can see our 20 being
40:25 - printed
40:27 - so let's try and calculate some values
40:29 - using this code if you have an in
40:32 - Balance make it equal to 1,000 and let's
40:35 - say we wanted to calculate the vat based
40:37 - off this then you'd have to do a little
40:39 - bit of a complicated calculation you
40:41 - have to take the balance and because the
40:42 - V is a percentage we need to convert it
40:45 - from decimal to percentage so if we do
40:47 - times and then open the parentheses we
40:49 - can insert
40:51 - vat divided by 800 and just to make sure
40:55 - that this gets processed as double we
40:57 - want to write 100 D cuz right now it's
40:59 - in 32 and if we leave this as an integer
41:01 - division then we'll lose any decimal
41:03 - places and decimal places are very
41:05 - important when it comes to percentages
41:07 - so we put a 100 D at the end now you can
41:09 - see it says double so it'll actually
41:11 - calculate as if it was a decimal number
41:13 - so now if we print that to the screen so
41:15 - we can see here that 20% of the balance
41:18 - is indeed 200 instead of having to do
41:21 - this calculation each time what we can
41:23 - actually do is make another const this
41:26 - I'm making it a double cuz we're not
41:27 - sure what the output of this division
41:29 - will be and we don't want to truncate it
41:31 - so we want it as a double and we can say
41:33 - percent
41:34 - vat and what we can do here when we
41:36 - assign the value just because it's a
41:38 - constant it means that we can't change
41:40 - the value but that also means we can
41:42 - read it as many times as we want so we
41:44 - can say the percentage V is actually the
41:47 - current V that we've got specified here
41:50 - ided
41:52 - 100d this will give us the vat from a
41:55 - number form into a decimal form so now
41:58 - when we do this calculation if we
42:00 - duplicate this line using contrl D we
42:02 - can remove these entire brackets and
42:03 - literally replace it with percentage vat
42:06 - and you should see we get the same
42:07 - values
42:09 - perfect this can be very helpful in the
42:11 - future if you have things like version
42:13 - numbers in your code you can have
42:15 - version 1.0 and then if you ever specify
42:18 - this version later on in your code you
42:20 - can just change it once up here and it
42:22 - will change the rest this can be very
42:24 - helpful you'll avoid a lot of typ and
42:26 - you won't have to redeclare this value
42:28 - several times if you had three different
42:30 - occasions where you displaying the
42:32 - version number in your code then it's
42:33 - going to be problematic once you update
42:35 - the version number and you have to
42:36 - change every single occurrence and you
42:38 - might miss them so inserting it once and
42:40 - only having to change it once is the
42:42 - preferred option just to note with
42:44 - constants when you compile your code all
42:46 - the constants will actually do is do a
42:49 - find and replace so it will take this
42:50 - vat and find all references of vat and
42:54 - just drop the 20 in there
42:57 - so this is more of a feature for
42:58 - maintaining your code from a user and
43:00 - programmer's perspective rather than
43:02 - anything to do with the compiler because
43:04 - when it compiles it just removes all the
43:06 - constant anywhere and then you're left
43:07 - over with the literal values that we've
43:09 - gave it nonetheless this is still
43:11 - something very handy to learn and to use
43:13 - throughout your
43:15 - code first you want to Define a variable
43:17 - to hold your name so we can just say
43:20 - string name equals abber perfect so
43:23 - that's the first one achieved says
43:25 - Define a VAR able to hold your phone
43:27 - number so at first this could be quite
43:29 - easy we could say int number equals and
43:32 - then we can start to type our number in
43:34 - here so now that's our number completed
43:36 - let's move on to holding your age and we
43:38 - can just have an INT age equals
43:41 - 23 print variables line by line to the
43:44 - screen so we can use CW tab tab and type
43:46 - in name and then we can use contrl D to
43:49 - copy and paste the line then we can do
43:51 - number crl D again and then we can use
43:53 - Edge now if we run the code let's see
43:55 - what
43:57 - happens here we've actually hit a slight
44:00 - problem it says 1 2 3 4 for the number
44:03 - but I'm pretty sure that I started off
44:04 - with zero this is a problem with storing
44:07 - your number as an integer as a number
44:09 - zeros at the front don't really matter
44:11 - if we had 100 zeros here then it's not
44:14 - going to change the actual value the
44:16 - only time zeros matter is if it's
44:18 - throughout the number or towards the end
44:21 - that actually changes the number but if
44:23 - we have lots of zeros at the start then
44:24 - it doesn't change anything
44:26 - so what you actually want to do in order
44:28 - to store a number is you want to store
44:29 - it as a
44:31 - string therefore when you run the code
44:33 - it will actually return the zero that we
44:35 - typed in so now that we've accomplished
44:37 - all of these let's see how we can Define
44:39 - the variables using the VAR keyword so
44:41 - if we hover over these you can see that
44:43 - it's picking up that it's a string and a
44:45 - string here and finally this is an
44:48 - integer so what we can do very simply is
44:51 - just change these to VAR and then let's
44:52 - hover over the variables and just see if
44:55 - the tool tip reads the the correct data
44:56 - type string string and integer and if
45:00 - you run the code you should see no
45:05 - difference so in this exercise I want
45:07 - you to create and initialize two integer
45:10 - variables make a variable to work out
45:12 - the remainder output the remainder to
45:14 - the screen and then change the first
45:16 - integer variable to another number
45:18 - recalculate the remainder and output the
45:20 - new remainer to the screen so let's take
45:22 - this step by step so first we need to
45:25 - create an ize two ins let's say int num
45:28 - 1 equals to 10 int num 2 equals to two
45:33 - make a variable to work out the
45:34 - remainder so we can have an INT
45:36 - remainder equals to and if you remember
45:39 - how to do the remainder it uses the
45:41 - modulus symbol which is the percentage
45:43 - sign so we can say num one percentage
45:46 - num
45:48 - two now it says output remainder to the
45:50 - screen so we can use CW tabtab add
45:53 - remainder in and hit run and just for
45:56 - now we can see that the remainder is
45:58 - indeed zero if the remainder is zero
46:01 - then that means 10 is even because 10
46:03 - modulous 2 gives us zero and if it's
46:06 - zero then that means it's even if the
46:08 - remainder was one then it would mean
46:11 - it's odd so if we try 11 remainder two
46:13 - we get one so 11 is indeed an odd number
46:17 - so let's change this back to 10 and then
46:19 - it says change the first inter variable
46:21 - to another number so just after here we
46:23 - could say num one equal 11 and then
46:27 - recalculate the remainder so we
46:29 - essentially just need to do this section
46:31 - again and we don't need to write into
46:33 - before these two variables cuz int is
46:35 - only used when you're declaring it this
46:37 - is reassigning the
46:39 - variable so we reassign variable num one
46:42 - to 11 and then we reassign the remainder
46:45 - to the calculation again and now we can
46:47 - use the exact same line of code above to
46:50 - print out the remainder to the screen
46:52 - now you can see that it's 0o and one
46:54 - it's zero because 10 is even and it's
46:56 - one because 11 is
46:59 - odd so far throughout the course we've
47:02 - been using console right line to Output
47:04 - stuff to the screen for example I can
47:06 - output hello my name is Aba and we can
47:08 - see it in the console the issue is so
47:11 - far we haven't really wrot any code to
47:13 - be able to read in values from the
47:14 - console so let's explore that option
47:17 - right now so in the console Library we
47:19 - have a console right line but what you
47:21 - don't realize is we can also use this
47:23 - console right line to ask the user a
47:25 - question and to let the user type
47:27 - something in so let's use CW tab tab and
47:31 - say enter your
47:33 - name with a colon and then end the
47:36 - quotation
47:37 - marks and then in order to return a
47:40 - value from the console into your program
47:42 - we need to use console. readline and if
47:45 - you hover over readline let's have a
47:47 - read at description reads the next line
47:49 - of characters from the standard input
47:51 - stream perfect this is exactly what we
47:53 - want to do right now it's to use at the
47:56 - end of our code just to stop the console
47:58 - from closing so we can actually see the
48:00 - output so if we just run this right now
48:02 - we actually get the opportunity to type
48:04 - but when we press enter our program
48:06 - closes this is because in this case
48:08 - we're simply using readline just to wait
48:11 - until the user has pressed enter so so
48:13 - our program doesn't close but what you
48:15 - don't actually see is this is returning
48:18 - as a string which means that anything
48:20 - that we type into here and when we press
48:22 - enter it actually gets a return back to
48:24 - the code but we not doing anything with
48:26 - it because we don't care at this point
48:29 - so now let's actually do something that
48:31 - will make us care about the user's input
48:33 - so we can make a new string variable and
48:35 - assign it to console readline and it
48:37 - should give us the ability to store
48:39 - Whatever Gets entered inside the console
48:42 - so we can just do string name and we can
48:45 - end the semicolon here and if you wanted
48:47 - to on the next line you could do name
48:49 - equals console.
48:51 - readline or if you wanted to have it all
48:54 - in one line then you can get rid of the
48:55 - semicolon and bring it up like this this
48:58 - is the preferred method as both lines
49:00 - were on top of each other and it wasn't
49:01 - really necessary to split them here
49:03 - we're doing a declaration of string name
49:06 - and an initialization and giving it the
49:08 - value of console. readline and this is
49:10 - whatever value the user is going to type
49:12 - in let's run our code and see what
49:15 - happens enter your name abber now when I
49:18 - press enter it's successfully stored
49:20 - abber inside this string name variable
49:23 - and now it's waiting at this line the
49:25 - console read line just right here so
49:27 - when I press enter the program closes so
49:30 - now that we've made a variable and not
49:32 - done anything with it let's print out to
49:34 - the screen to make sure that something's
49:35 - actually worked so if we use CW tab tab
49:38 - and we type in name in the brackets and
49:40 - we can run this code again and let's see
49:42 - what happens as soon as I type in Abba
49:44 - and press enter then this second abber
49:47 - is actually the variable printing out to
49:48 - the screen so here it says enter your
49:51 - name with a colon and normally when you
49:53 - see the colon it sometimes lets you type
49:55 - on the same line so if youd prefer the
49:57 - user to type on the same line then we
49:59 - actually have another function for that
50:01 - instead of using right line we can just
50:04 - use right and the difference between
50:06 - right line and right is the right line
50:09 - will actually have a Terminator at the
50:11 - end of the line to tell the console that
50:13 - he wants to push everything after it
50:15 - onto the next line whereas console.
50:17 - right will just print it out to the
50:19 - screen and not worry about any new lines
50:22 - let's try run it now and now we can type
50:25 - in
50:25 - and as you can see it's a little close
50:27 - to the colon so we can fix that in a
50:29 - second so you press enter you can see
50:31 - now that abber comes up on the second
50:33 - line so if we just put a space after the
50:35 - callon just to give it a bit of room now
50:38 - if we type in abber you can see that
50:39 - there's a bit of a gap and it's quite
50:41 - nicer to look at now if we press enter
50:44 - you can see that Abra has been stored
50:46 - successfully so what we can do now is
50:49 - maybe ask for your age so we can have a
50:52 - console.
50:53 - right enter your age age call on space
50:57 - and then do a string age equals console.
51:00 - readline and then we can have a age
51:03 - output as well and let's see how that
51:05 - works so we can say abber then say 23
51:08 - and press enter and now we have abber
51:10 - stored within the name variable and have
51:13 - 23 stored within the age variable so
51:15 - let's try and output a string that's a
51:17 - bit more meaningful to the user let's
51:19 - clean this console up and see what we
51:21 - can do so we don't need to Output their
51:24 - result back to the console because they
51:26 - literally just type that in and we don't
51:28 - want to have this line because we just
51:29 - use that as an example so if we run the
51:31 - code right now it'll look better but it
51:34 - does look a lot more structured enter
51:36 - your name and then enter your age so now
51:39 - when you press enter the program will
51:40 - just close so let's try and output these
51:42 - two variables in a formatted fashion so
51:45 - as you now know we can use console.
51:47 - write to print a lot of stuff on one
51:49 - line so we can use console. write and we
51:52 - can say your name is and then add a
51:55 - space and finish that line there and
51:58 - then duplicate it down we can write name
52:02 - duplicate that down and say space and
52:05 - your age is duplicate that one down and
52:09 - then we can type in age and let's see
52:11 - what happens now abber
52:14 - 23 there we go so we actually have the
52:17 - name output and the age output all on
52:20 - one line if we all change these to right
52:23 - lines then they're going to be on
52:24 - separate lines and it's not going to
52:25 - look very nice so I'm just going to
52:27 - introduce you to a notation called
52:29 - string concatenation this is the notion
52:32 - of being able to concatenate two
52:33 - different strings which just means to
52:35 - add one string onto another as you can
52:38 - see this is taken up four lines of
52:39 - chorde and it's getting a bit ugly the
52:41 - better and easier way to do this is by
52:44 - containing it all within one line so we
52:46 - can have a console right line and we can
52:49 - take the first section your name is keep
52:52 - the space at the end we can end the
52:53 - speech marks and put a plus
52:55 - and then we can say name so now we've
52:57 - just added these two together if we just
52:59 - comment out the rest of them and run the
53:02 - code and you can see that they should be
53:04 - on one line there you go so we can say
53:07 - your name is ABBA and let's just keep
53:09 - changing the plus symbol so we can say
53:12 - and your age is another space and the
53:15 - speech marks and plus the age now we've
53:18 - got all of this contained within one
53:21 - line and it looks a lot better enter
53:23 - your name abber and into your age 23 and
53:26 - now you can see exactly the same output
53:28 - but reduced to one
53:32 - line as you can see these three lines
53:34 - are all stuck to each other so if you
53:36 - wanted to add a blank line between these
53:38 - two you can just put an MC console right
53:41 - line just in here and what this will do
53:43 - is simply just print the right line
53:45 - character to the screen which will force
53:47 - the console to make it on the next line
53:50 - just like so here's the console right
53:52 - line from the empty line that we just
53:53 - wrote and this is the console right line
53:55 - to Output the
53:56 - values so now that you've understood how
53:59 - to read values in from the console let's
54:01 - try and convert some values as I showed
54:03 - you how to do it earlier on in the
54:04 - course you can actually convert these
54:06 - strings into integers ideally you want
54:08 - to store variables in their data types
54:10 - as we covered before ages should not be
54:12 - stored as strings they should be stored
54:14 - as integers but if you try and change
54:16 - this to an INT then you're going to have
54:18 - an issue console read line will return
54:21 - back a string so therefore it can't
54:23 - implicitly convert from a string to an
54:26 - integer so we need to do this in two
54:28 - steps we can rename this to age input
54:32 - and then on the line underneath it we
54:34 - can say int age equals convert to int 32
54:39 - and then add age input in these
54:42 - brackets there we go and now when we
54:44 - actually print the line of code nothing
54:47 - should actually
54:49 - change your name is abber and your age
54:51 - is 23 but now what's actually changed is
54:54 - we're storing the the variables in the
54:56 - correct format this is the ideal method
54:58 - because in the next section when we
54:59 - cover if statements you'll realize why
55:01 - this is very important if you wanted to
55:04 - minimize the amount of steps you need to
55:06 - convert this then you can actually move
55:08 - the console read line and get rid of the
55:10 - string input variable and we can just
55:12 - paste it straight into the bracket of
55:14 - the converter in 32 and you can get rid
55:17 - of the string input variable and
55:19 - everything will work the same AB 23 and
55:22 - now it's working exactly the same if
55:24 - this is many steps for you or if this
55:26 - looks too complicated then just please
55:28 - revert it back just to keep it the same
55:30 - way for the time
55:32 - being so now we've learned how to read
55:35 - in values from the console and output
55:36 - them back to the screen now let's see
55:38 - how we can use if statements to divert
55:40 - our code into multiple paths so in the
55:43 - previous section I told you that it is
55:45 - very crucial for our code to have this
55:47 - int Edge and the reason why is age is
55:50 - meant to be stored as a number and not
55:52 - as a string so we read it in first as a
55:54 - string and and then convert it to an
55:56 - integer using this function and store it
55:58 - into our age variable this is the reason
56:01 - why so our condition goes as follows we
56:04 - write the word if and between the
56:06 - brackets this needs to be evaluated to
56:08 - either a true or false value and then we
56:10 - can have the curly braces to tell us
56:12 - what to do if this becomes true so in
56:15 - this case you want to just check if our
56:16 - age input is greater than or equal to 18
56:19 - let's say this was an entrance to a
56:21 - place that only allowed overes to enter
56:23 - so we can do a input which references
56:26 - the age input variable and we can use
56:29 - the operators equals greater than
56:32 - greater than or equal to less than or
56:34 - less than or equal to or not equal to so
56:36 - these are all the different options that
56:38 - we have we can say if the age input is
56:40 - equal to
56:42 - 18 perfect so now that we've read in the
56:45 - age input we can check if it's 18 let's
56:48 - just process a message in here says you
56:50 - are 18 and let's have a look and see if
56:53 - this works
56:56 - AB 18 now I press enter it says you are
57:00 - 18 but this is the problem with storing
57:02 - everything as a string and then trying
57:04 - to use it as if it was a number if I
57:07 - type in 18 followed by a space as you
57:10 - can see there's a blank Spacey now and
57:11 - press enter you can see that it doesn't
57:13 - come up and the reason why is it's
57:15 - processing it like this with a space at
57:17 - the end in order to avoid situations
57:20 - like this this is why we would convert
57:22 - it to a number and the reason why we're
57:24 - using equals to here is we can't use
57:26 - greater than or equal to because strings
57:28 - can't be greater than or equal to
57:30 - another string they can only ever be
57:32 - equal to or not equal to string is just
57:35 - text so if something equals to something
57:38 - then it's fine the only way that we can
57:40 - use these different operators is if we
57:42 - actually interact with our integer
57:44 - variable now let's see how we can use
57:46 - this so we can say age equals equals 18
57:49 - and now you can see we actually
57:50 - reference it as a number now let's run
57:52 - the code if I do 18 Follow by space it
57:56 - still works and the reason why is it
57:59 - actually dismisses that space when it's
58:01 - converting to the integer so now age is
58:03 - stored as an integer and we can actually
58:05 - manipulate this a bit better so instead
58:07 - of saying you are 18 we can say you are
58:10 - 18 or Alo and now instead of doing equal
58:12 - to we can have greater than if we have
58:15 - greater than then we're actually
58:16 - dismissing the number 18 because if the
58:19 - age is greater than 18 so this will read
58:21 - like this and 18 is not greater than 18
58:25 - so this will return back false what we
58:27 - actually want to use is greater than or
58:29 - equal to if the age that we've inputed
58:32 - is greater than or equal to 18 then you
58:34 - are 18 hence the equal to or greater
58:38 - than if you're older so now let's try
58:40 - and run this abber 23 perfect you are 18
58:45 - or older let's change so let's change
58:47 - some other if statements to add some
58:49 - additional conditions so we can say else
58:52 - if and the only reason why it would come
58:54 - into this bracket if this condition
58:57 - returns false it will move down the next
59:00 - condition in the else chain if this was
59:02 - wrote as a separate if statement then
59:04 - this would run completely independently
59:06 - from this one if you're going to have
59:08 - chained if statements you need to make
59:10 - sure that you chain them correctly in
59:12 - this case I want to check if it ages
59:14 - between 18 and 25 and then move on to a
59:18 - different age bracket and these two
59:20 - things are grouped together so we should
59:22 - have this as an else if because with an
59:24 - age bracket you can only be part of one
59:26 - age bracket and not multiple so we can
59:29 - say if age is greater than or equal to
59:31 - 25 and we can copy this and we can say
59:34 - you are 25 or older now let's see what
59:36 - happens enter your name abber and let's
59:39 - just say that I am
59:40 - 35 it says you're 18 or older but I told
59:44 - it the program I was 35 now the problem
59:46 - we're facing is any value that's over 18
59:49 - will always enter inside here and it
59:51 - will skip over this one completely this
59:53 - is not the behavior it that we want so
59:56 - what we can do in our if statements is
59:57 - we can use the double pipe which
59:59 - represents or or the double Ampersand
60:01 - which represents and and we can change
60:04 - some conditions in here to make sure
60:06 - that you implement some sort of range so
60:08 - we can actually have a range between 18
60:11 - and 25 so we can say if the age is
60:14 - greater than or equal to 18 and the age
60:18 - is less than or equal to 25 and we can
60:21 - tweak this message you are between 18
60:25 - and
60:27 - 25 and let's just run that for now and
60:29 - see what happens ABA 25 now it says 18
60:34 - and
60:35 - 25 so now that we've got between 18 and
60:38 - 25 here we can tweak this to be greater
60:41 - than or equal to
60:44 - 26 if you're 25 will'll enter this
60:47 - condition and if you're 26 or older into
60:50 - this condition so let's test that now if
60:52 - we enter
60:53 - 35 now it says you're 26 or older that's
60:57 - perfect because now that we've
60:58 - implemented range checking it gives us
61:00 - the ability differentiate between
61:02 - different age groups more precisely
61:04 - let's Show an example of how to use the
61:06 - all so if we just have a block comment
61:08 - around all of this we can write an if
61:10 - statement in here and we can say if the
61:13 - edge is smaller than zero or the edge is
61:16 - bigger than 150 then we can output to
61:19 - the screen inv valid Edge and what this
61:23 - is saying is if we're less than zero and
61:26 - notice that this is less than zero so
61:28 - this value will actually start at minus
61:30 - one and this value start at 150 is minus
61:34 - one or less or over 150 then this will
61:38 - happen notice why it's an r one of these
61:41 - need to be true in order for this to be
61:43 - true when you've got an and both sides
61:47 - need to be true in order for this
61:49 - condition to evaluate is true so let's
61:51 - try our code we can say and we put
61:53 - minus one one and now it says invalid
61:56 - age which is perfect because this is our
61:58 - range checking and we can try again with
62:02 - 151 as it's just outside the range it
62:05 - will say invalid age and if we have an
62:08 - else on here we can print valid
62:12 - Edge notice there is no condition in
62:14 - here if you have an open else like this
62:17 - it means If This Were to return false it
62:20 - will always do this regardless of any
62:22 - condition in this case is it's perfectly
62:25 - reasonable to do this because we know
62:27 - that any values that are underneath zero
62:29 - or over 150 is invalid and anything
62:33 - between 0 and 150 is indeed valid what
62:37 - you can do instead is actually move
62:40 - these if statements inside here so
62:42 - instead of just printing out valid age
62:45 - we can actually check the age as
62:47 - well so let's run this now and we can
62:49 - say Aba minus one and it will only print
62:52 - out invalid age and then move on because
62:55 - once it reads this line of codee it will
62:57 - actually skip over the lse and finish up
62:59 - down here and now if you enter a real
63:03 - value you are between 18 and 25 so let's
63:06 - follow the path it got to here and
63:09 - realize that the range track was
63:10 - actually correct so it jumped out of
63:12 - this curly brace and went to the else
63:14 - because this had returned false we jump
63:16 - into this else and now we start checking
63:18 - if age is between 18 and 25 which it was
63:22 - because our age variable is 23 then it
63:24 - outputed this to the
63:27 - screen now if we do the same thing but
63:29 - have 35 instead then it follows the
63:32 - exact same path except towards here this
63:34 - will return back false and then it will
63:36 - check the next condition if age is over
63:39 - 26 then we'll return
63:42 - this so now let's just make a quick
63:44 - multiplication program using if
63:46 - statement to see if you can get the
63:47 - answer correct so let's just comment
63:49 - everything
63:51 - out and we'll start the next section
63:53 - underneath
63:56 - so let's make a console. write and ask
63:58 - the user to enter the first
64:01 - number and then we can say int number a
64:05 - equals convert to int32 and the value
64:09 - that we want to convert is a console.
64:11 - readline which is whatever the users
64:13 - entered from the console again if you're
64:16 - unfamiliar with this format you can just
64:18 - type it in manually number a input
64:21 - equals console readline and then we can
64:23 - put the number input in here now if you
64:25 - use shift and highlight these lines and
64:26 - press contrl D we can duplicate this
64:28 - entire section and we can say enter the
64:31 - second number change a to B change a to
64:35 - B and then finally change a to B perfect
64:38 - so now we've got into the first number
64:40 - and enter the second number and we can
64:42 - say our
64:44 - answer equal to number a multip by
64:48 - number
64:49 - B and then we can have a console. right
64:54 - value of you can add to it number A plus
64:58 - an X Plus number B and then finally plus
65:03 - a callon for the user to type in and
65:05 - then we can say string answer input
65:07 - equals console. readline and then
65:11 - int actual answer equals convert to in
65:16 - 32 and then we can have the input in
65:18 - here so now that we've got one number
65:21 - from the console the second number from
65:23 - the console we're just making a variable
65:25 - that will multiply them together and
65:27 - store inside answer and then we're just
65:29 - going to ask the user what's the value
65:31 - of number a times my number B and they
65:34 - can input that we store it as a string
65:36 - and then convert it to an integer and
65:38 - store the answer into actual answer so
65:41 - now just after the section we can write
65:42 - an if statement that says if the answer
65:45 - equals to the actual answer then we can
65:48 - say Well
65:50 - done and else and the reason why we
65:53 - don't need a condition this else because
65:55 - with equals to the only opposite thing
65:57 - you can have is if it's not equal to so
66:00 - if you really wanted to you could also
66:02 - right if answer is not equal to actual
66:04 - answer then in here you can say close
66:08 - but it was wrong you don't actually need
66:12 - this this is just for learning purposes
66:14 - because this will return back false if
66:16 - they're not equal to each other so this
66:18 - statement is just a given if they're not
66:20 - equal to each other then we can just
66:21 - assume that they're not equal to each
66:23 - other so so we don't need this
66:24 - additional statement if this condition
66:27 - evaluates to being false then that means
66:29 - they're not equal to each other we don't
66:31 - need this additional check to check if
66:33 - they're not equal to each other because
66:35 - that's a given if this returns back
66:37 - false so we can just leave this as an
66:39 - else let's try run the
66:42 - code 10 10 value of 10 * 10 100 now it
66:47 - says well done and let's just try that
66:49 - again and we can enter a different value
66:51 - 90 Clause but it was wrong
66:54 - so let's just have a quick
66:56 - recap so in the previous section we
66:59 - talked about how to input from the
67:00 - console and we generated this line of
67:02 - code which will output your name and
67:04 - your age in one line to the console and
67:07 - then we looked at how we can use these
67:08 - different operators in our if statements
67:10 - and we did some range checking to check
67:12 - if the age was between 18 and 25 and it
67:15 - would output something to the screen and
67:18 - if it was over 26 you'd get a different
67:20 - output to the screen and then we took
67:22 - that a little bit further and started
67:24 - using the r operator if the age is
67:26 - smaller than zero or it's greater than
67:29 - 150 then it must be invalid and if this
67:32 - condition returns false it must be
67:34 - between 0 and 150 so we can come into
67:37 - this L's bracket and inside here we can
67:39 - do our range checkin from the previous
67:41 - bit of code we can check the ranges
67:44 - between 180 and 25 and print a value or
67:47 - if it's over 26 we can print another
67:49 - value and you can keep changing these if
67:51 - you want you can have 26 to 40 and 40 to
67:54 - 60 etc etc that's up to
67:57 - you so this is just a quick little
67:59 - program to simulate multiplication
68:02 - program we can enter the first number
68:04 - using console. right and then we start
68:06 - it as a string and we put that string
68:08 - into the convert in 32 function to give
68:11 - us back an integer variable and we do
68:13 - exactly the same thing for the second
68:15 - number and then we make a variable to
68:18 - store both numbers multiplied by each
68:20 - other we ask the user what is the value
68:22 - of number a Times by number B and we
68:25 - give them an opportunity to type in a
68:26 - value we read that value in convert it
68:29 - to an integer store it as an into actual
68:32 - answer and then in our if statement we
68:34 - say if the answer is equal to the actual
68:36 - answer then we print well done to the
68:40 - screen double equals are used for
68:42 - equality and single equals are used for
68:44 - assignment don't get them mixed up we
68:47 - don't need an else condition in here
68:49 - because if this returns true then this
68:51 - will execute if this is indeed false
68:54 - that they're not equal to each other
68:55 - then we always want to do this section
68:57 - and we don't need to put an additional
68:59 - if statement inside here if you wanted
69:01 - to but it's not necessary you can have
69:03 - else if answer is not equal to actual
69:07 - answer but this is just extra code and
69:09 - it hurts the readability and it should
69:12 - be
69:14 - avoided if statements are one of the
69:16 - methods we can decide different paths in
69:17 - our code the next method we can use is
69:20 - called switch statements so let's write
69:21 - a little program so we can demonstrate
69:23 - this
69:24 - so we can just have a console. right
69:26 - enter a date of the week and we can have
69:29 - in date equals convert to in32 and we
69:32 - can place our console.
69:34 - readline inside the brackets so we take
69:36 - whatever the user typed into the console
69:39 - and then place it inside here and inside
69:41 - here we're going to convert whatever
69:42 - they've typed in to an integer 32 and
69:45 - star it into our D variable so if we
69:47 - just print this out to the screen to
69:48 - make sure it's working fine if we just
69:51 - type in seven we can see that seven is
69:52 - returned so it's all working
69:54 - so normally what we do is type if D
69:57 - equals equals 1 and then we can add the
69:59 - curly braces and use CW tab tab and we
70:02 - can print out Monday now if you run the
70:04 - code and try use number one then Monday
70:06 - works and that's fine and then let's do
70:09 - another lse if and we can say day equals
70:11 - equals 2 and then we can print
70:14 - Tuesday perfect so if we try that
70:16 - now there we go so now we have the
70:18 - ability to print out Monday and choose
70:20 - it to the console depending what day the
70:22 - week the user enters
70:24 - but since we're going to have seven
70:25 - different paths because we got seven
70:27 - days of the week then sometimes it might
70:29 - be better and cleaner to use a switch
70:31 - statement so let's have a look at the
70:32 - syntax so we can type in switch and then
70:35 - inside the brackets it's what variable
70:36 - we want to have a switch on so in this
70:39 - case we want to be using the day
70:40 - variable so we can add day in the
70:41 - brackets this is not a condition in the
70:43 - brackets this is just telling us what
70:45 - variable we're going to be using for the
70:47 - switch statement so let's open the curly
70:49 - braces after and inside here instead of
70:51 - having paths like this we're going to
70:53 - use cases so this can be translated to
70:56 - in the case of number one we can do this
70:59 - in the case of number two we can do this
71:02 - so let's try and see how it works we can
71:04 - type in case followed by number one and
71:06 - then add a call on and then we can type
71:08 - out our Monday in here and then we need
71:11 - to follow each case off by finishing the
71:14 - section off with a break this break is
71:16 - very essential and you'll get a syntax
71:18 - error if you don't put it in so now if
71:20 - we do case two and we do exactly the
71:22 - same thing there we go and if I dismiss
71:25 - the break then you'll realize that it
71:27 - says it cannot fall out so we have to
71:29 - use a break just the compiler knows that
71:31 - we want to break here the reason why
71:33 - this break is placed inside here is
71:35 - because what we can do is we can say
71:38 - case two and then add another one in
71:41 - here called case three and what this now
71:43 - reads is if we enter two it says Tuesday
71:47 - and if we enter three It also says
71:49 - choose it so what you can do is you can
71:52 - actually chain so this would be
71:53 - equivalent to writing if D equals 2 or D
71:57 - equal equals 3 now this is exact
72:00 - translation these two are exactly the
72:02 - same as of right now we have D equals
72:04 - equals 1 which is our case 1 and then
72:07 - equals 2 or equals 3 is right here if we
72:11 - go into the case 2 path it will fall in
72:12 - the case 3 so we're saying for this
72:14 - break is we want to end this section
72:17 - here so now if we just revert this back
72:18 - and continue the
72:20 - chain I'll just skip this part just so
72:22 - it's a little bit quick
72:26 - there we go so now that we've got all
72:27 - seven days of the week let's just see if
72:29 - it works let's try six and we have sat
72:31 - it so now we're kind of missing
72:33 - something from here the only thing we're
72:35 - missing is having our external else just
72:38 - in case the user types something invalid
72:40 - so normally we would write something
72:41 - like this enter value between 1 and 7
72:46 - just to make sure that the user knows
72:47 - what they're
72:48 - doing now we don't seem to have anything
72:51 - inside here that gives us the
72:52 - opportunity to it in invalid so we have
72:54 - this keyword called default and it works
72:57 - exactly the same as the case except what
72:59 - this will do is this is basically the
73:01 - word that replaces else so we can
73:03 - literally take this line of code and
73:05 - place it again over here and add
73:07 - ourselves a break this is exactly the
73:09 - same as doing our L statement inside
73:11 - here if none of these cases match this
73:14 - variable then it'll go into the default
73:16 - and continue as normal so if we type in
73:18 - zero we should see the message twice
73:20 - because it's executing for the if
73:21 - statement and executing down here and
73:24 - let's do eight and you see the message
73:26 - again so now that the case statement is
73:28 - fully working let's just comment out the
73:29 - if statement and make sure that it's
73:31 - still works one Monday let's just try
73:34 - another one and we can do seven for
73:36 - Sunday so just a quick recap case
73:39 - statements are used by using the keyword
73:40 - switch followed by the variable in
73:42 - question and then if you want to check
73:44 - if this variable number is equal to
73:46 - something you put that something
73:47 - straight after the word case followed by
73:50 - a colon and then you can insert multiple
73:52 - lines of code inside here and make sure
73:54 - you end that line with a break if you
73:56 - want to chair in multiple like Dayal 2
73:59 - or Dayal 3 then you can add the case
74:01 - above right here so the case of zero or
74:05 - the case of two it will do this little
74:07 - section so it'll print out choose there
74:09 - if the user enters zero or the user
74:11 - enters two of course in this case we
74:13 - don't actually want that after you
74:15 - filled out all of the code make sure you
74:17 - add something called the default the
74:19 - default is equivalent to an lse keyword
74:21 - in our if statement just to catch all
74:22 - the Val use in case the users type
74:25 - something incorrect and you want to let
74:26 - them know what they should be typing
74:30 - instead so now that we explored
74:32 - different paths in our code using IF
74:33 - statements and switch statements let's
74:35 - have a look at how we can iterate
74:36 - through our code an iteration in code is
74:39 - just the ability to be able to Loop and
74:41 - do a certain task so let's say we wanted
74:43 - to print high to the console several
74:46 - times then we just have to copy and
74:47 - paste it down and this will be five
74:49 - separate lines that do exactly the same
74:51 - thing this will essentially achieve what
74:54 - we want the problem is you just have
74:56 - exactly the same code copy and pasted so
74:59 - what we can do if we just block comment
75:01 - this line for the time being we can
75:02 - write something called a for Loop a for
75:05 - Loop gives us the ability to Loop a
75:07 - certain amount of times depending on the
75:08 - parameters that we give it so this is
75:10 - the syntax you can type for open the
75:13 - bracket and we have to use a variable so
75:15 - we can declare a new variable straight
75:17 - into these brackets we can say in I
75:19 - equals z and then have a semicolon and
75:22 - there's three different sections of this
75:24 - the first one is the variable decoration
75:26 - and initialization and the second one is
75:28 - the condition so in this case we want to
75:30 - do this task five times so you want to
75:33 - say I is less than five then we end that
75:35 - semicolon there and now for the third
75:37 - task every time this fall Loop goes
75:39 - around we want to increase I by one
75:42 - because we want to go in steps of one so
75:44 - we can do
75:45 - i++ alternative if you don't like using
75:48 - Plus+ you can say I = I + 1 or to make
75:52 - that quicker you can could say i+ equals
75:54 - 1 I personally just prefer using Plus+
75:57 - and you'll see that everywhere else
75:59 - there is certain cases where you would
76:01 - actually you want to change this to a
76:02 - different value like i+ equal 2 and
76:04 - we'll show you that in a second so this
76:06 - for Loop now says we want to go from
76:08 - ials Z and once this condition returns
76:11 - back false when I is equal to 5 or
76:14 - greater then we want to stop this for
76:16 - Loop every time this forp goes around so
76:18 - when it hits this curly brace and comes
76:20 - back around we want to do this action
76:22 - and in this this case it's I ++ so if we
76:25 - just use console right line and print
76:27 - out the value I we can see what happens
76:29 - when the follow
76:31 - runs you can see that the value of I is
76:34 - increasing one each time and after the
76:36 - fifth time is increased the value is
76:39 - actually five so now this statement is
76:41 - false because the value of I is equal to
76:44 - five so therefore this is now false and
76:46 - the fall Loop is ended so now that we've
76:49 - verified that you can repeat it five
76:51 - times using this code we no longer want
76:53 - to print I we want to print our high so
76:55 - let's paste that inside the bracket and
76:57 - run the code now you can see that these
76:59 - two values will be exactly the same as
77:02 - printing it out to the console just like
77:03 - this but now we have a lot less code so
77:07 - let's have a look at another example we
77:08 - can say 4 in I equal 0 and we can say I
77:12 - is less than or equal to 10 and then we
77:16 - can do i+ equal 2 and then if we just
77:19 - print I to the console so what this is
77:21 - now saying is I want to go from zero all
77:24 - the way till 10 and I want to go up two
77:27 - times each time so what this will be
77:29 - achieving is printing out all of the
77:31 - even numbers between 0 and
77:33 - 10 let's try and run
77:36 - it now we can see we have all the even
77:38 - numbers printed out between 0 and 10
77:41 - because we're going up in
77:42 - twos if we start this at one for example
77:45 - and still keep every parameter exactly
77:47 - the same then we'll be getting all of
77:49 - the even numbers between 1 and 10 11 is
77:52 - missing because our condition stops at
77:54 - less than or equal to 10 what you can
77:56 - also do with for Loops is you can let
77:57 - the user determine what this value is
78:00 - going to be let's test that so if we
78:03 - block comment this section out what we
78:05 - can do is we can append this little
78:06 - section so we can have a console. right
78:09 - how many times do you want to say hi can
78:13 - have a callon followed by speech marks
78:15 - and then we can say int Loop counter
78:18 - equals convert to n32 and we can have
78:21 - console read line inside the brackets
78:24 - how many times you want to say hi the
78:26 - user types in the value we take the
78:28 - console read line as a string convert it
78:30 - to an integer and St inside loop
78:33 - counter so now what needs to change
78:35 - inside here the five is what determines
78:38 - how many times that we're going to Loop
78:40 - so in this case we actually want to just
78:41 - Loop by whatever the user types in the
78:43 - counter let's just type five and make
78:46 - sure it works and if we just type one it
78:50 - works if we type zero however however it
78:53 - will just skip over the for Loop and the
78:56 - reason for that is if you're going from
78:58 - zero to I is less than zero then this is
79:00 - immediately going to be false so then
79:02 - the for Loop is just going to get
79:04 - skipped immediately there is nothing to
79:06 - do if the user is typed in zero which is
79:08 - perfectly reasonable and you can type in
79:10 - a really big number like a 100 and it
79:12 - will output them all to the
79:15 - screen if the user types in zero then
79:18 - nothing's going to come up so you always
79:19 - want to be able to let the user know if
79:21 - there's something wrong so we can say if
79:23 - the loop counter equals equals to zero
79:26 - or maybe we can change this to less than
79:28 - or equal to cuz it could type in minus
79:30 - numbers as well we could just say conso
79:33 - right line using CW tab tab sorry please
79:37 - enter a value above
79:39 - zero and then if this condition has
79:42 - returned back false then inside our else
79:44 - statement we don't need to give it an
79:46 - else if because if it's less than or
79:48 - equal to zero then we want to process
79:50 - the other values because it has to be
79:53 - greater or equal to
79:55 - one so when this is false this section
79:59 - has to be greater than or equal to one
80:01 - so we can just place our for Loop inside
80:03 - here and that's fine and let's try to
80:05 - run the code now and if we type in zero
80:07 - please enter a value of zero and if we
80:09 - just try any negative values we'll get
80:11 - the same message if you want to print
80:13 - additional code in here you can
80:15 - literally do anything you want you can
80:17 - even ask the user what they want to
80:18 - print up here and then you can replace
80:20 - this with a message for example we can
80:22 - have a string
80:24 - message and we can just change this to
80:26 - hello world and this could be something
80:28 - that you read in from the console so we
80:30 - can say message and we can put that in
80:32 - here and if we print that there we
80:35 - go so we can just say console.
80:39 - right what do you want to repeat and
80:43 - then we can read this
80:45 - in and actually it might be easier if we
80:48 - change this Loop counter to Second so if
80:51 - we highlight the section and hold alt
80:53 - and press down arrow twice we can move
80:54 - it down and say and how many times do
80:58 - you want to repeat it there we go so now
81:03 - what we can do is we can use this
81:05 - message inside here and then Loop
81:07 - depending on how many times the users
81:09 - typed in whatever so we can type in
81:11 - hello world get this exact value and we
81:13 - can say 10 times there we go so now this
81:16 - entire program is fully customized by
81:18 - the user's
81:20 - input so let's just have a quick recap
81:22 - so we started off this code by printing
81:25 - the console right line five times to the
81:26 - screen we wrote Our simple far Loop that
81:29 - went from in equal Zer to I is less than
81:32 - 5 and we did I ++ because we want to
81:35 - count up in ones you can place the high
81:37 - inside here and it'll printed it five
81:39 - times for us so now we've made our code
81:41 - from five lines down to just three lines
81:44 - for the for Loop and then we allowed the
81:46 - user to type in how many times that they
81:48 - want to repeat it and we change the
81:50 - condition from I is less than five to I
81:52 - is less than whatever the user has typed
81:54 - in installed within the loop counter and
81:57 - then we hit a problem where if we
81:59 - entered zero anything less than zero the
82:01 - F would just not run and it might look
82:03 - like some things went wrong so we added
82:05 - a little if statement in here to make
82:07 - sure that the user has entered a value
82:09 - above zero and if they haven't we can
82:11 - let them know we don't need another if
82:13 - statement in here because if this has
82:15 - returned back false we can assume that
82:17 - the value is something that we can work
82:19 - with we later tailored the program so we
82:22 - can change this message that was fixed
82:24 - to high to something that the user can
82:26 - type in
82:28 - manually so now that we know how to use
82:31 - for Loops let's have a look at while
82:32 - Loops for loops and while Loops still
82:35 - iterate through code but they're used in
82:37 - slightly different contexts for Loops
82:39 - are used mainly when you know how many
82:41 - times you can iterate through as in this
82:43 - example we're going to printer the
82:45 - console exactly 10 times but in a y Loop
82:48 - you might print until a condition is
82:50 - true for example if you asking the user
82:52 - to type a number and they kept typing in
82:55 - something else you don't know how many
82:57 - times it's going to take the user to
82:59 - type in correctly so in that case you
83:01 - would use a y Loop if you executing a
83:04 - certain amount of code and you're only
83:05 - doing it a fixed amount of times then
83:07 - it's always best to use a for Loop so
83:10 - first let's try and convert this simple
83:12 - for Loop that just prints I to the
83:13 - console 10
83:15 - times just like so from zero all the way
83:18 - till 9 so let's comment out this for
83:20 - Loop and have a look at this Syntax for
83:23 - the while loop so we can type the world
83:25 - while and then in here we have our
83:27 - condition and then we can open our curly
83:29 - braces and while this condition returns
83:32 - back true it will always go inside the
83:34 - curly braces and when this condition
83:36 - returns back false then we'll exit the
83:38 - while loop so let's try and mimic
83:41 - exactly what we're doing inside here
83:43 - there's three sections of the for Loop
83:46 - we Define the variable that we're going
83:47 - to use for the for Loop counter and we
83:49 - give it an initial value we give it the
83:52 - stop dring condition and we give it how
83:54 - many times the value needs to go up
83:56 - every time the fall Loop iterates in the
83:58 - while loop situation we only have the
84:00 - condition available so let's take our
84:02 - condition and paste it straight into
84:04 - here and now we need to store our
84:06 - variable so just because it's a while
84:08 - loop when we can't store it inside here
84:10 - we have to do it outside the Y Loop so
84:12 - let's make it in I and we'll make it
84:14 - equal to zero so we've got our variable
84:17 - we've got our condition now we need to
84:19 - set I ++ so inside the Y Loop we can say
84:23 - i++ and then now we've achieved this
84:25 - entire line and successfully converted
84:28 - it let's try and put the console right
84:30 - line in and see what
84:32 - happens and let's run the
84:34 - code so it's going from 1 all the way
84:37 - till 10 and the reason why it's gone
84:39 - from 1 till 10 not from 0 to 10 is
84:42 - because the i++ is at the start let's
84:44 - move it down online using alt and down
84:46 - arrow key to move it down and let's run
84:49 - it again and you can see it goes from 0
84:50 - to 99 and if we just block comment this
84:54 - out and undo the for
84:57 - Loop you can see that they're doing
84:59 - exactly the same thing so let's bring
85:01 - the W loop
85:03 - back and as you can see what we have is
85:07 - we've defined our I variable made it
85:09 - equals to zero while the I variable is
85:12 - less than the value of 10 we print the I
85:15 - to the console and increment I by one
85:17 - and we keep looping this until this
85:20 - statement returns back false and then
85:22 - exit the Y Loop and jump underneath the
85:24 - curly braces and hit the console read
85:26 - line and this is the output that we've
85:28 - got so now I've just copied the code
85:30 - from the if statement video and let's
85:32 - make this code a little bit better so
85:34 - let's comment out our while loop and our
85:36 - for Loop that was just used for
85:37 - explanation purposes and this is the
85:39 - code that you saw earlier on in the C we
85:42 - read in the first number start as a
85:43 - string use that string to convert to an
85:46 - integer star number a and Then star
85:48 - number B and these two blocks are
85:50 - exactly the same except you have have
85:52 - enter first number and enter second
85:54 - number and we store number a and store
85:56 - number B then we store the value of them
85:58 - both multiplied inside our int answer
86:02 - variable then we ask the user what's the
86:04 - value of both answers times together
86:07 - give them a chance to input their value
86:09 - convert it to an integer and then we
86:11 - check the value and print well done of
86:13 - close but it was wrong now if we run
86:15 - this code again and we type in 10 and 10
86:19 - and we know the values of 100 but let's
86:21 - just type in 90 now this is kind of a
86:23 - problematic user case we've asked the
86:26 - user to type in a value and they've got
86:28 - it wrong and then when they press enter
86:30 - the program just closes there's no
86:32 - opportunity to Loop or try this again so
86:35 - what we can do is add a y Loop in here
86:37 - and we can say while the answer is
86:39 - incorrect we can keep asking the user to
86:41 - keep on guessing so instead of reading
86:44 - the input here let's turn this little
86:45 - section into a question what's the value
86:50 - of number a * number B and instead of
86:52 - allowing an input here let's just put a
86:54 - question mark and then let's add a
86:57 - console right line just to give a little
86:58 - bit of a gap and then in order to do our
87:01 - while loop we actually want to create a
87:03 - bolean variable just to track if the
87:05 - answer has been correct or
87:07 - not this is the section that we want to
87:10 - loop around in the while loop we want to
87:12 - read in the user's answer check it
87:14 - output a message and then give them the
87:16 - opportunity to read in another value so
87:18 - they can guess again while the answer is
87:21 - not not equal to the actual answer then
87:24 - we can loop around our code so we have
87:27 - to modify a few things here so we can't
87:29 - just take this code and place it inside
87:31 - the problem with doing this is the
87:33 - variables that we want to check answer
87:35 - is outside of this y Loop but actual
87:38 - answer is inside and the reason why
87:40 - there's a red line here says it does not
87:42 - exist in the current context because
87:44 - we're trying to check a variable that
87:45 - hasn't been defined yet so what we can
87:47 - do is take the decoration for the actual
87:50 - answer and place it outside here and
87:51 - make make it equal to zero and instead
87:54 - of redeclaring it inside the while loop
87:55 - we can take this in and get rid of it so
87:58 - we set the actual answers to zero set
88:00 - the answer to the multiplication while
88:02 - the answer is not equal to the actual
88:04 - answer then we want to loop around so we
88:07 - don't actually need another check in
88:08 - here this while loop will keep on
88:11 - repeating if the answer is incorrect so
88:13 - we don't need a path for correct and
88:15 - incorrect if this while loop still
88:17 - continues then the answer will always be
88:19 - incorrect so what we can do to double
88:21 - check is we can say if the answer does
88:24 - not equal the actual answer then we can
88:27 - place this message inside here and get
88:29 - rid of this
88:31 - branch and then after the while loop has
88:34 - continued we can say Well done so let's
88:37 - just read through the code while the
88:39 - answer is not equal to the actual answer
88:42 - and when this while loop first enters
88:43 - it's going to be true because you're
88:45 - going to have 10 * 10 which is 100 and
88:48 - the value of answer is zero so this will
88:50 - return back true cuz these two values
88:52 - are not equal to each other then we're
88:54 - going to ask the user to enter the value
88:56 - then we're going to read into the actual
88:58 - answer check if they're not equal to
89:00 - each other and then we output a message
89:02 - because we're asking a question here we
89:04 - want to ask another one using a console
89:06 - right Line enter your answer call on
89:11 - here we go so let's have a look and see
89:13 - how this
89:14 - works 100 100 what's the value of 100 *
89:18 - 100 and let's just get it wrong on
89:20 - purpose 90 call is wrong and now we get
89:23 - to answer again and we can keep
89:25 - answering this as many times as we want
89:27 - until we reach the correct answer which
89:30 - in this case is 10,000 and we've got the
89:32 - answer well done so to make the console
89:35 - look a little bit better cuz this is all
89:37 - in one block we can separate these with
89:39 - console right lines maybe after this
89:41 - line we can print out a new line and
89:43 - then after each guess we can print out
89:45 - another new line so after each guess
89:47 - we'll be down here we can just print out
89:49 - a blank console right line and just
89:51 - after after you ask them to enter the
89:53 - second number we can print another one
89:54 - here and let's just see how that looks
89:56 - 10 10 now it looks a lot better because
89:59 - you ask the user to input the numbers
90:01 - then you ask them the question and then
90:03 - you get the answer and then it keeps
90:05 - looping around like
90:06 - this so there's a little gap between
90:08 - each one so you can efficiently read it
90:10 - instead of it all being closed off
90:12 - together and now if you answer it
90:13 - correctly 100 now it says well done and
90:16 - when we press enter again the program
90:18 - now closes so that was using a while
90:20 - loop and now we have something else
90:22 - called a do while and a do while is very
90:25 - close to a while except that the while
90:28 - will only happen if this condition
90:30 - returns back true and a do while will
90:32 - always happen once and it'll check the
90:35 - condition at the end so let's have a
90:37 - look and see how this works so we write
90:38 - the word do and then we have the curly
90:40 - braces and then after it we have our
90:42 - while condition and let's just copy the
90:45 - condition from the old while loop and we
90:47 - can say answer is not equal to actual
90:49 - answer so as you can see with a while
90:52 - loop it will always check the condition
90:53 - first and then it opens the curly braces
90:56 - in the do there is no condition it will
90:59 - always do everything inside the curly
91:01 - braces once and then it will check this
91:03 - while condition if this condition is
91:06 - still true then it'll loop around and
91:08 - check it every time but it will only
91:10 - check it at the end while Loops will
91:12 - check the condition as the first thing
91:13 - it does and then check it every
91:15 - iteration so let's move our Corde down
91:18 - into here and let's just comment out our
91:21 - while loop just to see how this works
91:24 - and if we run it again to make sure it's
91:25 - working fine 10 10 90 90 50 and then
91:30 - finally 100 and it says well done so you
91:33 - could be thinking what are the
91:34 - differences between a while loop and a
91:36 - do while in certain cases you want the
91:38 - while loop to make sure this condition
91:40 - is true before even continuing in this
91:43 - specific case we always want the user to
91:46 - answer the question it doesn't matter if
91:48 - it executes once because actually that's
91:50 - the behavior that we want
91:52 - we've asked the user a question right
91:54 - here so we want to always be looping at
91:56 - least one time the while loop user case
92:00 - doesn't quite apply here because we
92:02 - don't necessarily have to check if
92:03 - they've answered correctly if they
92:05 - haven't even inputed a value yet we
92:08 - always want to be able to give them the
92:09 - option to do it once and then we check
92:12 - their answer at the end they could get
92:13 - it on the first answer 10 10 100 and
92:17 - it'll still be fine the same is true
92:19 - with a while loop but it'll B easier and
92:22 - it makes more sense to read your code
92:24 - when you have a while loop you can see
92:26 - that this bit of code depends on a
92:28 - condition whereas in a due while the
92:31 - first iteration does not depend on
92:33 - anything but the second and third and so
92:35 - forth depend on the condition so
92:38 - depending on your user case and what
92:40 - situation you want to use it you should
92:42 - either pick a while loop which will only
92:44 - occur through a condition or pick a do
92:46 - while that will occur once or multiple
92:49 - times after the first condition has
92:51 - passed
92:54 - so when you have if statements that are
92:56 - pretty basic you can actually make them
92:58 - quite easy to read through the
93:00 - conditional operator also known as the
93:02 - Turner operator so let's see how this
93:04 - works let's say we have an INT ede and
93:06 - we set it to a minus value and we know
93:09 - that this value can never be someone's
93:11 - age because it's negative but let's say
93:13 - that we have a situation where you ask
93:15 - the use it for their age and they've
93:16 - accidentally typed in -10 and we know
93:19 - that that value is not actually true so
93:21 - we could write something like this age
93:24 - is greater than or equal to zero then we
93:26 - can print out
93:27 - valid and then in the lse we can take
93:31 - this console right line and we can print
93:33 - out invalid so that means if we run our
93:35 - code now you can see that it says
93:38 - invalid and if we change it to positive
93:40 - 10 now it says valid so this seems a
93:43 - little bit long we are just checking one
93:46 - condition printing a value and printing
93:49 - another value if that condition returns
93:51 - back false so our conditional operator
93:53 - works like this we have a condition
93:56 - followed by question mark then the value
93:59 - if it returns true then the value if it
94:01 - returns false let's see how you can
94:03 - rewrite this if statement into one
94:05 - simple line so let's take this in
94:08 - steps these two values are both strings
94:11 - that we've typed in so let's make a
94:14 - string and we can call it result and
94:16 - let's make it equal to our Turner
94:19 - operator so the first step is to get the
94:21 - condition and the condition in this case
94:23 - if the age is greater than equal to zero
94:26 - we can follow that by a question mark
94:29 - and then if this returns back true we
94:31 - want the string to say valid and we can
94:34 - have a call on and if it returns back
94:36 - false then we want the string to say
94:38 - invalid and we can add a semicolon and
94:41 - then straight after it we can just have
94:43 - a console right line that just says
94:45 - result as you can see now that we get it
94:47 - twice we can verify one comes from the
94:49 - if statement and one comes from from the
94:51 - turny operator and now if we make this a
94:53 - positive 10 then you can see it both
94:55 - says valid so if we comment out the if
94:58 - statement and just see this running on
95:00 - its own just to double check there we go
95:03 - and because this is just returning back
95:04 - a string we can actually just take all
95:07 - of this code in the conditional operator
95:09 - and paste it straight into the console
95:11 - right line so you run the line of code
95:12 - now we get exactly the same thing if
95:15 - this hurts the readability of your code
95:18 - then it's best to just store it and then
95:19 - use it after if you can read this code
95:21 - and it's better for you in the long run
95:24 - later on you might want to dismiss this
95:26 - variable and do it straight inside the
95:27 - brackets just to save a variable and
95:30 - then print it out to the screen straight
95:32 - away it'll be better for memory if you
95:34 - just print it out straight away but if
95:36 - you're not familiar with this notation
95:38 - yet and you want to get used to it then
95:39 - that's fine as well so a quick recap we
95:42 - had an if statement with a condition and
95:44 - if this returned back true we printed
95:46 - valid and if it return back false we
95:48 - print invalid and this is pretty simple
95:50 - the only difference between these two
95:52 - paths is this string literal that we've
95:54 - typed into here so we can pull the
95:56 - string values out and place them in our
95:59 - conditional operator we can say string
96:01 - result is equal to if the age is greater
96:04 - than or equal to zero then we store
96:07 - valid inside result and if it's not
96:09 - greater than equal to zero then we can
96:11 - start inv valid straighten our string
96:14 - after we've start this value we can
96:15 - print results straight to the screen
96:17 - which will either give us valid or
96:20 - invalid
96:23 - when you're dividing two numbers you
96:24 - might get an ugly output just like
96:27 - this the user sometimes doesn't want to
96:29 - see such long decimal places and maybe
96:32 - you just want to prevent it to
96:34 - 81.3 in order to do this we need to use
96:37 - a format pattern so the language
96:39 - understands what we're trying to achieve
96:40 - so if we make another console right line
96:42 - what we can do is use string. format and
96:45 - inside the brackets we can give it a
96:47 - format and then the object that we want
96:48 - to format so in this case the object in
96:50 - the second parameter is our value so
96:53 - let's open some speech marks go to the
96:56 - next parameter using the comma and just
96:58 - type in our value and then inside the
97:01 - speech marks we want to type in the
97:02 - pattern if you type in curly brace as
97:04 - zero then zero represents the first
97:07 - value in this list we can do a space
97:10 - followed by curly braces one and then
97:12 - add another comma and we can add a
97:14 - thousand and what this means is value
97:17 - will get placed where zero is and 1,000
97:19 - will get Place one is
97:21 - so let's run this and you see the exact
97:24 - same thing's happened plus a SP and now
97:27 - we have the Thousand which follows this
97:29 - part exactly if this is confusing don't
97:32 - worry too much about it I have the next
97:33 - section all about string functions so
97:36 - let's get rid of the one followed by the
97:38 - thousand and run it again and we should
97:40 - see the output being exactly the same
97:42 - there we go so now let's see how we can
97:45 - make this better in terms of decimal
97:46 - places so just after the zero and the
97:49 - zero represents the first value value we
97:51 - can add a callon and this callon will
97:54 - tell us what format we want the value to
97:56 - be displayed as we can type in
97:59 - 0. and what this means is all the
98:01 - numbers before the decimal place will
98:03 - get displayed and only two numbers after
98:06 - the decimal place will get displayed so
98:08 - let's try run this now and you can see
98:09 - that the code output is a lot cleaner
98:12 - one thing to note though by default this
98:13 - will round it up 0.37 becomes
98:17 - 0.4 not to worry though cuz this is what
98:20 - the user will see on the screen and it
98:21 - won't affect the actual value of the
98:23 - variable if we print out value straight
98:26 - after you'll see that the difference
98:28 - hasn't been changed it's still 0.3 in
98:31 - the original variable so that's one
98:33 - method of doing it what we can do now is
98:35 - just use contr D and copy it down and we
98:38 - can use different formats to show you
98:39 - what it looks like if we remove the 0
98:43 - and then one of the zeros and leave it
98:45 - like this and it grains one decimal
98:47 - place each time you'll see what the
98:49 - output looks like we just have the 81
98:52 - which essentially makes it into an
98:54 - integer because it's a whole number then
98:56 - we have
98:57 - 81.0 and the reason why it's 0 Z is cuz
99:00 - 0.3 will round down as it's under
99:03 - 0.5 the 03 is going to round down as
99:06 - it's under 05 so it'll round down to
99:09 - zero and then finally we have the
99:13 - 81.4 and just like before this will
99:15 - round down
99:16 - to4 and just like before this will round
99:19 - down to 0.4
99:21 - this will round down to
99:23 - 04 let's say you wanted to get rid of
99:25 - trailing zeros because you don't want
99:27 - them then you can actually change this
99:29 - zero to a hashtag once you onun the
99:31 - hashtag then it will trim off any
99:33 - trailing zeros so what this means is it
99:36 - will try and put it in this format but
99:38 - if this format happens to be a zero then
99:40 - it will just keep it like this and if
99:42 - you just have 81 dot then it'll also get
99:45 - rid of the dot for you so then you just
99:46 - left with
99:47 - 81 it's really up to you as the
99:50 - programmer what you want want to display
99:51 - depending on what context I'm just
99:53 - giving you the options that you have
99:55 - available so let's say we want to work
99:57 - with money now and we have a 10d divided
100:00 - by 3D and what that value would be is
100:03 - somewhere between 3333 and this will be
100:05 - reoccurring cuz it's exactly 1/3 the
100:08 - reason why I've got D's in here is
100:10 - because these are registering as doubles
100:12 - if you type the value in normally it'll
100:14 - get registers an in32 and the problem
100:17 - with in32 is when you do this division
100:20 - it will process the division is an
100:21 - integer and then store it as a double
100:24 - the issue with that is in this case and
100:26 - in this case both values will get truned
100:29 - let me demonstrate if I remove the D
100:31 - from both sides and down in here it will
100:33 - see what the difference is and let's
100:35 - print out money and then's see what's
100:38 - happened in the first case this isn't
100:40 - actually an issue because we have a
100:42 - decimal place here which means this will
100:44 - be a double so an integer divided by
100:46 - double will give us a double but we just
100:48 - place the D here just so we don't forget
100:50 - and and it makes the compiler's job a
100:52 - lot easier cuz it doesn't have to
100:53 - convert it from an integer to a double
100:56 - and in this case we have an INT that's
100:58 - divided by an INT so we'll get 3.3
101:01 - reoccurring but because it's processing
101:03 - as an integer then we just get three
101:05 - being displayed and this is not the
101:07 - intended result so let's just replace
101:09 - these back to D's and we'll see what we
101:10 - get now which is a 3.3 perfect so let's
101:14 - say that we want to display this as
101:16 - actual currency because you never see it
101:18 - displayed like this it's always to two
101:20 - decimal places just as follows so we can
101:23 - follow the same approach as
101:25 - above we can do string.
101:28 - format 0 call on 0.00 and the curly
101:32 - brace and then common money cuz that's
101:33 - the variable in reference and now if we
101:35 - run that let's see what happens
101:38 - 3.33 that's perfect and now what we can
101:41 - do in here because this is the pattern
101:43 - we can actually type in anything before
101:45 - after this and it won't affect the
101:47 - pattern just like so we've added some
101:49 - Extra Spaces in here so if we get rid of
101:51 - these spaces we can actually just place
101:53 - a pound sign in front of it and then
101:56 - let's see what happens when we run it
101:58 - perfect so now we actually have some
102:00 - money and we can say in here £10
102:05 - /3 equals
102:07 - this and now our output looks a little
102:09 - bit better because we have some
102:11 - formatting now the issue is when we
102:13 - start getting into negatives let's see
102:15 - what happens so we can say -10 /3 equals
102:21 - something and when we run we'll see that
102:23 - the format is actually incorrect
102:26 - now you never see the negative symbol
102:29 - after the pound symbol it's always this
102:31 - way around in this case what we're doing
102:34 - is we're telling the compiler hey we
102:36 - only want to see two decimal places but
102:39 - always keep in this format the pound
102:41 - sign followed by the value and the value
102:44 - of money is -3 so it'll Place -3 inside
102:47 - here and then add the pound sign before
102:50 - it but we don't don't exactly want that
102:52 - so we can add something called a culture
102:54 - info but we can also give it some other
102:56 - formatting some other way so let's
102:58 - explore some other
103:00 - options if you use money to string then
103:03 - what we're actually doing here is using
103:05 - the double variable and converting it to
103:07 - a string and we get passed back a string
103:10 - representative of this value and that's
103:13 - fine and when we run the code you'll see
103:15 - no difference between these two at this
103:17 - point they're both being converted to
103:19 - Strings but what we can do in this case
103:22 - is when we open these brackets it tells
103:23 - us there one of four what does this mean
103:26 - exactly so in our two string function we
103:28 - have four ways that we can call this
103:30 - function the first way you give nothing
103:32 - in the
103:35 - brackets and if we press the down arrow
103:38 - the second way is to give it a format
103:40 - provider the Third Way is just a string
103:42 - format and the fourth way is both a
103:45 - format and a provider so we'll use all
103:47 - of these in a second but let's explore
103:49 - the easiest one if you add a string in
103:51 - there which gives us the third overload
103:53 - string format and we can just type in a
103:55 - Capital C let's just see what
103:58 - happens perfect so now we have the best
104:01 - format displayed to us and the reason
104:03 - why this works is the C program will
104:06 - recognize that the format of C is
104:08 - telling us that we want to display
104:10 - currency so then it's going to your
104:12 - local machine and figuring out where you
104:14 - are based on your date and time just
104:16 - down here when you have adjust date and
104:18 - time it will figure it out based on this
104:21 - we have UTC time and we have the date
104:23 - and time listed up here based on that
104:26 - information it can figure out that we
104:27 - are indeed in the UK and we want to
104:29 - display a pound sign and because the
104:31 - program knows that it's - 3.33 it'll put
104:34 - the pound sign in the right location so
104:37 - now that we've explored C let's have a
104:39 - look at the other ones that are
104:40 - available so if we use contrl D and copy
104:42 - this down three times we can use C 0 C1
104:46 - and C2 and now if you run this again
104:48 - you'll see what the output gets you
104:51 - c will get your currency in its most
104:53 - native form which is what we're used to
104:55 - using in the UK C zero will only return
104:58 - you back with the whole number C1 will
105:00 - give you one decimal place and C2 mimics
105:03 - C on its own as they're displaying the
105:05 - same values now this is where it gets
105:08 - interesting if you want to display a
105:10 - different currencies then you're going
105:11 - to have to use this thing called a
105:13 - culture info which will be able to
105:14 - retrieve back different currency formats
105:17 - based on a certain country code that you
105:19 - give the function
105:21 - so let's have a look and see how that
105:23 - works if we scroll to the top we can add
105:25 - a new library called system.
105:27 - globalization inside globalization we
105:29 - have a culture info so let's see how we
105:32 - can tailor these to make it look a lot
105:34 - better if you're worried about different
105:36 - currencies so we use CW tab tab and we
105:39 - do the same thing money. two string we
105:42 - add our C and this is where our format
105:44 - provider fits in so we can start typing
105:47 - culture info it should come up like this
105:50 - press enter and inside this is a class
105:53 - that's why it went green if we press dot
105:56 - then we get the current culture the
105:58 - current culture will decide based on the
106:00 - machine that the program is running on
106:02 - if this program is running on a cloud
106:04 - computer and the cloud computer is
106:06 - stored in Europe then it might display
106:08 - euros and if it's stored in America then
106:10 - it'll display dollars so you want to
106:12 - avoid using current culture if you're
106:14 - going to scale your program worldwide in
106:17 - the case of this example I'm going to
106:19 - leave it because as you you can see when
106:20 - I run it it will display the same thing
106:22 - as the other ones because this one will
106:25 - also recognize that my current culture
106:27 - is UK and I'm also telling it to use the
106:30 - current culture so in both of these
106:31 - cases it's figured out that my current
106:33 - culture is indeed the UK and it started
106:36 - using the pound sign but let's say we
106:38 - want to give it a different culture then
106:40 - what we can do if we duplicate this line
106:42 - using contr D and remove this section
106:45 - just after the dot we can actually say
106:48 - create specific culture and inside the
106:51 - parentheses we can actually add a string
106:53 - and it says here a predefined culture
106:55 - name or the name of an existing culture
106:57 - info object the name is not case
106:59 - sensitive so in the case of the UK you
107:02 - have English GB and now we need another
107:05 - bracket at the end and then if we use
107:07 - controll D to copy this down we can
107:10 - change GB to us let's run this again and
107:13 - see what
107:16 - happens these two don't actually output
107:18 - anything different because we're just
107:20 - doing the normal culture and then we're
107:22 - telling it to find the GB culture which
107:24 - is exactly the same thing for me so we
107:26 - get these two values exactly the same
107:28 - and apparently it's picking up that in
107:30 - the US you have brackets around your
107:32 - negative values which I can't personally
107:34 - validate but this is how it's showing up
107:37 - so let's try some other cultures and see
107:39 - what happens so we can try Au for
107:43 - Australian then you can see that they
107:45 - actually use a negative followed by the
107:47 - pound sign and then the value so even
107:49 - though they're both in dollars one's US
107:51 - Dollars and one Australian dollars and
107:54 - apparently the US uses brackets for the
107:56 - negative values but Australians use the
107:58 - negative value like we do so let's just
108:01 - have a quick recap so we can display the
108:04 - value just like this but we'll have a
108:05 - problem with multiple decimal places we
108:08 - can use these former options to give us
108:10 - zero decimal places one or two decimal
108:13 - places and then when we use this format
108:16 - the problem with it was when you display
108:18 - negative numbers you get a nasty form
108:20 - format where the negative value actually
108:22 - comes after the pound sign which is not
108:24 - correct and you don't want to Output
108:26 - that to your users instead you should
108:28 - use the C format to tell the compiler
108:30 - that you want to process this as a
108:32 - currency currency processing is better
108:34 - because the software will understand
108:36 - that the value you're trying to
108:37 - represent depends on a certain strict
108:39 - format just as follows you don't want
108:41 - the negative to be here instead of
108:44 - before it because that doesn't look very
108:45 - nice to the end user alternatively you
108:48 - could use this CI info if you're going
108:50 - to scale your program scaling your
108:53 - program means that it's going to live on
108:54 - servers and this culture in for
108:57 - especially the current culture depends
108:59 - on where the program is being run on
109:01 - because it depends on the system time
109:03 - different servers will have different
109:05 - dat times set because they'll be in
109:07 - different countries so you want to be
109:09 - careful and if you want to display in a
109:10 - certain currency you can create a
109:12 - culture specification and pass the
109:15 - country code inside the brackets and
109:17 - then you'll get the correct output and
109:18 - it doesn't matter where your program
109:20 - lives if you always want to generate in
109:23 - pound symbols then you always use create
109:26 - specific culture and always specify
109:29 - NGB upon doing so you'll always get the
109:31 - pound sign and it doesn't matter where
109:33 - your program
109:36 - lives so throughout this course you've
109:38 - seen this notation a lot print out value
109:41 - using console right to give the user an
109:43 - opportunity to write on the same line
109:45 - reading their value as a string and
109:47 - store it in a variable and then use that
109:49 - variable able to convert it to an
109:51 - integer 32 and we're passing the string
109:53 - input inside here and then we convert it
109:56 - to an integer if we run the code you can
109:58 - see that this actually works perfectly
110:00 - assuming you actually enter a real
110:02 - number like 10 we press enter and it
110:05 - works and it outputs back to the screen
110:07 - using this console right line and if you
110:09 - press this restart button we can start
110:11 - the program again and let's say we
110:12 - accidentally type a character like L and
110:15 - we press enter and we've get a format
110:17 - exception now this is problematic
110:20 - because our program will now close if we
110:22 - press continue it doesn't even hit this
110:24 - line or this as soon as it hits the
110:26 - exception in here our program just
110:28 - closes if we use debug start with our
110:30 - debugging and now we're actually running
110:32 - the program outside of visual studio so
110:34 - we won't get that pop up when the error
110:36 - happens let's see what happens if we
110:38 - type this in now we can say 10p and
110:40 - press enter and now we get that the
110:42 - program stopped working you've probably
110:44 - seen this pop up a lot throughout
110:46 - Windows and different versions of
110:47 - Windows because when a program has a
110:49 - fair little error or an exception you
110:52 - see this popup appear and the only thing
110:54 - you can do is either debug or close it
110:56 - normally the debug option isn't
110:58 - available but because this is a c
111:00 - program and it's made through Visual
111:01 - Studio and the visual studio is being
111:03 - installed on the system then it gives us
111:05 - the option but really all we can do here
111:08 - is just terminate the program it doesn't
111:10 - matter what happened because we can't
111:12 - recover this if we press close then it's
111:14 - literally just going to close down it's
111:16 - going to tell us the exception and then
111:18 - press any key to continue and it's as
111:20 - you press any key then the program just
111:21 - closes so this is very fatal for our
111:24 - code since if we had some precious data
111:26 - stored in here or anywhere else in the
111:28 - program it is now lost before we can do
111:31 - anything this is problematic and we want
111:33 - to avoid this the best way to do this is
111:36 - to use something called trass right here
111:39 - the program is assuming that your string
111:41 - input is a perfect input and then you're
111:44 - immediately converting it to an integer
111:46 - now like I said what if this had 10 H in
111:49 - it the program is going to cause an
111:51 - exception and then the program is going
111:52 - to close so let's see what we can do
111:54 - with this trip pass function so the
111:57 - notation is int.
111:59 - trass the first parameter is a string s
112:02 - string s is a string containing a number
112:05 - to convert so what this
112:12 - tripassure equivalent a return value
112:15 - indicates whether the conversion
112:17 - succeeded okay perfect so we'll get into
112:19 - that in a second so our string s is a
112:22 - string containing our number to convert
112:24 - and in this case we want to be using the
112:26 - num input so we copy and paste that down
112:29 - and then we add a comma because we have
112:31 - more than one parameter now we have an
112:33 - out int result when this method returns
112:38 - result which is our integer contains the
112:40 - 32bit sign integer equivalent of the
112:43 - number contained in S and S in this case
112:45 - is our first parameter which is num
112:47 - input if the conversion succeeded
112:50 - then we get the value inside our result
112:52 - or zero if the conversion failed the
112:55 - conversion fails if the parameter s is
112:57 - null or string empty is not of the
113:00 - correct format or it represents a number
113:02 - that's less or more than the maximum
113:04 - value that the integer can stall this
113:07 - paramet is p uninitialized any value
113:09 - originally supplies in result will be
113:11 - overwritten let's dive in to see what
113:13 - this means because it's an out in result
113:17 - what this means is we can actually
113:18 - process a variable inside here like in
113:20 - Num so we can say out num and what this
113:23 - will do is when this line executes it
113:26 - will try and convert num input and place
113:28 - the value inside num so we don't need to
113:31 - run this convert anymore we can just
113:32 - specify that num is equal to zero so
113:36 - we've read in the string that contains
113:38 - our 10 H and we have our num that
113:41 - contains zero let's just remove this
113:43 - console right
113:44 - line so now we have our variable set up
113:47 - let's see what happens if we do a conso
113:50 - right line and just print num after this
113:52 - let's see what happens to the code so if
113:54 - we type in 10 H and press enter the
113:57 - value of num is zero but what you notice
113:59 - now the program hasn't caused because
114:02 - it's tried to pass it instead of just
114:05 - passing it automatically and then cause
114:07 - an exception so the reason why Try pass
114:10 - is called try pass is first it tries and
114:13 - then if it succeeds this will contain
114:15 - the value and if it doesn't succeed this
114:17 - will contain zero to know if the number
114:20 - has actually been converted we actually
114:22 - have to use the bull return value so
114:25 - what this means is because it returns us
114:27 - back a bull we can store it inside a
114:29 - bull and we can give it the name of
114:31 - success bull success equals into. trass
114:34 - we try and pass the num input and we
114:37 - place the value inside num the reason
114:39 - why having this bu success is very very
114:42 - essential let's say for example the user
114:45 - actually enters zero so technically as
114:48 - of this point num zero is actually
114:51 - correct because we've got zero and we
114:53 - initialize it to zero but of course
114:55 - after the trass runs this is still going
114:57 - to be zero now we don't know if the
115:00 - value zero is because this has succeeded
115:03 - or the value is zero because we
115:05 - initialized it to zero let me
115:07 - demonstrate if I type in a zero here is
115:11 - this zero being converted because this
115:13 - was successful or is it presenting me
115:16 - zero because this has been initialized
115:18 - to zero and the only way we can know is
115:21 - because our trip pass will return us
115:23 - back with true if s was converted
115:26 - successfully otherwise false we can
115:29 - actually write an if statement in here
115:31 - if success open the curly braces and we
115:34 - can start to type something in here so
115:36 - we can take our console right line and
115:38 - place it up here using alt and up Arrow
115:41 - key and then in the L's we can say
115:44 - failed to
115:47 - convert so now we have a mini setup here
115:51 - if it's been successful we print out the
115:53 - number if it hasn't been successful then
115:55 - it'll go into this path and it'll print
115:57 - fail to convert let's have a look and
116:00 - see how this works now if I press zero
116:03 - and I see Zero that means it's followed
116:05 - down the success path and this zero
116:08 - actually means it's converted my input
116:10 - instead of just the value that it's
116:11 - being initialized by if you run the code
116:14 - again and type in 10 hit then we
116:17 - actually see it says fail to convert
116:20 - and why that happened is we have 10 H
116:22 - appear and then this will return back
116:24 - false when it tries to convert num input
116:28 - and then after it hits this line since
116:30 - success will be false it will Dodge this
116:32 - path going into this path and output
116:35 - fail to convert what you can do if you
116:37 - really wanted to is you could wrap this
116:39 - around in a while loop so let's see what
116:41 - we can do so we can specify a bu's
116:45 - success and make that equal to true and
116:47 - then we can add a while loop with
116:49 - success in there and then open the curly
116:51 - braces and put all of this code inside
116:54 - here now we're going to have some errors
116:56 - because we got success twice but what we
116:58 - can do which will be a lot easier is we
117:01 - can place this straight inside our
117:04 - bracket and the reason why is because
117:06 - this returns us back at Boolean so we
117:08 - don't need to store it and then use it
117:11 - another thing we can do is instead of
117:13 - having Inn and then num right here you
117:16 - can actually make this a declaration as
117:18 - well so if we just remove this value we
117:21 - can write out Inn and this will do
117:24 - exactly the same thing it just uses less
117:27 - variables while our success is true we
117:30 - come into here and run this code if we
117:32 - fail to convert then we still want it to
117:35 - be true so we can loop around if we've
117:38 - converted it and the value is successful
117:40 - then we can actually make our success at
117:43 - this point false cuz that will stop the
117:46 - W loop from going around let's run the
117:48 - code we can type typ in 10 H 10 a 10 a
117:53 - etc etc and as soon as we type in a real
117:55 - number then it'll print out and the
117:57 - while loop will cancel and now right
117:59 - here we're set on the console readline
118:02 - now if we press enter the program will
118:03 - close so let's have a
118:06 - recap we use in. TR pass so we can try
118:10 - and pass a value before the program
118:12 - assumes that the value is in the correct
118:13 - format we give it a string variable and
118:16 - it returns us back with a fresh new
118:18 - integer called called num or whatever
118:20 - you want to call it inside here we can
118:22 - place this straight inside the condition
118:23 - of an if statement because this function
118:26 - returns us back with a true or false
118:27 - value otherwise known as a bull if this
118:30 - has been successful we stop the while
118:32 - loop and print the value out to the
118:34 - screen and if it hasn't been successful
118:37 - then we print fail to convert and
118:39 - because our success is still true it
118:41 - will L back around to the start of the
118:43 - while loop and ask the user to input
118:46 - another value to try and convert this
118:49 - Loop will only exit if it's indeed being
118:51 - successful and the only way it can exit
118:54 - is by having the success being equal to
118:56 - false and the only way that can happen
118:59 - is by having a successful
119:01 - conversion the use of trip pass in every
119:04 - program is very essential because if you
119:06 - have a fatal exception then your program
119:08 - will close and you will lose all the
119:10 - data the problem with that is you might
119:12 - lose anything that you haven't processed
119:14 - yet at that given point in your program
119:16 - so you want to try and use trass because
119:18 - you'll avoid any potential exceptions
119:21 - and you can let the user know if the
119:22 - conversion has been successful or not
119:24 - and write yourself the same while loop
119:26 - just like this so you can tell the user
119:28 - hey you input it incorrectly but this is
119:31 - how to do it right and make sure that
119:33 - your program doesn't execute incorrectly
119:36 - and make sure your program doesn't just
119:37 - close unexpectedly and then an error
119:40 - will be
119:42 - caused in this exercise I want you to
119:44 - print out some sort of times table and
119:47 - what I mean by this is you want to ask
119:48 - the user us to input a number for the
119:50 - table and then write a for Loop to print
119:53 - out the x * table X is dependent on the
119:56 - value that entered if they enter 10 in
119:58 - here then this will be the 10 times
120:00 - table let's get started so we can have
120:04 - our normal console.
120:05 - write enter a
120:08 - number and then use our int number
120:11 - equals to convert to in32 and we can say
120:15 - console. readline because we want to
120:16 - read whatever the user types in then we
120:19 - have a four into I equal 0 I is less
120:22 - than 10 we're only going to print up to
120:25 - the 10 times table so 1 * Something 2 *
120:28 - something all the way up to 10 times the
120:30 - value that they
120:32 - entered immediately we acknowledge an
120:34 - error here when you do your 10times
120:36 - table for example you do 1 * 10 2 * 10
120:40 - and so on and so forth the issue here is
120:43 - we're going from 0 to 10 but because
120:46 - it's less than 10 we're actually going
120:47 - from 0 to 9 so let changes to one and
120:50 - then less than or equal to 10 in both
120:53 - cases we were actually looping the same
120:55 - amount of times the issue is this was
120:58 - starting on one and the other one was
121:00 - starting on zero and the first one was
121:02 - finishing on nine and this one's
121:04 - finishing on 10 and we want them to go
121:06 - from 1 till 10 instead of from 0 till 9
121:10 - even though that's the same amount of
121:11 - iterations it gives us different
121:14 - values so in here we can just have a
121:16 - console right line and this is how it's
121:18 - going to work work we're going to have
121:20 - our first number times by our second
121:22 - number and that's going to be equal to
121:24 - something so our first number is our
121:27 - value of I cuz that will say 1 time
121:29 - something 2 * something and so forth our
121:33 - second number is whatever the user has
121:35 - typed into the calculation which will be
121:38 - number and our third number is going to
121:40 - be the actual result of the calculation
121:43 - which are these two times together so we
121:45 - can have I star number and that should
121:48 - be it
121:49 - let's run it and give it a
121:51 - shot we can do our 10 times table and if
121:54 - we press enter you can see that it's
121:56 - fully working this will be our I
121:58 - variable going down the side the second
122:01 - number is what the user typed in and the
122:04 - third number is this multiplied by this
122:06 - gives you the output let's run it again
122:09 - with a bigger number and it seems to
122:11 - handle okay and because this is an
122:14 - integer you'll expect to work okay up
122:16 - until around 2.1 billion which is a big
122:19 - number for some times tables anyway so
122:21 - just a quick recap we Loop through from
122:24 - 1 till 10 instead of from 0 to 9 because
122:27 - we made sure that when we do our
122:29 - multiplications we don't want to start
122:31 - the value at 0 * something we want to
122:33 - start the first one at 1 time something
122:35 - and we don't want to end at N9 we want
122:37 - to end at 10 so using one and less than
122:39 - or equal to 10 will get us the values
122:42 - that go from 1 till 10 and that will
122:44 - make our output look a lot more concise
122:47 - we're using conditional format in here
122:49 - adding the zero and curly braces and
122:51 - then the one and then the two and in
122:53 - order to insert the values in it's a
122:55 - comma delimited list after the speech
122:57 - marks the first one goes in the right
122:59 - order zero is I one is number two is I
123:04 - times the number running that code we
123:06 - will get this output there you
123:11 - go so in this exercise I want you to
123:13 - have a look and see if you can make the
123:15 - Fizz bu game Fizz bu game is one of the
123:18 - most popular interview questions you'll
123:19 - come
123:20 - across and the way to do this is to
123:23 - create a for loop from one to something
123:25 - in this case I'm just going to use 15
123:27 - and inside the followup you want to
123:28 - decide if the number is divisible by
123:30 - three and five then you want to print FS
123:32 - buuz if it's divisible by three then
123:35 - it's Fizz five it's buzz and if it
123:37 - doesn't fall into any of them categories
123:39 - then you want to simply just print the
123:41 - number out to the screen let's get
123:43 - started so we can have a four and
123:45 - because we know how many we want to do
123:47 - we want to do in I
123:49 - less than 15 I
123:52 - ++ and then inside here we need to use
123:55 - the modulus operator which is the
123:57 - percentage sign so if you remember from
123:59 - the tutorial in order to figure out if a
124:01 - number is odd or even you could do the
124:03 - number modul is two and if that value is
124:06 - one then it must mean it's odd and if
124:09 - that value is zero it must mean it's
124:11 - even but what we can also differentiate
124:14 - from here is if 10 modulus 2 equals 0
124:17 - then that means that 10 is divisible by
124:20 - two but also it is even and if it's even
124:24 - that means it's divisible by two if it's
124:26 - not divisible by two that means it's not
124:28 - even and therefore it's odd so in this
124:32 - case if we try to divide three and five
124:34 - we can have the same calculation but we
124:37 - can work it out differently so 10
124:39 - modulus 3 actually gives us a value of
124:41 - one because it's three remainder one so
124:44 - if this value is anything other than
124:46 - zero then we know that these two were
124:48 - not div divisible by each other 9
124:50 - percentage 3 equals 0 which means it's
124:53 - divisible by it so in our if statement
124:55 - we can say if I which is the number that
124:58 - we're currently up to
125:00 - percentage 3 equals equals to zero and
125:04 - because we want to check for five as
125:06 - well we want to say and I percentage 5
125:09 - equals equals to zero and that means
125:11 - they're both divisible by each other so
125:14 - we can do a console right line and we
125:15 - can say fiz buzz and then in else if
125:19 - we're going to check if it's three and
125:21 - we can repurpose this exact condition
125:23 - because this just checks if it's
125:25 - divisible by three and then we can print
125:28 - Fizz and then if we copy this exact
125:30 - structure down and change this to a five
125:32 - to check if it's divisible by five then
125:34 - we can print out buzz and in the worst
125:37 - case scenario where none of them get
125:39 - applied then we can simply print I to
125:41 - the screen and actually there's no point
125:43 - in starting at zero because normally
125:46 - these start at one so we'll just do one
125:48 - and we can make it 15 by making it less
125:50 - than or equal to so instead of before it
125:53 - was actually going from 0 to 14 now it's
125:55 - going from 1 to 15 and they will tell
125:58 - you this in the interview they might say
126:00 - counting from 1 to 100 print out all of
126:03 - the Fizz buzzers so let's run the code
126:05 - and see what's going
126:07 - on 1 2 fizz fizz is actually three so
126:11 - three is divisible by three then you
126:13 - have four and then five is divisible by
126:16 - five you get buzz and six goes into
126:19 - three so you get Fizz nine you get Fizz
126:21 - because it's divisible by three then 10
126:24 - / by 5 gives you buzz 11 12 goes into
126:28 - three so you've got Fizz and finally
126:30 - when you hit 15 it goes into three and
126:33 - goes into five so we get Fizz buzz and
126:36 - the way to increase this to 100 is by
126:37 - simply changing this to 100 if you need
126:40 - to and you can scroll through the entire
126:42 - input and you can see all the history if
126:44 - you wanted to make this slightly
126:46 - efficient what you could actually do is
126:48 - store the booing values for these
126:49 - calculations before you can store the
126:52 - values for these calculations before so
126:54 - we can say
126:56 - Bo 3 div equals false and bull 5 div
127:01 - equals false and what we can do at the
127:04 - start of each of the for Loop is we can
127:05 - say three div equals this value and five
127:09 - div also equals this
127:12 - value and then every time we find a
127:15 - calculation for three or calculation for
127:18 - five we can replace it with either three
127:20 - div or five div so let's change this one
127:23 - here and this one here and our five here
127:28 - and here and because these are values
127:31 - now we want to actually store them as
127:33 - true or falses so we don't need to check
127:35 - if they're equal to zero so we can just
127:37 - remove them so we can say if three div
127:40 - and five div are both true and they'll
127:42 - only be true if these two are both zero
127:45 - now if we run the code and just make it
127:47 - 15 again just just we have a Shor output
127:50 - you can see that our code is exactly the
127:51 - same the reason why this is more
127:54 - efficient is we're only doing this
127:55 - calculation twice whereas before we were
127:58 - doing it twice for three and twice for
128:00 - five now we're doing it once storing it
128:04 - and then making use of it this is a lot
128:06 - more memory efficient than having to
128:07 - calculate it every single time it
128:09 - computes a lot faster and it's better
128:11 - for readability if the rules of the game
128:14 - happen to change and this was divisible
128:15 - by four or six then you could just
128:18 - change it very easily whereas in the
128:20 - previous example you would have to
128:21 - change it in every single
128:24 - case in C when you're constructing
128:27 - strings that have backslashes you're
128:30 - going to need to use double backslash
128:32 - and the reason for this is the first
128:34 - backslash is an indication that it's
128:36 - actually going to be an escape character
128:38 - you're going to put an escape character
128:40 - in and then put the character that you
128:42 - want to display and the reason for that
128:44 - is they've chose backslash as the
128:46 - designated character so so you can use
128:49 - backs slash and then a backs slash to
128:51 - show one backslash only and what this
128:54 - means is it will use the first backs
128:56 - slash as a reference so it knows that
128:58 - it's going to process the next character
129:01 - as an escape character I want these
129:03 - Escape characters are you can have
129:05 - things like T for tab n for new line and
129:09 - you can even use speech marks because if
129:12 - you outputting some dialogue and you
129:14 - wanted to say something like this he
129:17 - said
129:19 - and then you added your own quote in
129:22 - there if you want to put something in
129:24 - quotes then you can't because the speech
129:26 - mark dictates that this is the end of
129:28 - the string literal that's why it's
129:30 - gotting it off like this and then now
129:32 - it's not recognizing that something is
129:34 - just wrote here and what it's actually
129:36 - doing is you've got two strings
129:38 - specified one that says he said space
129:41 - and one that's just empty and then you
129:43 - just have this something that's just in
129:45 - the middle of course we actually want to
129:47 - insert the speech marks within another
129:50 - pair of speech marks this is where the
129:52 - backslash comes in so you can insert a
129:54 - backslash before here and this is now
129:57 - acceptable and the same thing with the
129:59 - normal backslash because the backslash
130:02 - character is also going to be the Escape
130:04 - character then you need a double
130:06 - backslash so then that equals to a
130:08 - single backslash when you print it out
130:11 - let's Show an example so we have C colon
130:14 - SL slash which will return us back a
130:16 - single slash but visually right now it's
130:19 - a double slash but when it gets
130:21 - processed or outputed to the screen
130:23 - you'll see that it's a single slash so
130:25 - this common example is when you're
130:27 - constructing a path together and you
130:29 - want to use backs slashes to denote the
130:31 - different directories so let's output
130:34 - this to the screen and see what
130:36 - happens and as you can see we have a
130:38 - single backslash because of the Escape
130:40 - character we don't see both of them and
130:43 - if we print the Spree out to the screen
130:45 - just to show you that as well then we
130:47 - can see that there's only the speech
130:48 - marks around the something and we don't
130:51 - have the backslash you can tell when an
130:53 - escape character is being used because
130:55 - it goes a slight hint of yellow instead
130:58 - of the normal color for a string so now
131:00 - that we've worked out that this is how
131:02 - this works let's see a way that we can
131:05 - undo this to make it easier for us so
131:08 - you've used the dollar sign for string
131:09 - interpolation and you've used the plus
131:11 - just to concatenate two variables
131:14 - together and just as a quick example it
131:16 - looked something like this your name is
131:19 - and then the name variable and using the
131:22 - plus you would say your name is followed
131:25 - by a space and the quotation marks and
131:27 - do plus name that's fine and now we have
131:30 - another one so similar to how we placed
131:32 - a dollar sign before the speech marks we
131:35 - have a Verbatim identifier and what this
131:38 - means because it says verbatim it just
131:40 - means whatever you see is whatever
131:42 - happens so let's try and Define this
131:44 - path a slightly different way but still
131:46 - containing the exact same information
131:49 - that you see when you print out to the
131:51 - screen so let's have a look we can
131:54 - reassign the path value and just before
131:57 - the speech marks we can put it at symbol
132:00 - and this at symbol means it will
132:02 - actually negate all of the Escape
132:04 - characters it will process a single
132:06 - backslash as a single backslash let's
132:10 - take this line of code and place inside
132:12 - here now what you see is that tint of
132:15 - yellow is no longer there so if we print
132:17 - this past to the screen let's see what
132:20 - happens we actually get the double
132:22 - backslash because it's ignoring all the
132:24 - Escape characters which means if we take
132:26 - them all out this actually looks exactly
132:29 - how we want and you don't have to worry
132:31 - about the Escape
132:33 - characters there you
132:37 - go these two are identical even though
132:40 - one is being displayed using Escape
132:41 - characters and ones using the verbatim
132:44 - identifier please note that if you're
132:46 - going to use the back slash n for
132:48 - example and I'll just demonstrate at the
132:50 - end of this new line test and if we run
132:53 - that code again you'll see that it's
132:54 - printed the path on one line the back
132:57 - sln has made it go on to the next line
133:00 - and now it's printing new line test on a
133:02 - dedicated line that's fine the problem
133:06 - is if you use a back sln or a back SLT
133:09 - or any of these Escape characters during
133:12 - the at symbol then it's going to process
133:14 - it as literal characters which means you
133:16 - can't mix a back n with an at symbol AS
133:20 - this is just taking the text verbatim so
133:23 - if we try to run the code now you'll see
133:25 - the back sln will actually appear in the
133:27 - code if you wanted to do this then maybe
133:30 - you could remove the back slash n and
133:32 - add a plus at the end and then make
133:34 - another string that just has a back sln
133:37 - and then this string will not be
133:39 - processed as a Verbatim string because
133:41 - we don't have the at symbol right before
133:44 - it so then we can have the exact same
133:46 - thing here just to show you
133:49 - this so now these two are identical
133:52 - again just as shown here and as shown
133:56 - here the difference being that we can't
133:59 - specify a back sln in the same string we
134:01 - actually have to concatenate them
134:03 - together because of the verbatim
134:05 - identifier so let's have a look at
134:07 - speech
134:09 - marks so if we have a string name and we
134:12 - can make this equal to hello and then
134:15 - someone and we said before that we have
134:18 - to use the backslash so we can activate
134:20 - the Escape characters and that will work
134:22 - and if we just print that to the screen
134:24 - to make sure then we get hello someone
134:26 - in the speech marks if we add the
134:28 - verbatim identify at the start then we
134:31 - see we've got an error it's trying to
134:33 - process it
134:34 - differently this is a little Quirk with
134:37 - the verbatim identifier if you want to
134:39 - insert a speech marks you actually want
134:41 - a double speech mark on either side the
134:44 - double speech marks will get processed
134:46 - as a single speech mark because it's
134:48 - within a speech mark the verbatim
134:51 - identifier needs to know that you're
134:53 - specifying a speech mark and this acts
134:55 - as a same reason why you have a
134:57 - backslash here it's slightly quirky
134:59 - doing it this way but it still works as
135:01 - per you
135:02 - expect and when you're specifying
135:05 - something like name and we can say hello
135:08 - someone so let's print name to the
135:09 - screen and make sure it works in this
135:12 - case we don't actually need to specify
135:13 - any sort of Escape character because the
135:16 - quotation mark is a separate character
135:18 - to the speech mark and it doesn't
135:20 - interrupt anything by placing a
135:22 - quotation mark inside the string just
135:24 - represents that as its own character
135:26 - let's run that and make sure it works
135:28 - there you go so just as a quick recap
135:32 - Escape characters are very essential
135:34 - because we can use things like back SLT
135:36 - to give us a tab character in our
135:38 - console output this can be very helpful
135:40 - cuz you can almost mimic the use of
135:42 - columns inside our console output you'll
135:45 - notice that back sln is used quite a lot
135:48 - in the console output so you can
135:49 - separate lines without having to use
135:51 - multiple console right
135:53 - lines if you have a single backslash you
135:56 - can't have it on its own if the string
135:58 - is not a Verbatim string you have to
136:01 - pair it with another character otherwise
136:03 - you will get a syntax error if you want
136:05 - to use the verbatim string then you can
136:07 - put an at symbol before the string
136:09 - definition and then it will ignore all
136:11 - of the Escape characters for example
136:14 - using back sln within these speech marks
136:16 - will mean that the back SL n will
136:18 - literally be printed to the screen and
136:20 - you won't get the new line functionality
136:22 - that back sln provides when you want to
136:24 - print speech marks of the screen using
136:27 - the verbatim identifier you have to use
136:29 - a double speech marks in order for it to
136:31 - show up and as you can see it slightly
136:33 - goes yellow and that's the similar
136:35 - notation as using Escape character when
136:37 - you don't have an verbatim string if
136:40 - you're using other characters that are
136:41 - similar to a speech mark like a
136:43 - quotation mark because this doesn't
136:45 - interrupt the syntax of the language
136:48 - then this is fine because a character
136:50 - can just be inside a string and to the
136:52 - compiler this is just a character even
136:54 - though they are very similar the
136:56 - quotation mark doesn't affect the speech
137:01 - mark the most common approach for
137:03 - outputting values to the console is by
137:05 - having this format you type something in
137:08 - as a static string and then you add a
137:10 - variable to it but when you're doing
137:12 - long sentences this format can get messy
137:15 - quite quickly so this will just output
137:17 - both of these on separate lines the name
137:20 - followed by the name variable and the
137:22 - age followed by the age variable I just
137:25 - have a console right line to split up
137:27 - these two sections just so you can see
137:28 - it visually in the console so if we run
137:31 - this code you can see that both the
137:33 - outputs are exactly the same and the
137:36 - reason why is we can use this back sln
137:39 - what this back sln is doing is inserting
137:41 - a new line character just where my
137:43 - cursor is here which is forcing The Edge
137:46 - to jump onto the next line the reason
137:48 - why this is a slightly different shade
137:50 - to the age text is because it's an
137:52 - Escape character back sln means new line
137:56 - we'll explain this in a further video in
137:58 - this section so don't worry about that
138:00 - just know that it means that it produces
138:02 - a new line so as you can see since we're
138:04 - adding the name followed by the name and
138:06 - then the age followed by the ede then
138:08 - it's getting a bit long and a little bit
138:10 - tedious it's not too bad in this case
138:13 - because we're not really printing out a
138:14 - sentence we're just going straight to
138:16 - another line but let's see what this is
138:18 - going to look like if we start dealing
138:20 - with multiple pits of data your name is
138:24 - followed by the name and then we can add
138:27 - a comma and your age is and then add the
138:31 - age and as you can see while we're
138:33 - structuring a sentence then it gets a
138:35 - little bit long we have to remember to
138:38 - put in the spaces otherwise our code is
138:40 - going to look funky when we print out to
138:42 - the screen and the reason for that is
138:45 - there's no spaces between the name and
138:47 - the age variables so let's put them back
138:49 - in and make sure the output looks all
138:53 - right now that the output looks like
138:55 - this let's explore composite formatting
138:57 - and what this means is we can get rid of
138:59 - all of these plus symbols and replace it
139:01 - with curly braces so let's actually
139:04 - output this string again but just output
139:06 - it completely static your name is
139:09 - abber and your age is
139:12 - 23 and now if we've run this you'll see
139:15 - that both outputs are identical this is
139:18 - because I know the values for the string
139:19 - variables up here and I can input it
139:22 - straight into here so now that we know
139:24 - what our sentence is going to be we
139:26 - don't need to add any pluses what we do
139:28 - need to do is remove our variables so in
139:31 - the case of this sentence our name
139:33 - variable is here and our age variable is
139:35 - here so we can replace this with this
139:38 - curly brace notation we can have curly
139:41 - BRAC and then we want to start this
139:43 - value at zero throughout the string you
139:46 - want to have these values starting from
139:49 - zero and going up incrementally from
139:52 - left to right so our next variable would
139:54 - be our 23 and we can store it like this
139:59 - now that it's got your name zero and
140:01 - your age one let's see what happens when
140:03 - you output it then we just get this and
140:05 - this is very confusing that's because
140:08 - we're not done yet so now that we've got
140:10 - our string typed in we can actually
140:12 - place a comma in here and now it lets us
140:15 - put any object in and any object could
140:18 - be a string an in a double or any data
140:20 - type so we want to insert the values
140:23 - inside here going from left to right so
140:26 - our name is first and then we do a comma
140:29 - and we type in Age and what this now
140:31 - says is the name will get replaced by
140:33 - the curly brace zero and the age will
140:36 - get replaced by the curly brace one so
140:39 - now if we run the code let's see what
140:41 - happens and now you'll see that the
140:42 - output is exactly the same and now look
140:45 - at the difference between these two
140:47 - lines you'll see that these multiple
140:49 - amount of pluses are not confusing and
140:52 - let's say you forget this one then
140:54 - you're going to get a syntax error and
140:55 - it's a bit frustrating to keep on typing
140:58 - when you're trying to join things
140:59 - together now we can clearly see that
141:01 - this flaw is like a sentence and this
141:03 - space here looks very unnatural but this
141:06 - space here looks like it's part of the
141:08 - sentence which makes our code a bit more
141:11 - complete and the same goes if you want
141:13 - to print something like this and let's
141:15 - convert this one so if we copy this line
141:18 - down into here and we just remove the
141:20 - spaces then it can look something like
141:24 - this name followed by the name we don't
141:27 - actually need this space here because
141:28 - we're going to be going into a brake
141:30 - line we can replace our name with curly
141:32 - braces zero and our age with curly
141:35 - braces one and then straight after we
141:38 - can type name and age and if we output
141:41 - this we'll see it's exactly the same
141:43 - there we go so just a quick recap print
141:47 - ing strings and any other variables to
141:49 - the screen has been normally achieved by
141:51 - doing a string followed by a plus and
141:54 - then adding another variable to it
141:56 - adding more than one can be a little bit
141:58 - complicated and hard to track of all the
142:01 - spaces that you're going to put in and
142:02 - you might accidentally miss one of them
142:05 - like this one here or this one here are
142:07 - very crucial to the output if you miss
142:09 - this one then it's going to say is
142:11 - followed by the name all together with
142:14 - no space we then introduce composite
142:16 - format in which lets us use this
142:18 - notation of curly brace Z and curly
142:21 - brace one to give us the ability to
142:23 - store some variables outside of the
142:26 - string and then insert them in
142:29 - dynamically we took both of these
142:31 - examples and made them down here using
142:34 - composite
142:36 - forming so let's explore a new method of
142:39 - concatenation that makes this look a lot
142:41 - better the reason why this is an issue
142:43 - is you have spaces in here and sometimes
142:45 - you might forget these spaces and it
142:47 - could mess up your program this string
142:49 - here looks very unnatural because you're
142:51 - forcing the space but when you run it
142:54 - you'll see that it is actually what you
142:55 - expect the spaces are complete and it
142:58 - makes perfect sense but when you're
143:00 - writing it it kind of looks a little bit
143:02 - stupid because you're forcing the space
143:05 - and then adding a plus and then the name
143:07 - and then another plus and then another
143:09 - static string and this just get a little
143:11 - bit long to type it's fine when you have
143:13 - a smaller sentence like this but when
143:15 - the program starts to grow it could be a
143:17 - little bit problematic and you'll have a
143:19 - lot of syntax errors when you forget to
143:21 - type in all the pluses locally this can
143:23 - be fixed let's duplicate this line down
143:26 - and let's see what we can do so we have
143:28 - this thing called string interpolation
143:30 - and it uses a dollar sign as a reference
143:33 - we can place the dollar sign before the
143:35 - quotation marks and then what you can do
143:38 - is you can actually keep this as one big
143:40 - sentence so let's remove all of the
143:43 - values and have it like this so now of
143:46 - course this actually doesn't print our
143:47 - variables because we've just replaced it
143:49 - with text so if we just run this then
143:51 - it's completely messed up because now
143:53 - we're not using our variables and this
143:56 - can be easily fixed because we've used
143:58 - our dollar sign now we can actually wrap
144:00 - our variables in this curly brace and
144:03 - now you can see it's went white if I
144:05 - double click on it you can see that it's
144:06 - referencing the
144:08 - variable wrapping the variables in the
144:10 - curly brace means that they can actually
144:12 - be processed variables even though they
144:14 - are still within the speech marks please
144:16 - do not remove the dollar sign because
144:18 - now this will be interpreted as string
144:20 - text as you can see here putting a
144:23 - dollar sign at the start will make into
144:25 - string interpolation and then we get the
144:27 - ability to have our brackets this can
144:30 - make string concatenation very easy to
144:32 - do because you don't have to worry about
144:34 - all the pluses and adding them together
144:37 - and don't have to worry about the spaces
144:38 - as well this looks more like a natural
144:41 - sentence and what you can do for
144:43 - practice is you can actually just type
144:44 - out the sentence your name is AB
144:47 - your age is 23 and then from there you
144:51 - can actually just break down the
144:52 - variables and know that you'll need one
144:54 - here so you can replace that with name
144:57 - and then you'll know you'll need one
144:58 - here so you can replace that one with
144:59 - age and then you can place the dollar
145:02 - sign right at the end and then there you
145:04 - go you have your solution this method
145:06 - means that it's a lot cleaner to read
145:09 - easier to maintain and make changes in
145:11 - the future and that's the whole point of
145:13 - programming if your code base is very
145:15 - difficult to go around and understand
145:17 - what's going on and potentially make
145:19 - changes in the future then you've
145:20 - already made a bad step and you don't
145:22 - want to get into these nasty habits it's
145:25 - fine if you're just going to have
145:26 - something like this where it's not
145:27 - really complicated at all a string plus
145:30 - another string that's quite simple and
145:32 - that's fine you don't have to go the
145:34 - extra effort to put in the dollar sign
145:36 - and wrap it around in the curly braces
145:38 - even though I personally still would
145:40 - because in my personal opinion this
145:42 - looks a lot
145:44 - better than having it like that you can
145:47 - see that it's a lot neater it takes up
145:49 - less code and you can see visually that
145:51 - you're using a specific variable and you
145:54 - don't have to worry too much about the
145:55 - spaces because this looks like a real
145:59 - sentence explore another method of
146:01 - string concatenation which is the idea
146:03 - of taking strings or objects and add
146:06 - them together to form a sentence of
146:07 - sorts we can say your name is followed
146:10 - by a space and then add the name
146:13 - followed by a space add your ages and
146:15 - then add the actual age variable
146:17 - and we can also write the exact same
146:19 - line using string interpolation or
146:21 - composite formatting just like this and
146:24 - like this we can specify the dollar
146:27 - symbol and put our variable in the
146:29 - bracket which is shown here and here and
146:32 - for the composite formatting we can take
146:34 - the content where our variable would go
146:36 - and replace it with incremental numbers
146:39 - 0 and one wrapped around in a curly
146:41 - brace and then specify in the correct
146:43 - order zero takes a value of name and one
146:46 - one takes a value of age if we run this
146:49 - code you'll see that the outputs are
146:51 - identical so let's explore this other
146:54 - method we have a string test for example
146:57 - and then inside the string Library we
146:59 - have this function called concat and it
147:01 - can taking any amount of parameters that
147:03 - we want to give it so we could say your
147:07 - name is space and the quotation marks
147:10 - and then we can add a comma and then we
147:12 - can say we want to add the name and then
147:14 - another comma and we want to add and
147:16 - your
147:17 - ages and the speech marks add a comma
147:20 - add the age variable and that's it and
147:23 - we could just use CW tab tab and type in
147:25 - test and let's run it and see what
147:28 - happens and now as you can see we get
147:30 - the exact same output and because this
147:32 - just returns us back with a string we
147:34 - can also just take this entire line and
147:37 - paste it straight into the console right
147:38 - line you don't necessarily have to store
147:40 - it but you can if you want to and there
147:42 - you go all methods produce the same
147:44 - output another way you can use this
147:46 - concap function is by giving it an array
147:49 - we haven't covered arrays so far so I'm
147:51 - just going to show you this for
147:52 - demonstration purposes don't worry about
147:54 - understanding it so just a quick
147:56 - explanation arrays are just ways of
147:58 - storing multiple of the same data type
148:00 - so if we have these three names inside
148:03 - our names we can actually use the
148:05 - console to print them all out so we can
148:08 - say string. concat and then we can
148:10 - concut the names together which will
148:12 - just add all of these three together now
148:14 - the problem is when you've run it you'll
148:16 - see this stuck together so what you
148:18 - could do is just add a space between
148:20 - them and as you can see this is getting
148:22 - a little bit tedious
148:23 - now there's other methods that we can
148:26 - use to concat some arrays together and
148:28 - I'll show you that in the next section
148:29 - but for now don't worry about it this is
148:31 - concentrating on the string concat
148:33 - function and we'll just demonstrate that
148:35 - again so if we run the line of code we
148:37 - can see that they're all the same so now
148:39 - that you have four different methods of
148:41 - printing out exactly the same
148:42 - information you might be asking yourself
148:45 - what's the best method I personally
148:47 - prefer to use the string interpolation
148:49 - because with this one you can easily
148:51 - miss the spaces and you could produce a
148:53 - bad output and it might be stuck
148:55 - together it's fine when you can see the
148:57 - lines right in front of you and you can
148:59 - easily identify the spaces but when
149:01 - you're adding about 10 variables
149:03 - together then it could be a problem the
149:05 - reason why I like string interpolation
149:07 - using the dollar signs and the variables
149:09 - in the curly braces is that you don't
149:11 - have to rely on missing out spaces
149:13 - because it actually forms a sentence and
149:15 - you just replace the use with your
149:17 - variable composite formatting which is
149:19 - this one is very efficient and very nice
149:21 - to look at because it allows you to
149:24 - specify the sentence and then plug in
149:26 - the variables after the only problem
149:28 - with this is if you were to change this
149:29 - value in the future or to change a
149:31 - sentence you have to make sure that the
149:33 - numbers add up just like in the first
149:35 - example if you only have a short
149:37 - sentence then this isn't really an issue
149:39 - since you can see it all visually and
149:41 - you also got to realize that these need
149:42 - to be in the right order because if you
149:44 - put Age first then it's going to put age
149:46 - in this one and name in the second one
149:48 - and that's going to be problematic cuz
149:50 - it now mess up the sentence using string
149:53 - interpolation you don't actually have to
149:54 - worry about anything because if you
149:56 - wanted to change this to say your age is
149:59 - then you simply just do this and that's
150:01 - very easy to do because in this case
150:03 - you'd say your age is and then you'd
150:05 - have to change a string and then now
150:07 - that this is zero we need to change this
150:10 - from being age and this one to be name
150:13 - whereas in the first example you could
150:14 - just easily change the value in the
150:16 - curly braces instead of changing this
150:18 - reference and the end reference cona is
150:21 - not widely used just because you have
150:23 - all of these methods available where you
150:25 - can easily add stuff together but there
150:27 - could be user cases later on down the
150:29 - line where users just so it's a bit more
150:31 - obvious and it helps the readability of
150:33 - your code and maintain within a big
150:35 - project or just on your personal
150:37 - projects when you're looking back at
150:39 - your previous
150:41 - code when you create and initialize a
150:44 - string variable you might want to give
150:45 - it the value of an empty quotes and this
150:47 - will just default the value to
150:49 - essentially nothing you're giving it a
150:51 - value but at the same time the value
150:52 - doesn't actually contain any sort of
150:54 - characters if we print this out to the
150:56 - screen then you won't really see
150:57 - anything this video is going to focus on
150:59 - string.empty and string.empty will
151:02 - actually just represent these quotation
151:03 - marks string. empty will represent these
151:06 - speech marks so what we can do is we can
151:08 - type in string using a DOT and then we
151:11 - can type in empty just like that we've
151:13 - initialized our string name to a value
151:16 - of empty
151:17 - now this isn't necessarily used when
151:19 - you're declaring and initializing it
151:21 - because this is almost identical to just
151:23 - defining a string on its own main reason
151:25 - why this is used let's say we actually
151:27 - ask the user to input their name so we
151:29 - can say a console. write enter your name
151:32 - and then we can take this string
151:33 - variable move it down use an alt and
151:36 - then arrow keys and remove this and
151:38 - let's initialize it to a
151:40 - console.readline to read in the value
151:42 - from the
151:43 - console and now what we can do is using
151:45 - our is string interpolation method that
151:48 - we just learned we can print to the user
151:50 - your name is and then the name in The
151:51 - Curly braces now let's just see what
151:54 - happens so let's actually type our name
151:56 - in Abba and it says your name is ABBA
151:59 - but what if the user just types in
152:00 - nothing and just presses enter Then it
152:02 - still says your name is blank now let's
152:04 - see what we can do here we don't
152:06 - necessarily want to say your name is
152:08 - blank we want to check what this value
152:09 - is so we can say if the name is not
152:12 - equal to empty quotation marks then we
152:14 - can output your name is and then then
152:17 - else we can say name is empty and then
152:20 - if we run it now and press enter it says
152:22 - name is empty so we can use string.
152:25 - empty instead of these quotation
152:28 - marks this looks a lot better when
152:29 - you're trying to compare it AB your name
152:32 - is Aba and then when we press enter it
152:34 - says name is empty this just helps to
152:37 - keep your code a lot tidier just so you
152:39 - don't have to write the two quotes if
152:41 - you accidentally put a space in there
152:43 - now your if statement is incorrect if
152:45 - you always use string. empty then it
152:47 - just helps you to make sure that your
152:49 - code is going to be maintainable and
152:50 - readable in the future reading
152:53 - string.empty gives you a better
152:54 - representation of what's going on
152:56 - instead of two open
152:59 - quotes if there is a situation where you
153:02 - want to check if one string equals
153:03 - another string then you can do the
153:06 - following if message equals equals
153:09 - compare then we can print out same and
153:12 - then else we can print out
153:15 - different and as we can see here they
153:17 - both have a capital H and they both say
153:19 - hello so they should be identical let's
153:22 - run the code and find out so they say
153:24 - same which is exactly what we'd expect
153:27 - so we have another method of being able
153:29 - to do this so even though we can apply
153:31 - equals equals to two strings it's
153:33 - normally better practice to use do
153:35 - equals and then place the other string
153:37 - inside the brackets so you're saying if
153:39 - message equals compare now if you run
153:42 - the code you'll see that it's the same
153:44 - output in certain circumstances where
153:47 - you want to ask what the user has
153:48 - entered enter your name and then we can
153:52 - use a string name equals console.
153:54 - readline we can say if the name does not
153:58 - equal to empty strings then from there
154:01 - what we can do is type in your name is
154:05 - plus
154:06 - name and then we get some output
154:09 - your name is abber but since we're
154:11 - checking if it's not equal to that that
154:13 - means they've entered something in let's
154:15 - see if there's another way that we can
154:16 - actually write this so if we just
154:18 - duplicate it and comment it out so we
154:20 - got it for reference so what we want to
154:22 - do is we're checking if name is not
154:24 - equal to empty quotes so we can say name
154:28 - do
154:29 - equals empty quotes but what this is
154:31 - telling us if the name equals empty
154:33 - quotes then we should do this so then
154:35 - what we can do when we learn about the
154:37 - if statements is we can use the not
154:39 - operator and we can say if the name not
154:42 - equals to empty quotes then we proceed
154:44 - with this line L we can just
154:48 - say invalid name
154:51 - input let's run that and see what
154:53 - happens to type in AB then it passes
154:55 - fine and if we type in nothing then we
154:57 - get an invalid name input the reason why
155:00 - equals equals and the do equals function
155:02 - are different is because lower level
155:05 - using equals equals will actually
155:07 - compare the reference in the memory and
155:09 - the reference in the memory is what's
155:11 - used up when you actually create these
155:13 - variables so what this is doing is it's
155:16 - comparing the value that's actually
155:17 - stored in memory to the other one that's
155:19 - stored in memory now the problem is when
155:22 - it comes to something like arrays where
155:24 - you actually have the same value but
155:26 - they're slightly different let me
155:27 - demonstrate so I'm just going to use
155:29 - this code because we haven't covered
155:31 - arrays yet so I'm just showing you an
155:32 - example if we have a chart array that
155:35 - literally says hello and then we can use
155:37 - this line of code to join them together
155:40 - but this is actually an object instead
155:42 - of a string but if you see what we can
155:44 - do in the if statement we can say save
155:46 - the message which is equal to hello we
155:49 - can use message. equals and we got the
155:51 - new compare and this is actually an
155:53 - object so now we're comparing a string
155:56 - with an object and generically speaking
155:58 - an object can hold any sort of value
156:01 - because all of these variables that are
156:03 - strings ins double Etc they're all
156:05 - derived from something called an object
156:07 - which is just a very generic way of
156:09 - storing information so since these two
156:11 - data types are little bit different they
156:13 - still evaluate to the same thing what
156:16 - the equals function is doing is actually
156:18 - checking the literal values of the
156:20 - variables instead of checking the values
156:22 - that are held inside the memory address
156:24 - location and the difference here is even
156:26 - though we have a character array that is
156:28 - giving us the values hello and our
156:31 - string is also given us the value of
156:33 - hello if we run this line of core that
156:35 - uses do equals then you'll actually see
156:38 - that the second same actually represents
156:40 - the bottom if statement so what that's
156:42 - doing is it's actually giving us back
156:45 - the comparison saying that it's true and
156:47 - it is indeed true because hello is
156:49 - literally equal to hello but if you were
156:52 - to use the double
156:54 - equals then what you'll realize when you
156:56 - run the code is now it will say it's
156:58 - different because what it's doing now is
157:01 - it's taking a string object and
157:03 - comparing it to an object and they are
157:06 - not different because of their memory
157:08 - and that's what the equals equals is
157:10 - comparing it's not only comparing the
157:12 - value it's comparing the memory address
157:14 - location and that's going to going be
157:16 - vastly confusing because you don't want
157:18 - to hit these situations so it's always
157:20 - best to use the equals function because
157:22 - the equals function is concerned about
157:24 - the values rather than where they are in
157:27 - your memory I hope that made sense and
157:29 - it wasn't just confusing but basically
157:31 - when you use equals equals it checks the
157:34 - values that are actually wrot in your
157:35 - computer's memory instead of the value
157:38 - itself it will do both it will check the
157:40 - memory and check the value whereas when
157:43 - you use do equals it is only concerned
157:45 - about about the values and that's all
157:47 - that matters when we're doing an if
157:48 - statement like this we're checking if
157:50 - they're both the same so it shouldn't
157:52 - really matter how and where they are
157:54 - stored the only thing that matters is
157:56 - the values contained within the variable
157:58 - we're only caring about the values and
158:00 - not where they're
158:03 - stored so when we have a string variable
158:05 - defined in C we have it like this and
158:08 - when we print it out to the console we
158:10 - get the entire string being
158:12 - displayed but what if you want to return
158:14 - the first element back not the rest then
158:16 - what are your options so in the later
158:18 - video in the course we covered the
158:20 - substring function and technically you
158:22 - could go from the first character till
158:24 - the second character and you will just
158:26 - get C back so that's index zero till
158:28 - index one and you'll get the C back now
158:31 - the problem with that is that's an extra
158:32 - function call or something that should
158:34 - be quite simple and it is a message is a
158:36 - string and strings tend to be an array
158:39 - of characters which is similar to this
158:42 - we haven't learned about arrays so far
158:44 - and we'll cover that in the next section
158:46 - but what an array essentially is is it
158:47 - lets you store multiple of that data
158:49 - type so we could have a chart array that
158:52 - holds exactly the same value and each
158:54 - position will hold each one of these
158:56 - characters and the reason why I'm
158:58 - mentioning this is because with strings
159:00 - you can use the square bracket notation
159:02 - so if you add some square brackets at
159:03 - the end it says here it returns back a
159:05 - Char and it takes in an index gets the
159:09 - CH object at the specified position in
159:11 - the current string object so if we use
159:13 - message zero you can see that returns
159:15 - back with a ch ch right here gets the CH
159:18 - object so we can call this on a string
159:21 - and it can return us back with a
159:23 - character because like I said with the
159:25 - array of characters that's essentially
159:27 - what a string is each one of these is
159:29 - just its own independent character and a
159:32 - string lets you pair them all together
159:34 - so if we print this out then we should
159:36 - get C because it's zero based so if we
159:38 - copy this down and use
159:40 - one 2 and three then what should we get
159:44 - we get C
159:46 - then we get actually nothing technically
159:49 - because it's a space character and then
159:51 - the third character which is the fourth
159:53 - in the list because it's zerob based is
159:55 - going to be our I so let's just print
159:57 - this out to the screen and see what
159:58 - happens there we go so even though we
160:00 - don't see it visually there's actually a
160:02 - space character right there and that's
160:04 - the third character in The List which is
160:06 - right here so of course we don't tend to
160:09 - know how long the string is unless we
160:11 - can see it visually and if you were to
160:13 - reference one of these values and the
160:15 - string is not actually that long then
160:17 - you have a problem let's demonstrate if
160:19 - we have the string just called C and
160:21 - let's comment out the rest then that's
160:24 - only two characters so only zero and one
160:26 - will be applicable these two will return
160:29 - back something let's have a look and see
160:31 - what happens so the first character and
160:33 - the second character will run fine and
160:35 - let's put a console read line in there
160:37 - just to break it up so the other code
160:39 - doesn't run yet if we run the code we
160:41 - get our C and that's the max length of
160:44 - our string so so far it's zero and one
160:47 - now if we press enter let's see what
160:49 - happens we get an index out of range
160:52 - exception index was outside the bounds
160:54 - of the array and the reason for that is
160:56 - we only have two characters inside our
160:58 - message and we're trying to display the
161:00 - third and the fourth this is problematic
161:03 - because we literally don't have any of
161:04 - them characters to
161:06 - display so what we can do instead is
161:08 - actually write ourselves a little Loop
161:10 - to go through the entire string and
161:12 - return us back all of these character
161:13 - positions instead of us just get ing how
161:15 - long the string is so if we return this
161:17 - string back to normal and then just
161:19 - after this little section we can write a
161:21 - for Loop in I equals 0 and I is less
161:24 - than message and then we have access to
161:27 - dot length this gets the number of
161:29 - characters in the current string so we
161:31 - don't have to worry about the maximum
161:32 - length in the square brackets we can
161:34 - always rely on do length because we
161:37 - don't have to keep track of it and the
161:39 - language can know that for us and give
161:40 - us the
161:42 - value in this case we're going from zero
161:44 - to whatever the length is these
161:45 - characters are and then in here we can
161:48 - actually just console right line and we
161:50 - can do the same notation we did here
161:52 - we're say we want to print the message
161:54 - but not only the message we want to
161:56 - print the index and the index is going
161:58 - to be I in this case because we start at
162:01 - zero since it's zero based and then
162:03 - we're going to the last character so
162:05 - let's print this and see what
162:07 - happens so now we get C Is Awesome from
162:10 - here down to the bottom c is awesome
162:13 - print on every single line and that's a
162:15 - little bit annoying to read so what we
162:17 - could do is just change this to a
162:18 - console right and maybe we can just
162:20 - comment this section out just so we can
162:22 - see this
162:25 - properly there we go so we get c is
162:27 - awesome and because it's a console right
162:29 - it's right in them all next to each
162:31 - other and they're being printed out one
162:32 - by one let's add a cool little effect
162:35 - that can demonstrate you for now so
162:37 - inside the system. threading Library we
162:39 - have this sleep function so what we can
162:42 - do is we can add another using command
162:44 - system do threading we already have
162:47 - threading do tasks in there but the
162:49 - function that we need is inside the
162:50 - threading Library so there's two ways we
162:53 - can write this we can actually write
162:54 - everything by hand like this do sleep or
162:58 - you could just remove the system do
163:00 - threading because we've added it at the
163:02 - Top If you don't want to add it at the
163:03 - top that's not really a problem you can
163:05 - just include it straight into here
163:07 - adding it at the top will include it
163:09 - within the entire project but if you're
163:10 - only going to use it once or twice then
163:12 - sometimes it's better to just include it
163:14 - straight into here because it'll make
163:15 - your overall program size a lot smaller
163:18 - so let's just keep it in so we can make
163:20 - our code a bit more readable so we have
163:22 - thread. sleep and what this will do is
163:25 - it will suspend the current thread for a
163:26 - specified number of milliseconds there's
163:29 - a th000 milliseconds in 1 second so what
163:32 - we can do in here and we're trying to
163:33 - mimic a typewriter effect so we can say
163:36 - something like 200 which will be roughly
163:38 - a quarter of a second so if we've run
163:40 - the code now let's see what happens so
163:42 - we get this cool effect where after it
163:44 - prints out each of the characters
163:45 - characters it will print out the next
163:47 - character only after it's been asleep
163:49 - for a quarter of a second and that looks
163:51 - kind of cool if you wanted to speed it
163:52 - up you could just decrease this number
163:55 - there you
163:55 - go of course if you make it too low then
163:58 - it might be too fast for you to actually
163:59 - acknowledge what's happening and if you
164:02 - also make it too slow then it's just
164:04 - going to take too long to turn off and
164:06 - at that point you can use control+ C on
164:08 - your keyboard or use the stop button at
164:10 - the top to terminate the program okay so
164:12 - let's have a look at another thing that
164:14 - we can do with this so maybe we can make
164:15 - this 100 for now in the previous videos
164:18 - we've used a function called contains
164:21 - and let's say we're just checking if it
164:23 - Con turns C and we know it does because
164:25 - we can see it visually let's run the
164:27 - code and we see we have true being
164:30 - printed and the reason why true is
164:32 - actually on the same line as c is
164:34 - awesome is because we're using console.
164:36 - right here so it's actually not made a
164:38 - new line character just after the E so
164:41 - when it's printing true it prints it
164:43 - straight after that so what we can do do
164:45 - to fix that is just place a new line
164:47 - character in here using console.
164:48 - readline and we can just drop this a
164:50 - little bit lower to 50 there we go so we
164:53 - have true and what we can do with this
164:56 - is we can actually make our own little
164:57 - version of the contains function let's
165:00 - demonstrate so if we make this exact for
165:02 - loop again in I equals z i is less than
165:05 - the message. length and i++ so first
165:09 - let's kind of understand what's going on
165:10 - with this function returns a value
165:12 - indicating whether a specified substring
165:14 - occurs with in this string and what that
165:16 - means is it will return a Boolean for us
165:18 - if C is inside our message then this
165:20 - will return back true and we know this
165:22 - is true because we just outputed to the
165:24 - screen and we can see this visually so
165:26 - what we need to do is we need to Loop
165:28 - through our message and try and figure
165:30 - out if we can find C inside our message
165:33 - and then we can give back a value of
165:35 - true so maybe we can do a bu contains
165:38 - equal false and the reason why we
165:40 - initial it to false and the reason why
165:41 - we initialize it to false is because we
165:43 - want to set it up telling that we
165:45 - haven't found it and then inside the for
165:47 - Loop if we find it then we can set it to
165:51 - True let's have a look so after the for
165:53 - Loop we can print contains of the screen
165:55 - and then inside the for Loop what we can
165:57 - do as we've seen here it returns back
166:00 - every single character so you'll get
166:02 - back C sharp then the space then I then
166:05 - s and so on and so forth and what we
166:08 - want to do is we want to go through each
166:09 - of the characters and then just ask if
166:12 - the variable is equal to C if C is equal
166:15 - to C then we can assign this to true and
166:18 - then go through if hashtag is equal to C
166:20 - if space is equal to C and so on and so
166:22 - forth so we can write a if statement
166:24 - here that says message square bracket I
166:27 - is equal to equal to apostrophe C and
166:31 - the reason why it's an apostrophe is
166:32 - because this is a character and this
166:34 - also returns us back with a character so
166:36 - we need to compare them both like that
166:39 - if we use a string in here then it might
166:40 - complain that we're trying to convert
166:42 - between a chart and a string and it
166:44 - won't let let you do the equals equals
166:46 - operator between two different variables
166:49 - maybe what we can do instead is to
166:50 - follow the approach that we used before
166:52 - and use the equals function and place
166:54 - our C inside here so if the character
166:56 - that we're currently up to inside the
166:58 - for Loop is equal to our C which is what
167:01 - we want to search for then we can set
167:03 - our contains variable equal to true we
167:06 - don't need to write an lse statement in
167:08 - here to set our contains to false
167:11 - because we've already gave it a value at
167:12 - the start if we didn't have this value
167:14 - then it'll be beneficial to do this but
167:17 - since we have it then we can remove this
167:19 - other path and we don't exactly need it
167:21 - so let's have a look and see if this
167:24 - works perfect it says true maybe we can
167:27 - change this character to something like
167:28 - air make sure this
167:30 - works which it does as well so perfect
167:33 - so now we've made our own mini little
167:35 - contains function inside here and we can
167:37 - also use the C library one but the
167:40 - purpose of this exercise was just to
167:41 - show you how we can iterate through a
167:43 - string variable and and then decide what
167:45 - each of the characters can be equal to
167:48 - and then we can decide if they're equal
167:49 - to another one and then let the user
167:51 - know that we found a match for their
167:53 - search
167:56 - term so far in the course we've covered
167:58 - the equals function and the contains
168:00 - function when you're searching through
168:02 - strings or trying to find values let's
168:04 - have a look at a method that makes sure
168:06 - a string is valid before we can process
168:08 - information on it so in this quick
168:10 - example we have a name output we're
168:12 - reading the value into a string name and
168:14 - then we simp complet output it to the
168:16 - screen if we run the code and just press
168:18 - enter then it says your name is blank
168:20 - and we don't really want that because we
168:22 - want to check if your name is equal to
168:24 - something before we continue so let's
168:26 - look at some methods so we have if the
168:29 - name is not equal to nothing and then
168:31 - let's just print zero to the screen and
168:34 - that's one of the methods and we can say
168:37 - if name is not equals two quotation
168:41 - marks then let's print out number one so
168:44 - what what this is doing is checking if
168:46 - the name is not equal to empty quotes
168:48 - and then this is doing exactly the same
168:50 - thing except we're using the equals
168:52 - method and let's just run the code and
168:55 - press enter and you can see the zero or
168:57 - the one doesn't appear because it's
168:59 - detecting that it contains nothing so if
169:01 - we type in a real value we can see Zero
169:03 - and one coming up so these are both
169:06 - valid ways of checking if the string is
169:08 - not empty so let's look at a third one
169:11 - and this one is actually very important
169:12 - for reasons I'll explain in a second so
169:15 - inside our string Library we have is
169:17 - null or empty so we place our name
169:20 - inside here and let's see what this says
169:22 - now indicates whether the specified
169:25 - string is null or it's an empty string
169:28 - so this can be very effective so what
169:30 - this reads now is if the string is null
169:33 - or empty then we print a value but we
169:36 - want it to be not null or empty because
169:38 - it wants to have some contents so if we
169:41 - type a value in again you'll see now we
169:43 - get all three numbers and what them
169:45 - three numbers mean is that it's past all
169:47 - of these checks and each of these checks
169:49 - just ensures that the value has got
169:51 - something inside and that's fine but it
169:54 - can be slightly problematic for this
169:56 - reason using this method and this method
169:59 - are fine in some cases except as it says
170:02 - here it checks if the string is null and
170:05 - null means it doesn't have a value but
170:07 - it just has nothing instead of something
170:10 - let me demonstrate if we assign the
170:12 - value of empty quotation marks this
170:15 - actually has a value but the contents is
170:17 - empty but it's still a string as it
170:20 - comes up in here if we assign this the
170:22 - value of null then it's just a keyw that
170:24 - we can use to denote that this literally
170:26 - has no contents it's not that it has an
170:29 - empty string CU an empty string is still
170:32 - actually a string whereas a null it just
170:34 - means the variable is blank now this is
170:37 - where the issue arises if we try and
170:39 - call a method on something that's null
170:42 - Watch What
170:43 - Happens we actually get an exception and
170:45 - our program just crashes you can't run
170:48 - any code on something if that variable
170:50 - is actually defined as
170:52 - null it doesn't mind if you check the
170:55 - value of it but if you try and run a
170:57 - function then you've got a problem so if
170:59 - we comment this line out this ensures
171:02 - everything it ensures it's null or it's
171:05 - empty and this is the belt and braces
171:07 - option because if it's null we don't
171:09 - actually get an exception when we try
171:11 - and run this code as follows
171:15 - we get the zero showing up because our
171:17 - variable has something that's not speech
171:19 - marks and it's actually null so we want
171:22 - to avoid this option as well and also
171:24 - avoid this option in case our string is
171:27 - actually genuinely
171:28 - null using is null or empty we'll check
171:32 - both for the value of null which it is
171:34 - right now and if it's got empty quotes
171:37 - EG the value is empty so if we just run
171:40 - this again and have these two paths
171:42 - commented out we can see that two is not
171:44 - appearing if we change this back to our
171:47 - console readline and we try and do it
171:50 - then we get our number two because it's
171:52 - validated that this string variable is
171:55 - got something inside it and the variable
171:57 - is not actually no this is a very good
172:00 - way of being able to make sure that your
172:02 - program doesn't get exceptions as with
172:04 - calling these equals if you want to call
172:07 - equals then call it inside here you can
172:10 - check if that variable equals something
172:13 - by simply placing that if statement in
172:15 - inside here after you validated if the
172:17 - name variable actually has some contents
172:21 - if it's null or it's empty running
172:23 - equals on it will just break the code
172:25 - further and you don't need to check if
172:27 - it's equal to Something in here maybe
172:29 - you were checking if the value is equal
172:31 - to abber or something along them lines
172:33 - and now if we run it again we actually
172:36 - get the output correct it's best to Nest
172:39 - them like this because if you run this
172:41 - function on something that's null it's
172:43 - actually really safe but as you saw
172:46 - previously if you run a function on
172:47 - something that's null then you're going
172:49 - to get a null reference exception and
172:51 - your program will close down and break
172:54 - you want to avoid exceptions at all cost
172:56 - so nesting it inside it is null Remy
172:59 - check will be perfect for your code it
173:01 - improves the stab ability of your
173:03 - program to ensure that exceptions don't
173:07 - happen so in this exercise I want you to
173:09 - ask the user to input any message and
173:11 - then I want you to print the message in
173:13 - Order character by character and then
173:15 - also print it in reverse character by
173:17 - character let's get started so we could
173:20 - just have a console right line but let's
173:22 - change it to a right and just say enter
173:24 - your message callon and then speech
173:26 - marks and then just have a string
173:28 - message
173:30 - equals console. readline perfect so in
173:34 - order to be able to Loop through the
173:36 - string message we need to have a for
173:37 - Loop if you remember from our previous
173:39 - videos we can have this string variable
173:42 - followed by a square bracket and then
173:44 - and then we can have an index inside and
173:46 - that will print us back any sort of
173:47 - index based on that position so if we
173:51 - just have this is a test then it's prob
173:54 - print as the T because that's the first
173:56 - index and so on and so forth so what we
173:59 - can do with this information is take
174:01 - what we can do with the string index and
174:03 - then also use the property which is
174:05 - length and then use these two values to
174:08 - be able to process this is a test so we
174:11 - have the first character square bracket
174:13 - 0 and the last character is at length 14
174:16 - so our message variable now contains 14
174:19 - characters obviously When I close the
174:21 - program then that value is lost and I
174:22 - have to re-enter it but because of that
174:24 - exact reason we would always use do
174:26 - length because we never know how long
174:28 - the user's input is going to be so we
174:30 - can have a for Loop so we can say 4 into
174:33 - I equal 0 I is less than and we can use
174:36 - the message. length here and then we can
174:38 - say I
174:39 - ++ so you want to start at zero because
174:42 - our first index position is inde Z and
174:45 - we want to go from the index zero all
174:47 - the way to the length now in that
174:49 - example I just printed out 14 for the
174:51 - length but you got to realize is there
174:54 - might be 14 positions but there's only
174:56 - 13 indexes so it's not actually 13 index
175:00 - it's just up to 13 when you start at
175:02 - zero going from 0 to 13 gives you 14
175:06 - positions so when we're saying 0 is less
175:09 - than the message length then that will
175:11 - actually take us from 0 to 13 instead of
175:13 - 0 to 14 if we made this greater than or
175:16 - equal to and change this to a one for
175:18 - example then that's going to go from 1
175:20 - to 14 and first we're going to miss out
175:23 - the first character and we're actually
175:25 - going to go one over the message length
175:27 - so you always want to start from zero if
175:29 - we're going through the entire string so
175:31 - this will go from 0 to 13 and then here
175:34 - we can just have a console right line
175:36 - and just print message square bracket I
175:39 - and then just for the time being we can
175:40 - comment out these lines just so it
175:42 - doesn't saturate the output so let's run
175:43 - this Cod code and see what
175:45 - happens this is a test and then we get
175:48 - them all on separate lines maybe we can
175:51 - just use a console. right instead so we
175:53 - get each character on the same line
175:55 - instead of a new line character being
175:56 - outputed at the end of each of the lines
175:59 - so we can say this is a test again and
176:01 - there we go we get this as a test
176:03 - outputed as well so now that we've
176:05 - printed that in order let's see how we
176:06 - can print it in reverse so just a quick
176:09 - little tip throughout this C I've been
176:11 - quite hard on you I've made you WR the
176:13 - for Loop out exactly the way it should
176:15 - be but all done manually this is so you
176:18 - can get used to the syntax and after a
176:20 - while once you understand exactly what
176:22 - to do then what you can do is when you
176:24 - type in the four you can see that it
176:26 - says there's a for snippet tab twice to
176:28 - insert the for snippet and we can do
176:30 - that now and it actually gives you a
176:32 - little bit of an output you can see
176:34 - these sections that have been
176:35 - highlighted the reason they're
176:36 - highlighted is once you're done with one
176:38 - section you can actually press Tab and
176:40 - it'll jump to the next one so now my
176:42 - cursor is jumped on the length and we
176:44 - can type in message. length if I press
176:47 - tab again then it'll just keep cycling
176:49 - through them until we're done and we can
176:51 - press Escape upon pressing escape then
176:53 - it gets out of the little message and
176:55 - there we go we've now just defined a
176:58 - really quick for Loop please only use
177:00 - this once you're comfortable writing for
177:02 - loops and don't use them immediately
177:04 - because you might get stuck on what to
177:06 - do and how to do it so it's best to
177:08 - always write the for Loop syntax out
177:09 - from scratch so you can get used to the
177:11 - three different sections so this is
177:13 - actually a for Loop that goes forwards
177:15 - it's going from 0 to 13 but what we
177:18 - actually want to do now is go from 13 to
177:21 - 0er so let's actually change this for
177:23 - Loop completely and we can do our little
177:25 - shortcut again so if we do four and then
177:28 - we don't actually want to start on the
177:29 - value is zero we want to start on
177:32 - message. length and then you want to
177:34 - minus one and just as we said here we
177:37 - never actually want to get to the length
177:39 - because we want to go from 0 to 13 so if
177:41 - we want to go backwards we want to go
177:43 - from 13 to zero and the only way that we
177:46 - can get this 13 is by getting the 14
177:49 - value which is message. length and
177:51 - simply minusing one so now that we've
177:53 - got our first variable which is in I
177:55 - equal message length minus one which
177:57 - will give us the 13 we want to go from I
178:00 - and instead of less than it's going to
178:03 - be greater than or equal to and then we
178:05 - actually want to change it to a zero
178:07 - because we actually want to stop at zero
178:08 - in this case and then we don't want to
178:10 - use I ++ because if we start at 13 we
178:14 - want to go down in one instead of up in
178:16 - one then we can simply just do minus
178:19 - minus we can take this exact line and
178:21 - print it out to the
178:23 - screen and if we just print something
178:25 - small in between like a hyphen just to
178:28 - separate the two outputs and let's see
178:30 - what
178:31 - happens test there we go so we have test
178:35 - and then t s e and t is now in Reverse
178:39 - but now you might be wondering if we had
178:42 - a shortcut for the four what what's this
178:44 - for with an additional R Cordes n it for
178:46 - a reverse for Loop so if you tap tab
178:49 - twice you can see that we have exactly
178:51 - the same format in I equals something
178:54 - minus one which we have right here and
178:56 - then we have I is greater than or equal
178:58 - to zero as is we have here and then we
179:01 - have IUS minus just like here so we can
179:04 - literally just change this into message
179:06 - do length and then these two now are
179:09 - exactly the same so just copying this
179:12 - down we'll get us exactly what we need
179:14 - but obviously we just wrote this I just
179:15 - wanted to show you the shortcut so let's
179:18 - try it with a longer string this is a
179:20 - test there you go and if you wanted to
179:22 - you could just print these on separate
179:23 - lines so you can just change this into a
179:25 - right line for
179:27 - example and have it like that it doesn't
179:29 - really matter the rest is up to you but
179:31 - the task is just so you can print it one
179:33 - way and then print it the other way I
179:35 - realized that what you can also do is
179:38 - just simply print a console right line
179:40 - and have message in there and just get
179:42 - rid of this completely and the output
179:44 - will still look exactly the same there
179:47 - you go and the reason why I told you to
179:49 - write the for Loop is not because it'll
179:51 - be easier if you do this it's more for
179:53 - your Educational Learning purposes
179:55 - having more practice to how to iterate a
179:57 - string variable is very helpful for the
180:00 - future and you can understand it fully
180:02 - if you just print out to the screen then
180:04 - you're not learning anything extra
180:05 - you're just applying what you already
180:07 - know so let's just have a quick recap we
180:09 - ask the user to enter the message we STW
180:11 - it into a string variable and then Iden
180:13 - demonstrated that you could use the
180:14 - square brackets to Output the first
180:16 - index then you can output the length of
180:18 - the entire variable using a follow you
180:20 - can go from zero to message length which
180:23 - will give us from indexes zero up until
180:25 - 13 in this case and then we can go
180:27 - through i++ incremen in one and then we
180:30 - can have a console right which will just
180:32 - print out message index I for the index
180:35 - that we're currently up to and then we
180:36 - break it off with a console right line
180:38 - just in the middle because these are
180:40 - printing on the same line so we need to
180:42 - insert a new line character at the end
180:44 - after we've done that what we can do now
180:46 - is print it in reverse and now we can do
180:48 - exactly the same thing except from 0 to
180:51 - 13 we go from 13 to zero so we start at
180:54 - the message length minus one because the
180:56 - length was 14 and now we minus one to
180:58 - get to 13 and we're going from I is
181:00 - greater than or equal to zero because
181:02 - that's the value that we want to stop at
181:04 - and then we can do I minus minus if we
181:06 - were to take out this equals operator
181:09 - let's see what happens test and now
181:12 - we're actually missing the last
181:13 - character because what we've done is
181:15 - we've actually went from 13 to 1 instead
181:18 - of 13 to 0o so let's put that back in
181:21 - and make sure it works and then we have
181:23 - t set for test and then we're outputting
181:26 - the exact same thing in both for Loops
181:29 - because we're simply just printing the
181:30 - character that we're currently up to and
181:32 - because this for Loop starts at zero and
181:34 - this for Loop starts at the length minus
181:36 - one then they outputting the same values
181:39 - or what it appears to be the same values
181:41 - it's just starting at different indexes
181:45 - in this exercise we're going to be
181:47 - building some sort of a password
181:48 - validator this can be present in
181:50 - something like a register form where you
181:52 - ask the user to enter their password and
181:54 - then enter it again to make sure that
181:56 - they've entered it correctly so you want
181:57 - to ask user to enter their password in
181:59 - twice and store them both check if they
182:01 - both contain something if they do we can
182:03 - print out password match if they don't
182:05 - passwords do not match and if they both
182:07 - contain nothing then you want to Output
182:09 - please enter a password so let's get
182:11 - started first we can have have a console
182:14 - console right we can have enter
182:18 - password string password equals console.
182:23 - readline and then we can just copy these
182:25 - two lines down using contrl D and then
182:28 - we can have a password C for password
182:30 - confirmation and we can say enter
182:32 - password again and let's just print
182:34 - these out to the screen just to make
182:35 - sure we know what's going on just like
182:37 - so so we can have abber and then abber
182:40 - again so now we have both AB stored and
182:42 - that's fine
182:44 - so let's see what we can do now we need
182:46 - to check if they both contain something
182:48 - so what are the different ways that we
182:49 - can do this so we can have if password
182:52 - do equals and then we can make it equals
182:54 - to string. empty and because we want to
182:56 - check if it's not empty then we can
182:58 - simply place the not operator right at
183:00 - the start and then we can join them with
183:02 - another one not password. equals and
183:05 - then exactly the same thing string.
183:08 - empty but in this case we don't want to
183:10 - use password we want to use password C
183:13 - there we go so if we've came into here
183:15 - then that means they must have entered
183:17 - something so let's just quickly do our
183:19 - exit path which is if they're empty
183:21 - please enter a password so we can say
183:23 - else and we don't need a condition here
183:26 - because if this were to fail then it has
183:28 - to mean that their passwords empty so we
183:30 - can have a console. right line and we
183:32 - can just do please enter a
183:35 - password and let's just test if this
183:37 - path works first and we just press enter
183:40 - twice and we get please enter a password
183:43 - and maybe if we typee something in for
183:44 - both and then we get nothing because
183:46 - it's actually came to here now perfect
183:49 - so if we come through and we can say
183:51 - password equals equals password C or we
183:54 - could use the equals function and we can
183:56 - say password. equals and then password C
184:00 - and if they both equal to each other
184:02 - then we can print out passwords
184:05 - match there we go and if that were to
184:09 - fail then we can print out passwords do
184:12 - not match
184:14 - here we go let's run that let's find out
184:17 - ABA and ABA and we get passwords match
184:20 - and if we try ABA and ab two is and then
184:23 - we get passwords do not match so what
184:25 - are some other ways that we can do this
184:27 - you can structure this completely
184:29 - differently right now we're doing both
184:31 - checks in one single if statement and we
184:33 - can actually split this up into two and
184:35 - then provide a different error message
184:37 - so right now this ISS please enter a
184:39 - password you might have entered the
184:41 - second one but not have entered the
184:43 - first one or vice versa but it doesn't
184:45 - matter because you have to enter both of
184:47 - them in order to pass this validation
184:49 - check so what you could do instead is
184:51 - actually put another if statement inside
184:54 - and paste this one inside here and then
184:57 - just keep these as two separate if
184:59 - statements and then you can actually
185:01 - provide different error messages so
185:03 - let's Nest this in one deeper so we can
185:06 - say if the password is not equal to
185:09 - empty and if this returns back true then
185:11 - this variable has something inside it
185:13 - and then once we go inside these curly
185:15 - braces we get another check and if the
185:17 - password C is not equal to nothing then
185:20 - that means if we've came in here then we
185:22 - pass both of these validation checks and
185:24 - both of them contain something and then
185:26 - we can proceed to check the variables so
185:28 - what you can do in the first L statement
185:30 - is you can say please enter a password
185:33 - but on the second one so just after this
185:34 - curly brace we can have another L
185:37 - statement or we can say please enter a
185:41 - password confirmation
185:44 - so I know that was a bit quick so let's
185:45 - just have a quick recap so we can have
185:47 - one if statement that processes the
185:49 - first password that you type in and if
185:51 - this is empty then it says please enter
185:53 - a password and if it's not empty then
185:55 - it'll go inside this curly brace hit the
185:58 - first line and check if the password
186:00 - confirmation is not empty if it is empty
186:03 - then it'll say please enter a password
186:05 - confirmation if both of these return
186:07 - back true then it will go inside the
186:09 - success path in which it will actually
186:11 - check if password is equal to the
186:13 - password confirmation and we can say the
186:15 - passwords match or if they don't equal
186:17 - to each other we can say the passwords
186:19 - do not match let's run that and see what
186:21 - we get so if we type something in for
186:23 - the second one but not the first one so
186:26 - for the first one we just press enter
186:27 - and then let's type something in for the
186:29 - second one and it says please enter a
186:31 - password and then if we run that and do
186:33 - the complete opposite type in p and then
186:36 - press enter for the second one then it
186:38 - says please enter a password
186:39 - confirmation so you can see immediately
186:41 - what we can do is provide a different
186:43 - error message for different situations
186:45 - if you include these both in one line
186:48 - then you can only give out more of a
186:49 - generic error message this is similar
186:51 - for when you go to login and when you
186:53 - get your password or email wrong it
186:55 - doesn't say which one you've got wrong
186:57 - it just says them generically which one
186:59 - you've got wrong it says invalid
187:01 - credentials or invalid username or email
187:04 - it will say them generically like
187:05 - invalid username or password but it
187:07 - won't tell you which one it is because
187:09 - hackers can exploit this and you don't
187:11 - want to be doing this but in the case of
187:13 - a password confirmation and this is just
187:15 - for a register form then it's not
187:17 - exactly the worst thing to do this
187:19 - because sometimes what you'll see is the
187:20 - text boxes might go red to indicate that
187:22 - they're both not equal to each other and
187:24 - this is fine on registration but it's
187:26 - not fine on the login what we can also
187:28 - do in here once we've checked if they're
187:30 - both not equal to something we can
187:32 - actually just validate how long the
187:33 - string needs to be we can have if
187:36 - password. length and let's say you had a
187:38 - restriction and it can only be over six
187:41 - characters and we can say six
187:43 - and password
187:45 - c.length is greater than or equal to 6
187:48 - and once it passes all three of these
187:50 - checks then we can check if they're
187:52 - equal to each other if they got
187:54 - something inside and if they've got
187:56 - something inside and if they've got both
187:59 - the length is greater than or equal to
188:01 - six then we can check it so we can have
188:04 - something like password and then
188:06 - password and then this returns back with
188:08 - password matched if we have something
188:10 - like abber then it's actually returns
188:12 - back nothing
188:13 - because we don't have an else for this
188:15 - specific bracket so we can say else
188:19 - conso right line please enter six or
188:23 - more
188:25 - characters so if we type in Alit twice
188:28 - then you can see we get this message now
188:30 - please enter six some more characters so
188:32 - right now we have a validation for the
188:34 - first password and the second password
188:37 - and for the length and if all these
188:39 - checks go by then you can process the
188:41 - actual passwords that they they've
188:43 - entered and check if they're equal to
188:44 - each other you can technically do all of
188:46 - these checks in one line it'll just be a
188:49 - pretty long line but what that means is
188:51 - you can't have three separate error
188:53 - messages like this if you have it
188:55 - processed in one line the only error
188:57 - message that you can give is very
188:58 - generic there's no one generic message
189:00 - that can fit for password empty and the
189:03 - confirmation password empty and for the
189:05 - length so maybe what you could do is
189:07 - chain the both of them to be check if
189:09 - they're not empty so then you can
189:11 - process a message with something like
189:13 - please enter a password and then you can
189:15 - have another check for the password
189:16 - length just to let them know that they
189:18 - need to enter six or more characters but
189:20 - in these off into two separate checks is
189:23 - going to be very helpful because it'll
189:24 - let the user know something a bit better
189:26 - than a generic error message so in the
189:29 - previous examples throughout the course
189:30 - we've actually talked about using the
189:32 - two lower function and I said in
189:34 - majority of cases where you want
189:36 - actually compare two different things
189:37 - you want to actually use the two lower
189:39 - function or the two upper function and
189:41 - you can achieve this by having two lower
189:44 - just here and then also two lower just
189:47 - here now the problem with comparing if
189:49 - they're both equal to each other but
189:51 - checking the lowercase values is this is
189:53 - indeed a password if you're checking if
189:55 - the user has inputed any capitals lower
189:58 - case symbols Etc then there's no point
190:00 - in applying a too low function because
190:02 - that will just ruin their actual
190:04 - password and reduce the security so in
190:06 - certain cases you don't always want to
190:08 - use two lower and two upper for
190:10 - comparison you want to just check the
190:12 - value straight up and the same thing is
190:14 - when you're doing a login you don't want
190:16 - to be checking their values lowercase
190:18 - because that's their login these are
190:20 - some of the specific situations where
190:22 - you don't want to be using the tow
190:23 - function if the data that you're
190:25 - processing is pretty sensitive and will
190:27 - be messed up if you use the toow
190:29 - function that you should always avoid it
190:31 - passwords fit this perfectly and
190:33 - usernames as well if someone's added
190:35 - some capitals inside the username then
190:37 - you don't want to ruin that by doing
190:38 - lower case or upper
190:41 - case if you're your username is spelled
190:43 - like this and you try and log on like
190:45 - this then they are not equal to each
190:47 - other because this will probably be two
190:49 - different accounts you can have an
190:51 - account with a capital B and have
190:53 - account with a lowercase b so you don't
190:55 - be lower casing the input and then doing
190:56 - a comparison because what you might
190:58 - actually retrieve is a different account
191:00 - than you're looking
191:02 - for so now that we talked about stuff
191:04 - theoretically let's see how we can do
191:06 - things practically so as you heard in
191:08 - the last video arrays are a way that we
191:10 - can store multiple variables of the same
191:12 - data type in one little group so if we
191:15 - had something like Nome 1 = 5 in n 2 =
191:19 - 10 in N 3 = 15 and we had a similar case
191:23 - in one of the exercises like this where
191:25 - we had to work out if a triangle was
191:27 - actually a triangle so we asked user to
191:29 - input three different angles and then we
191:31 - stalled them all and then we added them
191:33 - up after and it looked something like
191:35 - this in total equals num 1 plus num 2
191:39 - and then finally plus num 3 and then we
191:42 - had some sort of if statement after to
191:44 - check if the
191:45 - total was equal to
191:48 - 180 and then we did something in the
191:50 - curly braces just output that it's valid
191:52 - and then else output it's
191:54 - invalid you can see how this gets a
191:56 - little tedious we have to create a new
191:58 - variable every single time we want some
192:00 - more data to be stored and in this case
192:02 - we just simply want another number that
192:04 - we can store but we have to just keep a
192:06 - pending one to it in that case we could
192:09 - have angle one angle two and angle three
192:11 - but how about if you have something that
192:13 - just called angles for now let's just
192:15 - talk about how arrays work and how we
192:17 - can use them and then after I've went
192:19 - through this example about arrays and
192:20 - taught you what to do with it then I
192:22 - will go get the code from the exercise
192:24 - from the triangle video and actually
192:26 - transform it into using an array so you
192:28 - can see what the difference is and how
192:29 - the new code will look like so let's get
192:32 - rid of this little section so now that
192:34 - we've got three integer variables let's
192:36 - see how we can do this another way so
192:38 - the Syntax for arrays you first type in
192:40 - the data type that you want just like
192:43 - before and then you add on a square
192:44 - bracket and a closed square bracket
192:46 - there's nothing that needs to be inside
192:48 - as of right now then you press space and
192:50 - type in the variable name as per always
192:53 - and then we can make that equal to new
192:55 - in 3 so what this side of the equal sign
192:58 - means is we want a new instance of an
193:00 - integer array and we want to have three
193:02 - positions since we have three variables
193:05 - here that we want to store we need to
193:06 - have three positions to stall them so
193:09 - this line in total says that we want to
193:10 - integer array we want to call it numbers
193:13 - and we want to instantiate our new
193:14 - integer array with three positions
193:17 - instantiate is just the term that we use
193:19 - when you turn something into a new class
193:22 - at this point if we don't use new then
193:25 - we're going to get compiler error
193:27 - because it's unsure what this is trying
193:28 - to tell you it's trying to St an integer
193:31 - inside integer array and that makes no
193:33 - sense so it won't recognize the square
193:35 - brackets in this case because it has no
193:37 - idea what it's trying to do and this
193:38 - syntax is completely incorrect so the
193:40 - compiler doesn't know what error message
193:42 - to give you so we can have a new int and
193:45 - what we can do now is by using the
193:47 - square bracket reference we can actually
193:49 - specify these three variables inside our
193:51 - numbers array so now we have access to
193:54 - numbers 0 = 5 and then if we use
193:58 - controll D to copy this down twice we
194:00 - change this to one and two and then
194:03 - print 10 here and 15 here so now this is
194:06 - exactly the same as this we have three
194:09 - integer variables defined separately as
194:11 - 5 10 15
194:13 - and now that we've created an array of
194:14 - numbers we can specify all three of
194:17 - these values inside our numbers array so
194:19 - instead of having three individual
194:21 - variables now we just have one that
194:23 - holds everything like a group and just
194:25 - to show you how this works if we have a
194:27 - console right line we can say n one
194:29 - space num two space num three and if we
194:34 - use control D to duplicate that down
194:36 - then what we can have instead of these
194:38 - num ones is simply just place these
194:40 - values
194:40 - inside changes to one and changes to two
194:44 - and what you should notice is these two
194:46 - lines are going to print the exact same
194:49 - values there we go so in this example
194:52 - we've took our sloppy code that will
194:54 - roll us around appending one to this
194:56 - number creating a new array and then
194:58 - printing it out so let's say we want to
195:00 - actually use these to read in values
195:02 - from the console what can we do and
195:04 - you'd use these exactly the same as how
195:06 - you use variables up here this is just
195:09 - an integer variable at a specific
195:10 - position held inside a group so we could
195:13 - simply have a console right line delete
195:16 - the right and just say enter a
195:18 - number and then instead of starting five
195:21 - we can say convert to in32 and then we
195:23 - can have a console.
195:26 - readline and that will read in from the
195:28 - console convert it to an integer 32 and
195:31 - then store it into the first position of
195:33 - our numbers array now if we just copy
195:36 - this down
195:37 - twice and we can get rid of these two
195:39 - lines cuz this is just staring it
195:41 - statically and add one and two to here
195:44 - so now what we're saying is enter a
195:46 - number St into 0o 1 and two and let's
195:49 - see what happens now so now we get asked
195:52 - the numbers 10 20 and 30 and you can see
195:54 - that they've been stored here of course
195:57 - these haven't changed because this is
195:58 - still referencing our static variables
196:00 - up here so what you can see in this
196:02 - example is now that we've made an array
196:04 - we can specify each of the values very
196:07 - easily inside here and if so we wanted
196:09 - to have a number four instead of to
196:12 - duplicate it and rename it and change
196:14 - the value for example we can just simply
196:16 - turn this into four duplicate this
196:19 - little section and then just change it
196:21 - to a three one thing to note in C and
196:25 - many other languages almost every single
196:27 - index will start at zero in the last
196:30 - section we covered the string functions
196:32 - and they also started at zero when
196:34 - you're dealing with strings and their
196:36 - positions when you have a for Loop of
196:38 - the string then you always want to use
196:40 - index zero as the first position
196:43 - the same is true here we have four
196:45 - positions which means it goes from zero
196:48 - all the way till three it never goes
196:50 - from 1 to 4 or from 0 to 4 these are bad
196:53 - values it always goes from 0 to
196:56 - 3 you might be thinking this looks
197:00 - really good but when we go to print it
197:02 - we're going to have to copy and paste
197:03 - this little section add another one and
197:05 - rename this to three this gets a little
197:07 - bit tedious if we just trying to print
197:09 - them all to the screen so let's see how
197:11 - we can fix that we can use a four Loop
197:13 - for this so we can have four in I equals
197:16 - z i is less than and then we can have
197:19 - numbers do length and if you notice from
197:22 - iterating through a string variable the
197:24 - syntax is exactly the same we have a do
197:27 - length property on the arrays as well as
197:29 - we do with a string
197:31 - variable so in order to print out this
197:33 - line what we can do is print one of them
197:36 - every time we go around the for Loop
197:38 - instead of using a console right line we
197:40 - can just use a console right
197:43 - so we can have console.
197:45 - right and then what we can simply do in
197:47 - here is we can say numbers square
197:50 - bracket I and then we can have a space
197:53 - right after it just to M make what
197:56 - happens here we have the number printed
197:57 - out and then a space after it number
197:59 - printed out a space after it and so on
198:02 - and so forth so let's see what happens
198:04 - now if we run the code 10 20 30 40 there
198:10 - you go so you can see that these two
198:11 - lines are exactly same and now what
198:13 - happens is let's just comment these two
198:15 - lines out and if we were to change this
198:17 - to five and we can duplicate the
198:20 - section changes to a four and then now
198:23 - we have five variables started and we
198:25 - don't need to touch this for Loop
198:26 - because the numbers do length will get
198:28 - updated anyway so we can have 1 2 3 4
198:31 - five and you can see all five variables
198:34 - have been printed automatically what
198:36 - also is quite tedious here is we're
198:37 - having to add another one to this just
198:39 - so we can ask the user how many times
198:41 - that they want to enter a number again
198:44 - this is quite tedious but we also have a
198:46 - fix for that because we know how many
198:48 - times we want to ask the user to enter a
198:50 - number then we can use a for Loop to
198:52 - iterate through and ask the user as you
198:55 - can see every single line here is
198:57 - exactly the same except for the index
198:59 - position that we're dealing with and the
199:01 - same is true for this for Loop this line
199:04 - will always be the same as we're
199:06 - printing out here and the only thing
199:07 - that changes between this section and
199:10 - this section is the fact that this says
199:12 - one and this says zero so we can
199:14 - translate this into a for Loop to make
199:17 - it
199:18 - Dynamic and we can do exactly the same
199:20 - thing above here so let's actually copy
199:23 - and paste this for
199:25 - Loop because we want to do exactly the
199:27 - same
199:29 - approach we want to go through all the
199:31 - positions inside our numbers array and
199:33 - then we can actually ask the user to
199:35 - enter a number in so let's block comment
199:37 - out this massive section and then we can
199:40 - take one of them and place it inside the
199:42 - follow Loop so now we're asking the user
199:44 - enter a number and then we're storing
199:46 - inside index zero and of course if we
199:48 - keep using index zero then it's just
199:50 - going to override the first one and
199:51 - we're not going to store any data so we
199:53 - can change that to an i let's see what
199:55 - happens when we run it now 1 2 3 4 5 and
199:59 - then we get the five numbers being
200:01 - printed this is awesome because what
200:03 - we've got now is five output commands
200:06 - coming straight to the console just from
200:07 - a for Loop the for Loop is responsible
200:10 - for printing them all out to the screen
200:12 - reading in the value convert it to an
200:14 - integer and then store it inside our
200:15 - array and then we have a separate for
200:17 - Loop to print it out to the screen
200:19 - what's really really powerful about
200:21 - these two for Loops that we've built is
200:23 - if we want to have 10 numbers now we
200:25 - simply just change this to 10 and then
200:27 - just rerun the code as you can see we
200:29 - now have 10 numbers there you go so what
200:32 - we've just done if we move this code
200:34 - down a lot now just so we can have it
200:36 - close
200:37 - by we've made our entire program that
200:40 - was actually pretty lengthy in into just
200:42 - a couple of lines and two for Loops one
200:45 - for Loop is responsible for looping x
200:47 - amount of times x depends on whatever
200:49 - that number is and then we go through
200:51 - and ask the user to enter a number read
200:54 - in from the console convert it to an
200:56 - integer 32 and start within the array
200:59 - after this for Loop has finished running
201:01 - then we have all the numbers stored
201:03 - inside our array and then we can go
201:05 - through and print them all out to the
201:06 - console another way we can print this
201:09 - out to the screen is by actually using a
201:11 - for each so we can say int num and then
201:14 - we want to be a number inside our
201:16 - numbers so for each of the integers
201:19 - inside the number we want to create a
201:21 - new local variable called num and then
201:23 - we can use it in here and if we take
201:25 - this line and copy it down everything's
201:27 - exactly the same except we don't need to
201:29 - specify the main array numbers now and
201:31 - we don't need to specify the square
201:33 - brackets we can just change this
201:35 - completely and replace it with n and if
201:37 - we just make this number smaller so we
201:39 - don't have to Output a lot of
201:40 - values
201:42 - 1 two and three and you can see that
201:44 - they're exactly the same there's no line
201:46 - between them because I don't have a
201:47 - console right line so let's quickly add
201:49 - that
201:51 - in and there we go 1 2 3 and you can see
201:54 - they're outputting the exact same
201:58 - values the reason why I needed a console
202:01 - right line is because these four Loops
202:02 - are using console. right the problem
202:04 - with console. right is even after
202:06 - finishing writing all of the lines it
202:08 - doesn't continue to the next line it
202:10 - stays there so if I don't break up the
202:13 - two outputs with the console right line
202:15 - then all six outputs from the console
202:17 - right and the other console right will
202:19 - all go on one line this is just for
202:21 - demonstration purpose anyway either one
202:23 - of these Solutions are fine more people
202:26 - tend to use this one the problem with
202:28 - these two options is you can't always
202:29 - use them
202:31 - interchangeably this one will always go
202:33 - through every single position it will
202:36 - always go from zero and it will always
202:37 - go to the length the problem with this
202:40 - for Loop is you can't choose how many
202:42 - times you want to iterate through before
202:44 - you stop there might be a very specific
202:46 - case where you have a big array of data
202:48 - but you only want to select the specific
202:50 - range if an example where you had a
202:52 - th000 array positions so from 0 to 999
202:56 - and let's say you wanted to request and
202:58 - run a for loop from 500 to 600 so you
203:01 - would literally type in 500 in here and
203:04 - then 600 inside here and this would be
203:07 - fine as long as your array has that many
203:09 - positions but with the four each Loop
203:11 - Loop if you run for each loop on a
203:13 - thousand length array then it's going to
203:15 - go through every single position in some
203:18 - cases you might not want that and you
203:19 - only want to go through specific cases
203:22 - so if you know you're going to go
203:23 - through every single case then you can
203:25 - use the for each but if you know you're
203:27 - going to go through a certain amount of
203:28 - cases then it's always best to use the
203:30 - fall Loop okay so we covered quite a lot
203:32 - in this video so let's just have a recap
203:35 - so initially we started off saying we
203:37 - have our num one num two and num three
203:39 - then we had our static variables St
203:41 - inside there and then we created our
203:43 - integer array which is now down here and
203:46 - just to make it a little bit easier to
203:48 - store multiple variables because if you
203:50 - wanted five variables you'd now have to
203:52 - duplicate that and change that to number
203:53 - five and this will get very tedious if
203:55 - we had something like 10 like before
203:58 - this is very long and you don't need be
204:00 - specifying number 10 in your code
204:02 - because this also hurts the readability
204:04 - of it using arrays can solve this
204:06 - problem quite a lot you can easily
204:08 - specify array using this notation int
204:12 - square brackets followed by the name and
204:14 - you make that equal to a new int three
204:17 - the three can be any number that you
204:19 - want as long as it's a whole number cuz
204:21 - this tells us how many positions that
204:22 - we've got we then outputed lots of
204:24 - values to the console and read them into
204:26 - our Ray but we had the same problem as
204:29 - we did above where we just had to keep
204:31 - duplicating the sections so what we did
204:33 - to prevent that is by writing a little
204:35 - for Loop that went through every single
204:37 - position in numbers array I puted
204:39 - something to the screen readed in the
204:41 - value converted it and stored it into
204:43 - the array and then after all that was
204:45 - done we can use a for Loop or a for each
204:48 - Loop and print that back to the screen
204:50 - now that we finished the base cont of
204:51 - this video and because I said at the
204:53 - start that I was going to take the
204:54 - triangle exercise and convert that into
204:56 - an array so let's do that now so now
204:59 - I've copy and paste a solution from the
205:01 - triangle exercise straight into this
205:03 - project I've just block commented
205:05 - everything above just so it doesn't
205:06 - interfere with our code so let's just
205:08 - run this code to familiarize us with
205:10 - what's going on so if we enter 60 60 and
205:14 - 60 then it says valid and if You' run it
205:17 - again and enter something else that
205:19 - doesn't equal to 180 then we get invalid
205:22 - so let's see how we can make this code a
205:24 - lot better by the use of arrays so as we
205:26 - said before we don't want to be using
205:28 - this angle one angle two and angle three
205:31 - let's make a int square bracket angles
205:35 - equal new int and then in this case we
205:37 - have three angles and what you could do
205:40 - as well is you could say con int angle
205:43 - count equals
205:44 - 3 and then you can simply use that
205:46 - inside here so later on in the code if
205:49 - we wanted to specify this to a different
205:51 - value we can just change that later
205:53 - on so now that we've got the three
205:55 - angles we can get rid of these three
205:57 - lines and write ourselves a little for
206:00 - Loop so I goes from zero all the way to
206:03 - angles. length and then every single
206:06 - time we go around in the for Loop we
206:08 - want to
206:10 - say console right enter angle one and
206:15 - then we can say angles square bracket
206:19 - and not zero in this case cuz we don't
206:21 - to be specifying index as it will go
206:23 - from 0o to 1 to two we want to be using
206:26 - I I because we're inside a for Loop
206:29 - that's already going through all the
206:30 - indexes forers and make that equal to
206:33 - convert to in32 and then a console.
206:37 - readline now we've got all the values
206:39 - stored inside here let's do deal with
206:41 - this problem so if we just comment out
206:44 - the total for the time being let's run
206:45 - the
206:50 - code oh we have one more error down here
206:52 - sorry let's run the code again and we
206:55 - can say enter angle one and we can type
206:57 - the values in but as you can see we've
207:00 - got angle one for each of the times what
207:03 - we can do in here is use our I index to
207:05 - print out the value so we can turn this
207:07 - into interpolation and then wrap the one
207:10 - inside curly braces and we can simply
207:12 - change this one to an i and let's see
207:15 - what happens now so we have enter angle
207:17 - zero and then one and then two and this
207:20 - is fine but humans don't like reading
207:23 - zero they like reading 1 two and three
207:25 - so what we can simply do is say I + one
207:28 - and because we're using I and then
207:30 - adding one to it it's not going to
207:31 - affect the variable inside the for Loop
207:33 - so there's no problems by doing this
207:35 - this is simply just for the output
207:37 - purposes so now we can have 1 2 and
207:40 - three just show up like that perfect so
207:44 - what we can do now that we have all the
207:45 - angles stored now we need to replace
207:48 - this line by writing a for Loop that can
207:50 - add up all the values for us so we can
207:52 - have for each in angle inside our angles
207:57 - and we can just say int angle sum plus
208:01 - equals
208:03 - angle the problem with this is we can't
208:06 - specify a new variable inside here and
208:09 - then use it outside an if statement so
208:11 - what do we do in this case you want to
208:13 - take angle sum and initialize it outside
208:16 - the for Loop and then give it a value of
208:18 - zero and then inside the follow we can
208:21 - remove the int and we can say angle sum
208:24 - plus equals the whatever angle that
208:26 - we're currently up to so if we had three
208:29 - values that's going to say 0 + 60 and
208:32 - then take that value and add another 60
208:34 - and then take that value and add another
208:36 - 60 so it'll keep a running total for us
208:38 - and if we just print out angle Su to the
208:40 - screen let's see see what happens 10 20
208:43 - 30 and now we have 60 and that's the
208:46 - correct calculation if you add them
208:48 - three together so now that we have a
208:50 - running total for angle sum then we're
208:52 - pretty much done if we get rid of this
208:54 - line of code which is our previous total
208:57 - and we actually bring back our if
208:59 - statement there you go there's no error
209:01 - now and all this is doing is checking if
209:03 - the angle sum is equal to 180 and then
209:06 - print valid and invalid so we can have
209:08 - 60 60 60 and it prints out valid and
209:11 - let's just comment out our
209:13 - output and then we can have 60 60 59 and
209:17 - then it prints out inv volid which is
209:18 - exact same behavior that we saw at the
209:20 - start so let's remove the extra code in
209:23 - here and keep it like this there you go
209:27 - so now we've got our solution just like
209:29 - this and it's a lot better because if
209:31 - triangles were to transform in the
209:32 - future and we wanted more than three
209:34 - sides then we can easily update this
209:36 - value because now that we're using
209:37 - arrays or we're using a for Loop to
209:39 - enter out the values what we can do we
209:42 - don't actually need to store it what I
209:44 - mean by that is we can actually just get
209:45 - rid of this array completely let me
209:49 - demonstrate we can take this angle sum
209:52 - and place it underneath here we can keep
209:54 - the count so we can use that in the for
209:56 - Loop so we going from 0 to three because
209:58 - that's our angle count and then we can
210:01 - get rid of all this and let's see what
210:03 - we can do now so we have an angle count
210:07 - equals 3 so we go from 0 to three which
210:10 - will'll just do as we said before from 0
210:12 - to two because it's less than the angle
210:14 - count and let's just print this to the
210:16 - screen see what happens so the output
210:18 - still exactly the same but what's
210:20 - happening is these values are not being
210:22 - stored they're just being shown to the
210:24 - screen and then not done anything there
210:26 - is no equal sign here to assign it into
210:29 - anything so what we can do is we can say
210:31 - angle sum plus equals the value straight
210:34 - away and now if we try it 60 60 60 then
210:38 - we get valid the main differences
210:40 - between the these two situations is in
210:43 - the first one we used an array to store
210:45 - all the different values and then we
210:47 - added the total but if we're not going
210:50 - to use these values after then what's
210:52 - the point in storing them we can just
210:54 - use a for Loop to ask the user how many
210:56 - times they want to input the values and
210:58 - then just add them every single time
211:00 - that they add the calculation in and at
211:02 - the end we could just simply use a
211:04 - conditional operator to be able to print
211:06 - at the screen whether it's valid or not
211:08 - but let me just undo that solution so I
211:09 - can show you the array solution and we
211:11 - can have a quick recap that was just an
211:13 - extra little tip just in case you wanted
211:15 - to know what different ways you could
211:17 - use to make this work there we go so
211:19 - let's just have a quick recap here so we
211:21 - have a Conant which all we'll do is let
211:24 - us specify three inside here and then we
211:26 - can use it here this isn't entirely
211:28 - necessary but it does clean up your code
211:30 - a little bit because it gives this
211:32 - number three a bit of a meaning it says
211:34 - the amount of angles is our angle count
211:37 - having a three left over like this is
211:39 - what we call a magic number they're
211:41 - quite bad because it hurts the
211:42 - readability of your code people want to
211:44 - know what the three actually means so if
211:47 - you bring in an angle count then you can
211:49 - actually read we want a set of angles
211:51 - and this is the amount that we need and
211:53 - that's denoted by angle count it adds
211:56 - text to a variable it gives you a way of
211:59 - making sure that the text equivalent of
212:01 - a variable is present so someone can
212:04 - just read it after we've created our
212:06 - integer we can actually make a for Loop
212:08 - that goes from zero to the length and
212:10 - then we ask the US it to enter the angle
212:12 - and in the previous example we had enter
212:15 - angle one 2 and three so now we can
212:17 - mimic that by using I but because I
212:20 - starts at zero we want to use plus one
212:22 - every time we loop around the for Loop
212:24 - we ask the user to enter the number read
212:26 - it in through console read line convert
212:28 - using convert 2 and 32 and then store
212:31 - into the array after this for Loop is
212:33 - finished we have all three values stored
212:35 - in the angles array and then we have an
212:37 - In Sum to count up all the values that
212:39 - we need and and then we use the fall
212:41 - Loop to go through every single integer
212:43 - value inside and make a running total
212:46 - and store it inside angle sum once angle
212:48 - sum has the total count then what we can
212:50 - do is use console right line along with
212:53 - the conditional operator to print
212:55 - whether it's valid or invalid to the
212:59 - screen in this video we're going to look
213:01 - at how we can use the built-in array
213:03 - functions to be able to sort an array so
213:05 - if you have an INT array called numbers
213:08 - and then using the previous notation
213:09 - that we looked at we can actually
213:11 - specify any numbers that we want using a
213:13 - common delimited list so if we just have
213:16 - nine numbers inside here then we've
213:18 - actually defined an integer array and
213:20 - then the compiler can count the amount
213:21 - of items that are inside here and give
213:23 - it the length but we don't have to worry
213:25 - about that ourselves so if we use a for
213:27 - each and we can just print
213:30 - Inn inside numbers we can do a console
213:34 - right line on the new local variable
213:36 - called num if print it out we can see
213:38 - all of the values and maybe we can
213:40 - actually just use a console
213:43 - right followed by a space just to give
213:46 - them all on the same line there we go so
213:49 - as you saw before if you had a string
213:51 - called test and we wanted to do
213:53 - something to it for example if you
213:55 - wanted to use the replace function if
213:57 - you want to remove all spaces with an
213:59 - empty string then if we check the
214:00 - replace tool tip we can see that it
214:02 - returns a new string most of the string
214:04 - functions will return you back the new
214:06 - string after doing something with it but
214:09 - in this case if we type type in Array
214:11 - followed by do sort and we can place our
214:14 - array straight in the bracket what
214:16 - you'll realize is if you hover over sort
214:18 - it will sort the elements in the entire
214:20 - array but it will indeed return back a
214:22 - void and void just means it returns back
214:25 - nothing so in this case what it's doing
214:28 - is you're actually affecting the numbers
214:30 - array straight away and you don't have
214:32 - to do numbers equals array. sort numbers
214:35 - for example if we were doing the test
214:37 - replace we would have to do this
214:39 - otherwise this would just be returning
214:41 - back a string but we wouldn't be using
214:43 - it the same is not true for the arrays
214:46 - when you run the array functions they
214:48 - tend to return back void and you don't
214:50 - have to do anything other than give it
214:52 - the array that you wanted to sort so now
214:55 - if you run this code you should just see
214:56 - the same output since they already
214:58 - sorted anywhere so let's change some of
215:00 - these numbers
215:02 - up and just see what happens
215:05 - now there we go 0255 6 7
215:09 - 899 and that's it sorted just like that
215:12 - there isn't a whole lot to this sorting
215:14 - function but what you should note is you
215:16 - can use this new array syntax to Define
215:18 - how many items that you want in there
215:20 - instead of having to change the amount
215:22 - of positions that you have using the
215:23 - square brackets you can just denote any
215:26 - number of items that you want inside the
215:28 - compiler will count them for you and
215:30 - press the length straight into the
215:31 - brackets for you so you don't have to
215:33 - worry about it using the array. sort
215:35 - function all you have to do is give it
215:37 - the parameter of the array that you want
215:39 - to sort and it will affect the array
215:41 - straight away and you don't have to
215:42 - restore it and then we're just using a
215:44 - simple for each Loop to print them out
215:46 - to the
215:48 - screen in this video I want to discuss
215:51 - the array reverse function so if you
215:53 - hide an INT numbers equal new int and if
215:56 - you just had lots of numbers in here
215:59 - defined just up to five then we can add
216:01 - a semicolon and again using this array
216:04 - function we can see array. reverse and
216:06 - pass our array
216:09 - inside and then we can just use a for H
216:12 - our item inside our
216:14 - numbers and simply just print them out
216:16 - using a console. write and we can use
216:18 - string interpolation I just put a space
216:20 - at the end there we go and if you run
216:22 - the code then you can see our numbers
216:25 - have just been reversed there isn't a
216:27 - lot to this video I just wanted to show
216:28 - you about the different functions that
216:30 - you have available for arrays these can
216:32 - come in handy when you have something
216:33 - like a list return from a database for
216:35 - example and it's ordered in a certain
216:37 - way let's say you're returning back a
216:39 - list of lots of people who ordered back
216:41 - alphabetically and it's going from a to
216:43 - zed and let's say you have some sort of
216:45 - user interface that allows you to flip
216:47 - the order instead of having to request
216:49 - the database to get the data back in the
216:51 - opposite order you can use this array
216:53 - function to just reverse the list the
216:55 - same thing goes if you're trying to
216:56 - order by lowest price or highest price
216:58 - you can use this to show the different
216:59 - values in different orders that's where
217:01 - this array function comes in handy when
217:03 - you have different situations like the
217:05 - names or the price by ascending or
217:07 - descending where you can just flip the
217:09 - data and instead of having to request it
217:11 - back from the database again flipping it
217:13 - locally is a lot easier than going back
217:15 - to the database as that uses more data
217:18 - and more computational power on the back
217:19 - end and then return it to the front end
217:22 - it's always best to be able to use these
217:23 - functions instead of having to use
217:25 - external things to be able to return
217:27 - back the same data using it locally like
217:30 - this will give us a performance
217:31 - Advantage because it's done directly on
217:33 - the data instead of having to request
217:35 - everything again if you wanted to do
217:37 - this manually let's have a look and see
217:39 - what your options are you can have your
217:41 - integer array just defined like this
217:43 - with a dynamic list and then we can have
217:45 - a sorted array using the same length as
217:48 - the current array what you can do
217:50 - instead of using reverse we can actually
217:52 - just comment these lines out you can
217:55 - bring back a normal for Loop but if we
217:56 - use two RS it gives us a reverse Vol so
217:59 - the length is going to be our numbers do
218:01 - length and the rest of the paramet is
218:03 - exactly the same we want to go from the
218:05 - last minus one all the way till zero and
218:08 - we want to decrement in one and we can
218:10 - say our sorted number I is equal to
218:14 - numbers I but all this will do right now
218:17 - is just give us back the same value
218:18 - stored so what we need to do in a case
218:21 - like this is make another variable
218:22 - something like X and we can store that
218:24 - into zero and what we can say is X is
218:27 - assigned the value of whatever this
218:29 - numbers is because this is going
218:31 - backwards but we want this one to go
218:33 - forwards CU we want it to be reversed
218:35 - and we can say x++ and see what happens
218:38 - when we run it
218:39 - now so so nothing's going to come up
218:41 - because we don't have any output so
218:42 - let's use a for
218:44 - each we can have V
218:47 - number inside our sorted numbers and we
218:50 - can just take this and place it in here
218:52 - and just print out the item and we can
218:54 - use
218:56 - num and there you go it's been flipped
218:59 - the exact same value is just the other
219:01 - way so this is obviously a little bit
219:03 - more complicated because you have to use
219:05 - an additional variable use a backwards
219:07 - for Loop and then incom your own
219:09 - separate variable and as well as
219:11 - completely make a whole new array of
219:13 - course you should only do this if you
219:14 - need it as two separate arrays if not
219:16 - you can always just affect the one that
219:18 - you're up to right
219:20 - now because I said before that arrays
219:23 - are actually static data and they're
219:24 - going to be fixed size then there's no
219:27 - way to remove or add an item but you can
219:29 - clear what you have already so let's
219:31 - have a look array do clear set a range
219:35 - of elements in an array to the default
219:37 - value of each element type so the first
219:39 - parameter takes our array so let's use
219:41 - numbers and we want to start off at the
219:43 - index that we want to clear from and
219:45 - let's just say zero and because we want
219:47 - to clear the entire array let's go all
219:49 - the way to numbers. length and now let's
219:52 - just produce a for each of our item
219:54 - inside numbers and then just have a
219:56 - console right string interpolation which
220:00 - just prints out the item followed by
220:01 - space and now let's run the code and see
220:03 - what happens so we have lots of zeros in
220:06 - the console and this is to be expected
220:08 - because as we've talked about before for
220:10 - the default value for an integer is
220:12 - indeed zero so all this is doing when it
220:15 - says it's clearing it's just actually
220:17 - assigning all of the positions the value
220:19 - of zero and we can mimic this quite
220:21 - easily through a for Loop so if we
220:24 - comment this out and write ourselves a
220:26 - for Loop in I equals z and we want to go
220:28 - to numbers. length and then simply
220:31 - inside we just want to say numbers
220:33 - square braet I equals to Z what you can
220:36 - also write is the word default this will
220:39 - pick up the default value for the data
220:41 - type that you specified you can type in
220:43 - zero or you can type in default it's up
220:46 - to you but I think in this case if
220:48 - you're trying to reset it back to
220:49 - default then you don't have to worry
220:51 - about remembering it or any typos you
220:53 - can just use the keyword default so if
220:56 - we run this code now let's see what
220:57 - happens so effectively we've mimicked
221:00 - what this function is doing but let's
221:02 - have a look and see what other
221:03 - parameters we have access to so if we
221:06 - comment this out and drop the value then
221:08 - you can still see we only have one
221:10 - Constructor normally you'd see the open
221:12 - down arrows on the left hand side to say
221:14 - one of two in this case we only have
221:16 - access to one Constructor it will only
221:18 - give us a range of elements we want to
221:20 - remove but really we just want to clear
221:23 - it does say here in the tool tip the
221:25 - array whose elements need to be cleared
221:28 - and because it is a clear and not a
221:29 - remove you got to remember when using
221:31 - this function it doesn't actually remove
221:33 - any of the positions it just resets the
221:35 - values inside the array so what we can
221:37 - do in this case is we can say numbers
221:40 - comma 5 comma 5 and what that will do is
221:44 - the first parameter is where you want to
221:46 - start so if you want to start at the
221:48 - fifth position and then we want to count
221:50 - five forward and because we have 10
221:53 - numbers then this should return back
221:54 - okay let's comment out this for Loops it
221:57 - doesn't take an effect and let's run the
221:59 - code and see what happens now so now we
222:01 - took the position five which is actually
222:03 - the sixth number because it's zero base
222:05 - and said we want to remove five forward
222:08 - so itself and then P more forward and
222:11 - there we go we have five numbers being
222:13 - removed so instead of removing all of
222:15 - the different values we can actually
222:17 - clear a certain amount that we want and
222:19 - to mimic this in a for Loop we can do
222:21 - the following we can start it at five
222:24 - and we want to go to 10 and let's run
222:27 - the code and you can see the output is
222:29 - exactly the same when doing in a for
222:32 - Loop you need to actually calculate what
222:34 - this is going to be so we need to take
222:36 - both the numbers the fifth index and the
222:38 - five length which is 5 + 5 and then we
222:41 - get 10 and we don't make this less than
222:43 - or equal to 10 because we have 10
222:46 - numbers so actually want to go from
222:48 - position five to position 9 which will
222:50 - equate to less than 10 we actually want
222:52 - to go from position five all the way to
222:54 - position 9 which actually covers five
222:57 - numbers 5 6 7 8 9 even though it feels
223:02 - like the difference between the two
223:03 - numbers is only four because 9 - 5 is
223:06 - four but we actually have five numbers
223:08 - between that 1 2 3 4 5 there we go so
223:13 - when we print the values from 5 to less
223:15 - than 10 we're going from 5 to 9 which is
223:18 - exactly what this is doing this is the
223:20 - index that you start at and this is how
223:22 - many numbers you want to count forward
223:25 - so let's just have a quick recap of this
223:26 - function we defined our numbers array
223:29 - using array. clear it doesn't actually
223:32 - clear the values it just gives us access
223:34 - to removing them back to their default
223:36 - values it doesn't actually clear the
223:38 - array it just resets the the values back
223:40 - to their default type we can have
223:42 - numbers parameter which will equal to
223:44 - our array and we want to say we want to
223:47 - go from index0 all the way to numbers.
223:50 - length which will be every single value
223:52 - inside the array and all that will do is
223:54 - go through the array and set them all to
223:56 - their default value which is similar to
223:59 - what this for Loop is doing and before
224:01 - we had inti equals z and I is less than
224:04 - numbers. length and that will go through
224:06 - every single position you can
224:07 - technically use zero instead of default
224:10 - but that would mean you have to remember
224:11 - the default value of every single data
224:13 - type it's easier to just write the
224:15 - default keyword and it doesn't promote
224:17 - any typos using the default keyword is
224:20 - by far the easiest and the most safest
224:22 - option if you're going to have this
224:23 - situation so making every numbers index
224:26 - equal to default in this case because
224:28 - we're using integers it's going to
224:30 - assign the value of zero and then after
224:32 - this voles run with I is zero and I is
224:35 - less than numbers. length it's going to
224:37 - make all of these positions equal to
224:39 - zero which is in essence what this
224:41 - function is here for because arrays
224:43 - can't be added or change in terms of the
224:45 - values that they have after they've been
224:47 - created you can only really modify
224:49 - what's already there or you can reset
224:51 - them all back to zero using this
224:53 - notation from zero to numbers length you
224:56 - can get rid of all the values and make
224:58 - them all zero using five to five means
225:00 - it'll start index 5 which is the sixth
225:03 - position and then go five numbers
225:05 - forward so it will delete these and
225:07 - reset them back to zero you can mimic is
225:09 - and a follow Loop just like this start
225:12 - in I at five and then go to less than 10
225:15 - and the reason why it's less than 10 is
225:17 - 5 + 5 gives you the 10th index but
225:19 - because it's I is less than 10 you
225:21 - actually want to go to the ninth index
225:24 - because from 5 to 9 that's actually
225:26 - covering five different numbers and then
225:28 - we can go through and assign the default
225:30 - value and then when we print it out
225:32 - you'll see that all of these numbers
225:34 - have turned into zeros just like
225:38 - so searching through arrays are very
225:41 - helpful when you try to find some data
225:43 - inside your array and you want to return
225:45 - back the position to maybe do something
225:47 - else with it so let's have a look at
225:48 - this example so we have a numbers array
225:51 - and let's say we want to search number
225:52 - 199 and find the index of it so first
225:56 - let's ask the user what the number they
225:58 - want to search enter number to search
226:01 - then we can have in search is equal to
226:04 - convert to in32 and we're converting the
226:07 - console. readline
226:10 - and then let's have a look at the
226:11 - function so inside the array Library we
226:13 - have an index of searches for the
226:16 - specified object and Returns the index
226:18 - of the first occurrence in a
226:19 - one-dimensional array this is very
226:21 - important as it says the first
226:23 - occurrence which means if there was
226:25 - another 199 at the end it's only going
226:28 - to return you back this one and then
226:30 - stop immediately and not give you the
226:32 - value of this one so let's have a look
226:34 - in the parameters and see what it takes
226:36 - it takes our array and then a value so
226:39 - our array is called numbers and the
226:41 - value you want to search by is our
226:42 - variable called search if you hover over
226:44 - the index function again it says that it
226:47 - returns back an integer zerob based
226:49 - index of the first occurrence of the
226:51 - value in the entire Ray if it was found
226:54 - otherwise the value is going to be minus
226:56 - one so we can say in position is equal
226:58 - to this and because it says if it's
227:01 - going to be found then it's going to
227:03 - have the value of a zero index and if
227:05 - it's not going to be found it's going to
227:07 - have the value of minus1 so we can say
227:09 - if the position is greater than minus1
227:12 - because if it's greater than minus1 that
227:14 - means the value is zero onwards we can
227:18 - also write this by saying if the
227:19 - position is greater than or equal to
227:21 - zero it's just up to you they both mean
227:24 - the same thing and then we can say in
227:26 - here number
227:29 - search has been found at position
227:34 - position there we go so let's run the
227:36 - code and let's do a perfect situation so
227:39 - we can can say 50 and you can see it
227:41 - says number 50 has been found at
227:43 - position three and that's the fourth
227:45 - index since it's zero based and what you
227:48 - could do if you wanted to is actually
227:49 - add one to this just so it looks like a
227:51 - bit more of a readable number because
227:54 - four is going to be the fourth number 1
227:57 - 2 3 4 and let's try find a number that
228:00 - hasn't came up like 60 it's going to
228:03 - return us back with nothing this is
228:05 - really bad because it looks like the
228:06 - search has failed which it has but you
228:08 - need to Output message to let the user
228:10 - know so have conso right line and say
228:13 - number search has not been
228:16 - found let's type that again 60 number 60
228:20 - has not been found so let's see what we
228:22 - can do to be able to write this function
228:24 - ourselves if we just block comment this
228:26 - for the time being we can actually use
228:29 - in
228:31 - position equals to minus1 and the reason
228:34 - why I make it equal to minus1 because
228:36 - when we read the tool tipe of this index
228:38 - function it said if it's not not going
228:39 - to be found it's set to minus1 so why
228:41 - don't we set it to minus1 first and then
228:43 - we can try and find it so in I equals 0
228:46 - and we want to go to numbers. length and
228:50 - inside here we want to scan each of the
228:52 - positions so we can say numbers square
228:54 - braet I and if that is equal to our
228:57 - search then we can set the position
228:59 - equal to I if the number we're up to is
229:02 - equal to what the user has typed in then
229:04 - we want to set our position to the index
229:06 - we're currently up to and we don't need
229:08 - to have an else because we've already
229:09 - set it to minus one and after the for
229:12 - Loop we can actually take this if
229:14 - statement and put it back down here
229:16 - because the code's going to be the same
229:18 - if the position is greater than minus
229:20 - one which in this case is our default
229:22 - value so in essence if this value has
229:24 - changed then this should always pass EG
229:28 - we've found the number so let's run the
229:30 - code and let's type a number in 30 now
229:34 - it's found at position five now if we
229:36 - try 60 again number 60 has is not being
229:40 - found there we go so this function is
229:43 - exactly doing something similar to this
229:46 - it's going through every single position
229:48 - finding the variable and if they match
229:50 - assigning the index and then after just
229:53 - returning back to position back to the
229:55 - console so let's comment our example and
229:57 - let's see what other variants of the
229:59 - function we can use and let's comment
230:00 - back the first one so using this line we
230:04 - can duplicate it and just comment it so
230:07 - we have some other parameters inside
230:09 - here if we add a comma we can actually
230:11 - give it a start Index this is the
230:13 - starting index of the search and let's
230:15 - say you only want to search from the
230:17 - second number onwards then you can just
230:20 - type in the number two so now if you've
230:21 - run the code and type in 90 it's going
230:24 - to say 90 is not found cuz 90 is the
230:26 - first one and let's try a value like 50
230:29 - now it says the number 50 is being found
230:31 - at position four because now it's
230:33 - included in the range from two onwards
230:36 - because this is two onwards it'll be
230:38 - position two until the the end of the
230:39 - array if you wanted a very specific
230:41 - range then you can actually give it
230:43 - another value so we can say we want to
230:45 - go from zero and then we only want to go
230:48 - to forward so if you run that now and
230:50 - type in 22 it says it's not being found
230:53 - cuz we' started here and we said 1 2 so
230:57 - now it's only searching between 90 and
230:59 - 199 and if you wanted to include the
231:02 - middle ones you could say you want to
231:03 - start a position one and go to forward
231:06 - so now you get these two numbers and so
231:08 - on and so forth
231:09 - so now if we try number 90 you'll see
231:12 - it's not being found because 90 is not
231:14 - one of these two the reason why you'd
231:16 - use different ones like this if I revert
231:18 - back the first
231:20 - one this will go from two till the end
231:23 - this will go specific range and this
231:25 - will go through everything the reason
231:27 - why these exist is if you have a very
231:29 - very big array let's say it's a th000
231:31 - indexes then you don't want to search
231:34 - everything unless you really need to
231:36 - let's say for example you had a names
231:37 - array and it was sorted off
231:39 - alphabetically and the person's name
231:41 - that you wanted to search began with an
231:42 - a there is no point in running the
231:44 - search all the way from a to zed if you
231:46 - know it begins with a and let's say for
231:49 - example you found the first index of the
231:52 - user that has a name B so you have now
231:55 - the indexes from the start of the array
231:57 - up until the last array position that
232:01 - has the value of someone's name
232:02 - beginning with a so now you have the two
232:05 - indexes of every single a name inside
232:08 - this array if this was a this was B and
232:11 - this was C and this was D and you had
232:13 - these two positions then you should only
232:15 - be searching all of the a names instead
232:18 - of searching the entire array and the
232:20 - reason for that is you'll be searching
232:21 - lots more data for no apparent reason
232:24 - and it's going to take an extra long
232:25 - time for searching something that you're
232:27 - never going to find if you're searching
232:29 - for a name that begins with a there is
232:31 - no point in searching for anything a BCD
232:33 - and so on and so forth that's where
232:35 - you'd use the very specific range you
232:38 - can say you want to go from zero all the
232:40 - way up to the first B name so then
232:41 - you're only searching the a names this
232:44 - is just one example and there is a lot
232:46 - more every situation is very unique so
232:49 - use the parameters that you want and
232:51 - always use the ones that can get you the
232:54 - best performance the least amount of
232:56 - things that you can search is the best
232:58 - way forward if you don't know what
233:00 - you're going to be searching then you
233:01 - should always use the top one which will
233:03 - just search everything if you know where
233:05 - the value is going to be or roughly
233:07 - going to be the then you can use this
233:09 - one or this one to give you a better
233:12 - range and it's a bit more focused
233:14 - instead of searching for everything so a
233:16 - quick recap of this index function what
233:18 - it will do is it will return you back to
233:20 - position if it's found it the position
233:22 - will be zero based just as arrays are if
233:25 - it hasn't found the position then it's
233:27 - going to return this variable with minus
233:29 - one so therefore after you've run the
233:31 - code you can check if the value is
233:33 - greater than minus one which will be
233:35 - from zero onwards if the value position
233:38 - is z onwards then you know that that
233:40 - number has been found and you can use
233:42 - the position variable to Output that to
233:44 - the screen if the value position is
233:46 - minus one it means the array index
233:49 - function has returned back negative and
233:51 - the value position is now minus one so
233:53 - you can output to the user that it has
233:55 - not been found just in my little
233:57 - explanation down below you can see that
233:59 - we can mimic this function by setting
234:01 - the value of position to minus one using
234:04 - a for Loop that goes from zero to
234:06 - numbers length and if you wanted to as
234:08 - well you could use these inside here if
234:11 - you wanted to mimic this this goes from
234:14 - two till the end so you can say I equal
234:16 - 2 and you still want to go to the length
234:19 - this one goes from one and then to ahead
234:21 - so you can actually put I equal 1 and
234:24 - then because it's two ahead from one
234:26 - instead of numbers. length it will just
234:28 - be I is less than three because 1 + 2
234:32 - gives you the three so in order to do
234:34 - this manually you can Lube through the
234:36 - elements that you want check if the
234:38 - number you're up to to based off the
234:39 - index position of I is equal to the
234:42 - search variable that the user typed in
234:44 - up here and if you find a match then you
234:46 - can assign the position to the value of
234:48 - I after the for Loop is run you can
234:51 - check the same if statement as we
234:52 - discussed above these are copy and past
234:55 - it down below just to give you an
234:56 - example in this little
235:00 - section all these arrays have static
235:02 - data which means that when you
235:04 - initialize them with a certain length
235:05 - you can't increase that length or
235:07 - decrease the length you can only modify
235:09 - the data inside it and you can't delete
235:11 - any rows if you create an array of size
235:14 - five and you only store three people in
235:16 - then now you have two positions that are
235:19 - being unused and that's unnecessary
235:21 - amount of data stored in your memory if
235:23 - you're not going to be using it up in
235:25 - certain situations like when you're
235:27 - making a game for example Tic Tac Toe
235:30 - then you know you're always going to
235:31 - need a 3X3 grid so a 2d array will be
235:35 - perfect in this situation cuz you know
235:37 - the exact width and height height of
235:39 - your array so you can do this perfectly
235:42 - whereas lists are quite Dynamic if you
235:44 - don't know how many people are going to
235:45 - be within a system for example if you're
235:48 - signing up some sort of register for a
235:51 - class or for a school or something of
235:52 - the sort and you don't know how many
235:54 - people are going to be in that class
235:56 - then you can use something called a list
235:58 - a list a dynamic cuz what you do when
236:00 - you initialize it you just say that you
236:02 - simply want a list and you can add items
236:05 - and you can remove items and you can
236:07 - also modify them if you wanted to expand
236:10 - the size of an array it's slightly
236:12 - complicated but it's not impossible so
236:14 - if you had int numbers equals new int
236:17 - and let's make that length four and
236:19 - let's say we had a numbers array that we
236:21 - wanted to increase to length
236:23 - five we could have new numbers change
236:26 - that position five and then what we're
236:28 - going to have to do is from position
236:30 - zero all the way to three which is our
236:33 - fourth length from the numbers array
236:35 - we're going to have to copy that into 0
236:38 - to 3 of the new numbers array so now
236:40 - they have the extra data plus the last
236:43 - one which will give us our four so
236:45 - that'll be five length 0 to three gives
236:47 - us our four numbers and then we have one
236:50 - empty one so we've just made a new array
236:52 - and then copied all the data from
236:54 - numbers into new numbers now of course
236:56 - this is not really practical that if you
236:57 - want to reduce the size or increase the
236:59 - size you're going to have to do this
237:01 - each time of course you don't want to do
237:03 - this you just want to use something
237:04 - called a list so let's stick with an
237:06 - example and see what we can do so you
237:08 - make this and
237:09 - three and let's just put three numbers
237:12 - inside here if you remember from the
237:13 - array video we can also declare it like
237:15 - this we can say number 0 equal 1 and
237:19 - then one and then two and change these
237:21 - values these two are doing exactly the
237:23 - same thing I'm initializing it with 1 2
237:26 - and 3 and also just saying that all the
237:28 - positions in here are equal to 1 2 and 3
237:31 - so we don't need this twice but I was
237:32 - just showing you as a quick recap so
237:34 - we're declaring array we're calling it
237:36 - numbers and we're giving it a length of
237:38 - three and initializing it to 1 2 and 3
237:41 - now let's see the syntax to define a
237:43 - list you start off with the word list
237:46 - and then you have a left and a right
237:47 - arrow which makes a little section
237:49 - inside the section you actually want to
237:50 - State the data type that you want so if
237:52 - we're copying the numbers array we can
237:54 - have an INT inside here and that's it
237:57 - for the Declaration of the data type and
237:59 - then we can say new numbers or List
238:01 - numbers equals to new and then there you
238:05 - go it gets Auto filled for you but let's
238:07 - just type it in we have list open the
238:10 - arrow in in the middle and then close it
238:13 - so now it's the same on both sides but
238:16 - because this is a new we need to add a
238:17 - Constructor so we can open the curly
238:19 - braces and the first Constructor says
238:21 - initialize a new instance of the list
238:23 - class that is empty and has the default
238:25 - initial capacity press the down arrow we
238:28 - can give it a capacity of the number of
238:30 - elements that the new list can initially
238:31 - store so we can start it off with five
238:34 - length or three length or whatever it
238:36 - doesn't actually matter it just means
238:38 - that we actually have three positions
238:39 - available immediately if we place three
238:42 - in the
238:43 - brackets and the last one we can
238:45 - actually give it entire collection so
238:47 - let's say if we loaded a list of numbers
238:49 - from a database or a list of something
238:52 - from database and we can actually insert
238:54 - it straight into this list by putting a
238:56 - list inside these brackets of course
238:59 - right now we don't have a list that
239:00 - we're going to assign it with so let's
239:02 - just leave this empty and close the
239:03 - brackets and add a semicolon so we could
239:06 - say list numbers do add and then we can
239:09 - add one and then duplicate this down and
239:11 - add two and add three so now these two
239:14 - have exactly the same contents instead
239:16 - of doing this you can have the same
239:18 - notation like this so you can have the
239:20 - codyy braces in
239:22 - here and we can put in one 2 and three
239:25 - now that's doing exactly the same thing
239:27 - and you see I can just keep adding more
239:29 - numbers in here and the list simply
239:31 - doesn't care but as soon as I add one
239:33 - more into here then I'm going to get a
239:35 - syntax error because it complains that
239:37 - the length is not equal to to the
239:38 - numbers that we
239:39 - have because the list are really Dynamic
239:42 - it doesn't matter how many you put in
239:43 - here because it can just go on forever
239:45 - of course until you run out of memory so
239:47 - let's have a little working example just
239:49 - to see how this
239:51 - works so we can have a for Loop and we
239:53 - can go from 0 to 10 or maybe 0 to 3 just
239:56 - so we don't have to enter as many values
239:58 - we can have a console right that kind of
240:00 - just says enter a number and then let's
240:02 - read that in and we can say in n equals
240:05 - convert to in 32 and we can place a
240:08 - console. readline inside
240:11 - here and then after we've got the
240:13 - console read line we've got an inome
240:15 - that's being converted from the console
240:17 - input inside our integer num and from
240:20 - there we can take our list numbers do
240:22 - add and we can add the num inside there
240:25 - or if you want to reduce a variable you
240:26 - can just take this line and place it
240:28 - straight into here now if you get rid of
240:31 - that when this fall Loop runs will have
240:33 - three iterations let's run the code and
240:35 - find out 1 2 3 so now we've ented three
240:39 - numbers and now they've been stored in
240:41 - the list so let's create a follow loop
240:43 - after and we can go from zero all the
240:45 - way to list numbers do length but of
240:48 - course when we're using list we don't
240:51 - have a length anymore when we're using
240:53 - arrays we have length because arrays
240:56 - have a fixed length whereas lists have a
240:58 - count of the items inside it so instead
241:01 - of length we simply use count and then
241:04 - inside here we could just do what we
241:06 - normally do and say list number numbers
241:08 - square braet I and let's run that and we
241:11 - should see the numbers printed back out
241:13 - in the exact same order 1 2 and 3 and
241:16 - the same principle goes if you use a for
241:18 - each Loop we can say V item inside list
241:20 - numbers and that's all you need to do
241:22 - and you can just print item to the
241:24 - screen now we should see the same output
241:26 - twice let's have a look at other values
241:28 - that we have inside here so we type in
241:30 - list numbers Dot and let's have a look
241:33 - at the functions inside so we can add
241:35 - which you just used above we can convert
241:37 - it to an array we can remove a specific
241:39 - position and we can clear it completely
241:42 - they have other ones in here like binary
241:44 - searches we can check if it contains a
241:46 - certain element this is going to be very
241:47 - handy when we do our
241:49 - remove we can convert them all to a
241:51 - different type we have a copy to we
241:54 - check if a value exists
241:56 - inside we have a find finding all of
241:59 - them the difference between these two is
242:01 - the find will return back the first one
242:04 - whereas find all will retrieve all the
242:05 - elements that match it finding the index
242:08 - of a specific match finding the last
242:10 - index iterating through them all you can
242:13 - insert a specific position whereas the
242:15 - ad will just insert at the end of the
242:17 - list adds an object to the end of the
242:20 - list inserts an element to the list at a
242:23 - specified index and then you have remove
242:26 - which gives you the first occurrence so
242:28 - you can type the number straight into
242:30 - there so you can ask the user what
242:32 - number do you want to delete and if they
242:34 - type zero it will delete the first zero
242:36 - in the list and you can can remove all
242:38 - so if you want to remove every single
242:40 - zero inside the list you can do that as
242:42 - well or you can remove a specific
242:44 - position this is the most used function
242:47 - because what you can
242:48 - do and what you can do is use the find
242:51 - index search for an element that matches
242:53 - a condition and then returns zerob based
242:55 - index the first occurrence so if you
242:58 - want to delete the number zero from the
243:00 - list you could use find index and that
243:02 - returns you back with an INT and then
243:04 - you can use the remove at and then pass
243:07 - that index straight into there you can
243:09 - also sort it so it goes up in number
243:11 - order we did this with the array. sort
243:13 - function as well and if you wanted to
243:15 - you can also reverse the entire list
243:17 - this can be very helpful as we did with
243:19 - the array functions if you just wanted
243:21 - to reverse them all in case someone had
243:23 - something like a filter when you're
243:25 - doing from Price high to low and low to
243:27 - high the difference between them two
243:29 - lists is simply the list flipped so
243:31 - let's run a remove just inside here and
243:33 - let's see what happens so we can say
243:35 - remove that and let's say position zero
243:38 - so we type in 1 2 and three you'll see
243:41 - that 1 2 3 gets printed out and then
243:44 - I'll hit this remove at and it will
243:46 - delete the first index and in this case
243:48 - the first index is going to be our
243:49 - number one so now this has became our
243:52 - first index and this is our second index
243:54 - and it's got rid of the number
243:57 - one so let's move on to a different data
244:00 - structure called dictionaries
244:02 - dictionaries are generic collections
244:03 - that store key value pairs in no
244:05 - particular order they take in a t key
244:08 - key and a t value and these just mean
244:10 - the key and the value can be any data
244:12 - type that you want dictionaries come
244:14 - under the system. collections. generic
244:16 - namespace and if you don't include this
244:18 - line at the top then you'll have to type
244:20 - in system. collections. generic space
244:23 - dictionary every single time you want a
244:25 - specify dictionary putting the name
244:27 - space at the top will include it within
244:29 - the project and you can use dictionaries
244:30 - freely so one thing to know is the keys
244:33 - must be unique and they cannot either be
244:34 - null values can be null or duplicate cuz
244:37 - they're the value values depending on
244:38 - the key as long as the keys aren't the
244:40 - same then the values can be similar so
244:42 - let's have a look and see what we can do
244:44 - we can type in dictionary and you can
244:47 - see it has the arrows either side and
244:49 - you can see here it says T key and T
244:51 - value and what T key and T value is is
244:54 - it gives us the flexibility to add any
244:56 - data types that we want we can add in
244:58 - two strings in here for example or we
245:00 - can do anything that we please so in
245:02 - this example I just want to start a list
245:04 - of names and I want to give them a
245:06 - unique identifier and this unique
245:08 - identifier will just give them a number
245:10 - that their profile is up against it's
245:12 - the same way whenever you make an
245:14 - account with any sort of website when
245:16 - your data gets stored in the database
245:18 - you have a unique ID for your account
245:20 - and this is the same thing that I'm
245:22 - trying to replicate here we have a
245:24 - unique ID and with that unique ID comes
245:26 - a name so we can say equals new
245:29 - dictionary just like we do with the list
245:32 - we can end the brackets and end the
245:34 - semicolon there and now we've created
245:36 - our dictionary and the exact same
245:38 - principle we can use with the list we
245:40 - can simply type in the name of the
245:42 - variable of the dictionary and type in
245:45 - add and then we have access to int key
245:47 - and string value and this parameter is
245:50 - going to change if this now becomes a
245:52 - string as I'll show you
245:54 - now and if we reopen the bracket you'll
245:57 - see this has turned into a string key so
246:00 - that will change depending on the data
246:01 - types that you specified so let's say we
246:03 - want to add one and we want to add
246:06 - ourselves then we can dup at this down
246:09 - and add in two and three and we can say
246:12 - test and test and now if you run the
246:14 - code you'll see that we have no errors
246:16 - and nothing's going to show up I'm just
246:18 - demonstrate that it compiles okay and
246:20 - the same thing with the list we can also
246:23 - simplifies the initialization process
246:25 - and it looks something like this so
246:28 - because this is a key value pair we can
246:30 - no longer just type it in one line they
246:32 - need to be in a little block so when we
246:34 - wrap these around the curly brace we can
246:36 - have the key on the left left and the
246:38 - value on the right and one of these is
246:40 - called a key value pair key value pair
246:45 - and we will use these in the for each
246:46 - Loop in a second when we print out all
246:48 - the values to the console so let me just
246:50 - demonstrate something about what I said
246:52 - at the start I said that all keys must
246:54 - be unique and there's a reason why I
246:56 - said that if we duplicate the first
246:58 - entry therefore giving us the same key
247:01 - as one and we try run it and let's see
247:03 - what happens we get something called a
247:05 - runtime error this runtime error happens
247:08 - when we run the program and it's got
247:10 - nothing to do with compile time or our
247:12 - logic an item with the same key has
247:14 - already been added so we need to watch
247:16 - out if we do this because our program is
247:18 - going to compile but it's not going to
247:19 - work at runtime and let me demonstrate
247:21 - another fact if we make this number four
247:24 - and our values are exactly the same once
247:26 - we run this it will still work fine
247:29 - values can be the same but the keys
247:31 - cannot be the same the keys have to be
247:33 - unique so just like with our lists and
247:35 - our arrays we can use a for each or for
247:38 - Loop to access this directly so we can
247:40 - say 4 in I equal 0 and we want to go
247:43 - names. count and the same reason it to
247:46 - do count for a dictionary as it is for a
247:48 - list but it's not for an array
247:50 - dictionaries don't have fixed length and
247:52 - neither do lists they are very Dynamic
247:54 - and basically are a list list can only
247:57 - store one different data type whereas
247:59 - dictionaries give you a key and a value
248:01 - so as we said above we have a key value
248:03 - pair so let's try and print this and see
248:05 - what happens have a console right line
248:07 - we can say names square bracket I and
248:10 - that will give us back the position the
248:12 - issue with this is it will just give us
248:13 - back the string and let's just see what
248:15 - happens if we print
248:17 - this then we get an exception because no
248:20 - key was given and the problem with this
248:22 - situation is we can't use this like a
248:24 - list Geto sets the value associated with
248:27 - a specified key what this means is when
248:29 - we give our square bracket I inside here
248:32 - this is actually not talking about the
248:33 - index this is actually trying to do a
248:35 - search on these keys
248:38 - so if you actually change this to one
248:40 - then we should get ABA return back this
248:42 - is not actually doing an index Lo up
248:44 - it's doing a key lookup and the reason
248:47 - for that is what we're going to have to
248:48 - do instead is say names do element at
248:51 - and then what we can do inside there is
248:53 - place our index so this element art will
248:56 - return us back with the key value pair
248:58 - as I said above here so how this
249:01 - variable works is we can do key value
249:03 - pair and then we need to specify this
249:05 - variable the same way we've got it up
249:07 - here so we have an INT inside a string
249:10 - and then we can say a pair and make that
249:12 - equal to the function called element at
249:15 - as that returns us back with a key value
249:17 - pair in string and of course if you
249:20 - wanted to make this a lot smaller you
249:21 - could just simply use VAR but let's keep
249:23 - it as key value pair just so you can
249:25 - understand what's going on and the
249:27 - reason why we need to get the key value
249:28 - pair is if we want to retrieve the
249:30 - integer and we want to retrieve the
249:32 - string and now we can use pair. key and
249:35 - pair. value and because these are both
249:38 - integer and this one is a string it
249:40 - matches our pair exactly so we can take
249:43 - these values and go to our console right
249:45 - line and we can say something like this
249:47 - use string nipulation and say pair. key
249:49 - and then maybe add a hyphen and then say
249:52 - pair do value and then just remove these
249:54 - two lines and let's try and run it now
249:58 - there we go so we get all the values and
249:59 - it doesn't matter what this key is it
250:01 - can be something random it doesn't
250:03 - really make a difference like I said
250:05 - this doesn't have to be in a specific
250:07 - order
250:08 - so let's keep it as 1 2 3 there we go so
250:11 - you can see using a for each Loop to
250:12 - print this is a little bit more
250:14 - complicated let's have a look and see
250:16 - what it takes when you use a for each
250:18 - Loop for each VAR item inside our
250:23 - names and as you can see here our item
250:25 - is automatically a key value pair of int
250:28 - and string and again what you can do is
250:31 - type this straight into here just so you
250:33 - can get used to the notation and there
250:35 - you go it's still a key value pair and
250:38 - then now what we can do is we can take
250:40 - this exact line and paste into here and
250:42 - instead of pair we have item and this
250:45 - should return us back the exact same
250:47 - values and if we just separate with a
250:48 - console right line there we go okay so
250:51 - now that we've understood this let's
250:53 - take a look at an example let's comment
250:55 - this out and let's create another
250:57 - dictionary so we can say dictionary and
250:59 - then we can have a string of
251:01 - string and we can call this teachers
251:04 - equals new dictionary string of string
251:06 - again and we can add our curly brace
251:08 - just so we can add our Valu straight to
251:10 - here so as you said before we need to
251:11 - open curly brace and close curly brace
251:14 - and then we can say the math teacher is
251:15 - called abber and then we can add another
251:18 - one and we say the science teacher is
251:21 - called test there we go so we've
251:22 - initialized our teachers and we said
251:24 - that the value that we want to give it
251:26 - is a unique identifier which is going to
251:28 - be our string assigned to the subject
251:31 - and this is going to be the teacher that
251:32 - is assigned to this subject so what we
251:34 - can do inside here is we can have a
251:36 - console right line and we can do
251:38 - something like this so remember when I
251:40 - was saying in the for Loop we can't
251:41 - actually use the square bracket notation
251:43 - like this because this is inferring to a
251:45 - key rather than a position so we had to
251:48 - use element at just to find out the key
251:50 - value pair and then to print out to the
251:52 - console so because the square brackets
251:54 - is an actual sech let's try and make use
251:57 - of that now so we know that there's a
251:58 - math class available so we can type math
252:00 - in here and what does should return us
252:02 - back is abber there we go so what that's
252:04 - doing is it's searching through our
252:06 - dictionary find ing this element inside
252:08 - here and then return us back with the
252:10 - value for that key get all sets the
252:13 - value associated with the specified key
252:15 - the problem with using this approach is
252:17 - it says here if the specified key is not
252:19 - found a operation throws a key not found
252:22 - exception let's just say for instance I
252:23 - mistyped the math and now we're just
252:25 - going to get a runtime error and it's
252:27 - going to be a horrible exception and our
252:29 - code is obviously going to break this is
252:31 - similar to what we do when we have int.
252:33 - trass we don't just trass it immediately
252:36 - and convert it it without actually
252:38 - checking if it's a valid value so
252:40 - instead of doing this line what we can
252:42 - do is we can check if that key exists
252:45 - first before we then use it so we can
252:48 - say if
252:49 - teachers do try and get the value which
252:52 - is a similar to what we have with trass
252:55 - and then the first parameter is the key
252:57 - that we want which is going to be our
252:59 - math and then out here is going to be
253:02 - the variable that we want to Output out
253:04 - so we can say out
253:06 - teacher and then open the curly braces
253:09 - and then inside here we can print out
253:11 - the teacher so we try to get the value
253:13 - for Math and if we found that key inside
253:15 - these then we return back the value
253:17 - inside our teacher the same way works
253:20 - for our
253:24 - tripassure if it successfully passed it
253:27 - and if it hasn't we can say cons output
253:30 - math teacher not found so let's try and
253:34 - run that now you see we get return back
253:36 - abber and if if you actually drop the
253:37 - lower case then it says the math teacher
253:40 - is not
253:41 - found alternatively what we can do
253:43 - inside here let's assume that this is
253:45 - correct we can take this value and place
253:48 - it straight inside the square brackets
253:50 - and do this again this is kind of
253:52 - redundant because we've told it to get
253:54 - the value for key place inside teacher
253:56 - and then we're just going back to the
253:57 - dictionary to get the value twice so
254:00 - make sure if you have an output variable
254:02 - that you actually use it inside here you
254:03 - can see that you're not using it when it
254:05 - goes a slightly dark color like this so
254:07 - just like in the last examples when we
254:09 - were placing values inside our list we
254:11 - can also do that in dictionaries we can
254:14 - say teachers square bracket math and
254:16 - then we can make that equal to something
254:18 - so if the math teacher were to change
254:20 - and now the teacher's called Joel then
254:22 - we can run this line and print out to
254:24 - the screen let's just take that for each
254:25 - Loop and tailor it to the new dictionary
254:28 - and see what happens when we run it so
254:30 - let's just change this into our V to
254:31 - make it simple and then we can have
254:33 - teachers inside here there we go so now
254:35 - let's just run this and see it now it
254:37 - says abber is the first value the abber
254:40 - is coming from console right line here
254:42 - that says teacher this is one line
254:44 - before we change it and we change the
254:46 - value of the math teacher to jaw on the
254:49 - next line and there we go it's committed
254:51 - the change and just like in the last
254:53 - video as well when we try to delete
254:54 - something from the list let's see what
254:56 - we can do to delete it from here so we
254:58 - can have teachers do remove and you can
255:00 - see that it says key in there and again
255:03 - if we add the key in like this then it's
255:04 - going to work just fine there go we just
255:07 - have science we don't have math anymore
255:09 - but if I drop the lowercase then it's
255:11 - going to cause us back with an error but
255:13 - in this case instead of it thrown an
255:14 - exception like it did when we were
255:16 - trying to do up here and up here as well
255:19 - the problem with using the remove is you
255:21 - just simply won't remove it but what it
255:23 - will do is it'll give you back a
255:25 - building if you remember from the last
255:27 - video we actually had a look at a
255:29 - section where in the list it gave you
255:31 - back a booing whether the remove
255:32 - function worked or not alternatively
255:34 - what you could do instead of using the
255:36 - remove function is to check if the item
255:39 - exists in the first place we can say
255:41 - contains key and we can place math
255:43 - inside here and if it does contain it
255:45 - then we can run the same line of code
255:47 - and we can say remove and then use math
255:50 - just to make sure that this is has been
255:52 - actually removed and then in the else we
255:54 - can say math not found retrieving values
255:58 - back should be retrieved using try get
256:00 - just so you don't cause an exception if
256:02 - this is not found we can simply do an
256:04 - update by placing the value of the key
256:06 - inside this square brackets and then
256:08 - simply just assigning it to something
256:10 - else this assignment will change the
256:12 - value of the key which is inside the
256:14 - teacher dictionary and if you wanted to
256:17 - remove something it's best to use the
256:18 - contains key just to check if it
256:20 - contains it first and then you can do
256:22 - the remove and then if it doesn't
256:23 - contain it you can tell the user that
256:25 - math has not been found and then finally
256:28 - we can just print it out like
256:30 - this so in this exercise I want you to
256:33 - create two lists with the integer data
256:35 - type one for even and one for odd and
256:37 - then we're going to Loop through from
256:38 - zero all the way till 20 and if the
256:40 - number is even add it to the even and if
256:43 - the number is odd add it to the odd list
256:45 - and at the end print out all the values
256:47 - for even and for odd I know you can just
256:49 - print these out inside the for Loop we
256:51 - don't have to have dedicated lists but
256:53 - this is just for list practice and I
256:55 - want to talk about different ways that
256:56 - we can do this solution so let's start
256:58 - we can have a list of int and we can say
257:01 - odd new list int and we don't know the
257:05 - size so we're just going to leave the
257:06 - gap empty and if we duplicate this down
257:09 - we can simply just change this to even
257:11 - now the reason why we're doing lists
257:13 - we're going from 0 to 20 of course this
257:15 - 20 value could be anything it could be a
257:17 - million it could be 100 but we don't
257:19 - know and the point is lists have counts
257:23 - whereas arrays have length if we set the
257:25 - array length to something like a
257:26 - thousand we know probably be able to
257:28 - contain all the numbers inside there but
257:30 - that's going to be a lot of positions
257:31 - that we don't exactly need because
257:33 - arrays are not really dynamic because
257:35 - they're static then it's it's best to
257:37 - use list in this case because we don't
257:39 - know how many numbers are going to be
257:40 - odd or are going to be even between this
257:43 - range if we knew the exact number of
257:45 - positions that we needed in a given
257:47 - solution then array would be better
257:49 - since you don't want it to be dynamic if
257:51 - it doesn't need to be so let's start you
257:53 - can have a for Loop that goes from 0o to
257:55 - 20 if you want to include the 20 as well
257:58 - we can just place an equals the best way
258:00 - to determine if a number is odd or even
258:02 - is to use the modulus operator so we can
258:04 - say I percentage 2al equal 0 and what
258:07 - this will do is it'll tell us if I is
258:09 - divisible by two if the value is equal
258:11 - to zero if you have two modulus 2 then
258:15 - the remainder is going to be zero if you
258:17 - have three modulus 2 it's going to be 1
258:20 - * by 2 which gets you to two and then to
258:23 - go from two to three you actually have
258:25 - one so if you insert an odd number and
258:28 - do a modulus 2 you're going to get a one
258:31 - returned if you do an odd number and you
258:33 - do modulus 2 then you're going to get
258:34 - one returned if you do an even number
258:36 - modulus 2 then you're going to get zero
258:39 - returned so what we can do in here is we
258:41 - can say even do add and then we can
258:43 - simply add I and then in the else we can
258:46 - also simply just do odd do add and then
258:49 - have I because the values of the
258:51 - remainder can only be Zer or one we
258:53 - don't need to have an lse if in here
258:55 - doing this is a little bit redundant
258:57 - although it's still technically correct
258:59 - the values can only either be zero or
259:01 - one so if you run this calculation and
259:03 - the value is zero if you run this
259:05 - calculation and the value zero the only
259:07 - other value can possibly be is one so
259:10 - therefore we don't need additional
259:11 - condition so therefore we don't need
259:13 - this additional condition and we can
259:14 - simply get rid of it if I modulus 2 is
259:17 - equal to0 then we add the number to even
259:20 - and else we add it to odd normally when
259:22 - you have situations like this we can use
259:25 - the conditional operator where we have
259:26 - the question mark followed by the colon
259:29 - but in this case we're actually doing
259:30 - two different assignments we're either
259:32 - assigning into the even or assigning
259:34 - into the odd so there's no room for the
259:36 - conditional operator so at this point we
259:38 - should have all the even and odd values
259:40 - from zero all the way to 20 inside our
259:43 - two lists so then we can now just print
259:45 - both the list out so we can say printing
259:49 - even numbers and then we can have a for
259:51 - each Loop that goes v item inside our
259:53 - even and then we can do a console Right
259:56 - add some inst string interpolation and
259:58 - then we can say item followed by space
260:01 - then we can print environment. new line
260:03 - just to give it some space and we can
260:05 - say printing odd numbers
260:07 - here we go and then we can just take
260:08 - this exact for Loop and copy it down
260:11 - instead of saying in even we want to do
260:13 - in odd and this exactly the same since
260:15 - the variable name is exactly the same
260:17 - let's try run the
260:19 - code there we go it's got zero all the
260:22 - way till 20 and you can see it goes up
260:24 - in twos hence all even numbers and we
260:26 - also get these going up in twos except
260:28 - it starts from one and this covers all
260:30 - of the odd numbers and if we change this
260:32 - number up to something like 50 then the
260:34 - list will just grow and they Cod just
260:35 - still work okay you can see that all of
260:38 - these numbers are still consistently
260:39 - even so now that our task is actually
260:41 - complete let's just have a little recap
260:43 - so the reason why we're using lists and
260:45 - we're not using arrays is for this exact
260:47 - nature if we have 0 to 10 then we can
260:51 - almost work out how many even numbers
260:53 - and how many odd numbers we can have we
260:55 - can manually count we have zero and then
260:58 - 2 4 6 8 and 10 and then for odd we have
261:01 - 1 3 5 7 and 9 so we know how many
261:05 - numbers exist within here but what if we
261:08 - just change that number to 50 then now
261:10 - we have a lot more odd and a lot more
261:12 - even it's impractical to type these
261:14 - numbers in and then to Simply count them
261:16 - in your head and then make an array
261:18 - length based on that position that's a
261:19 - bad solution because not all cases
261:22 - you're going to have the flexibility of
261:24 - Simply typing in the numbers like this
261:25 - and Counting them yourself these numbers
261:27 - could be something that typed in by a
261:29 - user or something loaded for something
261:31 - external like a text file you need to
261:33 - understand that these values can be
261:35 - generated from anywhere and if you just
261:37 - type them in then it provides an
261:38 - unrealistic expectation of how to write
261:40 - some programs so what you have to bear
261:42 - in mind in situations like this is you
261:45 - simply don't know how many even and how
261:47 - many odd numbers will be appearing
261:49 - during this range so you want to use a
261:51 - list so it as dynamic as possible we
261:53 - have two lists in this case one to store
261:56 - all the odd numbers and one to St all
261:57 - the even numbers we don't initialize
261:59 - them with any sort of capacity we just
262:01 - keep it empty for the exact reason we
262:03 - don't use an array we Loop through from
262:05 - zero to anything we don't even have to
262:07 - Lo from zero we can also just start this
262:09 - at 100 and go all the way to th000 it
262:12 - really doesn't matter what our number
262:14 - ranges the only thing that matters is
262:16 - that we have a list that is going to be
262:18 - dynamic and then we can calculate
262:20 - whether the number is odd or even and
262:23 - add it to the right list how this works
262:25 - is we use I which is the number we're
262:27 - currently up to and we calculate the
262:29 - modulus of it to check the remainder if
262:31 - the remainder is zero then it must be
262:33 - even as it's divisible by two and if
262:35 - it's anything else than Z zero which you
262:36 - can only ever be one in this case when
262:38 - using modulus 2 then we add it to the
262:41 - odd list after this followup has run now
262:43 - our odd and even lists have all the
262:45 - values that they should have and we
262:47 - simply just write these two blocks are
262:49 - exactly the same just print the even
262:51 - numbers and print them out print the odd
262:53 - numbers and simply print them out to the
262:55 - screen and that's it and if you run the
262:57 - code it might get a little bit crazy in
262:58 - here but as you can see these will
263:00 - actually work if you pick any random
263:02 - numbers you can see that they're all
263:04 - divisible by two and this same thing
263:06 - goes for odd you can see that they're
263:08 - not divisible to cuz they're all
263:11 - odd so in this exercise we're going to
263:14 - cover a little task I like this call
263:15 - this task an array of multiples so we
263:17 - want to Define initialize two integers
263:20 - and num into length so in the case of
263:22 - this example we have a number seven and
263:24 - the length of five so what this will do
263:26 - is it will essentially give you the
263:28 - seven times table but only the first
263:30 - five numbers 7 14 21 28 and 35 we take
263:35 - the first number which is Nome which
263:37 - will give us the multiples and we take
263:39 - the second number which is the length
263:41 - and that gives us the size of the array
263:43 - so we create the integer array with the
263:44 - size of length Loop through the array
263:46 - and insert the loop count Times by
263:49 - because this is 1 * 7 2 * 7 and so on so
263:52 - forth until we reach the length and we
263:54 - place into the array and then finally we
263:56 - paint the array just to give us these
263:58 - values out to the console all right so
263:59 - let's get started we can have it into
264:01 - norm and make it equal to seven and we
264:04 - have it into length and make that one
264:06 - equal to 5 now the defined initializer
264:08 - two integers let's create the int array
264:10 - with the size length int array result
264:13 - equals new int and we want size length
264:16 - after that we want to create our for
264:17 - Loop now this is the tricky part if we
264:19 - try go from zero all the way to result.
264:22 - length then let's see what happens so we
264:25 - want to start result I you want to make
264:27 - that equal to number which is our array
264:29 - of multiples Times by the value that
264:31 - we're currently up to now let's print
264:33 - our array using for each Loop to see the
264:35 - value so we can say a v item inside our
264:38 - result then we can have a console right
264:40 - that just prints one of them at a time
264:42 - so we can say item followed by spits now
264:45 - let's see what happens when we run
264:47 - it so we get 0 14 21 and 28 and as you
264:51 - can see these are the first four numbers
264:53 - so we're close what we're nearly there
264:56 - because our array starts at zero and it
264:58 - goes to the length which in this case is
265:00 - going to be 0o to less than five which
265:03 - will cover the positions of 0 to four
265:07 - with these positions it's going to do 0
265:09 - * 7 1 * 7 and then get to 4 * 7 and not
265:13 - actually get to the fifth because we're
265:15 - starting from zero so alternatively what
265:18 - we can do or what you think you can do
265:20 - is change it to a one and changes to
265:22 - equal to so now what it's doing is it's
265:25 - going from one all the way to five which
265:27 - is still covering the same amount of
265:29 - positions it's just one index forward so
265:31 - now if we try to run the code then we
265:33 - get a runtime exception and the reason
265:35 - for for that is it's trying to access
265:37 - position number five if we hover over I
265:40 - we have five and if we hover over the
265:43 - result we actually have some of the
265:45 - right values except it's trying to get
265:47 - to the fifth position and it's not
265:49 - working the reason why the zero index is
265:51 - actually zero is simply because that's
265:54 - the same value as the default value
265:56 - because our for Loop started at in I
265:58 - it's actually only starting from here
265:59 - and going down so this calculation is
266:01 - actually correct but it needs to be back
266:03 - one we need to start the multiplication
266:06 - on IAL 0 but our for Loop needs to start
266:09 - on IAL 1 so we can get all the way
266:12 - through so we have two ways of doing
266:15 - this we could say IUS one so even though
266:18 - it goes from 1 to 5 it's still assigning
266:20 - into the array using 0 to 4 so if we run
266:23 - that we can see that that will give us
266:25 - the desired result alternatively what we
266:27 - can actually do instead of doing IUS one
266:30 - inside here we can define a variable
266:32 - called counter and make it equal to zero
266:35 - we can change this this to counter and
266:37 - we don't need to change the
266:38 - multiplication because that's already
266:39 - going from one to the length which is 1
266:41 - to 5 in this case after the follow is
266:44 - run we need to remember to increment
266:46 - counter so there we go we have the
266:48 - desired effect another hack if you're
266:50 - interested if you have two variables
266:52 - that you want to increment inside a for
266:54 - Loop you can see that we already have I
266:56 - ++ in here which will increment it by
266:58 - one and we want to increment counter by
267:00 - one as well every single time it loops
267:03 - around what you can actually do is
267:05 - remove this and you know how these are
267:07 - broken up by semicolons that indicates
267:09 - that the section has ended the first
267:11 - section is for declaration the second is
267:13 - for the range and the third is so you
267:15 - can increment the variable or decrement
267:17 - it when you trying to increment two
267:18 - variables inside a for Loop instead of
267:20 - placing a semicolon here and type in the
267:23 - next one you can actually place a comma
267:25 - and do counter Plus+ what that will tell
267:27 - the for Loop is every single time you go
267:30 - through you want to do a series of these
267:32 - actions and because we have i++ and
267:34 - counter Plus+ then that's going to work
267:37 - exactly the same way it just prevents us
267:39 - having counter Plus+ down here and we
267:41 - can move it inside the for Loop just so
267:43 - it doesn't for us and it looks a lot
267:45 - cleaner cuz you can clearly see that
267:47 - every single time we loop around this
267:49 - for loop we're going to increment these
267:50 - two variables there we go so let's try
267:54 - to put some different values in here
267:55 - maybe make this 10 and we can have 10 on
267:57 - both which should give us the first 10
267:59 - numbers there we go from 10 all the way
268:01 - to 100 let's have a little recap so
268:04 - we're essentially just making an array
268:06 - that will give us back all the multiples
268:07 - so it's like a mini times table but the
268:10 - fact that we're doing it dynamically
268:11 - using our array is quite important what
268:14 - you can do if you wanted to is to extend
268:16 - this program you can ask the user to
268:18 - type these into the console and then
268:19 - convert them and use them right now
268:22 - we're just statically typing them in and
268:23 - that's not really an issue since the
268:25 - main focus was doing this for Loop if
268:27 - you wanted to you could ask the user and
268:29 - you can type these values in so you
268:31 - don't have to change them every single
268:32 - time you compile so now we've got the
268:34 - number and the length let's make our
268:35 - inter the rare call result and
268:36 - initialize it to the length we set up
268:39 - this counter so we simply didn't have to
268:40 - do I minus one here so it looks a little
268:43 - bit more intuitive we start the follow
268:45 - from one and go to the length so we can
268:48 - access 1 to five and the reason why we
268:50 - want to do 1 to five so when we do our
268:52 - multiplication it doesn't start at zero
268:55 - these two are going through the exact
268:56 - same amount of indexes 1 to five is five
268:59 - numbers and 0 to four is also five
269:01 - numbers so when we do our multiplication
269:03 - we want to start from one since the
269:05 - timetable normally starts at one and we
269:06 - go to the length the reason why we're
269:08 - using the counter is so we don't have to
269:10 - do IUS one in here and it breaks up the
269:12 - logic a little bit and it looks nicer
269:14 - with our counter we start our counter at
269:16 - zero and instead of incrementing down
269:18 - here we use this fancy comma and we can
269:21 - say we want to increment I and counter
269:23 - every time the for Loop goes around so
269:25 - we don't need to include the counter
269:26 - increment inside the for Loop and this
269:28 - one line is pretty simple we say result
269:31 - the index of counter which will start at
269:33 - zero which is the start of the array
269:35 - since it's zero base and we say that's
269:37 - equal to the number and the number is
269:38 - going to be a fixed number since this is
269:40 - the multiple and we say number times by
269:43 - I and in this case it goes from one all
269:45 - the way to the lth so we get essentially
269:47 - the times table and at the end we just
269:49 - use a simple for each Loop that will go
269:51 - through all the items inside the result
269:53 - array and just print them out to the
269:54 - screen with a comma after each other
269:56 - using console. WR just so they're all on
269:58 - one line this is the start of the
270:01 - function section functions can also be
270:03 - called method they are used
270:05 - interchangeable
270:06 - in the introduction we discussed dry
270:08 - which means don't repeat yourself and
270:10 - the whole point of dry is so you don't
270:12 - have multiple sections of code that do
270:14 - basically the same thing you want to
270:16 - wrap it around in a function functions
270:18 - are used to improve the readability of
270:20 - your code and the reusability of the
270:22 - code as well having multiple section
270:25 - code that are basically exactly the same
270:27 - can be more prone to errors if you wrap
270:29 - them round and place in One Singular
270:31 - function you can make sure that the
270:33 - error prone and then wherever you use it
270:35 - it will be error prone as well if you
270:37 - have to copy and paste and tweak some
270:39 - code then you're actually exaggerating
270:41 - the amount of errors that could occur
270:43 - and plus it makes your code look a lot
270:45 - cleaner and the structure a lot better
270:47 - since you can name the functions so
270:48 - let's take a little example we have a
270:51 - static void main straight into here this
270:54 - is a function or a method and these are
270:56 - the parameters for the function The NET
270:59 - Framework expects every C program to
271:02 - have a main function with a capital m
271:04 - and it needs to be a static and avoid
271:07 - the parameters don't exactly matter we
271:08 - can also remove them and it won't be a
271:10 - problem the only thing that matters is
271:12 - this needs to be called main if we drop
271:15 - the lowercase on it and try and run the
271:17 - code then we're going to get a build
271:19 - error program does not contain a static
271:22 - main method suitable for an entry point
271:25 - so if you change this back to M and run
271:26 - it again and then it works fine so
271:29 - that's one thing to note about The NET
271:31 - Framework is you need to include the
271:33 - main function otherwise the program
271:35 - won't run and it won't even compile so
271:37 - let's take a look at how we can use this
271:40 - we can have something like a console
271:41 - right line and we can say welcome to my
271:44 - program this is a line that we're
271:46 - probably only going to use once but
271:48 - let's say this is welcome in someone's
271:49 - name welcome AB let's say you had this
271:52 - in your software in many different
271:53 - places you don't want to be recalling
271:55 - this or retyping out this message in
271:58 - case you type it wrong the fifth time
271:59 - and you get a error of course this won't
272:01 - be a syntax or a runtime error it'll
272:04 - just simply be a logic eror because it's
272:06 - a typo so in order to make sure this
272:08 - typo never occurs we can actually make
272:10 - another function so outside of these
272:12 - curly braces and just still within the
272:14 - class we want to create a new function
272:16 - so we want to follow this exact same
272:18 - approach we can say static then viid and
272:22 - we can call it welcome message and we
272:24 - don't need to give it any parameters cuz
272:25 - we're not really going to give it any
272:27 - values just for now now that we've made
272:29 - that we have no syntax errors and we can
272:31 - run it like this except of course
272:33 - there's no body so let's place our
272:34 - console right line within here now if
272:36 - you run the codee nothing is going to
272:38 - happen and the reason for that is the
272:40 - code will still execute in the main we
272:43 - haven't called this function inside the
272:45 - main we've defined it and called it
272:47 - welcome message and we've gave it the
272:49 - contents but we haven't actually made
272:50 - use of it and you can see that when it's
272:52 - highlighted in a darker color that means
272:55 - it's not being used as it says here
272:57 - private member welcome message is on use
273:00 - so now we can simply type in here
273:02 - welcome message followed by an Open
273:04 - Bracket and then a close bracket to
273:06 - denote the parameters that we're going
273:07 - to give it and of course in this case
273:09 - there is no parameters and then we close
273:11 - the brackets and add a semicolon now if
273:13 - you run the code you can see it says
273:15 - welcome abber so just to go over some of
273:17 - these words that we're using static
273:19 - means that we can access it anywhere and
273:22 - everywhere what I mean by that is we
273:24 - don't have the keyword new just before
273:27 - this we don't need to make a new
273:28 - instance of the program class in order
273:31 - to access this so what that means is
273:33 - when we make future programs we're going
273:35 - to have some functions inside our class
273:37 - inside the class you can actually denote
273:40 - if a function is going to be static or
273:42 - it's not going to be static you don't
273:44 - have to specify is it static but this
273:46 - won't let you call it from here because
273:48 - it's unaware where this function is
273:49 - coming from an object reference is
273:51 - required for the non-static field method
273:53 - or property because this is static you
273:56 - need to reference something else from a
273:58 - static nature all static means is you
274:00 - don't have to create a new instance of
274:02 - this thing in order to use it we'll see
274:04 - different examples in the future where
274:06 - you have to create an instance in order
274:08 - to use something so let me just show you
274:10 - quickly if we have a test and I say
274:12 - static void
274:15 - something and we can just print out
274:17 - nothing to the screen and let's try and
274:19 - use this so because this class is
274:21 - outside of the program we have to use
274:24 - the notation test Dot and then it should
274:28 - be available within here and the reason
274:30 - why it's not is because you need to
274:31 - insert this public word just before it
274:33 - and public means everything has access
274:35 - access to it and static means you don't
274:37 - need to create an instance now if I type
274:39 - in the dot again you can see we can now
274:40 - see
274:42 - something and the reason why we can see
274:44 - something is because this is a static
274:46 - now if I remove the static word then you
274:48 - see that we'll get a compile error
274:50 - because it doesn't know where this is
274:52 - now if you don't use static you need to
274:54 - do this you need to say test test equals
274:57 - new test so you make it instance of the
275:00 - class and then inside test then we get
275:02 - the something so that's the difference
275:04 - between static and not static
275:08 - essentially it's accessible from
275:09 - everywhere but if you don't want to be
275:11 - accessible from everywhere then you can
275:13 - just simply remove the static word and
275:15 - the user will have to create a new
275:17 - instance before they can use it so this
275:19 - is what it's like without
275:21 - static and this is what it's like with
275:23 - sty don't worry if you don't understand
275:26 - this too much this was just a quick
275:27 - overview but I have a dedicated video
275:29 - later on in the course so don't worry
275:31 - too much about it so now that we've made
275:33 - a function and we've called it
275:34 - successfully in the main and it's
275:36 - printed out to the
275:39 - console so when we're declaring
275:41 - functions we want to specify what return
275:43 - type we're going to have we have a
275:45 - static void Main in here if you hover
275:47 - over main it says void which means at
275:49 - the end of this function it doesn't
275:51 - return anything hence it's void if you
275:53 - have a look at something like an inter.
275:55 - trass and we open the brackets you can
275:57 - see that it takes in a string and it
275:59 - takes in an integer out parameter it
276:02 - also returns us back with the booing so
276:04 - we can have something like 1 2 3 out in
276:07 - result and then it doesn't actually
276:08 - complain about anything but what we can
276:10 - do is also just store this into to a bu
276:13 - success and then print it out to the
276:17 - screen there we go so it says it was
276:19 - successfully true if we remove this or
276:22 - whether we keep it in or not trip pass
276:24 - function doesn't actually complain but
276:26 - the main point here is it defines back a
276:28 - bu that means at the end of this
276:30 - function it will always return you back
276:32 - with a bull and it's up to you if you
276:33 - want to make use of it and you can
276:35 - alternatively you can place this
276:37 - straight inside the console right line
276:39 - and get the value printed straight to
276:41 - the screen or you could wrap this around
276:43 - inside an if statement like we've done
276:44 - in the past Etc and make use of it that
276:47 - way and have the result being printed
276:48 - out inside here the point is you have
276:50 - functions that return something and
276:52 - functions that don't if you remember
276:54 - that we had the array. copy for example
276:57 - you'll see that they have void here
276:59 - because they just apply a function to
277:01 - something but they don't actually give
277:02 - you something back this is the
277:04 - difference of having something like this
277:06 - a string test that says hello and then
277:09 - you can do test. replace and then you
277:12 - can return you back with the string and
277:14 - it says here it returns a new string
277:16 - whereas when we had a string builder for
277:19 - example and we did string builder.
277:22 - replace you can see that alloy does say
277:24 - it replaces a new string Builder you can
277:27 - type anything inside here and it will
277:29 - still affect the current string Builder
277:31 - it won't have to do SB equals s SP
277:33 - replace as you would need to do here
277:35 - because this returns you back with a new
277:37 - string and if you wanted to replace test
277:39 - you would literally have to say test
277:41 - equals test. replace with something like
277:44 - a string Builder all the array functions
277:47 - you don't actually have to do any of
277:49 - that so you can say array. empty and
277:51 - it'll just return the empty array and
277:53 - the ones that we used before are things
277:54 - like equals and that will give you back
277:56 - a Bool because that's determining
277:58 - whether it's equal or not but if you're
278:00 - doing functions like sort for example
278:03 - and doing things like reverse it just
278:05 - simply applies the data but it doesn't
278:07 - return you back with anything so you can
278:09 - literally just call it inside here put
278:11 - your array in the brackets and it'll use
278:13 - it happily now depending on your user
278:15 - case you need to define whether or not
278:17 - you need to use a return type or not for
278:21 - now let's just cover void which means it
278:23 - won't do anything so let's just Define a
278:25 - function static void create and print an
278:28 - array open the brackets close the
278:30 - brackets and we can have it int numbers
278:33 - make it equal to new int with a l three
278:35 - and let's just have 0 1 and two inside
278:38 - here as the initializer let's just do a
278:41 - for each VAR item inside numbers and
278:44 - then just do a console right string
278:46 - interpolation and just have item Follow
278:49 - by space and now that it's dark gray
278:51 - because we haven't called the function
278:53 - so let's make use of it at the top of
278:54 - our code and let's run it now you can
278:57 - see we get 012 printed to the screen and
278:59 - if we make this into a five and simply
279:02 - just add more values in here and then we
279:04 - run the code you'll see that now it all
279:06 - update but because this doesn't return
279:07 - us back on anything and we don't
279:09 - actually use the integer array outside
279:11 - of these curly braces it's not actually
279:13 - available up here numbers won't be
279:15 - accessible inside here because it's
279:17 - simply not within the scope numbers is
279:21 - only available within this curly brace
279:23 - and this curly brace which means when
279:25 - this function finishes numbers has now
279:27 - been deleted from memory so you can't
279:29 - access it after this line void doesn't
279:31 - do anything it simply just does the
279:34 - contents of the function and as soon as
279:36 - it reaches the bottom that's all that
279:37 - happens you can have another function
279:39 - defined that can return a value like I
279:42 - said with in. trass for example at the
279:44 - end of the function you'll see a word
279:46 - that says something like this it will
279:48 - have return and then return back
279:50 - something followed by a semicolon and
279:52 - that will dictate that as soon as that
279:54 - function is done it's going to give you
279:56 - something back now we're going to cover
279:58 - that in the next video but for now we're
280:00 - only going to cover void functions so we
280:02 - can have something more obvious like a
280:04 - static void welcome
280:05 - message and simply just do a console
280:08 - right line welcome to my program and we
280:11 - don't need to return anything here
280:12 - because all this function will do is
280:14 - simply print out a welcome to the screen
280:17 - and we can use that just before the
280:18 - print array so we can say welcome
280:20 - message Open Bracket close bracket and
280:23 - then a semicolon and hit F5 to run and
280:26 - there we go as you can see our main is
280:28 - really tidy now it gives us function
280:30 - names that tells us exactly what's going
280:32 - on we're creating and printing an array
280:34 - and then then welcoming the user to the
280:36 - console and then having a console read
280:37 - line at the end there isn't an awful lot
280:40 - of void functions all you need to know
280:42 - is that when you create a function you
280:43 - need to give it a return type it returns
280:45 - back a certain data type or it simply
280:47 - just doesn't and depending on what you
280:49 - want to do and what you want to achieve
280:51 - with that function really depends on if
280:53 - you want to return a data type or not in
280:55 - the case of these since they're just
280:57 - doing something and then moving on you
280:59 - don't actually need to return anything
281:00 - by it with in. tripath you want to make
281:02 - the function is executed successfully so
281:05 - when you use in. tripos you can see that
281:07 - returns back a bull and the bull
281:09 - determines whether the conversion has
281:11 - been successful and based on that return
281:13 - value you can determine the next steps
281:15 - of your program if all your function
281:16 - needs to do is provide some sort of
281:18 - functionality and then quit then that's
281:21 - fine and avoid is fine but if you need
281:23 - to provide some functionality and then
281:25 - also return a value then you'll need to
281:27 - specify the data type in here which
281:29 - we'll cover in the next
281:32 - video so far we've covered a void
281:35 - functions but we haven't covered return
281:37 - types void functions are where the
281:38 - function just does something but doesn't
281:40 - actually return anything hence the name
281:42 - void let's start with an example if you
281:45 - have a static void print
281:48 - introduction might want to just return
281:50 - back your name after you've printed this
281:52 - line it's going to print it to the
281:53 - console and that's all it's going to
281:55 - do there we go let's say there's a
281:58 - situation where you actually want to use
281:59 - this inside your code you can actually
282:01 - set the console's title by typing in
282:03 - console. title and type in your name
282:05 - inside the quotation marks or you can
282:06 - type in anything inside here if you run
282:08 - that you'll see Abra is in the title of
282:10 - the console right now and that looks
282:11 - pretty cool what you got to realize is
282:14 - now we have two references to the same
282:15 - value now at this point we can actually
282:18 - do something better we can type in
282:20 - static string name equals abber and then
282:23 - instead of using abber in here we can
282:25 - say name and instead of using abber in
282:27 - here we can also say name and they're
282:29 - both using this variable and if you run
282:30 - the code now you see that the same
282:32 - output will happen you have ABA twice
282:34 - both both in the title and both in the
282:35 - console output now the problem with this
282:37 - approach is you're actually making use
282:38 - of a global variable which we do not
282:40 - like in code in situation like this you
282:42 - shouldn't need to make a global variable
282:44 - because there are ways around it so
282:46 - instead of having this which has a print
282:48 - introduction and we've got the name used
282:49 - in there but the name is coming from
282:51 - here maybe we can use this somewhere
282:53 - else so let's say we make another
282:54 - function called Static and instead of
282:57 - void we want to actually return back a
282:58 - string so we can say string and then we
283:01 - can say my
283:03 - name or something like return name or
283:06 - anything you want just make sure you
283:08 - give it a meaningful name so it dictates
283:10 - what the function is trying to do so
283:11 - this is to return the name and the
283:13 - reason why there's a red underline is it
283:15 - says not all called P return a value
283:18 - since we need to use our keyword return
283:21 - now that we add some empty codes and the
283:22 - return it's going to execute fine and
283:24 - the compil error is gone so obviously we
283:26 - don't want to just return nothing we
283:27 - actually want to take this arber and
283:29 - return in here so let's get rid of our
283:31 - Global variable and let's see what we're
283:33 - going to break so we're going to break
283:35 - these two references to the name
283:36 - variable and simply inside here we can
283:39 - actually just call return name and then
283:42 - here as well we can call return name and
283:44 - what this will do is inside here it will
283:47 - execute this function and then return
283:49 - the value in here if this is too many
283:52 - steps for you you can have a string name
283:54 - equals return name and then simply use
283:56 - the name inside the brackets these two
283:59 - lines are doing exactly the same thing
284:01 - except this is using a variable CU we're
284:03 - starring it first and then we're using
284:05 - it whereas if you place it straight
284:06 - inside the brackets that's just going to
284:08 - store it and use it immediately and
284:10 - there's no additional variable but don't
284:11 - worry too much if you're going to do
284:13 - this notation because an extra variable
284:15 - in this case doesn't really matter
284:17 - because as soon as this function is
284:18 - executed the variable used to run this
284:20 - function gets deleted since it's inside
284:23 - the scope of these two curly braces so
284:25 - now if we run the code you'll see that
284:27 - again we have abber and abber but now
284:29 - what we've done is actually controled
284:30 - everything throughout here so if you
284:32 - want name where to change or maybe this
284:34 - changes in different circumstance based
284:36 - on the user that's logged in then you
284:38 - can simply have the same thing now
284:40 - printed in two different locations in
284:42 - the title and in the console output and
284:45 - it's actually coming from one function
284:47 - so we can have a return name and we can
284:49 - make a static in now can say return age
284:52 - and then we can have simply return 23
284:55 - and that's our name and our age being
284:57 - returned I change us back to abber and
284:59 - then instead of the print introduction
285:01 - maybe we actually want to print a little
285:02 - bit more than the name then maybe in the
285:05 - title what we can do is have string
285:07 - interpolation wrap the return name and
285:10 - maybe put a hyphen in there and then we
285:11 - can say return age so if run the code
285:14 - now you can see we have ABA hyphen 23 so
285:18 - maybe that's the title of our console
285:20 - but then in the introduction we can use
285:22 - a bit more than that so we can have int
285:24 - age equals return age and then in the
285:26 - console output we can have something
285:28 - like this hello my name is name and my
285:32 - age is age and then after we've compiled
285:35 - that together we can place the output
285:37 - inside here there we go so we're using
285:40 - the name and the age inside the console
285:42 - title and then we have this function
285:44 - that runs to get us back the name and
285:46 - the age and then we're using it using
285:48 - string interpolation of course these
285:50 - four lines can be all squished into one
285:53 - you can simply take this dollar sign let
285:55 - me duplicate this
285:57 - line you can take this and paste it
286:00 - straight into here and while you have
286:01 - name we can have our return name and
286:03 - while you have age you can have return
286:05 - age and that will actually rule out all
286:08 - of these lines and you can wrap it all
286:10 - into one there you
286:13 - go and if age were to change like I said
286:15 - before you can simply type this number
286:17 - in change it and you can see in both
286:19 - cases in the title and in the console
286:21 - output it has officially changed
286:23 - functions can be very helpful to reduce
286:25 - repetition in code let's show you an
286:27 - example if you had three sections where
286:30 - you said enter a
286:32 - number and you had int n one equals
286:35 - convert to in32 and then we add a
286:38 - console.
286:40 - readline and then you had this section
286:42 - and you wanted to do num
286:44 - two and you had this section again and
286:46 - you actually wanted to do num three now
286:48 - at this point even though these three
286:50 - are actually identical you want to be
286:52 - using array in this case so you could
286:54 - have int numbers equals new int Square
286:58 - braet 3 and then here we could say
287:00 - numers
287:01 - zero numbers one numbers two and then we
287:05 - don't need the ins because it's already
287:07 - been defined and then we have them like
287:09 - this but because again all of these
287:11 - three sections are exactly identical we
287:13 - can actually run a for Loop that goes
287:15 - from numbers do length and then we can
287:17 - place one of these straight inside here
287:20 - and then change this to I and now we've
287:22 - achieved exactly the same thing but
287:23 - we're not actually done yet so if you
287:25 - run the code and we do 1 2 3 now we
287:28 - stored all three numbers so we have
287:29 - enter a number and then we have the
287:31 - console read line and maybe we can
287:33 - actually make these two lines a little
287:34 - bit shorter so let's make a function
287:37 - static and because we essentially want
287:39 - to return an integer we can say static
287:41 - int read number from
287:44 - console and then if we take these two
287:47 - lines place them inside here and because
287:49 - we need to return back an integer this
287:51 - is the value that we're going to be
287:52 - returning so instead of assigning this
287:54 - position to something we'll actually
287:56 - just immediately return at this point so
287:58 - instead of doing this line now and
288:01 - instead of doing all of this we can
288:02 - simply make this into one line of code
288:05 - read number from console so every time
288:07 - this will execute it will jump into here
288:09 - print out the value enter a number the
288:12 - user will type it in it will read it in
288:14 - convert it to an integer 32 and this
288:16 - will return back the integer that the
288:18 - user typed in and then that will return
288:19 - it back to the console and essentially
288:21 - replace this so if the user is typed in
288:23 - five then it essentially replace this
288:25 - with five store it loop around and if
288:27 - replaced in 10 the next time and then
288:29 - you replace this with 10 essentially and
288:31 - then that gets started inside and so on
288:32 - and so forth until until all the
288:34 - positions have been complete Let's test
288:36 - that 1 2 3 and it still works okay of
288:40 - course I'm not actually printing the
288:41 - values out to the screen so if you
288:42 - wanted to see that quickly for each can
288:45 - have our item inside our numbers and
288:48 - then do a console right with some string
288:50 - interpolation item followed by a space
288:53 - let's run that one two and three and
288:55 - there we go we get one two and three of
288:57 - course you can make these functions and
288:58 - they can return any bits of data that
289:00 - you want you can even have something
289:02 - like an INT array and we can say create
289:05 - random array and then we can create an
289:06 - array call numbers make that equal to
289:09 - new in square braet 3 and we can
289:12 - actually give it the values of 0 1 and
289:14 - two and then just at the end here we can
289:16 - actually just return numbers and then
289:18 - just in here we can have an INT array
289:20 - and we can call that new numbers since
289:22 - we have numbers above just above here
289:24 - and then we can make that equal to
289:25 - create random array and because this
289:28 - returns us back with an integer array
289:30 - there's no compile arrays inside here
289:32 - and we can have a for each follows the
289:34 - exact same approach as the one above new
289:36 - numbers console right line into a
289:39 - console right and then have item
289:41 - followed by a space now if we print
289:44 - these both out you can see that the zero
289:46 - one and two actually comes from the new
289:48 - one it's just we have two console right
289:50 - right next to each other so there's no
289:51 - new line separating them so if we just
289:53 - add a console right line here one two
289:56 - and three and there you go 1 2 and three
289:58 - comes from the three inputs we just
290:00 - typed in and 0 1 and two actually come
290:03 - from the function we've just created of
290:05 - course if you don't like this notation
290:07 - then what you can do is you make it a
290:08 - lot easier you don't even need to make a
290:11 - new variable you can actually just
290:12 - return the integer just like this so if
290:15 - we place
290:16 - this straight inside here actually just
290:20 - make it on one line just so it looks a
290:21 - bit neater then there you go we have our
290:23 - entire function reduced in one line the
290:26 - goal of functions is to make them do as
290:28 - little as possible if your function has
290:30 - two different things it's doing or more
290:32 - then you should break that out into into
290:34 - another function for example if you had
290:35 - a function that did two distinct
290:37 - operations one was a conversion and one
290:39 - was a calculation then you want to split
290:41 - out into two the first function should
290:43 - be the conversion and the second
290:44 - function should be the calculation and
290:46 - the reason why they're separate is
290:48 - because if you want to reuse them as a
290:50 - pair then you won't be able to reuse
290:52 - each of the pairs if you wanted to have
290:54 - a calculation on its own then you can't
290:56 - do that if both functions do the same
290:58 - thing for example you could have a
291:01 - static and it just could be something
291:03 - let's just call it VI and it could just
291:05 - be test for example and if you had the
291:07 - conversion here and then if you had the
291:09 - calculation in here then you need to
291:11 - split this up into two different
291:12 - functions you want have static void
291:16 - conversion and static void calulation if
291:19 - you wanted to use conversion or
291:21 - calculation separately you can't because
291:23 - now it's in this pair together so if you
291:24 - wanted to use them separately you simply
291:26 - can't it's best to keep functions on the
291:28 - RW anywhere just so they have a single
291:30 - purpose so you can give them a name cuz
291:32 - as you can see here we can't can't give
291:34 - this an appropriate name because it's
291:35 - doing more than one task this is doing
291:37 - the conversion this is doing the
291:38 - calculation and this is doing multiple
291:40 - things this could be doing something if
291:43 - you have to think too hard about the
291:44 - function title then you might be doing
291:46 - too much within each of functions these
291:48 - are very easy to be able to decide what
291:50 - they do cuz this one converts and this
291:52 - one's going to calculate reading number
291:54 - from console if this was reading the
291:56 - number from the console and doing
291:58 - something else then it's going to be a
292:00 - bit of a problem because now you've got
292:01 - a bigger name you don't want to be doing
292:03 - reading number from console and and
292:05 - something else cuz then your function
292:07 - name gets also too big and you got
292:09 - multiple dependencies so best thing to
292:11 - do is to call them accordingly and keep
292:13 - them as short as possible so let's say
292:15 - we wanted to make a function that added
292:16 - two values we can have a static int call
292:18 - it add and then we can return 5 + 5 now
292:22 - this function is a little bit redundant
292:24 - although it will actually work so if we
292:26 - go back to our main and we do a console
292:28 - right line and actually print the value
292:30 - of
292:31 - ADD and we go through our function then
292:33 - we see we get the value of 10 which is
292:35 - indeed 5 +
292:37 - 5 but since this 5 + 5 won't change it's
292:41 - always going to be 5 + 5 this is where
292:43 - parameters will come in which we'll
292:44 - cover in the next videos parameters are
292:46 - a way of being able to give the function
292:48 - value so these two can be actually
292:50 - changed there's no point in having an
292:52 - add function if the only ability you can
292:54 - do is add 5 + 5 because you may as well
292:56 - just return 10 at this point so I
292:58 - covered a lot in this video and there's
293:00 - lots of different functions that do
293:01 - different things of course there is
293:03 - quite a lot of lines we're up to 87 this
293:05 - is probably the biggest project that
293:06 - we've wrote so far and even though this
293:08 - is not really a project it's just a
293:10 - bunch of functions that do little things
293:12 - that are made for demonstrations so
293:14 - let's have a recap so first here we're
293:16 - setting the title as a result of return
293:18 - name and return age we can actually take
293:21 - this and develop this further if you
293:23 - want to we could actually say return
293:25 - name age pair and if you wanted to
293:28 - collapse that inside one function then
293:30 - that could be really easy you could say
293:32 - static string
293:34 - return name age pair and then you can
293:37 - have return and literally the exact same
293:39 - line above you can have return name
293:41 - followed by a hyphen and then you can
293:43 - have a return age and then end the line
293:46 - like that so that just concatenates the
293:48 - two values that are returned from these
293:49 - two functions but the point is you keep
293:51 - them all separate if you were to type in
293:53 - very statically inside here AB 25 then
293:56 - obviously like I've talked about above
293:58 - then you're going to have duplication of
294:00 - data and of course we're going to use
294:01 - this name inside something like here and
294:04 - as you can see this name age pair is
294:06 - actually not applicable when it comes
294:07 - back to this format so it's always best
294:09 - to keep these two separately so if you
294:12 - bring it back and we can actually keep
294:13 - it like this now instead of having this
294:15 - code we can actually say return name age
294:18 - PA now will give us the same value at
294:20 - the top of the code it will have ABA
294:22 - hyphen
294:23 - 25 so that's that bit in our print
294:26 - introduction If We Hold control and we
294:28 - actually press on this function it will
294:30 - actually jump us right down and then if
294:32 - we press the back arrow top left we can
294:34 - go back to it there we go and then click
294:36 - forward so in this function we can break
294:38 - down all of the return values into
294:40 - string variables we have a string name
294:42 - equals return name an inage equals
294:44 - return age then we have a string input
294:46 - that concatenates them both together
294:48 - hello my name is name and my age is age
294:51 - and then we print out to the screen or
294:52 - if you wanted to we could wrap all four
294:54 - of these lines straight up into one we
294:57 - don't need to assign these into
294:58 - variables although it does help the
295:00 - readability if you keep them separate
295:02 - but I prefer to keep it like this since
295:04 - I'm used to this notation we can place
295:06 - return name straight into there which
295:07 - will get rid of our name variable and
295:09 - the same thing with age which will get
295:11 - rid of these two variables and of course
295:13 - we're actually storing the string value
295:15 - before we printing it so we could just
295:17 - take all of this and place it straight
295:19 - instead of here scrolling back to the
295:23 - top this little section was
295:25 - demonstrating how we can use integer
295:27 - arrays to read in all the values from
295:29 - the console but wrap it around in a
295:31 - function so before in here you would
295:33 - would have something like a console
295:34 - right line you'd print out the value to
295:36 - the screen that would say something like
295:37 - a ter number and then you have on the
295:39 - next line a convert to in32 and then
295:43 - after you converted in 32 you'll
295:45 - actually start it straight to numbers
295:46 - but because this is going to be the same
295:48 - thing for inster all the numbers you can
295:50 - actually wrap this around in a function
295:52 - so if we hold control again and go to
295:54 - this you'll see that them two lines are
295:55 - very simply placed in here console right
295:58 - Line enter a new number and then convert
296:00 - in 32 based on the console read line and
296:03 - then we're simply just returning that
296:04 - back ready to be stored in the index of
296:07 - the numbers array and then straight
296:08 - after that we're just printing out all
296:10 - the values to make sure it's worked and
296:12 - that all succeeded fine here I was just
296:14 - demonstrating that you can have
296:15 - different return values and it can
296:16 - literally be anything so as you can see
296:18 - here if you hover over create random
296:20 - array it's inside the program class it's
296:22 - called create random array and it
296:24 - returns back an integer array so that's
296:26 - what we're sign into and if we hold
296:28 - control and click on this again you can
296:30 - see that all this simply does is returns
296:32 - us back back a three length array with 0
296:35 - 1 and two as the array positions and
296:38 - then if we scroll back up when we
296:40 - execute this for each Loop then we're
296:41 - simply going to get 0 1 and two just
296:45 - like that since it's a console right and
296:46 - it'll be on the same line with a space
296:49 - after each
296:51 - other this demonstration was slightly
296:54 - theoretical I was saying in one given
296:56 - situation a function should only do one
296:58 - task if your function converts and does
297:00 - a calculation at the same time then
297:02 - these are actually two different things
297:04 - you should split them so you use the
297:06 - conversion in this step and you use the
297:08 - calculation in this step if you wanted
297:10 - to convert something or calculate
297:11 - something in the future then you can
297:13 - only do it now because we've separated
297:16 - them whereas before if you have them
297:17 - both inside here then you simply can't
297:19 - do one operation because you wrapped it
297:22 - around in one section the same is true
297:24 - when I was discussing this earlier on if
297:27 - we kept this name pair is the only way
297:28 - to access the age in the name then it's
297:30 - going to mess up when we use it in here
297:32 - and then we're going to have a
297:33 - duplication of data but because we
297:35 - separated the name and we separated the
297:37 - age we can use it in this function and
297:39 - we can use it in this function and it
297:41 - doesn't interrupt anything this simply
297:43 - Returns the name this simply Returns the
297:45 - age and these two functions make use of
297:47 - them if we had something else underneath
297:50 - there were another function that
297:51 - depended on the name of the ede then
297:53 - again we can simply use them if it was
297:55 - restricted to this function then it's
297:57 - going to be a problem using it in this
297:59 - function or any future ones and finally
298:03 - just to finish off add function and all
298:05 - it simply does is return 5 + 5 and I was
298:08 - saying as of right now even though it
298:10 - returns back a value it's kind of
298:11 - pointless CU you may as well just return
298:13 - back 10 since it's doing the same thing
298:15 - the reason why included this function is
298:17 - that we can set it up and start planting
298:19 - the seeds to understand why functions
298:21 - exist and how to make use of parameters
298:23 - what a parameter is is it lets you put
298:25 - things Within These brackets so you can
298:27 - give this function some data so if you
298:29 - have an in. trass for example these
298:32 - things that we place ins inside the
298:33 - brackets are actually the parameters so
298:35 - we have a string s and out in something
298:38 - and that's how the parameters work on
298:39 - our Tri pass function and just to show
298:42 - you this is how it's actually wrote It's
298:44 - a Bo and then it's called trip pass and
298:47 - it takes in a string s and out in
298:51 - result then we can make this static and
298:54 - I know it's give us an error because we
298:56 - don't have the control path if we just
298:58 - use result and assign it to zero and
298:59 - then return back true you can see that
299:02 - the compil error is now gone on and as
299:03 - you can see here it says bull trip pass
299:05 - string s out in result and if we
299:08 - actually try and use the trip pass in
299:09 - here and press the brackets you can see
299:12 - that these parameters are exactly
299:13 - identical to parameters that were inside
299:16 - of the tripar coming from the integer
299:18 - Library so in the future we're going to
299:20 - study how we can use parameters to pass
299:22 - data inside our function but just for
299:25 - now know that this function is
299:26 - essentially pointless because it's only
299:28 - going to return back 10 and this
299:30 - function will gain the functionality it
299:32 - needs on when we start adding parameters
299:34 - this should essentially be add five + 5
299:37 - except this is kind of a pointless
299:39 - function because we already know the
299:40 - value is going to be 10 but again this
299:43 - is just helping you understand why
299:44 - parameters are very essential to
299:48 - functions we've covered how to create a
299:50 - viid function and a function that
299:52 - returns a data type but now we want to
299:54 - create a function that gives it some
299:55 - sort of data you may not realize it but
299:57 - all these functions that you normally
299:58 - use like console right line you're
300:00 - actually inserting data consistently
300:03 - into all of these functions if you hover
300:04 - over console right line you see his void
300:07 - console right line and right now there's
300:09 - an open bracket and there's a close
300:10 - bracket if we delete this bracket and
300:12 - reopen it you see there's 19 different
300:13 - ways you can call this function and as
300:15 - soon as you start to type a string you
300:17 - can see we have a string format and an
300:19 - object if you need to and if you type in
300:20 - another string you can see it says
300:22 - string value this string value is
300:24 - actually a parameter If We Hold control
300:26 - and press on right line you can see all
300:28 - of the different functions right here
300:30 - this is the most basic version that just
300:32 - inserts a right line character to the
300:33 - console and then these are all the
300:35 - different parameters that you can give
300:36 - the value of course you can't double
300:39 - click and view the source code because
300:40 - this is hidden inside Microsoft's
300:42 - libraries the values that are placed
300:45 - inside these parentheses are actually
300:46 - called the parameters this is known as
300:49 - functional overloading which we'll cover
300:51 - later on in the course basically that
300:53 - means you can have the same name
300:54 - function but give it different
300:56 - parameters and you'll see why this is
300:57 - helpful later on down the line so let's
300:59 - close this tab in the top right hand
301:00 - corner and let's bring back out code so
301:03 - now that we've passed hello into this
301:04 - function that's was actually given this
301:06 - a string value parameter and that hello
301:08 - is going to get passed straight into the
301:10 - console right line so then when we run
301:12 - the code it's going to print it to the
301:13 - console so let's create our own function
301:15 - with our own parameters so if we take
301:17 - the function I had last time it was
301:19 - static int add Open Bracket close
301:21 - bracket and it simply returned 5 + 5
301:24 - which we all know is going to be 10 so
301:26 - if we place add inside these brackets
301:28 - and we run the code we should get 10
301:30 - return back there we go so of course the
301:32 - this is a little bit pointless since
301:34 - it's always going to be adding 5 + 5
301:36 - there is no way we can change this
301:38 - without the use of parameters so in here
301:40 - we can actually just do what we do when
301:42 - we normally declare a variable we say
301:44 - the data type int and then the variable
301:46 - name and then if you want to add
301:48 - multiple parameters you can simply add a
301:49 - comma so now we can say int a and int B
301:53 - and you can see now we've got a syntax
301:54 - error because it expects us to have both
301:56 - of these values inside if you hover over
301:58 - it there is no argument given that
302:00 - corresponds to the required formal
302:01 - parameter a and then if we insert a by
302:04 - having five for example and if we hover
302:06 - over it it complains about not having B
302:09 - so we can do comma and then do five
302:11 - again so just this on its own is not
302:13 - actually going to do anything we're
302:14 - actually giving the add function the
302:16 - values of five and five and place them
302:18 - inside a and inside B variables these
302:21 - are now known as local variables and
302:23 - they only exist in memory between these
302:25 - two curly braces as soon as this
302:27 - function is done these are deleted from
302:29 - memory and you can no longer access in a
302:31 - and int B you can't just do something
302:33 - like a inside here and think that this
302:35 - can be used up here these are in two
302:37 - completely different Scopes this is one
302:39 - function and this is another function
302:41 - and they're completely separate from
302:43 - each other when you type in five and
302:44 - five it goes in order so int a is the
302:47 - first one so five gets placed into here
302:49 - and this five gets placed in a b so now
302:52 - that we need to make use of them we can
302:53 - simply change this to a and change this
302:56 - one to B now if we run the Corde we
302:58 - should still get 10 but now our function
303:00 - Works a bit better we can give it a set
303:02 - of d
303:03 - so if we actually just put zeros instead
303:05 - of here then we should get 100 returned
303:07 - perfect so now that we've figured out
303:09 - how to do this let's have a look at
303:10 - different ways that we can make use of
303:12 - this function so let's say we had a
303:14 - situation where we did console right
303:16 - enter a
303:18 - number and we add int nor equals convert
303:22 - to
303:23 - in32 and then converting the console do
303:26 - read
303:27 - line and let's wrap this inside a
303:30 - function so before what I was doing is
303:32 - simply just returning back in int it was
303:34 - static int read
303:37 - int and then we took these two lines and
303:40 - place it straight inside here and remove
303:42 - the fact that we have an integer and
303:43 - simply just change this to a return and
303:45 - what this now will say is let's output
303:47 - enter a number to the console let the
303:49 - user type it in inside the console read
303:52 - line and then read it in convert it to
303:54 - an integer and then give it back to
303:55 - whatever calls it so now we can get rid
303:57 - of this and get rid of this convert and
303:59 - simply just type in read in inside here
304:02 - and after the line let's just print it
304:04 - out to make sure it's worked okay enter
304:06 - a number 10 press enter and we have 10
304:09 - again and that's fine except if we want
304:11 - to use this in another case for example
304:13 - if you have num one maybe we don't
304:15 - actually want to enter a number maybe
304:17 - this time it's going to be enter an
304:18 - angle or something of this sort so what
304:21 - we can do if we undo that we can
304:23 - actually introduce a string message and
304:25 - what this will do now is actually
304:27 - specify the message that we put in here
304:29 - maybe there's a situation where we
304:31 - always want to enter something so maybe
304:33 - we can just replace this and put a
304:34 - string interpolation and wrap this
304:36 - number around in the curly brace and
304:38 - replace it to message so then in here we
304:40 - can say enter a and then we can pass the
304:44 - string variable which will get placed in
304:46 - here so if this is a number then we can
304:48 - type a number and maybe this is
304:49 - something like an
304:51 - angle and then here we can type an angle
304:54 - so we have 10 enter a number and then
304:56 - there you go it says enter an angle then
304:58 - we can have 100 and that's working as
305:00 - well alternatively if you want to
305:02 - specify the entire message then you can
305:04 - remove these and keep it like this and
305:07 - then in both of these situations we can
305:08 - say enter a number and copy that down
305:11 - like this and make sure you put the
305:13 - colum at the end followed by the space
305:15 - there we go enter a number 10 enter an
305:18 - angle 20 maybe the situation where this
305:21 - text actually changed and you just want
305:23 - it to be angle and if you run that again
305:25 - then you'll see that these are
305:26 - completely different now one says enter
305:28 - a number and one says angle but this
305:30 - gives us a lot of flexibility in what we
305:32 - pass in if we keep it as enter a and
305:35 - then let the user decide on what this
305:36 - section is then you rule out any
305:38 - opportunity to be able to do that option
305:40 - if you wanted to to prevent the colon in
305:42 - the space always being at the end you
305:44 - can actually just add that in manually
305:46 - if we bring back the string
305:47 - interpolation we can say colon followed
305:49 - by space so you don't have to remember
305:51 - to always put that in there we go so
305:53 - that's doing the exact same thing and
305:54 - we're actually just reducing the amount
305:56 - of repetition because we have to
305:58 - remember to put a call on Follow by
306:00 - space inside here we might just forget
306:02 - it and then when you leave it like this
306:04 - then the chord is going to look ugly
306:05 - because it looks like this and it's all
306:07 - stuck together so let's make use of
306:09 - these two functions and let's see if we
306:10 - can write a really basic calculator we
306:13 - can say int first num equals read int
306:16 - and we can say enter first number and
306:19 - then duplicate that down change first to
306:21 - second and then change this also to
306:23 - Second and then inside a console right
306:25 - line we can actually have the add
306:27 - function and we can type in first number
306:29 - and then we can type in second number
306:31 - and if you don't want to call the
306:32 - function inside here you could actually
306:33 - just make another int and we can say int
306:35 - result equals add and just bring this
306:38 - line over to here and then in the
306:39 - console right line you can just print
306:41 - the
306:42 - result there we go so we read in both
306:44 - the values execute the add function and
306:47 - then return it back to the user using a
306:49 - console right line so these are the
306:51 - other ones and then here they are so if
306:53 - we do 50 and we do 50 again and you see
306:55 - that I've messed up because we have
306:56 - double colums now so although our
306:58 - calculator did indeed work let's just go
307:00 - and correct that so we can take these
307:02 - off now because we added it inside
307:06 - here 50 and 25 we should get 75 perfect
307:10 - so now we've made a little basic
307:12 - calculator by simply making use these
307:14 - functions and if we just expand this
307:16 - just to show you what it would have
307:17 - looked like so we go in from this and we
307:21 - place our message inside to here and
307:24 - then we have our convert line just like
307:27 - this and then if we duplicate that down
307:29 - we can change this to second number and
307:31 - then to second number
307:33 - and then as for the result we can say
307:35 - first n plus second
307:38 - n there we go you can see the code is
307:40 - drastically longer and is a bit
307:41 - meaningless to have duplica code this is
307:44 - literally the exact same line in both of
307:47 - these sections except for the fact that
307:48 - this ISS first and this ISS second and
307:51 - we're starring in first and we're
307:52 - starring in second so let's undo that
307:54 - and get back to our more efficient code
307:56 - there we go you can see that these three
307:58 - lines are considerably shorter and
308:00 - easier to read this is telling us we
308:02 - read integer here is the value and we
308:04 - want to return it inside our first Nome
308:06 - and so on and so forth let's have a look
308:08 - at another example where we can make use
308:09 - of this so we can have a string called
308:11 - name and we can read this in from the
308:13 - console console.
308:16 - readline but we need to Output a message
308:18 - so we can have another console right and
308:21 - we can say enter your
308:23 - name and then we can have this twice and
308:27 - we can do enter your age and then have
308:29 - an INT
308:30 - age but of course we don't want to be
308:32 - using this approach and putting a
308:34 - console right line inside here with a
308:36 - convert in 32 because although this is
308:38 - actually technically correct now we're
308:40 - UND doing the point Val function so
308:42 - let's change this into our readint and
308:44 - then as for our message well we have the
308:46 - message right here and again we don't
308:47 - need the space colons let's remove that
308:49 - and then as for the name we can actually
308:51 - do this differently so this is actually
308:53 - going to do a string variable so what we
308:55 - want to do instead of having read in we
308:57 - can have another function called read
308:59 - string another string message parameter
309:02 - and then do exactly the same thing have
309:04 - a console right and we can place string
309:07 - interpolation and place a message inside
309:09 - here followed by callon space and then
309:11 - we can just simply return the console.
309:14 - readline there we go and instead of
309:16 - doing all of this we can actually just
309:18 - put our read string inside here and then
309:21 - place our ENT your name inside here just
309:24 - without the call on Space because we
309:25 - don't need that so now we' reduce this
309:28 - section to two lines as well so now what
309:30 - we can do is have a string details and
309:32 - make that equal to a function that we're
309:34 - going to use now we can say user details
309:36 - if we want to give it the name and give
309:37 - it the age and that will give us back a
309:40 - string that we can print to the console
309:42 - so we can say details so let's go ahead
309:44 - and make use of this function so we can
309:46 - have a static and it's going to return
309:48 - as back a string CU we're placing it
309:49 - inside the string and then it's going to
309:51 - be user details and then our name is a
309:54 - string our age is an INT and then inside
309:57 - here we just want to concatenate them
309:59 - two values together so we can say hello
310:01 - my name is name and my age is age and
310:07 - because that's returning us back with a
310:09 - string we can make use of it inside
310:10 - string details or we can place this
310:13 - straight inside the console right line
310:15 - let's leave it as a function call assign
310:17 - into string details and then print out
310:19 - to the screen let's just skip over these
310:22 - sections enter your name AB enter your
310:24 - age 23 and then there you go hello my
310:26 - name is abber and my age is
310:29 - 23 so this is how we can make use of
310:31 - parameters and inside our functions so
310:33 - we can actually give it some sort of
310:34 - data that's meaningful if you didn't use
310:36 - parameters then what you're going to
310:37 - have to face is for example we showed
310:39 - you with this integer if you don't use
310:41 - parameters then you're going to have
310:42 - situations like I showed you before with
310:44 - this integer function it returns back an
310:47 - integer but it only gave us the value of
310:49 - 5 + 5 I mean technically you don't need
310:51 - to return anything you can actually just
310:53 - keep this avoid and just wrap this
310:54 - around in console right line the only
310:56 - issue with this approach is you don't
310:58 - have any option other than to print out
311:00 - to the screen or if you didn't want to
311:02 - print out to the screen and he simply
311:03 - just wanted to return the calculation
311:05 - and then store it inside another
311:06 - variable this doesn't give you the
311:08 - flexibility of that so we change this
311:10 - into an INT and instead of returning it
311:12 - back to the console we just return back
311:14 - the pure value and then if the user
311:16 - decides that they want to print this out
311:17 - to the screen that's fine like here
311:20 - we've made a decision that we want to
311:21 - print out let's just say we had a
311:23 - variable that said in calculation then
311:25 - we place that inside but we actually
311:27 - never wanted to print it maybe we kept
311:29 - it like this and then use Cal for some
311:31 - something else down below or maybe that
311:33 - was something like storing inside a
311:35 - database not everything will be printed
311:37 - out to the screen for the user to see
311:39 - the best thing to do is return the
311:40 - values in their purus form because you
311:42 - never know what the developer or the
311:44 - user is going to make use of that data
311:45 - later on down the line keeping it it's
311:47 - purus form is the best way possible for
311:49 - example in this case we're actually
311:51 - reading back the integer and then print
311:52 - it out to the screen but in this exact
311:55 - case which is the best case scenario
311:56 - that I just showed you we're actually
311:58 - making use of first n and second n but
312:00 - first n and second n and never actually
312:02 - print it to the screen it's always just
312:04 - used for the calculation if we use
312:06 - console right line to print out first n
312:08 - and second n then we're not going to be
312:10 - able to use it inside our calculation
312:12 - and therefore our very basic calculator
312:14 - is now being rendered pointless so read
312:16 - in and add all return back values that
312:19 - we can use in their purest form and that
312:21 - is the whole goal of
312:24 - parameters so now that we covered
312:26 - parameters that are always going to be
312:27 - required let's have a look at another
312:29 - concept called optional parameters so we
312:32 - had a static int add and we had int a
312:34 - and int B for example and then we simply
312:37 - just returned a plus b like we used in
312:39 - the previous examples if we have an INT
312:41 - result and we want to call that function
312:44 - and we give it the value five and five
312:46 - and then print out to the screen
312:47 - everything runs okay because we've added
312:49 - in exactly what we expect let's say we
312:52 - don't actually have this additional five
312:53 - of course this doesn't make any sense
312:55 - cuz we meant to be adding two numbers
312:57 - but just humor me for a minute then what
312:59 - this will do is says there's no argument
313:01 - given that corresponds to the parameter
313:03 - B now of course this is a problem
313:04 - because it's a red underline which means
313:06 - if we try and run the code we're going
313:07 - to get an issue let's say you creating
313:10 - some sort of system that if you entered
313:12 - both values it uses both values but if
313:15 - you only entered one it automatically
313:17 - set the second value to something else
313:20 - and we can achieve this Behavior using
313:22 - optional parameters so an optional
313:24 - parameter doesn't exactly mean quite
313:26 - optional it kind of just means that it's
313:28 - going to be optional but you can also
313:30 - give it a default value this will always
313:32 - add two numbers A and B even if we make
313:36 - a or b optional it's going to still need
313:38 - two numbers to add in order for the
313:40 - function to run so in order to make a
313:42 - parameter optional let's just say we
313:44 - want to make B optional we can type in
313:46 - equals straight after it and actually
313:48 - give it a value so as you can see our
313:50 - syntax error is now gone and if we run
313:52 - the code we should get
313:54 - 55 and the reason why this works is a is
313:57 - now five if you hover over here we can
313:59 - see a is five and then the square
314:02 - brackets around the int B actually
314:04 - denotes that it's optional and it says
314:06 - int b equals 50 cuz we have that here so
314:09 - it's actually using this as 50 and if we
314:12 - don't specify the second parameter then
314:14 - it's practically just doing this which
314:16 - is completely fine so the reason why I
314:18 - said it's not quite optional is because
314:20 - you still need to give it a value of
314:22 - course in here you can use the default
314:23 - keyword in the case of an integer the
314:26 - default value is actually zero so if you
314:28 - just run that code now it's going to say
314:29 - 5 + 0 which is just 5
314:33 - so it can be optional but you still need
314:34 - to give it some sort of value of course
314:36 - if you're doing a calculator and you're
314:38 - adding two values if you only specify
314:40 - the first one then adding zero to it is
314:43 - simply not going to change it so zero or
314:45 - default is going to be the best user
314:47 - case when you're dealing with default
314:49 - values with integers so another way you
314:51 - can actually specify this is by
314:52 - inserting this thing called an attribute
314:54 - if we remove this equal zero and just
314:56 - before the end we can type in Open
314:58 - Bracket close bracket and type in
315:00 - optional with a capital O and then
315:03 - you're going to get a red underline if
315:05 - you hover over it it says we need to
315:07 - include this extra Library which will
315:09 - import it at the top of our code as you
315:11 - can see here now that this is available
315:13 - it says indicates that a parameter is
315:15 - optional and what this will do by
315:17 - default is it'll give you the basic
315:19 - value for this number so what I mean by
315:22 - that is we can type in here just to show
315:24 - you this b equals and then B and this
315:26 - will just give you the default value
315:28 - based on the data type and as we just
315:30 - said a minute ago that value is actually
315:32 - going to be zero there you go B is zero
315:35 - so all it's doing is saying 5 + 0 =
315:39 - 5 so that's another way of doing it or
315:41 - you could just leave it as I said before
315:43 - you can say in b equals default or in b
315:46 - equals z it's completely up to you I
315:48 - prefer using the default keyword so you
315:50 - don't have to keep remembering which
315:52 - different data types have the default
315:53 - values in the integer case it's zero but
315:56 - I just like leaving the default and we
315:58 - can get rid of this line now let's have
315:59 - a look at different situations where
316:01 - this be helpful if you had a function
316:03 - called print name and we had a string
316:05 - name in here and then we can simply just
316:08 - say console right line my name is and
316:11 - then name this is quite easy to use so
316:14 - we can say print name and then place
316:16 - arber inside the brackets and then run
316:18 - the code and we get abber printed to the
316:20 - screen and that's fine but let's say if
316:22 - we had someone else's name in there as
316:25 - Joe for example then we get Joe to the
316:26 - screen and let's just say as the
316:28 - developer you only want to default this
316:30 - to abber if you you don't actually
316:32 - insert anything so now if you don't
316:33 - insert anything of course we're going to
316:35 - get a compil error because we need a
316:36 - parameter but if we assume what we did
316:39 - here and just follow the same approach
316:41 - if we use default then it's going to
316:42 - give us nothing because the default
316:45 - value for a string is just empty quot
316:47 - which is just nothing but instead of
316:49 - default we can actually specify value so
316:52 - we can say if no one types their name
316:54 - inside the bracket then use
316:57 - abber there we go so you can have this
317:00 - optional parameter that defaults to
317:02 - something and if someone types in jaw or
317:04 - whatever inside the print name function
317:06 - then the default optional parameter is
317:07 - not going to be used since this will be
317:09 - overridden if you have a parameter
317:11 - placed inside here so now the abber is
317:13 - going to get overridden by the jaw
317:15 - because this is actually the parameter
317:17 - that's being used in the
317:19 - function so you've looked at functions
317:21 - with normal parameters optional
317:23 - parameters and now let's take a look at
317:24 - name parameters so let's say you had a
317:26 - situation where you had string name ABA
317:29 - in age equal 23 and string address
317:32 - equals one something Road and then you
317:35 - had a function that would simply print
317:37 - these details out to the console so
317:39 - start void print details there string
317:42 - name inage String
317:45 - address so you have three console right
317:47 - lines that just print out a name value
317:49 - pair just like
317:51 - this and then when you go to call this
317:53 - function what you're going to have to do
317:55 - is specify the name then the age then
317:57 - the address in that specific order as
318:00 - per the parameter show if we try and run
318:02 - the code now we should get the desired
318:05 - output perfect let's say for example you
318:07 - wanted to rearrange the parameters and
318:09 - put Age first you'll see we have a
318:11 - compiler error now because age and name
318:13 - are in the wrong order string name
318:15 - should be first and int age should be
318:17 - second we can still achieve this by
318:19 - using something called name parameters
318:21 - we don't have to stick to this order if
318:22 - we tell the compiler which parameter
318:24 - we're directly talking about so we can
318:27 - say age callon because our parameter is
318:29 - now called age as you can see it's been
318:31 - being highlighted and then after the
318:32 - call on it's the variables that we're
318:34 - talking about so it just happens to be
318:36 - that age is the same value as the edge
318:39 - so maybe we can change this to age input
318:42 - and place input at the end of these so
318:44 - then we can have age equals age input
318:46 - and name parameter equals the name input
318:49 - and the address parameter equals the
318:50 - address input now we can have it like
318:53 - this and to make it look even better you
318:55 - can actually add new lines in here just
318:57 - to break it off like this and this is a
318:59 - similar pattern that you'll see in
319:00 - normal production code putting a space
319:02 - here can separate them out a little bit
319:04 - and there we go it doesn't matter which
319:06 - order that we put these in right now we
319:07 - can even put address first and it'll
319:10 - still work okay and if we run it you
319:12 - should still get exactly the same output
319:14 - it's just specified in a different way
319:16 - so let's just have a little recap to
319:18 - make use of name parameters you don't
319:19 - need to do anything to the original
319:20 - function you just write it exactly the
319:22 - way you're used to doing you specify the
319:24 - parameters in the order that you think
319:26 - is sensible and when you go to call it
319:28 - you can simply just type in the
319:29 - parameter's name first followed by colon
319:32 - and then the variable name that you want
319:33 - to address once you've done that then
319:35 - you can use name parameters you can go
319:37 - back to using the normal function by
319:39 - just getting rid of the name followed by
319:40 - the colon and just replacing all of the
319:42 - parameters using the correct order and
319:44 - the original variables instead of the
319:46 - new notation having Name colon followed
319:49 - by name
319:51 - input so far we've covered functions
319:53 - with no parameters normal parameters
319:56 - optional parameters named parameters and
319:58 - let's look at a concept called out
320:00 - parameters let's demonstrate a quick
320:01 - example so if we call a function called
320:03 - test and we pass in a value and let's
320:05 - just make this work so we can have an
320:07 - INT Norm equals 0 and then we have a
320:09 - test function so we can say static void
320:12 - test and we can say in Num and inside
320:16 - here let's make num the value of five
320:18 - now in this example if we print out num
320:20 - to the screen what do you think is going
320:21 - to happen is num going to take the value
320:23 - of five or is it going to keep the value
320:26 - zero I'll give you a second to think and
320:27 - let's run the
320:29 - code so let's run it and see what
320:33 - happens and if you guess five you're
320:36 - indeed Incorrect and if you guess zero
320:38 - you are correct and the reason why it's
320:40 - not five is because when you pass a num
320:43 - inside this parameter it just becomes a
320:45 - parameter and therefore it becomes a
320:47 - local variable even though these two
320:50 - variables are actually called exactly
320:52 - the same thing you'll see that when I
320:54 - highlight it it only highlights this one
320:56 - and doesn't highlight this one and the
320:58 - same is true for this it highlights
321:00 - these three references but not the ones
321:02 - down here the gome variable is only
321:03 - accessible in each other scope this one
321:06 - is available through here and here and
321:08 - this one is available through here and
321:10 - here therefore if we use this assignment
321:13 - then it's actually doing nothing if we
321:15 - print out gnome inside here num equals
321:19 - num and then we print that we can see
321:22 - that it is assigned the value five but
321:24 - because it doesn't do anything at the
321:25 - end of this function then it simply
321:27 - doesn't get returned back or anything
321:28 - happens to it so let's see how we can
321:30 - make make this in to five when it gets
321:32 - printed out here so the options that we
321:35 - have is we can actually make this vo an
321:37 - integer and we can say nor equals 5 and
321:39 - then we can return num or alternatively
321:42 - we could simply just return five and not
321:44 - do both of these lines so if we run that
321:46 - now then we still get zero and the
321:49 - reason why we get zero is the test
321:51 - function is being called and it returns
321:53 - back an integer but we're simply not
321:55 - doing anything with it so we can say num
321:57 - equals the return value of this function
322:00 - which will be five and now if we run it
322:01 - we should see our five perfect now this
322:05 - is a little bit cumbersome and let's say
322:06 - you wanted to return a value and return
322:08 - back another value at the same time then
322:10 - what are your options so let me show you
322:12 - a quick example when you're using int.
322:14 - tripod we have a string s an out in
322:18 - result and a bull so what this function
322:20 - is effectively doing is return you back
322:23 - a true or false value to dictate whether
322:25 - or not the conversion has been
322:27 - successful and it's also returned you an
322:29 - out into result and what what this means
322:31 - is you can actually specify integer
322:33 - variable straight inside the brackets so
322:35 - in essence this function has gave you
322:37 - back two values it's gave you back
322:40 - something from the integer parameter and
322:41 - it's also returned back a Boolean
322:43 - variable so let's convert this to code
322:45 - and see what the third option is of
322:47 - trying to return back five over to this
322:50 - so if we just comment out this line and
322:52 - as you saw in the trip pass you simply
322:54 - just need to put the word out just
322:56 - before
322:57 - here out in Num
323:01 - now we don't actually need to return
323:02 - anything in this specific example
323:04 - because we want to just change a num
323:06 - variable using the out parameter but if
323:09 - we wanted to return something separate
323:10 - to the num like a booing like the tri
323:12 - pass did then we have that option so we
323:14 - can return back true but just before we
323:17 - return back true as there's a red
323:18 - underline here it will say that the out
323:20 - parameter gome must be assigned so we
323:23 - need to give num a
323:24 - value we give it the value five because
323:27 - what we're actually doing here even if
323:29 - we double click on this we'll still
323:30 - still get none being selected here cuz
323:33 - the scope is still exactly the same now
323:35 - except what's happening is when this
323:37 - variable gets returned it actually gets
323:39 - put into the variable that it was
323:40 - initially called with so let's fix these
323:42 - compiler errors first so the reason why
323:44 - it's complaining is because we need to
323:46 - give it the out keyword so when we're
323:48 - specifying in Tri pass our first
323:50 - parameter is a string so if the user
323:51 - types in 1 2 3 we put in the first
323:53 - parameter and then we'd say out in
323:56 - result or something along them lines you
323:58 - have an out and then you say you want to
324:00 - make a new integer and you want to call
324:02 - a result see in our case we don't need
324:04 - to put int just like in here because
324:06 - we've already created our num so the
324:08 - only keyword we need is out to follow by
324:10 - space and now of course we're trying to
324:12 - assign this back into an integer which
324:15 - we don't need anymore because this is a
324:16 - booing so we can say bu
324:19 - success equals test out n so we print
324:22 - out
324:24 - Success Print them both the screen now
324:26 - we should have five and true the true
324:28 - comes from the return true and the five
324:30 - comes the num equals 5 so what's
324:33 - actually happening here is we're
324:34 - creating our new integer we're passing
324:36 - it into this function we're also telling
324:38 - you it's going to be an out parameter so
324:40 - this function can still output things to
324:42 - our number variable and then when it
324:44 - gets placed inside here we assign Nome
324:46 - equal to five and then just because we
324:48 - have a bull we have to return true or we
324:50 - can return false of course we can just
324:53 - take this out completely take away the
324:55 - return true and just keep this as
324:57 - test of course in both scenarios these
325:00 - aren actually do anything they're just
325:01 - complete random values it's just made
325:03 - for demonstration so bu is returned back
325:06 - true or false doesn't actually mean
325:07 - anything I was just demonstrating that
325:09 - you can have two return values from one
325:11 - function there we go we get five when we
325:13 - run it just like this so now I've
325:15 - completed this little example let's have
325:17 - a look at how it's used in the real
325:18 - world so before we continue let's see if
325:20 - we can rewrite the tripal function in
325:23 - our code so it's going to be a static
325:25 - returns back a we have a triy pass our
325:27 - first parameter is a string s and our
325:29 - second parameter is out out into result
325:32 - and inside there we can just do result
325:35 - equals to zero and then we can return
325:37 - back true of course we actually need to
325:38 - do conversions inside here if you want
325:40 - this function to work but I'm just
325:42 - showing you for demonstration purpose if
325:44 - we uncomment this line out and have a
325:45 - look at the parameters again you'll see
325:47 - that now they line up perfectly string s
325:50 - out in result and it returns back a Bo
325:52 - which we have exactly the same here
325:54 - there you go bu in. trass string s out
325:57 - in result so that's how this function
325:59 - has been declared of course they're
326:01 - doing something inside the body that can
326:03 - take in the string convert it to an
326:04 - integer place it inside result and then
326:07 - return whether or not the function has
326:08 - been executed successfully so now that
326:11 - we understand how to make an example and
326:13 - how to make the trip pass function
326:14 - ourselves and to give you the
326:16 - Declaration let's have a look at a real
326:17 - world example so if we had a list of
326:20 - string and we had our shopping list that
326:22 - was used from the examples we can have
326:24 - list string and let's just create our
326:27 - own initializer just with coffee and
326:28 - milk
326:29 - inside there we go so now that we've
326:31 - created that we've got our shopping list
326:33 - if you wanted to find something inside
326:35 - the shopping list we have the function
326:36 - index of and what that will do as it
326:38 - says here searches for the specified
326:40 - object and Returns the zero based index
326:43 - of the first occurrence so if we were to
326:45 - search for coffee then we should get
326:47 - return back zero so let's try and run
326:50 - this and put it in the console right
326:51 - line and see what the value is there we
326:53 - go we get zero since it's the first item
326:56 - and if we place milk inside here we
326:57 - should get back one there we go
327:01 - so let's try and rewrite this function
327:03 - into our own code so all this will do is
327:05 - loop around all of the positions until
327:07 - it finds it and it'll find the first one
327:10 - and it'll return us back the index so in
327:12 - this case there's no out parameters but
327:14 - there is a return value so we can also
327:16 - include an out parameter and then
327:19 - instead of assigning the value of minus
327:21 - one we can actually assign the value of
327:22 - true or false to dictate whether or not
327:25 - that we found it so let's write the code
327:26 - normally in here and then let's wrap it
327:28 - around in a function so we can say int
327:30 - index equals minus one because we want
327:32 - it to start a value that we know is
327:34 - incorrect since the lists are from zero
327:36 - onwards the value is only ever minus one
327:39 - then that means it's not in the list
327:41 - then we can then create a for Loop
327:43 - entire equal Z shopping list do count
327:46 - cuz we want to go through every single
327:47 - item inside the shopping list and inside
327:50 - here we want to do a lowercase
327:51 - comparison so we can do if the shopping
327:53 - list square bracket I do to
327:56 - lower do equals and then we want to make
327:59 - that equal to just something that we're
328:01 - going to type in statically so we can
328:03 - just say copy we can make this into a
328:06 - parameter after but this is just for
328:07 - demonstration purposes so we have a
328:09 - bracket and if we found that match then
328:11 - we can say index equals to I cuz the
328:14 - index of the position that we want to
328:15 - find must be up to I cuz that's the one
328:17 - that we've made a match with and we
328:19 - don't need an else inside here we don't
328:22 - need to set an else inside here to make
328:24 - it equal to minus one because if it
328:25 - simply doesn't find it then the index
328:27 - variable won't change its value so it
328:29 - will always stay minus one if it doesn't
328:31 - find anything so after the follow Loop
328:33 - is run let's just print index out to the
328:36 - screen there we go we have zero and if
328:39 - we change this over to milk run it again
328:41 - then we actually have one placed inside
328:44 - here perfect so now what our function is
328:46 - doing is giving us the values of the
328:49 - index if it finds it now if you type in
328:51 - something else if you just add another
328:52 - can let's see what happens then we get
328:55 - minus one and minus one means that it's
328:57 - incorrect and it hasn't found it and
329:00 - what we we can do inside here we can say
329:02 - if the index is greater than minus one
329:05 - then we can say found or else we can say
329:08 - not found so let's run the code now and
329:10 - see if we get a visual representation
329:12 - not found and if we changes back to milk
329:15 - run it again then we get found perfect
329:19 - so as you can see here we're actually
329:20 - checking if the value is greater than
329:22 - minus one but it'd be easier if you had
329:24 - a variable called found and is actually
329:26 - a booing variable so we can make a Bo
329:28 - found and make that equal to and if
329:30 - statement condition so we can say
329:32 - something like index is greater than
329:34 - minus1 which is exactly what we had here
329:37 - a second ago and because this is a
329:39 - condition it's either going to return
329:40 - back true or false and it's going to
329:42 - place the value inside found and then
329:44 - we're going to use found inside here
329:46 - this is easier logic to understand if
329:49 - this is true then it's found if this is
329:51 - not true then it's not found true true
329:54 - false false it's quite really
329:56 - straightforward and very easy and clear
329:58 - you have an index and you have whether
330:00 - not it's being found so let's try and
330:02 - wrap this around inside a function so
330:04 - just as the trip pass does it returns us
330:06 - back with a Bool which in this case will
330:08 - be our found and it also gives us back
330:10 - an integer result but in this case it's
330:12 - going to be our index so let's see what
330:15 - we can do to write this so we can have a
330:16 - static we want to return back the Bo and
330:19 - we can say find in list we need to give
330:23 - it the item we're going to find so we're
330:25 - going to need a string s we need a
330:27 - string s for the item that we're going
330:28 - to find we need to give it the list as
330:30 - well and then finally we need our out
330:32 - int
330:34 - index there we go so let's comment out
330:37 - this code
330:39 - here and let's copy this down into our
330:42 - function and see what we need to do so
330:44 - index has the value of minus one we
330:46 - don't need the integer variable
330:48 - declaration here because we've already
330:49 - declared it inside the parameter so
330:51 - after declaring inside here we give it
330:53 - the value ofus one minus one indicates
330:56 - it hasn't been found since the index are
330:58 - zero based so instead of shopping list
331:00 - we now just have list and list here as
331:03 - well and then instead of having it being
331:06 - equal to milk we actually want to use
331:07 - our s variable and to make it better we
331:10 - can convert it to lower case just so we
331:11 - have lowercase conversions on both sides
331:13 - of the equals if we find a match between
331:16 - the list that we've passed in and the S
331:18 - variable which is our surge term that
331:19 - we've passed in then we assign I to the
331:22 - value of index and then it's still got a
331:24 - red underline because we haven't
331:26 - returned back
331:27 - bu so right now we actually want to
331:29 - return back the found variable so we
331:31 - have two options here we can return back
331:32 - found or we can simply take this and
331:35 - return it back in here we don't need to
331:37 - run this code to see if it's found or
331:38 - not and then store it and then return it
331:40 - after since we're not doing anything
331:42 - else with it we could just return it
331:43 - like this this makes the code
331:44 - considerably shorter because this will
331:46 - just return back a true or false if the
331:49 - index is greater than minus one then it
331:50 - will turn back true if the index is less
331:52 - than minus1 then it will turn back false
331:55 - so let's see how we can use this
331:56 - function inside our code now so we
331:58 - wanted to search for milk so let's just
332:00 - copy and paste this line and let's see
332:01 - if we can get the same output as the
332:03 - shopping list index of so now our
332:05 - function is called finding list you have
332:08 - a bracket and then our string s is going
332:09 - to be our milk our list is our shopping
332:12 - list and our out in
332:15 - index so this is going to return us back
332:18 - with a booing so we can print that
332:19 - booing to the screen and then if we just
332:21 - duplicate that down and we can print
332:23 - index to the screen and maybe using a
332:25 - console right line and just place a
332:27 - space right at the
332:29 - start so we print out whether it's
332:31 - successfully converted or not and we get
332:33 - the value back from
332:35 - it let's run the
332:38 - code so we get true plus the value of
332:41 - one so that means it's found it and it's
332:43 - found it at one index and the previous
332:45 - line before it which just run the normal
332:47 - index of function also return back one
332:50 - so they're both the same let's just get
332:51 - rid of that
332:55 - space so if you change these both to
332:58 - coffee then hopefully we should see the
333:01 - same result but with index zero there we
333:03 - go this zero comes from the index
333:05 - function this true is from our function
333:07 - telling us has been successful and this
333:09 - zero is the index so we can actually
333:11 - take this and put this straight into an
333:13 - if
333:14 - statement so just like we had down here
333:16 - with the found and not found we can say
333:18 - if and then this function call and then
333:21 - we can say found and then the item what
333:24 - we passed in so in this case it's going
333:25 - to be coffee found coffee found coffee
333:29 - at index index and if it hasn't been
333:32 - found then we can just print not
333:35 - found and this is getting an error
333:37 - because we have two indexes up here so
333:39 - let's comment out this line and let's
333:41 - try running out found coffee index zero
333:44 - and you can see these two are the same
333:46 - again one comes from here and one comes
333:48 - from that index we change these both to
333:50 - milk now milk milk and milk then run the
333:55 - code and you see F milk index one if you
333:58 - wanted to just before you pass in here
334:00 - you can ask the
334:02 - user enter an item to
334:06 - search start inside string search equals
334:10 - console.
334:12 - readline and then instead of passing mil
334:14 - in here we can just pass in Search and
334:16 - then instead of passing milk in here we
334:18 - can also use the search variable so now
334:20 - if we try run it again we can type in
334:21 - milk and then we go file milk index one
334:24 - and then coffee found coffee index zero
334:26 - and just to give this a test let's just
334:28 - try and find m not
334:31 - found
334:33 - perfect so let's have a little recap
334:35 - based on this function so initially we
334:37 - tried to assign the value of zero and
334:39 - then print out a normal function and
334:41 - inside test we just had a simple num
334:44 - equals 5 and what this was doing inside
334:46 - is just locally assigning it but not
334:48 - actually return anything and then we
334:50 - said we could assign it and then return
334:51 - it back and that was another option of
334:53 - being able to assign the value to five
334:55 - and then we useed the out parameter
334:57 - which allowed you to pass in an integer
334:58 - when you assign in here it will pass it
335:00 - back into the original call and place it
335:02 - in this variable here so when we print
335:05 - out on the next line it says it's equal
335:06 - to 5 we wrote our own little shopping
335:09 - list for the list of strings and then we
335:11 - called the shopping list function index
335:13 - of and then we actually created our own
335:15 - index of function and made it into a
335:18 - function so just a little recap what's
335:20 - going on here we have a string s which
335:22 - is our search term the list full of the
335:24 - items in the index that we're going to
335:26 - pass back to the user as well as
335:27 - returning back a bu to indicate whether
335:29 - we found found it or not we set the
335:32 - index to minus one so then that
335:33 - completes our logic at the bottom minus
335:36 - one means it hasn't been found since the
335:38 - list is all zero based if this value is
335:41 - greater than minus1 then that means that
335:44 - we found it inside the list since the
335:46 - list is zero Bas and if it's not that
335:48 - and this returns back false then we
335:50 - mustn't have found it because this line
335:52 - would have executed so we Loop through
335:54 - the list we do a lowercase comparison on
335:57 - both sides of the equation on the list
335:58 - item and on the sege term if they both
336:01 - match we run the index and stall the I
336:04 - variable inside the index and then we
336:06 - return whether index is greater than
336:07 - minus one so after we've turned this
336:09 - back from the end of the function we can
336:11 - see once we run it inside the console
336:12 - right Line This is just going to return
336:14 - us back with a true or false value as
336:16 - well as creating our new integer
336:18 - variable called index so on the next
336:20 - line we can use index and print out of
336:22 - the screen this line should return true
336:23 - or false since it's a Boolean return and
336:26 - this variable will either give us minus
336:28 - one or something above minus1 but in
336:30 - this case when we actually make use of
336:31 - the function we can ask a user to enter
336:33 - something get them to type it in and
336:36 - pass that into the function but more
336:37 - importantly when this function returns
336:40 - if it's true we output it's been found
336:42 - and if it's false we output not found
336:45 - and we only make use of this integer
336:47 - variable should this return back true
336:49 - there is no point in printing minus one
336:52 - to this screen because that's what
336:53 - you're going to get if it's not
336:55 - found it's going to look something like
336:57 - this which is kind of redundant because
336:59 - the user doesn't care about this so we
337:01 - don't need to include it when we're
337:02 - printing not found but we should include
337:04 - it when we're printing out the found of
337:06 - course this is just a random example and
337:07 - you might not need to print it out to
337:09 - the screen or you might just do
337:10 - something else inside here you might be
337:12 - searching for something and then you
337:14 - might want to edit it or do something
337:15 - else with it and then you can make use
337:17 - of that index if you wanted to ask the
337:19 - user to search for an item and then tell
337:21 - them what they want to replace it with
337:23 - then you can also do that just as we've
337:25 - covered in the last
337:28 - examples so after after we've covered
337:30 - out parameters and normal parameters
337:32 - let's have a look at a concept called
337:33 - passing by reference so we created
337:35 - interm equals 10 and let's call it
337:37 - assign and we passed it straight into
337:39 - here and we can have a static void
337:43 - assign in
337:45 - N if we say Nome equals 20 if we use a
337:48 - console right line up here then Nome is
337:50 - still going to be 10 because we're not
337:53 - returning it and we're not really
337:54 - affecting it now other ways we can do
337:57 - this is by changing this into an INT and
337:59 - then we can say return 20 and then we
338:02 - don't really need this anymore so we
338:04 - could just say
338:05 - num num equals a sign and then we'll get
338:08 - 20 assign back in there we go or we can
338:11 - actually make this an out into num and
338:14 - then we can say num equals to
338:17 - 20 and then inside here we can say out
338:20 - num we don't need to return back in
338:22 - anymore so we can make this Vol and you
338:24 - see the value 20 so there are different
338:26 - ways that we can assign a variable
338:28 - straight from here so let's let's have a
338:29 - look at another method so instead of
338:31 - having out we can actually use a new
338:33 - keyw called ref and the reason why it's
338:35 - ref it means it's passing it by
338:37 - reference so when you pass a value in
338:38 - through a parameter normally you're
338:40 - actually passing by value and what that
338:42 - means is you're copying this value that
338:44 - gets passed inside the brackets into
338:47 - here and it's making a whole new
338:48 - variable what I mean by that is this
338:51 - might have memory dress location one and
338:53 - then when this variable gets created it
338:55 - has memory dress location 2 for example
338:57 - and then it's used within here and then
338:59 - two is now deleted because you've got
339:01 - rid of the variable because of this
339:02 - function but one is still alive since in
339:05 - the main function when you pass by
339:06 - reference what you're doing is you're
339:08 - saying give me the memory address
339:10 - location of the variable inside the
339:11 - brackets and give it into this function
339:14 - rather than copying the value so if this
339:15 - has memory just location one and you
339:17 - pass it into here then it's also going
339:19 - to have one so what this actually means
339:21 - is if we put this ref keyword just
339:23 - before the in just like we do with the
339:25 - out and we can place it here as well
339:27 - we're now saying we want to pass this by
339:29 - by reference so when this 10 gets passed
339:31 - in here we actually have a link if you
339:34 - will to this gome is now linked to this
339:36 - gome which means if we simply do n
339:39 - equals 20 and run the code then we're
339:41 - going to see 20 the main differences
339:43 - between reference and using the out
339:45 - keyword is when you're using out within
339:47 - a function you actually need to make use
339:50 - of the value if I don't include anything
339:52 - within here then I'm going to get
339:53 - exception and it says the out parameter
339:55 - num must be assigned so when using the
339:58 - out keyword num has to be assigned when
340:01 - using the ref keyword you don't have to
340:03 - make any assignment because we're just
340:05 - passing a reference in with the out
340:07 - keyword you literally tell the function
340:09 - I want to Output this value but if you
340:11 - haven't gave it a value to Output then
340:13 - of course it's going to be an error so
340:14 - we can assign in the reference if we
340:16 - really want to but you don't have to and
340:18 - it's not required so there are the two
340:20 - main differences between passing by
340:22 - reference and passing by value and also
340:24 - using the out parameter passing by
340:26 - reference is technically quicker because
340:28 - of efficiency when you don't pass it by
340:30 - reference you pass it by value which
340:32 - means it'll essentially place that 10
340:34 - inside these
340:35 - brackets instead of passing the variable
340:38 - in it actually just passes the value and
340:40 - then it makes a whole new variable down
340:42 - here when you pass it in by reference
340:44 - you're essentially actually giving it a
340:46 - link to this memory address location
340:48 - from inside this function which means
340:50 - that you don't actually have another
340:52 - local variable inside here because this
340:54 - one is affecting this one directly you
340:57 - can do this with any amount of
340:58 - references you want by simply just
341:00 - changing them and adding another one in
341:02 - like that for example and then we can
341:04 - have a string name and then we can pass
341:07 - our ref name inside here and inside here
341:10 - we can say name equals hour and this
341:13 - doesn't like it if it's unassigned so we
341:15 - just give it empty quotes or we can sign
341:17 - it another name it doesn't really matter
341:19 - it's just a demonstration and if you run
341:21 - that but let's just print out the name
341:23 - as well to the
341:24 - screen there we go we get Abra assigned
341:27 - into
341:28 - there and same thing with this variable
341:30 - is we're actually just passing in the
341:32 - variable as a reference rather than as a
341:34 - value it doesn't matter what the value
341:36 - is going to be CU it's just given this
341:38 - variable inside this function so we're
341:40 - actually saying name equals we'll
341:42 - basically just assign it back into the
341:44 - original variable so let's just have a
341:45 - look at another example so we can have
341:47 - some sort of like change name function
341:49 - and we can give it the name variable as
341:51 - a reference and then we can give it the
341:53 - new name that we're going to pass in in
341:54 - a second so if we make a new function
341:56 - static void change name you're going to
341:58 - need a ref string name and a string new
342:01 - name and we can simply say in here name
342:04 - equals new
342:05 - name perfect so let's give this a shot
342:08 - so if we just comment out this little
342:10 - section and we can say console right
342:14 - enter your new name then we have a
342:16 - string new name equals console.
342:20 - readline and then just up here as we've
342:22 - done before we could just declare the
342:23 - name as being Joe and then we enter the
342:26 - new name call this function and then
342:28 - after we can say
342:30 - your new name is and then we can pass in
342:33 - name perfect let's run
342:35 - that so at this point the name is
342:37 - actually Joe cuz we've made it appear
342:39 - and then we'll enter a new name so we
342:40 - can type in abber now it says your new
342:43 - name is abber perfect so all this
342:45 - function is doing I know it's pretty
342:47 - pointless right now cuz it's just doing
342:48 - one line but all it's doing is assigning
342:51 - the reference to the variable that we
342:52 - pass in so what we can do now is make
342:54 - sure that we can actually assign this
342:56 - variable in and we can also pass in a
342:58 - Boolean variable so what we should do
343:00 - now is actually make sure that we can do
343:02 - the assignment properly cuz you don't
343:03 - want to assign it if the value is empty
343:05 - and then return back a booing type just
343:08 - to indicate whether or not it's being
343:09 - assigned so what we can do in here is
343:11 - just on the change name we can wrap this
343:13 - around an if statement and if this
343:15 - returns back true then your name has
343:17 - been changed and if not we can say
343:20 - console right Line new name cannot be
343:22 - empty or
343:24 - no in order to be able to do this check
343:27 - as we've used before we could say if new
343:30 - name and then just around that we can
343:32 - say string do is n or empty and wrap
343:34 - that inside the brackets and we want to
343:36 - say if it's not n or empty then we want
343:38 - to do our
343:40 - assignment after we've done our
343:42 - assignment we can return back true
343:43 - inside here and then just outside we can
343:46 - return back false notice how in this
343:48 - little bit of code we actually don't
343:49 - have an else we don't need to write else
343:52 - inside here and place return false
343:55 - inside here because if this returns back
343:57 - true then it's going to execute this one
343:59 - line return back true and since it's a
344:02 - return it's going to jump to the end of
344:03 - the function so we don't need the else
344:05 - in there because the only way that this
344:07 - line will ever execute is if we actually
344:09 - had this function returning back false
344:12 - so if this returns back true it's going
344:13 - to hit this line hit the return jump to
344:16 - the end if this returns back false it's
344:18 - going to skip over the if statement and
344:19 - then just return back false to the user
344:21 - perfect so now we've got no compile
344:22 - errors let's give it a run so we want to
344:25 - change your name to nothing if we just
344:27 - press enter then we can see it says says
344:29 - new name cannot be empty or no and if we
344:31 - type something in then we get our name
344:33 - changed so just to round up this video
344:35 - let's talk about the main differences
344:37 - between the ref parameter and the out
344:38 - parameter when you sign in by reference
344:40 - you actually have to make the variable
344:42 - before you pass it in for example you
344:44 - can't just write ref string in here and
344:46 - that actually works whereas you can't
344:48 - actually do that with the end let me
344:50 - demonstrate so if you had the in. trass
344:53 - and that has an out parameter you can
344:55 - actually type out in index inside here
344:58 - you don't actually have to make the int
345:00 - index inside here and then specify it
345:03 - outside you could just initialize and
345:05 - declare the variable straight inside the
345:07 - brackets whereas because you're passing
345:09 - a reference with the string you actually
345:11 - need to make the string first and then
345:12 - pass it in so that's a big difference
345:14 - between the out and the ref when you
345:16 - make use of it actually inside the
345:18 - function if you're using a reference
345:20 - then you never have to assign it or at
345:22 - least it's not required you could have a
345:24 - series of if statements inside this body
345:26 - and then you might determine that you
345:27 - might not need to assign it which is
345:29 - exactly what we've got here the only way
345:31 - we assign name is if this returns back
345:33 - true if it doesn't return back true then
345:35 - we simply don't assign it and move to
345:37 - here this is a problem if the out
345:39 - variable if we change it to an out then
345:41 - we're going to get a compiler error
345:43 - because it doesn't return back a value
345:45 - so we'd have to write something like
345:46 - this at the top name equals something
345:48 - and then potentially sign it here and
345:50 - then return back false so with reference
345:52 - you don't have to worry about the fact
345:54 - that you might not assign in every
345:55 - single path of your code and finally the
345:58 - main difference is the fact that out
345:59 - parameters are still used by value and
346:02 - this is by reference reference will be
346:04 - slightly quicker since you'll get the
346:05 - memory just location being passed in
346:07 - instead of the values so you won't have
346:09 - two copies of the same
346:12 - variable the focus of this task is to
346:15 - create a function that calculates the
346:16 - area of a triangle so we're going to ask
346:18 - the user for width and height install
346:20 - them both create a function to calculate
346:21 - the area the function is going to
346:23 - calculate it using width times by height
346:26 - taking that calculation and dividing the
346:28 - value by two call it in the main and
346:29 - print out the area of the triangle to
346:31 - the screen so let's start with entering
346:33 - the width and the height so we can say
346:35 - enter width
346:36 - callon and have int width equals convert
346:40 - to int
346:42 - 32 console do read line and if you copy
346:46 - these
346:47 - down change width to height and change
346:50 - width here to height and just before we
346:52 - continue because we did copy and paste
346:54 - down then this is quite bad and we
346:56 - should use a function here so in both of
346:58 - the cases we're going to output
346:59 - something to the console and then read
347:00 - it in and convert it back as an integer
347:02 - so we it says static int because we
347:04 - return back an integer so we can store
347:06 - it we can say read int and we want a
347:09 - string message so we can pass in this
347:11 - value inside
347:12 - here so we take these two lines and
347:15 - place inside here instead of enter
347:18 - height we're now going to have message
347:19 - instead of int height we're just going
347:21 - to have a return value and then we're
347:23 - ret return in the conversion from the
347:24 - console read line and now we can use it
347:26 - inside here read in and inside inside
347:28 - the brackets you want to put the string
347:30 - output which is going to be enter height
347:32 - if you paste that inside here and then
347:34 - do the same thing for the previous
347:36 - section and change height to width and
347:38 - now get rid of these so we just have
347:40 - these two lines perfect so let's just
347:42 - print these out to the screen on
347:44 - separate lines just to make sure it's
347:47 - working see the width of 10 and height
347:50 - of 15 we get 10 and 15 Perfect Since
347:52 - that's working okay we can now create a
347:54 - function that can calculate the area
347:56 - forward so we can get static int Cal
347:59 - area and we can have int width and in
348:05 - height and then taking this formula we
348:07 - can simply just do return bracket width
348:10 - times by height / two as you can see
348:13 - this is literally exactly the same as
348:15 - what we've got here it's crucial to
348:17 - include the brackets because we want to
348:19 - do this calculation first take the value
348:21 - of that and divide it by two if this is
348:23 - too many steps you can actually break it
348:25 - down we can say in calculation is equal
348:28 - to to the width times by the height and
348:30 - then we can simply return calculation /
348:33 - two back to the function it's slightly
348:35 - grayed out because we haven't use it but
348:37 - that's not a problem we're going to use
348:38 - it now I personally just to prefer is to
348:40 - keep that inside here and just have the
348:42 - brackets since a bit more obvious to me
348:44 - what's going on but it's up to you as
348:46 - the programmer either way it makes no
348:48 - difference it's just more for the
348:49 - programmer's convenience so now we need
348:51 - to call the function above so we can say
348:53 - in result equals calc area and then pass
348:56 - in the width and pass in the height and
348:58 - then we can have console right line that
348:59 - just says the area is and then result
349:02 - and then let's run it so you have 10 and
349:05 - 15 and there we go we get the area is
349:07 - 75 perfect if you didn't want to call
349:10 - the function inside here and St it
349:11 - inside a variable you could just output
349:13 - this straight to the screen by placing
349:15 - the function calls straight in the cly
349:16 - braces and if you run that again just to
349:18 - make sure 105 and we get 75 again
349:22 - perfect so just a quick little recap we
349:24 - have the console right plus the convert
349:26 - inside this function which will let us
349:28 - return is back an integer and we can
349:30 - pass in the message straight in the
349:31 - variable to make this a little bit
349:32 - quicker and a bit easier you can
349:34 - actually just change this one word
349:35 - inside here so you could actually say
349:38 - enter message call on space and then
349:41 - just inside here you can say height and
349:43 - just inside this one you can say width
349:45 - just to reduce on code because in this
349:47 - specific case the only thing that
349:49 - changes between them two string
349:50 - variables was the fact that one was
349:52 - width and one was
349:53 - height there we go you can see it's
349:55 - exactly the same now so after we read in
349:58 - these two variables we pass it into the
350:00 - function and all the function will do is
350:02 - take width and height times them both
350:04 - together take that value and divide it
350:06 - by two and return it back to the user
350:08 - and then we can call it straight in here
350:09 - the area is calc area and pass in width
350:11 - and
350:15 - height in this task we're going to
350:16 - create a function that will return us
350:18 - back with the sum of numbers inside an
350:20 - integer array so first step is to create
350:23 - an initialize an array of numbers create
350:25 - the function with the int return type
350:26 - and it also takes a int array as a
350:28 - parameter the function should return a
350:30 - total of all the numbers inside the
350:32 - interray call in the main output the
350:35 - total and just for extra bonus points
350:37 - inside the function instead of using a
350:39 - for Loop immediately you can check if
350:41 - the array length is greater than zero
350:43 - and then return minus one if it's empty
350:45 - and then check that inside the main and
350:47 - then output a specific message and also
350:49 - see if you can think of any other
350:51 - implementations you can use instead of
350:53 - having to do return minus one how else
350:55 - can you make this function whether that
350:56 - means you have to change the parameters
350:58 - of return type or anything like that
351:00 - just have a think about the situation
351:01 - and see what other options you can make
351:03 - of course the output at the end is still
351:04 - going to be the same but it's the way
351:06 - you do it and the problem solving skills
351:08 - that I'm trying to get you to get used
351:09 - to let's get started so let's create
351:11 - initialize an array of numbers so you
351:13 - have int numbers equals new int and
351:16 - let's just allocate them manually 1 2 3
351:18 - 4 5 and add a semicolon there we go now
351:21 - let's create the function sum of
351:24 - numbers and we want it to return integer
351:26 - back with the total then we want to take
351:28 - an in Array called
351:30 - numbers and then inside here we need to
351:32 - actually return back an INT so we can
351:34 - create an in total make that equal to
351:36 - zero and at the end we can return total
351:39 - and then during the middle we're going
351:40 - to have to write our for Loop so we can
351:42 - go through the integer array and count
351:43 - through everything so we can use a for
351:45 - each V item inside our numbers and just
351:48 - inside here we can say total plus equals
351:51 - item perfect so if we can call in here
351:54 - we can have a console right line and we
351:56 - can just say sum of numbers and pass our
351:58 - numbers array in the parameters so we're
352:00 - just going to Output it to the screen
352:01 - just for the time
352:02 - being so sum of values from zero all the
352:05 - way till 5 is 15
352:08 - perfect so now that we've done that
352:10 - we've created a function that Returns
352:11 - the total numbers call it in the main
352:13 - output the total so we can just say the
352:15 - total the total is and then wrap this
352:19 - around in the C
352:20 - brace there we go the total is
352:23 - 15 now with the extra points we can
352:25 - check the ray length and return minus
352:27 - one if if the array is empty so let's
352:30 - see what we can do in here before we
352:31 - even end up going inside anything to do
352:33 - with the total we can wrap this around
352:35 - in if statement that says if the numbers
352:37 - do length is greater than zero then we
352:39 - can proceed with this little section so
352:41 - if we highlight all of this hold alt and
352:43 - press upar key then because it's one
352:45 - back just press tab ones and just press
352:47 - the delete key here and let's get rid of
352:48 - the empty Line This is going to return
352:50 - us back with an error because not all
352:52 - code path return a value if this returns
352:55 - back true then we'll eventually hit a
352:57 - return but if this return Z false then
352:59 - we not do anything inside here so let's
353:01 - have a look at our requirements return
353:03 - minus one if the array is empty this
353:06 - dictates whether the rray is empty so if
353:08 - this returns back false then it's going
353:09 - to come into here and we can say return
353:11 - minus one so we've got this function
353:14 - call in here we don't want to print the
353:16 - total right now because we want to make
353:18 - sure that this total is actually greater
353:20 - than zero because we don't want to make
353:22 - a sum of the numbers if the array is
353:24 - empty so if you run this right now going
353:27 - to get the total is 15 and if we get rid
353:29 - of all these variables and just have the
353:31 - length of five but not give it any value
353:33 - so all the values are going to be zero
353:35 - then if we still run that then the total
353:37 - is going to be zero but that's still an
353:38 - acceptable value because that's actually
353:40 - got values
353:41 - inside but if you said the array length
353:44 - is zero then the total is minus one of
353:46 - course we don't want the user to see
353:48 - minus one so we want to bring this back
353:51 - and instead of calling the function
353:52 - immediately down here let's call it here
353:55 - we can say int result is equal to this
353:58 - and then we can say if the result is
354:00 - greater than minus one then we can
354:02 - output the total and again press into
354:04 - this line hold alt and press Arrow
354:06 - key and then we can place the result
354:08 - inside here and the L's to this will be
354:11 - canot add up and empty aray there we go
354:15 - so now if you run it we should still see
354:17 - 15 but if we get rid of this and put it
354:19 - back to
354:20 - zero there we go we cannot add an empty
354:24 - array so we bring that back perfect so
354:27 - now if we check this we've got check in
354:28 - the main output the message and then now
354:31 - we've got this little solution do we
354:33 - need to return minus one how else can we
354:35 - make this so right now we're going to
354:37 - have to return back minus one cuz that's
354:39 - the only way that we can tell the user
354:41 - whether or not it's been successful if
354:43 - the ray is empty we return minus one and
354:46 - if the ray is not empty then we return
354:47 - something greater than minus one which
354:49 - will be something above zero or Zer
354:51 - itself but as long as it's greater than
354:53 - minus one that's how we know it's
354:54 - complete but we don't actually want to
354:56 - do this we want to be ideally returning
354:59 - back a Boolean so let's duplicate this
355:01 - function and show you both
355:03 - implementations let's change this into
355:06 - a and then because we're still going to
355:08 - need to reference the total we're going
355:09 - to have an out in total so we need to
355:12 - change up a few things inside here
355:14 - instead of this return minus one we can
355:16 - do return false to indicate that it
355:18 - hasn't been successful instead of
355:20 - returning back total we can actually
355:21 - just return back true now we haven't
355:23 - done everything yet we don't need to
355:25 - redeclare in total inside because we
355:27 - already declared it inside here so we
355:29 - could just initialize total to equal to
355:31 - zero but the problem here is if we make
355:34 - total equal to zero just within this
355:36 - path then it's still going to complain
355:37 - that total must be assigned so we can
355:39 - take this and just assign it right at
355:41 - the start of the function just like that
355:44 - there we go so we make total equal to
355:46 - zero that gets rid of the compil errors
355:48 - and gives it a value the reason why we
355:50 - have to give it a value is because this
355:51 - out in parameter doesn't like it if you
355:54 - don't assign the value that is a
355:55 - requirement for using the out parameter
355:57 - so make total equal to zero check the
355:59 - numbers length If This Were to return
356:01 - back false then we return false to
356:03 - indicate that we can't do anything if
356:06 - this returns back true it will go
356:07 - through and count all of the items place
356:10 - inside total and then return back true
356:13 - so let's have a look and see what else
356:14 - we can write this little section of code
356:16 - so instead of having to call inside here
356:18 - and use it within there then we can
356:20 - actually do this another way the reason
356:22 - why we actually calling this straight
356:23 - inside here is because we can't place
356:25 - this straight into here since it returns
356:27 - returns us back with an integer and now
356:29 - that is actually fine if that returns
356:31 - back with integer cuz as you can see
356:32 - there's no problems here the issue
356:34 - arises is when we have our result
356:36 - variable we can use it inside the
356:37 - bracket and down here there's no point
356:39 - in calling this twice to get the same
356:41 - value although this would still
356:43 - technically work but this is not really
356:45 - efficient since you calling the function
356:46 - twice it's best to call it
356:49 - once store the value and then make use
356:51 - of it twice when we use our out
356:54 - parameter you'll see that this gets a
356:55 - bit easier so straight inside the if
356:57 - statement we can say sum of numbers and
356:59 - then we can pass in our numbers and then
357:01 - space out into total and what that'll do
357:04 - now is because this returns us back with
357:06 - the bull we don't need any additional
357:08 - conditions like we have one here cuz
357:09 - this will turn us back with a true or
357:11 - false true if it succeeds false if it
357:14 - doesn't so we don't need to say if it's
357:16 - greater than minus one because we don't
357:17 - actually care about the value of the
357:19 - total right now we just care if this
357:20 - returns back with true or false so
357:23 - inside here we can take this same output
357:24 - message and instead of having result
357:26 - here we can have total
357:28 - and then we can take this exact L
357:30 - statement and place it here and let's
357:32 - see what happens now the total is 15 and
357:35 - the total is 15 so they're both return
357:37 - back the same values let's add something
357:39 - else on here just to make sure it works
357:41 - there we go so you can see that both
357:43 - these Solutions look very identical but
357:45 - one is considerably different we have to
357:47 - make a variable outside use inside here
357:50 - and use inside here whereas in this
357:52 - function we can actually just call the
357:53 - function straight inside that will
357:55 - process our new out into total and then
357:58 - we can simply use total inside here and
358:00 - we don't have to require another
358:01 - additional variable just outside here as
358:04 - this one will and you can see that the
358:06 - functions is a little bit better because
358:08 - we're returning true and returning false
358:10 - to indicate whether or not it's been
358:11 - successful whereas in this solution we
358:13 - have to return back an arbitrary value
358:15 - and then check that in the console the
358:18 - reason with returning minus one is kind
358:20 - of a problem is what if these numbers
358:22 - are actually all negative then this
358:24 - value is going to be very bad this can
358:27 - only read work if all of these values
358:29 - are positive if you had negatives for
358:32 - all of these and we tried running the
358:34 - code there you go this is a major issue
358:37 - cannot add up an empty array well it's
358:39 - not the fact that it is empty it's the
358:41 - fact that these values are smaller than
358:43 - minus one so you don't actually want to
358:45 - be going with something like this
358:46 - approach where you're comparing the
358:48 - value because you don't know what
358:50 - numbers are going to be typed into here
358:51 - if the user were type in positive or
358:53 - negative you want to provide a solution
358:55 - just like this one that works for either
358:57 - positive or negative you don't want to
358:59 - restrict that by checking if it's
359:01 - greater than minus one will only works
359:03 - if all of these are positive values all
359:05 - this is an index for the array since
359:07 - arrays start at zero and go upwards you
359:09 - can't have a negative -1 array position
359:11 - but in terms of numbers that are
359:13 - randomly typed inside of a ray you
359:14 - should always be wary of using this
359:16 - option because if some of them are
359:18 - negative then this could return back
359:20 - false so let's just have a quick recap
359:23 - so we have an integer array we have our
359:25 - values initialized down here and then
359:27 - the first solution we call the function
359:29 - pass in the numbers array get our result
359:31 - back check if it's greater than minus
359:33 - one then that means it's been successful
359:35 - so we print it out and else we tell it
359:37 - it's an empty array now second option we
359:40 - actually call the function because it
359:41 - returns back a booly in this case so we
359:43 - can place it straight inside the if
359:44 - statement and then we can pass in the
359:46 - numbers array and then we have it out in
359:48 - total which will give us the total and
359:50 - in this case we don't need to check the
359:51 - value because this returns us back with
359:53 - the true or false and in this case true
359:55 - determines whether it's been successful
359:57 - and false it doesn't if it returns back
359:59 - true then it has some values inside the
360:01 - numbers array that we can actually add
360:03 - up and if it returns back false then
360:04 - that means the array is empty so let's
360:07 - have a look at the implementations so
360:09 - without the out parameters this is the
360:10 - first solution up
360:12 - here we get the numbers length check if
360:14 - it's greater than zero if it's not we
360:16 - return minus one make a new variable
360:18 - called total make equal to zero and we
360:20 - run a for each Loop of our item inside
360:22 - the numbers and we just say total plus
360:25 - equals item add them all up in the for
360:27 - Loop and simply return the total and
360:29 - then in the out solution we have a total
360:32 - equals zero which just initializes this
360:34 - variable otherwise we'll get a compile
360:35 - error then we can say if the numbers is
360:37 - greater than zero then we can say if
360:39 - numbers. length is greater than zero
360:41 - then we can do the for Loop and return
360:43 - back true and if this turn back false
360:45 - then we can say false inside here and
360:47 - then when we use it straight in the
360:49 - brackets we have access to it straight
360:50 - away since it uses a Boolean variable
360:53 - and then our value will be placed inside
360:54 - our out into total parameter which is
360:57 - used down here for the output to the
360:59 - screen and again if this returns back
361:01 - false then it will say cannot add up an
361:03 - empty array and then we hit the console
361:04 - read line and way at the end there we go
361:07 - that covers everything inside
361:09 - here exceptions are used to prevent your
361:11 - code from crashing and then the program
361:13 - closes down let's have a look at a very
361:16 - very common example let's have a console
361:18 - right and we can say enter a number and
361:21 - then we can use int Norm equals convert
361:24 - to int 32 and then we can have a
361:26 - console. readline inside here and let's
361:29 - just print out number to the screen now
361:31 - if we assume everything goes well and we
361:33 - actually enter an integer like 15 and we
361:35 - press enter then we simply get 15
361:38 - returned and as we saw in the past when
361:40 - we covered the trass function if you
361:42 - enter anything else that's not exactly a
361:44 - number then you get again exception
361:47 - exception unhandled unhandled means that
361:49 - we haven't wrote anything specific that
361:51 - will handle this exception so it's
361:53 - causing the program to close it's a
361:55 - system. format exception it says the
361:58 - input string was not in a correct format
362:00 - so this is a format exception because
362:01 - we've entered in a very weird set of
362:04 - characters that can't be converted over
362:05 - to an integer so now our program is
362:08 - forced to crash and now rest of our code
362:10 - is going to be deleted now because it
362:11 - won't be able to run so if you had any
362:14 - important data that was stored just
362:15 - before this point then it is now lost
362:17 - this is very crucial because if you have
362:19 - a system that rides to a database or it
362:21 - stores some very important information
362:23 - that someone's typed in you want to
362:24 - handle the exceptions so if something
362:26 - were to arise it doesn't actually close
362:28 - the program down and they lose all of
362:30 - their data I'm sure you've had it in the
362:31 - past where you've tried to do something
362:33 - and the program comes up in Windows and
362:35 - it says this program had to stop
362:37 - responding when that normally comes up
362:39 - it means that Something's Happened
362:40 - that's so fatal that the program cannot
362:42 - continue it has to crash down and in
362:44 - most cases this is what's called an
362:46 - exception so if we run this code again
362:48 - let's have a look and see what else we
362:49 - can do to make this code break so of
362:51 - course as you heard before a num integer
362:54 - can only survive up to about 2 billion
362:56 - numbers so if we enter a number bigger
362:58 - than that let's see what happens then we
363:00 - get an overflow exception value is
363:03 - either too large or too small for an
363:05 - in32 of course this number is very big
363:08 - and only a long would handle something
363:10 - like this an integer definitely won't so
363:12 - these are the kind of exceptions where
363:14 - you'd have to handle it yourself
363:16 - manually otherwise your program is going
363:17 - to crash coming up next we're going to
363:19 - go through the ways that we can handle
363:21 - these and make sure programs don't come
363:23 - to a halt exactly like these
363:26 - examples
363:28 - I want to explore a technique called TR
363:30 - catch this is very similar to when we
363:32 - use the int. trass what this essentially
363:35 - does is it tries to do something and it
363:38 - lets you know if something went wrong
363:40 - this is exactly the same when we're
363:41 - dealing with exceptions except when
363:43 - we're doing a try catch what the catch
363:46 - means is catching the exceptions that
363:47 - happen and therefore it is now a handled
363:50 - exception instead of unhandled exception
363:52 - so before we try and fix how this works
363:55 - let's just explore the syntax so we can
363:57 - type in try followed by curly brace and
363:59 - just after this curly brace we can say
364:01 - catch then we're going to put something
364:03 - inside the brackets and then we have an
364:05 - opens brackets if you wanted a quick
364:08 - shortcut to this just like we've done
364:09 - the for Loop and we double tap tab we
364:12 - can actually delete this so you can type
364:13 - in try and press tab twice and then you
364:15 - get try the Open brackets you get the
364:17 - exception and then we get throw so let's
364:20 - get rid of this and what we can do right
364:22 - now is we can actually place the Corde
364:24 - that we want inside here inside this Tri
364:26 - bit
364:28 - because we're telling the compiler that
364:29 - we want to try to do the things inside
364:31 - here and then we want to catch these
364:33 - things so inside these brackets what you
364:35 - want to actually do is decide what thing
364:38 - that you want to catch if you type in
364:40 - exception this will catch every single
364:43 - exception now the problem with that is
364:45 - you'll actually face some difficulties
364:47 - when you're trying to Output very very
364:49 - specific messages so as we've said
364:51 - before when you type in a value too
364:53 - large you get an overflow exception but
364:55 - when you type a value that can't be
364:57 - converted like a square bracket then you
364:59 - get an input format exception so first
365:02 - what you actually want to do is run this
365:04 - code outside the try and let's run it
365:06 - now and let's get them bad values so we
365:09 - had the square brackets and we can get
365:11 - this and let's copy it down and place
365:13 - inside a comment just like this and then
365:15 - let's rerun
365:17 - it and if you type a number too big take
365:21 - this stop the program and put it inside
365:24 - here so now that you know what the
365:25 - exceptions are called we can actually
365:26 - write write these inside the code so we
365:28 - have a form exception and an overflow
365:30 - exception but before we get into these
365:32 - specific exceptions let's just catch
365:35 - everything this is just a catch all and
365:37 - then see how this
365:39 - works so as we've put it back inside
365:42 - here let's see what actually happens so
365:44 - we can just put a console right on here
365:46 - and say something has went
365:49 - wrong the reason why something has went
365:52 - wrong is because this is a catch all any
365:54 - exception appears during this code it
365:57 - will always come into here regardless of
366:00 - what the exception is whether it's a
366:01 - format or an overflow it doesn't matter
366:04 - it will always come into here so it's
366:05 - going to be something because this is
366:07 - not specific at all so let's run the
366:10 - code enter very big number something has
366:13 - went wrong but if you notice how the
366:15 - program doesn't actually clash it's
366:16 - still very much alive and we can test
366:19 - this by putting a simple message here at
366:20 - the end that says goodbye and we run it
366:23 - again enter a big number and there you
366:25 - go we get the message as goodbye
366:27 - so it successfully skipped over this
366:29 - section without actually causing an
366:31 - exception that breaks the program so
366:33 - even though we've entered something very
366:35 - fatle because we've handled it then
366:37 - there's no
366:38 - problems so if we now type the other one
366:40 - where we have the square brackets then
366:42 - you'll see we'll also get something has
366:43 - went
366:44 - wrong so if you wanted to catch a very
366:47 - specific exception what we can do is say
366:49 - catch open the brackets and we can say
366:52 - format exception just like it says above
366:54 - here and then place the curry braces and
366:57 - what you can do now is you can actually
366:58 - chain these and these go from top to
367:01 - bottom when an exception occurs up here
367:04 - it will match this one if it doesn't
367:05 - match it will match this one and you
367:08 - want to put the catch all right at the
367:09 - end so if it doesn't match any of the
367:11 - ones above it it will always match the
367:13 - last one so you can have a generic
367:15 - message inside here but you can have a
367:17 - very specific message inside here
367:19 - because it's a format exception you can
367:21 - say please only enter numbers so now if
367:24 - we run the code and if we type in square
367:25 - brackets it'll say please only enter
367:28 - numbers there we go so this is a very
367:30 - specific example and if we copy and
367:32 - paste this down again and then we can
367:34 - say overl
367:35 - exception and we can say please enter a
367:39 - number less than 2
367:43 - billion if you enter a very big number
367:45 - again please enter a number that's less
367:48 - than 2 billion
367:50 - perfect so this will get checked like if
367:52 - statements it will start on the first
367:54 - one and go down the list imagine this is
367:56 - a if and then we have an lse if and then
367:58 - lse if as well if you place this one
368:00 - right at the start then you're actually
368:03 - going to get compile errors and you
368:05 - can't actually have the catch all right
368:07 - at the start so even if you wanted to
368:09 - the compiler literally doesn't let you
368:11 - and anyway you don't really want to be
368:13 - doing that because then you'll be ruling
368:14 - out these two and it's kind of pointless
368:16 - writing this code if it's never going to
368:18 - get used anyway so now when we run the
368:20 - Corde you can see even if we type in a
368:21 - bad value our program will still run and
368:24 - everything works okay so now what we can
368:26 - do is actually make this into a real
368:28 - life
368:29 - situation so if we actually type in 10.2
368:32 - that it says please only enter numbers
368:34 - then we're going to have an issue here
368:35 - because if we try and print the value
368:37 - down here then it's going to cause a
368:39 - problem let's try and print out num and
368:41 - you can see that num does not exist now
368:43 - we have an issue of scope int is only
368:45 - declared within here and here so if you
368:47 - wanted to print out the value of gome
368:49 - we'd have to print it out up here so now
368:51 - let's run it again and if we enter 20 20
368:53 - comes up if we've entered 15.5 then
368:56 - actually skips over this console right
368:58 - line because the exception occurs right
369:00 - here and then it'll jump into one of
369:02 - these paths so in order to store the
369:04 - value of num you can either move num
369:06 - outside here and make it equal to zero
369:08 - and then assign num inside here and then
369:11 - you can take this console right line and
369:13 - actually put it right after the triy
369:14 - pass but I don't really suggest this
369:16 - option so if you said 15.5 then you're
369:19 - just going to get zero returned but we
369:21 - don't really care about the zero because
369:23 - we're not going to get the value
369:24 - converted so why do we need to print the
369:26 - zero and the answer is we don't so what
369:29 - we should do is keep it all inside here
369:34 - again and then what we should do instead
369:36 - is wrap this around in a while loop so
369:39 - this will try to do the code this
369:41 - section will catch them all and then we
369:43 - simply have a good buy at the end but
369:45 - let's just make sure that this actually
369:46 - runs because if we type in
369:49 - 15.5 then the user still hasn't entered
369:51 - the number but our program is closed so
369:54 - we want to loop around until the user
369:56 - has success successfully enter a correct
369:58 - number so we can say bull looping equals
370:01 - true and we can have while the chord is
370:04 - looping then we can have the curly
370:05 - braces let's place our entire Tri cut
370:08 - inside here if we highlight it all hold
370:11 - alt and press the op power key and then
370:13 - tab it once and then get rid of this
370:14 - empty line so now we'll keep looping
370:17 - around here until this is going to be a
370:19 - different value so because the while
370:21 - loop will only keep looping until this
370:23 - is true and the moment when it's false
370:25 - is when it will cancel while loop so as
370:27 - I said before it when we run this code
370:30 - and then just at this specific line if
370:32 - the exception occurs it will actually
370:33 - skip this line and jumped below here so
370:36 - if it ski this line then what we can
370:38 - actually do is we know if it reaches
370:40 - this line then the conversion is been
370:42 - successful so we can print out to the
370:44 - screen and we can say looping equals
370:46 - false and we don't need to place looping
370:49 - is equal to True inside all of these
370:51 - three paths because if we don't assign
370:53 - it to true then it's still going to be
370:55 - the value false no matter how many times
370:57 - you loop around so let's try and run
370:59 - that
371:01 - now enter a number 15.5 enter a number
371:05 - 15 and we can keep doing this forever as
371:08 - it's a while loop and as soon as we
371:10 - enter a valid character 20 and now it
371:12 - says goodbye because we hit the end of
371:14 - the
371:15 - program so that's it for this video but
371:17 - let's just have a little recap so we've
371:20 - determined when we run our code just
371:22 - these two lines that in both situations
371:24 - we can have a format exception and it
371:26 - all overflow exception we can use these
371:28 - to catch them specific exceptions and
371:30 - then have a catch all at the end the
371:32 - reason why you want to catch multiple is
371:34 - you can have a very specific message
371:36 - overflow dictates we have a number
371:38 - that's too big or too small to fit
371:40 - inside of an integer it can be less than
371:42 - -2 billion or can be greater than 2
371:45 - billion and that's how you get the
371:46 - Overflow exception we get him a format
371:49 - exception if you entered something
371:50 - that's literally not a number or
371:52 - something that has decimal places and
371:54 - then I'll catch all can be if anything
371:55 - else goes wrong we can output a generic
371:57 - message but in 99% of the cases you'll
372:00 - either enter a number too big or too
372:02 - small or it's in the wrong format and
372:04 - this exception is just so it catches
372:06 - everything else should anything else
372:08 - happen so at this point even though our
372:10 - program doesn't actually close and
372:11 - there's no exceptions the user hasn't
372:13 - had a chance to enter the number again
372:15 - so we use this inside a while loop and
372:17 - we can say while looping is true when we
372:19 - hit a conversion that's successful we
372:21 - say looping is equal to false and once
372:23 - it hits this line the Y Loop will then
372:25 - exit and then we'll get our good goodbye
372:26 - message and we wrap the entire TR catch
372:29 - inside the W Loop just so this keeps on
372:31 - looping until the user has typed in a
372:33 - successful value as demonstrated
372:37 - above we can type all this and 15.2 15
372:41 - Point 15 and then finally says 15 and
372:45 - then
372:47 - goodbye so I want to explore different
372:49 - ways you can output messages inside this
372:51 - catch block when you have a catch
372:53 - exception this is actually a parameter
372:55 - that we're passing in this parameter can
372:57 - actually have a variable as well
372:59 - normally when you specify parameters in
373:01 - a function form you say int and then
373:06 - something whereas right now we're kind
373:08 - of defining the data type which is our
373:10 - exception in the same case as in in here
373:13 - but we're actually not giving it a name
373:14 - so it looks something like this of
373:15 - course when we do this inside a function
373:17 - we're going to get a syntax error but
373:19 - for a catch we're not going to get any
373:21 - errors at all and the reason is because
373:22 - we can catch without having to use a
373:24 - local variable so we actually add a
373:26 - local variable make you call it e for
373:29 - exception then we actually have lots of
373:31 - options inside here Type e then we have
373:33 - lots of data and the stack Trace is very
373:35 - helpful when you debuging but we'll
373:37 - cover that at a later date the thing I
373:38 - want to focus on right now is the
373:40 - message so we can use this and print out
373:42 - to the screen so we can say error callon
373:46 - and then type in E message and let's run
373:49 - that now if you enter something invalid
373:52 - input string was not in a correct format
373:55 - if you enter big number then value is
373:58 - either too large or too small for an
373:59 - in32 as you can see these error messages
374:02 - are pretty descriptive and normal users
374:04 - should be able to read this and
374:06 - understand it of course if you want this
374:07 - error message to be more specific then
374:09 - you can add some more catches inside
374:11 - here and we can have format
374:14 - exception this will be if you type in
374:16 - something other than number but if you
374:17 - do exactly the same thing in here then
374:20 - it's kind of redundant because you're
374:21 - just outputting exactly the same value
374:23 - if we try to put the square brackets
374:25 - again then we're going to get this this
374:26 - string which is actually outputed from
374:28 - this line but even if we include the
374:30 - catch all exception you get exactly the
374:32 - same error message outputed from here
374:35 - the moral of the story is you should
374:37 - always have a catch all right at the end
374:39 - of your chain but if the only thing
374:41 - you're going to do inside here is simply
374:43 - output this message to the screen then
374:45 - you don't need any multiple catches what
374:47 - you should do is catch multiple
374:49 - exceptions that you know are going to
374:50 - get fired in your code and then you want
374:52 - to handle them and then have a catch all
374:54 - at the bottom that will display the
374:55 - message generically instead of
374:57 - displaying the message right here you
374:59 - can actually have a more specific
375:00 - message like we covered in the last
375:01 - video so this could be please only enter
375:05 - numbers and we don't actually need the
375:07 - message in this case because we know
375:09 - what exception we're going to catch
375:10 - because we've specified format exception
375:13 - another little tip if you hover over the
375:15 - function call it says here format
375:17 - exception and overfall exception which
375:19 - is the two that we handled in the
375:20 - previous video this is very easy and
375:23 - understandable if you can just read the
375:24 - values from here into see what
375:26 - exceptions can get raised and the same
375:28 - thing here you get an IO exception for
375:30 - the console right line the console right
375:32 - can also give back an IO exception as
375:34 - well generally speaking these console
375:36 - functions almost never return back
375:38 - exceptions I don't think I've ever hit a
375:41 - situation where this exception has been
375:42 - returned unless you do something
375:44 - ridiculous and maybe you type in way too
375:46 - many values that the console right line
375:48 - can handle let's try an example and we
375:51 - can do something like this if you enter
375:52 - a very big number that can't be
375:54 - specified inside an integer then console
375:56 - right line has so many overloads that it
375:58 - actually processes it as a long right
376:00 - now so you almost can't break this
376:02 - unless something fundamental to your
376:04 - computer actually happens so you have
376:06 - exception e and with exception e you can
376:09 - actually take this local variable and
376:10 - print out the message this is the
376:12 - preferred pattern because instead of
376:14 - outputting here something went wrong
376:16 - just very generically you can actually
376:18 - give them the error message that comes
376:19 - back from the exception the reason why
376:21 - this is helpful is because if it doesn't
376:23 - hit any of these exceptions and it just
376:25 - happens to fall into the catch all at
376:27 - least the user has an idea of what the
376:29 - error message is going to be the
376:31 - preferred option is to try get to a
376:32 - point where you never have to reach the
376:34 - catch all and try chain as many catches
376:36 - as you can in order to handle as many
376:39 - exceptions based on the code that you're
376:40 - writing which can be found if you hover
376:42 - over the function and read the
376:44 - exceptions once you've covered as many
376:46 - options as you can throughout the
376:47 - catches then you almost never have to
376:49 - worry about the code entering this
376:51 - section because we've covered both the
376:53 - exceptions in format and overflow and we
376:55 - can do overflow right now please enter a
376:58 - value under 2
377:00 - billion then that means we've actually
377:02 - covered all of the catches that are to
377:04 - do with converting in integer 32 covered
377:07 - format and covered overflow so when we
377:09 - run this code the only two things that
377:11 - can possibly go wrong are these two
377:12 - functions the format exception overflow
377:15 - exception and we won't ever hit the
377:17 - catch all in this case but if anything
377:19 - goes wrong at least we have a belt and
377:21 - Brace option to catch it and we can tell
377:23 - the user what happened and because it's
377:25 - e. message then the value is going to be
377:27 - quite descriptive so the user can read
377:28 - it without any
377:31 - problems so in this task we want to be
377:34 - able to convert a string to an in
377:36 - successfully without any errors
377:37 - occurring and without any exceptions
377:39 - that could break our code so in steps we
377:41 - want to create an INT and try and
377:43 - convert any string from the console to
377:45 - an integer notice the error that appears
377:47 - when you try to do that write a try
377:49 - catch Handler around it to successfully
377:51 - operate that and output the message to
377:52 - the screen and you won't need to change
377:55 - the console out print and convert in 32
377:58 - to be able to make this work so you
377:59 - don't want to change the current code
378:01 - you just want to add the Trion Handler
378:03 - around it so why is this a bad situation
378:05 - how can we know if it's been converted
378:08 - this is just a question that you should
378:09 - keep at the back of your head and we'll
378:10 - answer this shortly and then finally we
378:13 - want to create a custom trip pass
378:14 - function find the real trip pass
378:16 - function and copy the return Titan
378:18 - parameters and see if you can mimic Its
378:20 - Behavior read the tool tip it gives you
378:22 - to give you ideas on what to do so let's
378:24 - take these in steps first first we can
378:26 - have a console right and say enter a
378:28 - number and then int num equals convert
378:31 - to in 32 and then we need a console read
378:35 - line and then if you run the
378:38 - code if we try and just convert some
378:41 - square brackets then we get a format
378:44 - exception so that's the exception that
378:46 - we're going to be handling right now so
378:48 - we can take this code and we can wrap it
378:50 - around in a
378:51 - try use alt and up Arrow key and then
378:55 - just have to do a c and then we want to
378:56 - do a format exception and then space e
378:59 - to give it a variable and then we do e.
379:01 - message out to the screen and now let's
379:03 - run the code square brackets input
379:06 - string was not in a correct format so we
379:08 - get our message and our exception has
379:09 - been successfully handled and our
379:11 - program hasn't crutched but the problem
379:13 - is is has got to this console read line
379:15 - and the user hasn't had a chance to
379:17 - actually enter a number so what we can
379:18 - do in here to ensure the user always has
379:21 - access to writing a number is we can say
379:23 - something like this bu success equals
379:26 - false and then just after here we can
379:28 - say success equals the
379:30 - true and just down here we can say
379:33 - console right line success question mark
379:36 - yay and then call on or
379:40 - no so if it convert it 15 we should get
379:43 - a yay and if we convert it and it fails
379:45 - then we should get an o no along with
379:47 - the message of course what you can also
379:50 - do is wrap this entire section inside a
379:52 - y Loop what we've already covered that
379:53 - inside the tutorial and that means we
379:55 - keep repeating this until this is set to
379:58 - true and therefore exit the while loop
380:00 - and then will the users finally typed in
380:01 - a number so let's go back so we've
380:03 - noticed an error and we've wrot a tri
380:05 - catch handle around it now we want to
380:06 - catch the error and output the error
380:08 - message with through done and then we
380:09 - haven't changed the current code which
380:11 - was these two lines we've added a the
380:13 - booing and set it to True here just so
380:15 - we can have a bit of an output message
380:16 - before so why is this a bad situation
380:18 - how can we know if it's being converted
380:20 - so this code is a bad situation because
380:22 - we just have these two lines outputed
380:25 - and then now that you've added our
380:26 - booing to tell the user whether it's
380:27 - been successful or not is actually
380:29 - making it a bit more meaningful the
380:30 - problem is even if we print or no then
380:33 - the user doesn't really have a chance to
380:34 - enter it again so like I said before you
380:36 - could loop around and use a while loop
380:37 - to make sure that this situation can go
380:40 - from something that gets handled into a
380:42 - situation where the user can actually
380:43 - type it in there's no point hand on
380:45 - exception and realizing there's error if
380:47 - you don't give the user a chance to
380:49 - enter another value if they enter out 15
380:51 - Follow by full stop when they only meant
380:53 - to type 15 then you need to give them
380:55 - another chance to type in that 15 value
380:58 - otherwise the program is simply just
380:59 - going to end and nothing's going to
381:01 - happen for example 15 DOT it says oh no
381:05 - or you can have another message that
381:06 - says something went wrong or you can
381:08 - have more specific message about the
381:10 - conversion and then once you press enter
381:11 - the program simply closes this is not an
381:13 - interaction that you want you want the
381:15 - user to be able to reselect another
381:17 - value so that's why it's a bad situation
381:19 - because you know it's been converted or
381:21 - not use now Bill success but the problem
381:23 - is we don't have any sort of looping so
381:26 - let's have a look so now let's comment
381:28 - out this and let's see how we can make
381:29 - our custom trip pass so we type in in.
381:32 - trass you can see they have a Bo inpass
381:35 - string s and out in result so let's try
381:38 - and copy that and make our own custom
381:39 - function so we say static Bull and then
381:42 - it's trass and then we have a string
381:45 - input and out end
381:49 - result perfect so now we can get rid of
381:51 - this line just so we use it for
381:53 - reference and let's use it straight in
381:54 - here and then we can write the
381:55 - implementation in a second so we can say
381:57 - if try pass the thing that we want to
382:00 - pass is actually a console read line and
382:03 - then we just say out into
382:06 - result and the console read line is
382:08 - going to be answered to this question
382:10 - which is enter a number we place it
382:12 - straight inside here and then we say out
382:13 - in result so if this has been successful
382:16 - we can print out yay again and else if
382:19 - it's not successful we can print out or
382:20 - not of course you can do other things
382:22 - inside here or you can even print out
382:24 - the value straight from here so we can
382:26 - say yay plus a space and then result
382:29 - just so we can get that back to the user
382:30 - and then oh know if something goes wrong
382:32 - of course this is just so we can test
382:33 - things and see how they work so this
382:35 - trass function it will take in a string
382:38 - input and it will try and give us back
382:40 - the result so in order to be able to
382:42 - make this successful function what we
382:43 - need to do is essentially do the
382:45 - conversion ourself which will be this
382:47 - convert in 32 so first we need to assign
382:50 - this out int so we can say result equals
382:53 - minus1 so now that we've used that we
382:54 - actually need to have return type as
382:56 - well but let's worry about that in a
382:57 - second so essentially what we actually
382:59 - want to do is say that the result is
383:02 - equal to convert to in32 and then we
383:04 - want to convert the input store it
383:06 - inside the result and if this goes
383:08 - successful then we want to return true
383:10 - and if it doesn't go successful then we
383:12 - want to return false but of course we
383:14 - need to be able to do these things
383:15 - separately so like we said with the try
383:18 - you only wrap around the section of
383:19 - which is going to be problematic so in
383:22 - this case as we've done here we've
383:23 - wrapped the convert in 32 inside the try
383:26 - so we're going to need to do that down
383:27 - here as well so we can open the try
383:29 - right here and place these two lines
383:32 - inside and then have a catch have a
383:35 - little think about what sort of catch do
383:37 - we need the whole point in this function
383:39 - is to Simply convert value and return
383:41 - back whether it's been successful or not
383:43 - there is no messages here we just need
383:46 - has it been successful yes or no and
383:49 - because we only need to know if it's a
383:50 - yes or a no then we can just have a
383:52 - generic exception and we don't need the
383:54 - E variable because we're not going to
383:56 - access the message we're going to keep
383:57 - it as an exception and instead of
383:59 - returning false down here we actually
384:00 - want to do this straight inside the
384:02 - catch so now the code reads like this we
384:05 - set the result to minus one and the
384:06 - reason why we do that is because if we
384:08 - don't then we're going to get a compiler
384:10 - error and it says that not all paths
384:12 - were going to assign result
384:13 - alternatively we can also assign result
384:15 - straight inside here just so we have an
384:17 - assignment in both paths or you could
384:19 - just leave it outside at the top so we
384:21 - assign result to minus one and then we
384:23 - place our problematic code straight
384:24 - inside here we try and convert the
384:26 - result and if this line returns back
384:28 - successful then it's going to execute
384:30 - the second line and return back true if
384:32 - this line returns back an exception it's
384:34 - going to miss this line completely and
384:36 - jump straight into the exception and
384:38 - then return us back with false so let's
384:40 - actually try this and see what happens
384:42 - 15 DOT or no and then 15 yay 15 so the
384:48 - reason why we don't care about the
384:49 - exception in here we can add in
384:51 - different values as we've used before
384:53 - with format exception overflow exception
384:55 - but as we saw with triy pass it simply
384:57 - just returns us back with the bull the
384:59 - bull simply tells us if it's been
385:01 - successful or not so we could stack
385:03 - these multiple times we can say catch
385:05 - and then we have the format exception
385:07 - and then we can place a return false in
385:09 - there and then we have another catch for
385:11 - the Overflow exception and we can place
385:13 - another return false in there but as you
385:15 - can see we're just returning false
385:16 - inside here so now that we've changed
385:18 - these it's kind of pointless each of
385:20 - them return back false and because we're
385:22 - not doing anything very specific we
385:24 - don't actually need to change them all
385:25 - together we don't care about the message
385:28 - we don't care the exception we only care
385:30 - about the fact that something has went
385:32 - wrong and if something has went wrong
385:34 - then we turn back false if everything
385:36 - goes okay then we return back true and
385:38 - that's all this Tri pass function is
385:40 - going to need to do it simply converts
385:42 - it or it doesn't convert it using an
385:44 - input and outputting a
385:46 - result so if you run it weet type in a
385:49 - real number we get a number back and
385:51 - then 15 DOT zero then we get all no
385:54 - because it can't come it there we go
385:56 - we've met all our requirements for this
385:59 - program let's have a look at how we can
386:01 - do debugging using visual studio to step
386:04 - through our code manually so this is the
386:06 - example I used last time int age equal
386:08 - 35 and ideally in this case you'd want
386:11 - something like 30 plus to be printed
386:13 - instead of 18 plus even though 18 plus
386:15 - is still technically true we'd still
386:17 - like 30 to be printed in this case
386:19 - because this says if it's over 18 do 18
386:22 - if it's over 30 do 30 plus so in order
386:24 - to start the debugging process you
386:26 - shouldn't run the code first if you run
386:28 - the code first it's going to execute so
386:31 - fast that you won't get a chance to
386:32 - actually put any code in and try and
386:34 - debug it there we go we've already hit
386:36 - the console read line and it's executed
386:38 - for a split second so the best thing to
386:41 - do just to the left of the line numbers
386:44 - you want to press in the Gap and that
386:46 - will create a red dot and it'll tell you
386:48 - that this is a debugging Red Dot just in
386:50 - this little tool tip debugging do
386:52 - program. Min debuging program
386:55 - main so it tells us we're in the program
386:57 - class and we're going inside the main
386:59 - you can also address the debug menu up
387:01 - here and it says we can have a toggle
387:03 - break point we can add new one we can
387:05 - delete them all or we can actually
387:06 - disable deleting them will just simply
387:09 - get rid of them as you can see here if I
387:11 - set a couple more and press disable then
387:14 - it's going to hide them so whenever we
387:16 - run our code it doesn't actually apply
387:18 - the debugging but it doesn't delete them
387:20 - and then we can enable them and then we
387:21 - can also delete them all and it gives
387:23 - you a little prompt because if you do
387:25 - doing this inside a big project and you
387:26 - just spent a lot of time going through
387:28 - and debugging certain functions then you
387:30 - don't want to be able to delete them all
387:32 - without any confirmation so let's delete
387:33 - them all and put it back on line 13
387:35 - which is our int Edge so let's run the
387:38 - code and see what happens so as you can
387:40 - see it minimizes our console for us and
387:42 - nothing's actually been printed yet
387:43 - because we're only up to this line and
387:45 - then we can use these buttons up here
387:47 - step into goes inside a function step
387:51 - over goes over the line so it will go
387:53 - from this line to this line step out is
387:56 - used after you've stepped in if you
387:58 - stepped into a function and then you
387:59 - don't want to see the rest of the
388:01 - function executing you can step out to
388:03 - jump back out of it which I'll
388:04 - demonstrate later on in this video so
388:06 - now that we've hit this line you can
388:08 - actually see what's going on so we have
388:09 - in age equals z because when this line
388:12 - is highlighted it means this line hasn't
388:14 - executed just yet so we can press this
388:17 - or we can press F10 on our keyboard if I
388:20 - press F10 you can now see in age has the
388:23 - value of 35 and what you can actually do
388:25 - is double click on it and just change
388:26 - the value to 30 for example now if you
388:28 - highlight you can see the value is 30 so
388:30 - you need to double click change the
388:32 - value to something and then simply press
388:34 - enter if you change the value but leave
388:36 - the box like this then it won't change
388:38 - the value so you have to remember to
388:39 - press enter so now I've made the age 40
388:42 - but let's just change it back to 35 to
388:43 - keep it the same and then now what we
388:45 - can do we can explore what's going on
388:47 - here if age is greater than 18 then
388:51 - we're going to check if this condition
388:52 - is true or false so in order to check if
388:54 - this returns back true or false you can
388:56 - actually hover over the operator and it
388:58 - says here AG is greater than 18 is equal
389:00 - to true and if we hover over this one it
389:03 - says age is greater than 30 is equal to
389:05 - True notice what we actually did there
389:07 - we essentially ran this condition
389:09 - through the debugger without actually
389:11 - reaching this line we're only up to line
389:13 - 15 as of right now but we've managed to
389:15 - execute this and give us back a function
389:18 - so as you can see age greater than 30 is
389:20 - true and age greater than 18 is true and
389:23 - because this is L if chain it only cares
389:26 - about the first one that turns back true
389:28 - and because this one has turned back
389:29 - true then if you press F10 again you'll
389:32 - see that now it's went inside this curly
389:33 - brace which will print out the console
389:35 - right line if I press F10 again you can
389:38 - see we're now waiting on here if I use
389:40 - alt tab I can get back to the console
389:42 - you see that 18 plus has now been
389:44 - printed now that we're waiting here we
389:46 - actually press F10 one more time and
389:48 - then it jump straight to this read line
389:50 - of course because this is L if chain as
389:52 - soon as one of these become true and it
389:54 - jumps over the lse if because of course
389:56 - this is a chain the first one it hits
389:59 - that's true it skips over the rest if we
390:01 - didn't want this to be a chain then we
390:03 - could keep them as both independent if
390:05 - statements if age is greater than 18 and
390:08 - if age is greater than 30 and don't use
390:10 - the lse keyword but in this case because
390:12 - you do want to Output a different
390:13 - message for every single age range you
390:15 - do want to place the L's word in there
390:17 - and now that we've hit this line we can
390:19 - press F10 and then now we jump back in
390:22 - the console and now we're wear in right
390:23 - here and just a little tip when it comes
390:26 - to debugging if at any point you just
390:28 - want to exit the debugging you can
390:29 - either press continue or just press F5
390:32 - and the program will run for example if
390:35 - we investigate this variable and we can
390:37 - see the value is 35 and then now we're
390:40 - happy with the rest of the code we can
390:41 - just press F5 and our code will run as
390:44 - normal we'll get the out print and we'll
390:46 - get a read line waiting here so we know
390:49 - our problem here is both conditions
390:51 - return back true so just like in the
390:52 - last video we actually changed this
390:54 - condition
390:55 - so to make sure that it only goes
390:56 - between this range but let's not repeat
390:58 - ourselves let's have a look at a
390:59 - different example so we can have string
391:01 - name equals Abu and then int age and
391:05 - then age equal 23 which I'll demonstrate
391:07 - why I've done it like this in a second
391:09 - and then let's have a function just so I
391:10 - can show you how to step in so we can
391:13 - have a static string print details
391:15 - string name in
391:17 - Edge and here actually we want to just
391:20 - return back a void because we just want
391:22 - to print out to the screen and we can
391:23 - say name space edge and maybe just put a
391:27 - dash between them and let's run that
391:28 - code now we can see ABA
391:31 - -23 of course making that function
391:33 - wasn't the point I actually want to show
391:35 - you what's going on so if we just print
391:37 - this a couple of times just so we can
391:38 - show you the step out and step in so you
391:40 - run the code now we can see our string
391:42 - name if we go over that you can see it's
391:45 - called abber and then now that it's
391:47 - stepped over this line cuz there's
391:48 - nothing really to execute here it's just
391:50 - creating back a variable so you can see
391:52 - that age is zero cuz that's the default
391:53 - value for an integ
391:55 - and when we skip over that now it's got
391:56 - the value of 23 so one line creates the
391:59 - integer with the default value equal to
392:01 - zero and then the next line will make it
392:03 - equal to 23 and then we're passing on
392:05 - the variables here and if you wanted to
392:07 - investigate it you could simply just
392:08 - hover over them like this so you can see
392:10 - what the values contain and then now
392:12 - that we've hit this function if we press
392:14 - F10 then it's just going to skip over it
392:17 - but what we actually want to do is be
392:19 - able to go inside the function so this
392:21 - is where our step in goes step over
392:24 - doesn't doesn't care if it's a function
392:25 - or a normal line it'll just step over it
392:27 - regardless so we want to in here we want
392:30 - to use step into or we can press f11
392:33 - once you press for f11 you can see that
392:35 - now it's jumped from print details up
392:37 - here to print details down here and then
392:39 - now look if I step through it's going to
392:41 - actually execute these one by one so
392:44 - right now it hasn't executed anything so
392:45 - I step over this once using F10 you'll
392:48 - see it now appears and then the same
392:49 - thing with this one and this one and now
392:51 - that I've executed three we should see
392:53 - three in the console perfect so now what
392:56 - I want to demonstrate is let's say we're
392:57 - happy with the rest of this function and
392:59 - then now we want to just step out so I
393:01 - press this button and you can see it
393:03 - jumps back up to print details f11 to go
393:06 - in and then shift f11 to go out so now
393:09 - that we're back in here the only thing
393:11 - we can do really from this point is
393:12 - either press F5 to stop debugging or
393:15 - press F10 to jump to this line and at
393:17 - this point we've already hit the last
393:18 - line now code so we don't really need to
393:20 - use F10 anymore cuz with nothing to step
393:22 - over so we can just press F5 let our
393:25 - program finish and there we go so let's
393:27 - have a look at another example can have
393:29 - a string message equals read from
393:31 - console then we can pass this in enter
393:34 - anything and then we can have a console
393:36 - right line and we can just print the
393:37 - message and then let's create this
393:39 - function so because it's a return value
393:41 - and store inside a string we're going to
393:43 - need a static string read from console
393:47 - and then this is one string parameter so
393:49 - we have a string
393:53 - message
393:55 - and then we can just do a console
393:57 - right and then print the message to the
393:59 - screen and then we just want to return
394:01 - the console. readline there we go and
394:05 - again let's put a breakpoint here and we
394:07 - can remove this one so it doesn't always
394:09 - have to be the first line if we're
394:11 - perfectly happy with this amount of code
394:13 - then we can simply take that off and it
394:15 - will stop when it gets after this
394:18 - line now if you look at the console
394:20 - you'll see all of this is executed that
394:22 - function is executed four times to print
394:24 - the name name and age of the screen and
394:25 - now we're waiting here so we have our
394:27 - read from console and now we can step
394:29 - into using f11 and you can see that if
394:32 - you hover over string message has enter
394:34 - anything which is our parameter that we
394:36 - specified up here and then there you go
394:38 - and then that will print into the screen
394:40 - so you tap back in you'll see it says
394:41 - enter anything and then just at the read
394:43 - line we need to actually enter it
394:45 - now
394:47 - something and then press enter and then
394:49 - just right here it's going to return it
394:51 - back so if we use F10 it jumps back in
394:54 - here
394:54 - and then actually we need to execute
394:56 - this line so F10 again and then if you
394:58 - hover over a message you see it says
395:00 - something which is exactly what we typed
395:02 - in the console here and then we just
395:04 - print it back to the screen there you go
395:07 - and now we just at the console read line
395:08 - and we can press F5 to finish up there
395:11 - we go so debugging is mainly used by
395:13 - pressing this button on the side so
395:15 - debugging is used by pressing on the
395:17 - empty Gap just to the left of the line
395:19 - number and it will create a red dot once
395:21 - you create a red dot it'll highlight
395:23 - this for you once you've clicked done it
395:24 - it should show up a red dot you can also
395:26 - disable or delete all the break points
395:28 - from the debug window at the top of the
395:29 - screen when you run the code it will
395:31 - stop here and then you can either use F9
395:34 - as a shortcut as well click into the
395:35 - line that you want to debug and press F9
395:37 - please note there is specific cases
395:39 - where if you try and press this one
395:41 - right here it's not going to let you if
395:43 - the line doesn't really do anything for
395:45 - example this is creating an integer
395:47 - there's no real action that's happening
395:49 - here that you should or want to debug
395:52 - this is an assignment this is an
395:53 - assignment this is a function call and
395:55 - so on and so forth and this is also a
395:57 - function call when it comes to just
395:59 - declaring variables then a compiler does
396:01 - not let you put in a breakpoint because
396:04 - there's nothing really to investigate
396:06 - when you're just creating a variable so
396:08 - don't get thrown off or think
396:09 - something's wrong if you click on the
396:10 - empty line and nothing appears so that's
396:12 - it for debugging but let's just have a
396:14 - little recap we can use F10 to step over
396:18 - f11 to step into functions shift f11 to
396:21 - step out or you can use the buttons that
396:23 - appear at the top of the screen when you
396:25 - run the code just right
396:28 - here hover over variables and you get
396:30 - their values as I showed you in the if
396:32 - statements if you hover over the
396:34 - operator inside the if statement it will
396:36 - actually tell you what the condition is
396:38 - and whether it's true or false so me say
396:39 - if1 equals equals to 1 and let's just
396:42 - print out true to the screen just so I
396:44 - can demonstrate
396:46 - this if a hover r that equals equals it
396:48 - says 1 equals equals 1 is
396:53 - true
396:54 - so that's how you check if a condition
396:56 - is going to be true or false when you're
396:58 - debugging you can check the parameter
397:00 - values by simply hovering over it and
397:02 - the tool tip should include the
397:05 - value just like so and if you wanted to
397:08 - step into this function you can use step
397:10 - into and then use step over which is F10
397:14 - just here and then you can actually
397:16 - investigate these values as well or you
397:18 - can look at the parameters and once
397:19 - you're done with the function you can do
397:20 - shift f11 or you can use step out and
397:24 - then you can skip over this and the same
397:26 - thing with this you can have a look at
397:27 - the string variable once it gets
397:29 - returned something in
397:31 - here and now it says something in here
397:33 - and string message and then we can print
397:35 - out to the screen Etc so you can have a
397:37 - little bit of Freedom with what you can
397:39 - do in terms of debugging play around to
397:41 - debuging in the past exercises that
397:43 - we've made together and then what you
397:45 - can actually do is gain experience in
397:47 - debugging so it comes to more
397:48 - complicated projects you can also apply
397:50 - that learning there and make sure that
397:52 - your code is error free
397:56 - so we covered how to debug by pressing
397:58 - the white space just to the left of the
398:00 - line number if we run the
398:03 - code the program will stop where our
398:05 - breakpoint is and it won't execute the
398:07 - line that we're up to we have to step
398:09 - over it so we've actually use this
398:10 - before to analyze our functions and see
398:13 - what values are inside things so we have
398:15 - these extra windows called the local and
398:17 - the auto so let's take a look at them
398:19 - and see what they're about so again if
398:21 - you don't have this layout you can use
398:23 - window reset layout and it should be in
398:25 - the left panel not the right one this
398:27 - time so we've got watch which we'll
398:29 - explore later and we're going to have
398:31 - locals and Autos so the autos because
398:34 - we're up to the age then it shows us the
398:36 - age has value zero and then that
398:39 - prevents us from hovering over it and if
398:41 - we step over it you'll see that now it's
398:42 - got age 23 and now name has appeared the
398:46 - auto tab will try and figure out what
398:48 - functions and what parameters you need
398:50 - to be displayed down here based on the
398:53 - section of cord that you up to so my
398:55 - guess is because we're up to this
398:56 - function and it takes in a name and age
398:59 - then we're getting name and age
399:00 - appearing before when we were on this
399:02 - line it was only showing back the age
399:04 - and because that section only used the
399:06 - age we only got age here but if you
399:09 - press locals you can see all the
399:10 - variables that are local to this main
399:12 - function are actually showing up we have
399:14 - a parameter called ARs and technically
399:16 - this is a parameter and it's a string a
399:18 - ray type but it's currently unused but
399:20 - it's still a parameter so you can see it
399:22 - down here and then in order we have have
399:24 - the name variable down here then we've
399:26 - got the age and then we've got the
399:27 - message which is currently said to know
399:29 - because we haven't created this in
399:31 - memory yet but as you can see this
399:33 - changes depending on the scope of our
399:34 - variables so now that we're about to hit
399:36 - this function let's use the step into
399:39 - and you'll see that the locals have now
399:41 - changed we've got rid of name age
399:43 - argument and string message and it's
399:45 - replaced with name and age because
399:47 - remember what I saying about the scope
399:48 - of the variables parameters inside a
399:50 - function are always going to be local to
399:52 - that function around the curly braces
399:54 - that they're surrounded by name and age
399:57 - is only within here so when it's trying
399:58 - to shows the local variables it's only
400:01 - local to what's inside these curly
400:02 - braces which in this case is name and
400:04 - ede so now if we step over
400:07 - this and then if we step into this read
400:10 - from console you'll see that just before
400:12 - we step into this function that these
400:13 - have all came back cuz again the scope
400:15 - has changed back to this function which
400:18 - is our main function which has all these
400:20 - variables inside so our read from
400:22 - console will only have our Str message
400:24 - so hopefully when we press f11 or press
400:27 - the step into button at the top we
400:28 - should only see the message variable
400:30 - inside here there we go we get enter
400:33 - anything cuz that's what was passed in
400:35 - over here and then as soon as we return
400:38 - back to
400:40 - that let we type something in and then
400:43 - we get all of the values again and you
400:45 - can see that system. console. reine had
400:47 - returned hello which is this line and
400:50 - then if we press F10 again you'll see
400:51 - that even though we've got it back here
400:53 - our message is about to be assigned once
400:55 - we step over this there you go it says
400:57 - hello and as you can see this changes in
401:00 - real time so as soon as we step over
401:02 - lines hello got placed straight into
401:04 - there this helps us tremendously because
401:06 - we don't have to keep hovering over
401:07 - variables like this to keep checking
401:09 - over their values you can simply use
401:11 - this menu and it will always update
401:13 - because whenever you change Scopes
401:15 - between functions that will
401:16 - automatically update as you just saw in
401:18 - them examples there we go and then when
401:20 - the program ends obviously this window
401:22 - is going to close down so that's a very
401:23 - help helpful method have being able to
401:25 - debug without having to hover over
401:27 - anything in the next video we're going
401:28 - to cover how to watch variables and this
401:30 - can be very handy when you're looking
401:32 - for specific
401:36 - errors another really good debuging
401:38 - technique is the watch window let's
401:40 - press a break point just of left of line
401:42 - 13 and let's run the code and let's see
401:44 - what this is about so we covered that we
401:46 - have the locals window and we have the
401:48 - auto window that will automatically give
401:50 - us the variabl that we're currently in
401:52 - the scope of but let's forget about that
401:54 - right now let's have a look at the watch
401:55 - window it says here add an item to watch
401:59 - so there's a couple ways that we can do
402:00 - this you can actually double click on a
402:02 - variable and right click or you can just
402:04 - highlight it like this and then right
402:06 - click and it says here add watch and you
402:08 - can press it it says name value null
402:11 - because we haven't created it yet so the
402:12 - default value is null as of right now
402:14 - cuz it's not actually assigned anything
402:16 - so you press F10 and step over it you'll
402:18 - see that immediately changes to abber
402:20 - without was having to do anything except
402:22 - simply press F10 which is the shortcut
402:24 - for our step over button right at the
402:26 - top of the screen this prevents us from
402:28 - having to hold over the variables to get
402:30 - the little tool tip so we can see the
402:32 - value the power of this is we can watch
402:34 - variables and we don't have to worry
402:36 - about showing in the locals or the auto
402:38 - because it's always there and if you
402:39 - have lots of variables like this then
402:41 - you're only concerned about the one that
402:43 - you're watching locals and aluto will
402:45 - always change depending on the scope
402:47 - that you currently at whereas watch will
402:49 - only do what you want it to do so
402:51 - because we don't put age inside there
402:53 - then it's simply won't come up just
402:54 - because it likes it if we check the
402:56 - locals we have agent there and the Autos
402:59 - we have agent there as well but we don't
403:00 - have it in the watch so what else you
403:03 - could do is actually just type straight
403:04 - into here age
403:07 - 23 if you really wanted to you can
403:09 - actually also type in conditions age
403:11 - equals equals 23 it returns back true so
403:14 - if you had an if statement that you
403:15 - wanted to track then you could do that
403:17 - as well so let's have a
403:20 - look so it a statement that said if age
403:23 - is greater than than 18 then we can just
403:25 - print out 18 plus to the screen so let's
403:27 - run the code now and see what happens so
403:29 - as you know we have this condition right
403:31 - here so if you actually highlight this
403:32 - and drag and drop it you can see that
403:34 - the cursor changes and you can drop it
403:36 - inside here let's click on the AG equals
403:38 - equal 23 and click delete so of course
403:41 - we can't really render this function
403:43 - right now because we haven't even
403:44 - created the integer variable so let's
403:46 - run over the integer variable and as you
403:48 - can see here it says AG is zero which is
403:51 - the default value for integer and that
403:53 - is is indeed zero right now and then age
403:55 - is greater than 18 is false but as soon
403:57 - as I step over this line and it makes
403:59 - age the value of 23 you'll see that
404:01 - these two immediately change you know
404:03 - they change because the values have went
404:05 - red red means that the values have just
404:07 - changed in the last button that you
404:08 - pressed whether that means he stepped
404:10 - into over or stepped out it doesn't
404:12 - matter red always dictates that the
404:14 - value is just changed so now it's
404:16 - telling us that age is greater than 18
404:18 - is returned back true so when I step
404:20 - over this line because this is returned
404:22 - back true I should render 18 plus let's
404:25 - have a look F10 F10 and there we go
404:28 - we've reached the middle which means
404:29 - that's going to get printed out
404:31 - now so moving on to another example we
404:34 - can have print details if we go into
404:36 - this function and let's say we only
404:38 - concerned about the name then we can
404:39 - print out the name down here but as you
404:41 - can see we already have it twice so
404:43 - that's just going to update depending on
404:44 - the parameter name and even if you
404:46 - wanted to show something like this you
404:48 - can drag this down here and it actually
404:50 - shows you the output this is very handy
404:52 - so you can see the output because
404:54 - sometimes when you have it like this it
404:55 - doesn't look very clear you can also
404:58 - hover over it right there and you can
404:59 - see the value placed here but again it's
405:02 - very handy to have it here so you don't
405:04 - have to keep hovering over the tool tape
405:06 - just to see the values and from here you
405:08 - can actually change the values so we can
405:10 - just say Harry is now the value for the
405:12 - name and Harry is going to be age 35 so
405:16 - when we press F5 and let the program run
405:18 - naturally you'll see that Harry is age
405:20 - 35 now and that's all done through the
405:22 - watch list down here here and it doesn't
405:24 - even matter because we have full control
405:26 - over the watch list variables and we can
405:28 - change their contents to see how our
405:30 - code acts in different situations so
405:33 - please use this watch list as much as
405:34 - you can and don't forget that once you
405:36 - can double click on variables and add it
405:38 - to the watch just from here you can also
405:41 - say quick watch and what that'll let you
405:43 - do is it'll give you the value and then
405:45 - if you want to add it you can press add
405:47 - watch here or you can just keep pressing
405:49 - re-evaluate once you've skipped over
405:51 - some lines so let's say we skipped over
405:53 - it now and then go back onto it and
405:56 - because it has a shortcut shift F9 we
405:58 - can just quickly press it like this and
406:00 - it says abber inside here and we can
406:02 - change the expression maybe do something
406:04 - like age and then click re evalue it and
406:06 - it changes the value to zero and then we
406:09 - can even change this to like 50 for
406:10 - example as you can see down here it's
406:12 - changed to 50 as well so you can drag
406:15 - and drop it into here or you can double
406:17 - click and press add watch it's up to you
406:19 - please make use of this watch variable
406:21 - and don't rely too much on the autos and
406:23 - the local just so you can keep your own
406:24 - variables inside here and you can have
406:26 - complicated outputs like these you can
406:28 - check conditions you can check console
406:30 - outputs as well as just checking normal
406:32 - variables so using the watch window you
406:35 - have lots of different opportunities to
406:37 - keep track of your
406:40 - code so we've got another debugging task
406:42 - let's try and run the code and see what
406:45 - happens we're going to get printed over
406:47 - 18 so our value is AG equals 35 and
406:50 - we're already getting over 18 printed to
406:52 - the screen so if we place a Brak line
406:54 - inside here and actually run the code we
406:56 - can see what's going on we can add them
406:58 - inside the watch just like this we can
407:01 - add in all the conditions
407:03 - inside just like
407:05 - this perfect so we can actually see here
407:08 - that because our age is over 35 it's
407:11 - saying greater than 18 is true greater
407:13 - than 30 is true but greater than 50
407:14 - isn't true and we can easily see that
407:17 - except because this is an if and an else
407:19 - if chain as soon as the first one is
407:21 - true it's going to enter that one you
407:23 - press press F10 then we get over 18 and
407:25 - then as soon as it finishes that path it
407:27 - actually skips all the way to the end
407:30 - the problem with this is we only want it
407:31 - to print over 30 since it's over 30 so
407:34 - we have to introduce ranges inside here
407:36 - and we can say age is less than 30 and
407:39 - then you can have ages greater than 30
407:41 - here and then you can also insert an end
407:43 - and say AG is less than 50 and there we
407:46 - go and now it says over
407:49 - 30 and if we change this to 55 then we
407:52 - should get over 50
407:54 - and then finally if we change this to
407:55 - something like 23 then we should also
407:58 - get over 18 perfect so what was going on
408:01 - here is because we had if and else if
408:03 - chains then you're only going to get one
408:05 - of them printed and because a value over
408:07 - 18 satisfied both the first path and the
408:10 - second path then it's only going to
408:11 - print the first path if we actually undo
408:13 - our changes all the way till the start
408:16 - and then we actually flip the order of
408:17 - this if we put our this one first and
408:20 - delete the El's and change it to lse if
408:23 - inside here so now we have a new chain
408:25 - except the first one in the chain is
408:27 - actually if age is greater than 30 now
408:29 - if you're on the code you'll see that
408:31 - the first one actually says over 30 and
408:33 - it says over 30 and it doesn't say over
408:35 - 18 anymore but simply because this is
408:38 - the first one in the list as soon as it
408:40 - hits the first one as I'll demonstrate
408:41 - now it will go inside this bracket hit
408:44 - this curly brace and then jump straight
408:45 - to the
408:46 - end you should always order them from
408:49 - smallest to biggest because that will
408:51 - probably make the most logical sense
408:53 - when you're reviewing your code and in
408:55 - doing so you can actually have a more
408:57 - formatted code but you need to watch out
408:59 - that the ranges need to make sense if
409:01 - you have something like this then you
409:03 - need to restrict this one because it's
409:04 - going to be blocking the second one and
409:06 - you don't want to make these all ifs
409:08 - because then you get multiple outputs
409:10 - now we should get 18 and 30 being
409:12 - printed to the screen this is not
409:14 - something you want so make sure that you
409:16 - place your ranges inside here by adding
409:18 - an and and then placing the other end of
409:20 - it which will be 30 and then this one
409:22 - will continue from it so so just to sum
409:23 - up what you need to do is make sure that
409:25 - you use Els and make sure that you have
409:28 - ranges just so when one exits it's going
409:31 - to check the other one and the other one
409:33 - you don't want the first condition to
409:34 - beat the second one if that's for the
409:36 - right path age 35 goes into this path or
409:40 - at least we want it to but it's been
409:42 - restricted by the fact that age is
409:43 - greater than 18 when we had it like
409:46 - this this is restricting everything over
409:49 - 18 to go inside this path if this was
409:51 - even like 65 we should only fall into
409:54 - this one and we run the code then we're
409:56 - still going to get over 18 which is
409:58 - still technically true it is still over
409:59 - 18 but we have different outputs for
410:02 - this sort of age range make sure that
410:03 - you use lfs and you keep in an
410:05 - appropriate range and keep them in the
410:07 - order of the if statements going from
410:09 - lowest to highest or whatever makes
410:11 - sense in that situation that you're
410:12 - using
410:13 - it this is a start of objectoriented
410:16 - programming let's start with a concept
410:17 - called structures structures allow us to
410:20 - store different data types inside one
410:22 - data type so it's almost like a group of
410:24 - data types we can demonstrate this if
410:26 - you wanted to stall something like a
410:28 - person you would normally have something
410:29 - like a string name equals ABA and in age
410:32 - equal 23 so in here we have a string
410:35 - name that represents the name and in age
410:38 - which represents their age and you can
410:39 - see that because these are two different
410:41 - data types you can't wrap them around
410:43 - inside an array you can't have a string
410:45 - array called person and then say we want
410:47 - to have two different values although
410:49 - this will still compile we can't store
410:51 - both these data types inside array
410:53 - unless you make the ede and store it as
410:55 - a string which will be 23 inside the
410:58 - quotation marks and then you'll have to
411:00 - worry about converting it later on in
411:01 - your program so this is not really ideal
411:04 - so we have something called a structure
411:06 - so just outside here we can say struct
411:09 - which stands for structure and then we
411:11 - can have our name straight after so we
411:13 - can say person in the next time we just
411:15 - open the curly braces and let's see what
411:16 - we've just created so now in order to
411:18 - make an instance of this we can actually
411:20 - use that like a data type between say
411:22 - person person there we go so now we've
411:24 - created our person variable now you see
411:26 - we've got our own data type before we're
411:28 - just using string and ins and arrays and
411:30 - things like that but now we actually
411:32 - have a new person so because our person
411:34 - is made up of a name and an age let's
411:37 - place that in here string name and then
411:40 - inage of course you don't want to give
411:41 - them default values because like all
411:44 - variables you don't know what the value
411:45 - is going to be to begin with so now what
411:48 - we can do person Dot and we don't
411:51 - actually have access to using these
411:52 - values yet so what we're going to have
411:53 - to do there is a concept called access
411:55 - modifiers which we'll cover on later on
411:58 - in this course but just for now what
412:00 - this means is you either have private or
412:02 - public and they're the main two words
412:04 - there's other words that you can have
412:05 - but they're the main two for now if you
412:07 - have it private it means you can't
412:08 - access it down here through person. name
412:11 - and but as soon as you make this
412:13 - public then now it becomes
412:17 - accessible there we go we can make that
412:19 - equal to something and if we take off
412:22 - public
412:24 - then you see we don't have access to it
412:26 - it's inaccessible due to its protection
412:28 - level because the protection level is
412:30 - private which means that you can only
412:32 - access name Within These two curly
412:33 - braces the second you make it public it
412:35 - means that anyone outside of the
412:37 - structure EG down here can also have
412:39 - access to name so if we do that to our
412:41 - public on int age and string name then
412:44 - we actually can access both now we can
412:46 - say person. Ag and it comes up like this
412:49 - the purple cube is a function and the
412:51 - blue is Fields you you can actually
412:53 - filter them out by pressing them down
412:54 - here show only methods and show only
412:57 - Fields so we can do age equals 23 and I
413:00 - can actually just place abber inside
413:02 - here now that this data is essentially
413:04 - the same as this the benefit that we
413:06 - have now is when we print to the screen
413:08 - we can say person. name and then hyphen
413:11 - person. Ag and if you run that
413:15 - now you we Abid
413:17 - 23 if we actually copy and paste this
413:20 - lined out and just remove person dot
413:22 - just so we're using these two variables
413:23 - at the top of here and we in the code
413:26 - you should see exactly the same values
413:27 - coming up there we go but now what's
413:30 - really handy about this situation is we
413:32 - have two data types that are wrapped
413:34 - inside of one data type instead of
413:36 - having a name and age we have a person
413:39 - because what gets really easy now is if
413:40 - you wanted to add something else inside
413:42 - here like for example birth month which
413:45 - for me is five so in here you'd have to
413:47 - make another one birth month equals 5
413:50 - and then all we have to do inside our
413:52 - person is just say person. birthmonth
413:54 - and we could just assign it right here
413:56 - instead of having to create a whole new
413:58 - variable we add it up here and then we
414:00 - can use it down here and then we can add
414:01 - that into here person. birthmonth
414:05 - and we can add this to this one and then
414:08 - get rid of birth month and as you can
414:10 - see it's exactly the
414:12 - same so we've taken these data types and
414:14 - placed it inside our structure so then
414:16 - we can just reference it by the person
414:19 - this becomes very very handy for this
414:21 - exact reason that I'm going to show show
414:22 - you now let's say you wanted to read
414:24 - this data R from the user so you have
414:26 - static and then you're a bit stuck on
414:28 - what data type you want to return if you
414:30 - forget about the birth month then we
414:32 - have a name and age as a very basic
414:34 - person but our return type only lets us
414:36 - have one type so that's going to be a
414:38 - problem now so you could do a string
414:39 - return that will give us back the name
414:41 - and then we can say return person and
414:45 - inside the brackets what you can
414:46 - actually do is do out in Edge so you can
414:48 - have two output variables an out Edge
414:51 - and then a return string since hiide
414:53 - here we could
414:55 - say enter your name and then string name
414:59 - equals console do read
415:01 - line if we copy and paste this down and
415:04 - then we can say enter your age and then
415:06 - we can say int age equals convert to and
415:09 - 32 and then put the console read line
415:12 - inside there there we go now that we've
415:14 - got that we don't actually need inage
415:16 - because we've already got output
415:17 - parameter so we just need to be Edge and
415:20 - then after we've retrieved them two
415:21 - values we can return name there we go so
415:25 - let's actually try that up here so we
415:28 - can say new name is equal to return
415:32 - person and then out in new ede and you
415:35 - can take this exact line paste it down
415:38 - here get rid of the birth month and then
415:40 - we can use new age in here and new name
415:42 - inside here so let's run that now ask us
415:46 - what is your name ABA what is your age
415:48 - 23 and then we got ABA 23 which is the
415:50 - same as what we've got before but you
415:52 - see that this situation is prettyy messy
415:54 - we have to return a string variable and
415:56 - also use an output in order to be able
415:58 - to give back two values alternatively
416:00 - what we could do is actually just return
416:02 - back void and then we can say string
416:04 - name and then inage but we're going to
416:07 - have to use references inside here and
416:10 - then have string new name equals nothing
416:13 - and then new inage equals 0o so we have
416:17 - string new name equals nothing and then
416:19 - into New Age also equal to nothing and
416:21 - then inside our function instead of
416:23 - having out parameters we can actually
416:25 - use a reference and we can say a new
416:27 - name and then ref New Age and what that
416:29 - will do is we can just return it like
416:31 - this because it's void instead of
416:33 - declaring a new string name we can
416:35 - actually just assign it to the reference
416:36 - that just passed and because it's a void
416:38 - parameter now and for the return type we
416:40 - don't actually need to return anything
416:42 - so we can actually assign these by
416:43 - reference enter your name ABA and 23 so
416:47 - as you can see it still works fine but
416:49 - let's say we wanted to add another birth
416:50 - month so we' have to take the birth
416:52 - month variable new birth month make it
416:55 - equal to zero and then add yet another
416:58 - parameter ref new birth month and then
417:02 - we need a new birth month inside
417:04 - here ref int birth month and then we
417:09 - need another one from here enter your
417:12 - birth
417:12 - month and then we'd start it inside
417:15 - birth month and then finally we can also
417:18 - return it up
417:20 - here as new birth month
417:23 - there we go AB 23 and then five so we
417:26 - get them values being returned so in
417:28 - order to keep adding different
417:29 - properties to your code you have to make
417:30 - a new parameter a new reference variable
417:33 - and then append the parameters inside
417:35 - the function now the problem that is
417:37 - even though you can have an infinite
417:38 - amount of parameters then this gets very
417:40 - tedious very quickly and you don't want
417:42 - this so let's have a look at how we can
417:44 - make this function exactly the same way
417:46 - just using our new structure you can see
417:50 - that instead of having to pass all of
417:51 - these different things in or return back
417:53 - a certain value we can actually just
417:55 - return back a complete person so all of
417:58 - this can be squished pretty quietly so
418:01 - actually let's just comment all of this
418:04 - out and let's comment out this function
418:06 - and let's have another
418:08 - rewrite so now that everything's gone we
418:10 - only want to be returning and dealing
418:12 - with the person so we can say static and
418:15 - instead of void we actually want to say
418:17 - we want to give the user back a person
418:19 - return person and we don't need any
418:21 - parameters in in this case this is only
418:24 - passed in because it's a reference so we
418:26 - can assign these values back to the
418:28 - original variables but because we're
418:30 - going to be returning a person then we
418:31 - don't need to do that so we can
418:33 - essentially take this code and put it in
418:35 - here and we can say string name now we
418:38 - have an in here and then also an in here
418:41 - there we go so now that we've
418:43 - constructed all our variables that we
418:45 - need for the person what we can do is we
418:47 - can make a new person person person and
418:50 - then person. name equals name
418:53 - and then duplicate this down we say a
418:54 - person. ag is equal to age and finally
418:58 - the birth month is equal to the birth
419:00 - month and then now that we've
419:02 - constructed our person we still got a
419:04 - red underline because we haven't
419:05 - returned anything yet and after all of
419:07 - that we can say return
419:09 - person there we
419:11 - go and now simply in here we could just
419:14 - say person person equals return person
419:19 - there we go and then we can take this
419:22 - console right line here and place it
419:24 - straight underneath since it uses the
419:25 - same properties now let's try and run it
419:28 - AB
419:30 - 235 there you go so now instead of
419:32 - having to make a whole new variable all
419:35 - you have to do is simply just add
419:36 - another one down here so we can just say
419:38 - number this could be your favorite
419:40 - number or anything and we can add it
419:42 - onto
419:45 - here person.
419:47 - number and then here we can paste this
419:50 - down we can say enter your number and
419:53 - then it will be number in here we can
419:56 - paste it down here and change it to
419:58 - number and there we go that's all we
420:00 - need to change and this code doesn't
420:02 - change cuz it's simply calling back the
420:04 - function and we're doing all the hard
420:05 - work inside here so now if you run this
420:08 - enter your name abber 23 5 and finally
420:13 - four and there you go we get the values
420:14 - being
420:16 - returned so this looks a little bit
420:18 - tedious we have to assign each one
420:20 - individually every single time we do it
420:22 - so we can actually use something called
420:24 - a Constructor in order to achieve this
420:26 - result we make the person we set them
420:28 - and then we return it it' be easier if
420:30 - we could have the Constructor that we
420:32 - can assign straight inside here and then
420:34 - just return it immediately instead of
420:35 - having to do all of these lines and then
420:37 - reference each one individually so let's
420:40 - have a look and see what we can do
420:42 - inside here we can have a new function
420:44 - that'll just be called whatever the
420:46 - structure is called then you open the
420:47 - brackets close the brackets for now and
420:49 - this is called a Constructor in order to
420:51 - be able to use it down here we need to
420:53 - make it public in order for someone else
420:55 - to access it so this says that it needs
420:57 - explicit parameters in order to be able
420:59 - to compile it says that it needs to
421:02 - assign name age birth month and number
421:04 - so let's see how we can do that as we've
421:06 - used Constructors in the past for
421:09 - example when we had things like the
421:11 - string Builder we had s SP equals new
421:13 - string Builder and when you make a new
421:15 - something that means you're making a new
421:17 - Constructor so all of these sixes are
421:20 - the parameters that go inside of this
421:22 - but each one of these is a separate
421:23 - Constructor if we control click this we
421:25 - should be able to see them all there we
421:27 - go you see that the class is called
421:29 - string Builder and this is called string
421:31 - Builder and these two names match
421:33 - exactly so to make a string Builder you
421:35 - can give it any one of these as long as
421:37 - your parameters match one of these six
421:40 - you can give it nothing or you can give
421:42 - it some other values and that's the same
421:44 - is true with our current
421:46 - person so what we need to do in this
421:48 - case is we don't have multiple ways that
421:51 - we can constru this in the case of our
421:53 - person we have to provide all of these
421:55 - details otherwise the compiler is not
421:57 - going to like it so we can have a string
421:59 - name int age int birth month and int
422:03 - number now we got our parameters set up
422:05 - we actually need to make use of them in
422:07 - here so because we have name and name
422:11 - and they're exactly the same string by
422:13 - string then in here we can't say name
422:15 - equals name in terms of global and local
422:18 - variables this is global within the
422:20 - structure as it's within these two curly
422:22 - braces and all of these variables are
422:24 - only Within These two curly braces local
422:27 - variables always take presidence over
422:29 - the main one if I double click on this
422:31 - you'll see that all three are
422:33 - referencing this Constructor if I double
422:35 - click on this you'll see that both name
422:37 - references on line 20 down here is all
422:40 - referencing this one in the parameter
422:42 - and not the one up top we want it to be
422:45 - assigned into here so you have two
422:46 - options in this case you could
422:48 - capitalize all of these so then you
422:50 - don't run into this issue and then
422:52 - instead of name equals name it's capital
422:54 - N equals name and that fixes it
422:56 - alternatively if you want it to be a
422:58 - lower case then what you can simply do
423:00 - is you can place this
423:02 - dot if you use this it goes back to the
423:04 - current scope and the current scope of
423:06 - name is going to be this which is within
423:09 - the
423:10 - structure when you use this it doesn't
423:12 - reference the local variables it
423:14 - references the global variables appear
423:16 - so when I double click on this now
423:17 - you'll see that that gets highlighted so
423:19 - we can say this. ede equals ede this.
423:22 - birth month equals birth month and
423:24 - finally this. number equals number so
423:27 - we're just getting all the parameters
423:29 - from here and putting them into these
423:31 - values this might look a little bit
423:33 - redundant but I'll show you why this is
423:34 - a lot
423:35 - cleaner so back in our return person
423:37 - function we have the variable and then
423:40 - we assign them all manually but look how
423:42 - easy this now has became if I comment
423:44 - out this return we can say a return
423:46 - person so now we can reference person
423:48 - with a capital P this time cuz I want to
423:50 - reference the structure directly so
423:52 - after the person we can open the
423:53 - brackets and then start to type in so
423:55 - our first one is name age and the birth
423:57 - month name comma age comma birth month
424:01 - comma and then number comma and then
424:02 - this is not going to like it because we
424:04 - also need to place new
424:09 - inside as I said before when you making
424:11 - a string Builder you have a new keyword
424:14 - and this new means that you want to
424:15 - create a new instance of this you could
424:18 - think of this structure as a template
424:20 - this is the template for something and
424:22 - until you start using that something
424:24 - it's actually not going to do anything
424:26 - so we have to make a new instance of it
424:28 - because it's not already available so we
424:30 - need to make it available through our
424:31 - data type so when we say we want a new
424:33 - person that gives us access to the
424:35 - Constructor if I remove that you'll see
424:37 - we've got one of two now we can create
424:39 - an empty person and that will just make
424:41 - us assign all the values individually
424:43 - but we don't want that we want to use
424:44 - the second path and if you drop the
424:46 - arrow you'll be able to see the
424:47 - different parameters which is the ones
424:49 - we just typed in name age birth month
424:52 - and then number and now that we've
424:54 - returned back this we actually don't
424:55 - even need to do any of these lines right
424:58 - here we can actually just return it
425:00 - exactly like this so now if you run it
425:01 - again you should see exactly the same
425:03 - output 23 5 and four perfect so let's
425:07 - just have a little recap so normally
425:09 - when we're creating variables we use
425:11 - common variables that we've used in the
425:12 - past string in double Flo bull Etc but
425:16 - with the use of structures we can create
425:18 - our own group of variables and then we
425:20 - can use them VAR Ables inside functions
425:23 - and inside our code to make things a lot
425:25 - cleaner and a lot easier so inside
425:27 - person we actually stall four different
425:29 - variables and they can be an infinite
425:31 - amount of variables should you will and
425:33 - you can easily remove them and then
425:35 - remove them from the parameters and from
425:37 - the assignment and then that's it if we
425:39 - use this without our structure then
425:40 - we're going to have to declare every
425:42 - single variable separately and I know
425:44 - this is the same as doing it up here
425:46 - it's actually a little bit more work cuz
425:47 - you need to create a new parameter and
425:49 - create all the the instances inside here
425:51 - and assign the values now the benefit of
425:54 - doing it within a structure is that when
425:56 - you go to do a function look how easy
425:58 - this line is before you'd have to have
426:01 - name age birth month all as references
426:03 - or have them as out parameters and it
426:05 - gets a little bit long and a bit sloppy
426:07 - you only to include the month in here
426:08 - we' have to have another int number and
426:12 - you can see that the parameters are
426:13 - growing if you wanted to store a user
426:15 - from a registration form you might have
426:17 - name address phone number country and
426:19 - the list goes on it can be a very long
426:21 - form and you therefore you'll have a lot
426:23 - of parameters so it's very easy to wrap
426:25 - it around inside a structure and then
426:27 - simply reference it like that and you'll
426:28 - need zero parameters because everything
426:31 - is contained within the data type and
426:33 - then inside here we can ask for the
426:34 - users's details individually store them
426:36 - as their integers and string variables
426:39 - and then instead of using this notation
426:40 - we can now use our fancy Constructor
426:43 - where we can pass it in in this exact
426:44 - order right here name age birth month
426:47 - and then the number perfect and then we
426:50 - can use inside here we can call each of
426:52 - these positions separately and
426:53 - concatenate them
426:56 - together so now that we covered
426:58 - structures known by struct as the
427:00 - keyword let's have a look at classes and
427:02 - how to define them syntactically so we
427:04 - can make a struct called person and we
427:06 - can give them a string name and inage
427:09 - and to make them accessible we'll make
427:10 - them
427:11 - public and we can say public person
427:14 - string name and int age and that means
427:17 - we can assign these values using the
427:19 - Constructor so we can say this.name
427:21 - equals equal name and this. age equals
427:24 - age perfect so let's get rid of our
427:27 - compiler error since we're assigning
427:28 - both the values and then down here we
427:30 - can use it we can say person person
427:32 - equals new person and then have abber
427:35 - and then 23 in the brackets and we can
427:38 - print to the screen person. name and
427:40 - then if use controll D to duplicate that
427:42 - down and we can do age and if we run
427:45 - that right now we should see abber and
427:47 - 23 being printed to the
427:50 - console perfect so as we talked about
427:52 - introduction syntactically the struct
427:54 - and the classes are very similar so
427:56 - let's comment this out so we don't get
427:58 - any compile errors and let's see how
428:00 - this is going to work so of course we're
428:01 - going to get error on this line but once
428:03 - we make our class the error should
428:04 - disappear from here so instead of struct
428:07 - person we're simply just going to have
428:09 - class person exactly the same and
428:12 - because these are fields we can also
428:14 - copy these down so we can have public
428:16 - string name and public int
428:18 - age and then we can have public person
428:22 - and then string name in age this do name
428:25 - equals name and this. age equals age so
428:28 - as you can see this is exactly the same
428:30 - as this except for the fact we have
428:32 - structure and we have class inside here
428:35 - now you see how compile error is gone
428:36 - and if you've run the code we should see
428:38 - exactly the same
428:40 - output there we go now the main
428:42 - difference about classes and about
428:43 - structures is that you don't actually
428:45 - have to give these a default value
428:47 - inside the
428:48 - Constructor if we just comment this one
428:50 - out for a second
428:53 - and if we bring the structure back and
428:55 - we actually remove the parameters from
428:57 - here then we're actually going to get
428:58 - compile errors and it says that the name
429:00 - and age must be assigned before it's
429:03 - returned and stroks cannot have
429:05 - parameterless Constructors now that's a
429:07 - bit of a problem in certain cases you
429:09 - might want to create an instance of
429:11 - something but not actually derive any
429:12 - values so you could actually make these
429:14 - into default values you can have string
429:17 - name equals nothing and int age equals
429:19 - zero and therefore once we place in
429:21 - inside here then there's no problems if
429:23 - you run the code then you will get the
429:25 - output this will be nothing this will be
429:27 - zero and you'll get errors and you won't
429:30 - get any compile errors doing this way
429:31 - but the point is you have to include
429:33 - them and you don't have a
429:35 - choice so if you just comment this back
429:37 - out now what you'll notice about the
429:39 - class
429:40 - person is even if we get rid of it then
429:43 - it still lets us have it of course we
429:45 - can't actually give it parameters since
429:46 - we don't have a Constructor that lets us
429:48 - have parameters but what you can do as
429:50 - well is you can overload this and
429:52 - actually include it as well so you can
429:54 - have another set that literally lets you
429:56 - define both of
429:58 - them and then you can even have another
430:00 - overload that lets you just include the
430:02 - name without the edge and then also
430:05 - another one that lets you include the
430:06 - int Edge without the name or you include
430:09 - both the details so in these cases what
430:12 - you can do is you can store the values
430:13 - up here as the fields let them use a
430:16 - default Constructor or only give it the
430:18 - name or the age or you can actually give
430:20 - it both so when we come down into here
430:23 - we actually now have four different
430:25 - Constructors we can make an empty person
430:27 - we can make it with an edge with the
430:29 - name or with
430:31 - both and what you can do in here is you
430:33 - can say this.name is equal to nothing
430:36 - and then here you can say this. AG is
430:38 - equal to minus one just to default it to
430:40 - a value that's incorrect so after we've
430:42 - got this let's have a look at the
430:44 - different ways so we can give it a
430:45 - person which gives us an empty value so
430:47 - if you run that now we get blank and
430:50 - zero and if we just give it the name
430:52 - which is Aba then we should get ABA in
430:54 - minus one yep and then if we just give
430:57 - it the age you should get nothing in 23
431:00 - and if you actually give them both then
431:02 - you should get both printed out to the
431:03 - screen and there we go so now we have
431:07 - four different ways that we can create
431:08 - our person with our structure we're only
431:11 - really limited to one since all of these
431:13 - values need to be assigned as the
431:15 - structure is created structures are
431:17 - meant to be used as an extension to a
431:19 - data type rather than almost like a mini
431:21 - management system when we make a class
431:24 - we have so many options of different
431:25 - ways that we can do this inside here and
431:27 - later on in the course we're going to
431:29 - show you how to include functions inside
431:31 - here and then eventually do other
431:33 - Advanced Techniques with classes that
431:35 - aren't directly available structures if
431:38 - you have a basic example where you want
431:39 - to extend something to use inside a
431:42 - function or a data type like starring
431:44 - name and age instead of having to do two
431:47 - return types inside a function then a
431:48 - struct is perfect the second you want to
431:50 - do more complicated things or make it a
431:53 - bit more specific and flexible then
431:55 - classes are the way forward you'll see
431:56 - it very often in games where they have
431:58 - struct position you'll see in video
432:00 - games where they have something like a
432:02 - struct position and they might have int
432:04 - X int Y and int Zed and that's for their
432:06 - 3D position or they might even just have
432:08 - an X and Y or you could have something
432:10 - simple like a rectangle and you can give
432:13 - it a width and a length so now when you
432:16 - use that inside the code you're going to
432:18 - have different flexibilities of the
432:20 - amount with data types that you can
432:21 - store and then when you return that back
432:23 - from a function that will be okay as
432:25 - well since you can use this as a data
432:27 - type so if you want something simple and
432:29 - straightforward then go for the struct
432:31 - the second you want something a bit more
432:33 - complicated and a bit flexible then you
432:35 - probably want a class we go into more
432:37 - different situations inside this cause
432:38 - so you understand in which cases to use
432:40 - what and in most cases you'll notice
432:42 - that the class is more replicable so if
432:44 - you wanted to you could ask the user to
432:45 - enter these details in and then you can
432:47 - pass them inside the Constructor so we
432:49 - could say a console right line
432:51 - changes to a right enter your
432:54 - name String name console. readline and
432:59 - then copy and paste this down change
433:00 - this into a int age and then wrap this
433:03 - around inside a convert in32 instead of
433:06 - enter your name it'll be n your H and
433:08 - then since these are grayed out it means
433:09 - we haven't used them so we can change
433:11 - abber to your name and then change 23 to
433:13 - H perfect so now if you run the code now
433:17 - enter your name ABA enter your age 23
433:20 - then we get AB number 23 printed out to
433:22 - the screen so just a quick recap
433:25 - Constructors are basically defined the
433:26 - same way you have public followed by the
433:29 - class or the structure name and then the
433:30 - parameters inside the brackets and then
433:32 - you can assign it after without
433:34 - structure you have to declare all of the
433:36 - variables inside the parameter and
433:38 - assign them all down here otherwise you
433:40 - won't be able to run your code with
433:42 - classes we have the flexibility of just
433:44 - including one default function which
433:46 - will just be our Constructor and even if
433:48 - it does nothing this is still acceptable
433:51 - and then we broke it down to multiple
433:52 - sections where you might have situations
433:54 - where you only want their name or their
433:56 - age or you might even collect both to
433:58 - store it if you collect the name then
434:00 - we'll initialize age to minus one just
434:02 - so you know that this is a bad value and
434:04 - if you declare only the age then we'll
434:06 - initialize a to nothing just so you know
434:09 - that it's an empty value and if you
434:10 - accept both then we simply assign both
434:13 - and down here we have access to it we
434:16 - can even make this a little bit better
434:17 - by checking these values so we can say
434:20 - if string is not null or mty of person.
434:24 - name and we can put a not inside here
434:27 - then we can print out
434:30 - this and then the same thing for age we
434:32 - can say if person. AG we can say greater
434:36 - than minus one since we set minus one as
434:38 - the bad value and then we can move this
434:40 - line up and let's try run it now so
434:42 - these two if statements are
434:44 - fundamentally separate from each other
434:46 - one is checking the name and one is
434:47 - checking the age so let's try and
434:49 - manually type these in and see what
434:51 - happens so enter your name let's make
434:54 - this blank and only include the age and
434:56 - let's see if this runs okay so you had
434:58 - no name in the age of 23 then you see we
435:01 - only get printed 23 because it'll skip
435:03 - over this line as you can see if we put
435:06 - a break point in now and just refresh
435:07 - the code we get empty name plus 23 and
435:11 - when we press F10 over this line it
435:13 - jumps the next one because if we hover
435:15 - over this you'll see that it should
435:17 - return us back with false there we go we
435:19 - get strings null or empty is is false so
435:21 - that'll skip over that and because the
435:23 - age is 23 then this line is going to
435:25 - execute let's run it again and do the
435:27 - opposite we could say name is Aba and
435:30 - then age is minus one and then we get
435:32 - ABA printed be not the
435:34 - age there we go so if you wanted to fix
435:37 - these in and type them manually so we
435:39 - can say
435:40 - 23 there we go we get 23 and if we only
435:43 - include the
435:45 - name
435:47 - ABA then we only get ABA printed out and
435:49 - if we include both both of
435:52 - them then we get them both printed out
435:56 - perfect so now that we've created our
435:58 - class we've gave it some fields and
436:00 - we've made our Constructor that lets us
436:02 - initialize it let's see how we can print
436:03 - the details out to the console so we can
436:05 - have a CW tab tab a console right line
436:08 - and then we can say string interpolation
436:11 - name callon space and then we can have
436:13 - our curly braces and we can say person.
436:16 - name we can access these fields using
436:18 - the dot operator and then we can say
436:20 - back/ again for the new line and then
436:22 - say age and the same thing person. AG
436:25 - let's try run that and see what we've
436:27 - got so now we've outputed name and age
436:30 - out to the screen let's see how we can
436:31 - do this inside a function if you wanted
436:33 - to place this in different part of your
436:34 - code then you're going to have to copy
436:36 - and paste this and as we know this is
436:38 - bad for our code because it's j a
436:39 - duplication we want to be able to wrap
436:41 - this inside a function somewhere so
436:43 - let's see what we can do we can have a
436:44 - static string so you can return us back
436:47 - with this that we can output straight to
436:48 - the console and we can say return
436:51 - details and for our parameter we can
436:53 - have something like string name and int
436:56 - age because that's what our class is
436:57 - made up of and inside here we can simply
437:00 - take this put it inside here and put a
437:03 - return before it and then get rid of the
437:05 - person dot since we have an aim and age
437:07 - variables as local to the function so
437:10 - now instead of this line we can
437:11 - duplicate this down take out the
437:13 - contents and we can say return details
437:16 - and then we can place person. name and
437:18 - person. AG inside here let's r on the
437:21 - code so we get exactly the same output
437:24 - but the problem with this function is
437:26 - we're having to type out the parameters
437:28 - manually we have them here and we're
437:30 - going to have to type them again in here
437:32 - and again for the parameters this is a
437:34 - bit of a problem because we've just made
437:35 - our class but we haven't really used it
437:37 - when we're passing it in so instead of
437:39 - having string name and int age we can
437:41 - actually duplicate this method and just
437:42 - comment it out just so you can see it
437:44 - for reference and instead of doing this
437:46 - you can actually just pass in an entire
437:48 - person so now we have access to person
437:51 - and we can bring this back and we can
437:52 - say person. name and we can also say
437:55 - person. Ag and the reason why this
437:57 - method is preferred is if you actually
437:59 - have something else public int number
438:02 - and then you added another one inside
438:03 - here int number and then you said this
438:05 - do number equals number the parameters
438:08 - won't have to change inside the function
438:11 - all you have to do is simply pass in the
438:13 - person and then now we actually have
438:15 - access to doing person. number inside
438:18 - here should we need to if you passing
438:20 - them all all in one by one like this
438:22 - then you have to append into number on
438:24 - the end and then add it straight to here
438:26 - and then also add it inside here as you
438:28 - have like this it's easy to pass the
438:30 - class in because all of these properties
438:32 - above are just simply used throughout
438:34 - the function so now if we just bring
438:35 - this
438:39 - back and let's have a run and see if we
438:42 - get the same
438:43 - output which we do name ABA age 23
438:46 - perfect so now that we've thought of two
438:49 - functions how to do this we we can
438:50 - manually type in the strings and the
438:52 - integer and any other parameters that we
438:54 - need or we can actually pass in the
438:55 - person the problem with these two
438:57 - approaches is the whole point of having
438:59 - classes and structures of the like is so
439:01 - we can wrap around lots of functionality
439:03 - inside it if you want to send this to
439:05 - another developer for them to use in
439:06 - their project or maybe this is a file
439:08 - that is shared within the projects then
439:10 - you don't want them to include a
439:11 - separate function that is simply outside
439:13 - of the class we want to include the
439:15 - functions inside the class so of course
439:18 - as you know these are functions so
439:20 - inside side here we can also make
439:22 - functions so let's do it so we can have
439:24 - public and we want a string return
439:27 - details and then we don't need to pass
439:29 - anything in the the values that we're
439:32 - going to be returning are these two
439:33 - right here which is technically local to
439:35 - our class so therefore we're not going
439:37 - to have any parameters I'll explain that
439:40 - further in a second so we can take this
439:42 - exact line paste it straight into here
439:44 - and get rid of the person Dot and get
439:46 - rid of the person dot on this side so
439:48 - then we have the name variable and the
439:49 - age variable
439:51 - if you double click on them you see it
439:52 - references these variables and the same
439:54 - thing for age the reason why we don't
439:56 - have parameters is when you call this
439:58 - function as I'll show you in a second
440:00 - you call it directly on the person so
440:02 - the person that you're trying to print
440:04 - has already got these contents inside of
440:05 - them so let's have a look we can
440:07 - duplicate this down and instead of
440:09 - calling return details and passing the
440:11 - person you actually do it the other way
440:13 - around you say the person object dot
440:16 - return details so now we're calling
440:18 - return details inside our person person
440:20 - an
440:21 - object now let's run the code you see
440:24 - the output is exactly the same except
440:26 - now this functionality is a lot better
440:28 - our return details is wrapped inside our
440:30 - class which is the preferred way now we
440:33 - can actually get rid of these inside
440:35 - here and then we shouldn't really use
440:37 - this notation even though is technically
440:39 - correct but you want to wrap all your
440:40 - functionality inside here and just bear
440:43 - in mind that scope is also applicable
440:44 - here return details is within this class
440:47 - which means if you try to run this
440:49 - function inside the main then it's not
440:51 - going to node exist this return details
440:53 - function was able to be used inside here
440:56 - because this was in the scope of the
440:57 - class program which is this curly brace
441:00 - and this curly brace but this return
441:02 - details is only within the scope of this
441:04 - class which means you can't just
441:06 - suddenly use it inside the main so
441:08 - please bear that in mind when you
441:09 - producing these classes and you're
441:10 - trying to understand where everything
441:12 - goes every function that you place
441:14 - inside here is accessible through the
441:16 - dot notation after the object once
441:18 - you've created the class soose person
441:20 - equals new person and then after we type
441:22 - person dot then we'll get a list of all
441:24 - the functions the same way if you have
441:26 - something else just like this and then
441:30 - if you do person Dot and then you see
441:32 - that something has appeared there so all
441:34 - the functions that you create up inside
441:36 - in this class for every person that you
441:38 - make it'll be accessible through the dot
441:40 - notation so just to round up this video
441:42 - you should always make your functions
441:44 - inside your class having them inside the
441:46 - class is the whole point of making a big
441:48 - class and have lots of functionality
441:50 - side if you keep the function that does
441:52 - exactly the same thing outside of the
441:54 - class then if you were to share this
441:56 - file or come back to it in the future
441:58 - then you're not going to understand why
441:59 - you've done this and it's outside the
442:01 - class keeping everything wrapped inside
442:03 - the class is the best way forward in
442:05 - most case
442:07 - scenarios so now we have our class
442:09 - person it's got a name and age a
442:11 - Constructor and a function to return
442:13 - back the details and we can simply use
442:15 - it like this and return back the details
442:17 - like this but so far we've covered how
442:19 - to make classes Constructors Etc and
442:22 - assign the values but the values are
442:24 - only getting assigned throughout the
442:26 - Constructor but what if a different part
442:28 - of our program the user want to change
442:30 - their name update their age Etc then
442:32 - what options do we have so you know we
442:34 - can access our Fields using person. name
442:37 - and then you can simply type equals and
442:39 - then type in another name and we can say
442:41 - person. AG equals 25 now we've changed
442:44 - these properties if we use the console
442:46 - right line and return details you'll see
442:48 - that the values have indeed changed
442:51 - as you can see there it's changed the
442:52 - Harry in
442:54 - 25 this is okay except for the fact that
442:57 - this shouldn't really be possible we
442:58 - should try and restrict this directly by
443:01 - the use of gets and sets so for now
443:03 - we're going to cover fields and how to
443:05 - restrict certain values and later on in
443:07 - the course we're going to go through
443:08 - what properties are so before alter
443:10 - properties got invented we had to use
443:13 - gets and Setters gets and sets are
443:15 - essentially functions that will prevent
443:17 - this from happening so the reason why we
443:20 - can do this is simply because this
443:22 - public word is placed right here if we
443:25 - change it to private it means that name
443:27 - is still accessible within here and here
443:30 - which is only the limit of the class but
443:32 - as you can see it's not applicable here
443:35 - this is why you need the public Getters
443:37 - and Setters so I'll explain that what
443:39 - that means now so we prevent these from
443:41 - accessing outside the class by making
443:44 - them private so this functionality no
443:46 - longer works so what you have to do
443:48 - instead is for every field that you have
443:50 - you need to create a getto and a set a
443:52 - function so in order to set a value we
443:55 - can have public and because we're
443:57 - setting it we don't need to return
443:58 - anything so it'll be void and we can say
444:00 - set name and then we pass in string name
444:04 - and then we simply just say this. name
444:06 - equals name so when someone calls set
444:09 - name and pass in the name like this we
444:11 - just overwrite it so let's see how that
444:13 - looks so if we comment these two lines
444:15 - out we can simply say person do set name
444:18 - and then we can say Harry so this line
444:21 - is directly replaced by this line and
444:23 - now if you run this we'll see that Harry
444:25 - should be changed there you go abber is
444:28 - changed to Harry this is really powerful
444:31 - because what we can do now is restrict
444:33 - the access inside here and make sure
444:35 - that the value contain something genuine
444:37 - we can say if string is null or empty
444:41 - and then pass the name inside there if
444:44 - the string isn't null or empty then we
444:46 - assign it and if it is null or empty
444:49 - then what we can do inside here is we
444:51 - can say else this do name equals nothing
444:54 - and we can keep it blank or we can use
444:56 - string. empty just to make sure that we
444:58 - know that the name has been blanked out
445:00 - if they've entered something invalid if
445:02 - they've entered something that's valid
445:04 - we assign it if it's invalid then we
445:06 - don't assign it and we just initialize
445:08 - it back to nothing and because our
445:09 - options are endless with this we can
445:11 - actually make this into something else
445:13 - we can simply just say invalid name so
445:15 - then what happens is if we try and
445:17 - change this to nothing and we run the
445:19 - code
445:21 - we can see that we get invalid name
445:22 - being printed to the screen and that's a
445:24 - lot better than if we had string.empty
445:27 - because if you had strings are empty
445:30 - then it would kind of say nothing then
445:31 - it looks like something's went wrong if
445:33 - you have something like invalid then
445:35 - that gives you a bit of a bar message so
445:38 - we can have invalid name there so using
445:40 - our Setter Let's us change our name from
445:42 - down here without directly exposing the
445:44 - public if he expose the public then
445:46 - everyone who uses classes can simply
445:49 - change the name to whatever they want
445:51 - having it private and only changing the
445:53 - name within the set name function is
445:55 - very preferable because you can restrict
445:57 - the access and what people can set the
445:59 - values to if they try to set it to
446:01 - something that's not valid then we set
446:03 - it to invalid name whereas before when
446:06 - we did this and if we make this public
446:10 - again we can simply set this to
446:12 - something bad like null null is a very
446:14 - bad value but it still lets us have it
446:17 - and the reason why it's very bad is if
446:19 - you you try to do something like this
446:21 - person do equals and just some empty
446:24 - brackets now even if I just leave this
446:26 - empty the fact that you try call equals
446:29 - onside person. name is going to be a bit
446:32 - of a
446:33 - problem so we can say person object the
446:36 - name property inside it and we're
446:38 - checking if it equals to abber for
446:39 - example but because we've just set it to
446:41 - null let's see what
446:43 - happens you see that we actually get an
446:45 - exception it's a null reference
446:47 - exception because if you hover over name
446:49 - you see that returns back null nulls are
446:51 - very bad in this case whereas if we
446:53 - actually bring our function back and we
446:56 - make this into a private and then if we
446:58 - try and take this value our null value
447:01 - and place it straight inside our set
447:03 - name if you uncomment it get rid of the
447:06 - quotation marks and if you actually try
447:08 - and assign it to null let's see what
447:10 - happens then we're going to get invalid
447:12 - name and this prevents us from breaking
447:14 - our code if a function like equals were
447:17 - to be called on any of our properties
447:18 - inside of name so now that we've done it
447:20 - for our name we can also do it for our
447:22 - age but before we do that we can also
447:25 - call a function called get name return
447:28 - details gives you back these details in
447:30 - a very specific fashion but what if you
447:32 - wanted to do something like this your
447:35 - name is and then you wanted to do
447:37 - person. name but of course you can't do
447:39 - that because name is no longer public so
447:42 - you can't reference it directly so we've
447:44 - got a set name and then now we need to
447:46 - do a get name so we can have public and
447:49 - because name is a string the return type
447:52 - is going to be string and we can say get
447:54 - name and this function is very simple it
447:56 - just returns back name and that's it
447:59 - there's no parameters because all it
448:01 - does is return back a value and in this
448:03 - case it's just returning back name so
448:06 - instead of using person. name in here we
448:08 - can say person. getet name open close
448:11 - the brackets to indicate it's a function
448:12 - but there's no parameters now you see
448:14 - that we have no compile errors so now if
448:16 - you run that you'll see that it says
448:18 - your name is invalid name so let's
448:21 - actually give it a
448:22 - value and we can say hurry again run the
448:25 - code there you go your name is hurry so
448:28 - let officially change it and now let's
448:30 - work on the
448:31 - edge so just following the exact same
448:33 - approach we can have a public void set
448:37 - age int age and instead of just doing
448:41 - this. age equals age let's try set some
448:43 - boundaries on this we can wrap this
448:46 - inside an if statement so as for the
448:48 - condition we want to valid Val if the
448:50 - age is successful so we want to do if
448:52 - age is greater than or equal to zero and
448:54 - age is less than or equal to 150 so this
448:57 - means if the age is less than zero or
448:59 - greater than 150 then this is going to
449:01 - return back false and then it's not
449:03 - going to assign the value and we can
449:05 - simply assign it to minus one minus one
449:08 - is just so we know it's a bad value so
449:09 - now that we've created our set age we
449:11 - can actually make our get age so we want
449:13 - to return back an INT because that's
449:16 - going to be the data type PR age so we
449:18 - do public int get age we don't need any
449:20 - parameters cuz as like the name we're
449:23 - just simply returning something so we
449:25 - can say return age so now that you've
449:27 - made the set age and the get age let's
449:29 - actually use it in our code so we've
449:31 - made our set name and let's say person
449:34 - do set age and we have 25 inside here
449:37 - just like above and then now that we've
449:39 - set the age let's appin this sentence we
449:41 - can say and your age is and then person.
449:45 - getage perfect so let's run the code and
449:47 - see what happens there we go we have 25
449:50 - and Harry being
449:52 - changed so another little tip when we
449:55 - doing this code our get age is one line
449:58 - and I'll set age as a couple of lines
450:00 - but fundamentally only assigning age so
450:02 - what we can do is we can make these into
450:04 - the tertiary operator so as we can see
450:06 - here this is the condition if this
450:09 - returns back true then we assign age our
450:11 - local parameter and if this returns back
450:13 - false we assign minus one so we can
450:16 - actually make this into this. AG equals
450:19 - if you remember remember the format of
450:20 - our conditional operator use condition
450:22 - true and then condition false so this is
450:25 - our condition that is leading our if
450:28 - statement and if this returns back true
450:30 - then we do question mark and put age in
450:32 - there and then call on if it returns
450:34 - back false then it's simply minus one
450:36 - there we go so this has actually been
450:38 - entirely replaced by this one simple
450:41 - line and we can do the same thing for
450:43 - our string so we can say this.name is
450:46 - equal to string that is null or empty
450:48 - pass the name name inside there and if
450:50 - that is true then we assign it to name
450:53 - and if that is false we say invalid name
450:55 - let's comment this one out and let's see
450:57 - if all code runs okay
450:59 - still hurry 25 hurry 25 and now let's
451:03 - try our bad values so we can try to set
451:05 - the age to 200 and the value to nothing
451:08 - and let's see what happens we get
451:10 - invalid name minus one and there you
451:13 - go perfect so that's working okay let's
451:15 - undo them values and you can see that
451:18 - this has been shorten completely another
451:20 - top tip for functions like this you can
451:22 - actually use something called Arrow
451:23 - functions and if you've done any
451:25 - JavaScript this might be quite familiar
451:27 - so we can have our get ede and instead
451:29 - of open the curly braces at this point
451:32 - we can actually place this Arrow inside
451:34 - so if we comment out this one with arrow
451:36 - functions you can only return back one
451:39 - simple line so because this is only one
451:41 - line we can have return age but our
451:44 - functions don't like the keyword return
451:46 - any variable that you put straight
451:48 - inside here is automatically applied
451:50 - that it's a return type so we literally
451:52 - just put age get age returns us back
451:55 - with age if this is confusing then stick
451:58 - to this approach but this can might tidy
452:00 - up your code because instead of having
452:02 - all of this and all the curly braces for
452:04 - one simple line you can use Arrow
452:07 - function so if you actually copy and
452:09 - paste but first comment out all of these
452:11 - functions you can see how small the code
452:14 - can actually get there we go and then
452:16 - let's actually have a public void set
452:20 - age let's put our R function in and then
452:22 - we can take this one line and paste it
452:24 - straight into here so you can see that
452:26 - these two lines are now being replaced
452:28 - by all of
452:29 - this and of course we need our int age
452:32 - inside here there we
452:35 - go so now we can do the same thing with
452:37 - our set name we can take
452:40 - this we can have public vo set name
452:44 - String name and then have our Arrow
452:46 - function and then simply paste that in
452:48 - you can see that this will get a little
452:49 - bit long now but it's still ideal I've
452:52 - got the code zoomed in but if you put
452:54 - that to 100% you'll see that this code
452:56 - is actually pretty small it's just I've
452:58 - zoomed in just so you can see the code a
453:00 - lot
453:01 - clearer and then finally for public
453:05 - string and we can get name and then we
453:07 - simply just do arrow and then name and
453:10 - you can see that with all this other
453:11 - code commented we just relying on these
453:13 - functions as we just created and you'll
453:15 - see there's no console errors or
453:17 - anything else so if you try and run it
453:19 - you'll see that everything is going okay
453:21 - of course if you don't like this
453:23 - notation and you don't have to include
453:24 - it you can stick with the curly braces I
453:27 - don't use Arrow functions a lot in
453:28 - practice because there isn't many
453:30 - situations where you'd actually use them
453:32 - and even if you do some people might not
453:34 - like them or there might be certain
453:36 - guidelines that you might be following
453:37 - inside a
453:38 - company what I do suggest you stick with
453:41 - is the tertiary operator these are a lot
453:44 - good and a lot better to use since it
453:46 - reduces the cord drastically if we
453:48 - actually remove
453:49 - this and I'll paste it back in just so
453:52 - you can see it for reference inside the
453:53 - resources but you can see that these
453:55 - four functions are now reduced to on one
453:58 - page you can see that they're all got
453:59 - one lines and they're pretty short so
454:02 - let me undo that just so you can see the
454:03 - original code and have it for
454:05 - reference so there's a lot covered
454:07 - inside this video so let's just have a
454:09 - little recap before we finish up so just
454:12 - to start at the beginning when we
454:14 - initialize our person with their name
454:16 - and their age we don't actually have any
454:18 - other opportunities to change their
454:19 - value which is where this comes in you
454:22 - can actually just say a person. name and
454:24 - assign any sort of value you can put
454:26 - anything inside there and it will assign
454:28 - it directly unconditionally the problems
454:30 - of doing this is someone might expose it
454:32 - to null by accident and some wearing
454:34 - your code if you're using something like
454:36 - equals this will actually prevent an
454:38 - exception of course you can wrap this
454:40 - inside a TR catch but this is
454:41 - unnecessary because we can prevent this
454:43 - in the first place it's always best to
454:45 - prevent an exception than to put
454:47 - additional code in like a TR catch in
454:49 - order to catch something that you can
454:50 - prevent in the first place prevention is
454:52 - definitely better than the Cure in this
454:54 - case so having something like a person.
454:57 - name being exposed it's not so much for
454:59 - the integer because integers will always
455:02 - have number values whereas strings they
455:04 - can be initialized to null there is no
455:06 - such thing as null in our age that our
455:09 - default value for an integer is zero so
455:12 - we don't really have the same issue we
455:13 - started introducing the name function
455:15 - and the age function these are used so
455:17 - we can control what Val values get
455:19 - assigned to our local variables and we
455:21 - also have our get functions get name and
455:23 - get age so let's explore how these are
455:25 - made inside our Cass and expand on that
455:28 - and see how they work so first we need
455:30 - to make sure that our variables are
455:32 - actually private they're private so we
455:34 - can't access them just like this if I
455:36 - copy and paste this line above you'll
455:37 - see we're going to get a compile error
455:39 - and this error is because we can't
455:41 - actually use it because as it says here
455:43 - it's inaccessible due to its protection
455:46 - level and the protection level comes
455:48 - from the fact that this is indeed
455:50 - private it's private so it's only
455:52 - accessible within class person so every
455:55 - reference to name can be used inside
455:56 - here just not outside so the only way to
455:59 - be able to change the name now you've
456:00 - made it private is by enforcing this
456:03 - function the good thing about this
456:04 - function is we can check if the value is
456:06 - invalid and then we can star it if it's
456:09 - valid and then change it to something
456:10 - else if it's invalid and then we can
456:12 - wrap this if statement around in a
456:14 - conditional Operator just to make it a
456:16 - little bit shorter and in order to
456:18 - retrieve an name because now that it
456:19 - made it public we can neither set or
456:22 - retrieve it so we have our get name
456:24 - function that simply just returns it
456:26 - back to the screen nothing special here
456:28 - and the same thing for our set age we
456:30 - can check if the age is between 0 and
456:32 - 150 and assign it and if it's not assign
456:34 - it to minus one and then again wrap it
456:37 - around in our conditional operator and
456:39 - then for our get age we can just return
456:40 - age I demonstrated our functions inside
456:43 - here you can take all of these on line
456:45 - functions and actually add them all in
456:47 - one line without the need of cly Braes
456:49 - if you want to return back in age then
456:51 - you simply just type in age just like
456:53 - you can see here and here when you do
456:56 - assignment you want to specify this.name
456:58 - equals but when you're doing returns you
457:00 - just need to type in the variable that
457:01 - you need of course this looks a little
457:03 - bit cleaner and a bit shorter but not
457:06 - Everyone likes this notation so it's
457:07 - completely up to the developer or the
457:09 - environment that you're working in and
457:11 - finally we just have our return details
457:13 - and then we can make use of them just
457:15 - like this by using person which is the
457:17 - name of our local variable for new
457:19 - instance followed by a DOT and then set
457:21 - name set age and then get name and then
457:24 - get
457:27 - age so now that we're dealing with
457:29 - classes it's important you focus on the
457:31 - scope we have a person person here
457:33 - that's defined within the main which
457:35 - means it's only Within These two curly
457:37 - braces so if we had a static void and a
457:39 - function that did something inside here
457:42 - we can't access person inside here if we
457:44 - take out the comment and we try it the
457:46 - only reference we have is accessing the
457:49 - class directly not this local variable
457:52 - if you want to access local variable
457:54 - from inside this function then you'd
457:56 - simply have to pass it in like this and
457:58 - then it'll finally become available as
458:00 - you can see now there's two and it says
458:02 - as a parameter and the same goes for
458:04 - this class above just because we have
458:07 - name and age up here it doesn't
458:09 - necessarily mean that we can magically
458:10 - use name down here if we have something
458:13 - like a static int defined right here
458:16 - then we can use this integer inside
458:18 - these function functions as it says
458:20 - there it's available we can sign that to
458:22 - 10 and it's also down here available and
458:24 - we can sign that one to 20 and you'll
458:26 - see we have no compil errors but if we
458:28 - take this and put it inside our return
458:30 - details function then you're going to
458:31 - get an exception because X is not
458:33 - available within that scope and the
458:35 - functional scope matters inside here as
458:37 - well if you have a string test inside
458:40 - here we can just access it in another
458:42 - function for example the Constructor we
458:45 - can't just print out test as a screen
458:48 - the handy or classes if you want
458:49 - variables to be available throughout the
458:51 - class then you put them at the top we
458:53 - can have that private string test and
458:56 - there you go you see that the compil
458:57 - error is now gone and we can give that
458:59 - initial value and then you can use that
459:01 - to print to the screen Etc and just to
459:04 - note when you have a variable that's
459:06 - called exactly the same thing we have a
459:09 - private string test up here and we can
459:11 - say hello and then we also have a string
459:13 - test down here so let me demonstrate
459:16 - what happens when two variables are the
459:17 - same so let's let's move this into our
459:20 - Constructor so if we run this as it is
459:22 - we test equals hello and then we print
459:24 - out test and then run the
459:26 - code there you go we get hello printed
459:29 - and just ignore this this is from the
459:31 - return details function as we've got in
459:33 - the main down here return details so
459:37 - we've made our new Constructor and then
459:39 - assigned it the value with abber and 23
459:41 - and then we can get hello printed to the
459:43 - screen but let's say we actually made a
459:44 - string test inside here and we said hi
459:47 - instead of hello then which one you
459:48 - think get use the global one or the
459:51 - local one let's run it and find out it's
459:54 - actually the local one the compiler will
459:56 - always prioritize the local variables
459:58 - over the global variables and this is
460:00 - the reason why you need to type this dot
460:03 - because when you use name it's always
460:05 - going to reference the parameter when
460:06 - it's name on its own use console right
460:09 - line and say name and then if we do
460:11 - after this line and another console
460:12 - right line and we say this. name then
460:14 - these are completely different this one
460:16 - is the parameter and this one is talking
460:18 - about the variables from the class and
460:20 - these are known as our
460:22 - Fields local variables take presidence
460:24 - over our Fields as long as they're
460:26 - called the same thing as you can see now
460:29 - it says it's assigned but the value is
460:30 - never used if you take the string test
460:32 - out then you can see it's now being
460:36 - used there you go hello gets printed out
460:39 - to the screen and there you go the green
460:41 - line has went because we're using it
460:43 - down here scope is very important when
460:45 - you're designing these classes and just
460:47 - to note that the variables that are
460:49 - available inside here are not going to
460:52 - be necessarily available inside here
460:54 - unless you make them public and even
460:56 - when you make them public that doesn't
460:58 - necessarily mean that this is still
461:00 - available magically over here name will
461:03 - only be available through an instance of
461:06 - the person class so if we do person.
461:08 - name now we can see that that's
461:10 - available as our field so that's why
461:13 - that makes it
461:14 - public if we try and make this private
461:16 - again just to return that value back
461:20 - and we scroll down you'll see now we get
461:22 - a compile error because it's
461:23 - inaccessible because it's outside the
461:25 - scope because it's now a private
461:30 - variable so we've covered what it means
461:32 - to have a public or a private field if
461:35 - you have a private field then you're
461:36 - going to have to use Setters and gets in
461:38 - order to work with this field if you
461:40 - make it directly public then you won't
461:42 - need any Setters and gets because the
461:44 - user can just type iname after their
461:47 - public instance
461:48 - so you can have person followed by the
461:50 - dot and right now you can't see name
461:52 - inside here and the blue slittle icon is
461:55 - no longer there the reason why it's not
461:57 - there is cuz there's no public Fields if
462:00 - we then change this to
462:02 - public remove the dot and readit you'll
462:04 - see that our blue square is now back
462:07 - because our field is now accessible and
462:09 - we can assign that to anything that we
462:11 - want the whole point of making this
462:12 - private is your only restricted access
462:15 - so you know what you're doing and the
462:17 - reason why I say that that is if they
462:19 - enter something that's invalid then we
462:21 - want to specify something like invalid
462:23 - if we give them Public Access then we're
462:25 - not going to know and we won't be able
462:26 - to validate what they've entered so in
462:29 - order to do it through a Setter we can
462:31 - make it private create our set function
462:33 - with a return type it's going to take in
462:35 - a string parameter and this string has
462:37 - to be the same data type as the
462:39 - parameter you're talking about call it
462:41 - name or whatever you want it to be and
462:43 - because these two are called exactly the
462:45 - same thing we have to use this dot so
462:47 - we're referencing this name instead of
462:49 - this name in the parameters and here
462:50 - we're just using a conditional operator
462:52 - and we're saying if the string is not
462:54 - null or empty hence the exclamation
462:56 - point then we assign it to name name
462:59 - gets put in this. name and if this were
463:01 - to return back false then we place
463:03 - invalid name straight into this. name
463:06 - and for the get we simply just return a
463:08 - string since that's a data type for name
463:10 - and then just return it back and it's
463:12 - that simple and the same thing for age
463:14 - we validate the age range set it and if
463:17 - it's outside this range we can set it to
463:18 - minus one so as you can see this is a
463:20 - bit long we have our private variables
463:23 - and then we have two functions one for
463:25 - set one for get and the same thing for
463:28 - age so these are called fields and gets
463:31 - and Setters so I'm going to introduce a
463:33 - notion called properties and properties
463:35 - make it easier to do this exact notation
463:38 - so let's now see how properties created
463:40 - since these fields are private we need
463:42 - to make something that's actually public
463:44 - so we can do something like this we can
463:46 - say public string
463:48 - and we can say name with a capital N so
463:51 - now you can see that name and name are
463:53 - not actually clashing and we can assign
463:55 - that in here should we want to and you
463:57 - see we don't need this dot anymore
463:59 - because this is now different it's a
464:02 - capital N so this one always references
464:04 - this and this references this so we need
464:07 - to add something else onto here so if
464:10 - you create them
464:11 - both now you can see we can do age
464:13 - equals age and there'll be no problems
464:15 - with this so now that we've made our two
464:18 - new Fields so now we have our two new
464:20 - public variables which are known as our
464:22 - Fields let's see how we can turn them
464:24 - into properties so if you remove the
464:26 - semicolon you can actually add in some
464:28 - curly braces so inside here we need a
464:31 - getter and Setter just like we had down
464:34 - there but we have a quick Ann notation
464:36 - for it instead of making two distinct
464:38 - functions you can actually create a
464:40 - little section inside these curly BRAC
464:42 - to get and set the name so you got to
464:44 - think of this as a middleman the same
464:46 - way this is a middleman
464:48 - we call this function and this function
464:51 - will affect the name and this is going
464:53 - to be the same principle we make use of
464:55 - name with a capital N but it will
464:57 - actually be affecting the lowercase n
464:59 - variable these are going to be our new
465:01 - middle mans and they will directly
465:03 - replace the gets and sets here so what
465:05 - we can do in here is we can say get
465:08 - press enter go on the next line and make
465:10 - some cly braces and then we can also
465:12 - have a set so this is like our mini get
465:15 - and mini set function just like we've
465:17 - got here by as you can see it's a lot
465:18 - shorter we don't need to give it a
465:20 - distinct name or set the public or
465:22 - anything else we just give it a simple
465:25 - set and get so if you have a look at the
465:27 - compile error it says not all call Path
465:30 - return of value because as it says here
465:32 - this get function is actually a mini
465:34 - function built into this property
465:37 - person. name which is our name with a
465:39 - capital N and then it's do get and this
465:41 - returns back a string so if we actually
465:43 - just type in return this then it gets
465:45 - rid of the compiler error but of course
465:47 - we don't want to return nothing we
465:48 - actually want to return name because
465:50 - remember what I said string name and
465:52 - intage up here is our private field they
465:55 - actually start the data the public
465:57 - string name and the public in age is the
465:59 - middleman that coordinates all of the
466:01 - gets and sets to do with the private
466:03 - variables so for the set just for now we
466:05 - can say name equals and then what do we
466:08 - give it the value of so if we hover over
466:11 - set it doesn't actually give you any
466:13 - indication of what it's going to be so
466:15 - let's have a look if we press control
466:17 - space then we don't also get the list of
466:19 - everything that we can add inside here
466:21 - now it's very difficult to understand
466:23 - what to assign this to when we have set
466:26 - name we've gave it a string name
466:28 - parameter so we can use name down here
466:30 - so what's our parameter in this case
466:31 - well the function itself doesn't
466:33 - actually tell us but I'm telling you
466:34 - right now that the parameter is actually
466:36 - just called value and this is a very
466:38 - default parameter that you'll see
466:40 - everywhere when you doing gets and sets
466:42 - inside a property you don't have to
466:44 - specify value or anything it just gets
466:47 - simply assigned in just like here where
466:49 - we have string name this will be a
466:52 - string value so it will look something
466:53 - like this behind the scenes but of
466:55 - course you can't actually type this in
466:57 - cuz remember these properties are trying
466:59 - to give you a short hand on how to do
467:01 - gets and Setters so you just got to
467:03 - remember that when you trying to set you
467:04 - get the property inserted as value so
467:07 - you can startall that into name so
467:09 - that's it the name is actually sorted
467:11 - now so before we do the same thing for
467:13 - age let's see how we can use this inside
467:15 - the code so we scroll down to our main
467:18 - we have a person person and then we have
467:19 - a console right line that prints the
467:21 - details so we can actually do person Dot
467:24 - and you can see now that it's slightly
467:26 - different if you ignore the age since
467:28 - that's returned back as a field since we
467:30 - haven't done that yet you'll see that
467:32 - name now has a little Cog next to it
467:34 - show only properties this is a new icon
467:37 - that we haven't saw yet so this is our
467:39 - new icon it says it's going to return us
467:41 - back with the string and we can actually
467:43 - execute a get and execute a set straight
467:45 - on this name then we can say name equals
467:48 - Harry and we don't get any compiler
467:49 - errors whatsoever this lets us do it
467:52 - completely so now if we do another
467:54 - console right line and we say person do
467:56 - return details and let's run that and
467:58 - you should see that the name gets
468:01 - changed there we go ABA gets changed to
468:04 - hurry perfect so after we've got person.
468:07 - name let's see how we can also get the
468:10 - value so we can just say string
468:12 - interpolation your name is and then we
468:15 - do person and followed by a DOT and as
468:18 - you can see the exact same list that we
468:20 - got given over here is given right here
468:22 - as well name also says get and set and
468:25 - it returns back a property which is a
468:27 - string type so we can open like this and
468:30 - you'll notice that we don't have the
468:31 - parentheses after it and the reason for
468:33 - that is because the brackets indicate
468:35 - that you're calling a function but a
468:37 - property is just a property it's almost
468:39 - like a variable so you're not actually
468:41 - needing to put any brackets after it
468:43 - because there's no function to call so
468:45 - as you can see this is exactly the same
468:47 - as this
468:48 - in this case we're actually setting the
468:50 - value and in this case we're actually
468:52 - getting the value so let's comment this
468:54 - line out and let's see what
468:56 - happens your name is Harry so that's
468:59 - worked okay so now let's do the same
469:01 - thing for
469:02 - age remove the semicolon add the curly
469:05 - brace we can say get and then return age
469:09 - and then simply do set and then do age
469:12 - equals value there we go so now we got
469:15 - that set up if we return back down here
469:17 - and we see person dot so as you can see
469:19 - now the age is being removed as being a
469:21 - field as we saw in the blue icon it's
469:24 - now being turned into a spanner which
469:26 - means it's a property as shown here show
469:28 - only properties so now you can see it
469:30 - returns back an integer and we've got a
469:32 - get in a set so we can set that to 25
469:35 - for example and then we can append onto
469:37 - here and your AG is person. AG you see
469:40 - that it's a couple a just as this one is
469:42 - a capital N and now we have get and set
469:44 - available and again we don't need the
469:46 - brackets inside here since this is a
469:48 - property not a function now let's run it
469:51 - we should see Harry 25 there you go your
469:53 - name is Harry and your age is
469:56 - 25 perfect so as you can see now is
470:00 - instead of having our set name and get
470:01 - name which are these two functions we
470:04 - actually have them contained within a
470:06 - property we call this property and it
470:09 - affects these variables but as you can
470:11 - see just as these functions below were a
470:13 - middleman we've now moved the middleman
470:16 - into these properties so as these are
470:18 - only one line you're probably thinking
470:21 - there's probably a better way of doing
470:22 - this and it's a lot quicker for syntax
470:24 - and you're right there is so let's
470:26 - explore that so I said before about
470:28 - Arrow functions when you're doing
470:30 - something like this get name you can
470:32 - have public string get name and then you
470:35 - can simply do Arrow name and this is a
470:37 - very common string function get name
470:39 - that just returns back a value and you
470:41 - can make that into an arrow function by
470:43 - literally just putting back name so we
470:45 - can actually do the same thing but for
470:46 - our properties
470:48 - so these both contain one line so we can
470:50 - actually minimize this and if we just
470:52 - block comment this
470:54 - out we can say public string name and
470:58 - then we can have get and then the same
471:00 - thing with the arrow function when we're
471:02 - doing Arrow function down here you would
471:04 - simply won't use the return keyword you
471:06 - would just type in the variable you want
471:07 - to return so we can say get arrow and
471:10 - then simply low case name and then add a
471:12 - semicolon just so you know that that
471:14 - section is ended and then straight after
471:16 - we can have set
471:18 - and then arrow and then name equals
471:20 - value just like that so as you can see
471:23 - these contents are exactly the same
471:25 - we've actually return them back in a
471:26 - short space and of course here as we got
471:29 - a compile error it just expects a semic
471:31 - callon to be right at the end here there
471:33 - you go and now we do the same thing for
471:34 - our
471:37 - age we can do public int age get Arrow
471:42 - age and set Arrow age equals
471:45 - value perfect so now you can see that
471:48 - this has been drastically reduced if I
471:50 - cut this just underneath you'll see that
471:52 - almost all of these lines are just
471:54 - replaced in a two and you'll see that
471:55 - our functionality will still work
471:57 - exactly the same if we just run the code
471:59 - Harry and 25 is being reassigned over
472:02 - our default variables perfect of course
472:05 - now if you want to add some more
472:06 - functionality inside here for example in
472:08 - our set name we had a little check that
472:11 - makes sure that it's a valid name before
472:13 - we assign it so we actually take
472:16 - this and paste it over here then you see
472:19 - the lines grown quite a lot so what's PR
472:22 - to do is if you're going to have any
472:23 - data inside here that does a little bit
472:26 - of logic then it's best to keep the
472:27 - curly braces since you can have a bigger
472:30 - output and it looks a bit more sensible
472:32 - if you just simply getting and you're
472:34 - setting the variables then you can leave
472:35 - this notation so let's undo this and
472:38 - bring back the original ones in this
472:43 - case there we go and then we can take
472:45 - that line and in the set we can actually
472:47 - replace it here so as you can see this
472:49 - is a little bit grayed out so let's put
472:51 - the semicon at the end and let's see why
472:53 - this is grayed out name can be
472:55 - simplified so what we're doing now is
472:57 - name and all of these variables are
472:59 - actually looking at the private variable
473:02 - whereas if you actually look down here
473:03 - and we uncomment this you'll see that
473:06 - set name if we double click on this one
473:08 - this is the only reference to it which
473:11 - is our private variable appear and the
473:13 - reason why this doesn't need to be used
473:15 - in this case is because our parameter is
473:18 - now called
473:21 - value so it's saying the name is equal
473:24 - to checking if the value is null or
473:26 - empty assigning the value into name if
473:29 - not and then if it is empty then we
473:31 - assign invalid straight into name in the
473:34 - case of our set name our name was our
473:37 - parameter the same goes here if we
473:39 - change this to Value we can change these
473:41 - two for Value as you can see now this
473:43 - dot is actually grayed out and it can be
473:45 - simplified to just simply name and the
473:47 - same principle applies above so let's
473:50 - comment these back out and scroll back
473:51 - to the top so now that we've assigned
473:54 - name there we go we've got our check
473:56 - inside there and you can also leave this
473:58 - on one line if you want you can even
474:00 - drop the curly brace in just so it looks
474:02 - like this instead of having it all on
474:04 - one line so you could do this and this
474:07 - would be applicable as well but the
474:09 - second you start to put it all on one
474:11 - line then it gets a little bit messy
474:13 - quickly so if you leave the outer
474:15 - bracket just like that then you can can
474:17 - be pretty short since you don't need
474:18 - more curly braces so now that we've done
474:21 - that for the name let's do it for the
474:23 - age as well so we had this. age we check
474:25 - the range and we assign the relevant
474:27 - values so let's take that paste it over
474:31 - this we don't need this dot anymore and
474:34 - age in this case is actually going to be
474:35 - the value gets passed
474:37 - in so replace all the ages with value
474:41 - there we go so if the value passes the
474:43 - range check we put the value inside age
474:46 - or not we can put minus one Inside Edge
474:49 - and again we can have the same thing we
474:51 - can use our arrows inside here there we
474:53 - go so now we've got our code drastically
474:57 - reduced so we went from these big
474:59 - functions that have to be defined with
475:01 - specific names over to our properties
475:04 - and they went from really small to just
475:05 - a little bit bigger but now they have
475:08 - advanced connections just to make sure
475:10 - that the variables are okay before you
475:12 - assign it in so now that we've got our
475:13 - properties let's have a look so inside
475:15 - our Constructor we we don't also need to
475:18 - use our local variables which is our
475:20 - private ones directly we should actually
475:23 - get rid of this now and we should always
475:25 - do everything through our properties
475:27 - name equals name and because this is a
475:29 - capital and this is a lower case we
475:31 - don't need this dot in
475:33 - there there we
475:35 - go so what you should do in the return
475:38 - details function is also use the capital
475:40 - n and the capital age so when you hover
475:42 - over these you're actually referring to
475:44 - the property because like I said before
475:47 - these are the middleman to communicate
475:48 - with the private variables you shouldn't
475:51 - need to access the private variables
475:52 - directly you should use the middleman as
475:54 - much as possible so now that we've done
475:57 - that I have one last thing to introduce
475:59 - so if we actually abandon all of this
476:00 - code just to keep it for reference we
476:02 - have something called an auto property
476:05 - and you briefly saw it when we saw it
476:07 - down here so if we actually just bring
476:09 - them back for a
476:11 - second and if you hover over a name down
476:13 - here it says string name get and set in
476:16 - the Cur C brace but you see how the get
476:18 - and set is empty it just has two values
476:21 - inside there and it just ends a curly
476:22 - brace with no actual logic you see in
476:25 - our get we're saying age and our set
476:28 - we're saying age equals this so when
476:30 - we're doing Auto properties what you can
476:32 - do is you can actually make these public
476:37 - again change these to a capital N
476:39 - changes to a capital A and just straight
476:42 - after it you can say Get Set just like
476:46 - that
476:48 - and what that will do is although
476:49 - they're actually made public what it's
476:51 - doing behind the scenes is actually
476:53 - doing this for you it actually has a
476:56 - private and a public for you behind the
476:59 - scenes this is just a Shand these are
477:01 - what's called a auto property what it
477:04 - does is it makes an anonymous property
477:05 - behind the scenes as I'll show you in
477:07 - Microsoft documentation right now as it
477:10 - says here in CP 3 or later Auto
477:12 - implemented properties make property
477:14 - declaration more concise when no
477:16 - addition logic is required and what that
477:19 - means is no additional logic all of
477:22 - these are additional logic if you just
477:25 - simply assigning a value and reading it
477:27 - back just like here then this is no need
477:30 - to write get name and set name if all
477:32 - you're doing is getting and setting it
477:34 - if you're getting and setting it but
477:35 - there is a certain amount of logic as we
477:37 - have here we essentially have a
477:39 - conditional operator that's making a
477:41 - subconscious decision about what to
477:43 - assign the name to but if you just
477:45 - simply assigning something like this
477:46 - then an auto property is perfect they
477:49 - also enable client code to create
477:51 - objects when you declare a property as
477:53 - shown in the following example the
477:54 - compiler creates a private Anonymous
477:57 - backing field that can only be accessed
477:58 - through the properties get and
478:01 - Setters as you can see here just like in
478:03 - our example we have public int something
478:06 - and then get and set and then they have
478:09 - a public in something with the get and
478:10 - set as well and they can use it just
478:12 - here to access it
478:14 - directly and because they're simply just
478:16 - assigned and getting the values and
478:18 - there isn't any additional logic then
478:20 - this is the best way to do it and you
478:22 - get as it says here an anonymous private
478:25 - backing field so this would be the same
478:27 - thing as doing this private string name
478:31 - and private int AG so once you do that
478:34 - and you make this into the get and set
478:36 - properties which are these two right
478:41 - here this and this line together make a
478:44 - property what the auto implement the
478:47 - property does is actually combine this
478:49 - line and this line together and make the
478:51 - private one behind the scenes so the
478:53 - programmer doesn't see it but it will be
478:55 - applicable when the program runs in the
478:56 - compiler and then you only get publicly
478:59 - exposed with this parameter which will
479:01 - be our name property so it will actually
479:04 - make the private for you if you just
479:06 - keep it like we had it a second
479:08 - ago just like this so if you leave it
479:11 - like this it will actually create the
479:13 - private variable behind the scenes as it
479:15 - says here it's Anonymous backing field
479:17 - and it can only be accessed through name
479:20 - and age and as you can see none of our
479:22 - code has actually changed all of these
479:25 - still function okay and if we run the
479:26 - code we should still get Harry and
479:29 - 25 so just to sum this video up since
479:31 - there was a lot covered the bottom line
479:33 - is if you're going to have any sort of
479:36 - values that require any logic then you
479:38 - should use normal properties if you're
479:40 - simply just going to assign and get the
479:42 - value and it doesn't matter and you have
479:44 - no control over it then you can use the
479:46 - auto implemented properties since that
479:48 - will do the same thing with less code
479:50 - using the gets and Setters is the old
479:52 - way of doing this and you should always
479:54 - use the properties going forward Getters
479:56 - and Setters are very helpful to know
479:58 - just so you understand what they are and
479:59 - why they exist but you should not that
480:02 - properties are the best way forward
480:04 - properties give you access to doing the
480:05 - same logic as it says inside here if you
480:08 - do an auto-implemented properties then
480:10 - you're not allowed to use the logic
480:12 - inside the set or the get so if you
480:14 - don't want to do any logic then don't
480:16 - use the AL implemented properties only
480:18 - use the normal properties to make a get
480:20 - and Setter you just do set name get the
480:22 - parameter and assign the local variable
480:25 - and the get just returns it getting back
480:27 - a property you want to capitalize your
480:29 - private variable if you had private
480:31 - string name with a lowercase n you want
480:33 - public string name with a capital N you
480:36 - get the name and then you can set the
480:37 - name with some sort of conditional
480:39 - operator or any if statement or anything
480:41 - inside here and the same thing goes with
480:43 - the age you can have a public int age
480:45 - with a capital a and a private end age
480:47 - with a lowas here you can get the age
480:49 - and then set the age with a conditional
480:51 - operator again or any other code if you
480:54 - don't require any logic like these two
480:56 - lines indicate then you can simply just
480:58 - use the auto properties as demonstrated
481:00 - above here and they can be used quite
481:02 - easily throughout the Constructor and
481:04 - our functions and even outside the
481:06 - function when the user is trying to call
481:09 - them but one thing that we haven't been
481:11 - able to solve and you may not have
481:13 - noticed this as a nuisance the problem
481:15 - is when you trying to return details
481:17 - about something we're having to call
481:18 - this function every single time if we
481:21 - have an INT age for example and made
481:22 - that equal to 23 and we did consle right
481:25 - line and simply placed age inside the
481:26 - brackets we don't have to do anything
481:28 - like this because it simply just prints
481:30 - the value out if we run the code you'll
481:33 - see that it simply just says 23 this
481:36 - should be pretty simple for our person
481:38 - as well but it's not we need to call
481:40 - return details every single time we want
481:42 - to print the properties and if we don't
481:44 - do this the only way to do it is is by
481:46 - making some string interpolation and we
481:48 - can say person.
481:51 - name and then also include person. AG
481:54 - Etc and then that can print out to the
481:56 - screen just like
481:58 - that of course it doesn't have the same
482:00 - format in but we can also just take this
482:03 - place it straight inside here add our
482:05 - person dot before them person Dot and
482:08 - there you go then you get exactly the
482:10 - same output as call and return details
482:12 - but of course you don't want to do this
482:14 - every time and you certainly don't want
482:15 - to have to type type in return details
482:17 - function every single time as well you
482:19 - want to keep it as just person now of
482:21 - course this is not going to work
482:23 - straight out the box let's try run that
482:24 - and see what happens so we get string
482:27 - override. person and what's going on
482:29 - here is it's saying namespace is string
482:31 - override and then it's a class person so
482:33 - it's just printing out this person
482:35 - object but it's not really doing
482:36 - anything because we haven't really told
482:38 - it to do something so what we can do
482:40 - here is we can actually override the two
482:42 - string method so let me explain so let
482:44 - me set up a couple of examples just to
482:47 - show you what's going to happen at the
482:48 - end so right now we call return details
482:50 - to return these details what we can also
482:52 - do is say do two string and then we can
482:55 - also do these three options return the
482:58 - details convert it to a string or just
483:00 - print the person straight to the console
483:02 - at the end of this little section we're
483:04 - going to make all three of these print
483:05 - out the same values so let's have a look
483:07 - now two string and printing out normally
483:11 - these two lines right here are actually
483:13 - doing exactly the same thing behind the
483:15 - scenes when you place anything inside
483:17 - these brackets inside a console right
483:18 - line it will try and convert it to a
483:20 - string anywhere so whether you put to a
483:22 - string or you leave it as person the
483:24 - console right line function will still
483:26 - accept it so let just comment out the
483:28 - age for the time being in order to make
483:30 - the two string function work as well as
483:32 - just ping person inside the brackets we
483:34 - need to make a special function which is
483:36 - an override function so let's have a
483:38 - look so just underneath our return
483:40 - details still within the scope of the
483:42 - class would say public and then override
483:45 - after we press tab we can follow it by a
483:47 - space and we can see the functions that
483:49 - we can override so in this video we're
483:51 - actually going to cover two string and
483:52 - equals get hash code will actually serve
483:55 - as a default hash function if I show you
483:57 - the documentation it says here a hash
483:59 - code is numeric value that is used to
484:01 - insert an identify an object in a hash
484:04 - based collection this is normally used
484:06 - when you doing hash functions as it says
484:08 - here and for the time being we're not
484:10 - actually going to be using this right
484:11 - now so the two we can do are two string
484:14 - and equals but as you can see our two
484:16 - string is available right now we'll
484:18 - cover equals as an extension in a minute
484:20 - so let's double click on our two string
484:22 - and we get this little template placed
484:24 - in if you don't want the template then
484:26 - it's just an override it returns back a
484:28 - string since it's converting to string
484:30 - it needs to be this exact notation if
484:32 - you drop the T then it's got nothing to
484:34 - override now you go be a compil error
484:37 - cuz there's nothing to override itself
484:40 - so play two string the capitals there's
484:42 - no parameters passed in and then we're
484:43 - going to be returning something so the
484:46 - thing that we're going to be returning
484:47 - is exactly the same as our return
484:48 - details function we actually have two
484:50 - options here we could say return and
484:52 - then return details so what that will do
484:55 - is it will go to this function it will
484:57 - call this function grab that and
484:59 - essentially place inside here and then
485:01 - return it back to the console in the
485:03 - ideal world we don't actually need this
485:04 - return details function so we could
485:06 - comment it out but I'm going to leave it
485:08 - in just so the demonstration doesn't
485:09 - break down here so we can take this and
485:12 - place it straight inside here now we
485:14 - have two functions that essentially do
485:15 - the same thing thing but the advantage
485:17 - is this function is something that needs
485:19 - to be called explicitly do return
485:21 - details whereas this function the two
485:24 - string override actually just gets
485:26 - called naturally without having to add
485:28 - any extensions so if you run the code
485:30 - now you'll see that now the all equal
485:32 - exactly the same value we get three
485:34 - sections that have this maybe we can
485:37 - place back SLT instead just so we can
485:39 - have them all in the same
485:41 - line there we go so you can see all
485:44 - three are exactly the same so what we
485:46 - can do now is if we comment this option
485:49 - and we comment out this function we
485:51 - don't have to include two string if we
485:52 - don't want to we can also comment this
485:54 - one out and we can keep it just as
485:56 - person so as we do when we declare the
485:58 - integer we say inage equals 23 and then
486:00 - we simply print out and this is exactly
486:03 - the notation that we want it should
486:05 - really be this simple there you go one
486:07 - line creates the person and one line
486:09 - with just a variable name goes inside
486:12 - the brackets to print them out the same
486:13 - thing here person person age and age and
486:17 - let's run that code now and there you go
486:19 - you get the person printed and the age
486:20 - printed exactly and straightforward as
486:23 - you may think it should be so now that
486:25 - we've done that let's explore what the
486:26 - equals function needs to be done let's
486:29 - make another person we can say person
486:30 - test equals new person and we can have
486:33 - hurry age
486:34 - 23 now we don't need to print them out
486:36 - in this example we just need to
486:38 - demonstrate this equals function so if
486:40 - you remember with strings we can have a
486:41 - string called Abba for example and we
486:43 - can say do equals straight after it we
486:45 - can say if ABA is equal to Harry then we
486:48 - can do something inside here what I'm
486:50 - trying to demonstrate is once you've got
486:52 - an object you can place do equals and
486:54 - then you can compare it like that so you
486:56 - can also do that with our classes so we
486:58 - can say person do equals and then equals
487:01 - to test and in here we could just say
487:04 - same let's try and make these as same as
487:06 - possible and see what happens so let's
487:08 - keep the name exactly the same just like
487:11 - that and let's copy the 25 down just
487:13 - like that so now these two are
487:15 - instantiated exactly the same way let's
487:17 - see what happens when we've run the
487:19 - equals then we don't get anything
487:21 - printed which means they're not the same
487:23 - so because this doesn't automatically
487:25 - tell us that these two are exactly the
487:26 - same we can override that and provide
487:28 - our own functionality just like we did
487:30 - with the operate overload we override
487:33 - equals we get passed in an object and we
487:35 - need to check something inside it so
487:37 - let's see what we can do inside here so
487:39 - in order to check if something is equal
487:41 - to another thing what can we do so we
487:43 - have a name and an age if this one is
487:46 - the same as this and this is the same as
487:48 - this then two people are exactly the
487:50 - same so let's try that out and see what
487:52 - happens so we can say name which is the
487:55 - property inside the class that we're
487:56 - currently inside and then we can use
487:59 - equals because this is just a string
488:00 - parameter and then we can say that
488:02 - equals to
488:04 - objectname but you can see we've got a
488:06 - little problem here this object is very
488:09 - generic it's just an object every class
488:12 - that you create is derived by an object
488:15 - what that means is every class or
488:17 - integer or double at the end of the day
488:19 - is also just known as an object through
488:21 - inheritance which we'll discuss further
488:23 - on this course but just know that
488:25 - everything inside C is always an object
488:27 - somewhere down the line so what that
488:29 - means is we have to convert it from an
488:31 - object to our custom class which is
488:33 - person in this case so we can use this
488:36 - thing called casting so we can say
488:38 - person person which is just Define a new
488:41 - variable and we can make that
488:42 - immediately equal to object as person
488:46 - so what we've done here is we've said
488:48 - our object which is this parameter is
488:51 - currently an object right now we want to
488:53 - cast it as a person which is kind of
488:55 - like converting into a person and then
488:57 - placing the values inside here so now if
488:59 - we get rid of this comment and instead
489:01 - of using object we actually have a new
489:03 - local variable called person so then
489:05 - here we can say personname there we go
489:08 - now we have access to the person
489:09 - property since we've converted this
489:11 - object into a person and of course we
489:13 - know that we have name and age available
489:16 - so if the name is equal to the person.
489:19 - name and the age is equal to the person.
489:24 - age then we must have a match and of
489:27 - course you want to keep using the
489:28 - properties we're going to use a capital
489:29 - A and there we go so we run the
489:31 - conversion on one line and then we check
489:33 - if they're equal to each other now in
489:35 - this specific case you can actually pass
489:37 - anything inside here so let's try it we
489:40 - can pass five into idea and as you can
489:42 - see there's no compile error cuz like I
489:44 - said five is just an integer which is an
489:46 - object at the endend of the day if you
489:48 - make it a double that works as well
489:50 - there is literally no compile errors and
489:52 - even if you put M to make it into a
489:54 - decimal again there's no compile errors
489:56 - because they're all objects at the end
489:57 - of the day so let's pass Tes in there
489:59 - what you will have to know is if you do
490:01 - accident pass in a double for example
490:03 - like this you're going to hit an error
490:05 - here which will be a runtime error it
490:07 - will try and convert it as soon as it
490:08 - hits this line and obviously you can't
490:10 - convert a double into our person so what
490:13 - you could do just to wrap it around you
490:15 - could say
490:16 - if the object is a person then we can
490:19 - proceed with a conversion just like this
490:22 - and then what you can do for safety is
490:24 - just outside of this you can actually
490:26 - just return back false just so the user
490:28 - knows that this isn't equal to each
490:30 - other so if the object is a person then
490:33 - we convert it as a person is is used for
490:36 - checking and as is used for converting
490:39 - is this object a person and if it is
490:42 - then we try and convert it and then
490:44 - return back if they're equal to each
490:45 - other and if we accidentally pass
490:47 - something in that's not a person then we
490:49 - just return back false so let's just
490:51 - demonstrate this
490:52 - first not the same so let's just save
490:55 - five inside here it says not the same so
490:59 - let's actually go into this place a
491:01 - break point and let's run it
491:02 - again hover over object then we get
491:06 - five if we place this straight inside
491:09 - the watch you can see object is person
491:11 - is returning back false so it's skipping
491:13 - this entire function and going into
491:15 - return false and then it's returning
491:17 - back false so we get not
491:19 - same let's stop the program change this
491:21 - over to test and rerun it using F5 and
491:24 - now we can see object is person is
491:27 - actually set to true so now if we put
491:29 - the object inside here you can see that
491:32 - generically it's an object right here it
491:35 - says object so what we can do now is we
491:37 - can place person and down here as well
491:40 - you see that person doesn't exist but if
491:41 - you just give it a second it we change
491:43 - this to just the p
491:47 - there we go so obviously the person
491:48 - doesn't exist cuz we're only up to this
491:49 - line we press F10 and F10 again so now
491:53 - it's create a the variable and F10 wants
491:55 - to skip over it and now you can see the
491:57 - object has went from type object to type
492:00 - string. override. person string
492:02 - overwrite is the name of our namespace
492:04 - and do person with a capital P is the
492:07 - name of our class now you can see that
492:08 - the object and the values are exactly
492:10 - the same 25 ab and 25 AB as you can see
492:14 - right here so now both of them are
492:16 - exactly equal to each other so when we
492:18 - check this name here is Aba name here is
492:22 - Aba age 25 and age is 25 so this must
492:26 - return back true and we can check that
492:28 - by highlighting everything dragging and
492:30 - dropping it down here and we can see it
492:31 - says true there so when it returns back
492:33 - to our code it's going to go and print
492:35 - their
492:37 - same perfect there you go so that's it
492:40 - for this video but let's just have a
492:41 - recap before we wrap up so before this
492:43 - video we'd always print the details out
492:45 - like this person. return details but
492:47 - obviously we don't have that function
492:48 - anymore so let's just bring it back
492:50 - quickly there we go so we use return
492:52 - details and this is just a bit long have
492:55 - to do this every single time if you want
492:57 - to print the details of the test object
492:59 - as well you have to test Dot and then
493:01 - return details again it'd be so much
493:02 - easier if we could simply just use it
493:04 - like this as you would do with a normal
493:06 - variable like an integer double A String
493:08 - Etc and now it's made possible by using
493:11 - our public override string two string
493:13 - function it will contain exactly the
493:15 - same contents as our previous function
493:17 - except we won't have to go through an
493:19 - additional function just to print out
493:20 - the details we can override the two
493:22 - string and then we can call it straight
493:24 - in the console like this and finally
493:26 - when you're doing equals inside an
493:28 - object you can actually build in some
493:30 - custom functionality we can convert the
493:32 - person using object as person but first
493:35 - before doing the conversion you want to
493:37 - check if the object is indeed a person
493:39 - type before doing the conversion this
493:42 - will give you a runtime error on this
493:44 - line so let me just demonstr that before
493:46 - we continue so if I comment out this one
493:48 - and actually just change this into
493:51 - 5D and then let's press into the code
493:54 - right
493:55 - here it's going to hit this line if I
493:57 - press F10 then it's going to try and
493:59 - convert it but you're going to get back
494:00 - null and then if you run the code again
494:03 - then you're get an exception thrown here
494:05 - you're going to get a runtime exception
494:06 - because it's a null reference we're
494:08 - trying to run the equals function on
494:10 - something that is null which is right
494:12 - here null reference exception so you
494:14 - shouldn't do this you you should also
494:16 - make sure that these are correct values
494:18 - before doing it this is a form of error
494:20 - checking if you don't do this then
494:22 - you're going to have to wrap this inside
494:24 - a tri catch and it will look something
494:26 - like this and the cord will be
494:27 - considerably longer you can place these
494:29 - two
494:30 - lines inside here and then place your
494:33 - cat inside here etc etc and you can
494:36 - return false inside here but as you can
494:38 - see the Cod is a bit more complicated
494:40 - now and there's no reason for this extra
494:42 - complication if you can prevent it with
494:44 - an if statement so undo
494:46 - that so what's best in this case is to
494:49 - say if the object is of type person then
494:52 - we can run the conversion if you run the
494:54 - conversion and it's not of type person
494:56 - then as you can see it's going to return
494:57 - back null for the person and then when
494:59 - you run this line it's actually going to
495:01 - return you back a null reference
495:02 - exception at this point but anyway the
495:04 - whole point of this equals is to check
495:06 - if two objects are going to be equal to
495:08 - each other so we keep this back to test
495:10 - because this is a custom classes you
495:12 - can't just simply do person equals
495:14 - equals time test and assume that that
495:16 - will just work these aren't buil-in
495:18 - functionalities for custom classes we
495:20 - covered operate overloading where you
495:22 - can actually overload what you do with
495:23 - the equal sign but we didn't cover the
495:25 - dot equals which is what we're doing
495:27 - today in this video as well as the two
495:30 - string this is a different kind of
495:32 - overriding because in the other one when
495:33 - we're doing operator overloading that's
495:35 - specifically an operator that you're
495:37 - just changing the parameters of whereas
495:39 - this one is a strict override of a
495:41 - function equals and the functions two
495:43 - string this will make it easier to print
495:45 - your custom classes out to the screen as
495:47 - well as comparing them just like this
495:49 - person. equals putting test inside the
495:51 - bracket is a lot easier and quicker and
495:53 - you can build in your own custom
495:55 - functionality if you only had the age in
495:57 - there then you can compare the age maybe
495:59 - have a lot more properties and you can
496:01 - always just chain them inside a big if
496:03 - statement that's fine as well but the
496:04 - point is you have full control over how
496:06 - you compare your custom classes maybe
496:09 - you had a list of names inside a
496:11 - dictionary for example and you wanted to
496:13 - add a new name or a new age or a new
496:15 - user to this dictionary but first before
496:18 - you add a new user to the dictionary you
496:20 - want to check if the user already exists
496:22 - so maybe you could have a system where
496:24 - it uses the equals function and it Loops
496:26 - through all of the dictionary items and
496:27 - it checks if all the values are not
496:29 - equal to this one if you didn't build in
496:31 - this functionality so you could do the
496:33 - do equals function then you won't be
496:35 - able to determine if this one is equal
496:37 - to this one and now with your equals
496:39 - function overrided you can now have the
496:42 - functionality to do so thank you for
496:44 - watching this C course I hope you found
496:46 - it helpful in your journey to becoming a
496:48 - proficient C developer if you have any
496:50 - questions or need further clarification
496:52 - on any topic we have covered please
496:53 - don't hesitate to leave a comment below
496:55 - and I will do my best to assist you for
496:57 - those of you who want to dive deeper
496:58 - into C consider checking out my udemy
497:00 - cause you'll find more comprehensive
497:02 - lessons and Hands-On exercises to
497:03 - enhance your skills remember practice
497:05 - makes perfect keep coding and exploring
497:08 - and I wish you all the best on your
497:09 - programming Journey

Cleaned transcript:

this comprehensive C course will take you from the basics of C programming to advanced concepts all while integrating exciting mini projects to solidify your learning this course offers a structured path through essential topics such as syntax object oriented programming data structures and more ABA teaches this course and he will help you understand C both theoretically and also gain practical experience in applying your knowledge to real world scenarios hey there free Corum ABA here join me in Walking you through everything you need to get a setup with cop let's have a quick walk through the course contents to let you know what to install for you we'll start with installing the visual studio program required to develop cop applications you'll learn about data types including integers strings and many more and how to manipulate them inside your code next we'll dive into control flow you'll discover how to use conditional statements and Loops to control the flow of your program's execution strings are essential in many applications you'll Master powerful string functions in C allowing you to manipulate and transform Text effortlessly data structures are crucial for organizing and managing data from arrays to collections you'll explore various data structures in C and learn how to use them effectively functions are the backbone of any program you'll uncover the power of functions in C including how to create and call them to organize your code no program is immune to errors you'll learn how to handle exceptions gracefully in C ensuring that your applications remain robust and reliable debugging is a crucial skill for any developer you'll discover how to use visual Studio's powerful debugging tools to identify and fix bugs in your C code efficiently finally we'll delve into objectoriented programming you'll learn the principles of objectoriented programming how to use classes objects inheritance and polymorphism to create modular and maintainable code by the end of this course you'll have a solid understanding of C programming and be well equipped to tackle a wide range of software development challenges thanks for tuning in let's get started so in order to start developing with C we need to install install the latest version of visual studio in this case it's currently 2022 so let's head over Google and type in Visual Studio 2022 download we will be presented with two links we have this one and this one we want to use a second one which says download visual studio tools so if you press on that and now we present it with the download area we have three additions Community professional Enterprise Community is free for students open source contributors and individuals which is exactly what we need for the content of this course we have the professional Enterprise Edition which paed for and only used by bigger companies or smaller teams so let's go ahead and press free download the download will start straight away after the download is complete let's start the installer so double click on the executable and press yes to allow it for admin permissions it'll pop up like this Visual Studio installer before you get started we need to set up a few things you can configure your installation you can read the privacy policy in the software terms if you'd like or you can just press continue so it's getting the visual studio installed already so so when you get to this section everything here is all the different packages and tools you can install within Visual Studio 2022 the main one that we're concerned within the content to this cause is the neck desktop environment so you can go ahead and press this one it will then tell you in the bottom right hand corner the total space required is 6.52 GB please make sure you have enough storage space available for this and then you can go ahead and press install if you want to check out other packages you can have a scroll through and read any other packages you may need and may want to install like I said the the only one required for this course is the net desktop environment you can also deal with noj development python development web development if you need to deal with individual components like specific versions you can access it here if you need some more languages installed you can access it here this should automatically select your default language for you that's based on your systems language and if you want it to you can also change the installation location in case you want to install it on a different drive or you just want it in a different folder so now that we selected the neck desktop environment ment we can go ahead and press the installation button we do have two options down here we have it install while downloading and it download all then install if you have a reasonably fast computer you can stick with the install while downloading and it will do the installation and the downloading at the same time if you have a slow computer it's preferred that you use this option to download it first and then install it just means that it won't slow down your computer too much so you can go for this one and press install now the installation will begin so now that visual studi finish installing it will say done installing Visual Studio has been successfully installed we recommend rebooting soon to clean up any remaining files so this just means restart on your computer just so it has a chance to clean up any files that were kept during the installation process so we can just press okay if you have any other versions of Visual Studio installed they'll also show up down here now that Visual Studio Community 2022 is installed we can just press launch so now it'll prompt you to sign into Visual Studio we should definitely sign in but just for now I'm going to skip but feel free to create an account or sign in if you already have one existing we can skip this and then we get to choose your theme I personally prefer the Dark theme but you can go with blue blue extra contrast or the light mode so let's select dark and hit start Visual Studio it will do a first time setup and it's already done and we're already inside Visual Studio 2022 so that's it for the visual studio installation so now that we got Visual Studio 2022 installed let's let's see how to create your first project so once you've opened Visual Studio 2022 you'll see this window popping up you can clone a repository from things like GI Hub in as you devops or open a project that you already have or open a folder which may have projects inside or you can create one from scratch if you don't want to do any of these options you can just open the visual studio program just on its own by clicking continue without code so let's go down the create a project path so click on create a new project and we'll get a list of all these different projects inside our system to be able to use the ones we going to be focusing on on this course is going to be C in the languages dropdown box and the platform is going to be windows and the project type is going to be console and they have one that uses net core which is for Linux Mac and windows and one that uses the Net Framework which is Windows so we want to go for this one so press on this one and then press next here we have our project name our location and our console app so we can start with the project name and say my first project as you can see it start copying over to the solution name as well and it tells you where the project will be created into so I'll be creating a folder called my first project which is the solution name plus my first project which is the project name inside that folder if we change the solution name you'll see update you can see here now we have multiple T's because we appended the solution name the solution name is almost like a folder that holds lots of projects inside so to begin with we'll have one solution that has one project inside and then later on in the course if you feel like you want to add more project projects to it you can just add more to this solution so let's get started and press create so now we've created our very first project and just to explain what's here we have a static main void which is the main entry point to our program if you do a lowercase M then the system is not going to recognize this main function because the down NET Framework requires this function to be found in order to run a c console app and you can see here in the errors the program does not contain a static main function and you can see it's capital M and C programming language is K sensitive so make sure to include it so now you understand how to use Visual Studio 2022 to create a project and also know where the main entry point is in C let's get started with Hello World example to kick off this course so as we know our main entry point to our application is the static void main if we go inside here and press enter then we can actually start writing some code inside here just a quick note before we continue static void main is inside the class program and the class program is inside the namespace hello world and the reason why you can tell this is because of the curly braces the curly braces of hello world begins here and ends here and Within These curly braces we have a class program and also within the class program we have the styo men so just between these curly braces we want to type console. right line open the brackets and we can type in some speech marks and we can simply Type Hello World there you go so as you can see now system has actually been highlighted so if we just delete this line you can see now system has been gr out and the reason why is it says it's unnecessary because it hasn't been used so if you undo it then this comes up because I showed you before that console right line is actually within the system Library what happens if we delete it if we delete it then it doesn't know where console exists from and because that just said system we can actually just use system. console. right line and then open the brackets and type in hello world and now this works again and the reason why this works it's because we don't have to Define that we're using system we could just use it straight in here if you have multiple lines like this then you don't want to be using syst right at the start ideally you want to have the reference to it at the top of the screen and then use it throughout so now that we've included back in the project you can see that now these have turned gray and it says that it can be simplified if we press the light bulb and we can say simplify member and it doesn't really matter because we can just delete the rest now so now that we've WR hello world let's press F5 which is a shortcut to the start button as you can see well you couldn't really see because the program closed too quickly and the reason for that is printed hello world to the console and then it didn't do anything else CU there's nothing else for it to do so the console simply closed we can use another command called console read Line open the brackets and close the brackets and have a semicolon at the end all this does is it waits here until the user inputs something reads the next line of characters from the standard input stream so although the program will actually be reading stuff we you just want this line to stop the application from closing so now if you press F5 and run the program you can see it actually says hello world and it's just waiting here flushing and this flashing means it just started this console read line so it doesn't matter what we type into here it just waits for us to press enter and as soon as we press enter this line executes and the program finishes congratulations you just wrote your first C program welcome to the amazing journey of programming so let's look at how to make variables in our C codee let's start every code with a console read line and then we can hit F5 just to make sure our console doesn't close so let's begin with an integer so integers are whole numbers so we can just say int age equals 23 so what we've actually done here is we've said we want an INT we want to call it age already made it equal to 23 this is called initializing and declaring in the same line line so what you could do alternatively is you can end the semicolon here and it just says int Edge and then on the next line you can write ede equals 23 so this is declaring it in the first line and then give it an initial value in the second line if they're right underneath each other like this case then you may as well just make it together because then you have less lines of code the reason why it says it's a green under line it's because there the unnecessary assignment because we're not actually using age so let's just print ede to the console if we make some new lines and we can type in console. right line and then press tab to finish it we can write Edge and if we run our code using F5 we can see that 23 gets print out to the screen so now that we've worked on the Edge Let's explore all data types so let's define a long variable so let's start with the type long followed by space and then the variable name that we want and let's add equals and type in a very big number so now if we hover over it it says it's a system int32 and int32 2 is actually an integer but we're telling it it's a long which makes no sense we have an in 64 here but when we hover over the number it comes up as n32 and the reason for that is when C sees that you just have a number typed in like this it will always assume that it is an integer to tell the compiler that you indeed want this to be processed as a long number then you can put a capital l right at the end now if we hover over it it says N64 and this says in 64 so so now we've got it working and we've got the long there so now we can take another console right line and just print this out to the screen and just a helpful tip if you type in CW and press tab twice then you get the console right line it's very easy to write your code and then you can type in big Follow by a tab and it'll come up straight away so as you can see they're both being printed to the console now so now that we've made positive numbers we can also make these negative by simply just putting a negative sign behind them there we go and just to show you how big these numbers are what we can do we can type in int. max value and then make another one using contr D and type an int. Min value so you can see integers can be positive 2.1 billion or negative 2.1 billion and if we do the same for long you can see that long is a very very big number because instead of being an INT 32 it's an int64 which takes up a lot more memory so now we've covered whole numbers let's have a look at decimals so we can have a double negative for example and we can say it's minus 55.2 and in this case when you just have a number typed in like this and it's got a decimal point in it it will always register it as a double but just to make sure just as we're doing with the long you can actually just put a capital D at the end now if we print this out to the screen and also print out how big these numbers can be max value and Min value and print this out so we get our minus 55.2 and you can see that these numbers can be very big e + 308 means it's this number times by 10 to the^ of 308 which is a very big number and we also have that as a negative so we have float let's call this precision and make equal 5.1 and then put a semic call at the end now we've got a problem here this is trying to register as a double but we don't want to register double we want to register as a float and this is the same issue we have the long so when you type any number that has a decimal point in it the C compiler will always register as a double the same way when you type in a whole number it'll always register as an INT so in this case we need to put a capital f at the end and it'll process this as a Flo so now we can print this out and then let's just print out the max values and the Min values just to show you what that looks like so as you can see here we have our number printed out and again we have quite a big number 3.4 * 10 to the^ of 38 so again it's a big number and we have that positive and negative so quite a big range of numbers and the last one we're going to cover is decimal for things like money and currency 14.99 and again in this case it's trying to assign a double into a decimal so in order to denote what a decimal is you can put a capital M right at the end and for one last time let's print out the money and the decimal. max value contrl D and then we'll do Min value and you can see here that this is a really big number as well and it's even bigger than the long so we have our number printed and the Max and the minimum values so now that we've understood that how to declare a variable I have an extra little tip for you so if we had three variables int X and int Y and in in Z and let's say you're always going to declare them together like this you can actually miss out and do X comma y comma Z and that will do exactly the same thing there you go and that's really neat and it's a lot better let's say for example you had these variables but you actually had them set to something like equals 10 = 20 = 30 this is still practical but it might look a little uglier so you can actually type them in straight into here and if you comment these out again then it still works you can even put these onto new lines like this just so it looks a bit neater just prevent you from typing the additional int each time if they're all going to be the same variable type so that's it for the numbers inside our code so let's just have a quick recap so in order to Define a variable you want use the data type in this case an integer followed by the variable name and then you can either add a semicolon at that point or you can add a equals to give it a value this is just called declaring a value and this is called initializing a value if you want to decide you want to change the variable further down your program for example age equals 50 here then this is fine and this is now called an assignment it's called initialization because as soon as you make it you give it a value value and then in later on in the code if you give it another value this is called simply assigning a value this is just called assigning it a value so now that we can store numbers in C let's see how we can store characters and letters so as you know from the introduction we have a string variable so let's call that name and make it equal to Aba please note that when you're defining a string and giving it a value that this value needs to be in speech mark if you put it in quotation marks it will not accept this because that's the notation to declare a Char which we'll get on to next so on the next line we can do a Char letter equals and we can't have something like this because the Char will only accept One Singular character so we have to wrap it around the quotation mark once you've wrapped it around the quotation mark then it will accept it so let's print these two to the screen so CW tab tab and we can just print these to the screen and if we just run the code you can see that we've got the values entered in here we can start to write stuff your name is and then we can output this and we can also put it on one line if we do a console right and a console right then maybe we can take the callon off and just have it space and we can say your name is ABBA and we've seen that additional a because that's the right line for the letter so we can space it out with an empty conso right line and they'll add a gap between them both there we go so now we know how to declare a string variable and give it a value and we can declare a Char variable and also give it a value just a quick recap when you're declaring and initializing string variables you need to put the value in speech marks but when you're declaring and initializing a Char you don't have to put it in speech marks you put them in apostrophes whenever you see apostrophes that that can only ever refer to One Singular character when you see a speech mark it could be one or more characters also things can be empty this just means the string is empty this is also a valid character it just means that we're storing a string but it has no value with a Char that's not exactly the same you can't store an empty character literal it has to be given something Charles get defaulted at back sl0 which is just a default character but don't worry about that too much now we'll go into Escape characters which is the back SL later on in the course for now just knowe that whenever you declare a string variable we need to put it in the speech marks and when we're declaring a Char variable we need the quotation mark So now that we know how to define numbers in C and to also Define strings and characters then let's look at how to convert between them both so let's take some similar code from our first video and we can Define it age the number the negative the Precision and the money and we give it the same values from the first video we simply just print them out to the console here and if we just run we can see them all but this doesn't help us cuz we're just statically typing in the numbers what if these were actually processed as string and we want to convert them into an INT so just above each of the variables we're going to make another variable so we can say a string text age equals 23 and then for the age what we're going to use is this function called convert to in32 and we can put in the string inside the brackets and what this is now saying is we're taking our string text Edge which is equal to 23 and we're passing it into this function convert to in32 and the reason why in32 is because an INT is by definition an in32 which is a 32bit signed integer so what we want to do here is convert for our text age into an int32 and store it back into our int and hopefully we should see the same value when we hit run 23 so now that's actually went from a string variable and then went into our integer and we've printed out as an integer and it's no longer a string variable now we can do the same for the other ones so we can have a string text big number and make it equal to this value just in the quotation marks now we're typing this value in the quotation marks we don't need to put the L at the end the L is just to tell the compiler that we want to use N64 if we take the L away then it's going to think it wants in32 this is not re applicable when it comes to text because we're going to explicitly stay on the next line we want to convert to N64 so the compiler already knows that it's in 64 and we don't need to put an L at the end now let's make sure this works and there we go so what we should end up with is the console should look exactly the same as how we had it at the start of the video but actually what we're doing is converting it from a string into the applicable value string text negative = 55.2 and then in here we can do convert to double add the text negative inside here and let's just run it to check and we still have the same value so it's going well okay a string text Precision make it equal to this and then instead of this we can have a convert to and in this case it's actually going to be a single and the reason why it's a single when you hover of a float the definition for a float is indeed a single so we can add that in text precision and we're just going to do the last one just check it all together text money equals 14.99 and then instead of this we can have a convert and let's have a look at this a decimal is indeed a decimal so we can say two decimal and then add the text money in perfect now if you run the line of code we can see that all of these values are exactly as we had them now they're being represented by their official descriptions Based On A String conversion as I mentioned before in the error video the problem you'll have with this is if this value actually has a character inside you will get a runtime error this can be fixed in the future when we look at how to resolve these errors and we can have exception handling and use functions like trass so we can try and avoid these exceptions occurring because when these exceptions occur the rest of our code does not run and it becomes fatal at this point but for now don't worry about this too much just get used to the notation and how these things work so this video we're going to focus on the booing data type so we can make a Boolean data type by saying Bo value equals true this Boolean value is literally just a true or false value we can store anything in here and maybe something like bull is male and we can just say it true and later on our code booleans are used to make decisions we'll cover this in the next section of this course but boings are mainly used for making decisions if one thing is equal to another thing then we can take another path or if something is true or something is false then we can do another path for example if you make an output to the user you could check if this value is true and if the value is true then you can address the user as a male and if the value is false then you can address the user as a female these are the kind of things that booleans can help us with and just like any variable if you want to assign it later on you can just assign it again and if we print these out to the screen just like that you'll just see the value is true and the values false appear on the screen as of right now in the course there's not a whole lot to do with booing just understand that they can hold a true or false value so now that we know how to define different variables and how to convert between them let's see how we can perform operations on different data types let's say we could have an INT age equals 23 and then what we can do to that age is we can say Age ++ and what this age will do is it will actually just increment age by one and if we do age minus minus it will decrement it by one so if we just print it out after and after this as well what we'll notice is there'll be no change CU it'll go forward one and then back one there we go went from 23 plus plus to 24 and then minus minus to 23 that's one of the important operators that you'll see a lot especially during the next section of this course so another way to be able to add one to a variable or anything to a variable we can replace this with age equals age + 1 and what we're seeing here we want age to have the value of itself added to one which will give us the same result is doing h++ another way of writing this is a quick shorthand is you can say age plus equals 1 these three things are doing exactly the same thing when you do an age Plus+ you can only increment by one and only one these two options give you the flexibility of having something like 10 these two are doing exactly the same age equals age + 10 and this is going to read exactly the same thing it's is when you use plus equals it will take the value of the current variable and add it to 10 which exactly what this line does to make it a lot shorter you can use age plus equals and then just put the value at the end just in case you forget to mention age twice so now if we just get rid of these two lines of code and we can just have a look and see if this runs so now the value should be 33 perfect and now as we said we're going to cover plus minus times and divide so just as you did with plus equals you can actually do a minus equals as well which will give us 13 and you can do a times equals which should give us 230 now if we try to do divide equals we're going to run into an issue it says 2 23 / 10 is 2.3 and when you take 2.3 and make it into an integer it's just going to truncate the3 and leave you with two with integers if you add two integers or take away two integers or times them you'll always end up with an integer if you divide two integers you don't know what you'll end with for example if you make this into 20 then you'll always end up with two but that's not always the case as you just saw 23 / 10 is 2.3 so if you're ever going to do any division it's best to actually make this a double cuz now that we do the division we actually get 2.3 which is technically the right value so you can add minus times and divide any variables that you want these are just demonstrated in int and double but you can do this the Flor the decimal Etc so let's have a look and see what the plus and the minus operators do when you've got a string variable so we can have a string name equals abber and then we can say the name plus equals is programming and then we can just print out name to the screen and see what happens so there you go you've actually just joined two strings together they're completely separate from each other and we've made them string together so if we try to do a minus equals you can't really remove from a string because a string is just text it'll be very difficult for the compiler and for the C language to be able to determine what's currently in the string and whether you can remove it or not this is not something that's built into the language this is not something that's built into the language so let's remove that and we can have the same thing with the TR now the problem with the Char is if we add a to B then let's see what happens to the output what it will try and do is actually get the uni code values for both of these items and try and add them together as integer variables so when you add a and b it will take the unic code value and you will actually get a capital A with a squiggle at the top and if we open character map you can see that this squiggle at the top is right here here which is unic codee 61 and 61 actually means 97 because it's 6 * by 16 + the 1 and b means it's 6 * 16 which is 96 + the 2 so you have 97 and 98 and if you add them two values together you'll get the hex code which is C3 just for this character so what you're doing is you're kind of adding them both together and you're producing weird results so unless you really want to do this then you should be worried about adding two characters together one more thing to note about when you're doing Plus+ let's bring another int variable we just say int I equal Z then we can do i++ and then if we print out I the value should be one which is fine what if we did i++ but we did Plus+ I so the value is still going to be one but what happens if we put this i+ plus straight into these brackets let's try and run it and you'll still get the value is zero that's strange because we've said I ++ and what happens when you do Plus+ at the front it will actually execute this and return the value of I and then do the Plus+ so if you actually print the value of I after you'll realize that now it becomes one after if you have had a situation where you need to increment first and then use the value you can use plus plus I now if you run it you should see the value is one twice the difference is that as the plus pluses before the VAR aable name it tells the compiler please do this action first and then return back the I if you don't want that behavior then use i++ finding the remainder between the division of two integer variables can be very handy when you're determining whether a number is even or odd let's look at an example let's have it in first Nome design the value of 10 and in second n and give it the value of three now if we just printed the screen first n divided by second n what do you think you'll get so the value of this in the calculator would be 3.3 reoccurring so we'd actually just get three because it's truncating it because of the integer so now what happens if we need the remainder between both of these you could actually work this out by seeing how many times three would be divided by 10 as close as possible and you'll see is the value is three and then 3 * 3 is 9 which will give you one left over for the 10 but that's a bit too long in our code so we have something called a modulus operator so we can actually change this divide for a percentage sign and what this will outut is it will only give us the remainder so let's say 10 / 3 is 3.3 as we've just said but the remainder is different remainder is exactly how you learned it at school 10 / 3 is actually three remainder 1 because 3 * 3 is 9 and then you have one left over to get to 10 so that'll be 3 * 3 which is equal to 9 and then one left over to get to 10 so now let's run our code and see if we do actually get one there we go so the best way to determine if a value is actually odd or even is to divide it by two so we can say 10 modulus 2 and if the value is zero then that means the value for first num is actually even if the value is one one then it's odd let's see how this works out if we had 10 modulus 2 then the value is zero because 10 can be divisible by two perfectly let's say we had 11 modulus 2 the closest multiple to 11 is 10 which is five and then we have one left over so you just have the remainder is equal to one and if we just keep going up in the chain we'll realize that it's the same pattern every single time you go up a value the value just toggles so when we print this out to the console and the value is actually zero that means the number is even and if we make the number odd on purpose and then rerun the code you can see that it's a number one now which means this value is now odd so let's look at a couple of examples and see if you can figure out the answer if we do a th000 modulus 90 what do you think the value will be and let's write a couple more if we do 100 modulus 90 and maybe something like like 71 modulus 10 so have a think about this in your head and see if you can figure out the answers pause the video and see if you were correct let's take a look at the answers so we can see we have 10 10 and 1 so the closest multiple to 1,000 from 90 is 990 so we have 10 left over to get to 1,000 and the same goes here the closest multiple of 100 to 90 is just indeed 90 so we only have 10 to get from 90 to 100 and in this case the closest multiple of 71 to 10 is 70 and we have one to get up to 71 therefore these two answers are indeed correct so now that we know how to really Define a variable by specifying that type followed by the name and given it a value let's see how we can do a very easy way of defining a variable so normally we would type in Edge but we can use this VAR keyword and what this means is the compiler will figure out what type it needs to be based on the value we initialize it with so if we just make a variable called age then it's not going to like it because you need to give it a value this doesn't give the compiler enough information to figure out what this variable is going to be just because it says age this is just text to the compiler this does not mean anything so if you make it equal to 23 then the compiler can see that this is indeed int 32 because it knows that so now if you hover over VAR it says in32 now let's try and do this for the big number our big number equals 90,000 and what will happen now is because it's defined as in32 it's going to say this is in32 as well and this is the same issue we had we'll move first def finding the long variable in the first video we need to explicitly give it an L just so this knows that it's N64 and now the VAR has updated to an in 64 instead of rewriting each one we can just change each to V and inspect what happens double double and now we have a float single single and finally the decimal we have a decimal and we have a decimal and the same thing goes for a string we can say V name equals ABA and we can have a v letter equals a there we go and they'll both register as there pickable data types as a string and as a CH and if we just print this out to the screen to make sure everything's working fine and run the code you can see that everything is exactly how we'd expect so just a quick recap you don't have to do this at the end of the day this will be exactly the same as writing this because when our code gets compiled down it doesn't matter what these things are cuz the compiler will deal with it however way it wants to this is just for us to read it in some cases if the value is very obvious like as we know an age cannot really be a point 23.1 years old no one says that in real life when you get asked your age so we can just assume that this value is going to be an integer and that's fine because that's an easy number that's an easy example but if we say we want a negative or a big number then it doesn't really tell us what we're meant to be like this big number could be somewhere up to 2.1 billion which is what an integer supports but in this case if it's going to be a big number and we specified the L then we're going to need a really big number bigger than 2.1 billion so in my honest opinion it would be very beneficial to only use VAR if it's very obvious what the variable is going to be and what it's been assigned to using VAR too much might hurt the readability of your code in the future because you have to inspect each variable individually to read what the type is going to be if you're scrolling through your code and you can see that this is along very quickly and you don't have to hover over it then it can improve your read time this is really important as readability of code will make more sense when it comes to Big projects when you have 20 30 lines just like this project then it makes almost no difference cuz it only takes a couple of seconds when you have big functions and big software when you work at a job then it's going to be very difficult to be able to find your way around and to understand what's going on especially if you're new to the code something very simple like this where you know you're defining a name it's very obvious and V will be accepted fine because you can tell that this is always going to be a string there's no other data type in C gets specified by a speech mark whereas when you're defining numbers it can be very very hard to understand what different data types that people are using throughout the code especially when these numbers are not statically typed in they might be inputs from the console from the user from a different function from anywhere so having good variable names along with their explicit types will be very handy to understand code in the future so now that you've understood how to make a variable let's look at a concept called constants so we defined a variable called vat and we set it to 20 just to represent the 20% vat in the UK now later on in the program we can actually change it to anything we want and that's because it's a variable variables can change in certain circumstances like vat you might not want to change it and you want to disable the ability to change it to out the code if it's done accidentally let's say for example you're making a banking application and you want to fix the vat and you don't want anyone else to change it you can add this keyword called const right before the Declaration and now when you go to reassign it you'll get an error message and it says at the left hand side of the assignment so anything before the equal sign has to be a variable property or indexer and in this case if you hover over vat it states that it's a local constant local because there's no access modifier before it and constant because we specified the cons keyword so now if we try and run the code we'll actually get a compile error because the vat cannot be changed so if we remove that and then we just print out to the console using CW tab tab and then we can put V8 in the brackets and press F5 and now we can see our 20 being printed so let's try and calculate some values using this code if you have an in Balance make it equal to 1,000 and let's say we wanted to calculate the vat based off this then you'd have to do a little bit of a complicated calculation you have to take the balance and because the V is a percentage we need to convert it from decimal to percentage so if we do times and then open the parentheses we can insert vat divided by 800 and just to make sure that this gets processed as double we want to write 100 D cuz right now it's in 32 and if we leave this as an integer division then we'll lose any decimal places and decimal places are very important when it comes to percentages so we put a 100 D at the end now you can see it says double so it'll actually calculate as if it was a decimal number so now if we print that to the screen so we can see here that 20% of the balance is indeed 200 instead of having to do this calculation each time what we can actually do is make another const this I'm making it a double cuz we're not sure what the output of this division will be and we don't want to truncate it so we want it as a double and we can say percent vat and what we can do here when we assign the value just because it's a constant it means that we can't change the value but that also means we can read it as many times as we want so we can say the percentage V is actually the current V that we've got specified here ided 100d this will give us the vat from a number form into a decimal form so now when we do this calculation if we duplicate this line using contrl D we can remove these entire brackets and literally replace it with percentage vat and you should see we get the same values perfect this can be very helpful in the future if you have things like version numbers in your code you can have version 1.0 and then if you ever specify this version later on in your code you can just change it once up here and it will change the rest this can be very helpful you'll avoid a lot of typ and you won't have to redeclare this value several times if you had three different occasions where you displaying the version number in your code then it's going to be problematic once you update the version number and you have to change every single occurrence and you might miss them so inserting it once and only having to change it once is the preferred option just to note with constants when you compile your code all the constants will actually do is do a find and replace so it will take this vat and find all references of vat and just drop the 20 in there so this is more of a feature for maintaining your code from a user and programmer's perspective rather than anything to do with the compiler because when it compiles it just removes all the constant anywhere and then you're left over with the literal values that we've gave it nonetheless this is still something very handy to learn and to use throughout your code first you want to Define a variable to hold your name so we can just say string name equals abber perfect so that's the first one achieved says Define a VAR able to hold your phone number so at first this could be quite easy we could say int number equals and then we can start to type our number in here so now that's our number completed let's move on to holding your age and we can just have an INT age equals 23 print variables line by line to the screen so we can use CW tab tab and type in name and then we can use contrl D to copy and paste the line then we can do number crl D again and then we can use Edge now if we run the code let's see what happens here we've actually hit a slight problem it says 1 2 3 4 for the number but I'm pretty sure that I started off with zero this is a problem with storing your number as an integer as a number zeros at the front don't really matter if we had 100 zeros here then it's not going to change the actual value the only time zeros matter is if it's throughout the number or towards the end that actually changes the number but if we have lots of zeros at the start then it doesn't change anything so what you actually want to do in order to store a number is you want to store it as a string therefore when you run the code it will actually return the zero that we typed in so now that we've accomplished all of these let's see how we can Define the variables using the VAR keyword so if we hover over these you can see that it's picking up that it's a string and a string here and finally this is an integer so what we can do very simply is just change these to VAR and then let's hover over the variables and just see if the tool tip reads the the correct data type string string and integer and if you run the code you should see no difference so in this exercise I want you to create and initialize two integer variables make a variable to work out the remainder output the remainder to the screen and then change the first integer variable to another number recalculate the remainder and output the new remainer to the screen so let's take this step by step so first we need to create an ize two ins let's say int num 1 equals to 10 int num 2 equals to two make a variable to work out the remainder so we can have an INT remainder equals to and if you remember how to do the remainder it uses the modulus symbol which is the percentage sign so we can say num one percentage num two now it says output remainder to the screen so we can use CW tabtab add remainder in and hit run and just for now we can see that the remainder is indeed zero if the remainder is zero then that means 10 is even because 10 modulous 2 gives us zero and if it's zero then that means it's even if the remainder was one then it would mean it's odd so if we try 11 remainder two we get one so 11 is indeed an odd number so let's change this back to 10 and then it says change the first inter variable to another number so just after here we could say num one equal 11 and then recalculate the remainder so we essentially just need to do this section again and we don't need to write into before these two variables cuz int is only used when you're declaring it this is reassigning the variable so we reassign variable num one to 11 and then we reassign the remainder to the calculation again and now we can use the exact same line of code above to print out the remainder to the screen now you can see that it's 0o and one it's zero because 10 is even and it's one because 11 is odd so far throughout the course we've been using console right line to Output stuff to the screen for example I can output hello my name is Aba and we can see it in the console the issue is so far we haven't really wrot any code to be able to read in values from the console so let's explore that option right now so in the console Library we have a console right line but what you don't realize is we can also use this console right line to ask the user a question and to let the user type something in so let's use CW tab tab and say enter your name with a colon and then end the quotation marks and then in order to return a value from the console into your program we need to use console. readline and if you hover over readline let's have a read at description reads the next line of characters from the standard input stream perfect this is exactly what we want to do right now it's to use at the end of our code just to stop the console from closing so we can actually see the output so if we just run this right now we actually get the opportunity to type but when we press enter our program closes this is because in this case we're simply using readline just to wait until the user has pressed enter so so our program doesn't close but what you don't actually see is this is returning as a string which means that anything that we type into here and when we press enter it actually gets a return back to the code but we not doing anything with it because we don't care at this point so now let's actually do something that will make us care about the user's input so we can make a new string variable and assign it to console readline and it should give us the ability to store Whatever Gets entered inside the console so we can just do string name and we can end the semicolon here and if you wanted to on the next line you could do name equals console. readline or if you wanted to have it all in one line then you can get rid of the semicolon and bring it up like this this is the preferred method as both lines were on top of each other and it wasn't really necessary to split them here we're doing a declaration of string name and an initialization and giving it the value of console. readline and this is whatever value the user is going to type in let's run our code and see what happens enter your name abber now when I press enter it's successfully stored abber inside this string name variable and now it's waiting at this line the console read line just right here so when I press enter the program closes so now that we've made a variable and not done anything with it let's print out to the screen to make sure that something's actually worked so if we use CW tab tab and we type in name in the brackets and we can run this code again and let's see what happens as soon as I type in Abba and press enter then this second abber is actually the variable printing out to the screen so here it says enter your name with a colon and normally when you see the colon it sometimes lets you type on the same line so if youd prefer the user to type on the same line then we actually have another function for that instead of using right line we can just use right and the difference between right line and right is the right line will actually have a Terminator at the end of the line to tell the console that he wants to push everything after it onto the next line whereas console. right will just print it out to the screen and not worry about any new lines let's try run it now and now we can type in and as you can see it's a little close to the colon so we can fix that in a second so you press enter you can see now that abber comes up on the second line so if we just put a space after the callon just to give it a bit of room now if we type in abber you can see that there's a bit of a gap and it's quite nicer to look at now if we press enter you can see that Abra has been stored successfully so what we can do now is maybe ask for your age so we can have a console. right enter your age age call on space and then do a string age equals console. readline and then we can have a age output as well and let's see how that works so we can say abber then say 23 and press enter and now we have abber stored within the name variable and have 23 stored within the age variable so let's try and output a string that's a bit more meaningful to the user let's clean this console up and see what we can do so we don't need to Output their result back to the console because they literally just type that in and we don't want to have this line because we just use that as an example so if we run the code right now it'll look better but it does look a lot more structured enter your name and then enter your age so now when you press enter the program will just close so let's try and output these two variables in a formatted fashion so as you now know we can use console. write to print a lot of stuff on one line so we can use console. write and we can say your name is and then add a space and finish that line there and then duplicate it down we can write name duplicate that down and say space and your age is duplicate that one down and then we can type in age and let's see what happens now abber 23 there we go so we actually have the name output and the age output all on one line if we all change these to right lines then they're going to be on separate lines and it's not going to look very nice so I'm just going to introduce you to a notation called string concatenation this is the notion of being able to concatenate two different strings which just means to add one string onto another as you can see this is taken up four lines of chorde and it's getting a bit ugly the better and easier way to do this is by containing it all within one line so we can have a console right line and we can take the first section your name is keep the space at the end we can end the speech marks and put a plus and then we can say name so now we've just added these two together if we just comment out the rest of them and run the code and you can see that they should be on one line there you go so we can say your name is ABBA and let's just keep changing the plus symbol so we can say and your age is another space and the speech marks and plus the age now we've got all of this contained within one line and it looks a lot better enter your name abber and into your age 23 and now you can see exactly the same output but reduced to one line as you can see these three lines are all stuck to each other so if you wanted to add a blank line between these two you can just put an MC console right line just in here and what this will do is simply just print the right line character to the screen which will force the console to make it on the next line just like so here's the console right line from the empty line that we just wrote and this is the console right line to Output the values so now that you've understood how to read values in from the console let's try and convert some values as I showed you how to do it earlier on in the course you can actually convert these strings into integers ideally you want to store variables in their data types as we covered before ages should not be stored as strings they should be stored as integers but if you try and change this to an INT then you're going to have an issue console read line will return back a string so therefore it can't implicitly convert from a string to an integer so we need to do this in two steps we can rename this to age input and then on the line underneath it we can say int age equals convert to int 32 and then add age input in these brackets there we go and now when we actually print the line of code nothing should actually change your name is abber and your age is 23 but now what's actually changed is we're storing the the variables in the correct format this is the ideal method because in the next section when we cover if statements you'll realize why this is very important if you wanted to minimize the amount of steps you need to convert this then you can actually move the console read line and get rid of the string input variable and we can just paste it straight into the bracket of the converter in 32 and you can get rid of the string input variable and everything will work the same AB 23 and now it's working exactly the same if this is many steps for you or if this looks too complicated then just please revert it back just to keep it the same way for the time being so now we've learned how to read in values from the console and output them back to the screen now let's see how we can use if statements to divert our code into multiple paths so in the previous section I told you that it is very crucial for our code to have this int Edge and the reason why is age is meant to be stored as a number and not as a string so we read it in first as a string and and then convert it to an integer using this function and store it into our age variable this is the reason why so our condition goes as follows we write the word if and between the brackets this needs to be evaluated to either a true or false value and then we can have the curly braces to tell us what to do if this becomes true so in this case you want to just check if our age input is greater than or equal to 18 let's say this was an entrance to a place that only allowed overes to enter so we can do a input which references the age input variable and we can use the operators equals greater than greater than or equal to less than or less than or equal to or not equal to so these are all the different options that we have we can say if the age input is equal to 18 perfect so now that we've read in the age input we can check if it's 18 let's just process a message in here says you are 18 and let's have a look and see if this works AB 18 now I press enter it says you are 18 but this is the problem with storing everything as a string and then trying to use it as if it was a number if I type in 18 followed by a space as you can see there's a blank Spacey now and press enter you can see that it doesn't come up and the reason why is it's processing it like this with a space at the end in order to avoid situations like this this is why we would convert it to a number and the reason why we're using equals to here is we can't use greater than or equal to because strings can't be greater than or equal to another string they can only ever be equal to or not equal to string is just text so if something equals to something then it's fine the only way that we can use these different operators is if we actually interact with our integer variable now let's see how we can use this so we can say age equals equals 18 and now you can see we actually reference it as a number now let's run the code if I do 18 Follow by space it still works and the reason why is it actually dismisses that space when it's converting to the integer so now age is stored as an integer and we can actually manipulate this a bit better so instead of saying you are 18 we can say you are 18 or Alo and now instead of doing equal to we can have greater than if we have greater than then we're actually dismissing the number 18 because if the age is greater than 18 so this will read like this and 18 is not greater than 18 so this will return back false what we actually want to use is greater than or equal to if the age that we've inputed is greater than or equal to 18 then you are 18 hence the equal to or greater than if you're older so now let's try and run this abber 23 perfect you are 18 or older let's change so let's change some other if statements to add some additional conditions so we can say else if and the only reason why it would come into this bracket if this condition returns false it will move down the next condition in the else chain if this was wrote as a separate if statement then this would run completely independently from this one if you're going to have chained if statements you need to make sure that you chain them correctly in this case I want to check if it ages between 18 and 25 and then move on to a different age bracket and these two things are grouped together so we should have this as an else if because with an age bracket you can only be part of one age bracket and not multiple so we can say if age is greater than or equal to 25 and we can copy this and we can say you are 25 or older now let's see what happens enter your name abber and let's just say that I am 35 it says you're 18 or older but I told it the program I was 35 now the problem we're facing is any value that's over 18 will always enter inside here and it will skip over this one completely this is not the behavior it that we want so what we can do in our if statements is we can use the double pipe which represents or or the double Ampersand which represents and and we can change some conditions in here to make sure that you implement some sort of range so we can actually have a range between 18 and 25 so we can say if the age is greater than or equal to 18 and the age is less than or equal to 25 and we can tweak this message you are between 18 and 25 and let's just run that for now and see what happens ABA 25 now it says 18 and 25 so now that we've got between 18 and 25 here we can tweak this to be greater than or equal to 26 if you're 25 will'll enter this condition and if you're 26 or older into this condition so let's test that now if we enter 35 now it says you're 26 or older that's perfect because now that we've implemented range checking it gives us the ability differentiate between different age groups more precisely let's Show an example of how to use the all so if we just have a block comment around all of this we can write an if statement in here and we can say if the edge is smaller than zero or the edge is bigger than 150 then we can output to the screen inv valid Edge and what this is saying is if we're less than zero and notice that this is less than zero so this value will actually start at minus one and this value start at 150 is minus one or less or over 150 then this will happen notice why it's an r one of these need to be true in order for this to be true when you've got an and both sides need to be true in order for this condition to evaluate is true so let's try our code we can say and we put minus one one and now it says invalid age which is perfect because this is our range checking and we can try again with 151 as it's just outside the range it will say invalid age and if we have an else on here we can print valid Edge notice there is no condition in here if you have an open else like this it means If This Were to return false it will always do this regardless of any condition in this case is it's perfectly reasonable to do this because we know that any values that are underneath zero or over 150 is invalid and anything between 0 and 150 is indeed valid what you can do instead is actually move these if statements inside here so instead of just printing out valid age we can actually check the age as well so let's run this now and we can say Aba minus one and it will only print out invalid age and then move on because once it reads this line of codee it will actually skip over the lse and finish up down here and now if you enter a real value you are between 18 and 25 so let's follow the path it got to here and realize that the range track was actually correct so it jumped out of this curly brace and went to the else because this had returned false we jump into this else and now we start checking if age is between 18 and 25 which it was because our age variable is 23 then it outputed this to the screen now if we do the same thing but have 35 instead then it follows the exact same path except towards here this will return back false and then it will check the next condition if age is over 26 then we'll return this so now let's just make a quick multiplication program using if statement to see if you can get the answer correct so let's just comment everything out and we'll start the next section underneath so let's make a console. write and ask the user to enter the first number and then we can say int number a equals convert to int32 and the value that we want to convert is a console. readline which is whatever the users entered from the console again if you're unfamiliar with this format you can just type it in manually number a input equals console readline and then we can put the number input in here now if you use shift and highlight these lines and press contrl D we can duplicate this entire section and we can say enter the second number change a to B change a to B and then finally change a to B perfect so now we've got into the first number and enter the second number and we can say our answer equal to number a multip by number B and then we can have a console. right value of you can add to it number A plus an X Plus number B and then finally plus a callon for the user to type in and then we can say string answer input equals console. readline and then int actual answer equals convert to in 32 and then we can have the input in here so now that we've got one number from the console the second number from the console we're just making a variable that will multiply them together and store inside answer and then we're just going to ask the user what's the value of number a times my number B and they can input that we store it as a string and then convert it to an integer and store the answer into actual answer so now just after the section we can write an if statement that says if the answer equals to the actual answer then we can say Well done and else and the reason why we don't need a condition this else because with equals to the only opposite thing you can have is if it's not equal to so if you really wanted to you could also right if answer is not equal to actual answer then in here you can say close but it was wrong you don't actually need this this is just for learning purposes because this will return back false if they're not equal to each other so this statement is just a given if they're not equal to each other then we can just assume that they're not equal to each other so so we don't need this additional statement if this condition evaluates to being false then that means they're not equal to each other we don't need this additional check to check if they're not equal to each other because that's a given if this returns back false so we can just leave this as an else let's try run the code 10 10 value of 10 * 10 100 now it says well done and let's just try that again and we can enter a different value 90 Clause but it was wrong so let's just have a quick recap so in the previous section we talked about how to input from the console and we generated this line of code which will output your name and your age in one line to the console and then we looked at how we can use these different operators in our if statements and we did some range checking to check if the age was between 18 and 25 and it would output something to the screen and if it was over 26 you'd get a different output to the screen and then we took that a little bit further and started using the r operator if the age is smaller than zero or it's greater than 150 then it must be invalid and if this condition returns false it must be between 0 and 150 so we can come into this L's bracket and inside here we can do our range checkin from the previous bit of code we can check the ranges between 180 and 25 and print a value or if it's over 26 we can print another value and you can keep changing these if you want you can have 26 to 40 and 40 to 60 etc etc that's up to you so this is just a quick little program to simulate multiplication program we can enter the first number using console. right and then we start it as a string and we put that string into the convert in 32 function to give us back an integer variable and we do exactly the same thing for the second number and then we make a variable to store both numbers multiplied by each other we ask the user what is the value of number a Times by number B and we give them an opportunity to type in a value we read that value in convert it to an integer store it as an into actual answer and then in our if statement we say if the answer is equal to the actual answer then we print well done to the screen double equals are used for equality and single equals are used for assignment don't get them mixed up we don't need an else condition in here because if this returns true then this will execute if this is indeed false that they're not equal to each other then we always want to do this section and we don't need to put an additional if statement inside here if you wanted to but it's not necessary you can have else if answer is not equal to actual answer but this is just extra code and it hurts the readability and it should be avoided if statements are one of the methods we can decide different paths in our code the next method we can use is called switch statements so let's write a little program so we can demonstrate this so we can just have a console. right enter a date of the week and we can have in date equals convert to in32 and we can place our console. readline inside the brackets so we take whatever the user typed into the console and then place it inside here and inside here we're going to convert whatever they've typed in to an integer 32 and star it into our D variable so if we just print this out to the screen to make sure it's working fine if we just type in seven we can see that seven is returned so it's all working so normally what we do is type if D equals equals 1 and then we can add the curly braces and use CW tab tab and we can print out Monday now if you run the code and try use number one then Monday works and that's fine and then let's do another lse if and we can say day equals equals 2 and then we can print Tuesday perfect so if we try that now there we go so now we have the ability to print out Monday and choose it to the console depending what day the week the user enters but since we're going to have seven different paths because we got seven days of the week then sometimes it might be better and cleaner to use a switch statement so let's have a look at the syntax so we can type in switch and then inside the brackets it's what variable we want to have a switch on so in this case we want to be using the day variable so we can add day in the brackets this is not a condition in the brackets this is just telling us what variable we're going to be using for the switch statement so let's open the curly braces after and inside here instead of having paths like this we're going to use cases so this can be translated to in the case of number one we can do this in the case of number two we can do this so let's try and see how it works we can type in case followed by number one and then add a call on and then we can type out our Monday in here and then we need to follow each case off by finishing the section off with a break this break is very essential and you'll get a syntax error if you don't put it in so now if we do case two and we do exactly the same thing there we go and if I dismiss the break then you'll realize that it says it cannot fall out so we have to use a break just the compiler knows that we want to break here the reason why this break is placed inside here is because what we can do is we can say case two and then add another one in here called case three and what this now reads is if we enter two it says Tuesday and if we enter three It also says choose it so what you can do is you can actually chain so this would be equivalent to writing if D equals 2 or D equal equals 3 now this is exact translation these two are exactly the same as of right now we have D equals equals 1 which is our case 1 and then equals 2 or equals 3 is right here if we go into the case 2 path it will fall in the case 3 so we're saying for this break is we want to end this section here so now if we just revert this back and continue the chain I'll just skip this part just so it's a little bit quick there we go so now that we've got all seven days of the week let's just see if it works let's try six and we have sat it so now we're kind of missing something from here the only thing we're missing is having our external else just in case the user types something invalid so normally we would write something like this enter value between 1 and 7 just to make sure that the user knows what they're doing now we don't seem to have anything inside here that gives us the opportunity to it in invalid so we have this keyword called default and it works exactly the same as the case except what this will do is this is basically the word that replaces else so we can literally take this line of code and place it again over here and add ourselves a break this is exactly the same as doing our L statement inside here if none of these cases match this variable then it'll go into the default and continue as normal so if we type in zero we should see the message twice because it's executing for the if statement and executing down here and let's do eight and you see the message again so now that the case statement is fully working let's just comment out the if statement and make sure that it's still works one Monday let's just try another one and we can do seven for Sunday so just a quick recap case statements are used by using the keyword switch followed by the variable in question and then if you want to check if this variable number is equal to something you put that something straight after the word case followed by a colon and then you can insert multiple lines of code inside here and make sure you end that line with a break if you want to chair in multiple like Dayal 2 or Dayal 3 then you can add the case above right here so the case of zero or the case of two it will do this little section so it'll print out choose there if the user enters zero or the user enters two of course in this case we don't actually want that after you filled out all of the code make sure you add something called the default the default is equivalent to an lse keyword in our if statement just to catch all the Val use in case the users type something incorrect and you want to let them know what they should be typing instead so now that we explored different paths in our code using IF statements and switch statements let's have a look at how we can iterate through our code an iteration in code is just the ability to be able to Loop and do a certain task so let's say we wanted to print high to the console several times then we just have to copy and paste it down and this will be five separate lines that do exactly the same thing this will essentially achieve what we want the problem is you just have exactly the same code copy and pasted so what we can do if we just block comment this line for the time being we can write something called a for Loop a for Loop gives us the ability to Loop a certain amount of times depending on the parameters that we give it so this is the syntax you can type for open the bracket and we have to use a variable so we can declare a new variable straight into these brackets we can say in I equals z and then have a semicolon and there's three different sections of this the first one is the variable decoration and initialization and the second one is the condition so in this case we want to do this task five times so you want to say I is less than five then we end that semicolon there and now for the third task every time this fall Loop goes around we want to increase I by one because we want to go in steps of one so we can do i++ alternative if you don't like using Plus+ you can say I = I + 1 or to make that quicker you can could say i+ equals 1 I personally just prefer using Plus+ and you'll see that everywhere else there is certain cases where you would actually you want to change this to a different value like i+ equal 2 and we'll show you that in a second so this for Loop now says we want to go from ials Z and once this condition returns back false when I is equal to 5 or greater then we want to stop this for Loop every time this forp goes around so when it hits this curly brace and comes back around we want to do this action and in this this case it's I ++ so if we just use console right line and print out the value I we can see what happens when the follow runs you can see that the value of I is increasing one each time and after the fifth time is increased the value is actually five so now this statement is false because the value of I is equal to five so therefore this is now false and the fall Loop is ended so now that we've verified that you can repeat it five times using this code we no longer want to print I we want to print our high so let's paste that inside the bracket and run the code now you can see that these two values will be exactly the same as printing it out to the console just like this but now we have a lot less code so let's have a look at another example we can say 4 in I equal 0 and we can say I is less than or equal to 10 and then we can do i+ equal 2 and then if we just print I to the console so what this is now saying is I want to go from zero all the way till 10 and I want to go up two times each time so what this will be achieving is printing out all of the even numbers between 0 and 10 let's try and run it now we can see we have all the even numbers printed out between 0 and 10 because we're going up in twos if we start this at one for example and still keep every parameter exactly the same then we'll be getting all of the even numbers between 1 and 10 11 is missing because our condition stops at less than or equal to 10 what you can also do with for Loops is you can let the user determine what this value is going to be let's test that so if we block comment this section out what we can do is we can append this little section so we can have a console. right how many times do you want to say hi can have a callon followed by speech marks and then we can say int Loop counter equals convert to n32 and we can have console read line inside the brackets how many times you want to say hi the user types in the value we take the console read line as a string convert it to an integer and St inside loop counter so now what needs to change inside here the five is what determines how many times that we're going to Loop so in this case we actually want to just Loop by whatever the user types in the counter let's just type five and make sure it works and if we just type one it works if we type zero however however it will just skip over the for Loop and the reason for that is if you're going from zero to I is less than zero then this is immediately going to be false so then the for Loop is just going to get skipped immediately there is nothing to do if the user is typed in zero which is perfectly reasonable and you can type in a really big number like a 100 and it will output them all to the screen if the user types in zero then nothing's going to come up so you always want to be able to let the user know if there's something wrong so we can say if the loop counter equals equals to zero or maybe we can change this to less than or equal to cuz it could type in minus numbers as well we could just say conso right line using CW tab tab sorry please enter a value above zero and then if this condition has returned back false then inside our else statement we don't need to give it an else if because if it's less than or equal to zero then we want to process the other values because it has to be greater or equal to one so when this is false this section has to be greater than or equal to one so we can just place our for Loop inside here and that's fine and let's try to run the code now and if we type in zero please enter a value of zero and if we just try any negative values we'll get the same message if you want to print additional code in here you can literally do anything you want you can even ask the user what they want to print up here and then you can replace this with a message for example we can have a string message and we can just change this to hello world and this could be something that you read in from the console so we can say message and we can put that in here and if we print that there we go so we can just say console. right what do you want to repeat and then we can read this in and actually it might be easier if we change this Loop counter to Second so if we highlight the section and hold alt and press down arrow twice we can move it down and say and how many times do you want to repeat it there we go so now what we can do is we can use this message inside here and then Loop depending on how many times the users typed in whatever so we can type in hello world get this exact value and we can say 10 times there we go so now this entire program is fully customized by the user's input so let's just have a quick recap so we started off this code by printing the console right line five times to the screen we wrote Our simple far Loop that went from in equal Zer to I is less than 5 and we did I ++ because we want to count up in ones you can place the high inside here and it'll printed it five times for us so now we've made our code from five lines down to just three lines for the for Loop and then we allowed the user to type in how many times that they want to repeat it and we change the condition from I is less than five to I is less than whatever the user has typed in installed within the loop counter and then we hit a problem where if we entered zero anything less than zero the F would just not run and it might look like some things went wrong so we added a little if statement in here to make sure that the user has entered a value above zero and if they haven't we can let them know we don't need another if statement in here because if this has returned back false we can assume that the value is something that we can work with we later tailored the program so we can change this message that was fixed to high to something that the user can type in manually so now that we know how to use for Loops let's have a look at while Loops for loops and while Loops still iterate through code but they're used in slightly different contexts for Loops are used mainly when you know how many times you can iterate through as in this example we're going to printer the console exactly 10 times but in a y Loop you might print until a condition is true for example if you asking the user to type a number and they kept typing in something else you don't know how many times it's going to take the user to type in correctly so in that case you would use a y Loop if you executing a certain amount of code and you're only doing it a fixed amount of times then it's always best to use a for Loop so first let's try and convert this simple for Loop that just prints I to the console 10 times just like so from zero all the way till 9 so let's comment out this for Loop and have a look at this Syntax for the while loop so we can type the world while and then in here we have our condition and then we can open our curly braces and while this condition returns back true it will always go inside the curly braces and when this condition returns back false then we'll exit the while loop so let's try and mimic exactly what we're doing inside here there's three sections of the for Loop we Define the variable that we're going to use for the for Loop counter and we give it an initial value we give it the stop dring condition and we give it how many times the value needs to go up every time the fall Loop iterates in the while loop situation we only have the condition available so let's take our condition and paste it straight into here and now we need to store our variable so just because it's a while loop when we can't store it inside here we have to do it outside the Y Loop so let's make it in I and we'll make it equal to zero so we've got our variable we've got our condition now we need to set I ++ so inside the Y Loop we can say i++ and then now we've achieved this entire line and successfully converted it let's try and put the console right line in and see what happens and let's run the code so it's going from 1 all the way till 10 and the reason why it's gone from 1 till 10 not from 0 to 10 is because the i++ is at the start let's move it down online using alt and down arrow key to move it down and let's run it again and you can see it goes from 0 to 99 and if we just block comment this out and undo the for Loop you can see that they're doing exactly the same thing so let's bring the W loop back and as you can see what we have is we've defined our I variable made it equals to zero while the I variable is less than the value of 10 we print the I to the console and increment I by one and we keep looping this until this statement returns back false and then exit the Y Loop and jump underneath the curly braces and hit the console read line and this is the output that we've got so now I've just copied the code from the if statement video and let's make this code a little bit better so let's comment out our while loop and our for Loop that was just used for explanation purposes and this is the code that you saw earlier on in the C we read in the first number start as a string use that string to convert to an integer star number a and Then star number B and these two blocks are exactly the same except you have have enter first number and enter second number and we store number a and store number B then we store the value of them both multiplied inside our int answer variable then we ask the user what's the value of both answers times together give them a chance to input their value convert it to an integer and then we check the value and print well done of close but it was wrong now if we run this code again and we type in 10 and 10 and we know the values of 100 but let's just type in 90 now this is kind of a problematic user case we've asked the user to type in a value and they've got it wrong and then when they press enter the program just closes there's no opportunity to Loop or try this again so what we can do is add a y Loop in here and we can say while the answer is incorrect we can keep asking the user to keep on guessing so instead of reading the input here let's turn this little section into a question what's the value of number a * number B and instead of allowing an input here let's just put a question mark and then let's add a console right line just to give a little bit of a gap and then in order to do our while loop we actually want to create a bolean variable just to track if the answer has been correct or not this is the section that we want to loop around in the while loop we want to read in the user's answer check it output a message and then give them the opportunity to read in another value so they can guess again while the answer is not not equal to the actual answer then we can loop around our code so we have to modify a few things here so we can't just take this code and place it inside the problem with doing this is the variables that we want to check answer is outside of this y Loop but actual answer is inside and the reason why there's a red line here says it does not exist in the current context because we're trying to check a variable that hasn't been defined yet so what we can do is take the decoration for the actual answer and place it outside here and make make it equal to zero and instead of redeclaring it inside the while loop we can take this in and get rid of it so we set the actual answers to zero set the answer to the multiplication while the answer is not equal to the actual answer then we want to loop around so we don't actually need another check in here this while loop will keep on repeating if the answer is incorrect so we don't need a path for correct and incorrect if this while loop still continues then the answer will always be incorrect so what we can do to double check is we can say if the answer does not equal the actual answer then we can place this message inside here and get rid of this branch and then after the while loop has continued we can say Well done so let's just read through the code while the answer is not equal to the actual answer and when this while loop first enters it's going to be true because you're going to have 10 * 10 which is 100 and the value of answer is zero so this will return back true cuz these two values are not equal to each other then we're going to ask the user to enter the value then we're going to read into the actual answer check if they're not equal to each other and then we output a message because we're asking a question here we want to ask another one using a console right Line enter your answer call on here we go so let's have a look and see how this works 100 100 what's the value of 100 * 100 and let's just get it wrong on purpose 90 call is wrong and now we get to answer again and we can keep answering this as many times as we want until we reach the correct answer which in this case is 10,000 and we've got the answer well done so to make the console look a little bit better cuz this is all in one block we can separate these with console right lines maybe after this line we can print out a new line and then after each guess we can print out another new line so after each guess we'll be down here we can just print out a blank console right line and just after after you ask them to enter the second number we can print another one here and let's just see how that looks 10 10 now it looks a lot better because you ask the user to input the numbers then you ask them the question and then you get the answer and then it keeps looping around like this so there's a little gap between each one so you can efficiently read it instead of it all being closed off together and now if you answer it correctly 100 now it says well done and when we press enter again the program now closes so that was using a while loop and now we have something else called a do while and a do while is very close to a while except that the while will only happen if this condition returns back true and a do while will always happen once and it'll check the condition at the end so let's have a look and see how this works so we write the word do and then we have the curly braces and then after it we have our while condition and let's just copy the condition from the old while loop and we can say answer is not equal to actual answer so as you can see with a while loop it will always check the condition first and then it opens the curly braces in the do there is no condition it will always do everything inside the curly braces once and then it will check this while condition if this condition is still true then it'll loop around and check it every time but it will only check it at the end while Loops will check the condition as the first thing it does and then check it every iteration so let's move our Corde down into here and let's just comment out our while loop just to see how this works and if we run it again to make sure it's working fine 10 10 90 90 50 and then finally 100 and it says well done so you could be thinking what are the differences between a while loop and a do while in certain cases you want the while loop to make sure this condition is true before even continuing in this specific case we always want the user to answer the question it doesn't matter if it executes once because actually that's the behavior that we want we've asked the user a question right here so we want to always be looping at least one time the while loop user case doesn't quite apply here because we don't necessarily have to check if they've answered correctly if they haven't even inputed a value yet we always want to be able to give them the option to do it once and then we check their answer at the end they could get it on the first answer 10 10 100 and it'll still be fine the same is true with a while loop but it'll B easier and it makes more sense to read your code when you have a while loop you can see that this bit of code depends on a condition whereas in a due while the first iteration does not depend on anything but the second and third and so forth depend on the condition so depending on your user case and what situation you want to use it you should either pick a while loop which will only occur through a condition or pick a do while that will occur once or multiple times after the first condition has passed so when you have if statements that are pretty basic you can actually make them quite easy to read through the conditional operator also known as the Turner operator so let's see how this works let's say we have an INT ede and we set it to a minus value and we know that this value can never be someone's age because it's negative but let's say that we have a situation where you ask the use it for their age and they've accidentally typed in 10 and we know that that value is not actually true so we could write something like this age is greater than or equal to zero then we can print out valid and then in the lse we can take this console right line and we can print out invalid so that means if we run our code now you can see that it says invalid and if we change it to positive 10 now it says valid so this seems a little bit long we are just checking one condition printing a value and printing another value if that condition returns back false so our conditional operator works like this we have a condition followed by question mark then the value if it returns true then the value if it returns false let's see how you can rewrite this if statement into one simple line so let's take this in steps these two values are both strings that we've typed in so let's make a string and we can call it result and let's make it equal to our Turner operator so the first step is to get the condition and the condition in this case if the age is greater than equal to zero we can follow that by a question mark and then if this returns back true we want the string to say valid and we can have a call on and if it returns back false then we want the string to say invalid and we can add a semicolon and then straight after it we can just have a console right line that just says result as you can see now that we get it twice we can verify one comes from the if statement and one comes from from the turny operator and now if we make this a positive 10 then you can see it both says valid so if we comment out the if statement and just see this running on its own just to double check there we go and because this is just returning back a string we can actually just take all of this code in the conditional operator and paste it straight into the console right line so you run the line of code now we get exactly the same thing if this hurts the readability of your code then it's best to just store it and then use it after if you can read this code and it's better for you in the long run later on you might want to dismiss this variable and do it straight inside the brackets just to save a variable and then print it out to the screen straight away it'll be better for memory if you just print it out straight away but if you're not familiar with this notation yet and you want to get used to it then that's fine as well so a quick recap we had an if statement with a condition and if this returned back true we printed valid and if it return back false we print invalid and this is pretty simple the only difference between these two paths is this string literal that we've typed into here so we can pull the string values out and place them in our conditional operator we can say string result is equal to if the age is greater than or equal to zero then we store valid inside result and if it's not greater than equal to zero then we can start inv valid straighten our string after we've start this value we can print results straight to the screen which will either give us valid or invalid when you're dividing two numbers you might get an ugly output just like this the user sometimes doesn't want to see such long decimal places and maybe you just want to prevent it to 81.3 in order to do this we need to use a format pattern so the language understands what we're trying to achieve so if we make another console right line what we can do is use string. format and inside the brackets we can give it a format and then the object that we want to format so in this case the object in the second parameter is our value so let's open some speech marks go to the next parameter using the comma and just type in our value and then inside the speech marks we want to type in the pattern if you type in curly brace as zero then zero represents the first value in this list we can do a space followed by curly braces one and then add another comma and we can add a thousand and what this means is value will get placed where zero is and 1,000 will get Place one is so let's run this and you see the exact same thing's happened plus a SP and now we have the Thousand which follows this part exactly if this is confusing don't worry too much about it I have the next section all about string functions so let's get rid of the one followed by the thousand and run it again and we should see the output being exactly the same there we go so now let's see how we can make this better in terms of decimal places so just after the zero and the zero represents the first value value we can add a callon and this callon will tell us what format we want the value to be displayed as we can type in 0. and what this means is all the numbers before the decimal place will get displayed and only two numbers after the decimal place will get displayed so let's try run this now and you can see that the code output is a lot cleaner one thing to note though by default this will round it up 0.37 becomes 0.4 not to worry though cuz this is what the user will see on the screen and it won't affect the actual value of the variable if we print out value straight after you'll see that the difference hasn't been changed it's still 0.3 in the original variable so that's one method of doing it what we can do now is just use contr D and copy it down and we can use different formats to show you what it looks like if we remove the 0 and then one of the zeros and leave it like this and it grains one decimal place each time you'll see what the output looks like we just have the 81 which essentially makes it into an integer because it's a whole number then we have 81.0 and the reason why it's 0 Z is cuz 0.3 will round down as it's under 0.5 the 03 is going to round down as it's under 05 so it'll round down to zero and then finally we have the 81.4 and just like before this will round down to4 and just like before this will round down to 0.4 this will round down to 04 let's say you wanted to get rid of trailing zeros because you don't want them then you can actually change this zero to a hashtag once you onun the hashtag then it will trim off any trailing zeros so what this means is it will try and put it in this format but if this format happens to be a zero then it will just keep it like this and if you just have 81 dot then it'll also get rid of the dot for you so then you just left with 81 it's really up to you as the programmer what you want want to display depending on what context I'm just giving you the options that you have available so let's say we want to work with money now and we have a 10d divided by 3D and what that value would be is somewhere between 3333 and this will be reoccurring cuz it's exactly 1/3 the reason why I've got D's in here is because these are registering as doubles if you type the value in normally it'll get registers an in32 and the problem with in32 is when you do this division it will process the division is an integer and then store it as a double the issue with that is in this case and in this case both values will get truned let me demonstrate if I remove the D from both sides and down in here it will see what the difference is and let's print out money and then's see what's happened in the first case this isn't actually an issue because we have a decimal place here which means this will be a double so an integer divided by double will give us a double but we just place the D here just so we don't forget and and it makes the compiler's job a lot easier cuz it doesn't have to convert it from an integer to a double and in this case we have an INT that's divided by an INT so we'll get 3.3 reoccurring but because it's processing as an integer then we just get three being displayed and this is not the intended result so let's just replace these back to D's and we'll see what we get now which is a 3.3 perfect so let's say that we want to display this as actual currency because you never see it displayed like this it's always to two decimal places just as follows so we can follow the same approach as above we can do string. format 0 call on 0.00 and the curly brace and then common money cuz that's the variable in reference and now if we run that let's see what happens 3.33 that's perfect and now what we can do in here because this is the pattern we can actually type in anything before after this and it won't affect the pattern just like so we've added some Extra Spaces in here so if we get rid of these spaces we can actually just place a pound sign in front of it and then let's see what happens when we run it perfect so now we actually have some money and we can say in here £10 /3 equals this and now our output looks a little bit better because we have some formatting now the issue is when we start getting into negatives let's see what happens so we can say 10 /3 equals something and when we run we'll see that the format is actually incorrect now you never see the negative symbol after the pound symbol it's always this way around in this case what we're doing is we're telling the compiler hey we only want to see two decimal places but always keep in this format the pound sign followed by the value and the value of money is 3 so it'll Place 3 inside here and then add the pound sign before it but we don't don't exactly want that so we can add something called a culture info but we can also give it some other formatting some other way so let's explore some other options if you use money to string then what we're actually doing here is using the double variable and converting it to a string and we get passed back a string representative of this value and that's fine and when we run the code you'll see no difference between these two at this point they're both being converted to Strings but what we can do in this case is when we open these brackets it tells us there one of four what does this mean exactly so in our two string function we have four ways that we can call this function the first way you give nothing in the brackets and if we press the down arrow the second way is to give it a format provider the Third Way is just a string format and the fourth way is both a format and a provider so we'll use all of these in a second but let's explore the easiest one if you add a string in there which gives us the third overload string format and we can just type in a Capital C let's just see what happens perfect so now we have the best format displayed to us and the reason why this works is the C program will recognize that the format of C is telling us that we want to display currency so then it's going to your local machine and figuring out where you are based on your date and time just down here when you have adjust date and time it will figure it out based on this we have UTC time and we have the date and time listed up here based on that information it can figure out that we are indeed in the UK and we want to display a pound sign and because the program knows that it's 3.33 it'll put the pound sign in the right location so now that we've explored C let's have a look at the other ones that are available so if we use contrl D and copy this down three times we can use C 0 C1 and C2 and now if you run this again you'll see what the output gets you c will get your currency in its most native form which is what we're used to using in the UK C zero will only return you back with the whole number C1 will give you one decimal place and C2 mimics C on its own as they're displaying the same values now this is where it gets interesting if you want to display a different currencies then you're going to have to use this thing called a culture info which will be able to retrieve back different currency formats based on a certain country code that you give the function so let's have a look and see how that works if we scroll to the top we can add a new library called system. globalization inside globalization we have a culture info so let's see how we can tailor these to make it look a lot better if you're worried about different currencies so we use CW tab tab and we do the same thing money. two string we add our C and this is where our format provider fits in so we can start typing culture info it should come up like this press enter and inside this is a class that's why it went green if we press dot then we get the current culture the current culture will decide based on the machine that the program is running on if this program is running on a cloud computer and the cloud computer is stored in Europe then it might display euros and if it's stored in America then it'll display dollars so you want to avoid using current culture if you're going to scale your program worldwide in the case of this example I'm going to leave it because as you you can see when I run it it will display the same thing as the other ones because this one will also recognize that my current culture is UK and I'm also telling it to use the current culture so in both of these cases it's figured out that my current culture is indeed the UK and it started using the pound sign but let's say we want to give it a different culture then what we can do if we duplicate this line using contr D and remove this section just after the dot we can actually say create specific culture and inside the parentheses we can actually add a string and it says here a predefined culture name or the name of an existing culture info object the name is not case sensitive so in the case of the UK you have English GB and now we need another bracket at the end and then if we use controll D to copy this down we can change GB to us let's run this again and see what happens these two don't actually output anything different because we're just doing the normal culture and then we're telling it to find the GB culture which is exactly the same thing for me so we get these two values exactly the same and apparently it's picking up that in the US you have brackets around your negative values which I can't personally validate but this is how it's showing up so let's try some other cultures and see what happens so we can try Au for Australian then you can see that they actually use a negative followed by the pound sign and then the value so even though they're both in dollars one's US Dollars and one Australian dollars and apparently the US uses brackets for the negative values but Australians use the negative value like we do so let's just have a quick recap so we can display the value just like this but we'll have a problem with multiple decimal places we can use these former options to give us zero decimal places one or two decimal places and then when we use this format the problem with it was when you display negative numbers you get a nasty form format where the negative value actually comes after the pound sign which is not correct and you don't want to Output that to your users instead you should use the C format to tell the compiler that you want to process this as a currency currency processing is better because the software will understand that the value you're trying to represent depends on a certain strict format just as follows you don't want the negative to be here instead of before it because that doesn't look very nice to the end user alternatively you could use this CI info if you're going to scale your program scaling your program means that it's going to live on servers and this culture in for especially the current culture depends on where the program is being run on because it depends on the system time different servers will have different dat times set because they'll be in different countries so you want to be careful and if you want to display in a certain currency you can create a culture specification and pass the country code inside the brackets and then you'll get the correct output and it doesn't matter where your program lives if you always want to generate in pound symbols then you always use create specific culture and always specify NGB upon doing so you'll always get the pound sign and it doesn't matter where your program lives so throughout this course you've seen this notation a lot print out value using console right to give the user an opportunity to write on the same line reading their value as a string and store it in a variable and then use that variable able to convert it to an integer 32 and we're passing the string input inside here and then we convert it to an integer if we run the code you can see that this actually works perfectly assuming you actually enter a real number like 10 we press enter and it works and it outputs back to the screen using this console right line and if you press this restart button we can start the program again and let's say we accidentally type a character like L and we press enter and we've get a format exception now this is problematic because our program will now close if we press continue it doesn't even hit this line or this as soon as it hits the exception in here our program just closes if we use debug start with our debugging and now we're actually running the program outside of visual studio so we won't get that pop up when the error happens let's see what happens if we type this in now we can say 10p and press enter and now we get that the program stopped working you've probably seen this pop up a lot throughout Windows and different versions of Windows because when a program has a fair little error or an exception you see this popup appear and the only thing you can do is either debug or close it normally the debug option isn't available but because this is a c program and it's made through Visual Studio and the visual studio is being installed on the system then it gives us the option but really all we can do here is just terminate the program it doesn't matter what happened because we can't recover this if we press close then it's literally just going to close down it's going to tell us the exception and then press any key to continue and it's as you press any key then the program just closes so this is very fatal for our code since if we had some precious data stored in here or anywhere else in the program it is now lost before we can do anything this is problematic and we want to avoid this the best way to do this is to use something called trass right here the program is assuming that your string input is a perfect input and then you're immediately converting it to an integer now like I said what if this had 10 H in it the program is going to cause an exception and then the program is going to close so let's see what we can do with this trip pass function so the notation is int. trass the first parameter is a string s string s is a string containing a number to convert so what this tripassure equivalent a return value indicates whether the conversion succeeded okay perfect so we'll get into that in a second so our string s is a string containing our number to convert and in this case we want to be using the num input so we copy and paste that down and then we add a comma because we have more than one parameter now we have an out int result when this method returns result which is our integer contains the 32bit sign integer equivalent of the number contained in S and S in this case is our first parameter which is num input if the conversion succeeded then we get the value inside our result or zero if the conversion failed the conversion fails if the parameter s is null or string empty is not of the correct format or it represents a number that's less or more than the maximum value that the integer can stall this paramet is p uninitialized any value originally supplies in result will be overwritten let's dive in to see what this means because it's an out in result what this means is we can actually process a variable inside here like in Num so we can say out num and what this will do is when this line executes it will try and convert num input and place the value inside num so we don't need to run this convert anymore we can just specify that num is equal to zero so we've read in the string that contains our 10 H and we have our num that contains zero let's just remove this console right line so now we have our variable set up let's see what happens if we do a conso right line and just print num after this let's see what happens to the code so if we type in 10 H and press enter the value of num is zero but what you notice now the program hasn't caused because it's tried to pass it instead of just passing it automatically and then cause an exception so the reason why Try pass is called try pass is first it tries and then if it succeeds this will contain the value and if it doesn't succeed this will contain zero to know if the number has actually been converted we actually have to use the bull return value so what this means is because it returns us back a bull we can store it inside a bull and we can give it the name of success bull success equals into. trass we try and pass the num input and we place the value inside num the reason why having this bu success is very very essential let's say for example the user actually enters zero so technically as of this point num zero is actually correct because we've got zero and we initialize it to zero but of course after the trass runs this is still going to be zero now we don't know if the value zero is because this has succeeded or the value is zero because we initialized it to zero let me demonstrate if I type in a zero here is this zero being converted because this was successful or is it presenting me zero because this has been initialized to zero and the only way we can know is because our trip pass will return us back with true if s was converted successfully otherwise false we can actually write an if statement in here if success open the curly braces and we can start to type something in here so we can take our console right line and place it up here using alt and up Arrow key and then in the L's we can say failed to convert so now we have a mini setup here if it's been successful we print out the number if it hasn't been successful then it'll go into this path and it'll print fail to convert let's have a look and see how this works now if I press zero and I see Zero that means it's followed down the success path and this zero actually means it's converted my input instead of just the value that it's being initialized by if you run the code again and type in 10 hit then we actually see it says fail to convert and why that happened is we have 10 H appear and then this will return back false when it tries to convert num input and then after it hits this line since success will be false it will Dodge this path going into this path and output fail to convert what you can do if you really wanted to is you could wrap this around in a while loop so let's see what we can do so we can specify a bu's success and make that equal to true and then we can add a while loop with success in there and then open the curly braces and put all of this code inside here now we're going to have some errors because we got success twice but what we can do which will be a lot easier is we can place this straight inside our bracket and the reason why is because this returns us back at Boolean so we don't need to store it and then use it another thing we can do is instead of having Inn and then num right here you can actually make this a declaration as well so if we just remove this value we can write out Inn and this will do exactly the same thing it just uses less variables while our success is true we come into here and run this code if we fail to convert then we still want it to be true so we can loop around if we've converted it and the value is successful then we can actually make our success at this point false cuz that will stop the W loop from going around let's run the code we can type typ in 10 H 10 a 10 a etc etc and as soon as we type in a real number then it'll print out and the while loop will cancel and now right here we're set on the console readline now if we press enter the program will close so let's have a recap we use in. TR pass so we can try and pass a value before the program assumes that the value is in the correct format we give it a string variable and it returns us back with a fresh new integer called called num or whatever you want to call it inside here we can place this straight inside the condition of an if statement because this function returns us back with a true or false value otherwise known as a bull if this has been successful we stop the while loop and print the value out to the screen and if it hasn't been successful then we print fail to convert and because our success is still true it will L back around to the start of the while loop and ask the user to input another value to try and convert this Loop will only exit if it's indeed being successful and the only way it can exit is by having the success being equal to false and the only way that can happen is by having a successful conversion the use of trip pass in every program is very essential because if you have a fatal exception then your program will close and you will lose all the data the problem with that is you might lose anything that you haven't processed yet at that given point in your program so you want to try and use trass because you'll avoid any potential exceptions and you can let the user know if the conversion has been successful or not and write yourself the same while loop just like this so you can tell the user hey you input it incorrectly but this is how to do it right and make sure that your program doesn't execute incorrectly and make sure your program doesn't just close unexpectedly and then an error will be caused in this exercise I want you to print out some sort of times table and what I mean by this is you want to ask the user us to input a number for the table and then write a for Loop to print out the x * table X is dependent on the value that entered if they enter 10 in here then this will be the 10 times table let's get started so we can have our normal console. write enter a number and then use our int number equals to convert to in32 and we can say console. readline because we want to read whatever the user types in then we have a four into I equal 0 I is less than 10 we're only going to print up to the 10 times table so 1 * Something 2 * something all the way up to 10 times the value that they entered immediately we acknowledge an error here when you do your 10times table for example you do 1 * 10 2 * 10 and so on and so forth the issue here is we're going from 0 to 10 but because it's less than 10 we're actually going from 0 to 9 so let changes to one and then less than or equal to 10 in both cases we were actually looping the same amount of times the issue is this was starting on one and the other one was starting on zero and the first one was finishing on nine and this one's finishing on 10 and we want them to go from 1 till 10 instead of from 0 till 9 even though that's the same amount of iterations it gives us different values so in here we can just have a console right line and this is how it's going to work work we're going to have our first number times by our second number and that's going to be equal to something so our first number is our value of I cuz that will say 1 time something 2 * something and so forth our second number is whatever the user has typed into the calculation which will be number and our third number is going to be the actual result of the calculation which are these two times together so we can have I star number and that should be it let's run it and give it a shot we can do our 10 times table and if we press enter you can see that it's fully working this will be our I variable going down the side the second number is what the user typed in and the third number is this multiplied by this gives you the output let's run it again with a bigger number and it seems to handle okay and because this is an integer you'll expect to work okay up until around 2.1 billion which is a big number for some times tables anyway so just a quick recap we Loop through from 1 till 10 instead of from 0 to 9 because we made sure that when we do our multiplications we don't want to start the value at 0 * something we want to start the first one at 1 time something and we don't want to end at N9 we want to end at 10 so using one and less than or equal to 10 will get us the values that go from 1 till 10 and that will make our output look a lot more concise we're using conditional format in here adding the zero and curly braces and then the one and then the two and in order to insert the values in it's a comma delimited list after the speech marks the first one goes in the right order zero is I one is number two is I times the number running that code we will get this output there you go so in this exercise I want you to have a look and see if you can make the Fizz bu game Fizz bu game is one of the most popular interview questions you'll come across and the way to do this is to create a for loop from one to something in this case I'm just going to use 15 and inside the followup you want to decide if the number is divisible by three and five then you want to print FS buuz if it's divisible by three then it's Fizz five it's buzz and if it doesn't fall into any of them categories then you want to simply just print the number out to the screen let's get started so we can have a four and because we know how many we want to do we want to do in I less than 15 I ++ and then inside here we need to use the modulus operator which is the percentage sign so if you remember from the tutorial in order to figure out if a number is odd or even you could do the number modul is two and if that value is one then it must mean it's odd and if that value is zero it must mean it's even but what we can also differentiate from here is if 10 modulus 2 equals 0 then that means that 10 is divisible by two but also it is even and if it's even that means it's divisible by two if it's not divisible by two that means it's not even and therefore it's odd so in this case if we try to divide three and five we can have the same calculation but we can work it out differently so 10 modulus 3 actually gives us a value of one because it's three remainder one so if this value is anything other than zero then we know that these two were not div divisible by each other 9 percentage 3 equals 0 which means it's divisible by it so in our if statement we can say if I which is the number that we're currently up to percentage 3 equals equals to zero and because we want to check for five as well we want to say and I percentage 5 equals equals to zero and that means they're both divisible by each other so we can do a console right line and we can say fiz buzz and then in else if we're going to check if it's three and we can repurpose this exact condition because this just checks if it's divisible by three and then we can print Fizz and then if we copy this exact structure down and change this to a five to check if it's divisible by five then we can print out buzz and in the worst case scenario where none of them get applied then we can simply print I to the screen and actually there's no point in starting at zero because normally these start at one so we'll just do one and we can make it 15 by making it less than or equal to so instead of before it was actually going from 0 to 14 now it's going from 1 to 15 and they will tell you this in the interview they might say counting from 1 to 100 print out all of the Fizz buzzers so let's run the code and see what's going on 1 2 fizz fizz is actually three so three is divisible by three then you have four and then five is divisible by five you get buzz and six goes into three so you get Fizz nine you get Fizz because it's divisible by three then 10 / by 5 gives you buzz 11 12 goes into three so you've got Fizz and finally when you hit 15 it goes into three and goes into five so we get Fizz buzz and the way to increase this to 100 is by simply changing this to 100 if you need to and you can scroll through the entire input and you can see all the history if you wanted to make this slightly efficient what you could actually do is store the booing values for these calculations before you can store the values for these calculations before so we can say Bo 3 div equals false and bull 5 div equals false and what we can do at the start of each of the for Loop is we can say three div equals this value and five div also equals this value and then every time we find a calculation for three or calculation for five we can replace it with either three div or five div so let's change this one here and this one here and our five here and here and because these are values now we want to actually store them as true or falses so we don't need to check if they're equal to zero so we can just remove them so we can say if three div and five div are both true and they'll only be true if these two are both zero now if we run the code and just make it 15 again just just we have a Shor output you can see that our code is exactly the same the reason why this is more efficient is we're only doing this calculation twice whereas before we were doing it twice for three and twice for five now we're doing it once storing it and then making use of it this is a lot more memory efficient than having to calculate it every single time it computes a lot faster and it's better for readability if the rules of the game happen to change and this was divisible by four or six then you could just change it very easily whereas in the previous example you would have to change it in every single case in C when you're constructing strings that have backslashes you're going to need to use double backslash and the reason for this is the first backslash is an indication that it's actually going to be an escape character you're going to put an escape character in and then put the character that you want to display and the reason for that is they've chose backslash as the designated character so so you can use backs slash and then a backs slash to show one backslash only and what this means is it will use the first backs slash as a reference so it knows that it's going to process the next character as an escape character I want these Escape characters are you can have things like T for tab n for new line and you can even use speech marks because if you outputting some dialogue and you wanted to say something like this he said and then you added your own quote in there if you want to put something in quotes then you can't because the speech mark dictates that this is the end of the string literal that's why it's gotting it off like this and then now it's not recognizing that something is just wrote here and what it's actually doing is you've got two strings specified one that says he said space and one that's just empty and then you just have this something that's just in the middle of course we actually want to insert the speech marks within another pair of speech marks this is where the backslash comes in so you can insert a backslash before here and this is now acceptable and the same thing with the normal backslash because the backslash character is also going to be the Escape character then you need a double backslash so then that equals to a single backslash when you print it out let's Show an example so we have C colon SL slash which will return us back a single slash but visually right now it's a double slash but when it gets processed or outputed to the screen you'll see that it's a single slash so this common example is when you're constructing a path together and you want to use backs slashes to denote the different directories so let's output this to the screen and see what happens and as you can see we have a single backslash because of the Escape character we don't see both of them and if we print the Spree out to the screen just to show you that as well then we can see that there's only the speech marks around the something and we don't have the backslash you can tell when an escape character is being used because it goes a slight hint of yellow instead of the normal color for a string so now that we've worked out that this is how this works let's see a way that we can undo this to make it easier for us so you've used the dollar sign for string interpolation and you've used the plus just to concatenate two variables together and just as a quick example it looked something like this your name is and then the name variable and using the plus you would say your name is followed by a space and the quotation marks and do plus name that's fine and now we have another one so similar to how we placed a dollar sign before the speech marks we have a Verbatim identifier and what this means because it says verbatim it just means whatever you see is whatever happens so let's try and Define this path a slightly different way but still containing the exact same information that you see when you print out to the screen so let's have a look we can reassign the path value and just before the speech marks we can put it at symbol and this at symbol means it will actually negate all of the Escape characters it will process a single backslash as a single backslash let's take this line of code and place inside here now what you see is that tint of yellow is no longer there so if we print this past to the screen let's see what happens we actually get the double backslash because it's ignoring all the Escape characters which means if we take them all out this actually looks exactly how we want and you don't have to worry about the Escape characters there you go these two are identical even though one is being displayed using Escape characters and ones using the verbatim identifier please note that if you're going to use the back slash n for example and I'll just demonstrate at the end of this new line test and if we run that code again you'll see that it's printed the path on one line the back sln has made it go on to the next line and now it's printing new line test on a dedicated line that's fine the problem is if you use a back sln or a back SLT or any of these Escape characters during the at symbol then it's going to process it as literal characters which means you can't mix a back n with an at symbol AS this is just taking the text verbatim so if we try to run the code now you'll see the back sln will actually appear in the code if you wanted to do this then maybe you could remove the back slash n and add a plus at the end and then make another string that just has a back sln and then this string will not be processed as a Verbatim string because we don't have the at symbol right before it so then we can have the exact same thing here just to show you this so now these two are identical again just as shown here and as shown here the difference being that we can't specify a back sln in the same string we actually have to concatenate them together because of the verbatim identifier so let's have a look at speech marks so if we have a string name and we can make this equal to hello and then someone and we said before that we have to use the backslash so we can activate the Escape characters and that will work and if we just print that to the screen to make sure then we get hello someone in the speech marks if we add the verbatim identify at the start then we see we've got an error it's trying to process it differently this is a little Quirk with the verbatim identifier if you want to insert a speech marks you actually want a double speech mark on either side the double speech marks will get processed as a single speech mark because it's within a speech mark the verbatim identifier needs to know that you're specifying a speech mark and this acts as a same reason why you have a backslash here it's slightly quirky doing it this way but it still works as per you expect and when you're specifying something like name and we can say hello someone so let's print name to the screen and make sure it works in this case we don't actually need to specify any sort of Escape character because the quotation mark is a separate character to the speech mark and it doesn't interrupt anything by placing a quotation mark inside the string just represents that as its own character let's run that and make sure it works there you go so just as a quick recap Escape characters are very essential because we can use things like back SLT to give us a tab character in our console output this can be very helpful cuz you can almost mimic the use of columns inside our console output you'll notice that back sln is used quite a lot in the console output so you can separate lines without having to use multiple console right lines if you have a single backslash you can't have it on its own if the string is not a Verbatim string you have to pair it with another character otherwise you will get a syntax error if you want to use the verbatim string then you can put an at symbol before the string definition and then it will ignore all of the Escape characters for example using back sln within these speech marks will mean that the back SL n will literally be printed to the screen and you won't get the new line functionality that back sln provides when you want to print speech marks of the screen using the verbatim identifier you have to use a double speech marks in order for it to show up and as you can see it slightly goes yellow and that's the similar notation as using Escape character when you don't have an verbatim string if you're using other characters that are similar to a speech mark like a quotation mark because this doesn't interrupt the syntax of the language then this is fine because a character can just be inside a string and to the compiler this is just a character even though they are very similar the quotation mark doesn't affect the speech mark the most common approach for outputting values to the console is by having this format you type something in as a static string and then you add a variable to it but when you're doing long sentences this format can get messy quite quickly so this will just output both of these on separate lines the name followed by the name variable and the age followed by the age variable I just have a console right line to split up these two sections just so you can see it visually in the console so if we run this code you can see that both the outputs are exactly the same and the reason why is we can use this back sln what this back sln is doing is inserting a new line character just where my cursor is here which is forcing The Edge to jump onto the next line the reason why this is a slightly different shade to the age text is because it's an Escape character back sln means new line we'll explain this in a further video in this section so don't worry about that just know that it means that it produces a new line so as you can see since we're adding the name followed by the name and then the age followed by the ede then it's getting a bit long and a little bit tedious it's not too bad in this case because we're not really printing out a sentence we're just going straight to another line but let's see what this is going to look like if we start dealing with multiple pits of data your name is followed by the name and then we can add a comma and your age is and then add the age and as you can see while we're structuring a sentence then it gets a little bit long we have to remember to put in the spaces otherwise our code is going to look funky when we print out to the screen and the reason for that is there's no spaces between the name and the age variables so let's put them back in and make sure the output looks all right now that the output looks like this let's explore composite formatting and what this means is we can get rid of all of these plus symbols and replace it with curly braces so let's actually output this string again but just output it completely static your name is abber and your age is 23 and now if we've run this you'll see that both outputs are identical this is because I know the values for the string variables up here and I can input it straight into here so now that we know what our sentence is going to be we don't need to add any pluses what we do need to do is remove our variables so in the case of this sentence our name variable is here and our age variable is here so we can replace this with this curly brace notation we can have curly BRAC and then we want to start this value at zero throughout the string you want to have these values starting from zero and going up incrementally from left to right so our next variable would be our 23 and we can store it like this now that it's got your name zero and your age one let's see what happens when you output it then we just get this and this is very confusing that's because we're not done yet so now that we've got our string typed in we can actually place a comma in here and now it lets us put any object in and any object could be a string an in a double or any data type so we want to insert the values inside here going from left to right so our name is first and then we do a comma and we type in Age and what this now says is the name will get replaced by the curly brace zero and the age will get replaced by the curly brace one so now if we run the code let's see what happens and now you'll see that the output is exactly the same and now look at the difference between these two lines you'll see that these multiple amount of pluses are not confusing and let's say you forget this one then you're going to get a syntax error and it's a bit frustrating to keep on typing when you're trying to join things together now we can clearly see that this flaw is like a sentence and this space here looks very unnatural but this space here looks like it's part of the sentence which makes our code a bit more complete and the same goes if you want to print something like this and let's convert this one so if we copy this line down into here and we just remove the spaces then it can look something like this name followed by the name we don't actually need this space here because we're going to be going into a brake line we can replace our name with curly braces zero and our age with curly braces one and then straight after we can type name and age and if we output this we'll see it's exactly the same there we go so just a quick recap print ing strings and any other variables to the screen has been normally achieved by doing a string followed by a plus and then adding another variable to it adding more than one can be a little bit complicated and hard to track of all the spaces that you're going to put in and you might accidentally miss one of them like this one here or this one here are very crucial to the output if you miss this one then it's going to say is followed by the name all together with no space we then introduce composite format in which lets us use this notation of curly brace Z and curly brace one to give us the ability to store some variables outside of the string and then insert them in dynamically we took both of these examples and made them down here using composite forming so let's explore a new method of concatenation that makes this look a lot better the reason why this is an issue is you have spaces in here and sometimes you might forget these spaces and it could mess up your program this string here looks very unnatural because you're forcing the space but when you run it you'll see that it is actually what you expect the spaces are complete and it makes perfect sense but when you're writing it it kind of looks a little bit stupid because you're forcing the space and then adding a plus and then the name and then another plus and then another static string and this just get a little bit long to type it's fine when you have a smaller sentence like this but when the program starts to grow it could be a little bit problematic and you'll have a lot of syntax errors when you forget to type in all the pluses locally this can be fixed let's duplicate this line down and let's see what we can do so we have this thing called string interpolation and it uses a dollar sign as a reference we can place the dollar sign before the quotation marks and then what you can do is you can actually keep this as one big sentence so let's remove all of the values and have it like this so now of course this actually doesn't print our variables because we've just replaced it with text so if we just run this then it's completely messed up because now we're not using our variables and this can be easily fixed because we've used our dollar sign now we can actually wrap our variables in this curly brace and now you can see it's went white if I double click on it you can see that it's referencing the variable wrapping the variables in the curly brace means that they can actually be processed variables even though they are still within the speech marks please do not remove the dollar sign because now this will be interpreted as string text as you can see here putting a dollar sign at the start will make into string interpolation and then we get the ability to have our brackets this can make string concatenation very easy to do because you don't have to worry about all the pluses and adding them together and don't have to worry about the spaces as well this looks more like a natural sentence and what you can do for practice is you can actually just type out the sentence your name is AB your age is 23 and then from there you can actually just break down the variables and know that you'll need one here so you can replace that with name and then you'll know you'll need one here so you can replace that one with age and then you can place the dollar sign right at the end and then there you go you have your solution this method means that it's a lot cleaner to read easier to maintain and make changes in the future and that's the whole point of programming if your code base is very difficult to go around and understand what's going on and potentially make changes in the future then you've already made a bad step and you don't want to get into these nasty habits it's fine if you're just going to have something like this where it's not really complicated at all a string plus another string that's quite simple and that's fine you don't have to go the extra effort to put in the dollar sign and wrap it around in the curly braces even though I personally still would because in my personal opinion this looks a lot better than having it like that you can see that it's a lot neater it takes up less code and you can see visually that you're using a specific variable and you don't have to worry too much about the spaces because this looks like a real sentence explore another method of string concatenation which is the idea of taking strings or objects and add them together to form a sentence of sorts we can say your name is followed by a space and then add the name followed by a space add your ages and then add the actual age variable and we can also write the exact same line using string interpolation or composite formatting just like this and like this we can specify the dollar symbol and put our variable in the bracket which is shown here and here and for the composite formatting we can take the content where our variable would go and replace it with incremental numbers 0 and one wrapped around in a curly brace and then specify in the correct order zero takes a value of name and one one takes a value of age if we run this code you'll see that the outputs are identical so let's explore this other method we have a string test for example and then inside the string Library we have this function called concat and it can taking any amount of parameters that we want to give it so we could say your name is space and the quotation marks and then we can add a comma and then we can say we want to add the name and then another comma and we want to add and your ages and the speech marks add a comma add the age variable and that's it and we could just use CW tab tab and type in test and let's run it and see what happens and now as you can see we get the exact same output and because this just returns us back with a string we can also just take this entire line and paste it straight into the console right line you don't necessarily have to store it but you can if you want to and there you go all methods produce the same output another way you can use this concap function is by giving it an array we haven't covered arrays so far so I'm just going to show you this for demonstration purposes don't worry about understanding it so just a quick explanation arrays are just ways of storing multiple of the same data type so if we have these three names inside our names we can actually use the console to print them all out so we can say string. concat and then we can concut the names together which will just add all of these three together now the problem is when you've run it you'll see this stuck together so what you could do is just add a space between them and as you can see this is getting a little bit tedious now there's other methods that we can use to concat some arrays together and I'll show you that in the next section but for now don't worry about it this is concentrating on the string concat function and we'll just demonstrate that again so if we run the line of code we can see that they're all the same so now that you have four different methods of printing out exactly the same information you might be asking yourself what's the best method I personally prefer to use the string interpolation because with this one you can easily miss the spaces and you could produce a bad output and it might be stuck together it's fine when you can see the lines right in front of you and you can easily identify the spaces but when you're adding about 10 variables together then it could be a problem the reason why I like string interpolation using the dollar signs and the variables in the curly braces is that you don't have to rely on missing out spaces because it actually forms a sentence and you just replace the use with your variable composite formatting which is this one is very efficient and very nice to look at because it allows you to specify the sentence and then plug in the variables after the only problem with this is if you were to change this value in the future or to change a sentence you have to make sure that the numbers add up just like in the first example if you only have a short sentence then this isn't really an issue since you can see it all visually and you also got to realize that these need to be in the right order because if you put Age first then it's going to put age in this one and name in the second one and that's going to be problematic cuz it now mess up the sentence using string interpolation you don't actually have to worry about anything because if you wanted to change this to say your age is then you simply just do this and that's very easy to do because in this case you'd say your age is and then you'd have to change a string and then now that this is zero we need to change this from being age and this one to be name whereas in the first example you could just easily change the value in the curly braces instead of changing this reference and the end reference cona is not widely used just because you have all of these methods available where you can easily add stuff together but there could be user cases later on down the line where users just so it's a bit more obvious and it helps the readability of your code and maintain within a big project or just on your personal projects when you're looking back at your previous code when you create and initialize a string variable you might want to give it the value of an empty quotes and this will just default the value to essentially nothing you're giving it a value but at the same time the value doesn't actually contain any sort of characters if we print this out to the screen then you won't really see anything this video is going to focus on string.empty and string.empty will actually just represent these quotation marks string. empty will represent these speech marks so what we can do is we can type in string using a DOT and then we can type in empty just like that we've initialized our string name to a value of empty now this isn't necessarily used when you're declaring and initializing it because this is almost identical to just defining a string on its own main reason why this is used let's say we actually ask the user to input their name so we can say a console. write enter your name and then we can take this string variable move it down use an alt and then arrow keys and remove this and let's initialize it to a console.readline to read in the value from the console and now what we can do is using our is string interpolation method that we just learned we can print to the user your name is and then the name in The Curly braces now let's just see what happens so let's actually type our name in Abba and it says your name is ABBA but what if the user just types in nothing and just presses enter Then it still says your name is blank now let's see what we can do here we don't necessarily want to say your name is blank we want to check what this value is so we can say if the name is not equal to empty quotation marks then we can output your name is and then then else we can say name is empty and then if we run it now and press enter it says name is empty so we can use string. empty instead of these quotation marks this looks a lot better when you're trying to compare it AB your name is Aba and then when we press enter it says name is empty this just helps to keep your code a lot tidier just so you don't have to write the two quotes if you accidentally put a space in there now your if statement is incorrect if you always use string. empty then it just helps you to make sure that your code is going to be maintainable and readable in the future reading string.empty gives you a better representation of what's going on instead of two open quotes if there is a situation where you want to check if one string equals another string then you can do the following if message equals equals compare then we can print out same and then else we can print out different and as we can see here they both have a capital H and they both say hello so they should be identical let's run the code and find out so they say same which is exactly what we'd expect so we have another method of being able to do this so even though we can apply equals equals to two strings it's normally better practice to use do equals and then place the other string inside the brackets so you're saying if message equals compare now if you run the code you'll see that it's the same output in certain circumstances where you want to ask what the user has entered enter your name and then we can use a string name equals console. readline we can say if the name does not equal to empty strings then from there what we can do is type in your name is plus name and then we get some output your name is abber but since we're checking if it's not equal to that that means they've entered something in let's see if there's another way that we can actually write this so if we just duplicate it and comment it out so we got it for reference so what we want to do is we're checking if name is not equal to empty quotes so we can say name do equals empty quotes but what this is telling us if the name equals empty quotes then we should do this so then what we can do when we learn about the if statements is we can use the not operator and we can say if the name not equals to empty quotes then we proceed with this line L we can just say invalid name input let's run that and see what happens to type in AB then it passes fine and if we type in nothing then we get an invalid name input the reason why equals equals and the do equals function are different is because lower level using equals equals will actually compare the reference in the memory and the reference in the memory is what's used up when you actually create these variables so what this is doing is it's comparing the value that's actually stored in memory to the other one that's stored in memory now the problem is when it comes to something like arrays where you actually have the same value but they're slightly different let me demonstrate so I'm just going to use this code because we haven't covered arrays yet so I'm just showing you an example if we have a chart array that literally says hello and then we can use this line of code to join them together but this is actually an object instead of a string but if you see what we can do in the if statement we can say save the message which is equal to hello we can use message. equals and we got the new compare and this is actually an object so now we're comparing a string with an object and generically speaking an object can hold any sort of value because all of these variables that are strings ins double Etc they're all derived from something called an object which is just a very generic way of storing information so since these two data types are little bit different they still evaluate to the same thing what the equals function is doing is actually checking the literal values of the variables instead of checking the values that are held inside the memory address location and the difference here is even though we have a character array that is giving us the values hello and our string is also given us the value of hello if we run this line of core that uses do equals then you'll actually see that the second same actually represents the bottom if statement so what that's doing is it's actually giving us back the comparison saying that it's true and it is indeed true because hello is literally equal to hello but if you were to use the double equals then what you'll realize when you run the code is now it will say it's different because what it's doing now is it's taking a string object and comparing it to an object and they are not different because of their memory and that's what the equals equals is comparing it's not only comparing the value it's comparing the memory address location and that's going to going be vastly confusing because you don't want to hit these situations so it's always best to use the equals function because the equals function is concerned about the values rather than where they are in your memory I hope that made sense and it wasn't just confusing but basically when you use equals equals it checks the values that are actually wrot in your computer's memory instead of the value itself it will do both it will check the memory and check the value whereas when you use do equals it is only concerned about about the values and that's all that matters when we're doing an if statement like this we're checking if they're both the same so it shouldn't really matter how and where they are stored the only thing that matters is the values contained within the variable we're only caring about the values and not where they're stored so when we have a string variable defined in C we have it like this and when we print it out to the console we get the entire string being displayed but what if you want to return the first element back not the rest then what are your options so in the later video in the course we covered the substring function and technically you could go from the first character till the second character and you will just get C back so that's index zero till index one and you'll get the C back now the problem with that is that's an extra function call or something that should be quite simple and it is a message is a string and strings tend to be an array of characters which is similar to this we haven't learned about arrays so far and we'll cover that in the next section but what an array essentially is is it lets you store multiple of that data type so we could have a chart array that holds exactly the same value and each position will hold each one of these characters and the reason why I'm mentioning this is because with strings you can use the square bracket notation so if you add some square brackets at the end it says here it returns back a Char and it takes in an index gets the CH object at the specified position in the current string object so if we use message zero you can see that returns back with a ch ch right here gets the CH object so we can call this on a string and it can return us back with a character because like I said with the array of characters that's essentially what a string is each one of these is just its own independent character and a string lets you pair them all together so if we print this out then we should get C because it's zero based so if we copy this down and use one 2 and three then what should we get we get C then we get actually nothing technically because it's a space character and then the third character which is the fourth in the list because it's zerob based is going to be our I so let's just print this out to the screen and see what happens there we go so even though we don't see it visually there's actually a space character right there and that's the third character in The List which is right here so of course we don't tend to know how long the string is unless we can see it visually and if you were to reference one of these values and the string is not actually that long then you have a problem let's demonstrate if we have the string just called C and let's comment out the rest then that's only two characters so only zero and one will be applicable these two will return back something let's have a look and see what happens so the first character and the second character will run fine and let's put a console read line in there just to break it up so the other code doesn't run yet if we run the code we get our C and that's the max length of our string so so far it's zero and one now if we press enter let's see what happens we get an index out of range exception index was outside the bounds of the array and the reason for that is we only have two characters inside our message and we're trying to display the third and the fourth this is problematic because we literally don't have any of them characters to display so what we can do instead is actually write ourselves a little Loop to go through the entire string and return us back all of these character positions instead of us just get ing how long the string is so if we return this string back to normal and then just after this little section we can write a for Loop in I equals 0 and I is less than message and then we have access to dot length this gets the number of characters in the current string so we don't have to worry about the maximum length in the square brackets we can always rely on do length because we don't have to keep track of it and the language can know that for us and give us the value in this case we're going from zero to whatever the length is these characters are and then in here we can actually just console right line and we can do the same notation we did here we're say we want to print the message but not only the message we want to print the index and the index is going to be I in this case because we start at zero since it's zero based and then we're going to the last character so let's print this and see what happens so now we get C Is Awesome from here down to the bottom c is awesome print on every single line and that's a little bit annoying to read so what we could do is just change this to a console right and maybe we can just comment this section out just so we can see this properly there we go so we get c is awesome and because it's a console right it's right in them all next to each other and they're being printed out one by one let's add a cool little effect that can demonstrate you for now so inside the system. threading Library we have this sleep function so what we can do is we can add another using command system do threading we already have threading do tasks in there but the function that we need is inside the threading Library so there's two ways we can write this we can actually write everything by hand like this do sleep or you could just remove the system do threading because we've added it at the Top If you don't want to add it at the top that's not really a problem you can just include it straight into here adding it at the top will include it within the entire project but if you're only going to use it once or twice then sometimes it's better to just include it straight into here because it'll make your overall program size a lot smaller so let's just keep it in so we can make our code a bit more readable so we have thread. sleep and what this will do is it will suspend the current thread for a specified number of milliseconds there's a th000 milliseconds in 1 second so what we can do in here and we're trying to mimic a typewriter effect so we can say something like 200 which will be roughly a quarter of a second so if we've run the code now let's see what happens so we get this cool effect where after it prints out each of the characters characters it will print out the next character only after it's been asleep for a quarter of a second and that looks kind of cool if you wanted to speed it up you could just decrease this number there you go of course if you make it too low then it might be too fast for you to actually acknowledge what's happening and if you also make it too slow then it's just going to take too long to turn off and at that point you can use control+ C on your keyboard or use the stop button at the top to terminate the program okay so let's have a look at another thing that we can do with this so maybe we can make this 100 for now in the previous videos we've used a function called contains and let's say we're just checking if it Con turns C and we know it does because we can see it visually let's run the code and we see we have true being printed and the reason why true is actually on the same line as c is awesome is because we're using console. right here so it's actually not made a new line character just after the E so when it's printing true it prints it straight after that so what we can do do to fix that is just place a new line character in here using console. readline and we can just drop this a little bit lower to 50 there we go so we have true and what we can do with this is we can actually make our own little version of the contains function let's demonstrate so if we make this exact for loop again in I equals z i is less than the message. length and i++ so first let's kind of understand what's going on with this function returns a value indicating whether a specified substring occurs with in this string and what that means is it will return a Boolean for us if C is inside our message then this will return back true and we know this is true because we just outputed to the screen and we can see this visually so what we need to do is we need to Loop through our message and try and figure out if we can find C inside our message and then we can give back a value of true so maybe we can do a bu contains equal false and the reason why we initial it to false and the reason why we initialize it to false is because we want to set it up telling that we haven't found it and then inside the for Loop if we find it then we can set it to True let's have a look so after the for Loop we can print contains of the screen and then inside the for Loop what we can do as we've seen here it returns back every single character so you'll get back C sharp then the space then I then s and so on and so forth and what we want to do is we want to go through each of the characters and then just ask if the variable is equal to C if C is equal to C then we can assign this to true and then go through if hashtag is equal to C if space is equal to C and so on and so forth so we can write a if statement here that says message square bracket I is equal to equal to apostrophe C and the reason why it's an apostrophe is because this is a character and this also returns us back with a character so we need to compare them both like that if we use a string in here then it might complain that we're trying to convert between a chart and a string and it won't let let you do the equals equals operator between two different variables maybe what we can do instead is to follow the approach that we used before and use the equals function and place our C inside here so if the character that we're currently up to inside the for Loop is equal to our C which is what we want to search for then we can set our contains variable equal to true we don't need to write an lse statement in here to set our contains to false because we've already gave it a value at the start if we didn't have this value then it'll be beneficial to do this but since we have it then we can remove this other path and we don't exactly need it so let's have a look and see if this works perfect it says true maybe we can change this character to something like air make sure this works which it does as well so perfect so now we've made our own mini little contains function inside here and we can also use the C library one but the purpose of this exercise was just to show you how we can iterate through a string variable and and then decide what each of the characters can be equal to and then we can decide if they're equal to another one and then let the user know that we found a match for their search term so far in the course we've covered the equals function and the contains function when you're searching through strings or trying to find values let's have a look at a method that makes sure a string is valid before we can process information on it so in this quick example we have a name output we're reading the value into a string name and then we simp complet output it to the screen if we run the code and just press enter then it says your name is blank and we don't really want that because we want to check if your name is equal to something before we continue so let's look at some methods so we have if the name is not equal to nothing and then let's just print zero to the screen and that's one of the methods and we can say if name is not equals two quotation marks then let's print out number one so what what this is doing is checking if the name is not equal to empty quotes and then this is doing exactly the same thing except we're using the equals method and let's just run the code and press enter and you can see the zero or the one doesn't appear because it's detecting that it contains nothing so if we type in a real value we can see Zero and one coming up so these are both valid ways of checking if the string is not empty so let's look at a third one and this one is actually very important for reasons I'll explain in a second so inside our string Library we have is null or empty so we place our name inside here and let's see what this says now indicates whether the specified string is null or it's an empty string so this can be very effective so what this reads now is if the string is null or empty then we print a value but we want it to be not null or empty because it wants to have some contents so if we type a value in again you'll see now we get all three numbers and what them three numbers mean is that it's past all of these checks and each of these checks just ensures that the value has got something inside and that's fine but it can be slightly problematic for this reason using this method and this method are fine in some cases except as it says here it checks if the string is null and null means it doesn't have a value but it just has nothing instead of something let me demonstrate if we assign the value of empty quotation marks this actually has a value but the contents is empty but it's still a string as it comes up in here if we assign this the value of null then it's just a keyw that we can use to denote that this literally has no contents it's not that it has an empty string CU an empty string is still actually a string whereas a null it just means the variable is blank now this is where the issue arises if we try and call a method on something that's null Watch What Happens we actually get an exception and our program just crashes you can't run any code on something if that variable is actually defined as null it doesn't mind if you check the value of it but if you try and run a function then you've got a problem so if we comment this line out this ensures everything it ensures it's null or it's empty and this is the belt and braces option because if it's null we don't actually get an exception when we try and run this code as follows we get the zero showing up because our variable has something that's not speech marks and it's actually null so we want to avoid this option as well and also avoid this option in case our string is actually genuinely null using is null or empty we'll check both for the value of null which it is right now and if it's got empty quotes EG the value is empty so if we just run this again and have these two paths commented out we can see that two is not appearing if we change this back to our console readline and we try and do it then we get our number two because it's validated that this string variable is got something inside it and the variable is not actually no this is a very good way of being able to make sure that your program doesn't get exceptions as with calling these equals if you want to call equals then call it inside here you can check if that variable equals something by simply placing that if statement in inside here after you validated if the name variable actually has some contents if it's null or it's empty running equals on it will just break the code further and you don't need to check if it's equal to Something in here maybe you were checking if the value is equal to abber or something along them lines and now if we run it again we actually get the output correct it's best to Nest them like this because if you run this function on something that's null it's actually really safe but as you saw previously if you run a function on something that's null then you're going to get a null reference exception and your program will close down and break you want to avoid exceptions at all cost so nesting it inside it is null Remy check will be perfect for your code it improves the stab ability of your program to ensure that exceptions don't happen so in this exercise I want you to ask the user to input any message and then I want you to print the message in Order character by character and then also print it in reverse character by character let's get started so we could just have a console right line but let's change it to a right and just say enter your message callon and then speech marks and then just have a string message equals console. readline perfect so in order to be able to Loop through the string message we need to have a for Loop if you remember from our previous videos we can have this string variable followed by a square bracket and then and then we can have an index inside and that will print us back any sort of index based on that position so if we just have this is a test then it's prob print as the T because that's the first index and so on and so forth so what we can do with this information is take what we can do with the string index and then also use the property which is length and then use these two values to be able to process this is a test so we have the first character square bracket 0 and the last character is at length 14 so our message variable now contains 14 characters obviously When I close the program then that value is lost and I have to reenter it but because of that exact reason we would always use do length because we never know how long the user's input is going to be so we can have a for Loop so we can say 4 into I equal 0 I is less than and we can use the message. length here and then we can say I ++ so you want to start at zero because our first index position is inde Z and we want to go from the index zero all the way to the length now in that example I just printed out 14 for the length but you got to realize is there might be 14 positions but there's only 13 indexes so it's not actually 13 index it's just up to 13 when you start at zero going from 0 to 13 gives you 14 positions so when we're saying 0 is less than the message length then that will actually take us from 0 to 13 instead of 0 to 14 if we made this greater than or equal to and change this to a one for example then that's going to go from 1 to 14 and first we're going to miss out the first character and we're actually going to go one over the message length so you always want to start from zero if we're going through the entire string so this will go from 0 to 13 and then here we can just have a console right line and just print message square bracket I and then just for the time being we can comment out these lines just so it doesn't saturate the output so let's run this Cod code and see what happens this is a test and then we get them all on separate lines maybe we can just use a console. right instead so we get each character on the same line instead of a new line character being outputed at the end of each of the lines so we can say this is a test again and there we go we get this as a test outputed as well so now that we've printed that in order let's see how we can print it in reverse so just a quick little tip throughout this C I've been quite hard on you I've made you WR the for Loop out exactly the way it should be but all done manually this is so you can get used to the syntax and after a while once you understand exactly what to do then what you can do is when you type in the four you can see that it says there's a for snippet tab twice to insert the for snippet and we can do that now and it actually gives you a little bit of an output you can see these sections that have been highlighted the reason they're highlighted is once you're done with one section you can actually press Tab and it'll jump to the next one so now my cursor is jumped on the length and we can type in message. length if I press tab again then it'll just keep cycling through them until we're done and we can press Escape upon pressing escape then it gets out of the little message and there we go we've now just defined a really quick for Loop please only use this once you're comfortable writing for loops and don't use them immediately because you might get stuck on what to do and how to do it so it's best to always write the for Loop syntax out from scratch so you can get used to the three different sections so this is actually a for Loop that goes forwards it's going from 0 to 13 but what we actually want to do now is go from 13 to 0er so let's actually change this for Loop completely and we can do our little shortcut again so if we do four and then we don't actually want to start on the value is zero we want to start on message. length and then you want to minus one and just as we said here we never actually want to get to the length because we want to go from 0 to 13 so if we want to go backwards we want to go from 13 to zero and the only way that we can get this 13 is by getting the 14 value which is message. length and simply minusing one so now that we've got our first variable which is in I equal message length minus one which will give us the 13 we want to go from I and instead of less than it's going to be greater than or equal to and then we actually want to change it to a zero because we actually want to stop at zero in this case and then we don't want to use I ++ because if we start at 13 we want to go down in one instead of up in one then we can simply just do minus minus we can take this exact line and print it out to the screen and if we just print something small in between like a hyphen just to separate the two outputs and let's see what happens test there we go so we have test and then t s e and t is now in Reverse but now you might be wondering if we had a shortcut for the four what what's this for with an additional R Cordes n it for a reverse for Loop so if you tap tab twice you can see that we have exactly the same format in I equals something minus one which we have right here and then we have I is greater than or equal to zero as is we have here and then we have IUS minus just like here so we can literally just change this into message do length and then these two now are exactly the same so just copying this down we'll get us exactly what we need but obviously we just wrote this I just wanted to show you the shortcut so let's try it with a longer string this is a test there you go and if you wanted to you could just print these on separate lines so you can just change this into a right line for example and have it like that it doesn't really matter the rest is up to you but the task is just so you can print it one way and then print it the other way I realized that what you can also do is just simply print a console right line and have message in there and just get rid of this completely and the output will still look exactly the same there you go and the reason why I told you to write the for Loop is not because it'll be easier if you do this it's more for your Educational Learning purposes having more practice to how to iterate a string variable is very helpful for the future and you can understand it fully if you just print out to the screen then you're not learning anything extra you're just applying what you already know so let's just have a quick recap we ask the user to enter the message we STW it into a string variable and then Iden demonstrated that you could use the square brackets to Output the first index then you can output the length of the entire variable using a follow you can go from zero to message length which will give us from indexes zero up until 13 in this case and then we can go through i++ incremen in one and then we can have a console right which will just print out message index I for the index that we're currently up to and then we break it off with a console right line just in the middle because these are printing on the same line so we need to insert a new line character at the end after we've done that what we can do now is print it in reverse and now we can do exactly the same thing except from 0 to 13 we go from 13 to zero so we start at the message length minus one because the length was 14 and now we minus one to get to 13 and we're going from I is greater than or equal to zero because that's the value that we want to stop at and then we can do I minus minus if we were to take out this equals operator let's see what happens test and now we're actually missing the last character because what we've done is we've actually went from 13 to 1 instead of 13 to 0o so let's put that back in and make sure it works and then we have t set for test and then we're outputting the exact same thing in both for Loops because we're simply just printing the character that we're currently up to and because this for Loop starts at zero and this for Loop starts at the length minus one then they outputting the same values or what it appears to be the same values it's just starting at different indexes in this exercise we're going to be building some sort of a password validator this can be present in something like a register form where you ask the user to enter their password and then enter it again to make sure that they've entered it correctly so you want to ask user to enter their password in twice and store them both check if they both contain something if they do we can print out password match if they don't passwords do not match and if they both contain nothing then you want to Output please enter a password so let's get started first we can have have a console console right we can have enter password string password equals console. readline and then we can just copy these two lines down using contrl D and then we can have a password C for password confirmation and we can say enter password again and let's just print these out to the screen just to make sure we know what's going on just like so so we can have abber and then abber again so now we have both AB stored and that's fine so let's see what we can do now we need to check if they both contain something so what are the different ways that we can do this so we can have if password do equals and then we can make it equals to string. empty and because we want to check if it's not empty then we can simply place the not operator right at the start and then we can join them with another one not password. equals and then exactly the same thing string. empty but in this case we don't want to use password we want to use password C there we go so if we've came into here then that means they must have entered something so let's just quickly do our exit path which is if they're empty please enter a password so we can say else and we don't need a condition here because if this were to fail then it has to mean that their passwords empty so we can have a console. right line and we can just do please enter a password and let's just test if this path works first and we just press enter twice and we get please enter a password and maybe if we typee something in for both and then we get nothing because it's actually came to here now perfect so if we come through and we can say password equals equals password C or we could use the equals function and we can say password. equals and then password C and if they both equal to each other then we can print out passwords match there we go and if that were to fail then we can print out passwords do not match here we go let's run that let's find out ABA and ABA and we get passwords match and if we try ABA and ab two is and then we get passwords do not match so what are some other ways that we can do this you can structure this completely differently right now we're doing both checks in one single if statement and we can actually split this up into two and then provide a different error message so right now this ISS please enter a password you might have entered the second one but not have entered the first one or vice versa but it doesn't matter because you have to enter both of them in order to pass this validation check so what you could do instead is actually put another if statement inside and paste this one inside here and then just keep these as two separate if statements and then you can actually provide different error messages so let's Nest this in one deeper so we can say if the password is not equal to empty and if this returns back true then this variable has something inside it and then once we go inside these curly braces we get another check and if the password C is not equal to nothing then that means if we've came in here then we pass both of these validation checks and both of them contain something and then we can proceed to check the variables so what you can do in the first L statement is you can say please enter a password but on the second one so just after this curly brace we can have another L statement or we can say please enter a password confirmation so I know that was a bit quick so let's just have a quick recap so we can have one if statement that processes the first password that you type in and if this is empty then it says please enter a password and if it's not empty then it'll go inside this curly brace hit the first line and check if the password confirmation is not empty if it is empty then it'll say please enter a password confirmation if both of these return back true then it will go inside the success path in which it will actually check if password is equal to the password confirmation and we can say the passwords match or if they don't equal to each other we can say the passwords do not match let's run that and see what we get so if we type something in for the second one but not the first one so for the first one we just press enter and then let's type something in for the second one and it says please enter a password and then if we run that and do the complete opposite type in p and then press enter for the second one then it says please enter a password confirmation so you can see immediately what we can do is provide a different error message for different situations if you include these both in one line then you can only give out more of a generic error message this is similar for when you go to login and when you get your password or email wrong it doesn't say which one you've got wrong it just says them generically which one you've got wrong it says invalid credentials or invalid username or email it will say them generically like invalid username or password but it won't tell you which one it is because hackers can exploit this and you don't want to be doing this but in the case of a password confirmation and this is just for a register form then it's not exactly the worst thing to do this because sometimes what you'll see is the text boxes might go red to indicate that they're both not equal to each other and this is fine on registration but it's not fine on the login what we can also do in here once we've checked if they're both not equal to something we can actually just validate how long the string needs to be we can have if password. length and let's say you had a restriction and it can only be over six characters and we can say six and password c.length is greater than or equal to 6 and once it passes all three of these checks then we can check if they're equal to each other if they got something inside and if they've got something inside and if they've got both the length is greater than or equal to six then we can check it so we can have something like password and then password and then this returns back with password matched if we have something like abber then it's actually returns back nothing because we don't have an else for this specific bracket so we can say else conso right line please enter six or more characters so if we type in Alit twice then you can see we get this message now please enter six some more characters so right now we have a validation for the first password and the second password and for the length and if all these checks go by then you can process the actual passwords that they they've entered and check if they're equal to each other you can technically do all of these checks in one line it'll just be a pretty long line but what that means is you can't have three separate error messages like this if you have it processed in one line the only error message that you can give is very generic there's no one generic message that can fit for password empty and the confirmation password empty and for the length so maybe what you could do is chain the both of them to be check if they're not empty so then you can process a message with something like please enter a password and then you can have another check for the password length just to let them know that they need to enter six or more characters but in these off into two separate checks is going to be very helpful because it'll let the user know something a bit better than a generic error message so in the previous examples throughout the course we've actually talked about using the two lower function and I said in majority of cases where you want actually compare two different things you want to actually use the two lower function or the two upper function and you can achieve this by having two lower just here and then also two lower just here now the problem with comparing if they're both equal to each other but checking the lowercase values is this is indeed a password if you're checking if the user has inputed any capitals lower case symbols Etc then there's no point in applying a too low function because that will just ruin their actual password and reduce the security so in certain cases you don't always want to use two lower and two upper for comparison you want to just check the value straight up and the same thing is when you're doing a login you don't want to be checking their values lowercase because that's their login these are some of the specific situations where you don't want to be using the tow function if the data that you're processing is pretty sensitive and will be messed up if you use the toow function that you should always avoid it passwords fit this perfectly and usernames as well if someone's added some capitals inside the username then you don't want to ruin that by doing lower case or upper case if you're your username is spelled like this and you try and log on like this then they are not equal to each other because this will probably be two different accounts you can have an account with a capital B and have account with a lowercase b so you don't be lower casing the input and then doing a comparison because what you might actually retrieve is a different account than you're looking for so now that we talked about stuff theoretically let's see how we can do things practically so as you heard in the last video arrays are a way that we can store multiple variables of the same data type in one little group so if we had something like Nome 1 = 5 in n 2 = 10 in N 3 = 15 and we had a similar case in one of the exercises like this where we had to work out if a triangle was actually a triangle so we asked user to input three different angles and then we stalled them all and then we added them up after and it looked something like this in total equals num 1 plus num 2 and then finally plus num 3 and then we had some sort of if statement after to check if the total was equal to 180 and then we did something in the curly braces just output that it's valid and then else output it's invalid you can see how this gets a little tedious we have to create a new variable every single time we want some more data to be stored and in this case we just simply want another number that we can store but we have to just keep a pending one to it in that case we could have angle one angle two and angle three but how about if you have something that just called angles for now let's just talk about how arrays work and how we can use them and then after I've went through this example about arrays and taught you what to do with it then I will go get the code from the exercise from the triangle video and actually transform it into using an array so you can see what the difference is and how the new code will look like so let's get rid of this little section so now that we've got three integer variables let's see how we can do this another way so the Syntax for arrays you first type in the data type that you want just like before and then you add on a square bracket and a closed square bracket there's nothing that needs to be inside as of right now then you press space and type in the variable name as per always and then we can make that equal to new in 3 so what this side of the equal sign means is we want a new instance of an integer array and we want to have three positions since we have three variables here that we want to store we need to have three positions to stall them so this line in total says that we want to integer array we want to call it numbers and we want to instantiate our new integer array with three positions instantiate is just the term that we use when you turn something into a new class at this point if we don't use new then we're going to get compiler error because it's unsure what this is trying to tell you it's trying to St an integer inside integer array and that makes no sense so it won't recognize the square brackets in this case because it has no idea what it's trying to do and this syntax is completely incorrect so the compiler doesn't know what error message to give you so we can have a new int and what we can do now is by using the square bracket reference we can actually specify these three variables inside our numbers array so now we have access to numbers 0 = 5 and then if we use controll D to copy this down twice we change this to one and two and then print 10 here and 15 here so now this is exactly the same as this we have three integer variables defined separately as 5 10 15 and now that we've created an array of numbers we can specify all three of these values inside our numbers array so instead of having three individual variables now we just have one that holds everything like a group and just to show you how this works if we have a console right line we can say n one space num two space num three and if we use control D to duplicate that down then what we can have instead of these num ones is simply just place these values inside changes to one and changes to two and what you should notice is these two lines are going to print the exact same values there we go so in this example we've took our sloppy code that will roll us around appending one to this number creating a new array and then printing it out so let's say we want to actually use these to read in values from the console what can we do and you'd use these exactly the same as how you use variables up here this is just an integer variable at a specific position held inside a group so we could simply have a console right line delete the right and just say enter a number and then instead of starting five we can say convert to in32 and then we can have a console. readline and that will read in from the console convert it to an integer 32 and then store it into the first position of our numbers array now if we just copy this down twice and we can get rid of these two lines cuz this is just staring it statically and add one and two to here so now what we're saying is enter a number St into 0o 1 and two and let's see what happens now so now we get asked the numbers 10 20 and 30 and you can see that they've been stored here of course these haven't changed because this is still referencing our static variables up here so what you can see in this example is now that we've made an array we can specify each of the values very easily inside here and if so we wanted to have a number four instead of to duplicate it and rename it and change the value for example we can just simply turn this into four duplicate this little section and then just change it to a three one thing to note in C and many other languages almost every single index will start at zero in the last section we covered the string functions and they also started at zero when you're dealing with strings and their positions when you have a for Loop of the string then you always want to use index zero as the first position the same is true here we have four positions which means it goes from zero all the way till three it never goes from 1 to 4 or from 0 to 4 these are bad values it always goes from 0 to 3 you might be thinking this looks really good but when we go to print it we're going to have to copy and paste this little section add another one and rename this to three this gets a little bit tedious if we just trying to print them all to the screen so let's see how we can fix that we can use a four Loop for this so we can have four in I equals z i is less than and then we can have numbers do length and if you notice from iterating through a string variable the syntax is exactly the same we have a do length property on the arrays as well as we do with a string variable so in order to print out this line what we can do is print one of them every time we go around the for Loop instead of using a console right line we can just use a console right so we can have console. right and then what we can simply do in here is we can say numbers square bracket I and then we can have a space right after it just to M make what happens here we have the number printed out and then a space after it number printed out a space after it and so on and so forth so let's see what happens now if we run the code 10 20 30 40 there you go so you can see that these two lines are exactly same and now what happens is let's just comment these two lines out and if we were to change this to five and we can duplicate the section changes to a four and then now we have five variables started and we don't need to touch this for Loop because the numbers do length will get updated anyway so we can have 1 2 3 4 five and you can see all five variables have been printed automatically what also is quite tedious here is we're having to add another one to this just so we can ask the user how many times that they want to enter a number again this is quite tedious but we also have a fix for that because we know how many times we want to ask the user to enter a number then we can use a for Loop to iterate through and ask the user as you can see every single line here is exactly the same except for the index position that we're dealing with and the same is true for this for Loop this line will always be the same as we're printing out here and the only thing that changes between this section and this section is the fact that this says one and this says zero so we can translate this into a for Loop to make it Dynamic and we can do exactly the same thing above here so let's actually copy and paste this for Loop because we want to do exactly the same approach we want to go through all the positions inside our numbers array and then we can actually ask the user to enter a number in so let's block comment out this massive section and then we can take one of them and place it inside the follow Loop so now we're asking the user enter a number and then we're storing inside index zero and of course if we keep using index zero then it's just going to override the first one and we're not going to store any data so we can change that to an i let's see what happens when we run it now 1 2 3 4 5 and then we get the five numbers being printed this is awesome because what we've got now is five output commands coming straight to the console just from a for Loop the for Loop is responsible for printing them all out to the screen reading in the value convert it to an integer and then store it inside our array and then we have a separate for Loop to print it out to the screen what's really really powerful about these two for Loops that we've built is if we want to have 10 numbers now we simply just change this to 10 and then just rerun the code as you can see we now have 10 numbers there you go so what we've just done if we move this code down a lot now just so we can have it close by we've made our entire program that was actually pretty lengthy in into just a couple of lines and two for Loops one for Loop is responsible for looping x amount of times x depends on whatever that number is and then we go through and ask the user to enter a number read in from the console convert it to an integer 32 and start within the array after this for Loop has finished running then we have all the numbers stored inside our array and then we can go through and print them all out to the console another way we can print this out to the screen is by actually using a for each so we can say int num and then we want to be a number inside our numbers so for each of the integers inside the number we want to create a new local variable called num and then we can use it in here and if we take this line and copy it down everything's exactly the same except we don't need to specify the main array numbers now and we don't need to specify the square brackets we can just change this completely and replace it with n and if we just make this number smaller so we don't have to Output a lot of values 1 two and three and you can see that they're exactly the same there's no line between them because I don't have a console right line so let's quickly add that in and there we go 1 2 3 and you can see they're outputting the exact same values the reason why I needed a console right line is because these four Loops are using console. right the problem with console. right is even after finishing writing all of the lines it doesn't continue to the next line it stays there so if I don't break up the two outputs with the console right line then all six outputs from the console right and the other console right will all go on one line this is just for demonstration purpose anyway either one of these Solutions are fine more people tend to use this one the problem with these two options is you can't always use them interchangeably this one will always go through every single position it will always go from zero and it will always go to the length the problem with this for Loop is you can't choose how many times you want to iterate through before you stop there might be a very specific case where you have a big array of data but you only want to select the specific range if an example where you had a th000 array positions so from 0 to 999 and let's say you wanted to request and run a for loop from 500 to 600 so you would literally type in 500 in here and then 600 inside here and this would be fine as long as your array has that many positions but with the four each Loop Loop if you run for each loop on a thousand length array then it's going to go through every single position in some cases you might not want that and you only want to go through specific cases so if you know you're going to go through every single case then you can use the for each but if you know you're going to go through a certain amount of cases then it's always best to use the fall Loop okay so we covered quite a lot in this video so let's just have a recap so initially we started off saying we have our num one num two and num three then we had our static variables St inside there and then we created our integer array which is now down here and just to make it a little bit easier to store multiple variables because if you wanted five variables you'd now have to duplicate that and change that to number five and this will get very tedious if we had something like 10 like before this is very long and you don't need be specifying number 10 in your code because this also hurts the readability of it using arrays can solve this problem quite a lot you can easily specify array using this notation int square brackets followed by the name and you make that equal to a new int three the three can be any number that you want as long as it's a whole number cuz this tells us how many positions that we've got we then outputed lots of values to the console and read them into our Ray but we had the same problem as we did above where we just had to keep duplicating the sections so what we did to prevent that is by writing a little for Loop that went through every single position in numbers array I puted something to the screen readed in the value converted it and stored it into the array and then after all that was done we can use a for Loop or a for each Loop and print that back to the screen now that we finished the base cont of this video and because I said at the start that I was going to take the triangle exercise and convert that into an array so let's do that now so now I've copy and paste a solution from the triangle exercise straight into this project I've just block commented everything above just so it doesn't interfere with our code so let's just run this code to familiarize us with what's going on so if we enter 60 60 and 60 then it says valid and if You' run it again and enter something else that doesn't equal to 180 then we get invalid so let's see how we can make this code a lot better by the use of arrays so as we said before we don't want to be using this angle one angle two and angle three let's make a int square bracket angles equal new int and then in this case we have three angles and what you could do as well is you could say con int angle count equals 3 and then you can simply use that inside here so later on in the code if we wanted to specify this to a different value we can just change that later on so now that we've got the three angles we can get rid of these three lines and write ourselves a little for Loop so I goes from zero all the way to angles. length and then every single time we go around in the for Loop we want to say console right enter angle one and then we can say angles square bracket and not zero in this case cuz we don't to be specifying index as it will go from 0o to 1 to two we want to be using I I because we're inside a for Loop that's already going through all the indexes forers and make that equal to convert to in32 and then a console. readline now we've got all the values stored inside here let's do deal with this problem so if we just comment out the total for the time being let's run the code oh we have one more error down here sorry let's run the code again and we can say enter angle one and we can type the values in but as you can see we've got angle one for each of the times what we can do in here is use our I index to print out the value so we can turn this into interpolation and then wrap the one inside curly braces and we can simply change this one to an i and let's see what happens now so we have enter angle zero and then one and then two and this is fine but humans don't like reading zero they like reading 1 two and three so what we can simply do is say I + one and because we're using I and then adding one to it it's not going to affect the variable inside the for Loop so there's no problems by doing this this is simply just for the output purposes so now we can have 1 2 and three just show up like that perfect so what we can do now that we have all the angles stored now we need to replace this line by writing a for Loop that can add up all the values for us so we can have for each in angle inside our angles and we can just say int angle sum plus equals angle the problem with this is we can't specify a new variable inside here and then use it outside an if statement so what do we do in this case you want to take angle sum and initialize it outside the for Loop and then give it a value of zero and then inside the follow we can remove the int and we can say angle sum plus equals the whatever angle that we're currently up to so if we had three values that's going to say 0 + 60 and then take that value and add another 60 and then take that value and add another 60 so it'll keep a running total for us and if we just print out angle Su to the screen let's see see what happens 10 20 30 and now we have 60 and that's the correct calculation if you add them three together so now that we have a running total for angle sum then we're pretty much done if we get rid of this line of code which is our previous total and we actually bring back our if statement there you go there's no error now and all this is doing is checking if the angle sum is equal to 180 and then print valid and invalid so we can have 60 60 60 and it prints out valid and let's just comment out our output and then we can have 60 60 59 and then it prints out inv volid which is exact same behavior that we saw at the start so let's remove the extra code in here and keep it like this there you go so now we've got our solution just like this and it's a lot better because if triangles were to transform in the future and we wanted more than three sides then we can easily update this value because now that we're using arrays or we're using a for Loop to enter out the values what we can do we don't actually need to store it what I mean by that is we can actually just get rid of this array completely let me demonstrate we can take this angle sum and place it underneath here we can keep the count so we can use that in the for Loop so we going from 0 to three because that's our angle count and then we can get rid of all this and let's see what we can do now so we have an angle count equals 3 so we go from 0 to three which will'll just do as we said before from 0 to two because it's less than the angle count and let's just print this to the screen see what happens so the output still exactly the same but what's happening is these values are not being stored they're just being shown to the screen and then not done anything there is no equal sign here to assign it into anything so what we can do is we can say angle sum plus equals the value straight away and now if we try it 60 60 60 then we get valid the main differences between the these two situations is in the first one we used an array to store all the different values and then we added the total but if we're not going to use these values after then what's the point in storing them we can just use a for Loop to ask the user how many times they want to input the values and then just add them every single time that they add the calculation in and at the end we could just simply use a conditional operator to be able to print at the screen whether it's valid or not but let me just undo that solution so I can show you the array solution and we can have a quick recap that was just an extra little tip just in case you wanted to know what different ways you could use to make this work there we go so let's just have a quick recap here so we have a Conant which all we'll do is let us specify three inside here and then we can use it here this isn't entirely necessary but it does clean up your code a little bit because it gives this number three a bit of a meaning it says the amount of angles is our angle count having a three left over like this is what we call a magic number they're quite bad because it hurts the readability of your code people want to know what the three actually means so if you bring in an angle count then you can actually read we want a set of angles and this is the amount that we need and that's denoted by angle count it adds text to a variable it gives you a way of making sure that the text equivalent of a variable is present so someone can just read it after we've created our integer we can actually make a for Loop that goes from zero to the length and then we ask the US it to enter the angle and in the previous example we had enter angle one 2 and three so now we can mimic that by using I but because I starts at zero we want to use plus one every time we loop around the for Loop we ask the user to enter the number read it in through console read line convert using convert 2 and 32 and then store into the array after this for Loop is finished we have all three values stored in the angles array and then we have an In Sum to count up all the values that we need and and then we use the fall Loop to go through every single integer value inside and make a running total and store it inside angle sum once angle sum has the total count then what we can do is use console right line along with the conditional operator to print whether it's valid or invalid to the screen in this video we're going to look at how we can use the builtin array functions to be able to sort an array so if you have an INT array called numbers and then using the previous notation that we looked at we can actually specify any numbers that we want using a common delimited list so if we just have nine numbers inside here then we've actually defined an integer array and then the compiler can count the amount of items that are inside here and give it the length but we don't have to worry about that ourselves so if we use a for each and we can just print Inn inside numbers we can do a console right line on the new local variable called num if print it out we can see all of the values and maybe we can actually just use a console right followed by a space just to give them all on the same line there we go so as you saw before if you had a string called test and we wanted to do something to it for example if you wanted to use the replace function if you want to remove all spaces with an empty string then if we check the replace tool tip we can see that it returns a new string most of the string functions will return you back the new string after doing something with it but in this case if we type type in Array followed by do sort and we can place our array straight in the bracket what you'll realize is if you hover over sort it will sort the elements in the entire array but it will indeed return back a void and void just means it returns back nothing so in this case what it's doing is you're actually affecting the numbers array straight away and you don't have to do numbers equals array. sort numbers for example if we were doing the test replace we would have to do this otherwise this would just be returning back a string but we wouldn't be using it the same is not true for the arrays when you run the array functions they tend to return back void and you don't have to do anything other than give it the array that you wanted to sort so now if you run this code you should just see the same output since they already sorted anywhere so let's change some of these numbers up and just see what happens now there we go 0255 6 7 899 and that's it sorted just like that there isn't a whole lot to this sorting function but what you should note is you can use this new array syntax to Define how many items that you want in there instead of having to change the amount of positions that you have using the square brackets you can just denote any number of items that you want inside the compiler will count them for you and press the length straight into the brackets for you so you don't have to worry about it using the array. sort function all you have to do is give it the parameter of the array that you want to sort and it will affect the array straight away and you don't have to restore it and then we're just using a simple for each Loop to print them out to the screen in this video I want to discuss the array reverse function so if you hide an INT numbers equal new int and if you just had lots of numbers in here defined just up to five then we can add a semicolon and again using this array function we can see array. reverse and pass our array inside and then we can just use a for H our item inside our numbers and simply just print them out using a console. write and we can use string interpolation I just put a space at the end there we go and if you run the code then you can see our numbers have just been reversed there isn't a lot to this video I just wanted to show you about the different functions that you have available for arrays these can come in handy when you have something like a list return from a database for example and it's ordered in a certain way let's say you're returning back a list of lots of people who ordered back alphabetically and it's going from a to zed and let's say you have some sort of user interface that allows you to flip the order instead of having to request the database to get the data back in the opposite order you can use this array function to just reverse the list the same thing goes if you're trying to order by lowest price or highest price you can use this to show the different values in different orders that's where this array function comes in handy when you have different situations like the names or the price by ascending or descending where you can just flip the data and instead of having to request it back from the database again flipping it locally is a lot easier than going back to the database as that uses more data and more computational power on the back end and then return it to the front end it's always best to be able to use these functions instead of having to use external things to be able to return back the same data using it locally like this will give us a performance Advantage because it's done directly on the data instead of having to request everything again if you wanted to do this manually let's have a look and see what your options are you can have your integer array just defined like this with a dynamic list and then we can have a sorted array using the same length as the current array what you can do instead of using reverse we can actually just comment these lines out you can bring back a normal for Loop but if we use two RS it gives us a reverse Vol so the length is going to be our numbers do length and the rest of the paramet is exactly the same we want to go from the last minus one all the way till zero and we want to decrement in one and we can say our sorted number I is equal to numbers I but all this will do right now is just give us back the same value stored so what we need to do in a case like this is make another variable something like X and we can store that into zero and what we can say is X is assigned the value of whatever this numbers is because this is going backwards but we want this one to go forwards CU we want it to be reversed and we can say x++ and see what happens when we run it now so so nothing's going to come up because we don't have any output so let's use a for each we can have V number inside our sorted numbers and we can just take this and place it in here and just print out the item and we can use num and there you go it's been flipped the exact same value is just the other way so this is obviously a little bit more complicated because you have to use an additional variable use a backwards for Loop and then incom your own separate variable and as well as completely make a whole new array of course you should only do this if you need it as two separate arrays if not you can always just affect the one that you're up to right now because I said before that arrays are actually static data and they're going to be fixed size then there's no way to remove or add an item but you can clear what you have already so let's have a look array do clear set a range of elements in an array to the default value of each element type so the first parameter takes our array so let's use numbers and we want to start off at the index that we want to clear from and let's just say zero and because we want to clear the entire array let's go all the way to numbers. length and now let's just produce a for each of our item inside numbers and then just have a console right string interpolation which just prints out the item followed by space and now let's run the code and see what happens so we have lots of zeros in the console and this is to be expected because as we've talked about before for the default value for an integer is indeed zero so all this is doing when it says it's clearing it's just actually assigning all of the positions the value of zero and we can mimic this quite easily through a for Loop so if we comment this out and write ourselves a for Loop in I equals z and we want to go to numbers. length and then simply inside we just want to say numbers square braet I equals to Z what you can also write is the word default this will pick up the default value for the data type that you specified you can type in zero or you can type in default it's up to you but I think in this case if you're trying to reset it back to default then you don't have to worry about remembering it or any typos you can just use the keyword default so if we run this code now let's see what happens so effectively we've mimicked what this function is doing but let's have a look and see what other parameters we have access to so if we comment this out and drop the value then you can still see we only have one Constructor normally you'd see the open down arrows on the left hand side to say one of two in this case we only have access to one Constructor it will only give us a range of elements we want to remove but really we just want to clear it does say here in the tool tip the array whose elements need to be cleared and because it is a clear and not a remove you got to remember when using this function it doesn't actually remove any of the positions it just resets the values inside the array so what we can do in this case is we can say numbers comma 5 comma 5 and what that will do is the first parameter is where you want to start so if you want to start at the fifth position and then we want to count five forward and because we have 10 numbers then this should return back okay let's comment out this for Loops it doesn't take an effect and let's run the code and see what happens now so now we took the position five which is actually the sixth number because it's zero base and said we want to remove five forward so itself and then P more forward and there we go we have five numbers being removed so instead of removing all of the different values we can actually clear a certain amount that we want and to mimic this in a for Loop we can do the following we can start it at five and we want to go to 10 and let's run the code and you can see the output is exactly the same when doing in a for Loop you need to actually calculate what this is going to be so we need to take both the numbers the fifth index and the five length which is 5 + 5 and then we get 10 and we don't make this less than or equal to 10 because we have 10 numbers so actually want to go from position five to position 9 which will equate to less than 10 we actually want to go from position five all the way to position 9 which actually covers five numbers 5 6 7 8 9 even though it feels like the difference between the two numbers is only four because 9 5 is four but we actually have five numbers between that 1 2 3 4 5 there we go so when we print the values from 5 to less than 10 we're going from 5 to 9 which is exactly what this is doing this is the index that you start at and this is how many numbers you want to count forward so let's just have a quick recap of this function we defined our numbers array using array. clear it doesn't actually clear the values it just gives us access to removing them back to their default values it doesn't actually clear the array it just resets the the values back to their default type we can have numbers parameter which will equal to our array and we want to say we want to go from index0 all the way to numbers. length which will be every single value inside the array and all that will do is go through the array and set them all to their default value which is similar to what this for Loop is doing and before we had inti equals z and I is less than numbers. length and that will go through every single position you can technically use zero instead of default but that would mean you have to remember the default value of every single data type it's easier to just write the default keyword and it doesn't promote any typos using the default keyword is by far the easiest and the most safest option if you're going to have this situation so making every numbers index equal to default in this case because we're using integers it's going to assign the value of zero and then after this voles run with I is zero and I is less than numbers. length it's going to make all of these positions equal to zero which is in essence what this function is here for because arrays can't be added or change in terms of the values that they have after they've been created you can only really modify what's already there or you can reset them all back to zero using this notation from zero to numbers length you can get rid of all the values and make them all zero using five to five means it'll start index 5 which is the sixth position and then go five numbers forward so it will delete these and reset them back to zero you can mimic is and a follow Loop just like this start in I at five and then go to less than 10 and the reason why it's less than 10 is 5 + 5 gives you the 10th index but because it's I is less than 10 you actually want to go to the ninth index because from 5 to 9 that's actually covering five different numbers and then we can go through and assign the default value and then when we print it out you'll see that all of these numbers have turned into zeros just like so searching through arrays are very helpful when you try to find some data inside your array and you want to return back the position to maybe do something else with it so let's have a look at this example so we have a numbers array and let's say we want to search number 199 and find the index of it so first let's ask the user what the number they want to search enter number to search then we can have in search is equal to convert to in32 and we're converting the console. readline and then let's have a look at the function so inside the array Library we have an index of searches for the specified object and Returns the index of the first occurrence in a onedimensional array this is very important as it says the first occurrence which means if there was another 199 at the end it's only going to return you back this one and then stop immediately and not give you the value of this one so let's have a look in the parameters and see what it takes it takes our array and then a value so our array is called numbers and the value you want to search by is our variable called search if you hover over the index function again it says that it returns back an integer zerob based index of the first occurrence of the value in the entire Ray if it was found otherwise the value is going to be minus one so we can say in position is equal to this and because it says if it's going to be found then it's going to have the value of a zero index and if it's not going to be found it's going to have the value of minus1 so we can say if the position is greater than minus1 because if it's greater than minus1 that means the value is zero onwards we can also write this by saying if the position is greater than or equal to zero it's just up to you they both mean the same thing and then we can say in here number search has been found at position position there we go so let's run the code and let's do a perfect situation so we can can say 50 and you can see it says number 50 has been found at position three and that's the fourth index since it's zero based and what you could do if you wanted to is actually add one to this just so it looks like a bit more of a readable number because four is going to be the fourth number 1 2 3 4 and let's try find a number that hasn't came up like 60 it's going to return us back with nothing this is really bad because it looks like the search has failed which it has but you need to Output message to let the user know so have conso right line and say number search has not been found let's type that again 60 number 60 has not been found so let's see what we can do to be able to write this function ourselves if we just block comment this for the time being we can actually use in position equals to minus1 and the reason why I make it equal to minus1 because when we read the tool tipe of this index function it said if it's not not going to be found it's set to minus1 so why don't we set it to minus1 first and then we can try and find it so in I equals 0 and we want to go to numbers. length and inside here we want to scan each of the positions so we can say numbers square braet I and if that is equal to our search then we can set the position equal to I if the number we're up to is equal to what the user has typed in then we want to set our position to the index we're currently up to and we don't need to have an else because we've already set it to minus one and after the for Loop we can actually take this if statement and put it back down here because the code's going to be the same if the position is greater than minus one which in this case is our default value so in essence if this value has changed then this should always pass EG we've found the number so let's run the code and let's type a number in 30 now it's found at position five now if we try 60 again number 60 has is not being found there we go so this function is exactly doing something similar to this it's going through every single position finding the variable and if they match assigning the index and then after just returning back to position back to the console so let's comment our example and let's see what other variants of the function we can use and let's comment back the first one so using this line we can duplicate it and just comment it so we have some other parameters inside here if we add a comma we can actually give it a start Index this is the starting index of the search and let's say you only want to search from the second number onwards then you can just type in the number two so now if you've run the code and type in 90 it's going to say 90 is not found cuz 90 is the first one and let's try a value like 50 now it says the number 50 is being found at position four because now it's included in the range from two onwards because this is two onwards it'll be position two until the the end of the array if you wanted a very specific range then you can actually give it another value so we can say we want to go from zero and then we only want to go to forward so if you run that now and type in 22 it says it's not being found cuz we' started here and we said 1 2 so now it's only searching between 90 and 199 and if you wanted to include the middle ones you could say you want to start a position one and go to forward so now you get these two numbers and so on and so forth so now if we try number 90 you'll see it's not being found because 90 is not one of these two the reason why you'd use different ones like this if I revert back the first one this will go from two till the end this will go specific range and this will go through everything the reason why these exist is if you have a very very big array let's say it's a th000 indexes then you don't want to search everything unless you really need to let's say for example you had a names array and it was sorted off alphabetically and the person's name that you wanted to search began with an a there is no point in running the search all the way from a to zed if you know it begins with a and let's say for example you found the first index of the user that has a name B so you have now the indexes from the start of the array up until the last array position that has the value of someone's name beginning with a so now you have the two indexes of every single a name inside this array if this was a this was B and this was C and this was D and you had these two positions then you should only be searching all of the a names instead of searching the entire array and the reason for that is you'll be searching lots more data for no apparent reason and it's going to take an extra long time for searching something that you're never going to find if you're searching for a name that begins with a there is no point in searching for anything a BCD and so on and so forth that's where you'd use the very specific range you can say you want to go from zero all the way up to the first B name so then you're only searching the a names this is just one example and there is a lot more every situation is very unique so use the parameters that you want and always use the ones that can get you the best performance the least amount of things that you can search is the best way forward if you don't know what you're going to be searching then you should always use the top one which will just search everything if you know where the value is going to be or roughly going to be the then you can use this one or this one to give you a better range and it's a bit more focused instead of searching for everything so a quick recap of this index function what it will do is it will return you back to position if it's found it the position will be zero based just as arrays are if it hasn't found the position then it's going to return this variable with minus one so therefore after you've run the code you can check if the value is greater than minus one which will be from zero onwards if the value position is z onwards then you know that that number has been found and you can use the position variable to Output that to the screen if the value position is minus one it means the array index function has returned back negative and the value position is now minus one so you can output to the user that it has not been found just in my little explanation down below you can see that we can mimic this function by setting the value of position to minus one using a for Loop that goes from zero to numbers length and if you wanted to as well you could use these inside here if you wanted to mimic this this goes from two till the end so you can say I equal 2 and you still want to go to the length this one goes from one and then to ahead so you can actually put I equal 1 and then because it's two ahead from one instead of numbers. length it will just be I is less than three because 1 + 2 gives you the three so in order to do this manually you can Lube through the elements that you want check if the number you're up to to based off the index position of I is equal to the search variable that the user typed in up here and if you find a match then you can assign the position to the value of I after the for Loop is run you can check the same if statement as we discussed above these are copy and past it down below just to give you an example in this little section all these arrays have static data which means that when you initialize them with a certain length you can't increase that length or decrease the length you can only modify the data inside it and you can't delete any rows if you create an array of size five and you only store three people in then now you have two positions that are being unused and that's unnecessary amount of data stored in your memory if you're not going to be using it up in certain situations like when you're making a game for example Tic Tac Toe then you know you're always going to need a 3X3 grid so a 2d array will be perfect in this situation cuz you know the exact width and height height of your array so you can do this perfectly whereas lists are quite Dynamic if you don't know how many people are going to be within a system for example if you're signing up some sort of register for a class or for a school or something of the sort and you don't know how many people are going to be in that class then you can use something called a list a list a dynamic cuz what you do when you initialize it you just say that you simply want a list and you can add items and you can remove items and you can also modify them if you wanted to expand the size of an array it's slightly complicated but it's not impossible so if you had int numbers equals new int and let's make that length four and let's say we had a numbers array that we wanted to increase to length five we could have new numbers change that position five and then what we're going to have to do is from position zero all the way to three which is our fourth length from the numbers array we're going to have to copy that into 0 to 3 of the new numbers array so now they have the extra data plus the last one which will give us our four so that'll be five length 0 to three gives us our four numbers and then we have one empty one so we've just made a new array and then copied all the data from numbers into new numbers now of course this is not really practical that if you want to reduce the size or increase the size you're going to have to do this each time of course you don't want to do this you just want to use something called a list so let's stick with an example and see what we can do so you make this and three and let's just put three numbers inside here if you remember from the array video we can also declare it like this we can say number 0 equal 1 and then one and then two and change these values these two are doing exactly the same thing I'm initializing it with 1 2 and 3 and also just saying that all the positions in here are equal to 1 2 and 3 so we don't need this twice but I was just showing you as a quick recap so we're declaring array we're calling it numbers and we're giving it a length of three and initializing it to 1 2 and 3 now let's see the syntax to define a list you start off with the word list and then you have a left and a right arrow which makes a little section inside the section you actually want to State the data type that you want so if we're copying the numbers array we can have an INT inside here and that's it for the Declaration of the data type and then we can say new numbers or List numbers equals to new and then there you go it gets Auto filled for you but let's just type it in we have list open the arrow in in the middle and then close it so now it's the same on both sides but because this is a new we need to add a Constructor so we can open the curly braces and the first Constructor says initialize a new instance of the list class that is empty and has the default initial capacity press the down arrow we can give it a capacity of the number of elements that the new list can initially store so we can start it off with five length or three length or whatever it doesn't actually matter it just means that we actually have three positions available immediately if we place three in the brackets and the last one we can actually give it entire collection so let's say if we loaded a list of numbers from a database or a list of something from database and we can actually insert it straight into this list by putting a list inside these brackets of course right now we don't have a list that we're going to assign it with so let's just leave this empty and close the brackets and add a semicolon so we could say list numbers do add and then we can add one and then duplicate this down and add two and add three so now these two have exactly the same contents instead of doing this you can have the same notation like this so you can have the codyy braces in here and we can put in one 2 and three now that's doing exactly the same thing and you see I can just keep adding more numbers in here and the list simply doesn't care but as soon as I add one more into here then I'm going to get a syntax error because it complains that the length is not equal to to the numbers that we have because the list are really Dynamic it doesn't matter how many you put in here because it can just go on forever of course until you run out of memory so let's have a little working example just to see how this works so we can have a for Loop and we can go from 0 to 10 or maybe 0 to 3 just so we don't have to enter as many values we can have a console right that kind of just says enter a number and then let's read that in and we can say in n equals convert to in 32 and we can place a console. readline inside here and then after we've got the console read line we've got an inome that's being converted from the console input inside our integer num and from there we can take our list numbers do add and we can add the num inside there or if you want to reduce a variable you can just take this line and place it straight into here now if you get rid of that when this fall Loop runs will have three iterations let's run the code and find out 1 2 3 so now we've ented three numbers and now they've been stored in the list so let's create a follow loop after and we can go from zero all the way to list numbers do length but of course when we're using list we don't have a length anymore when we're using arrays we have length because arrays have a fixed length whereas lists have a count of the items inside it so instead of length we simply use count and then inside here we could just do what we normally do and say list number numbers square braet I and let's run that and we should see the numbers printed back out in the exact same order 1 2 and 3 and the same principle goes if you use a for each Loop we can say V item inside list numbers and that's all you need to do and you can just print item to the screen now we should see the same output twice let's have a look at other values that we have inside here so we type in list numbers Dot and let's have a look at the functions inside so we can add which you just used above we can convert it to an array we can remove a specific position and we can clear it completely they have other ones in here like binary searches we can check if it contains a certain element this is going to be very handy when we do our remove we can convert them all to a different type we have a copy to we check if a value exists inside we have a find finding all of them the difference between these two is the find will return back the first one whereas find all will retrieve all the elements that match it finding the index of a specific match finding the last index iterating through them all you can insert a specific position whereas the ad will just insert at the end of the list adds an object to the end of the list inserts an element to the list at a specified index and then you have remove which gives you the first occurrence so you can type the number straight into there so you can ask the user what number do you want to delete and if they type zero it will delete the first zero in the list and you can can remove all so if you want to remove every single zero inside the list you can do that as well or you can remove a specific position this is the most used function because what you can do and what you can do is use the find index search for an element that matches a condition and then returns zerob based index the first occurrence so if you want to delete the number zero from the list you could use find index and that returns you back with an INT and then you can use the remove at and then pass that index straight into there you can also sort it so it goes up in number order we did this with the array. sort function as well and if you wanted to you can also reverse the entire list this can be very helpful as we did with the array functions if you just wanted to reverse them all in case someone had something like a filter when you're doing from Price high to low and low to high the difference between them two lists is simply the list flipped so let's run a remove just inside here and let's see what happens so we can say remove that and let's say position zero so we type in 1 2 and three you'll see that 1 2 3 gets printed out and then I'll hit this remove at and it will delete the first index and in this case the first index is going to be our number one so now this has became our first index and this is our second index and it's got rid of the number one so let's move on to a different data structure called dictionaries dictionaries are generic collections that store key value pairs in no particular order they take in a t key key and a t value and these just mean the key and the value can be any data type that you want dictionaries come under the system. collections. generic namespace and if you don't include this line at the top then you'll have to type in system. collections. generic space dictionary every single time you want a specify dictionary putting the name space at the top will include it within the project and you can use dictionaries freely so one thing to know is the keys must be unique and they cannot either be null values can be null or duplicate cuz they're the value values depending on the key as long as the keys aren't the same then the values can be similar so let's have a look and see what we can do we can type in dictionary and you can see it has the arrows either side and you can see here it says T key and T value and what T key and T value is is it gives us the flexibility to add any data types that we want we can add in two strings in here for example or we can do anything that we please so in this example I just want to start a list of names and I want to give them a unique identifier and this unique identifier will just give them a number that their profile is up against it's the same way whenever you make an account with any sort of website when your data gets stored in the database you have a unique ID for your account and this is the same thing that I'm trying to replicate here we have a unique ID and with that unique ID comes a name so we can say equals new dictionary just like we do with the list we can end the brackets and end the semicolon there and now we've created our dictionary and the exact same principle we can use with the list we can simply type in the name of the variable of the dictionary and type in add and then we have access to int key and string value and this parameter is going to change if this now becomes a string as I'll show you now and if we reopen the bracket you'll see this has turned into a string key so that will change depending on the data types that you specified so let's say we want to add one and we want to add ourselves then we can dup at this down and add in two and three and we can say test and test and now if you run the code you'll see that we have no errors and nothing's going to show up I'm just demonstrate that it compiles okay and the same thing with the list we can also simplifies the initialization process and it looks something like this so because this is a key value pair we can no longer just type it in one line they need to be in a little block so when we wrap these around the curly brace we can have the key on the left left and the value on the right and one of these is called a key value pair key value pair and we will use these in the for each Loop in a second when we print out all the values to the console so let me just demonstrate something about what I said at the start I said that all keys must be unique and there's a reason why I said that if we duplicate the first entry therefore giving us the same key as one and we try run it and let's see what happens we get something called a runtime error this runtime error happens when we run the program and it's got nothing to do with compile time or our logic an item with the same key has already been added so we need to watch out if we do this because our program is going to compile but it's not going to work at runtime and let me demonstrate another fact if we make this number four and our values are exactly the same once we run this it will still work fine values can be the same but the keys cannot be the same the keys have to be unique so just like with our lists and our arrays we can use a for each or for Loop to access this directly so we can say 4 in I equal 0 and we want to go names. count and the same reason it to do count for a dictionary as it is for a list but it's not for an array dictionaries don't have fixed length and neither do lists they are very Dynamic and basically are a list list can only store one different data type whereas dictionaries give you a key and a value so as we said above we have a key value pair so let's try and print this and see what happens have a console right line we can say names square bracket I and that will give us back the position the issue with this is it will just give us back the string and let's just see what happens if we print this then we get an exception because no key was given and the problem with this situation is we can't use this like a list Geto sets the value associated with a specified key what this means is when we give our square bracket I inside here this is actually not talking about the index this is actually trying to do a search on these keys so if you actually change this to one then we should get ABA return back this is not actually doing an index Lo up it's doing a key lookup and the reason for that is what we're going to have to do instead is say names do element at and then what we can do inside there is place our index so this element art will return us back with the key value pair as I said above here so how this variable works is we can do key value pair and then we need to specify this variable the same way we've got it up here so we have an INT inside a string and then we can say a pair and make that equal to the function called element at as that returns us back with a key value pair in string and of course if you wanted to make this a lot smaller you could just simply use VAR but let's keep it as key value pair just so you can understand what's going on and the reason why we need to get the key value pair is if we want to retrieve the integer and we want to retrieve the string and now we can use pair. key and pair. value and because these are both integer and this one is a string it matches our pair exactly so we can take these values and go to our console right line and we can say something like this use string nipulation and say pair. key and then maybe add a hyphen and then say pair do value and then just remove these two lines and let's try and run it now there we go so we get all the values and it doesn't matter what this key is it can be something random it doesn't really make a difference like I said this doesn't have to be in a specific order so let's keep it as 1 2 3 there we go so you can see using a for each Loop to print this is a little bit more complicated let's have a look and see what it takes when you use a for each Loop for each VAR item inside our names and as you can see here our item is automatically a key value pair of int and string and again what you can do is type this straight into here just so you can get used to the notation and there you go it's still a key value pair and then now what we can do is we can take this exact line and paste into here and instead of pair we have item and this should return us back the exact same values and if we just separate with a console right line there we go okay so now that we've understood this let's take a look at an example let's comment this out and let's create another dictionary so we can say dictionary and then we can have a string of string and we can call this teachers equals new dictionary string of string again and we can add our curly brace just so we can add our Valu straight to here so as you said before we need to open curly brace and close curly brace and then we can say the math teacher is called abber and then we can add another one and we say the science teacher is called test there we go so we've initialized our teachers and we said that the value that we want to give it is a unique identifier which is going to be our string assigned to the subject and this is going to be the teacher that is assigned to this subject so what we can do inside here is we can have a console right line and we can do something like this so remember when I was saying in the for Loop we can't actually use the square bracket notation like this because this is inferring to a key rather than a position so we had to use element at just to find out the key value pair and then to print out to the console so because the square brackets is an actual sech let's try and make use of that now so we know that there's a math class available so we can type math in here and what does should return us back is abber there we go so what that's doing is it's searching through our dictionary find ing this element inside here and then return us back with the value for that key get all sets the value associated with the specified key the problem with using this approach is it says here if the specified key is not found a operation throws a key not found exception let's just say for instance I mistyped the math and now we're just going to get a runtime error and it's going to be a horrible exception and our code is obviously going to break this is similar to what we do when we have int. trass we don't just trass it immediately and convert it it without actually checking if it's a valid value so instead of doing this line what we can do is we can check if that key exists first before we then use it so we can say if teachers do try and get the value which is a similar to what we have with trass and then the first parameter is the key that we want which is going to be our math and then out here is going to be the variable that we want to Output out so we can say out teacher and then open the curly braces and then inside here we can print out the teacher so we try to get the value for Math and if we found that key inside these then we return back the value inside our teacher the same way works for our tripassure if it successfully passed it and if it hasn't we can say cons output math teacher not found so let's try and run that now you see we get return back abber and if if you actually drop the lower case then it says the math teacher is not found alternatively what we can do inside here let's assume that this is correct we can take this value and place it straight inside the square brackets and do this again this is kind of redundant because we've told it to get the value for key place inside teacher and then we're just going back to the dictionary to get the value twice so make sure if you have an output variable that you actually use it inside here you can see that you're not using it when it goes a slightly dark color like this so just like in the last examples when we were placing values inside our list we can also do that in dictionaries we can say teachers square bracket math and then we can make that equal to something so if the math teacher were to change and now the teacher's called Joel then we can run this line and print out to the screen let's just take that for each Loop and tailor it to the new dictionary and see what happens when we run it so let's just change this into our V to make it simple and then we can have teachers inside here there we go so now let's just run this and see it now it says abber is the first value the abber is coming from console right line here that says teacher this is one line before we change it and we change the value of the math teacher to jaw on the next line and there we go it's committed the change and just like in the last video as well when we try to delete something from the list let's see what we can do to delete it from here so we can have teachers do remove and you can see that it says key in there and again if we add the key in like this then it's going to work just fine there go we just have science we don't have math anymore but if I drop the lowercase then it's going to cause us back with an error but in this case instead of it thrown an exception like it did when we were trying to do up here and up here as well the problem with using the remove is you just simply won't remove it but what it will do is it'll give you back a building if you remember from the last video we actually had a look at a section where in the list it gave you back a booing whether the remove function worked or not alternatively what you could do instead of using the remove function is to check if the item exists in the first place we can say contains key and we can place math inside here and if it does contain it then we can run the same line of code and we can say remove and then use math just to make sure that this is has been actually removed and then in the else we can say math not found retrieving values back should be retrieved using try get just so you don't cause an exception if this is not found we can simply do an update by placing the value of the key inside this square brackets and then simply just assigning it to something else this assignment will change the value of the key which is inside the teacher dictionary and if you wanted to remove something it's best to use the contains key just to check if it contains it first and then you can do the remove and then if it doesn't contain it you can tell the user that math has not been found and then finally we can just print it out like this so in this exercise I want you to create two lists with the integer data type one for even and one for odd and then we're going to Loop through from zero all the way till 20 and if the number is even add it to the even and if the number is odd add it to the odd list and at the end print out all the values for even and for odd I know you can just print these out inside the for Loop we don't have to have dedicated lists but this is just for list practice and I want to talk about different ways that we can do this solution so let's start we can have a list of int and we can say odd new list int and we don't know the size so we're just going to leave the gap empty and if we duplicate this down we can simply just change this to even now the reason why we're doing lists we're going from 0 to 20 of course this 20 value could be anything it could be a million it could be 100 but we don't know and the point is lists have counts whereas arrays have length if we set the array length to something like a thousand we know probably be able to contain all the numbers inside there but that's going to be a lot of positions that we don't exactly need because arrays are not really dynamic because they're static then it's it's best to use list in this case because we don't know how many numbers are going to be odd or are going to be even between this range if we knew the exact number of positions that we needed in a given solution then array would be better since you don't want it to be dynamic if it doesn't need to be so let's start you can have a for Loop that goes from 0o to 20 if you want to include the 20 as well we can just place an equals the best way to determine if a number is odd or even is to use the modulus operator so we can say I percentage 2al equal 0 and what this will do is it'll tell us if I is divisible by two if the value is equal to zero if you have two modulus 2 then the remainder is going to be zero if you have three modulus 2 it's going to be 1 * by 2 which gets you to two and then to go from two to three you actually have one so if you insert an odd number and do a modulus 2 you're going to get a one returned if you do an odd number and you do modulus 2 then you're going to get one returned if you do an even number modulus 2 then you're going to get zero returned so what we can do in here is we can say even do add and then we can simply add I and then in the else we can also simply just do odd do add and then have I because the values of the remainder can only be Zer or one we don't need to have an lse if in here doing this is a little bit redundant although it's still technically correct the values can only either be zero or one so if you run this calculation and the value is zero if you run this calculation and the value zero the only other value can possibly be is one so therefore we don't need additional condition so therefore we don't need this additional condition and we can simply get rid of it if I modulus 2 is equal to0 then we add the number to even and else we add it to odd normally when you have situations like this we can use the conditional operator where we have the question mark followed by the colon but in this case we're actually doing two different assignments we're either assigning into the even or assigning into the odd so there's no room for the conditional operator so at this point we should have all the even and odd values from zero all the way to 20 inside our two lists so then we can now just print both the list out so we can say printing even numbers and then we can have a for each Loop that goes v item inside our even and then we can do a console Right add some inst string interpolation and then we can say item followed by space then we can print environment. new line just to give it some space and we can say printing odd numbers here we go and then we can just take this exact for Loop and copy it down instead of saying in even we want to do in odd and this exactly the same since the variable name is exactly the same let's try run the code there we go it's got zero all the way till 20 and you can see it goes up in twos hence all even numbers and we also get these going up in twos except it starts from one and this covers all of the odd numbers and if we change this number up to something like 50 then the list will just grow and they Cod just still work okay you can see that all of these numbers are still consistently even so now that our task is actually complete let's just have a little recap so the reason why we're using lists and we're not using arrays is for this exact nature if we have 0 to 10 then we can almost work out how many even numbers and how many odd numbers we can have we can manually count we have zero and then 2 4 6 8 and 10 and then for odd we have 1 3 5 7 and 9 so we know how many numbers exist within here but what if we just change that number to 50 then now we have a lot more odd and a lot more even it's impractical to type these numbers in and then to Simply count them in your head and then make an array length based on that position that's a bad solution because not all cases you're going to have the flexibility of Simply typing in the numbers like this and Counting them yourself these numbers could be something that typed in by a user or something loaded for something external like a text file you need to understand that these values can be generated from anywhere and if you just type them in then it provides an unrealistic expectation of how to write some programs so what you have to bear in mind in situations like this is you simply don't know how many even and how many odd numbers will be appearing during this range so you want to use a list so it as dynamic as possible we have two lists in this case one to store all the odd numbers and one to St all the even numbers we don't initialize them with any sort of capacity we just keep it empty for the exact reason we don't use an array we Loop through from zero to anything we don't even have to Lo from zero we can also just start this at 100 and go all the way to th000 it really doesn't matter what our number ranges the only thing that matters is that we have a list that is going to be dynamic and then we can calculate whether the number is odd or even and add it to the right list how this works is we use I which is the number we're currently up to and we calculate the modulus of it to check the remainder if the remainder is zero then it must be even as it's divisible by two and if it's anything else than Z zero which you can only ever be one in this case when using modulus 2 then we add it to the odd list after this followup has run now our odd and even lists have all the values that they should have and we simply just write these two blocks are exactly the same just print the even numbers and print them out print the odd numbers and simply print them out to the screen and that's it and if you run the code it might get a little bit crazy in here but as you can see these will actually work if you pick any random numbers you can see that they're all divisible by two and this same thing goes for odd you can see that they're not divisible to cuz they're all odd so in this exercise we're going to cover a little task I like this call this task an array of multiples so we want to Define initialize two integers and num into length so in the case of this example we have a number seven and the length of five so what this will do is it will essentially give you the seven times table but only the first five numbers 7 14 21 28 and 35 we take the first number which is Nome which will give us the multiples and we take the second number which is the length and that gives us the size of the array so we create the integer array with the size of length Loop through the array and insert the loop count Times by because this is 1 * 7 2 * 7 and so on so forth until we reach the length and we place into the array and then finally we paint the array just to give us these values out to the console all right so let's get started we can have it into norm and make it equal to seven and we have it into length and make that one equal to 5 now the defined initializer two integers let's create the int array with the size length int array result equals new int and we want size length after that we want to create our for Loop now this is the tricky part if we try go from zero all the way to result. length then let's see what happens so we want to start result I you want to make that equal to number which is our array of multiples Times by the value that we're currently up to now let's print our array using for each Loop to see the value so we can say a v item inside our result then we can have a console right that just prints one of them at a time so we can say item followed by spits now let's see what happens when we run it so we get 0 14 21 and 28 and as you can see these are the first four numbers so we're close what we're nearly there because our array starts at zero and it goes to the length which in this case is going to be 0o to less than five which will cover the positions of 0 to four with these positions it's going to do 0 * 7 1 * 7 and then get to 4 * 7 and not actually get to the fifth because we're starting from zero so alternatively what we can do or what you think you can do is change it to a one and changes to equal to so now what it's doing is it's going from one all the way to five which is still covering the same amount of positions it's just one index forward so now if we try to run the code then we get a runtime exception and the reason for for that is it's trying to access position number five if we hover over I we have five and if we hover over the result we actually have some of the right values except it's trying to get to the fifth position and it's not working the reason why the zero index is actually zero is simply because that's the same value as the default value because our for Loop started at in I it's actually only starting from here and going down so this calculation is actually correct but it needs to be back one we need to start the multiplication on IAL 0 but our for Loop needs to start on IAL 1 so we can get all the way through so we have two ways of doing this we could say IUS one so even though it goes from 1 to 5 it's still assigning into the array using 0 to 4 so if we run that we can see that that will give us the desired result alternatively what we can actually do instead of doing IUS one inside here we can define a variable called counter and make it equal to zero we can change this this to counter and we don't need to change the multiplication because that's already going from one to the length which is 1 to 5 in this case after the follow is run we need to remember to increment counter so there we go we have the desired effect another hack if you're interested if you have two variables that you want to increment inside a for Loop you can see that we already have I ++ in here which will increment it by one and we want to increment counter by one as well every single time it loops around what you can actually do is remove this and you know how these are broken up by semicolons that indicates that the section has ended the first section is for declaration the second is for the range and the third is so you can increment the variable or decrement it when you trying to increment two variables inside a for Loop instead of placing a semicolon here and type in the next one you can actually place a comma and do counter Plus+ what that will tell the for Loop is every single time you go through you want to do a series of these actions and because we have i++ and counter Plus+ then that's going to work exactly the same way it just prevents us having counter Plus+ down here and we can move it inside the for Loop just so it doesn't for us and it looks a lot cleaner cuz you can clearly see that every single time we loop around this for loop we're going to increment these two variables there we go so let's try to put some different values in here maybe make this 10 and we can have 10 on both which should give us the first 10 numbers there we go from 10 all the way to 100 let's have a little recap so we're essentially just making an array that will give us back all the multiples so it's like a mini times table but the fact that we're doing it dynamically using our array is quite important what you can do if you wanted to is to extend this program you can ask the user to type these into the console and then convert them and use them right now we're just statically typing them in and that's not really an issue since the main focus was doing this for Loop if you wanted to you could ask the user and you can type these values in so you don't have to change them every single time you compile so now we've got the number and the length let's make our inter the rare call result and initialize it to the length we set up this counter so we simply didn't have to do I minus one here so it looks a little bit more intuitive we start the follow from one and go to the length so we can access 1 to five and the reason why we want to do 1 to five so when we do our multiplication it doesn't start at zero these two are going through the exact same amount of indexes 1 to five is five numbers and 0 to four is also five numbers so when we do our multiplication we want to start from one since the timetable normally starts at one and we go to the length the reason why we're using the counter is so we don't have to do IUS one in here and it breaks up the logic a little bit and it looks nicer with our counter we start our counter at zero and instead of incrementing down here we use this fancy comma and we can say we want to increment I and counter every time the for Loop goes around so we don't need to include the counter increment inside the for Loop and this one line is pretty simple we say result the index of counter which will start at zero which is the start of the array since it's zero base and we say that's equal to the number and the number is going to be a fixed number since this is the multiple and we say number times by I and in this case it goes from one all the way to the lth so we get essentially the times table and at the end we just use a simple for each Loop that will go through all the items inside the result array and just print them out to the screen with a comma after each other using console. WR just so they're all on one line this is the start of the function section functions can also be called method they are used interchangeable in the introduction we discussed dry which means don't repeat yourself and the whole point of dry is so you don't have multiple sections of code that do basically the same thing you want to wrap it around in a function functions are used to improve the readability of your code and the reusability of the code as well having multiple section code that are basically exactly the same can be more prone to errors if you wrap them round and place in One Singular function you can make sure that the error prone and then wherever you use it it will be error prone as well if you have to copy and paste and tweak some code then you're actually exaggerating the amount of errors that could occur and plus it makes your code look a lot cleaner and the structure a lot better since you can name the functions so let's take a little example we have a static void main straight into here this is a function or a method and these are the parameters for the function The NET Framework expects every C program to have a main function with a capital m and it needs to be a static and avoid the parameters don't exactly matter we can also remove them and it won't be a problem the only thing that matters is this needs to be called main if we drop the lowercase on it and try and run the code then we're going to get a build error program does not contain a static main method suitable for an entry point so if you change this back to M and run it again and then it works fine so that's one thing to note about The NET Framework is you need to include the main function otherwise the program won't run and it won't even compile so let's take a look at how we can use this we can have something like a console right line and we can say welcome to my program this is a line that we're probably only going to use once but let's say this is welcome in someone's name welcome AB let's say you had this in your software in many different places you don't want to be recalling this or retyping out this message in case you type it wrong the fifth time and you get a error of course this won't be a syntax or a runtime error it'll just simply be a logic eror because it's a typo so in order to make sure this typo never occurs we can actually make another function so outside of these curly braces and just still within the class we want to create a new function so we want to follow this exact same approach we can say static then viid and we can call it welcome message and we don't need to give it any parameters cuz we're not really going to give it any values just for now now that we've made that we have no syntax errors and we can run it like this except of course there's no body so let's place our console right line within here now if you run the codee nothing is going to happen and the reason for that is the code will still execute in the main we haven't called this function inside the main we've defined it and called it welcome message and we've gave it the contents but we haven't actually made use of it and you can see that when it's highlighted in a darker color that means it's not being used as it says here private member welcome message is on use so now we can simply type in here welcome message followed by an Open Bracket and then a close bracket to denote the parameters that we're going to give it and of course in this case there is no parameters and then we close the brackets and add a semicolon now if you run the code you can see it says welcome abber so just to go over some of these words that we're using static means that we can access it anywhere and everywhere what I mean by that is we don't have the keyword new just before this we don't need to make a new instance of the program class in order to access this so what that means is when we make future programs we're going to have some functions inside our class inside the class you can actually denote if a function is going to be static or it's not going to be static you don't have to specify is it static but this won't let you call it from here because it's unaware where this function is coming from an object reference is required for the nonstatic field method or property because this is static you need to reference something else from a static nature all static means is you don't have to create a new instance of this thing in order to use it we'll see different examples in the future where you have to create an instance in order to use something so let me just show you quickly if we have a test and I say static void something and we can just print out nothing to the screen and let's try and use this so because this class is outside of the program we have to use the notation test Dot and then it should be available within here and the reason why it's not is because you need to insert this public word just before it and public means everything has access access to it and static means you don't need to create an instance now if I type in the dot again you can see we can now see something and the reason why we can see something is because this is a static now if I remove the static word then you see that we'll get a compile error because it doesn't know where this is now if you don't use static you need to do this you need to say test test equals new test so you make it instance of the class and then inside test then we get the something so that's the difference between static and not static essentially it's accessible from everywhere but if you don't want to be accessible from everywhere then you can just simply remove the static word and the user will have to create a new instance before they can use it so this is what it's like without static and this is what it's like with sty don't worry if you don't understand this too much this was just a quick overview but I have a dedicated video later on in the course so don't worry too much about it so now that we've made a function and we've called it successfully in the main and it's printed out to the console so when we're declaring functions we want to specify what return type we're going to have we have a static void Main in here if you hover over main it says void which means at the end of this function it doesn't return anything hence it's void if you have a look at something like an inter. trass and we open the brackets you can see that it takes in a string and it takes in an integer out parameter it also returns us back with the booing so we can have something like 1 2 3 out in result and then it doesn't actually complain about anything but what we can do is also just store this into to a bu success and then print it out to the screen there we go so it says it was successfully true if we remove this or whether we keep it in or not trip pass function doesn't actually complain but the main point here is it defines back a bu that means at the end of this function it will always return you back with a bull and it's up to you if you want to make use of it and you can alternatively you can place this straight inside the console right line and get the value printed straight to the screen or you could wrap this around inside an if statement like we've done in the past Etc and make use of it that way and have the result being printed out inside here the point is you have functions that return something and functions that don't if you remember that we had the array. copy for example you'll see that they have void here because they just apply a function to something but they don't actually give you something back this is the difference of having something like this a string test that says hello and then you can do test. replace and then you can return you back with the string and it says here it returns a new string whereas when we had a string builder for example and we did string builder. replace you can see that alloy does say it replaces a new string Builder you can type anything inside here and it will still affect the current string Builder it won't have to do SB equals s SP replace as you would need to do here because this returns you back with a new string and if you wanted to replace test you would literally have to say test equals test. replace with something like a string Builder all the array functions you don't actually have to do any of that so you can say array. empty and it'll just return the empty array and the ones that we used before are things like equals and that will give you back a Bool because that's determining whether it's equal or not but if you're doing functions like sort for example and doing things like reverse it just simply applies the data but it doesn't return you back with anything so you can literally just call it inside here put your array in the brackets and it'll use it happily now depending on your user case you need to define whether or not you need to use a return type or not for now let's just cover void which means it won't do anything so let's just Define a function static void create and print an array open the brackets close the brackets and we can have it int numbers make it equal to new int with a l three and let's just have 0 1 and two inside here as the initializer let's just do a for each VAR item inside numbers and then just do a console right string interpolation and just have item Follow by space and now that it's dark gray because we haven't called the function so let's make use of it at the top of our code and let's run it now you can see we get 012 printed to the screen and if we make this into a five and simply just add more values in here and then we run the code you'll see that now it all update but because this doesn't return us back on anything and we don't actually use the integer array outside of these curly braces it's not actually available up here numbers won't be accessible inside here because it's simply not within the scope numbers is only available within this curly brace and this curly brace which means when this function finishes numbers has now been deleted from memory so you can't access it after this line void doesn't do anything it simply just does the contents of the function and as soon as it reaches the bottom that's all that happens you can have another function defined that can return a value like I said with in. trass for example at the end of the function you'll see a word that says something like this it will have return and then return back something followed by a semicolon and that will dictate that as soon as that function is done it's going to give you something back now we're going to cover that in the next video but for now we're only going to cover void functions so we can have something more obvious like a static void welcome message and simply just do a console right line welcome to my program and we don't need to return anything here because all this function will do is simply print out a welcome to the screen and we can use that just before the print array so we can say welcome message Open Bracket close bracket and then a semicolon and hit F5 to run and there we go as you can see our main is really tidy now it gives us function names that tells us exactly what's going on we're creating and printing an array and then then welcoming the user to the console and then having a console read line at the end there isn't an awful lot of void functions all you need to know is that when you create a function you need to give it a return type it returns back a certain data type or it simply just doesn't and depending on what you want to do and what you want to achieve with that function really depends on if you want to return a data type or not in the case of these since they're just doing something and then moving on you don't actually need to return anything by it with in. tripath you want to make the function is executed successfully so when you use in. tripos you can see that returns back a bull and the bull determines whether the conversion has been successful and based on that return value you can determine the next steps of your program if all your function needs to do is provide some sort of functionality and then quit then that's fine and avoid is fine but if you need to provide some functionality and then also return a value then you'll need to specify the data type in here which we'll cover in the next video so far we've covered a void functions but we haven't covered return types void functions are where the function just does something but doesn't actually return anything hence the name void let's start with an example if you have a static void print introduction might want to just return back your name after you've printed this line it's going to print it to the console and that's all it's going to do there we go let's say there's a situation where you actually want to use this inside your code you can actually set the console's title by typing in console. title and type in your name inside the quotation marks or you can type in anything inside here if you run that you'll see Abra is in the title of the console right now and that looks pretty cool what you got to realize is now we have two references to the same value now at this point we can actually do something better we can type in static string name equals abber and then instead of using abber in here we can say name and instead of using abber in here we can also say name and they're both using this variable and if you run the code now you see that the same output will happen you have ABA twice both both in the title and both in the console output now the problem with this approach is you're actually making use of a global variable which we do not like in code in situation like this you shouldn't need to make a global variable because there are ways around it so instead of having this which has a print introduction and we've got the name used in there but the name is coming from here maybe we can use this somewhere else so let's say we make another function called Static and instead of void we want to actually return back a string so we can say string and then we can say my name or something like return name or anything you want just make sure you give it a meaningful name so it dictates what the function is trying to do so this is to return the name and the reason why there's a red underline is it says not all called P return a value since we need to use our keyword return now that we add some empty codes and the return it's going to execute fine and the compil error is gone so obviously we don't want to just return nothing we actually want to take this arber and return in here so let's get rid of our Global variable and let's see what we're going to break so we're going to break these two references to the name variable and simply inside here we can actually just call return name and then here as well we can call return name and what this will do is inside here it will execute this function and then return the value in here if this is too many steps for you you can have a string name equals return name and then simply use the name inside the brackets these two lines are doing exactly the same thing except this is using a variable CU we're starring it first and then we're using it whereas if you place it straight inside the brackets that's just going to store it and use it immediately and there's no additional variable but don't worry too much if you're going to do this notation because an extra variable in this case doesn't really matter because as soon as this function is executed the variable used to run this function gets deleted since it's inside the scope of these two curly braces so now if we run the code you'll see that again we have abber and abber but now what we've done is actually controled everything throughout here so if you want name where to change or maybe this changes in different circumstance based on the user that's logged in then you can simply have the same thing now printed in two different locations in the title and in the console output and it's actually coming from one function so we can have a return name and we can make a static in now can say return age and then we can have simply return 23 and that's our name and our age being returned I change us back to abber and then instead of the print introduction maybe we actually want to print a little bit more than the name then maybe in the title what we can do is have string interpolation wrap the return name and maybe put a hyphen in there and then we can say return age so if run the code now you can see we have ABA hyphen 23 so maybe that's the title of our console but then in the introduction we can use a bit more than that so we can have int age equals return age and then in the console output we can have something like this hello my name is name and my age is age and then after we've compiled that together we can place the output inside here there we go so we're using the name and the age inside the console title and then we have this function that runs to get us back the name and the age and then we're using it using string interpolation of course these four lines can be all squished into one you can simply take this dollar sign let me duplicate this line you can take this and paste it straight into here and while you have name we can have our return name and while you have age you can have return age and that will actually rule out all of these lines and you can wrap it all into one there you go and if age were to change like I said before you can simply type this number in change it and you can see in both cases in the title and in the console output it has officially changed functions can be very helpful to reduce repetition in code let's show you an example if you had three sections where you said enter a number and you had int n one equals convert to in32 and then we add a console. readline and then you had this section and you wanted to do num two and you had this section again and you actually wanted to do num three now at this point even though these three are actually identical you want to be using array in this case so you could have int numbers equals new int Square braet 3 and then here we could say numers zero numbers one numbers two and then we don't need the ins because it's already been defined and then we have them like this but because again all of these three sections are exactly identical we can actually run a for Loop that goes from numbers do length and then we can place one of these straight inside here and then change this to I and now we've achieved exactly the same thing but we're not actually done yet so if you run the code and we do 1 2 3 now we stored all three numbers so we have enter a number and then we have the console read line and maybe we can actually make these two lines a little bit shorter so let's make a function static and because we essentially want to return an integer we can say static int read number from console and then if we take these two lines place them inside here and because we need to return back an integer this is the value that we're going to be returning so instead of assigning this position to something we'll actually just immediately return at this point so instead of doing this line now and instead of doing all of this we can simply make this into one line of code read number from console so every time this will execute it will jump into here print out the value enter a number the user will type it in it will read it in convert it to an integer 32 and this will return back the integer that the user typed in and then that will return it back to the console and essentially replace this so if the user is typed in five then it essentially replace this with five store it loop around and if replaced in 10 the next time and then you replace this with 10 essentially and then that gets started inside and so on and so forth until until all the positions have been complete Let's test that 1 2 3 and it still works okay of course I'm not actually printing the values out to the screen so if you wanted to see that quickly for each can have our item inside our numbers and then do a console right with some string interpolation item followed by a space let's run that one two and three and there we go we get one two and three of course you can make these functions and they can return any bits of data that you want you can even have something like an INT array and we can say create random array and then we can create an array call numbers make that equal to new in square braet 3 and we can actually give it the values of 0 1 and two and then just at the end here we can actually just return numbers and then just in here we can have an INT array and we can call that new numbers since we have numbers above just above here and then we can make that equal to create random array and because this returns us back with an integer array there's no compile arrays inside here and we can have a for each follows the exact same approach as the one above new numbers console right line into a console right and then have item followed by a space now if we print these both out you can see that the zero one and two actually comes from the new one it's just we have two console right right next to each other so there's no new line separating them so if we just add a console right line here one two and three and there you go 1 2 and three comes from the three inputs we just typed in and 0 1 and two actually come from the function we've just created of course if you don't like this notation then what you can do is you make it a lot easier you don't even need to make a new variable you can actually just return the integer just like this so if we place this straight inside here actually just make it on one line just so it looks a bit neater then there you go we have our entire function reduced in one line the goal of functions is to make them do as little as possible if your function has two different things it's doing or more then you should break that out into into another function for example if you had a function that did two distinct operations one was a conversion and one was a calculation then you want to split out into two the first function should be the conversion and the second function should be the calculation and the reason why they're separate is because if you want to reuse them as a pair then you won't be able to reuse each of the pairs if you wanted to have a calculation on its own then you can't do that if both functions do the same thing for example you could have a static and it just could be something let's just call it VI and it could just be test for example and if you had the conversion here and then if you had the calculation in here then you need to split this up into two different functions you want have static void conversion and static void calulation if you wanted to use conversion or calculation separately you can't because now it's in this pair together so if you wanted to use them separately you simply can't it's best to keep functions on the RW anywhere just so they have a single purpose so you can give them a name cuz as you can see here we can't can't give this an appropriate name because it's doing more than one task this is doing the conversion this is doing the calculation and this is doing multiple things this could be doing something if you have to think too hard about the function title then you might be doing too much within each of functions these are very easy to be able to decide what they do cuz this one converts and this one's going to calculate reading number from console if this was reading the number from the console and doing something else then it's going to be a bit of a problem because now you've got a bigger name you don't want to be doing reading number from console and and something else cuz then your function name gets also too big and you got multiple dependencies so best thing to do is to call them accordingly and keep them as short as possible so let's say we wanted to make a function that added two values we can have a static int call it add and then we can return 5 + 5 now this function is a little bit redundant although it will actually work so if we go back to our main and we do a console right line and actually print the value of ADD and we go through our function then we see we get the value of 10 which is indeed 5 + 5 but since this 5 + 5 won't change it's always going to be 5 + 5 this is where parameters will come in which we'll cover in the next videos parameters are a way of being able to give the function value so these two can be actually changed there's no point in having an add function if the only ability you can do is add 5 + 5 because you may as well just return 10 at this point so I covered a lot in this video and there's lots of different functions that do different things of course there is quite a lot of lines we're up to 87 this is probably the biggest project that we've wrote so far and even though this is not really a project it's just a bunch of functions that do little things that are made for demonstrations so let's have a recap so first here we're setting the title as a result of return name and return age we can actually take this and develop this further if you want to we could actually say return name age pair and if you wanted to collapse that inside one function then that could be really easy you could say static string return name age pair and then you can have return and literally the exact same line above you can have return name followed by a hyphen and then you can have a return age and then end the line like that so that just concatenates the two values that are returned from these two functions but the point is you keep them all separate if you were to type in very statically inside here AB 25 then obviously like I've talked about above then you're going to have duplication of data and of course we're going to use this name inside something like here and as you can see this name age pair is actually not applicable when it comes back to this format so it's always best to keep these two separately so if you bring it back and we can actually keep it like this now instead of having this code we can actually say return name age PA now will give us the same value at the top of the code it will have ABA hyphen 25 so that's that bit in our print introduction If We Hold control and we actually press on this function it will actually jump us right down and then if we press the back arrow top left we can go back to it there we go and then click forward so in this function we can break down all of the return values into string variables we have a string name equals return name an inage equals return age then we have a string input that concatenates them both together hello my name is name and my age is age and then we print out to the screen or if you wanted to we could wrap all four of these lines straight up into one we don't need to assign these into variables although it does help the readability if you keep them separate but I prefer to keep it like this since I'm used to this notation we can place return name straight into there which will get rid of our name variable and the same thing with age which will get rid of these two variables and of course we're actually storing the string value before we printing it so we could just take all of this and place it straight instead of here scrolling back to the top this little section was demonstrating how we can use integer arrays to read in all the values from the console but wrap it around in a function so before in here you would would have something like a console right line you'd print out the value to the screen that would say something like a ter number and then you have on the next line a convert to in32 and then after you converted in 32 you'll actually start it straight to numbers but because this is going to be the same thing for inster all the numbers you can actually wrap this around in a function so if we hold control again and go to this you'll see that them two lines are very simply placed in here console right Line enter a new number and then convert in 32 based on the console read line and then we're simply just returning that back ready to be stored in the index of the numbers array and then straight after that we're just printing out all the values to make sure it's worked and that all succeeded fine here I was just demonstrating that you can have different return values and it can literally be anything so as you can see here if you hover over create random array it's inside the program class it's called create random array and it returns back an integer array so that's what we're sign into and if we hold control and click on this again you can see that all this simply does is returns us back back a three length array with 0 1 and two as the array positions and then if we scroll back up when we execute this for each Loop then we're simply going to get 0 1 and two just like that since it's a console right and it'll be on the same line with a space after each other this demonstration was slightly theoretical I was saying in one given situation a function should only do one task if your function converts and does a calculation at the same time then these are actually two different things you should split them so you use the conversion in this step and you use the calculation in this step if you wanted to convert something or calculate something in the future then you can only do it now because we've separated them whereas before if you have them both inside here then you simply can't do one operation because you wrapped it around in one section the same is true when I was discussing this earlier on if we kept this name pair is the only way to access the age in the name then it's going to mess up when we use it in here and then we're going to have a duplication of data but because we separated the name and we separated the age we can use it in this function and we can use it in this function and it doesn't interrupt anything this simply Returns the name this simply Returns the age and these two functions make use of them if we had something else underneath there were another function that depended on the name of the ede then again we can simply use them if it was restricted to this function then it's going to be a problem using it in this function or any future ones and finally just to finish off add function and all it simply does is return 5 + 5 and I was saying as of right now even though it returns back a value it's kind of pointless CU you may as well just return back 10 since it's doing the same thing the reason why included this function is that we can set it up and start planting the seeds to understand why functions exist and how to make use of parameters what a parameter is is it lets you put things Within These brackets so you can give this function some data so if you have an in. trass for example these things that we place ins inside the brackets are actually the parameters so we have a string s and out in something and that's how the parameters work on our Tri pass function and just to show you this is how it's actually wrote It's a Bo and then it's called trip pass and it takes in a string s and out in result then we can make this static and I know it's give us an error because we don't have the control path if we just use result and assign it to zero and then return back true you can see that the compil error is now gone on and as you can see here it says bull trip pass string s out in result and if we actually try and use the trip pass in here and press the brackets you can see that these parameters are exactly identical to parameters that were inside of the tripar coming from the integer Library so in the future we're going to study how we can use parameters to pass data inside our function but just for now know that this function is essentially pointless because it's only going to return back 10 and this function will gain the functionality it needs on when we start adding parameters this should essentially be add five + 5 except this is kind of a pointless function because we already know the value is going to be 10 but again this is just helping you understand why parameters are very essential to functions we've covered how to create a viid function and a function that returns a data type but now we want to create a function that gives it some sort of data you may not realize it but all these functions that you normally use like console right line you're actually inserting data consistently into all of these functions if you hover over console right line you see his void console right line and right now there's an open bracket and there's a close bracket if we delete this bracket and reopen it you see there's 19 different ways you can call this function and as soon as you start to type a string you can see we have a string format and an object if you need to and if you type in another string you can see it says string value this string value is actually a parameter If We Hold control and press on right line you can see all of the different functions right here this is the most basic version that just inserts a right line character to the console and then these are all the different parameters that you can give the value of course you can't double click and view the source code because this is hidden inside Microsoft's libraries the values that are placed inside these parentheses are actually called the parameters this is known as functional overloading which we'll cover later on in the course basically that means you can have the same name function but give it different parameters and you'll see why this is helpful later on down the line so let's close this tab in the top right hand corner and let's bring back out code so now that we've passed hello into this function that's was actually given this a string value parameter and that hello is going to get passed straight into the console right line so then when we run the code it's going to print it to the console so let's create our own function with our own parameters so if we take the function I had last time it was static int add Open Bracket close bracket and it simply returned 5 + 5 which we all know is going to be 10 so if we place add inside these brackets and we run the code we should get 10 return back there we go so of course the this is a little bit pointless since it's always going to be adding 5 + 5 there is no way we can change this without the use of parameters so in here we can actually just do what we do when we normally declare a variable we say the data type int and then the variable name and then if you want to add multiple parameters you can simply add a comma so now we can say int a and int B and you can see now we've got a syntax error because it expects us to have both of these values inside if you hover over it there is no argument given that corresponds to the required formal parameter a and then if we insert a by having five for example and if we hover over it it complains about not having B so we can do comma and then do five again so just this on its own is not actually going to do anything we're actually giving the add function the values of five and five and place them inside a and inside B variables these are now known as local variables and they only exist in memory between these two curly braces as soon as this function is done these are deleted from memory and you can no longer access in a and int B you can't just do something like a inside here and think that this can be used up here these are in two completely different Scopes this is one function and this is another function and they're completely separate from each other when you type in five and five it goes in order so int a is the first one so five gets placed into here and this five gets placed in a b so now that we need to make use of them we can simply change this to a and change this one to B now if we run the Corde we should still get 10 but now our function Works a bit better we can give it a set of d so if we actually just put zeros instead of here then we should get 100 returned perfect so now that we've figured out how to do this let's have a look at different ways that we can make use of this function so let's say we had a situation where we did console right enter a number and we add int nor equals convert to in32 and then converting the console do read line and let's wrap this inside a function so before what I was doing is simply just returning back in int it was static int read int and then we took these two lines and place it straight inside here and remove the fact that we have an integer and simply just change this to a return and what this now will say is let's output enter a number to the console let the user type it in inside the console read line and then read it in convert it to an integer and then give it back to whatever calls it so now we can get rid of this and get rid of this convert and simply just type in read in inside here and after the line let's just print it out to make sure it's worked okay enter a number 10 press enter and we have 10 again and that's fine except if we want to use this in another case for example if you have num one maybe we don't actually want to enter a number maybe this time it's going to be enter an angle or something of this sort so what we can do if we undo that we can actually introduce a string message and what this will do now is actually specify the message that we put in here maybe there's a situation where we always want to enter something so maybe we can just replace this and put a string interpolation and wrap this number around in the curly brace and replace it to message so then in here we can say enter a and then we can pass the string variable which will get placed in here so if this is a number then we can type a number and maybe this is something like an angle and then here we can type an angle so we have 10 enter a number and then there you go it says enter an angle then we can have 100 and that's working as well alternatively if you want to specify the entire message then you can remove these and keep it like this and then in both of these situations we can say enter a number and copy that down like this and make sure you put the colum at the end followed by the space there we go enter a number 10 enter an angle 20 maybe the situation where this text actually changed and you just want it to be angle and if you run that again then you'll see that these are completely different now one says enter a number and one says angle but this gives us a lot of flexibility in what we pass in if we keep it as enter a and then let the user decide on what this section is then you rule out any opportunity to be able to do that option if you wanted to to prevent the colon in the space always being at the end you can actually just add that in manually if we bring back the string interpolation we can say colon followed by space so you don't have to remember to always put that in there we go so that's doing the exact same thing and we're actually just reducing the amount of repetition because we have to remember to put a call on Follow by space inside here we might just forget it and then when you leave it like this then the chord is going to look ugly because it looks like this and it's all stuck together so let's make use of these two functions and let's see if we can write a really basic calculator we can say int first num equals read int and we can say enter first number and then duplicate that down change first to second and then change this also to Second and then inside a console right line we can actually have the add function and we can type in first number and then we can type in second number and if you don't want to call the function inside here you could actually just make another int and we can say int result equals add and just bring this line over to here and then in the console right line you can just print the result there we go so we read in both the values execute the add function and then return it back to the user using a console right line so these are the other ones and then here they are so if we do 50 and we do 50 again and you see that I've messed up because we have double colums now so although our calculator did indeed work let's just go and correct that so we can take these off now because we added it inside here 50 and 25 we should get 75 perfect so now we've made a little basic calculator by simply making use these functions and if we just expand this just to show you what it would have looked like so we go in from this and we place our message inside to here and then we have our convert line just like this and then if we duplicate that down we can change this to second number and then to second number and then as for the result we can say first n plus second n there we go you can see the code is drastically longer and is a bit meaningless to have duplica code this is literally the exact same line in both of these sections except for the fact that this ISS first and this ISS second and we're starring in first and we're starring in second so let's undo that and get back to our more efficient code there we go you can see that these three lines are considerably shorter and easier to read this is telling us we read integer here is the value and we want to return it inside our first Nome and so on and so forth let's have a look at another example where we can make use of this so we can have a string called name and we can read this in from the console console. readline but we need to Output a message so we can have another console right and we can say enter your name and then we can have this twice and we can do enter your age and then have an INT age but of course we don't want to be using this approach and putting a console right line inside here with a convert in 32 because although this is actually technically correct now we're UND doing the point Val function so let's change this into our readint and then as for our message well we have the message right here and again we don't need the space colons let's remove that and then as for the name we can actually do this differently so this is actually going to do a string variable so what we want to do instead of having read in we can have another function called read string another string message parameter and then do exactly the same thing have a console right and we can place string interpolation and place a message inside here followed by callon space and then we can just simply return the console. readline there we go and instead of doing all of this we can actually just put our read string inside here and then place our ENT your name inside here just without the call on Space because we don't need that so now we' reduce this section to two lines as well so now what we can do is have a string details and make that equal to a function that we're going to use now we can say user details if we want to give it the name and give it the age and that will give us back a string that we can print to the console so we can say details so let's go ahead and make use of this function so we can have a static and it's going to return as back a string CU we're placing it inside the string and then it's going to be user details and then our name is a string our age is an INT and then inside here we just want to concatenate them two values together so we can say hello my name is name and my age is age and because that's returning us back with a string we can make use of it inside string details or we can place this straight inside the console right line let's leave it as a function call assign into string details and then print out to the screen let's just skip over these sections enter your name AB enter your age 23 and then there you go hello my name is abber and my age is 23 so this is how we can make use of parameters and inside our functions so we can actually give it some sort of data that's meaningful if you didn't use parameters then what you're going to have to face is for example we showed you with this integer if you don't use parameters then you're going to have situations like I showed you before with this integer function it returns back an integer but it only gave us the value of 5 + 5 I mean technically you don't need to return anything you can actually just keep this avoid and just wrap this around in console right line the only issue with this approach is you don't have any option other than to print out to the screen or if you didn't want to print out to the screen and he simply just wanted to return the calculation and then store it inside another variable this doesn't give you the flexibility of that so we change this into an INT and instead of returning it back to the console we just return back the pure value and then if the user decides that they want to print this out to the screen that's fine like here we've made a decision that we want to print out let's just say we had a variable that said in calculation then we place that inside but we actually never wanted to print it maybe we kept it like this and then use Cal for some something else down below or maybe that was something like storing inside a database not everything will be printed out to the screen for the user to see the best thing to do is return the values in their purus form because you never know what the developer or the user is going to make use of that data later on down the line keeping it it's purus form is the best way possible for example in this case we're actually reading back the integer and then print it out to the screen but in this exact case which is the best case scenario that I just showed you we're actually making use of first n and second n but first n and second n and never actually print it to the screen it's always just used for the calculation if we use console right line to print out first n and second n then we're not going to be able to use it inside our calculation and therefore our very basic calculator is now being rendered pointless so read in and add all return back values that we can use in their purest form and that is the whole goal of parameters so now that we covered parameters that are always going to be required let's have a look at another concept called optional parameters so we had a static int add and we had int a and int B for example and then we simply just returned a plus b like we used in the previous examples if we have an INT result and we want to call that function and we give it the value five and five and then print out to the screen everything runs okay because we've added in exactly what we expect let's say we don't actually have this additional five of course this doesn't make any sense cuz we meant to be adding two numbers but just humor me for a minute then what this will do is says there's no argument given that corresponds to the parameter B now of course this is a problem because it's a red underline which means if we try and run the code we're going to get an issue let's say you creating some sort of system that if you entered both values it uses both values but if you only entered one it automatically set the second value to something else and we can achieve this Behavior using optional parameters so an optional parameter doesn't exactly mean quite optional it kind of just means that it's going to be optional but you can also give it a default value this will always add two numbers A and B even if we make a or b optional it's going to still need two numbers to add in order for the function to run so in order to make a parameter optional let's just say we want to make B optional we can type in equals straight after it and actually give it a value so as you can see our syntax error is now gone and if we run the code we should get 55 and the reason why this works is a is now five if you hover over here we can see a is five and then the square brackets around the int B actually denotes that it's optional and it says int b equals 50 cuz we have that here so it's actually using this as 50 and if we don't specify the second parameter then it's practically just doing this which is completely fine so the reason why I said it's not quite optional is because you still need to give it a value of course in here you can use the default keyword in the case of an integer the default value is actually zero so if you just run that code now it's going to say 5 + 0 which is just 5 so it can be optional but you still need to give it some sort of value of course if you're doing a calculator and you're adding two values if you only specify the first one then adding zero to it is simply not going to change it so zero or default is going to be the best user case when you're dealing with default values with integers so another way you can actually specify this is by inserting this thing called an attribute if we remove this equal zero and just before the end we can type in Open Bracket close bracket and type in optional with a capital O and then you're going to get a red underline if you hover over it it says we need to include this extra Library which will import it at the top of our code as you can see here now that this is available it says indicates that a parameter is optional and what this will do by default is it'll give you the basic value for this number so what I mean by that is we can type in here just to show you this b equals and then B and this will just give you the default value based on the data type and as we just said a minute ago that value is actually going to be zero there you go B is zero so all it's doing is saying 5 + 0 = 5 so that's another way of doing it or you could just leave it as I said before you can say in b equals default or in b equals z it's completely up to you I prefer using the default keyword so you don't have to keep remembering which different data types have the default values in the integer case it's zero but I just like leaving the default and we can get rid of this line now let's have a look at different situations where this be helpful if you had a function called print name and we had a string name in here and then we can simply just say console right line my name is and then name this is quite easy to use so we can say print name and then place arber inside the brackets and then run the code and we get abber printed to the screen and that's fine but let's say if we had someone else's name in there as Joe for example then we get Joe to the screen and let's just say as the developer you only want to default this to abber if you you don't actually insert anything so now if you don't insert anything of course we're going to get a compil error because we need a parameter but if we assume what we did here and just follow the same approach if we use default then it's going to give us nothing because the default value for a string is just empty quot which is just nothing but instead of default we can actually specify value so we can say if no one types their name inside the bracket then use abber there we go so you can have this optional parameter that defaults to something and if someone types in jaw or whatever inside the print name function then the default optional parameter is not going to be used since this will be overridden if you have a parameter placed inside here so now the abber is going to get overridden by the jaw because this is actually the parameter that's being used in the function so you've looked at functions with normal parameters optional parameters and now let's take a look at name parameters so let's say you had a situation where you had string name ABA in age equal 23 and string address equals one something Road and then you had a function that would simply print these details out to the console so start void print details there string name inage String address so you have three console right lines that just print out a name value pair just like this and then when you go to call this function what you're going to have to do is specify the name then the age then the address in that specific order as per the parameter show if we try and run the code now we should get the desired output perfect let's say for example you wanted to rearrange the parameters and put Age first you'll see we have a compiler error now because age and name are in the wrong order string name should be first and int age should be second we can still achieve this by using something called name parameters we don't have to stick to this order if we tell the compiler which parameter we're directly talking about so we can say age callon because our parameter is now called age as you can see it's been being highlighted and then after the call on it's the variables that we're talking about so it just happens to be that age is the same value as the edge so maybe we can change this to age input and place input at the end of these so then we can have age equals age input and name parameter equals the name input and the address parameter equals the address input now we can have it like this and to make it look even better you can actually add new lines in here just to break it off like this and this is a similar pattern that you'll see in normal production code putting a space here can separate them out a little bit and there we go it doesn't matter which order that we put these in right now we can even put address first and it'll still work okay and if we run it you should still get exactly the same output it's just specified in a different way so let's just have a little recap to make use of name parameters you don't need to do anything to the original function you just write it exactly the way you're used to doing you specify the parameters in the order that you think is sensible and when you go to call it you can simply just type in the parameter's name first followed by colon and then the variable name that you want to address once you've done that then you can use name parameters you can go back to using the normal function by just getting rid of the name followed by the colon and just replacing all of the parameters using the correct order and the original variables instead of the new notation having Name colon followed by name input so far we've covered functions with no parameters normal parameters optional parameters named parameters and let's look at a concept called out parameters let's demonstrate a quick example so if we call a function called test and we pass in a value and let's just make this work so we can have an INT Norm equals 0 and then we have a test function so we can say static void test and we can say in Num and inside here let's make num the value of five now in this example if we print out num to the screen what do you think is going to happen is num going to take the value of five or is it going to keep the value zero I'll give you a second to think and let's run the code so let's run it and see what happens and if you guess five you're indeed Incorrect and if you guess zero you are correct and the reason why it's not five is because when you pass a num inside this parameter it just becomes a parameter and therefore it becomes a local variable even though these two variables are actually called exactly the same thing you'll see that when I highlight it it only highlights this one and doesn't highlight this one and the same is true for this it highlights these three references but not the ones down here the gome variable is only accessible in each other scope this one is available through here and here and this one is available through here and here therefore if we use this assignment then it's actually doing nothing if we print out gnome inside here num equals num and then we print that we can see that it is assigned the value five but because it doesn't do anything at the end of this function then it simply doesn't get returned back or anything happens to it so let's see how we can make make this in to five when it gets printed out here so the options that we have is we can actually make this vo an integer and we can say nor equals 5 and then we can return num or alternatively we could simply just return five and not do both of these lines so if we run that now then we still get zero and the reason why we get zero is the test function is being called and it returns back an integer but we're simply not doing anything with it so we can say num equals the return value of this function which will be five and now if we run it we should see our five perfect now this is a little bit cumbersome and let's say you wanted to return a value and return back another value at the same time then what are your options so let me show you a quick example when you're using int. tripod we have a string s an out in result and a bull so what this function is effectively doing is return you back a true or false value to dictate whether or not the conversion has been successful and it's also returned you an out into result and what what this means is you can actually specify integer variable straight inside the brackets so in essence this function has gave you back two values it's gave you back something from the integer parameter and it's also returned back a Boolean variable so let's convert this to code and see what the third option is of trying to return back five over to this so if we just comment out this line and as you saw in the trip pass you simply just need to put the word out just before here out in Num now we don't actually need to return anything in this specific example because we want to just change a num variable using the out parameter but if we wanted to return something separate to the num like a booing like the tri pass did then we have that option so we can return back true but just before we return back true as there's a red underline here it will say that the out parameter gome must be assigned so we need to give num a value we give it the value five because what we're actually doing here even if we double click on this we'll still still get none being selected here cuz the scope is still exactly the same now except what's happening is when this variable gets returned it actually gets put into the variable that it was initially called with so let's fix these compiler errors first so the reason why it's complaining is because we need to give it the out keyword so when we're specifying in Tri pass our first parameter is a string so if the user types in 1 2 3 we put in the first parameter and then we'd say out in result or something along them lines you have an out and then you say you want to make a new integer and you want to call a result see in our case we don't need to put int just like in here because we've already created our num so the only keyword we need is out to follow by space and now of course we're trying to assign this back into an integer which we don't need anymore because this is a booing so we can say bu success equals test out n so we print out Success Print them both the screen now we should have five and true the true comes from the return true and the five comes the num equals 5 so what's actually happening here is we're creating our new integer we're passing it into this function we're also telling you it's going to be an out parameter so this function can still output things to our number variable and then when it gets placed inside here we assign Nome equal to five and then just because we have a bull we have to return true or we can return false of course we can just take this out completely take away the return true and just keep this as test of course in both scenarios these aren actually do anything they're just complete random values it's just made for demonstration so bu is returned back true or false doesn't actually mean anything I was just demonstrating that you can have two return values from one function there we go we get five when we run it just like this so now I've completed this little example let's have a look at how it's used in the real world so before we continue let's see if we can rewrite the tripal function in our code so it's going to be a static returns back a we have a triy pass our first parameter is a string s and our second parameter is out out into result and inside there we can just do result equals to zero and then we can return back true of course we actually need to do conversions inside here if you want this function to work but I'm just showing you for demonstration purpose if we uncomment this line out and have a look at the parameters again you'll see that now they line up perfectly string s out in result and it returns back a Bo which we have exactly the same here there you go bu in. trass string s out in result so that's how this function has been declared of course they're doing something inside the body that can take in the string convert it to an integer place it inside result and then return whether or not the function has been executed successfully so now that we understand how to make an example and how to make the trip pass function ourselves and to give you the Declaration let's have a look at a real world example so if we had a list of string and we had our shopping list that was used from the examples we can have list string and let's just create our own initializer just with coffee and milk inside there we go so now that we've created that we've got our shopping list if you wanted to find something inside the shopping list we have the function index of and what that will do as it says here searches for the specified object and Returns the zero based index of the first occurrence so if we were to search for coffee then we should get return back zero so let's try and run this and put it in the console right line and see what the value is there we go we get zero since it's the first item and if we place milk inside here we should get back one there we go so let's try and rewrite this function into our own code so all this will do is loop around all of the positions until it finds it and it'll find the first one and it'll return us back the index so in this case there's no out parameters but there is a return value so we can also include an out parameter and then instead of assigning the value of minus one we can actually assign the value of true or false to dictate whether or not that we found it so let's write the code normally in here and then let's wrap it around in a function so we can say int index equals minus one because we want it to start a value that we know is incorrect since the lists are from zero onwards the value is only ever minus one then that means it's not in the list then we can then create a for Loop entire equal Z shopping list do count cuz we want to go through every single item inside the shopping list and inside here we want to do a lowercase comparison so we can do if the shopping list square bracket I do to lower do equals and then we want to make that equal to just something that we're going to type in statically so we can just say copy we can make this into a parameter after but this is just for demonstration purposes so we have a bracket and if we found that match then we can say index equals to I cuz the index of the position that we want to find must be up to I cuz that's the one that we've made a match with and we don't need an else inside here we don't need to set an else inside here to make it equal to minus one because if it simply doesn't find it then the index variable won't change its value so it will always stay minus one if it doesn't find anything so after the follow Loop is run let's just print index out to the screen there we go we have zero and if we change this over to milk run it again then we actually have one placed inside here perfect so now what our function is doing is giving us the values of the index if it finds it now if you type in something else if you just add another can let's see what happens then we get minus one and minus one means that it's incorrect and it hasn't found it and what we we can do inside here we can say if the index is greater than minus one then we can say found or else we can say not found so let's run the code now and see if we get a visual representation not found and if we changes back to milk run it again then we get found perfect so as you can see here we're actually checking if the value is greater than minus one but it'd be easier if you had a variable called found and is actually a booing variable so we can make a Bo found and make that equal to and if statement condition so we can say something like index is greater than minus1 which is exactly what we had here a second ago and because this is a condition it's either going to return back true or false and it's going to place the value inside found and then we're going to use found inside here this is easier logic to understand if this is true then it's found if this is not true then it's not found true true false false it's quite really straightforward and very easy and clear you have an index and you have whether not it's being found so let's try and wrap this around inside a function so just as the trip pass does it returns us back with a Bool which in this case will be our found and it also gives us back an integer result but in this case it's going to be our index so let's see what we can do to write this so we can have a static we want to return back the Bo and we can say find in list we need to give it the item we're going to find so we're going to need a string s we need a string s for the item that we're going to find we need to give it the list as well and then finally we need our out int index there we go so let's comment out this code here and let's copy this down into our function and see what we need to do so index has the value of minus one we don't need the integer variable declaration here because we've already declared it inside the parameter so after declaring inside here we give it the value ofus one minus one indicates it hasn't been found since the index are zero based so instead of shopping list we now just have list and list here as well and then instead of having it being equal to milk we actually want to use our s variable and to make it better we can convert it to lower case just so we have lowercase conversions on both sides of the equals if we find a match between the list that we've passed in and the S variable which is our surge term that we've passed in then we assign I to the value of index and then it's still got a red underline because we haven't returned back bu so right now we actually want to return back the found variable so we have two options here we can return back found or we can simply take this and return it back in here we don't need to run this code to see if it's found or not and then store it and then return it after since we're not doing anything else with it we could just return it like this this makes the code considerably shorter because this will just return back a true or false if the index is greater than minus one then it will turn back true if the index is less than minus1 then it will turn back false so let's see how we can use this function inside our code now so we wanted to search for milk so let's just copy and paste this line and let's see if we can get the same output as the shopping list index of so now our function is called finding list you have a bracket and then our string s is going to be our milk our list is our shopping list and our out in index so this is going to return us back with a booing so we can print that booing to the screen and then if we just duplicate that down and we can print index to the screen and maybe using a console right line and just place a space right at the start so we print out whether it's successfully converted or not and we get the value back from it let's run the code so we get true plus the value of one so that means it's found it and it's found it at one index and the previous line before it which just run the normal index of function also return back one so they're both the same let's just get rid of that space so if you change these both to coffee then hopefully we should see the same result but with index zero there we go this zero comes from the index function this true is from our function telling us has been successful and this zero is the index so we can actually take this and put this straight into an if statement so just like we had down here with the found and not found we can say if and then this function call and then we can say found and then the item what we passed in so in this case it's going to be coffee found coffee found coffee at index index and if it hasn't been found then we can just print not found and this is getting an error because we have two indexes up here so let's comment out this line and let's try running out found coffee index zero and you can see these two are the same again one comes from here and one comes from that index we change these both to milk now milk milk and milk then run the code and you see F milk index one if you wanted to just before you pass in here you can ask the user enter an item to search start inside string search equals console. readline and then instead of passing mil in here we can just pass in Search and then instead of passing milk in here we can also use the search variable so now if we try run it again we can type in milk and then we go file milk index one and then coffee found coffee index zero and just to give this a test let's just try and find m not found perfect so let's have a little recap based on this function so initially we tried to assign the value of zero and then print out a normal function and inside test we just had a simple num equals 5 and what this was doing inside is just locally assigning it but not actually return anything and then we said we could assign it and then return it back and that was another option of being able to assign the value to five and then we useed the out parameter which allowed you to pass in an integer when you assign in here it will pass it back into the original call and place it in this variable here so when we print out on the next line it says it's equal to 5 we wrote our own little shopping list for the list of strings and then we called the shopping list function index of and then we actually created our own index of function and made it into a function so just a little recap what's going on here we have a string s which is our search term the list full of the items in the index that we're going to pass back to the user as well as returning back a bu to indicate whether we found found it or not we set the index to minus one so then that completes our logic at the bottom minus one means it hasn't been found since the list is all zero based if this value is greater than minus1 then that means that we found it inside the list since the list is zero Bas and if it's not that and this returns back false then we mustn't have found it because this line would have executed so we Loop through the list we do a lowercase comparison on both sides of the equation on the list item and on the sege term if they both match we run the index and stall the I variable inside the index and then we return whether index is greater than minus one so after we've turned this back from the end of the function we can see once we run it inside the console right Line This is just going to return us back with a true or false value as well as creating our new integer variable called index so on the next line we can use index and print out of the screen this line should return true or false since it's a Boolean return and this variable will either give us minus one or something above minus1 but in this case when we actually make use of the function we can ask a user to enter something get them to type it in and pass that into the function but more importantly when this function returns if it's true we output it's been found and if it's false we output not found and we only make use of this integer variable should this return back true there is no point in printing minus one to this screen because that's what you're going to get if it's not found it's going to look something like this which is kind of redundant because the user doesn't care about this so we don't need to include it when we're printing not found but we should include it when we're printing out the found of course this is just a random example and you might not need to print it out to the screen or you might just do something else inside here you might be searching for something and then you might want to edit it or do something else with it and then you can make use of that index if you wanted to ask the user to search for an item and then tell them what they want to replace it with then you can also do that just as we've covered in the last examples so after after we've covered out parameters and normal parameters let's have a look at a concept called passing by reference so we created interm equals 10 and let's call it assign and we passed it straight into here and we can have a static void assign in N if we say Nome equals 20 if we use a console right line up here then Nome is still going to be 10 because we're not returning it and we're not really affecting it now other ways we can do this is by changing this into an INT and then we can say return 20 and then we don't really need this anymore so we could just say num num equals a sign and then we'll get 20 assign back in there we go or we can actually make this an out into num and then we can say num equals to 20 and then inside here we can say out num we don't need to return back in anymore so we can make this Vol and you see the value 20 so there are different ways that we can assign a variable straight from here so let's let's have a look at another method so instead of having out we can actually use a new keyw called ref and the reason why it's ref it means it's passing it by reference so when you pass a value in through a parameter normally you're actually passing by value and what that means is you're copying this value that gets passed inside the brackets into here and it's making a whole new variable what I mean by that is this might have memory dress location one and then when this variable gets created it has memory dress location 2 for example and then it's used within here and then two is now deleted because you've got rid of the variable because of this function but one is still alive since in the main function when you pass by reference what you're doing is you're saying give me the memory address location of the variable inside the brackets and give it into this function rather than copying the value so if this has memory just location one and you pass it into here then it's also going to have one so what this actually means is if we put this ref keyword just before the in just like we do with the out and we can place it here as well we're now saying we want to pass this by by reference so when this 10 gets passed in here we actually have a link if you will to this gome is now linked to this gome which means if we simply do n equals 20 and run the code then we're going to see 20 the main differences between reference and using the out keyword is when you're using out within a function you actually need to make use of the value if I don't include anything within here then I'm going to get exception and it says the out parameter num must be assigned so when using the out keyword num has to be assigned when using the ref keyword you don't have to make any assignment because we're just passing a reference in with the out keyword you literally tell the function I want to Output this value but if you haven't gave it a value to Output then of course it's going to be an error so we can assign in the reference if we really want to but you don't have to and it's not required so there are the two main differences between passing by reference and passing by value and also using the out parameter passing by reference is technically quicker because of efficiency when you don't pass it by reference you pass it by value which means it'll essentially place that 10 inside these brackets instead of passing the variable in it actually just passes the value and then it makes a whole new variable down here when you pass it in by reference you're essentially actually giving it a link to this memory address location from inside this function which means that you don't actually have another local variable inside here because this one is affecting this one directly you can do this with any amount of references you want by simply just changing them and adding another one in like that for example and then we can have a string name and then we can pass our ref name inside here and inside here we can say name equals hour and this doesn't like it if it's unassigned so we just give it empty quotes or we can sign it another name it doesn't really matter it's just a demonstration and if you run that but let's just print out the name as well to the screen there we go we get Abra assigned into there and same thing with this variable is we're actually just passing in the variable as a reference rather than as a value it doesn't matter what the value is going to be CU it's just given this variable inside this function so we're actually saying name equals we'll basically just assign it back into the original variable so let's just have a look at another example so we can have some sort of like change name function and we can give it the name variable as a reference and then we can give it the new name that we're going to pass in in a second so if we make a new function static void change name you're going to need a ref string name and a string new name and we can simply say in here name equals new name perfect so let's give this a shot so if we just comment out this little section and we can say console right enter your new name then we have a string new name equals console. readline and then just up here as we've done before we could just declare the name as being Joe and then we enter the new name call this function and then after we can say your new name is and then we can pass in name perfect let's run that so at this point the name is actually Joe cuz we've made it appear and then we'll enter a new name so we can type in abber now it says your new name is abber perfect so all this function is doing I know it's pretty pointless right now cuz it's just doing one line but all it's doing is assigning the reference to the variable that we pass in so what we can do now is make sure that we can actually assign this variable in and we can also pass in a Boolean variable so what we should do now is actually make sure that we can do the assignment properly cuz you don't want to assign it if the value is empty and then return back a booing type just to indicate whether or not it's being assigned so what we can do in here is just on the change name we can wrap this around an if statement and if this returns back true then your name has been changed and if not we can say console right Line new name cannot be empty or no in order to be able to do this check as we've used before we could say if new name and then just around that we can say string do is n or empty and wrap that inside the brackets and we want to say if it's not n or empty then we want to do our assignment after we've done our assignment we can return back true inside here and then just outside we can return back false notice how in this little bit of code we actually don't have an else we don't need to write else inside here and place return false inside here because if this returns back true then it's going to execute this one line return back true and since it's a return it's going to jump to the end of the function so we don't need the else in there because the only way that this line will ever execute is if we actually had this function returning back false so if this returns back true it's going to hit this line hit the return jump to the end if this returns back false it's going to skip over the if statement and then just return back false to the user perfect so now we've got no compile errors let's give it a run so we want to change your name to nothing if we just press enter then we can see it says says new name cannot be empty or no and if we type something in then we get our name changed so just to round up this video let's talk about the main differences between the ref parameter and the out parameter when you sign in by reference you actually have to make the variable before you pass it in for example you can't just write ref string in here and that actually works whereas you can't actually do that with the end let me demonstrate so if you had the in. trass and that has an out parameter you can actually type out in index inside here you don't actually have to make the int index inside here and then specify it outside you could just initialize and declare the variable straight inside the brackets whereas because you're passing a reference with the string you actually need to make the string first and then pass it in so that's a big difference between the out and the ref when you make use of it actually inside the function if you're using a reference then you never have to assign it or at least it's not required you could have a series of if statements inside this body and then you might determine that you might not need to assign it which is exactly what we've got here the only way we assign name is if this returns back true if it doesn't return back true then we simply don't assign it and move to here this is a problem if the out variable if we change it to an out then we're going to get a compiler error because it doesn't return back a value so we'd have to write something like this at the top name equals something and then potentially sign it here and then return back false so with reference you don't have to worry about the fact that you might not assign in every single path of your code and finally the main difference is the fact that out parameters are still used by value and this is by reference reference will be slightly quicker since you'll get the memory just location being passed in instead of the values so you won't have two copies of the same variable the focus of this task is to create a function that calculates the area of a triangle so we're going to ask the user for width and height install them both create a function to calculate the area the function is going to calculate it using width times by height taking that calculation and dividing the value by two call it in the main and print out the area of the triangle to the screen so let's start with entering the width and the height so we can say enter width callon and have int width equals convert to int 32 console do read line and if you copy these down change width to height and change width here to height and just before we continue because we did copy and paste down then this is quite bad and we should use a function here so in both of the cases we're going to output something to the console and then read it in and convert it back as an integer so we it says static int because we return back an integer so we can store it we can say read int and we want a string message so we can pass in this value inside here so we take these two lines and place inside here instead of enter height we're now going to have message instead of int height we're just going to have a return value and then we're ret return in the conversion from the console read line and now we can use it inside here read in and inside inside the brackets you want to put the string output which is going to be enter height if you paste that inside here and then do the same thing for the previous section and change height to width and now get rid of these so we just have these two lines perfect so let's just print these out to the screen on separate lines just to make sure it's working see the width of 10 and height of 15 we get 10 and 15 Perfect Since that's working okay we can now create a function that can calculate the area forward so we can get static int Cal area and we can have int width and in height and then taking this formula we can simply just do return bracket width times by height / two as you can see this is literally exactly the same as what we've got here it's crucial to include the brackets because we want to do this calculation first take the value of that and divide it by two if this is too many steps you can actually break it down we can say in calculation is equal to to the width times by the height and then we can simply return calculation / two back to the function it's slightly grayed out because we haven't use it but that's not a problem we're going to use it now I personally just to prefer is to keep that inside here and just have the brackets since a bit more obvious to me what's going on but it's up to you as the programmer either way it makes no difference it's just more for the programmer's convenience so now we need to call the function above so we can say in result equals calc area and then pass in the width and pass in the height and then we can have console right line that just says the area is and then result and then let's run it so you have 10 and 15 and there we go we get the area is 75 perfect if you didn't want to call the function inside here and St it inside a variable you could just output this straight to the screen by placing the function calls straight in the cly braces and if you run that again just to make sure 105 and we get 75 again perfect so just a quick little recap we have the console right plus the convert inside this function which will let us return is back an integer and we can pass in the message straight in the variable to make this a little bit quicker and a bit easier you can actually just change this one word inside here so you could actually say enter message call on space and then just inside here you can say height and just inside this one you can say width just to reduce on code because in this specific case the only thing that changes between them two string variables was the fact that one was width and one was height there we go you can see it's exactly the same now so after we read in these two variables we pass it into the function and all the function will do is take width and height times them both together take that value and divide it by two and return it back to the user and then we can call it straight in here the area is calc area and pass in width and height in this task we're going to create a function that will return us back with the sum of numbers inside an integer array so first step is to create an initialize an array of numbers create the function with the int return type and it also takes a int array as a parameter the function should return a total of all the numbers inside the interray call in the main output the total and just for extra bonus points inside the function instead of using a for Loop immediately you can check if the array length is greater than zero and then return minus one if it's empty and then check that inside the main and then output a specific message and also see if you can think of any other implementations you can use instead of having to do return minus one how else can you make this function whether that means you have to change the parameters of return type or anything like that just have a think about the situation and see what other options you can make of course the output at the end is still going to be the same but it's the way you do it and the problem solving skills that I'm trying to get you to get used to let's get started so let's create initialize an array of numbers so you have int numbers equals new int and let's just allocate them manually 1 2 3 4 5 and add a semicolon there we go now let's create the function sum of numbers and we want it to return integer back with the total then we want to take an in Array called numbers and then inside here we need to actually return back an INT so we can create an in total make that equal to zero and at the end we can return total and then during the middle we're going to have to write our for Loop so we can go through the integer array and count through everything so we can use a for each V item inside our numbers and just inside here we can say total plus equals item perfect so if we can call in here we can have a console right line and we can just say sum of numbers and pass our numbers array in the parameters so we're just going to Output it to the screen just for the time being so sum of values from zero all the way till 5 is 15 perfect so now that we've done that we've created a function that Returns the total numbers call it in the main output the total so we can just say the total the total is and then wrap this around in the C brace there we go the total is 15 now with the extra points we can check the ray length and return minus one if if the array is empty so let's see what we can do in here before we even end up going inside anything to do with the total we can wrap this around in if statement that says if the numbers do length is greater than zero then we can proceed with this little section so if we highlight all of this hold alt and press upar key then because it's one back just press tab ones and just press the delete key here and let's get rid of the empty Line This is going to return us back with an error because not all code path return a value if this returns back true then we'll eventually hit a return but if this return Z false then we not do anything inside here so let's have a look at our requirements return minus one if the array is empty this dictates whether the rray is empty so if this returns back false then it's going to come into here and we can say return minus one so we've got this function call in here we don't want to print the total right now because we want to make sure that this total is actually greater than zero because we don't want to make a sum of the numbers if the array is empty so if you run this right now going to get the total is 15 and if we get rid of all these variables and just have the length of five but not give it any value so all the values are going to be zero then if we still run that then the total is going to be zero but that's still an acceptable value because that's actually got values inside but if you said the array length is zero then the total is minus one of course we don't want the user to see minus one so we want to bring this back and instead of calling the function immediately down here let's call it here we can say int result is equal to this and then we can say if the result is greater than minus one then we can output the total and again press into this line hold alt and press Arrow key and then we can place the result inside here and the L's to this will be canot add up and empty aray there we go so now if you run it we should still see 15 but if we get rid of this and put it back to zero there we go we cannot add an empty array so we bring that back perfect so now if we check this we've got check in the main output the message and then now we've got this little solution do we need to return minus one how else can we make this so right now we're going to have to return back minus one cuz that's the only way that we can tell the user whether or not it's been successful if the ray is empty we return minus one and if the ray is not empty then we return something greater than minus one which will be something above zero or Zer itself but as long as it's greater than minus one that's how we know it's complete but we don't actually want to do this we want to be ideally returning back a Boolean so let's duplicate this function and show you both implementations let's change this into a and then because we're still going to need to reference the total we're going to have an out in total so we need to change up a few things inside here instead of this return minus one we can do return false to indicate that it hasn't been successful instead of returning back total we can actually just return back true now we haven't done everything yet we don't need to redeclare in total inside because we already declared it inside here so we could just initialize total to equal to zero but the problem here is if we make total equal to zero just within this path then it's still going to complain that total must be assigned so we can take this and just assign it right at the start of the function just like that there we go so we make total equal to zero that gets rid of the compil errors and gives it a value the reason why we have to give it a value is because this out in parameter doesn't like it if you don't assign the value that is a requirement for using the out parameter so make total equal to zero check the numbers length If This Were to return back false then we return false to indicate that we can't do anything if this returns back true it will go through and count all of the items place inside total and then return back true so let's have a look and see what else we can write this little section of code so instead of having to call inside here and use it within there then we can actually do this another way the reason why we actually calling this straight inside here is because we can't place this straight into here since it returns returns us back with an integer and now that is actually fine if that returns back with integer cuz as you can see there's no problems here the issue arises is when we have our result variable we can use it inside the bracket and down here there's no point in calling this twice to get the same value although this would still technically work but this is not really efficient since you calling the function twice it's best to call it once store the value and then make use of it twice when we use our out parameter you'll see that this gets a bit easier so straight inside the if statement we can say sum of numbers and then we can pass in our numbers and then space out into total and what that'll do now is because this returns us back with the bull we don't need any additional conditions like we have one here cuz this will turn us back with a true or false true if it succeeds false if it doesn't so we don't need to say if it's greater than minus one because we don't actually care about the value of the total right now we just care if this returns back with true or false so inside here we can take this same output message and instead of having result here we can have total and then we can take this exact L statement and place it here and let's see what happens now the total is 15 and the total is 15 so they're both return back the same values let's add something else on here just to make sure it works there we go so you can see that both these Solutions look very identical but one is considerably different we have to make a variable outside use inside here and use inside here whereas in this function we can actually just call the function straight inside that will process our new out into total and then we can simply use total inside here and we don't have to require another additional variable just outside here as this one will and you can see that the functions is a little bit better because we're returning true and returning false to indicate whether or not it's been successful whereas in this solution we have to return back an arbitrary value and then check that in the console the reason with returning minus one is kind of a problem is what if these numbers are actually all negative then this value is going to be very bad this can only read work if all of these values are positive if you had negatives for all of these and we tried running the code there you go this is a major issue cannot add up an empty array well it's not the fact that it is empty it's the fact that these values are smaller than minus one so you don't actually want to be going with something like this approach where you're comparing the value because you don't know what numbers are going to be typed into here if the user were type in positive or negative you want to provide a solution just like this one that works for either positive or negative you don't want to restrict that by checking if it's greater than minus one will only works if all of these are positive values all this is an index for the array since arrays start at zero and go upwards you can't have a negative 1 array position but in terms of numbers that are randomly typed inside of a ray you should always be wary of using this option because if some of them are negative then this could return back false so let's just have a quick recap so we have an integer array we have our values initialized down here and then the first solution we call the function pass in the numbers array get our result back check if it's greater than minus one then that means it's been successful so we print it out and else we tell it it's an empty array now second option we actually call the function because it returns back a booly in this case so we can place it straight inside the if statement and then we can pass in the numbers array and then we have it out in total which will give us the total and in this case we don't need to check the value because this returns us back with the true or false and in this case true determines whether it's been successful and false it doesn't if it returns back true then it has some values inside the numbers array that we can actually add up and if it returns back false then that means the array is empty so let's have a look at the implementations so without the out parameters this is the first solution up here we get the numbers length check if it's greater than zero if it's not we return minus one make a new variable called total make equal to zero and we run a for each Loop of our item inside the numbers and we just say total plus equals item add them all up in the for Loop and simply return the total and then in the out solution we have a total equals zero which just initializes this variable otherwise we'll get a compile error then we can say if the numbers is greater than zero then we can say if numbers. length is greater than zero then we can do the for Loop and return back true and if this turn back false then we can say false inside here and then when we use it straight in the brackets we have access to it straight away since it uses a Boolean variable and then our value will be placed inside our out into total parameter which is used down here for the output to the screen and again if this returns back false then it will say cannot add up an empty array and then we hit the console read line and way at the end there we go that covers everything inside here exceptions are used to prevent your code from crashing and then the program closes down let's have a look at a very very common example let's have a console right and we can say enter a number and then we can use int Norm equals convert to int 32 and then we can have a console. readline inside here and let's just print out number to the screen now if we assume everything goes well and we actually enter an integer like 15 and we press enter then we simply get 15 returned and as we saw in the past when we covered the trass function if you enter anything else that's not exactly a number then you get again exception exception unhandled unhandled means that we haven't wrote anything specific that will handle this exception so it's causing the program to close it's a system. format exception it says the input string was not in a correct format so this is a format exception because we've entered in a very weird set of characters that can't be converted over to an integer so now our program is forced to crash and now rest of our code is going to be deleted now because it won't be able to run so if you had any important data that was stored just before this point then it is now lost this is very crucial because if you have a system that rides to a database or it stores some very important information that someone's typed in you want to handle the exceptions so if something were to arise it doesn't actually close the program down and they lose all of their data I'm sure you've had it in the past where you've tried to do something and the program comes up in Windows and it says this program had to stop responding when that normally comes up it means that Something's Happened that's so fatal that the program cannot continue it has to crash down and in most cases this is what's called an exception so if we run this code again let's have a look and see what else we can do to make this code break so of course as you heard before a num integer can only survive up to about 2 billion numbers so if we enter a number bigger than that let's see what happens then we get an overflow exception value is either too large or too small for an in32 of course this number is very big and only a long would handle something like this an integer definitely won't so these are the kind of exceptions where you'd have to handle it yourself manually otherwise your program is going to crash coming up next we're going to go through the ways that we can handle these and make sure programs don't come to a halt exactly like these examples I want to explore a technique called TR catch this is very similar to when we use the int. trass what this essentially does is it tries to do something and it lets you know if something went wrong this is exactly the same when we're dealing with exceptions except when we're doing a try catch what the catch means is catching the exceptions that happen and therefore it is now a handled exception instead of unhandled exception so before we try and fix how this works let's just explore the syntax so we can type in try followed by curly brace and just after this curly brace we can say catch then we're going to put something inside the brackets and then we have an opens brackets if you wanted a quick shortcut to this just like we've done the for Loop and we double tap tab we can actually delete this so you can type in try and press tab twice and then you get try the Open brackets you get the exception and then we get throw so let's get rid of this and what we can do right now is we can actually place the Corde that we want inside here inside this Tri bit because we're telling the compiler that we want to try to do the things inside here and then we want to catch these things so inside these brackets what you want to actually do is decide what thing that you want to catch if you type in exception this will catch every single exception now the problem with that is you'll actually face some difficulties when you're trying to Output very very specific messages so as we've said before when you type in a value too large you get an overflow exception but when you type a value that can't be converted like a square bracket then you get an input format exception so first what you actually want to do is run this code outside the try and let's run it now and let's get them bad values so we had the square brackets and we can get this and let's copy it down and place inside a comment just like this and then let's rerun it and if you type a number too big take this stop the program and put it inside here so now that you know what the exceptions are called we can actually write write these inside the code so we have a form exception and an overflow exception but before we get into these specific exceptions let's just catch everything this is just a catch all and then see how this works so as we've put it back inside here let's see what actually happens so we can just put a console right on here and say something has went wrong the reason why something has went wrong is because this is a catch all any exception appears during this code it will always come into here regardless of what the exception is whether it's a format or an overflow it doesn't matter it will always come into here so it's going to be something because this is not specific at all so let's run the code enter very big number something has went wrong but if you notice how the program doesn't actually clash it's still very much alive and we can test this by putting a simple message here at the end that says goodbye and we run it again enter a big number and there you go we get the message as goodbye so it successfully skipped over this section without actually causing an exception that breaks the program so even though we've entered something very fatle because we've handled it then there's no problems so if we now type the other one where we have the square brackets then you'll see we'll also get something has went wrong so if you wanted to catch a very specific exception what we can do is say catch open the brackets and we can say format exception just like it says above here and then place the curry braces and what you can do now is you can actually chain these and these go from top to bottom when an exception occurs up here it will match this one if it doesn't match it will match this one and you want to put the catch all right at the end so if it doesn't match any of the ones above it it will always match the last one so you can have a generic message inside here but you can have a very specific message inside here because it's a format exception you can say please only enter numbers so now if we run the code and if we type in square brackets it'll say please only enter numbers there we go so this is a very specific example and if we copy and paste this down again and then we can say overl exception and we can say please enter a number less than 2 billion if you enter a very big number again please enter a number that's less than 2 billion perfect so this will get checked like if statements it will start on the first one and go down the list imagine this is a if and then we have an lse if and then lse if as well if you place this one right at the start then you're actually going to get compile errors and you can't actually have the catch all right at the start so even if you wanted to the compiler literally doesn't let you and anyway you don't really want to be doing that because then you'll be ruling out these two and it's kind of pointless writing this code if it's never going to get used anyway so now when we run the Corde you can see even if we type in a bad value our program will still run and everything works okay so now what we can do is actually make this into a real life situation so if we actually type in 10.2 that it says please only enter numbers then we're going to have an issue here because if we try and print the value down here then it's going to cause a problem let's try and print out num and you can see that num does not exist now we have an issue of scope int is only declared within here and here so if you wanted to print out the value of gome we'd have to print it out up here so now let's run it again and if we enter 20 20 comes up if we've entered 15.5 then actually skips over this console right line because the exception occurs right here and then it'll jump into one of these paths so in order to store the value of num you can either move num outside here and make it equal to zero and then assign num inside here and then you can take this console right line and actually put it right after the triy pass but I don't really suggest this option so if you said 15.5 then you're just going to get zero returned but we don't really care about the zero because we're not going to get the value converted so why do we need to print the zero and the answer is we don't so what we should do is keep it all inside here again and then what we should do instead is wrap this around in a while loop so this will try to do the code this section will catch them all and then we simply have a good buy at the end but let's just make sure that this actually runs because if we type in 15.5 then the user still hasn't entered the number but our program is closed so we want to loop around until the user has success successfully enter a correct number so we can say bull looping equals true and we can have while the chord is looping then we can have the curly braces let's place our entire Tri cut inside here if we highlight it all hold alt and press the op power key and then tab it once and then get rid of this empty line so now we'll keep looping around here until this is going to be a different value so because the while loop will only keep looping until this is true and the moment when it's false is when it will cancel while loop so as I said before it when we run this code and then just at this specific line if the exception occurs it will actually skip this line and jumped below here so if it ski this line then what we can actually do is we know if it reaches this line then the conversion is been successful so we can print out to the screen and we can say looping equals false and we don't need to place looping is equal to True inside all of these three paths because if we don't assign it to true then it's still going to be the value false no matter how many times you loop around so let's try and run that now enter a number 15.5 enter a number 15 and we can keep doing this forever as it's a while loop and as soon as we enter a valid character 20 and now it says goodbye because we hit the end of the program so that's it for this video but let's just have a little recap so we've determined when we run our code just these two lines that in both situations we can have a format exception and it all overflow exception we can use these to catch them specific exceptions and then have a catch all at the end the reason why you want to catch multiple is you can have a very specific message overflow dictates we have a number that's too big or too small to fit inside of an integer it can be less than 2 billion or can be greater than 2 billion and that's how you get the Overflow exception we get him a format exception if you entered something that's literally not a number or something that has decimal places and then I'll catch all can be if anything else goes wrong we can output a generic message but in 99% of the cases you'll either enter a number too big or too small or it's in the wrong format and this exception is just so it catches everything else should anything else happen so at this point even though our program doesn't actually close and there's no exceptions the user hasn't had a chance to enter the number again so we use this inside a while loop and we can say while looping is true when we hit a conversion that's successful we say looping is equal to false and once it hits this line the Y Loop will then exit and then we'll get our good goodbye message and we wrap the entire TR catch inside the W Loop just so this keeps on looping until the user has typed in a successful value as demonstrated above we can type all this and 15.2 15 Point 15 and then finally says 15 and then goodbye so I want to explore different ways you can output messages inside this catch block when you have a catch exception this is actually a parameter that we're passing in this parameter can actually have a variable as well normally when you specify parameters in a function form you say int and then something whereas right now we're kind of defining the data type which is our exception in the same case as in in here but we're actually not giving it a name so it looks something like this of course when we do this inside a function we're going to get a syntax error but for a catch we're not going to get any errors at all and the reason is because we can catch without having to use a local variable so we actually add a local variable make you call it e for exception then we actually have lots of options inside here Type e then we have lots of data and the stack Trace is very helpful when you debuging but we'll cover that at a later date the thing I want to focus on right now is the message so we can use this and print out to the screen so we can say error callon and then type in E message and let's run that now if you enter something invalid input string was not in a correct format if you enter big number then value is either too large or too small for an in32 as you can see these error messages are pretty descriptive and normal users should be able to read this and understand it of course if you want this error message to be more specific then you can add some more catches inside here and we can have format exception this will be if you type in something other than number but if you do exactly the same thing in here then it's kind of redundant because you're just outputting exactly the same value if we try to put the square brackets again then we're going to get this this string which is actually outputed from this line but even if we include the catch all exception you get exactly the same error message outputed from here the moral of the story is you should always have a catch all right at the end of your chain but if the only thing you're going to do inside here is simply output this message to the screen then you don't need any multiple catches what you should do is catch multiple exceptions that you know are going to get fired in your code and then you want to handle them and then have a catch all at the bottom that will display the message generically instead of displaying the message right here you can actually have a more specific message like we covered in the last video so this could be please only enter numbers and we don't actually need the message in this case because we know what exception we're going to catch because we've specified format exception another little tip if you hover over the function call it says here format exception and overfall exception which is the two that we handled in the previous video this is very easy and understandable if you can just read the values from here into see what exceptions can get raised and the same thing here you get an IO exception for the console right line the console right can also give back an IO exception as well generally speaking these console functions almost never return back exceptions I don't think I've ever hit a situation where this exception has been returned unless you do something ridiculous and maybe you type in way too many values that the console right line can handle let's try an example and we can do something like this if you enter a very big number that can't be specified inside an integer then console right line has so many overloads that it actually processes it as a long right now so you almost can't break this unless something fundamental to your computer actually happens so you have exception e and with exception e you can actually take this local variable and print out the message this is the preferred pattern because instead of outputting here something went wrong just very generically you can actually give them the error message that comes back from the exception the reason why this is helpful is because if it doesn't hit any of these exceptions and it just happens to fall into the catch all at least the user has an idea of what the error message is going to be the preferred option is to try get to a point where you never have to reach the catch all and try chain as many catches as you can in order to handle as many exceptions based on the code that you're writing which can be found if you hover over the function and read the exceptions once you've covered as many options as you can throughout the catches then you almost never have to worry about the code entering this section because we've covered both the exceptions in format and overflow and we can do overflow right now please enter a value under 2 billion then that means we've actually covered all of the catches that are to do with converting in integer 32 covered format and covered overflow so when we run this code the only two things that can possibly go wrong are these two functions the format exception overflow exception and we won't ever hit the catch all in this case but if anything goes wrong at least we have a belt and Brace option to catch it and we can tell the user what happened and because it's e. message then the value is going to be quite descriptive so the user can read it without any problems so in this task we want to be able to convert a string to an in successfully without any errors occurring and without any exceptions that could break our code so in steps we want to create an INT and try and convert any string from the console to an integer notice the error that appears when you try to do that write a try catch Handler around it to successfully operate that and output the message to the screen and you won't need to change the console out print and convert in 32 to be able to make this work so you don't want to change the current code you just want to add the Trion Handler around it so why is this a bad situation how can we know if it's been converted this is just a question that you should keep at the back of your head and we'll answer this shortly and then finally we want to create a custom trip pass function find the real trip pass function and copy the return Titan parameters and see if you can mimic Its Behavior read the tool tip it gives you to give you ideas on what to do so let's take these in steps first first we can have a console right and say enter a number and then int num equals convert to in 32 and then we need a console read line and then if you run the code if we try and just convert some square brackets then we get a format exception so that's the exception that we're going to be handling right now so we can take this code and we can wrap it around in a try use alt and up Arrow key and then just have to do a c and then we want to do a format exception and then space e to give it a variable and then we do e. message out to the screen and now let's run the code square brackets input string was not in a correct format so we get our message and our exception has been successfully handled and our program hasn't crutched but the problem is is has got to this console read line and the user hasn't had a chance to actually enter a number so what we can do in here to ensure the user always has access to writing a number is we can say something like this bu success equals false and then just after here we can say success equals the true and just down here we can say console right line success question mark yay and then call on or no so if it convert it 15 we should get a yay and if we convert it and it fails then we should get an o no along with the message of course what you can also do is wrap this entire section inside a y Loop what we've already covered that inside the tutorial and that means we keep repeating this until this is set to true and therefore exit the while loop and then will the users finally typed in a number so let's go back so we've noticed an error and we've wrot a tri catch handle around it now we want to catch the error and output the error message with through done and then we haven't changed the current code which was these two lines we've added a the booing and set it to True here just so we can have a bit of an output message before so why is this a bad situation how can we know if it's being converted so this code is a bad situation because we just have these two lines outputed and then now that you've added our booing to tell the user whether it's been successful or not is actually making it a bit more meaningful the problem is even if we print or no then the user doesn't really have a chance to enter it again so like I said before you could loop around and use a while loop to make sure that this situation can go from something that gets handled into a situation where the user can actually type it in there's no point hand on exception and realizing there's error if you don't give the user a chance to enter another value if they enter out 15 Follow by full stop when they only meant to type 15 then you need to give them another chance to type in that 15 value otherwise the program is simply just going to end and nothing's going to happen for example 15 DOT it says oh no or you can have another message that says something went wrong or you can have more specific message about the conversion and then once you press enter the program simply closes this is not an interaction that you want you want the user to be able to reselect another value so that's why it's a bad situation because you know it's been converted or not use now Bill success but the problem is we don't have any sort of looping so let's have a look so now let's comment out this and let's see how we can make our custom trip pass so we type in in. trass you can see they have a Bo inpass string s and out in result so let's try and copy that and make our own custom function so we say static Bull and then it's trass and then we have a string input and out end result perfect so now we can get rid of this line just so we use it for reference and let's use it straight in here and then we can write the implementation in a second so we can say if try pass the thing that we want to pass is actually a console read line and then we just say out into result and the console read line is going to be answered to this question which is enter a number we place it straight inside here and then we say out in result so if this has been successful we can print out yay again and else if it's not successful we can print out or not of course you can do other things inside here or you can even print out the value straight from here so we can say yay plus a space and then result just so we can get that back to the user and then oh know if something goes wrong of course this is just so we can test things and see how they work so this trass function it will take in a string input and it will try and give us back the result so in order to be able to make this successful function what we need to do is essentially do the conversion ourself which will be this convert in 32 so first we need to assign this out int so we can say result equals minus1 so now that we've used that we actually need to have return type as well but let's worry about that in a second so essentially what we actually want to do is say that the result is equal to convert to in32 and then we want to convert the input store it inside the result and if this goes successful then we want to return true and if it doesn't go successful then we want to return false but of course we need to be able to do these things separately so like we said with the try you only wrap around the section of which is going to be problematic so in this case as we've done here we've wrapped the convert in 32 inside the try so we're going to need to do that down here as well so we can open the try right here and place these two lines inside and then have a catch have a little think about what sort of catch do we need the whole point in this function is to Simply convert value and return back whether it's been successful or not there is no messages here we just need has it been successful yes or no and because we only need to know if it's a yes or a no then we can just have a generic exception and we don't need the E variable because we're not going to access the message we're going to keep it as an exception and instead of returning false down here we actually want to do this straight inside the catch so now the code reads like this we set the result to minus one and the reason why we do that is because if we don't then we're going to get a compiler error and it says that not all paths were going to assign result alternatively we can also assign result straight inside here just so we have an assignment in both paths or you could just leave it outside at the top so we assign result to minus one and then we place our problematic code straight inside here we try and convert the result and if this line returns back successful then it's going to execute the second line and return back true if this line returns back an exception it's going to miss this line completely and jump straight into the exception and then return us back with false so let's actually try this and see what happens 15 DOT or no and then 15 yay 15 so the reason why we don't care about the exception in here we can add in different values as we've used before with format exception overflow exception but as we saw with triy pass it simply just returns us back with the bull the bull simply tells us if it's been successful or not so we could stack these multiple times we can say catch and then we have the format exception and then we can place a return false in there and then we have another catch for the Overflow exception and we can place another return false in there but as you can see we're just returning false inside here so now that we've changed these it's kind of pointless each of them return back false and because we're not doing anything very specific we don't actually need to change them all together we don't care about the message we don't care the exception we only care about the fact that something has went wrong and if something has went wrong then we turn back false if everything goes okay then we return back true and that's all this Tri pass function is going to need to do it simply converts it or it doesn't convert it using an input and outputting a result so if you run it weet type in a real number we get a number back and then 15 DOT zero then we get all no because it can't come it there we go we've met all our requirements for this program let's have a look at how we can do debugging using visual studio to step through our code manually so this is the example I used last time int age equal 35 and ideally in this case you'd want something like 30 plus to be printed instead of 18 plus even though 18 plus is still technically true we'd still like 30 to be printed in this case because this says if it's over 18 do 18 if it's over 30 do 30 plus so in order to start the debugging process you shouldn't run the code first if you run the code first it's going to execute so fast that you won't get a chance to actually put any code in and try and debug it there we go we've already hit the console read line and it's executed for a split second so the best thing to do just to the left of the line numbers you want to press in the Gap and that will create a red dot and it'll tell you that this is a debugging Red Dot just in this little tool tip debugging do program. Min debuging program main so it tells us we're in the program class and we're going inside the main you can also address the debug menu up here and it says we can have a toggle break point we can add new one we can delete them all or we can actually disable deleting them will just simply get rid of them as you can see here if I set a couple more and press disable then it's going to hide them so whenever we run our code it doesn't actually apply the debugging but it doesn't delete them and then we can enable them and then we can also delete them all and it gives you a little prompt because if you do doing this inside a big project and you just spent a lot of time going through and debugging certain functions then you don't want to be able to delete them all without any confirmation so let's delete them all and put it back on line 13 which is our int Edge so let's run the code and see what happens so as you can see it minimizes our console for us and nothing's actually been printed yet because we're only up to this line and then we can use these buttons up here step into goes inside a function step over goes over the line so it will go from this line to this line step out is used after you've stepped in if you stepped into a function and then you don't want to see the rest of the function executing you can step out to jump back out of it which I'll demonstrate later on in this video so now that we've hit this line you can actually see what's going on so we have in age equals z because when this line is highlighted it means this line hasn't executed just yet so we can press this or we can press F10 on our keyboard if I press F10 you can now see in age has the value of 35 and what you can actually do is double click on it and just change the value to 30 for example now if you highlight you can see the value is 30 so you need to double click change the value to something and then simply press enter if you change the value but leave the box like this then it won't change the value so you have to remember to press enter so now I've made the age 40 but let's just change it back to 35 to keep it the same and then now what we can do we can explore what's going on here if age is greater than 18 then we're going to check if this condition is true or false so in order to check if this returns back true or false you can actually hover over the operator and it says here AG is greater than 18 is equal to true and if we hover over this one it says age is greater than 30 is equal to True notice what we actually did there we essentially ran this condition through the debugger without actually reaching this line we're only up to line 15 as of right now but we've managed to execute this and give us back a function so as you can see age greater than 30 is true and age greater than 18 is true and because this is L if chain it only cares about the first one that turns back true and because this one has turned back true then if you press F10 again you'll see that now it's went inside this curly brace which will print out the console right line if I press F10 again you can see we're now waiting on here if I use alt tab I can get back to the console you see that 18 plus has now been printed now that we're waiting here we actually press F10 one more time and then it jump straight to this read line of course because this is L if chain as soon as one of these become true and it jumps over the lse if because of course this is a chain the first one it hits that's true it skips over the rest if we didn't want this to be a chain then we could keep them as both independent if statements if age is greater than 18 and if age is greater than 30 and don't use the lse keyword but in this case because you do want to Output a different message for every single age range you do want to place the L's word in there and now that we've hit this line we can press F10 and then now we jump back in the console and now we're wear in right here and just a little tip when it comes to debugging if at any point you just want to exit the debugging you can either press continue or just press F5 and the program will run for example if we investigate this variable and we can see the value is 35 and then now we're happy with the rest of the code we can just press F5 and our code will run as normal we'll get the out print and we'll get a read line waiting here so we know our problem here is both conditions return back true so just like in the last video we actually changed this condition so to make sure that it only goes between this range but let's not repeat ourselves let's have a look at a different example so we can have string name equals Abu and then int age and then age equal 23 which I'll demonstrate why I've done it like this in a second and then let's have a function just so I can show you how to step in so we can have a static string print details string name in Edge and here actually we want to just return back a void because we just want to print out to the screen and we can say name space edge and maybe just put a dash between them and let's run that code now we can see ABA 23 of course making that function wasn't the point I actually want to show you what's going on so if we just print this a couple of times just so we can show you the step out and step in so you run the code now we can see our string name if we go over that you can see it's called abber and then now that it's stepped over this line cuz there's nothing really to execute here it's just creating back a variable so you can see that age is zero cuz that's the default value for an integ and when we skip over that now it's got the value of 23 so one line creates the integer with the default value equal to zero and then the next line will make it equal to 23 and then we're passing on the variables here and if you wanted to investigate it you could simply just hover over them like this so you can see what the values contain and then now that we've hit this function if we press F10 then it's just going to skip over it but what we actually want to do is be able to go inside the function so this is where our step in goes step over doesn't doesn't care if it's a function or a normal line it'll just step over it regardless so we want to in here we want to use step into or we can press f11 once you press for f11 you can see that now it's jumped from print details up here to print details down here and then now look if I step through it's going to actually execute these one by one so right now it hasn't executed anything so I step over this once using F10 you'll see it now appears and then the same thing with this one and this one and now that I've executed three we should see three in the console perfect so now what I want to demonstrate is let's say we're happy with the rest of this function and then now we want to just step out so I press this button and you can see it jumps back up to print details f11 to go in and then shift f11 to go out so now that we're back in here the only thing we can do really from this point is either press F5 to stop debugging or press F10 to jump to this line and at this point we've already hit the last line now code so we don't really need to use F10 anymore cuz with nothing to step over so we can just press F5 let our program finish and there we go so let's have a look at another example can have a string message equals read from console then we can pass this in enter anything and then we can have a console right line and we can just print the message and then let's create this function so because it's a return value and store inside a string we're going to need a static string read from console and then this is one string parameter so we have a string message and then we can just do a console right and then print the message to the screen and then we just want to return the console. readline there we go and again let's put a breakpoint here and we can remove this one so it doesn't always have to be the first line if we're perfectly happy with this amount of code then we can simply take that off and it will stop when it gets after this line now if you look at the console you'll see all of this is executed that function is executed four times to print the name name and age of the screen and now we're waiting here so we have our read from console and now we can step into using f11 and you can see that if you hover over string message has enter anything which is our parameter that we specified up here and then there you go and then that will print into the screen so you tap back in you'll see it says enter anything and then just at the read line we need to actually enter it now something and then press enter and then just right here it's going to return it back so if we use F10 it jumps back in here and then actually we need to execute this line so F10 again and then if you hover over a message you see it says something which is exactly what we typed in the console here and then we just print it back to the screen there you go and now we just at the console read line and we can press F5 to finish up there we go so debugging is mainly used by pressing this button on the side so debugging is used by pressing on the empty Gap just to the left of the line number and it will create a red dot once you create a red dot it'll highlight this for you once you've clicked done it it should show up a red dot you can also disable or delete all the break points from the debug window at the top of the screen when you run the code it will stop here and then you can either use F9 as a shortcut as well click into the line that you want to debug and press F9 please note there is specific cases where if you try and press this one right here it's not going to let you if the line doesn't really do anything for example this is creating an integer there's no real action that's happening here that you should or want to debug this is an assignment this is an assignment this is a function call and so on and so forth and this is also a function call when it comes to just declaring variables then a compiler does not let you put in a breakpoint because there's nothing really to investigate when you're just creating a variable so don't get thrown off or think something's wrong if you click on the empty line and nothing appears so that's it for debugging but let's just have a little recap we can use F10 to step over f11 to step into functions shift f11 to step out or you can use the buttons that appear at the top of the screen when you run the code just right here hover over variables and you get their values as I showed you in the if statements if you hover over the operator inside the if statement it will actually tell you what the condition is and whether it's true or false so me say if1 equals equals to 1 and let's just print out true to the screen just so I can demonstrate this if a hover r that equals equals it says 1 equals equals 1 is true so that's how you check if a condition is going to be true or false when you're debugging you can check the parameter values by simply hovering over it and the tool tip should include the value just like so and if you wanted to step into this function you can use step into and then use step over which is F10 just here and then you can actually investigate these values as well or you can look at the parameters and once you're done with the function you can do shift f11 or you can use step out and then you can skip over this and the same thing with this you can have a look at the string variable once it gets returned something in here and now it says something in here and string message and then we can print out to the screen Etc so you can have a little bit of Freedom with what you can do in terms of debugging play around to debuging in the past exercises that we've made together and then what you can actually do is gain experience in debugging so it comes to more complicated projects you can also apply that learning there and make sure that your code is error free so we covered how to debug by pressing the white space just to the left of the line number if we run the code the program will stop where our breakpoint is and it won't execute the line that we're up to we have to step over it so we've actually use this before to analyze our functions and see what values are inside things so we have these extra windows called the local and the auto so let's take a look at them and see what they're about so again if you don't have this layout you can use window reset layout and it should be in the left panel not the right one this time so we've got watch which we'll explore later and we're going to have locals and Autos so the autos because we're up to the age then it shows us the age has value zero and then that prevents us from hovering over it and if we step over it you'll see that now it's got age 23 and now name has appeared the auto tab will try and figure out what functions and what parameters you need to be displayed down here based on the section of cord that you up to so my guess is because we're up to this function and it takes in a name and age then we're getting name and age appearing before when we were on this line it was only showing back the age and because that section only used the age we only got age here but if you press locals you can see all the variables that are local to this main function are actually showing up we have a parameter called ARs and technically this is a parameter and it's a string a ray type but it's currently unused but it's still a parameter so you can see it down here and then in order we have have the name variable down here then we've got the age and then we've got the message which is currently said to know because we haven't created this in memory yet but as you can see this changes depending on the scope of our variables so now that we're about to hit this function let's use the step into and you'll see that the locals have now changed we've got rid of name age argument and string message and it's replaced with name and age because remember what I saying about the scope of the variables parameters inside a function are always going to be local to that function around the curly braces that they're surrounded by name and age is only within here so when it's trying to shows the local variables it's only local to what's inside these curly braces which in this case is name and ede so now if we step over this and then if we step into this read from console you'll see that just before we step into this function that these have all came back cuz again the scope has changed back to this function which is our main function which has all these variables inside so our read from console will only have our Str message so hopefully when we press f11 or press the step into button at the top we should only see the message variable inside here there we go we get enter anything cuz that's what was passed in over here and then as soon as we return back to that let we type something in and then we get all of the values again and you can see that system. console. reine had returned hello which is this line and then if we press F10 again you'll see that even though we've got it back here our message is about to be assigned once we step over this there you go it says hello and as you can see this changes in real time so as soon as we step over lines hello got placed straight into there this helps us tremendously because we don't have to keep hovering over variables like this to keep checking over their values you can simply use this menu and it will always update because whenever you change Scopes between functions that will automatically update as you just saw in them examples there we go and then when the program ends obviously this window is going to close down so that's a very help helpful method have being able to debug without having to hover over anything in the next video we're going to cover how to watch variables and this can be very handy when you're looking for specific errors another really good debuging technique is the watch window let's press a break point just of left of line 13 and let's run the code and let's see what this is about so we covered that we have the locals window and we have the auto window that will automatically give us the variabl that we're currently in the scope of but let's forget about that right now let's have a look at the watch window it says here add an item to watch so there's a couple ways that we can do this you can actually double click on a variable and right click or you can just highlight it like this and then right click and it says here add watch and you can press it it says name value null because we haven't created it yet so the default value is null as of right now cuz it's not actually assigned anything so you press F10 and step over it you'll see that immediately changes to abber without was having to do anything except simply press F10 which is the shortcut for our step over button right at the top of the screen this prevents us from having to hold over the variables to get the little tool tip so we can see the value the power of this is we can watch variables and we don't have to worry about showing in the locals or the auto because it's always there and if you have lots of variables like this then you're only concerned about the one that you're watching locals and aluto will always change depending on the scope that you currently at whereas watch will only do what you want it to do so because we don't put age inside there then it's simply won't come up just because it likes it if we check the locals we have agent there and the Autos we have agent there as well but we don't have it in the watch so what else you could do is actually just type straight into here age 23 if you really wanted to you can actually also type in conditions age equals equals 23 it returns back true so if you had an if statement that you wanted to track then you could do that as well so let's have a look so it a statement that said if age is greater than than 18 then we can just print out 18 plus to the screen so let's run the code now and see what happens so as you know we have this condition right here so if you actually highlight this and drag and drop it you can see that the cursor changes and you can drop it inside here let's click on the AG equals equal 23 and click delete so of course we can't really render this function right now because we haven't even created the integer variable so let's run over the integer variable and as you can see here it says AG is zero which is the default value for integer and that is is indeed zero right now and then age is greater than 18 is false but as soon as I step over this line and it makes age the value of 23 you'll see that these two immediately change you know they change because the values have went red red means that the values have just changed in the last button that you pressed whether that means he stepped into over or stepped out it doesn't matter red always dictates that the value is just changed so now it's telling us that age is greater than 18 is returned back true so when I step over this line because this is returned back true I should render 18 plus let's have a look F10 F10 and there we go we've reached the middle which means that's going to get printed out now so moving on to another example we can have print details if we go into this function and let's say we only concerned about the name then we can print out the name down here but as you can see we already have it twice so that's just going to update depending on the parameter name and even if you wanted to show something like this you can drag this down here and it actually shows you the output this is very handy so you can see the output because sometimes when you have it like this it doesn't look very clear you can also hover over it right there and you can see the value placed here but again it's very handy to have it here so you don't have to keep hovering over the tool tape just to see the values and from here you can actually change the values so we can just say Harry is now the value for the name and Harry is going to be age 35 so when we press F5 and let the program run naturally you'll see that Harry is age 35 now and that's all done through the watch list down here here and it doesn't even matter because we have full control over the watch list variables and we can change their contents to see how our code acts in different situations so please use this watch list as much as you can and don't forget that once you can double click on variables and add it to the watch just from here you can also say quick watch and what that'll let you do is it'll give you the value and then if you want to add it you can press add watch here or you can just keep pressing reevaluate once you've skipped over some lines so let's say we skipped over it now and then go back onto it and because it has a shortcut shift F9 we can just quickly press it like this and it says abber inside here and we can change the expression maybe do something like age and then click re evalue it and it changes the value to zero and then we can even change this to like 50 for example as you can see down here it's changed to 50 as well so you can drag and drop it into here or you can double click and press add watch it's up to you please make use of this watch variable and don't rely too much on the autos and the local just so you can keep your own variables inside here and you can have complicated outputs like these you can check conditions you can check console outputs as well as just checking normal variables so using the watch window you have lots of different opportunities to keep track of your code so we've got another debugging task let's try and run the code and see what happens we're going to get printed over 18 so our value is AG equals 35 and we're already getting over 18 printed to the screen so if we place a Brak line inside here and actually run the code we can see what's going on we can add them inside the watch just like this we can add in all the conditions inside just like this perfect so we can actually see here that because our age is over 35 it's saying greater than 18 is true greater than 30 is true but greater than 50 isn't true and we can easily see that except because this is an if and an else if chain as soon as the first one is true it's going to enter that one you press press F10 then we get over 18 and then as soon as it finishes that path it actually skips all the way to the end the problem with this is we only want it to print over 30 since it's over 30 so we have to introduce ranges inside here and we can say age is less than 30 and then you can have ages greater than 30 here and then you can also insert an end and say AG is less than 50 and there we go and now it says over 30 and if we change this to 55 then we should get over 50 and then finally if we change this to something like 23 then we should also get over 18 perfect so what was going on here is because we had if and else if chains then you're only going to get one of them printed and because a value over 18 satisfied both the first path and the second path then it's only going to print the first path if we actually undo our changes all the way till the start and then we actually flip the order of this if we put our this one first and delete the El's and change it to lse if inside here so now we have a new chain except the first one in the chain is actually if age is greater than 30 now if you're on the code you'll see that the first one actually says over 30 and it says over 30 and it doesn't say over 18 anymore but simply because this is the first one in the list as soon as it hits the first one as I'll demonstrate now it will go inside this bracket hit this curly brace and then jump straight to the end you should always order them from smallest to biggest because that will probably make the most logical sense when you're reviewing your code and in doing so you can actually have a more formatted code but you need to watch out that the ranges need to make sense if you have something like this then you need to restrict this one because it's going to be blocking the second one and you don't want to make these all ifs because then you get multiple outputs now we should get 18 and 30 being printed to the screen this is not something you want so make sure that you place your ranges inside here by adding an and and then placing the other end of it which will be 30 and then this one will continue from it so so just to sum up what you need to do is make sure that you use Els and make sure that you have ranges just so when one exits it's going to check the other one and the other one you don't want the first condition to beat the second one if that's for the right path age 35 goes into this path or at least we want it to but it's been restricted by the fact that age is greater than 18 when we had it like this this is restricting everything over 18 to go inside this path if this was even like 65 we should only fall into this one and we run the code then we're still going to get over 18 which is still technically true it is still over 18 but we have different outputs for this sort of age range make sure that you use lfs and you keep in an appropriate range and keep them in the order of the if statements going from lowest to highest or whatever makes sense in that situation that you're using it this is a start of objectoriented programming let's start with a concept called structures structures allow us to store different data types inside one data type so it's almost like a group of data types we can demonstrate this if you wanted to stall something like a person you would normally have something like a string name equals ABA and in age equal 23 so in here we have a string name that represents the name and in age which represents their age and you can see that because these are two different data types you can't wrap them around inside an array you can't have a string array called person and then say we want to have two different values although this will still compile we can't store both these data types inside array unless you make the ede and store it as a string which will be 23 inside the quotation marks and then you'll have to worry about converting it later on in your program so this is not really ideal so we have something called a structure so just outside here we can say struct which stands for structure and then we can have our name straight after so we can say person in the next time we just open the curly braces and let's see what we've just created so now in order to make an instance of this we can actually use that like a data type between say person person there we go so now we've created our person variable now you see we've got our own data type before we're just using string and ins and arrays and things like that but now we actually have a new person so because our person is made up of a name and an age let's place that in here string name and then inage of course you don't want to give them default values because like all variables you don't know what the value is going to be to begin with so now what we can do person Dot and we don't actually have access to using these values yet so what we're going to have to do there is a concept called access modifiers which we'll cover on later on in this course but just for now what this means is you either have private or public and they're the main two words there's other words that you can have but they're the main two for now if you have it private it means you can't access it down here through person. name and but as soon as you make this public then now it becomes accessible there we go we can make that equal to something and if we take off public then you see we don't have access to it it's inaccessible due to its protection level because the protection level is private which means that you can only access name Within These two curly braces the second you make it public it means that anyone outside of the structure EG down here can also have access to name so if we do that to our public on int age and string name then we actually can access both now we can say person. Ag and it comes up like this the purple cube is a function and the blue is Fields you you can actually filter them out by pressing them down here show only methods and show only Fields so we can do age equals 23 and I can actually just place abber inside here now that this data is essentially the same as this the benefit that we have now is when we print to the screen we can say person. name and then hyphen person. Ag and if you run that now you we Abid 23 if we actually copy and paste this lined out and just remove person dot just so we're using these two variables at the top of here and we in the code you should see exactly the same values coming up there we go but now what's really handy about this situation is we have two data types that are wrapped inside of one data type instead of having a name and age we have a person because what gets really easy now is if you wanted to add something else inside here like for example birth month which for me is five so in here you'd have to make another one birth month equals 5 and then all we have to do inside our person is just say person. birthmonth and we could just assign it right here instead of having to create a whole new variable we add it up here and then we can use it down here and then we can add that into here person. birthmonth and we can add this to this one and then get rid of birth month and as you can see it's exactly the same so we've taken these data types and placed it inside our structure so then we can just reference it by the person this becomes very very handy for this exact reason that I'm going to show show you now let's say you wanted to read this data R from the user so you have static and then you're a bit stuck on what data type you want to return if you forget about the birth month then we have a name and age as a very basic person but our return type only lets us have one type so that's going to be a problem now so you could do a string return that will give us back the name and then we can say return person and inside the brackets what you can actually do is do out in Edge so you can have two output variables an out Edge and then a return string since hiide here we could say enter your name and then string name equals console do read line if we copy and paste this down and then we can say enter your age and then we can say int age equals convert to and 32 and then put the console read line inside there there we go now that we've got that we don't actually need inage because we've already got output parameter so we just need to be Edge and then after we've retrieved them two values we can return name there we go so let's actually try that up here so we can say new name is equal to return person and then out in new ede and you can take this exact line paste it down here get rid of the birth month and then we can use new age in here and new name inside here so let's run that now ask us what is your name ABA what is your age 23 and then we got ABA 23 which is the same as what we've got before but you see that this situation is prettyy messy we have to return a string variable and also use an output in order to be able to give back two values alternatively what we could do is actually just return back void and then we can say string name and then inage but we're going to have to use references inside here and then have string new name equals nothing and then new inage equals 0o so we have string new name equals nothing and then into New Age also equal to nothing and then inside our function instead of having out parameters we can actually use a reference and we can say a new name and then ref New Age and what that will do is we can just return it like this because it's void instead of declaring a new string name we can actually just assign it to the reference that just passed and because it's a void parameter now and for the return type we don't actually need to return anything so we can actually assign these by reference enter your name ABA and 23 so as you can see it still works fine but let's say we wanted to add another birth month so we' have to take the birth month variable new birth month make it equal to zero and then add yet another parameter ref new birth month and then we need a new birth month inside here ref int birth month and then we need another one from here enter your birth month and then we'd start it inside birth month and then finally we can also return it up here as new birth month there we go AB 23 and then five so we get them values being returned so in order to keep adding different properties to your code you have to make a new parameter a new reference variable and then append the parameters inside the function now the problem that is even though you can have an infinite amount of parameters then this gets very tedious very quickly and you don't want this so let's have a look at how we can make this function exactly the same way just using our new structure you can see that instead of having to pass all of these different things in or return back a certain value we can actually just return back a complete person so all of this can be squished pretty quietly so actually let's just comment all of this out and let's comment out this function and let's have another rewrite so now that everything's gone we only want to be returning and dealing with the person so we can say static and instead of void we actually want to say we want to give the user back a person return person and we don't need any parameters in in this case this is only passed in because it's a reference so we can assign these values back to the original variables but because we're going to be returning a person then we don't need to do that so we can essentially take this code and put it in here and we can say string name now we have an in here and then also an in here there we go so now that we've constructed all our variables that we need for the person what we can do is we can make a new person person person and then person. name equals name and then duplicate this down we say a person. ag is equal to age and finally the birth month is equal to the birth month and then now that we've constructed our person we still got a red underline because we haven't returned anything yet and after all of that we can say return person there we go and now simply in here we could just say person person equals return person there we go and then we can take this console right line here and place it straight underneath since it uses the same properties now let's try and run it AB 235 there you go so now instead of having to make a whole new variable all you have to do is simply just add another one down here so we can just say number this could be your favorite number or anything and we can add it onto here person. number and then here we can paste this down we can say enter your number and then it will be number in here we can paste it down here and change it to number and there we go that's all we need to change and this code doesn't change cuz it's simply calling back the function and we're doing all the hard work inside here so now if you run this enter your name abber 23 5 and finally four and there you go we get the values being returned so this looks a little bit tedious we have to assign each one individually every single time we do it so we can actually use something called a Constructor in order to achieve this result we make the person we set them and then we return it it' be easier if we could have the Constructor that we can assign straight inside here and then just return it immediately instead of having to do all of these lines and then reference each one individually so let's have a look and see what we can do inside here we can have a new function that'll just be called whatever the structure is called then you open the brackets close the brackets for now and this is called a Constructor in order to be able to use it down here we need to make it public in order for someone else to access it so this says that it needs explicit parameters in order to be able to compile it says that it needs to assign name age birth month and number so let's see how we can do that as we've used Constructors in the past for example when we had things like the string Builder we had s SP equals new string Builder and when you make a new something that means you're making a new Constructor so all of these sixes are the parameters that go inside of this but each one of these is a separate Constructor if we control click this we should be able to see them all there we go you see that the class is called string Builder and this is called string Builder and these two names match exactly so to make a string Builder you can give it any one of these as long as your parameters match one of these six you can give it nothing or you can give it some other values and that's the same is true with our current person so what we need to do in this case is we don't have multiple ways that we can constru this in the case of our person we have to provide all of these details otherwise the compiler is not going to like it so we can have a string name int age int birth month and int number now we got our parameters set up we actually need to make use of them in here so because we have name and name and they're exactly the same string by string then in here we can't say name equals name in terms of global and local variables this is global within the structure as it's within these two curly braces and all of these variables are only Within These two curly braces local variables always take presidence over the main one if I double click on this you'll see that all three are referencing this Constructor if I double click on this you'll see that both name references on line 20 down here is all referencing this one in the parameter and not the one up top we want it to be assigned into here so you have two options in this case you could capitalize all of these so then you don't run into this issue and then instead of name equals name it's capital N equals name and that fixes it alternatively if you want it to be a lower case then what you can simply do is you can place this dot if you use this it goes back to the current scope and the current scope of name is going to be this which is within the structure when you use this it doesn't reference the local variables it references the global variables appear so when I double click on this now you'll see that that gets highlighted so we can say this. ede equals ede this. birth month equals birth month and finally this. number equals number so we're just getting all the parameters from here and putting them into these values this might look a little bit redundant but I'll show you why this is a lot cleaner so back in our return person function we have the variable and then we assign them all manually but look how easy this now has became if I comment out this return we can say a return person so now we can reference person with a capital P this time cuz I want to reference the structure directly so after the person we can open the brackets and then start to type in so our first one is name age and the birth month name comma age comma birth month comma and then number comma and then this is not going to like it because we also need to place new inside as I said before when you making a string Builder you have a new keyword and this new means that you want to create a new instance of this you could think of this structure as a template this is the template for something and until you start using that something it's actually not going to do anything so we have to make a new instance of it because it's not already available so we need to make it available through our data type so when we say we want a new person that gives us access to the Constructor if I remove that you'll see we've got one of two now we can create an empty person and that will just make us assign all the values individually but we don't want that we want to use the second path and if you drop the arrow you'll be able to see the different parameters which is the ones we just typed in name age birth month and then number and now that we've returned back this we actually don't even need to do any of these lines right here we can actually just return it exactly like this so now if you run it again you should see exactly the same output 23 5 and four perfect so let's just have a little recap so normally when we're creating variables we use common variables that we've used in the past string in double Flo bull Etc but with the use of structures we can create our own group of variables and then we can use them VAR Ables inside functions and inside our code to make things a lot cleaner and a lot easier so inside person we actually stall four different variables and they can be an infinite amount of variables should you will and you can easily remove them and then remove them from the parameters and from the assignment and then that's it if we use this without our structure then we're going to have to declare every single variable separately and I know this is the same as doing it up here it's actually a little bit more work cuz you need to create a new parameter and create all the the instances inside here and assign the values now the benefit of doing it within a structure is that when you go to do a function look how easy this line is before you'd have to have name age birth month all as references or have them as out parameters and it gets a little bit long and a bit sloppy you only to include the month in here we' have to have another int number and you can see that the parameters are growing if you wanted to store a user from a registration form you might have name address phone number country and the list goes on it can be a very long form and you therefore you'll have a lot of parameters so it's very easy to wrap it around inside a structure and then simply reference it like that and you'll need zero parameters because everything is contained within the data type and then inside here we can ask for the users's details individually store them as their integers and string variables and then instead of using this notation we can now use our fancy Constructor where we can pass it in in this exact order right here name age birth month and then the number perfect and then we can use inside here we can call each of these positions separately and concatenate them together so now that we covered structures known by struct as the keyword let's have a look at classes and how to define them syntactically so we can make a struct called person and we can give them a string name and inage and to make them accessible we'll make them public and we can say public person string name and int age and that means we can assign these values using the Constructor so we can say this.name equals equal name and this. age equals age perfect so let's get rid of our compiler error since we're assigning both the values and then down here we can use it we can say person person equals new person and then have abber and then 23 in the brackets and we can print to the screen person. name and then if use controll D to duplicate that down and we can do age and if we run that right now we should see abber and 23 being printed to the console perfect so as we talked about introduction syntactically the struct and the classes are very similar so let's comment this out so we don't get any compile errors and let's see how this is going to work so of course we're going to get error on this line but once we make our class the error should disappear from here so instead of struct person we're simply just going to have class person exactly the same and because these are fields we can also copy these down so we can have public string name and public int age and then we can have public person and then string name in age this do name equals name and this. age equals age so as you can see this is exactly the same as this except for the fact we have structure and we have class inside here now you see how compile error is gone and if you've run the code we should see exactly the same output there we go now the main difference about classes and about structures is that you don't actually have to give these a default value inside the Constructor if we just comment this one out for a second and if we bring the structure back and we actually remove the parameters from here then we're actually going to get compile errors and it says that the name and age must be assigned before it's returned and stroks cannot have parameterless Constructors now that's a bit of a problem in certain cases you might want to create an instance of something but not actually derive any values so you could actually make these into default values you can have string name equals nothing and int age equals zero and therefore once we place in inside here then there's no problems if you run the code then you will get the output this will be nothing this will be zero and you'll get errors and you won't get any compile errors doing this way but the point is you have to include them and you don't have a choice so if you just comment this back out now what you'll notice about the class person is even if we get rid of it then it still lets us have it of course we can't actually give it parameters since we don't have a Constructor that lets us have parameters but what you can do as well is you can overload this and actually include it as well so you can have another set that literally lets you define both of them and then you can even have another overload that lets you just include the name without the edge and then also another one that lets you include the int Edge without the name or you include both the details so in these cases what you can do is you can store the values up here as the fields let them use a default Constructor or only give it the name or the age or you can actually give it both so when we come down into here we actually now have four different Constructors we can make an empty person we can make it with an edge with the name or with both and what you can do in here is you can say this.name is equal to nothing and then here you can say this. AG is equal to minus one just to default it to a value that's incorrect so after we've got this let's have a look at the different ways so we can give it a person which gives us an empty value so if you run that now we get blank and zero and if we just give it the name which is Aba then we should get ABA in minus one yep and then if we just give it the age you should get nothing in 23 and if you actually give them both then you should get both printed out to the screen and there we go so now we have four different ways that we can create our person with our structure we're only really limited to one since all of these values need to be assigned as the structure is created structures are meant to be used as an extension to a data type rather than almost like a mini management system when we make a class we have so many options of different ways that we can do this inside here and later on in the course we're going to show you how to include functions inside here and then eventually do other Advanced Techniques with classes that aren't directly available structures if you have a basic example where you want to extend something to use inside a function or a data type like starring name and age instead of having to do two return types inside a function then a struct is perfect the second you want to do more complicated things or make it a bit more specific and flexible then classes are the way forward you'll see it very often in games where they have struct position you'll see in video games where they have something like a struct position and they might have int X int Y and int Zed and that's for their 3D position or they might even just have an X and Y or you could have something simple like a rectangle and you can give it a width and a length so now when you use that inside the code you're going to have different flexibilities of the amount with data types that you can store and then when you return that back from a function that will be okay as well since you can use this as a data type so if you want something simple and straightforward then go for the struct the second you want something a bit more complicated and a bit flexible then you probably want a class we go into more different situations inside this cause so you understand in which cases to use what and in most cases you'll notice that the class is more replicable so if you wanted to you could ask the user to enter these details in and then you can pass them inside the Constructor so we could say a console right line changes to a right enter your name String name console. readline and then copy and paste this down change this into a int age and then wrap this around inside a convert in32 instead of enter your name it'll be n your H and then since these are grayed out it means we haven't used them so we can change abber to your name and then change 23 to H perfect so now if you run the code now enter your name ABA enter your age 23 then we get AB number 23 printed out to the screen so just a quick recap Constructors are basically defined the same way you have public followed by the class or the structure name and then the parameters inside the brackets and then you can assign it after without structure you have to declare all of the variables inside the parameter and assign them all down here otherwise you won't be able to run your code with classes we have the flexibility of just including one default function which will just be our Constructor and even if it does nothing this is still acceptable and then we broke it down to multiple sections where you might have situations where you only want their name or their age or you might even collect both to store it if you collect the name then we'll initialize age to minus one just so you know that this is a bad value and if you declare only the age then we'll initialize a to nothing just so you know that it's an empty value and if you accept both then we simply assign both and down here we have access to it we can even make this a little bit better by checking these values so we can say if string is not null or mty of person. name and we can put a not inside here then we can print out this and then the same thing for age we can say if person. AG we can say greater than minus one since we set minus one as the bad value and then we can move this line up and let's try run it now so these two if statements are fundamentally separate from each other one is checking the name and one is checking the age so let's try and manually type these in and see what happens so enter your name let's make this blank and only include the age and let's see if this runs okay so you had no name in the age of 23 then you see we only get printed 23 because it'll skip over this line as you can see if we put a break point in now and just refresh the code we get empty name plus 23 and when we press F10 over this line it jumps the next one because if we hover over this you'll see that it should return us back with false there we go we get strings null or empty is is false so that'll skip over that and because the age is 23 then this line is going to execute let's run it again and do the opposite we could say name is Aba and then age is minus one and then we get ABA printed be not the age there we go so if you wanted to fix these in and type them manually so we can say 23 there we go we get 23 and if we only include the name ABA then we only get ABA printed out and if we include both both of them then we get them both printed out perfect so now that we've created our class we've gave it some fields and we've made our Constructor that lets us initialize it let's see how we can print the details out to the console so we can have a CW tab tab a console right line and then we can say string interpolation name callon space and then we can have our curly braces and we can say person. name we can access these fields using the dot operator and then we can say back/ again for the new line and then say age and the same thing person. AG let's try run that and see what we've got so now we've outputed name and age out to the screen let's see how we can do this inside a function if you wanted to place this in different part of your code then you're going to have to copy and paste this and as we know this is bad for our code because it's j a duplication we want to be able to wrap this inside a function somewhere so let's see what we can do we can have a static string so you can return us back with this that we can output straight to the console and we can say return details and for our parameter we can have something like string name and int age because that's what our class is made up of and inside here we can simply take this put it inside here and put a return before it and then get rid of the person dot since we have an aim and age variables as local to the function so now instead of this line we can duplicate this down take out the contents and we can say return details and then we can place person. name and person. AG inside here let's r on the code so we get exactly the same output but the problem with this function is we're having to type out the parameters manually we have them here and we're going to have to type them again in here and again for the parameters this is a bit of a problem because we've just made our class but we haven't really used it when we're passing it in so instead of having string name and int age we can actually duplicate this method and just comment it out just so you can see it for reference and instead of doing this you can actually just pass in an entire person so now we have access to person and we can bring this back and we can say person. name and we can also say person. Ag and the reason why this method is preferred is if you actually have something else public int number and then you added another one inside here int number and then you said this do number equals number the parameters won't have to change inside the function all you have to do is simply pass in the person and then now we actually have access to doing person. number inside here should we need to if you passing them all all in one by one like this then you have to append into number on the end and then add it straight to here and then also add it inside here as you have like this it's easy to pass the class in because all of these properties above are just simply used throughout the function so now if we just bring this back and let's have a run and see if we get the same output which we do name ABA age 23 perfect so now that we've thought of two functions how to do this we we can manually type in the strings and the integer and any other parameters that we need or we can actually pass in the person the problem with these two approaches is the whole point of having classes and structures of the like is so we can wrap around lots of functionality inside it if you want to send this to another developer for them to use in their project or maybe this is a file that is shared within the projects then you don't want them to include a separate function that is simply outside of the class we want to include the functions inside the class so of course as you know these are functions so inside side here we can also make functions so let's do it so we can have public and we want a string return details and then we don't need to pass anything in the the values that we're going to be returning are these two right here which is technically local to our class so therefore we're not going to have any parameters I'll explain that further in a second so we can take this exact line paste it straight into here and get rid of the person Dot and get rid of the person dot on this side so then we have the name variable and the age variable if you double click on them you see it references these variables and the same thing for age the reason why we don't have parameters is when you call this function as I'll show you in a second you call it directly on the person so the person that you're trying to print has already got these contents inside of them so let's have a look we can duplicate this down and instead of calling return details and passing the person you actually do it the other way around you say the person object dot return details so now we're calling return details inside our person person an object now let's run the code you see the output is exactly the same except now this functionality is a lot better our return details is wrapped inside our class which is the preferred way now we can actually get rid of these inside here and then we shouldn't really use this notation even though is technically correct but you want to wrap all your functionality inside here and just bear in mind that scope is also applicable here return details is within this class which means if you try to run this function inside the main then it's not going to node exist this return details function was able to be used inside here because this was in the scope of the class program which is this curly brace and this curly brace but this return details is only within the scope of this class which means you can't just suddenly use it inside the main so please bear that in mind when you producing these classes and you're trying to understand where everything goes every function that you place inside here is accessible through the dot notation after the object once you've created the class soose person equals new person and then after we type person dot then we'll get a list of all the functions the same way if you have something else just like this and then if you do person Dot and then you see that something has appeared there so all the functions that you create up inside in this class for every person that you make it'll be accessible through the dot notation so just to round up this video you should always make your functions inside your class having them inside the class is the whole point of making a big class and have lots of functionality side if you keep the function that does exactly the same thing outside of the class then if you were to share this file or come back to it in the future then you're not going to understand why you've done this and it's outside the class keeping everything wrapped inside the class is the best way forward in most case scenarios so now we have our class person it's got a name and age a Constructor and a function to return back the details and we can simply use it like this and return back the details like this but so far we've covered how to make classes Constructors Etc and assign the values but the values are only getting assigned throughout the Constructor but what if a different part of our program the user want to change their name update their age Etc then what options do we have so you know we can access our Fields using person. name and then you can simply type equals and then type in another name and we can say person. AG equals 25 now we've changed these properties if we use the console right line and return details you'll see that the values have indeed changed as you can see there it's changed the Harry in 25 this is okay except for the fact that this shouldn't really be possible we should try and restrict this directly by the use of gets and sets so for now we're going to cover fields and how to restrict certain values and later on in the course we're going to go through what properties are so before alter properties got invented we had to use gets and Setters gets and sets are essentially functions that will prevent this from happening so the reason why we can do this is simply because this public word is placed right here if we change it to private it means that name is still accessible within here and here which is only the limit of the class but as you can see it's not applicable here this is why you need the public Getters and Setters so I'll explain that what that means now so we prevent these from accessing outside the class by making them private so this functionality no longer works so what you have to do instead is for every field that you have you need to create a getto and a set a function so in order to set a value we can have public and because we're setting it we don't need to return anything so it'll be void and we can say set name and then we pass in string name and then we simply just say this. name equals name so when someone calls set name and pass in the name like this we just overwrite it so let's see how that looks so if we comment these two lines out we can simply say person do set name and then we can say Harry so this line is directly replaced by this line and now if you run this we'll see that Harry should be changed there you go abber is changed to Harry this is really powerful because what we can do now is restrict the access inside here and make sure that the value contain something genuine we can say if string is null or empty and then pass the name inside there if the string isn't null or empty then we assign it and if it is null or empty then what we can do inside here is we can say else this do name equals nothing and we can keep it blank or we can use string. empty just to make sure that we know that the name has been blanked out if they've entered something invalid if they've entered something that's valid we assign it if it's invalid then we don't assign it and we just initialize it back to nothing and because our options are endless with this we can actually make this into something else we can simply just say invalid name so then what happens is if we try and change this to nothing and we run the code we can see that we get invalid name being printed to the screen and that's a lot better than if we had string.empty because if you had strings are empty then it would kind of say nothing then it looks like something's went wrong if you have something like invalid then that gives you a bit of a bar message so we can have invalid name there so using our Setter Let's us change our name from down here without directly exposing the public if he expose the public then everyone who uses classes can simply change the name to whatever they want having it private and only changing the name within the set name function is very preferable because you can restrict the access and what people can set the values to if they try to set it to something that's not valid then we set it to invalid name whereas before when we did this and if we make this public again we can simply set this to something bad like null null is a very bad value but it still lets us have it and the reason why it's very bad is if you you try to do something like this person do equals and just some empty brackets now even if I just leave this empty the fact that you try call equals onside person. name is going to be a bit of a problem so we can say person object the name property inside it and we're checking if it equals to abber for example but because we've just set it to null let's see what happens you see that we actually get an exception it's a null reference exception because if you hover over name you see that returns back null nulls are very bad in this case whereas if we actually bring our function back and we make this into a private and then if we try and take this value our null value and place it straight inside our set name if you uncomment it get rid of the quotation marks and if you actually try and assign it to null let's see what happens then we're going to get invalid name and this prevents us from breaking our code if a function like equals were to be called on any of our properties inside of name so now that we've done it for our name we can also do it for our age but before we do that we can also call a function called get name return details gives you back these details in a very specific fashion but what if you wanted to do something like this your name is and then you wanted to do person. name but of course you can't do that because name is no longer public so you can't reference it directly so we've got a set name and then now we need to do a get name so we can have public and because name is a string the return type is going to be string and we can say get name and this function is very simple it just returns back name and that's it there's no parameters because all it does is return back a value and in this case it's just returning back name so instead of using person. name in here we can say person. getet name open close the brackets to indicate it's a function but there's no parameters now you see that we have no compile errors so now if you run that you'll see that it says your name is invalid name so let's actually give it a value and we can say hurry again run the code there you go your name is hurry so let officially change it and now let's work on the edge so just following the exact same approach we can have a public void set age int age and instead of just doing this. age equals age let's try set some boundaries on this we can wrap this inside an if statement so as for the condition we want to valid Val if the age is successful so we want to do if age is greater than or equal to zero and age is less than or equal to 150 so this means if the age is less than zero or greater than 150 then this is going to return back false and then it's not going to assign the value and we can simply assign it to minus one minus one is just so we know it's a bad value so now that we've created our set age we can actually make our get age so we want to return back an INT because that's going to be the data type PR age so we do public int get age we don't need any parameters cuz as like the name we're just simply returning something so we can say return age so now that you've made the set age and the get age let's actually use it in our code so we've made our set name and let's say person do set age and we have 25 inside here just like above and then now that we've set the age let's appin this sentence we can say and your age is and then person. getage perfect so let's run the code and see what happens there we go we have 25 and Harry being changed so another little tip when we doing this code our get age is one line and I'll set age as a couple of lines but fundamentally only assigning age so what we can do is we can make these into the tertiary operator so as we can see here this is the condition if this returns back true then we assign age our local parameter and if this returns back false we assign minus one so we can actually make this into this. AG equals if you remember remember the format of our conditional operator use condition true and then condition false so this is our condition that is leading our if statement and if this returns back true then we do question mark and put age in there and then call on if it returns back false then it's simply minus one there we go so this has actually been entirely replaced by this one simple line and we can do the same thing for our string so we can say this.name is equal to string that is null or empty pass the name name inside there and if that is true then we assign it to name and if that is false we say invalid name let's comment this one out and let's see if all code runs okay still hurry 25 hurry 25 and now let's try our bad values so we can try to set the age to 200 and the value to nothing and let's see what happens we get invalid name minus one and there you go perfect so that's working okay let's undo them values and you can see that this has been shorten completely another top tip for functions like this you can actually use something called Arrow functions and if you've done any JavaScript this might be quite familiar so we can have our get ede and instead of open the curly braces at this point we can actually place this Arrow inside so if we comment out this one with arrow functions you can only return back one simple line so because this is only one line we can have return age but our functions don't like the keyword return any variable that you put straight inside here is automatically applied that it's a return type so we literally just put age get age returns us back with age if this is confusing then stick to this approach but this can might tidy up your code because instead of having all of this and all the curly braces for one simple line you can use Arrow function so if you actually copy and paste but first comment out all of these functions you can see how small the code can actually get there we go and then let's actually have a public void set age let's put our R function in and then we can take this one line and paste it straight into here so you can see that these two lines are now being replaced by all of this and of course we need our int age inside here there we go so now we can do the same thing with our set name we can take this we can have public vo set name String name and then have our Arrow function and then simply paste that in you can see that this will get a little bit long now but it's still ideal I've got the code zoomed in but if you put that to 100% you'll see that this code is actually pretty small it's just I've zoomed in just so you can see the code a lot clearer and then finally for public string and we can get name and then we simply just do arrow and then name and you can see that with all this other code commented we just relying on these functions as we just created and you'll see there's no console errors or anything else so if you try and run it you'll see that everything is going okay of course if you don't like this notation and you don't have to include it you can stick with the curly braces I don't use Arrow functions a lot in practice because there isn't many situations where you'd actually use them and even if you do some people might not like them or there might be certain guidelines that you might be following inside a company what I do suggest you stick with is the tertiary operator these are a lot good and a lot better to use since it reduces the cord drastically if we actually remove this and I'll paste it back in just so you can see it for reference inside the resources but you can see that these four functions are now reduced to on one page you can see that they're all got one lines and they're pretty short so let me undo that just so you can see the original code and have it for reference so there's a lot covered inside this video so let's just have a little recap before we finish up so just to start at the beginning when we initialize our person with their name and their age we don't actually have any other opportunities to change their value which is where this comes in you can actually just say a person. name and assign any sort of value you can put anything inside there and it will assign it directly unconditionally the problems of doing this is someone might expose it to null by accident and some wearing your code if you're using something like equals this will actually prevent an exception of course you can wrap this inside a TR catch but this is unnecessary because we can prevent this in the first place it's always best to prevent an exception than to put additional code in like a TR catch in order to catch something that you can prevent in the first place prevention is definitely better than the Cure in this case so having something like a person. name being exposed it's not so much for the integer because integers will always have number values whereas strings they can be initialized to null there is no such thing as null in our age that our default value for an integer is zero so we don't really have the same issue we started introducing the name function and the age function these are used so we can control what Val values get assigned to our local variables and we also have our get functions get name and get age so let's explore how these are made inside our Cass and expand on that and see how they work so first we need to make sure that our variables are actually private they're private so we can't access them just like this if I copy and paste this line above you'll see we're going to get a compile error and this error is because we can't actually use it because as it says here it's inaccessible due to its protection level and the protection level comes from the fact that this is indeed private it's private so it's only accessible within class person so every reference to name can be used inside here just not outside so the only way to be able to change the name now you've made it private is by enforcing this function the good thing about this function is we can check if the value is invalid and then we can star it if it's valid and then change it to something else if it's invalid and then we can wrap this if statement around in a conditional Operator just to make it a little bit shorter and in order to retrieve an name because now that it made it public we can neither set or retrieve it so we have our get name function that simply just returns it back to the screen nothing special here and the same thing for our set age we can check if the age is between 0 and 150 and assign it and if it's not assign it to minus one and then again wrap it around in our conditional operator and then for our get age we can just return age I demonstrated our functions inside here you can take all of these on line functions and actually add them all in one line without the need of cly Braes if you want to return back in age then you simply just type in age just like you can see here and here when you do assignment you want to specify this.name equals but when you're doing returns you just need to type in the variable that you need of course this looks a little bit cleaner and a bit shorter but not Everyone likes this notation so it's completely up to the developer or the environment that you're working in and finally we just have our return details and then we can make use of them just like this by using person which is the name of our local variable for new instance followed by a DOT and then set name set age and then get name and then get age so now that we're dealing with classes it's important you focus on the scope we have a person person here that's defined within the main which means it's only Within These two curly braces so if we had a static void and a function that did something inside here we can't access person inside here if we take out the comment and we try it the only reference we have is accessing the class directly not this local variable if you want to access local variable from inside this function then you'd simply have to pass it in like this and then it'll finally become available as you can see now there's two and it says as a parameter and the same goes for this class above just because we have name and age up here it doesn't necessarily mean that we can magically use name down here if we have something like a static int defined right here then we can use this integer inside these function functions as it says there it's available we can sign that to 10 and it's also down here available and we can sign that one to 20 and you'll see we have no compil errors but if we take this and put it inside our return details function then you're going to get an exception because X is not available within that scope and the functional scope matters inside here as well if you have a string test inside here we can just access it in another function for example the Constructor we can't just print out test as a screen the handy or classes if you want variables to be available throughout the class then you put them at the top we can have that private string test and there you go you see that the compil error is now gone and we can give that initial value and then you can use that to print to the screen Etc and just to note when you have a variable that's called exactly the same thing we have a private string test up here and we can say hello and then we also have a string test down here so let me demonstrate what happens when two variables are the same so let's let's move this into our Constructor so if we run this as it is we test equals hello and then we print out test and then run the code there you go we get hello printed and just ignore this this is from the return details function as we've got in the main down here return details so we've made our new Constructor and then assigned it the value with abber and 23 and then we can get hello printed to the screen but let's say we actually made a string test inside here and we said hi instead of hello then which one you think get use the global one or the local one let's run it and find out it's actually the local one the compiler will always prioritize the local variables over the global variables and this is the reason why you need to type this dot because when you use name it's always going to reference the parameter when it's name on its own use console right line and say name and then if we do after this line and another console right line and we say this. name then these are completely different this one is the parameter and this one is talking about the variables from the class and these are known as our Fields local variables take presidence over our Fields as long as they're called the same thing as you can see now it says it's assigned but the value is never used if you take the string test out then you can see it's now being used there you go hello gets printed out to the screen and there you go the green line has went because we're using it down here scope is very important when you're designing these classes and just to note that the variables that are available inside here are not going to be necessarily available inside here unless you make them public and even when you make them public that doesn't necessarily mean that this is still available magically over here name will only be available through an instance of the person class so if we do person. name now we can see that that's available as our field so that's why that makes it public if we try and make this private again just to return that value back and we scroll down you'll see now we get a compile error because it's inaccessible because it's outside the scope because it's now a private variable so we've covered what it means to have a public or a private field if you have a private field then you're going to have to use Setters and gets in order to work with this field if you make it directly public then you won't need any Setters and gets because the user can just type iname after their public instance so you can have person followed by the dot and right now you can't see name inside here and the blue slittle icon is no longer there the reason why it's not there is cuz there's no public Fields if we then change this to public remove the dot and readit you'll see that our blue square is now back because our field is now accessible and we can assign that to anything that we want the whole point of making this private is your only restricted access so you know what you're doing and the reason why I say that that is if they enter something that's invalid then we want to specify something like invalid if we give them Public Access then we're not going to know and we won't be able to validate what they've entered so in order to do it through a Setter we can make it private create our set function with a return type it's going to take in a string parameter and this string has to be the same data type as the parameter you're talking about call it name or whatever you want it to be and because these two are called exactly the same thing we have to use this dot so we're referencing this name instead of this name in the parameters and here we're just using a conditional operator and we're saying if the string is not null or empty hence the exclamation point then we assign it to name name gets put in this. name and if this were to return back false then we place invalid name straight into this. name and for the get we simply just return a string since that's a data type for name and then just return it back and it's that simple and the same thing for age we validate the age range set it and if it's outside this range we can set it to minus one so as you can see this is a bit long we have our private variables and then we have two functions one for set one for get and the same thing for age so these are called fields and gets and Setters so I'm going to introduce a notion called properties and properties make it easier to do this exact notation so let's now see how properties created since these fields are private we need to make something that's actually public so we can do something like this we can say public string and we can say name with a capital N so now you can see that name and name are not actually clashing and we can assign that in here should we want to and you see we don't need this dot anymore because this is now different it's a capital N so this one always references this and this references this so we need to add something else onto here so if you create them both now you can see we can do age equals age and there'll be no problems with this so now that we've made our two new Fields so now we have our two new public variables which are known as our Fields let's see how we can turn them into properties so if you remove the semicolon you can actually add in some curly braces so inside here we need a getter and Setter just like we had down there but we have a quick Ann notation for it instead of making two distinct functions you can actually create a little section inside these curly BRAC to get and set the name so you got to think of this as a middleman the same way this is a middleman we call this function and this function will affect the name and this is going to be the same principle we make use of name with a capital N but it will actually be affecting the lowercase n variable these are going to be our new middle mans and they will directly replace the gets and sets here so what we can do in here is we can say get press enter go on the next line and make some cly braces and then we can also have a set so this is like our mini get and mini set function just like we've got here by as you can see it's a lot shorter we don't need to give it a distinct name or set the public or anything else we just give it a simple set and get so if you have a look at the compile error it says not all call Path return of value because as it says here this get function is actually a mini function built into this property person. name which is our name with a capital N and then it's do get and this returns back a string so if we actually just type in return this then it gets rid of the compiler error but of course we don't want to return nothing we actually want to return name because remember what I said string name and intage up here is our private field they actually start the data the public string name and the public in age is the middleman that coordinates all of the gets and sets to do with the private variables so for the set just for now we can say name equals and then what do we give it the value of so if we hover over set it doesn't actually give you any indication of what it's going to be so let's have a look if we press control space then we don't also get the list of everything that we can add inside here now it's very difficult to understand what to assign this to when we have set name we've gave it a string name parameter so we can use name down here so what's our parameter in this case well the function itself doesn't actually tell us but I'm telling you right now that the parameter is actually just called value and this is a very default parameter that you'll see everywhere when you doing gets and sets inside a property you don't have to specify value or anything it just gets simply assigned in just like here where we have string name this will be a string value so it will look something like this behind the scenes but of course you can't actually type this in cuz remember these properties are trying to give you a short hand on how to do gets and Setters so you just got to remember that when you trying to set you get the property inserted as value so you can startall that into name so that's it the name is actually sorted now so before we do the same thing for age let's see how we can use this inside the code so we scroll down to our main we have a person person and then we have a console right line that prints the details so we can actually do person Dot and you can see now that it's slightly different if you ignore the age since that's returned back as a field since we haven't done that yet you'll see that name now has a little Cog next to it show only properties this is a new icon that we haven't saw yet so this is our new icon it says it's going to return us back with the string and we can actually execute a get and execute a set straight on this name then we can say name equals Harry and we don't get any compiler errors whatsoever this lets us do it completely so now if we do another console right line and we say person do return details and let's run that and you should see that the name gets changed there we go ABA gets changed to hurry perfect so after we've got person. name let's see how we can also get the value so we can just say string interpolation your name is and then we do person and followed by a DOT and as you can see the exact same list that we got given over here is given right here as well name also says get and set and it returns back a property which is a string type so we can open like this and you'll notice that we don't have the parentheses after it and the reason for that is because the brackets indicate that you're calling a function but a property is just a property it's almost like a variable so you're not actually needing to put any brackets after it because there's no function to call so as you can see this is exactly the same as this in this case we're actually setting the value and in this case we're actually getting the value so let's comment this line out and let's see what happens your name is Harry so that's worked okay so now let's do the same thing for age remove the semicolon add the curly brace we can say get and then return age and then simply do set and then do age equals value there we go so now we got that set up if we return back down here and we see person dot so as you can see now the age is being removed as being a field as we saw in the blue icon it's now being turned into a spanner which means it's a property as shown here show only properties so now you can see it returns back an integer and we've got a get in a set so we can set that to 25 for example and then we can append onto here and your AG is person. AG you see that it's a couple a just as this one is a capital N and now we have get and set available and again we don't need the brackets inside here since this is a property not a function now let's run it we should see Harry 25 there you go your name is Harry and your age is 25 perfect so as you can see now is instead of having our set name and get name which are these two functions we actually have them contained within a property we call this property and it affects these variables but as you can see just as these functions below were a middleman we've now moved the middleman into these properties so as these are only one line you're probably thinking there's probably a better way of doing this and it's a lot quicker for syntax and you're right there is so let's explore that so I said before about Arrow functions when you're doing something like this get name you can have public string get name and then you can simply do Arrow name and this is a very common string function get name that just returns back a value and you can make that into an arrow function by literally just putting back name so we can actually do the same thing but for our properties so these both contain one line so we can actually minimize this and if we just block comment this out we can say public string name and then we can have get and then the same thing with the arrow function when we're doing Arrow function down here you would simply won't use the return keyword you would just type in the variable you want to return so we can say get arrow and then simply low case name and then add a semicolon just so you know that that section is ended and then straight after we can have set and then arrow and then name equals value just like that so as you can see these contents are exactly the same we've actually return them back in a short space and of course here as we got a compile error it just expects a semic callon to be right at the end here there you go and now we do the same thing for our age we can do public int age get Arrow age and set Arrow age equals value perfect so now you can see that this has been drastically reduced if I cut this just underneath you'll see that almost all of these lines are just replaced in a two and you'll see that our functionality will still work exactly the same if we just run the code Harry and 25 is being reassigned over our default variables perfect of course now if you want to add some more functionality inside here for example in our set name we had a little check that makes sure that it's a valid name before we assign it so we actually take this and paste it over here then you see the lines grown quite a lot so what's PR to do is if you're going to have any data inside here that does a little bit of logic then it's best to keep the curly braces since you can have a bigger output and it looks a bit more sensible if you just simply getting and you're setting the variables then you can leave this notation so let's undo this and bring back the original ones in this case there we go and then we can take that line and in the set we can actually replace it here so as you can see this is a little bit grayed out so let's put the semicon at the end and let's see why this is grayed out name can be simplified so what we're doing now is name and all of these variables are actually looking at the private variable whereas if you actually look down here and we uncomment this you'll see that set name if we double click on this one this is the only reference to it which is our private variable appear and the reason why this doesn't need to be used in this case is because our parameter is now called value so it's saying the name is equal to checking if the value is null or empty assigning the value into name if not and then if it is empty then we assign invalid straight into name in the case of our set name our name was our parameter the same goes here if we change this to Value we can change these two for Value as you can see now this dot is actually grayed out and it can be simplified to just simply name and the same principle applies above so let's comment these back out and scroll back to the top so now that we've assigned name there we go we've got our check inside there and you can also leave this on one line if you want you can even drop the curly brace in just so it looks like this instead of having it all on one line so you could do this and this would be applicable as well but the second you start to put it all on one line then it gets a little bit messy quickly so if you leave the outer bracket just like that then you can can be pretty short since you don't need more curly braces so now that we've done that for the name let's do it for the age as well so we had this. age we check the range and we assign the relevant values so let's take that paste it over this we don't need this dot anymore and age in this case is actually going to be the value gets passed in so replace all the ages with value there we go so if the value passes the range check we put the value inside age or not we can put minus one Inside Edge and again we can have the same thing we can use our arrows inside here there we go so now we've got our code drastically reduced so we went from these big functions that have to be defined with specific names over to our properties and they went from really small to just a little bit bigger but now they have advanced connections just to make sure that the variables are okay before you assign it in so now that we've got our properties let's have a look so inside our Constructor we we don't also need to use our local variables which is our private ones directly we should actually get rid of this now and we should always do everything through our properties name equals name and because this is a capital and this is a lower case we don't need this dot in there there we go so what you should do in the return details function is also use the capital n and the capital age so when you hover over these you're actually referring to the property because like I said before these are the middleman to communicate with the private variables you shouldn't need to access the private variables directly you should use the middleman as much as possible so now that we've done that I have one last thing to introduce so if we actually abandon all of this code just to keep it for reference we have something called an auto property and you briefly saw it when we saw it down here so if we actually just bring them back for a second and if you hover over a name down here it says string name get and set in the Cur C brace but you see how the get and set is empty it just has two values inside there and it just ends a curly brace with no actual logic you see in our get we're saying age and our set we're saying age equals this so when we're doing Auto properties what you can do is you can actually make these public again change these to a capital N changes to a capital A and just straight after it you can say Get Set just like that and what that will do is although they're actually made public what it's doing behind the scenes is actually doing this for you it actually has a private and a public for you behind the scenes this is just a Shand these are what's called a auto property what it does is it makes an anonymous property behind the scenes as I'll show you in Microsoft documentation right now as it says here in CP 3 or later Auto implemented properties make property declaration more concise when no addition logic is required and what that means is no additional logic all of these are additional logic if you just simply assigning a value and reading it back just like here then this is no need to write get name and set name if all you're doing is getting and setting it if you're getting and setting it but there is a certain amount of logic as we have here we essentially have a conditional operator that's making a subconscious decision about what to assign the name to but if you just simply assigning something like this then an auto property is perfect they also enable client code to create objects when you declare a property as shown in the following example the compiler creates a private Anonymous backing field that can only be accessed through the properties get and Setters as you can see here just like in our example we have public int something and then get and set and then they have a public in something with the get and set as well and they can use it just here to access it directly and because they're simply just assigned and getting the values and there isn't any additional logic then this is the best way to do it and you get as it says here an anonymous private backing field so this would be the same thing as doing this private string name and private int AG so once you do that and you make this into the get and set properties which are these two right here this and this line together make a property what the auto implement the property does is actually combine this line and this line together and make the private one behind the scenes so the programmer doesn't see it but it will be applicable when the program runs in the compiler and then you only get publicly exposed with this parameter which will be our name property so it will actually make the private for you if you just keep it like we had it a second ago just like this so if you leave it like this it will actually create the private variable behind the scenes as it says here it's Anonymous backing field and it can only be accessed through name and age and as you can see none of our code has actually changed all of these still function okay and if we run the code we should still get Harry and 25 so just to sum this video up since there was a lot covered the bottom line is if you're going to have any sort of values that require any logic then you should use normal properties if you're simply just going to assign and get the value and it doesn't matter and you have no control over it then you can use the auto implemented properties since that will do the same thing with less code using the gets and Setters is the old way of doing this and you should always use the properties going forward Getters and Setters are very helpful to know just so you understand what they are and why they exist but you should not that properties are the best way forward properties give you access to doing the same logic as it says inside here if you do an autoimplemented properties then you're not allowed to use the logic inside the set or the get so if you don't want to do any logic then don't use the AL implemented properties only use the normal properties to make a get and Setter you just do set name get the parameter and assign the local variable and the get just returns it getting back a property you want to capitalize your private variable if you had private string name with a lowercase n you want public string name with a capital N you get the name and then you can set the name with some sort of conditional operator or any if statement or anything inside here and the same thing goes with the age you can have a public int age with a capital a and a private end age with a lowas here you can get the age and then set the age with a conditional operator again or any other code if you don't require any logic like these two lines indicate then you can simply just use the auto properties as demonstrated above here and they can be used quite easily throughout the Constructor and our functions and even outside the function when the user is trying to call them but one thing that we haven't been able to solve and you may not have noticed this as a nuisance the problem is when you trying to return details about something we're having to call this function every single time if we have an INT age for example and made that equal to 23 and we did consle right line and simply placed age inside the brackets we don't have to do anything like this because it simply just prints the value out if we run the code you'll see that it simply just says 23 this should be pretty simple for our person as well but it's not we need to call return details every single time we want to print the properties and if we don't do this the only way to do it is is by making some string interpolation and we can say person. name and then also include person. AG Etc and then that can print out to the screen just like that of course it doesn't have the same format in but we can also just take this place it straight inside here add our person dot before them person Dot and there you go then you get exactly the same output as call and return details but of course you don't want to do this every time and you certainly don't want to have to type type in return details function every single time as well you want to keep it as just person now of course this is not going to work straight out the box let's try run that and see what happens so we get string override. person and what's going on here is it's saying namespace is string override and then it's a class person so it's just printing out this person object but it's not really doing anything because we haven't really told it to do something so what we can do here is we can actually override the two string method so let me explain so let me set up a couple of examples just to show you what's going to happen at the end so right now we call return details to return these details what we can also do is say do two string and then we can also do these three options return the details convert it to a string or just print the person straight to the console at the end of this little section we're going to make all three of these print out the same values so let's have a look now two string and printing out normally these two lines right here are actually doing exactly the same thing behind the scenes when you place anything inside these brackets inside a console right line it will try and convert it to a string anywhere so whether you put to a string or you leave it as person the console right line function will still accept it so let just comment out the age for the time being in order to make the two string function work as well as just ping person inside the brackets we need to make a special function which is an override function so let's have a look so just underneath our return details still within the scope of the class would say public and then override after we press tab we can follow it by a space and we can see the functions that we can override so in this video we're actually going to cover two string and equals get hash code will actually serve as a default hash function if I show you the documentation it says here a hash code is numeric value that is used to insert an identify an object in a hash based collection this is normally used when you doing hash functions as it says here and for the time being we're not actually going to be using this right now so the two we can do are two string and equals but as you can see our two string is available right now we'll cover equals as an extension in a minute so let's double click on our two string and we get this little template placed in if you don't want the template then it's just an override it returns back a string since it's converting to string it needs to be this exact notation if you drop the T then it's got nothing to override now you go be a compil error cuz there's nothing to override itself so play two string the capitals there's no parameters passed in and then we're going to be returning something so the thing that we're going to be returning is exactly the same as our return details function we actually have two options here we could say return and then return details so what that will do is it will go to this function it will call this function grab that and essentially place inside here and then return it back to the console in the ideal world we don't actually need this return details function so we could comment it out but I'm going to leave it in just so the demonstration doesn't break down here so we can take this and place it straight inside here now we have two functions that essentially do the same thing thing but the advantage is this function is something that needs to be called explicitly do return details whereas this function the two string override actually just gets called naturally without having to add any extensions so if you run the code now you'll see that now the all equal exactly the same value we get three sections that have this maybe we can place back SLT instead just so we can have them all in the same line there we go so you can see all three are exactly the same so what we can do now is if we comment this option and we comment out this function we don't have to include two string if we don't want to we can also comment this one out and we can keep it just as person so as we do when we declare the integer we say inage equals 23 and then we simply print out and this is exactly the notation that we want it should really be this simple there you go one line creates the person and one line with just a variable name goes inside the brackets to print them out the same thing here person person age and age and let's run that code now and there you go you get the person printed and the age printed exactly and straightforward as you may think it should be so now that we've done that let's explore what the equals function needs to be done let's make another person we can say person test equals new person and we can have hurry age 23 now we don't need to print them out in this example we just need to demonstrate this equals function so if you remember with strings we can have a string called Abba for example and we can say do equals straight after it we can say if ABA is equal to Harry then we can do something inside here what I'm trying to demonstrate is once you've got an object you can place do equals and then you can compare it like that so you can also do that with our classes so we can say person do equals and then equals to test and in here we could just say same let's try and make these as same as possible and see what happens so let's keep the name exactly the same just like that and let's copy the 25 down just like that so now these two are instantiated exactly the same way let's see what happens when we've run the equals then we don't get anything printed which means they're not the same so because this doesn't automatically tell us that these two are exactly the same we can override that and provide our own functionality just like we did with the operate overload we override equals we get passed in an object and we need to check something inside it so let's see what we can do inside here so in order to check if something is equal to another thing what can we do so we have a name and an age if this one is the same as this and this is the same as this then two people are exactly the same so let's try that out and see what happens so we can say name which is the property inside the class that we're currently inside and then we can use equals because this is just a string parameter and then we can say that equals to objectname but you can see we've got a little problem here this object is very generic it's just an object every class that you create is derived by an object what that means is every class or integer or double at the end of the day is also just known as an object through inheritance which we'll discuss further on this course but just know that everything inside C is always an object somewhere down the line so what that means is we have to convert it from an object to our custom class which is person in this case so we can use this thing called casting so we can say person person which is just Define a new variable and we can make that immediately equal to object as person so what we've done here is we've said our object which is this parameter is currently an object right now we want to cast it as a person which is kind of like converting into a person and then placing the values inside here so now if we get rid of this comment and instead of using object we actually have a new local variable called person so then here we can say personname there we go now we have access to the person property since we've converted this object into a person and of course we know that we have name and age available so if the name is equal to the person. name and the age is equal to the person. age then we must have a match and of course you want to keep using the properties we're going to use a capital A and there we go so we run the conversion on one line and then we check if they're equal to each other now in this specific case you can actually pass anything inside here so let's try it we can pass five into idea and as you can see there's no compile error cuz like I said five is just an integer which is an object at the endend of the day if you make it a double that works as well there is literally no compile errors and even if you put M to make it into a decimal again there's no compile errors because they're all objects at the end of the day so let's pass Tes in there what you will have to know is if you do accident pass in a double for example like this you're going to hit an error here which will be a runtime error it will try and convert it as soon as it hits this line and obviously you can't convert a double into our person so what you could do just to wrap it around you could say if the object is a person then we can proceed with a conversion just like this and then what you can do for safety is just outside of this you can actually just return back false just so the user knows that this isn't equal to each other so if the object is a person then we convert it as a person is is used for checking and as is used for converting is this object a person and if it is then we try and convert it and then return back if they're equal to each other and if we accidentally pass something in that's not a person then we just return back false so let's just demonstrate this first not the same so let's just save five inside here it says not the same so let's actually go into this place a break point and let's run it again hover over object then we get five if we place this straight inside the watch you can see object is person is returning back false so it's skipping this entire function and going into return false and then it's returning back false so we get not same let's stop the program change this over to test and rerun it using F5 and now we can see object is person is actually set to true so now if we put the object inside here you can see that generically it's an object right here it says object so what we can do now is we can place person and down here as well you see that person doesn't exist but if you just give it a second it we change this to just the p there we go so obviously the person doesn't exist cuz we're only up to this line we press F10 and F10 again so now it's create a the variable and F10 wants to skip over it and now you can see the object has went from type object to type string. override. person string overwrite is the name of our namespace and do person with a capital P is the name of our class now you can see that the object and the values are exactly the same 25 ab and 25 AB as you can see right here so now both of them are exactly equal to each other so when we check this name here is Aba name here is Aba age 25 and age is 25 so this must return back true and we can check that by highlighting everything dragging and dropping it down here and we can see it says true there so when it returns back to our code it's going to go and print their same perfect there you go so that's it for this video but let's just have a recap before we wrap up so before this video we'd always print the details out like this person. return details but obviously we don't have that function anymore so let's just bring it back quickly there we go so we use return details and this is just a bit long have to do this every single time if you want to print the details of the test object as well you have to test Dot and then return details again it'd be so much easier if we could simply just use it like this as you would do with a normal variable like an integer double A String Etc and now it's made possible by using our public override string two string function it will contain exactly the same contents as our previous function except we won't have to go through an additional function just to print out the details we can override the two string and then we can call it straight in the console like this and finally when you're doing equals inside an object you can actually build in some custom functionality we can convert the person using object as person but first before doing the conversion you want to check if the object is indeed a person type before doing the conversion this will give you a runtime error on this line so let me just demonstr that before we continue so if I comment out this one and actually just change this into 5D and then let's press into the code right here it's going to hit this line if I press F10 then it's going to try and convert it but you're going to get back null and then if you run the code again then you're get an exception thrown here you're going to get a runtime exception because it's a null reference we're trying to run the equals function on something that is null which is right here null reference exception so you shouldn't do this you you should also make sure that these are correct values before doing it this is a form of error checking if you don't do this then you're going to have to wrap this inside a tri catch and it will look something like this and the cord will be considerably longer you can place these two lines inside here and then place your cat inside here etc etc and you can return false inside here but as you can see the Cod is a bit more complicated now and there's no reason for this extra complication if you can prevent it with an if statement so undo that so what's best in this case is to say if the object is of type person then we can run the conversion if you run the conversion and it's not of type person then as you can see it's going to return back null for the person and then when you run this line it's actually going to return you back a null reference exception at this point but anyway the whole point of this equals is to check if two objects are going to be equal to each other so we keep this back to test because this is a custom classes you can't just simply do person equals equals time test and assume that that will just work these aren't builin functionalities for custom classes we covered operate overloading where you can actually overload what you do with the equal sign but we didn't cover the dot equals which is what we're doing today in this video as well as the two string this is a different kind of overriding because in the other one when we're doing operator overloading that's specifically an operator that you're just changing the parameters of whereas this one is a strict override of a function equals and the functions two string this will make it easier to print your custom classes out to the screen as well as comparing them just like this person. equals putting test inside the bracket is a lot easier and quicker and you can build in your own custom functionality if you only had the age in there then you can compare the age maybe have a lot more properties and you can always just chain them inside a big if statement that's fine as well but the point is you have full control over how you compare your custom classes maybe you had a list of names inside a dictionary for example and you wanted to add a new name or a new age or a new user to this dictionary but first before you add a new user to the dictionary you want to check if the user already exists so maybe you could have a system where it uses the equals function and it Loops through all of the dictionary items and it checks if all the values are not equal to this one if you didn't build in this functionality so you could do the do equals function then you won't be able to determine if this one is equal to this one and now with your equals function overrided you can now have the functionality to do so thank you for watching this C course I hope you found it helpful in your journey to becoming a proficient C developer if you have any questions or need further clarification on any topic we have covered please don't hesitate to leave a comment below and I will do my best to assist you for those of you who want to dive deeper into C consider checking out my udemy cause you'll find more comprehensive lessons and HandsOn exercises to enhance your skills remember practice makes perfect keep coding and exploring and I wish you all the best on your programming Journey
