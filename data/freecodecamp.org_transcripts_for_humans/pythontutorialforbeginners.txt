With timestamps:

00:00 - You're about to learn the Python 
programming language from scratch,  
00:03 - you'll learn everything from setting 
up your system to program with Python  
00:07 - to working with API's, Bobby Stearman 
from dig coding teaches this course.  
00:12 - Hi, everyone. I'm Bobby stemming from decoding. 
And this is my Python course for beginners. So  
00:18 - if you're looking to learn Python, or polish up 
on some skills you've already got, then you are  
00:22 - in the right place. Because in this course, we'll 
be covering topics such as setting up our system  
00:27 - to use Python, we'll be looking at numbers, 
strings, data types, control flows, classes,  
00:33 - and all the fundamental things that sit in 
between. And before we close off the course, we'll  
00:38 - then use those newfound Python skills to write 
some Python programs. But before we jump into it,  
00:44 - I just like to say a big thank you to the guys at 
Freako camp for publishing this course, you guys  
00:49 - are fantastic, you're doing an outstanding 
job, keep up the good work, and also keep  
00:54 - that content coming that is absolutely free. So 
without further ado, let's jump straight into it.  
01:13 - So you can see here that I'm on pythons main 
website, this is python.org. So this course has  
01:18 - been designed around their own documentation. I've 
extrapolated out the parts that I feel are the  
01:22 - fundamentals for you as a beginner. But we will 
be becoming familiar with their site because like  
01:28 - I say, I've referenced the documentation quite 
a lot. So if you visit python.org, hover over  
01:33 - downloads on the nav bar, you can see here, it's 
given me the option to download three, point 10.2.  
01:38 - That's the latest and greatest stable version of 
Python as of the time of recording this video. So  
01:44 - if I click that, that will download an installer, 
minus download. And it will say that as you become  
01:49 - better at Python, and you become a freelance or 
a software engineer, then you will start working  
01:54 - on projects that may have been built some time 
ago, in which case, you may need an older version  
01:58 - of Python on your machine. To do that, hover over 
your machine, type on the left hand side and click  
02:03 - that will take you through to a different page 
and you have all of the different releases  
02:06 - that you can download. So for instance, if I 
wanted to download 3.9 point 10, I could click  
02:11 - this here and it would download the installer and 
I can go about and just install it in the same way  
02:15 - as we are now about to for three point 10.2. It's 
a little bit more advanced than beginner, but I  
02:21 - thought it'd be worthwhile just noting it down. 
So the installer is hit and ready to open up.  
02:29 - Okay, so it's given me the option. Let me just 
zoom in a little bit that you can see that a  
02:34 - little bit better. So it's giving me the option 
to install now. Now you can click that and it will  
02:38 - go ahead and he'll install Python in that path. 
I don't find it very intuitive. I like to keep  
02:44 - Python in my own path of choice, because if I 
want to download more versions, I know exactly  
02:49 - where they are. And I can just flick between 
them as when necessary. So we're going to go  
02:53 - with custom install. And we're also going to 
click the Add python three point center path.  
02:57 - Because if you're using let's say a web framework, 
such as Django, Django, we need to look in your  
03:02 - environment variables in your path to understand 
where Python is on your machine. So it's important  
03:06 - we click that OK, zoom out quick. So we will click 
that, click on Customize. And you can see a whole  
03:14 - bunch of things ticked, just keep them ticked. 
Okay, this is the first install that you've  
03:18 - done. So let's get the documentation that's get 
a package manager called PIP. We'll be using that  
03:24 - later on in the course. So keep that ticked. 
Okay, and keep everything else ticked for now.  
03:30 - Click Next. And then we've got zoom in 
again, we've got a few other options here,  
03:35 - just keep it as as you can see that the fourth 
one down, says as Python, add python two  
03:39 - environment variables, that is important, we'll 
do that. Okay. So all we need to do is click on  
03:43 - Browse and change the customized install location. 
So I'll go ahead and do that. And I like to keep  
03:50 - my Python versions in my PC, C drive. And in 
here, I'll create a directory called Python.  
04:02 - session which contained by Okay, we got one 
cool place and have we we have Okay, great.  
04:09 - We will then go in there and create a new 
folder. And we'll call this Python. We tend to  
04:17 - click enter. So if I was to install Python 
397, I'll create a file called Three point 9.7.  
04:25 - And I'll install all of the Python packages 
and files and configurations in that directory.  
04:32 - So it keeps it all in his own little container 
so you can keep flicking between them. Okay,  
04:35 - that's why I do it that way. So we click that, 
click OK. You can see now where it says customize  
04:41 - install location is now changed to Python, Python 
3102. Okay, now we want to click Install. There  
04:50 - we go. It shouldn't take more than a few seconds, 
but that's now going ahead and it's fetching and  
04:54 - installing all of the Python bits and bobs and 
adding it to the directory that we just created.  
04:59 - And to test to make sure that it is on our machine 
present correct and working as expected, we need  
05:06 - now need to fire up what's called a command prompt 
on Windows. Now it's called a terminal on Mac.  
05:11 - But you, you fire it up on Windows by 
going to the search bar and just type in  
05:17 - CLM, it'll come up with command prompt. Mine looks 
a little bit different to what yours would because  
05:23 - I've changed the settings, yours will probably 
be black. But all you need to do is type Python,  
05:30 - put python three or three point 10. If you're 
on Mac or Unix, you put dash dash version.  
05:37 - Okay, actually, because we've got the pi 
dot exe file installed from this install,  
05:43 - we can actually reference on a Windows 
machine machine, Python with pi.  
05:48 - And that should still give us python three, point 
10.2. You can see that there you go. Happy Day. So  
05:54 - we've now installed Python on our machine, we're 
now ready to start looking at the interpreter,  
06:00 - which will then start looking at things like 
text editors and IDs and things like that.  
06:04 - So let's call it a day with this video. 
And I'll be seeing you in the next video.  
06:20 - So I'm on a Windows machine. So I'm using 
a command prompt. So if you are on a UNIX,  
06:26 - Mac or Linux, then he is a different 
command to me when firing up the  
06:30 - interpreter or using just general Python 
commands, you'd use python three point 10.  
06:36 - Now I use Python or p y. The reason I know I use 
the command p y is because this paragraph here,  
06:42 - I installed p y dot exe launcher in the last video 
I put together which we use to install Python on  
06:49 - our machine. So when I'm on my command prompt, and 
I'm typing things such as p y dash dash version,  
06:58 - you would put python three point 10 dash dash 
version to do exactly the same thing. Oh,  
07:03 - typo there, but you see what I'm saying? Okay, 
so let's fire up the interpreter with p y.  
07:09 - This autonomy, the interpreter is open. 
And in interactive mode. That's what these  
07:14 - three great n symbols are telling me. So give 
me some code, I want to do something with it.  
07:20 - But before I type into it, this understand 
what the interpreter is doing. So as I  
07:24 - typed Python code into this interpreter, it's 
translating it into a universal language Binary.  
07:29 - Binary is ones and zeros. Yeah. And like this. 
difficult to read, you can understand this is  
07:37 - the programming language that software engineers 
used to use back in the day when writing programs  
07:42 - 1000s and 1000s and 1000s of lines, ones 
and zeros. Joe Average could not just sit  
07:47 - on a seat and start coding, it's a pain in the 
ass. Okay, so and it wasn't very scalable. So  
07:53 - from binary, the assembly language was put 
together and this kind of streamlined binary, it  
07:59 - allowed you to use much more easier to understand 
commands to do the same thing. But assembly  
08:04 - languages weren't transferable between machines. 
So my Windows assembly language didn't work  
08:09 - on a different operating system. Okay, so then 
high level languages were designed, okay. And this  
08:18 - took the assembly language to the next level. This 
allows programmers to write code in a humanized  
08:23 - way in an elegant way to a cent and then translate 
it to binary. Okay, so that's what so these high  
08:30 - level languages, PHP, C++, you've got Java. And of 
course, you got Python, right. So these languages  
08:37 - allow us to code in an elegant way, and then 
things like the interpreter, but then translate  
08:42 - that into binary code. So our machines know what 
you're trying to do. Now, I hope it didn't just  
08:47 - butcher the explanation. But I've just tried to 
break down what the interpreter actually doing.  
08:52 - Because when I started, I didn't get explanation, 
I just wondered what the hell I was doing, I just  
08:56 - start typing away and it magically done something 
in the background. So I hope now you understand  
09:01 - what it is and how it works. But before I close 
this video off this just buyer in some code,  
09:05 - and just see it working, so I can just put a 
simple one plus one, so integer plus integer,  
09:11 - in this case, one plus one, if I press Enter, it 
will then run that command. And the result is two.  
09:18 - So we can go 10 multiplied by six, or we can use 
the multiplication operator, which in this case  
09:25 - is a star, press enter, and it spits out 60. So 
that is the interpreter, okay. All it's doing is  
09:34 - taken our code, in this case Python, and it's 
just translating it so that your machine can do  
09:41 - something with it. Okay, so let's close this 
video off. In the next video, we will start  
09:46 - looking at text editors and it is so thanks for 
watching. I'll see you in the next video. Bye bye  
10:01 - Okay, so my browser is open on microsoft.com on 
our Visual Studio Code page, because we will be  
10:06 - installed in VS code. In today's video vs. Code 
is a text editor. Now we use text editors. Because  
10:15 - in the interpreter, we can easily write 
single lines of code. We can run scripts,  
10:20 - but it doesn't really help us with things like 
syntax, errors and debugging. That's where text  
10:25 - editors come into it. And also, they will help us 
as a developer manage things like directory trees  
10:29 - and the hundreds of files. Okay, that's why we use 
text editors, there are apps that we can install  
10:34 - that help us just do our day to day job. Now, IDE, 
which are integrated development environments,  
10:40 - take text editors to the next level, they 
do everything that a text editor can do. But  
10:46 - with all the bells and whistles, so they help you 
with things like debugging, and deployment. Okay,  
10:51 - I will be installing a text editor called VS 
code because it behaves like an IDE because it  
10:58 - has been called extensions. And it's fantastic. 
And in fact, the reason I'm installing VS code is  
11:03 - because on their own website, they've got a tool 
here, that helps you decide what's best for you,  
11:09 - based on what you do. Okay, so under the 
languages, platforms and workflows, you can click,  
11:15 - so you can click the machine you're using, 
then the languages, platforms and workflows,  
11:19 - you can click, in my case, desktop, Python, 
JavaScript. And it's telling me that the right  
11:24 - job for what I do or sorry, the right app for my 
job is download Visual Studio code. So let's go  
11:30 - ahead and do that. It will download the installer, 
redirect us First, download an installer.  
11:36 - And then if we open that, I'll open up the 
installer, I will zoom in because it's quite small  
11:41 - on my screen here. Okay, so it's asking us to read 
the T's and C's, please do that. It's always worth  
11:47 - doing that I've already read them. So I'm going 
to go ahead and click the I accept the agreement.  
11:52 - Click Next. It will then ask you where you want 
VS code to be saved, I'm going to go ahead and  
11:58 - just keep it with the default, it then asks you 
to was this select Start menu folder, just keep  
12:07 - that as next it's fine, then it's giving you some 
extra options. One of them is quite important is  
12:12 - telling you to add it to your path. So same as 
installing Python, let's get this added to our  
12:17 - PATH environment variable so that it's accessible, 
and we know exactly where it is on our machine.  
12:22 - And then if we click next, it will summarize 
and we can then click Install should only take a  
12:27 - minute or two. But it's now installing all of the 
files and all of the configurations in the path  
12:33 - that it suggested. When it's done, it asks us if 
we want to launch VS code, we will keep that text  
12:40 - and click Finish. And in a future video, I'll show 
you how to open VS code in a certain directory as  
12:45 - and when necessary. So I already had an instance 
VS code on my machine, and it's opened up in the  
12:51 - directory, which is going to be the cheat sheet 
for this course. And you can see that it's got  
12:55 - all of the different topics that we'll be going 
through. But this is VS code, okay. So if I just  
13:02 - zoom in a little bit, there we go, we've got an 
explorer, here, we don't necessarily need to open,  
13:11 - it doesn't really matter. So we've got an 
explorer, tab or panel, we've got a panel  
13:15 - here that we can actually write straight into. 
So if I open up a new file here, and just put  
13:22 - hello with an extension P why, because 
it's a python file that I'll open this up,  
13:26 - and I can write straight into it. Okay, but what 
is beautiful about VS code is we can install a an  
13:32 - extension that will help us with syntax errors, 
click Extensions on the left type in Python,  
13:40 - that'll give you a whole bunch of Python 
extensions. Now I've got this one installed.  
13:44 - It's called Python. And it's been installed 
by over 50 million people actually,  
13:48 - I looked at this the other day, and it was 49 
and a half million. So there's a lot of people  
13:52 - installing this extension. So not that, you got 
to assume that 50 million people can't be wrong,  
13:59 - right. So it's good, it's gonna help you with 
syntax errors, get it installed, or select  
14:03 - another one and get that installed on your VS 
code instance. And it will help you with syntax.  
14:07 - Let's go back into the panel here. And also was 
good about VS code is got a terminal built in.  
14:16 - So where I've got my command prompt here, let 
me close that down, I will open up a terminal.  
14:23 - Mine defaults to CMD. Because I've changed the 
settings, yours might be PowerShell. But you can  
14:27 - select the type with this pulldown list, click 
Command Prompt. And then you can simply put p y,  
14:34 - happy days. Now I can type straight into here, one 
plus one. And you can see that that works. And you  
14:40 - can see here that actually this is what is under 
underlined squiggle here or underlined squiggle.  
14:46 - It's telling me that actually that's a syntax 
error, and that's coming up as a problem and is  
14:51 - explaining it here. That's because we've got the 
extension installed. So that is done right Got  
15:00 - a text editor installed on our machine, we've got 
VS code installed, we've got a text editor, we now  
15:05 - can start coding in Python. In fact, 
whilst I've got this directory open,  
15:11 - you can see that we're going to start going 
through these files and talking about each of  
15:15 - the topics in detail using VS code. So that 
marks the end of this video. Thank you very  
15:22 - much for watching. In the next video, we will 
install Git Bash. And the reason we'll install  
15:28 - Git Bash is because this repository is on GitHub, 
and you need to clone it down to get access to it  
15:33 - on your machine. So thanks for watching. 
I'll see you in the next video. Bye bye.  
15:46 - So Git is a version control system. 
And with Git installed in your machine,  
15:50 - you can manage version control using places 
such as GitHub, GitLab, and BitBucket. Okay,  
15:57 - so it's important you got git on your machine, 
I have already got 2.3 5.1 on my machine,  
16:03 - which is the latest and greatest version at the 
point of recording. So I won't be following along  
16:07 - with this video because it gets a bit clunky, 
and it switches my video off and it's just not  
16:11 - pretty when you're trying to watch and follow 
along. So I'll show you the steps get installed,  
16:16 - get get installed in your machine and come back 
to the video. Okay, so click the link here. Oh,  
16:21 - sorry, right, we are on get dash scm.com. 
Okay, that's where you will find get.  
16:26 - And you need to click on a version of when get 
for your machine type miners window. So click  
16:32 - on download for Windows, when you get redirected, 
click on the link that is the right one for your  
16:38 - machine. Mine's a 64 bit Windows, so I need the 
installer. For that, I would click this here. And  
16:43 - that will download the installer. When downloaded, 
open up the installer and follow along with the  
16:48 - easy step by step guide. And that will get gets 
on your machine. Okay, so now that you've got  
16:53 - get this open up VS code in the correct directory, 
or in your directory that you want this to be,  
16:59 - I want mine to be in my course directory, 
click here. This is an easy way of opening  
17:04 - an instance of VS code without opening 
and then scrolling and trying to navigate,  
17:10 - type CMD. When your command prompt opens, just put 
code space period and that will open an instance  
17:17 - of VS code in your development directory. So 
now we need to clone down so open a terminal  
17:25 - from a drop down, open up Git 
Bash. Now you'll only have this  
17:29 - option if you've got git on your machine. So 
that's why it's important. You've got Git. Okay,  
17:33 - so now we want to use the command git clone. And 
then after that, we need to dump in there the URL  
17:38 - of the repository. So in GitHub, the 
repository that you want to look for  
17:44 - is github.com/bobby-d, coding slash Python course 
for beginners, this is a public repository,  
17:51 - and all of the documentation is in there. Okay, 
so we've got all of these different Python files.  
17:58 - So click code and the main branch and 
copied this code here, open up VS code,  
18:06 - dump it in there, space, full stop, and 
that will clone down a repository into  
18:12 - your directory. It's asking me for a 
passcode. Because I've got an S H. SSH key.  
18:24 - There we have it. Okay, so you probably won't get 
asked for a passphrase. And no bother. So this is  
18:31 - the supporting documentation. So there's open up 
one of the first ones we'll be looking at numbers.  
18:38 - So numbers dot p y, this is the first thing 
we'll be looking at. These other supporting  
18:43 - documentation, use these as cheat sheets. So at 
the end of this course, you can always refer back  
18:49 - to these files, make your own notes, it's really, 
really helpful. I do use cheap seats, there are  
18:55 - some certain things that I might not necessarily 
use on a daily or weekly basis, I just need a  
19:01 - refresher. So that would be my advice, save these 
on your machine and keep referring back to them.  
19:08 - So that is the end of this video. Hopefully now 
we'll be ready to start really jumping into this  
19:14 - course, and start looking at Python code itself. 
And we'll be signed with numbers. So thanks for  
19:20 - watching. I've enjoyed making this video. I'll 
see you in the next video. Thank you bye bye  
19:33 - so I've got VS code opened up on my screen here 
in the file called numbers dot p y. There are a  
19:40 - few of these files in the supporting documentation 
that we cloned down from GitHub in the last video,  
19:43 - but we're looking at numbers. So we're close 
the Explorer because I want to use as much  
19:47 - real estate as possible. You see here I've got 
a terminal with the interpreter up and running.  
19:53 - Okay, that's what these great symbols 
mean. You do that simply by if we put exit  
20:00 - Hello myself though a little bit in their 
terminal or command prompt, just put p y,  
20:04 - if you're on Windows, and there you 
go, there's the interpreter. But we'll  
20:08 - be using the interpreter to take an input and 
return an output. So the input will be a sum,  
20:11 - the output will be the result. That's what we're 
doing. We're using it as a calculator. In Python,  
20:16 - we have a whole bunch of operators that we can 
tap into. Let's make a bit bigger. We've got  
20:24 - the symbols, that's the operator and what it 
does the description here, okay, so we've got  
20:28 - pluses addition, subtraction, multiplication, 
nice and easy, right basic stuff, division.  
20:33 - Now that will always return a float, which is a 
number type, we'll talk about that in a second. So  
20:40 - 10 divided by four be 2.5. Floor division 
is the same but returns the integer version,  
20:46 - so four divided, so 10 divided by four would be 
two, so 2.5, remove the decimal and a five is two.  
20:54 - So less floor division modulus is the remainder 
of 10 divided by four, which would be two, so  
21:02 - that's the remainder. So four goes into 10 twice, 
the remainder is two, so four plus four is eight.  
21:08 - The remainder is two, as modulus, then you've 
got power of so star star is if you put a five  
21:16 - star star two would be five to the power 
of two. So five, times five, five star star  
21:22 - three would be five times five times five, 
which would be one to five. That's power of  
21:28 - you've then got assignment operators got equals, 
okay, yeah, there are other ones we've got equals  
21:34 - equals got equals great and, and so on and so 
forth. Now, if you go to pythons doc page, if you  
21:42 - look up here, we've got Doc's dot org slash three 
slash tutorial slash introduction to HTML, that  
21:48 - is pythons documentation, to an introduction 
to numbers. I've extrapolated everything I  
21:54 - feel is basic stuff, you can do a deeper dive 
on their docks, please feel free. This course  
22:00 - has been designed around that documentation. So 
I wanted to give you the very, very basics, okay.  
22:07 - Okay, so got number types. But integers, we've 
got floats, integers are whole numbers. Floats are  
22:15 - numbers with decimal places. Okay, you've then got 
fractions. But again, this is a beginners class.  
22:20 - Okay, so look at INTZ and floats. Today, you got 
some built in functions we're using round today.  
22:26 - So if we were to use round 
function on this number here,  
22:31 - you could pass through a number and then 
pass through the amount of decimal places  
22:36 - you want. And it will, it would return the rounded 
version. So for instance, if I pass 5.6667 data,  
22:44 - there are three to this function here, as the 
number change decimals to two, that would return  
22:51 - 5.67. Okay, we use in dev mode, we're also going 
to use what else power. So these are a couple of  
22:59 - other functions that we've got here that are 
built in to numbers, really, really helpful.  
23:04 - dev mode returns a tuple of the result of the 
floor division, and modulus. So dev mod 10,  
23:12 - four would return to two. We'll look at that in 
a second. Lastly, before we jump into actually  
23:18 - throwing in inputs and getting outputs, Python is 
a really handy way of representing large integers.  
23:23 - So 4 billion, which looks a bit hard to read, can 
be represented as this for underscore three zeros,  
23:32 - underscore three zeros underscore three zeros, 
I think is a really handy way of representing  
23:36 - large numbers, especially if your code in so 
Okay, let's look at some of these basics here.  
23:44 - And we will dump them straight into the 
interpreter. So anything that comes after a hash  
23:49 - is a comment and the interpreter knows to ignore 
it. Okay, the comment is for you. Excuse me. So  
23:57 - two plus two simple addition is four, five minus 
two is three, seven times 10 is 70. Simple stuff,  
24:04 - right? All we're using is the interpreter as a 
calculator, then you got division, so 10 over  
24:10 - four would be 2.5. Okay, which is a float 2.5 flow 
mod is the same calculation, but rather than 2.5,  
24:19 - it would be two because it would disregard the 
decimal place and 510. Modulus four would be two.  
24:28 - Okay, and then div mod would be two and two. 
Because it's this sum, this sum of 10 and four,  
24:36 - they show you what I mean. Go in here, 
right click, press enter. Fine. Now.  
24:44 - It's a bit hard when you zoom so far in 
when you're doing a screen share too.  
24:50 - Show you what we're doing here, right so 
10 over four is 2.5 10 divided by four  
24:54 - 2.5 10 floor division over four so 10 With flow 
division four, b two, because rather than 2.5,  
25:03 - you're removing the point five, that leaves to 
10. Modulus four is four goes into 10, twice,  
25:10 - whole, okay? That gives you eight 
and the remainder of that sum is two.  
25:14 - That's why it's two in dev mode, which is a built 
in function is doing floor division, and then  
25:20 - modulus. So 10, we possibly 1014 is essentially 
doing two calculations, two, and two. Brilliant.  
25:29 - Again, you can spend as much time as you 
like adding these into your own interpreter,  
25:33 - you can always add other sums to give you a 
much better rounded knowledge of numbers in  
25:39 - your own time. But there's a kind of a simple 
walkthrough for you as a beginner. Okay,  
25:43 - I now copy this, these are fancy some, so think 
of BOD mass when you're looking at these sums.  
25:48 - So brackets are the division, multiplication, 
addition, subtraction in that order.  
25:53 - And what will happen is, oh, let's copy 
this copy, there we go. So it will do this  
26:03 - part first, because that is the multiplication. 
So five times six is 3050 minus 30, is 20.  
26:10 - It will do this first because the brackets, and 
I will do this inside the brackets first, because  
26:14 - there's multiplication. So it's 50 minus 30, is 
2020 divided by four is five, which is division,  
26:21 - so it would turn a float, then you got five 
times three plus two, so 15 plus 270. Okay.  
26:31 - I say five fancy, some sums can get a lot more 
fancy than that, then you have five power of two,  
26:37 - which would be 25. And I did say earlier, five, 
multiple power of three would be one to five,  
26:43 - which is correct. So two to the power of 
seven is one to eight, if I remember rightly,  
26:50 - that was more than that, oh is one to eight. But 
you can also use a built in function called pal,  
26:56 - which saves the use of the star star, 
I don't know what's easier to read,  
27:00 - but two to the power of seven, 
returns the same as one to eight,  
27:04 - then variables. So it's not really numbers, but 
you can assign anything to a variable. And today,  
27:10 - we were assigning numbers to one. So 60 is 
assigned to the variable width, we're using  
27:16 - that assignment operator, height equals 21, 
three times seven. So width multiplied by height,  
27:26 - I think is 12801260. There you go. I was tinkering 
with this earlier. So rather than doing 60,  
27:37 - times by three times seven, 
which is essentially the sum,  
27:40 - you're assigning the numbers to a variable, and 
you're using the variables to do the sum itself.  
27:46 - Okay, which is all fun. And lastly, before 
I close off this video, let's look at this.  
27:51 - So in interactive mode in the interpreter, the 
last printed expression, which is really handy,  
27:55 - gets saved to an automatically saved to a 
variable underscore, so you don't need to assign  
28:01 - it at all it knows to assign it to an underscore 
variable. So we bought this into the interpreter.  
28:14 - Okay, price times tax has now automatically 
been assigned to underscore, okay.  
28:21 - So if I can, if I now do price plus underscore  
28:26 - hope it's just type it in RBZ. There you go. 
So price plus underscore is one, one 3.0 65.  
28:34 - Now that expression has been saved to the 
variable underscore, so you see how they've  
28:38 - gone underscores and consistent every expression 
on the last one is assigned to it. Okay.  
28:45 - Now, if I use round, it's not liking it. So I 
type it, round, underscore, comma to remember  
28:53 - that function we looked at earlier. There we go. 
Round underscore, underscore is one one 3.0 65  
29:01 - decimal places to says One, one 3.06. Okay, so 
this is my whistlestop tour of numbers. Okay,  
29:11 - there's a lot more to learn. There's fractions. 
There's all of the different operators,  
29:15 - you can do really, really fancy sums using 
numbers. Please look at the documentation on  
29:20 - Python. There's no better place to learn numbers 
than Python numbers page. There's like I say this  
29:27 - is just all for beginners. So keep the supporting 
documentation add more notes as you find something  
29:32 - else that is interesting. But that is the 
end of this video. Thanks for watching, have  
29:36 - enjoyed making it and I'll see you in the next 
video which will all be about strings. Bye bye.  
29:50 - So again, I've got a VS code instance open on my 
screen here in settings dot p y, which is one of  
29:55 - the files we downloaded or cloned from GitHub. We 
look in the Explorer here. You can see there's a  
30:00 - whole bunch of other files, but we're looking at 
strings today. So Python can be used to manipulate  
30:06 - strings, which can be expressed in a few different 
ways. They can be enclosed in single quotes or  
30:12 - double quotes. So it doesn't matter, it is still 
a string, if expressed in one or the other way.  
30:18 - Now, a backslash is used to escape out 
of a string, or a quote should I say,  
30:24 - and that's really helpful. And one of the 
examples that I've got in a moment or two,  
30:28 - because there's certain words that use this A and 
apostrophe, and if you're using single quotes,  
30:33 - then you can imagine that you're in a whole spot 
of bother with that string unless you escape out.  
30:38 - Okay? So Python strings cannot be 
changed, they aren't immutable. So  
30:42 - you cannot isolate a character in a string 
and replace it with something else. Okay,  
30:46 - you have to create a new string 
altogether, which is completely possible,  
30:50 - we'll be looking at a built in function called 
Len in this video. Now Lenny's really helpful,  
30:55 - you can use it on strings, lists, dictionaries, 
tuple sets, and it returns the number of items  
31:01 - or characters in any one of those objects. 
Really helpful with strings. So if we called Len  
31:07 - on my name, which is Bobby, it will return five 
because Bobby has got five characters in it.  
31:11 - Okay? strings have a whole bunch of methods. 
Now these are really, really helpful. Okay,  
31:16 - so I've listed out all of the different 
methods that you can use on a string.  
31:19 - So for instance, capitalized there, you've got a 
bit of space. So if I put bA, bB y as a string,  
31:29 - capitalize would return Bobby, okay, as a string, 
really helpful method to use. And you've got a  
31:38 - whole bunch of other stuff here as well, you've 
got case fold sent accounting code. Where else  
31:43 - other examples so that he got right at the 
bottom that you got apart. So that would just be  
31:50 - Bobby would return. Bobby is all uppercase, okay. 
So really helpful methods when managing strings,  
31:59 - you'll be using them a lot. Okay, you now need to 
open up a terminal and open up a interpreter. So I  
32:07 - mean windows at p y. I've got my three Greatland 
symbols there. So it's ready for an input.  
32:13 - So I've got a few examples here that if I bought 
them straight into the interpreter, we can see  
32:18 - what's actually going on here. Okay, so the top 
here, we've got sperm and eggs in single quotes,  
32:25 - as an input, so the output is a string, span x 
doesn't has an apostrophe, okay, so single quotes,  
32:34 - single quotes, because we need to use a single 
quote in the string, you need to escape out using  
32:39 - backslash, and it converts the single quotes or 
double quotes, and then you return your output  
32:44 - is doesn't have double quotes, really helpful 
understanding the backslash. Or you could just  
32:49 - write that string as double quotes, and you won't 
have any problem whatsoever. Now in this example,  
32:54 - we've got double quotes in the string itself 
that haven't been escaped out. So of course,  
32:57 - what gets returned is that whole string, the 
double quotes within the string are characters.  
33:04 - way you can escape out and use the double quotes.  
33:08 - In the string itself, sorry, would be 
to use the escape and it changed the  
33:12 - double quotes to single quotes. That is pretty 
much the polar opposite of the dozen example.  
33:18 - So if we had single quotes, we use an apostrophe 
in that example, we use in double quotes. And  
33:22 - actually, we want to use double quotes in the 
string. And in which case, you need the escape,  
33:26 - backslash, okay. If you look at the documentation 
on Python, if you look in 3.1, point two, on  
33:34 - docs.python.org/three/tutorial/introduction, 
that is their intro to strings, do a deeper  
33:41 - dive in there, I've extrapolated out a whole 
bunch of stuff. Hopefully, that is just the  
33:46 - basics that I've got in my video here. Okay, 
so next, we've got new lines. So new line is  
33:54 - represented in Python with backslash n, okay, and 
it will just use the interpreter, it comes out as  
34:01 - a single string, it just ignores the new line. But 
if you print it from a variable, it will pick up  
34:06 - that new line and print it as first line second 
line in this example. So if I use this copy,  
34:17 - puppet in there, so we're saving first line, 
new line, second line into an S variable,  
34:23 - we just return s, it just prints out the return 
statement, it doesn't do anything. But if we use  
34:28 - the print statement, and pass through S, then it 
picks up that new line. First line, second line,  
34:34 - that's really, really helpful when you're trying 
to format certain strings to a user maybe in an  
34:40 - API message, something like that. Right. 
Next, we've got raw strings. So we can use  
34:49 - our for regular expression to print out raw 
strings because you can imagine a path here  
34:53 - we'll have backslashes. And this example is a 
great one because it got a backslash n. So if  
34:58 - we were to print that it's just going to Come 
out something silly, because we know backslash  
35:02 - n is new line in a print statement. But 
if we use our as a regular expression,  
35:09 - you can see that we see see some name has been 
done, see slash some, and then it's printed out  
35:14 - this. But if we use reg x, then it's absolutely 
fine. Okay, string literals. So you can use three  
35:22 - quotes, whether it be single or doubles. And that 
will print out everything under that. So it's sort  
35:28 - of like a comment. So a comment is a hash, but 
it's a single line, string literal can can span  
35:33 - numerous lines. And I've done that at the top of 
the page here for my description, okay, so that's  
35:38 - what a string literal is. Copy that, dump it in 
here, that will print out exactly as you want it  
35:46 - to be. Okay, then you got concatenated, basically 
glued together. So if we use the number three,  
35:55 - multiplied by UN that would basically do un un 
un. And then the plus symbol, the operator in  
36:01 - this case is concatenate. Now, glue, un un un with 
our UN. So that should bring that in there. There  
36:12 - you go. You don't even need to use the operator 
plus, if it's two strings put together like that  
36:17 - Python knows what you're trying to do. And it 
will actually join it together. The coding really  
36:22 - helpful stuff. But that's really helpful when 
your strings in a text or parentheses there,  
36:29 - span more than one line. Python knows what you're 
doing. And it will just join those together. Okay.  
36:37 - So this only works for two literals though, not 
variables or expressions, so we're gonna have an  
36:44 - error here, try and dump this in here. Okay, so 
it's basically because we've got a variable and  
36:50 - a string, whereas what you need is two strings. So 
prefix equals dead, and then you got prefix with  
36:57 - that, we then need to use the operator and then 
it will work just nicely, okay, so the removing  
37:02 - the operator will only work for us in two strings. 
That's what I'm trying to put there. In indexing.  
37:09 - So strings, so I keep hitting my mouse bonds 
really annoying. indexing. So we need to  
37:15 - understand indexing for things like strings and 
lists, okay. And I love this, I took it straight  
37:21 - from the Python website. But an index allows us 
to play with certain characters in string based  
37:27 - on where that character is in the string by 
index. So the first point in a string is zero.  
37:34 - And the last point is, in this case, eight or 
minus one, so you can reference the string from  
37:38 - the front. So not one, two, or you can reference 
it from the back minus one minus two minus three.  
37:46 - So when we're working with a word such as 
dead coding, if we go word, square bracket,  
37:52 - zero, we're referencing the first index 
of the word dead code in which would be D.  
37:59 - Okay, let's dump all of these in my 
interpreter and see ya spits out okay?  
38:11 - So, so Right, so the word is 
decoding. So word index zero,  
38:15 - that's the first as per this 
diagram at the top here. 012. Okay.  
38:23 - Word five would be always printing out little D, 
so it's not 12345. So it's D, okay, so you can  
38:31 - see that that's working, you can reference so if 
you put zero colon, two, that will be include an  
38:39 - exclude, so it's include 01 and exclude two, which 
is Di, include 234, but exclude five. That's what  
38:49 - that means. Okay? So be DCO. If you missed the 
first integer, in this expression, it assumes you  
38:57 - mean zero. So that'll be 01 exclude two, which is 
Di, if you move, if you ignore the last integer,  
39:04 - it assumes you mean the very last but that's 
a minus one. Okay? So that will be everything  
39:10 - from four to the end. And then we've got 
some other examples there. Okay. So we've  
39:16 - got minus four, so we're referencing minus one 
minus two to the end, which would be Engie.  
39:25 - There we go. N G. And then you got you can 
bring these two together so you can join them  
39:29 - together. So is everything up until but excluding 
to and everything from to everything to the end,  
39:35 - you joined into it brings together decoded, 
and then again, you've got another one here,  
39:39 - which is an example of bringing 
that together. Okay. So that's  
39:44 - indexing is really really really helpful. So 
changing strings. So if we wanted to change  
39:52 - so referencing the D, but assigning p it 
says none and and and I type error string  
39:56 - object does not support item assignment 
is immutable. So, if what we do is  
40:05 - have the string p plus word which will be 
including the first. So this will be everything  
40:11 - from O onwards, that will work and we'll change it 
to peer decoding. Or equally, we can do this. The  
40:20 - ID, di, di, di, okay, so we are just manipulating 
strings. That's what we're trying to do and  
40:26 - demonstrate in this video. Okay, we use a lens. So 
if we look at Bobby decoding, which is the GitHub  
40:33 - username, it's got 15 characters 
in that using the len function  
40:37 - really, really helpful function, 
you'll be using that quite a lot.  
40:41 - Handy built in functions. So when you don't need 
fancy outputs, but just want a quick display of  
40:46 - some variables. for debugging purposes, you 
can convert any value to a string with the  
40:52 - wrapper, or the SDR functions. So here's a list of 
just some handy little functions that you can you  
40:58 - can use, okay, and here are some examples of what 
you can do. So x, y, y 400, what you can do is  
41:07 - dump them in here. And that will just give you a 
really handy representation of what you're trying  
41:12 - to achieve. Same with str, it will just change 
everything to a string. Okay. And then you've got  
41:25 - which, there we go. So let's give those examples 
there. So we've got format, okay, so this,  
41:31 - there's a bit of an explained explanation here. 
In python three, you can use the F string, which  
41:35 - is F followed by two quotes. And then you can 
use placeholders placeholders to add variables.  
41:42 - But you can also use format, which is valid for 
Python two, and three. And what we're doing here  
41:47 - is we're doing a print statement, we're adding 
placeholders. That's what these squiggly brackets  
41:50 - are. So it's placeholder and placeholder, and 
then dot format, which is the method and it goes  
41:58 - in order. So the span will be injected into this 
placeholder and eggs will be in that placeholder.  
42:04 - And equally, in a second example here, we're just 
changing them around. So nor is the first item one  
42:10 - is the second item in this tuple. And that would 
just change it around eggs and spam. Okay, so  
42:19 - that's my whistlestop tour of strings, there 
is more to go in and do a deeper dive on  
42:24 - Python's website here. But do that in your 
own time, do a bit of bedtime reading. Okay.  
42:29 - But that is the end of this video. I'm 
glad that I put it together. Hope you've  
42:34 - enjoyed it. And I'll be seeing you 
in the next video. Thank you, bye.  
42:46 - Okay, like always, I've got Visual 
Studio Code open on my screen  
42:50 - in the list.pi file. So this is just one 
of the pages in my supporting documentation  
42:55 - that we cloned out from GitHub a couple of 
videos ago, we don't need the Explorer open,  
42:59 - we want as much real estate on the screen 
here as possible. So we'll be manipulating  
43:03 - lists today. A list is a datatype. So 
there's four different data types that  
43:09 - Python knows of lists, dictionaries, sets, and 
tuples. I'm going to do a video on each so I don't  
43:15 - need to explain that explain the difference 
in them, except for lists are written as a  
43:21 - list of comma separated values or items between 
square brackets. Okay, so a list will look like  
43:30 - this, okay? That would be considered a list in 
Python, okay? Now, lists are mutable. So, unlike  
43:39 - strings are immutable and tuples are immutable. 
A list is mutable, you can change and alter  
43:45 - the items in lists. So you can identify a certain 
item, and you can replace it with something else.  
43:51 - Okay? So they're mutable, which 
is really, really helpful.  
43:56 - I have also added on all of these pages, if 
there's any methods that are associated to  
44:01 - a particular let's say, data type, or let's say 
numbers of strings, or anything, I've listed those  
44:05 - methods in the files themselves. So lists have got 
methods such as append, which allows you to add an  
44:11 - element to the end of the list, you've got count, 
extend in next reverse sort, so on and so forth.  
44:17 - When you have a bit more time outside of this 
video, just have a tinker with lists and just  
44:21 - play with these methods. They're really, really, 
really, really helpful. Okay, so into the basics,  
44:26 - we will need a terminal open and we will need 
a Python interpreter interact Interactive Mode.  
44:32 - Okay, we've done that 100 times in this course 
already. So all you need to do is fire up three  
44:37 - greater than symbols shows me that it's ready 
for an input. So this is a basic list and we're,  
44:42 - we're assigning that to a variable called squares. 
Okay, so dump that in here. And now we can access  
44:51 - squares by just doing that and it will 
just print out in the interpreter,  
44:55 - the list okay. So that is a list in Python. Okay, 
we've then got it scroll down indices. So this is  
45:03 - exactly the same as we went through in the string. 
I haven't changed this to a list. But essentially  
45:09 - imagine that this is a list, you can change these 
two square brackets if you like. But essentially,  
45:17 - each item in a list, you can reference by its 
index. So in this case, this is zero, this is one,  
45:24 - this is two, this is three, and this is four in 
the same way as in the string, you've got 0123,  
45:30 - and four, you can reference it from left to 
right, not 123, and four, you can reference it  
45:35 - right to left, which would be minus 12345. Okay, 
same as string. But understanding indexing is  
45:42 - paramount in Python is really, really helpful. 
So if we put squares zero, it would turn one,  
45:48 - squares minus one would return 25 minus 
three. So slicing, when you use a colon,  
45:55 - that syntax means include everything from minus 
three, having a missing integer means to the end,  
46:02 - or assumes you mean to the end. So minus three 
b naught 123. So it would return all of that.  
46:08 - Okay, so if we copy all of this, 
we bump that in here. There you go.  
46:19 - There we are, right. Okay. So creating a list 
copy, this is quite handy, sometimes just  
46:25 - open bracket, close bracket with a colon in the 
middle, now do an outright copy of the list, you  
46:30 - can assign that to a variable, and then you can 
change that copy as much as you like, it doesn't  
46:35 - affect the original. It's a handy way of creating 
a copy. concatenation. So saying the strings,  
46:43 - you can glue things together, you can glue strings 
together, you can glue lists together. Okay, so  
46:49 - if we take the variable squares, we can glue 
a second list to it, and then what you've got  
46:57 - is a much bigger list. Oh, sorry. So I Okay, 
let's go. Squares underscore two equals,  
47:07 - and then we'll dump that in there. If we 
then put squares underscore to There you go.  
47:14 - Oh, my typing fantastic. So squares remains the 
same, because we didn't assign to a variable,  
47:21 - then I did sign it to a variable called 
squares to, and this then becomes this. Okay,  
47:27 - so that's concatenation, that is essentially 
gluing two lists together, which again, is really,  
47:32 - really helpful. Right, you can alter items. So 
unlike strings, where you can index the character,  
47:39 - but you can't change it in a list, you can so I 
can find one bytes index, I can then replace it.  
47:44 - So in cubes, you can see we've got one 827 65. 
That's incorrect. Okay, that should be 64. So  
47:52 - three to the power, so four to the power of three 
equals 64. So we need to reference this by index,  
47:59 - which in this case is indexed three, so 
it's not not 123. Or you can go minus two.  
48:05 - So that could just be minus two is the 
same way, you're just referencing it  
48:09 - from a different direction. And you can 
then put equals 64. So you're referencing  
48:15 - the item in the list and replacing it with a 
new number. And then we'll print cubes again.  
48:23 - Okay, so now the new list is 1-820-760-4125. So 
it's mutable, you can change the items by indexing  
48:32 - them, and then assigning them with the operator 
equals. And as the same way, as we do it in  
48:39 - dictionaries, actually, you reference the 
key using this method with the key name,  
48:44 - and then we use equals to assign a value. 
Okay, so it's the same as in dictionaries,  
48:50 - list methods, so we've got a pen so accused, 
we can append to one six, just do that. Hmm.  
48:59 - We use a pen to do an operate of seven to 
the power of three. And then if we put cubes,  
49:06 - you can see that list has just grown by 
two because we've appended to one, six,  
49:10 - and then 343. Okay, so we use an a method, 
append, adds an element to the end of the list,  
49:16 - this is your cheat sheet, you'll be referencing 
this page a lot in the near future. So keep adding  
49:21 - to it. If you find other methods are really 
helpful, just keep adding to this cheat sheet  
49:25 - and save it and you've got it as reference point 
in the future. So length, we look this in lists  
49:30 - is sorry, in strings, it just returns the amount 
of characters or in this case by items in a list.  
49:35 - So that should return four because I've got 123 
and four. Okay, four, really, really helpful.  
49:42 - Then you've got nesting. So nesting, we've got one 
list ABC and D. We've got another 112 and three,  
49:50 - we assigned both of them within another list to 
a variable X. X is a list that contains lists.  
49:58 - Show you what I mean. Okay, so you got 
square brackets that contain one list  
50:06 - and a second list. Hopefully that makes sense. 
So to get this list from its parent list,  
50:13 - you reference x with index zero, because 
this is index zero, this is index one.  
50:20 - So x zero will return the first 
list. So then if we want to get  
50:28 - B from this list, it would be x zero, and 
then index one. So we're grabbing that list  
50:34 - from that list, we're then grabbing be by that 
integer. And that's what we're doing here.  
50:38 - So spend some time understanding that it's 
really, really useful with lists, but especially  
50:45 - with dictionaries, as well, because you might be 
working with dictionaries, or Jason. And in which  
50:49 - case, you're referencing keyword after keyword 
after keyword just to access different values,  
50:55 - especially with API calls and things like that. 
So it's really, really helpful to understand that.  
51:00 - list comprehension. Now, this is a little bit 
more advanced than what I would normally put in  
51:04 - one of these kinds of courses. But because we're 
using a control flow, so we're using a for loop.  
51:11 - So list comprehension allows us to write this 
piece of code here in one line, essentially.  
51:19 - So I'll just gloss over it quickly. So don't 
worry about this, we'll go through control  
51:25 - flows in another video. But using this piece of 
code, we're creating a list, I won't go through  
51:31 - the ins and outs of what we're actually doing and 
how we're looping through. But we're creating this  
51:34 - list here. Okay. By using this one line of code, 
which is called list comprehension, you don't  
51:40 - need to use multiple lines of code to create that 
same list, you can just go with one line. And lo  
51:46 - and behold, it creates exactly the same list, but 
with a much easier syntax. Okay, we'll go through  
51:54 - loops a little bit later. But list comprehension 
is massively powerful. So please read up on it.  
52:01 - If you go to Python docs on this page, which is 
docs.python.org/three/tutorial/introduction. It  
52:09 - gives you a rundown of numbers, strings and lists. 
If you scroll down to the bottom near enough to  
52:16 - the bottom here, we've got Where Are We There we 
go. 3.1 point three lists. So it goes into great  
52:22 - detail there. And if you do a deeper dive into 
Python docs, you've got a lot more to read about  
52:27 - this comprehension. Okay, so, go back in Visual 
Studio Code, we've then got the final bit of this  
52:35 - video, which is built in function, which is called 
list. So this function will convert. In this case,  
52:42 - it's a tuple into a list. So it just takes one 
object and it converts it or tries to convey  
52:48 - into a list if it can. So this is just a tuple. 
And a tuple is defined similar to a list but  
52:52 - instead of square brackets, it uses just standard 
parentheses. This function is converting that into  
52:59 - a list. So we'll change that to square brackets. 
Okay, so there we go. bobby@decoding.com.  
53:07 - Okay, so that's my whistlestop tour of lists. 
Like I said, this is geared towards beginners,  
53:15 - you've got supporting documentation. This is your 
cheat sheet that you've got on your screen here,  
53:20 - read up on lists, play with lists and add to 
this cheat sheet as and when you find something  
53:25 - interesting, you can keep referring back to 
this as long as you want 2345 years down the  
53:31 - line in your career, and you may find something 
useful. Okay. So that marks the end of this video.  
53:38 - Thanks for watching. I've enjoyed putting it 
together. I'll see you in the next video. Bye bye.  
53:50 - Okay, so we're looking at tables today. This 
is my Visual Studio Code instance opened up  
53:54 - in a tuples.py file that is contained within the 
supporting documentation that you can clone down  
53:59 - from GitHub. Okay, there's loads of files in here. 
The structure of this course is that I will just  
54:05 - walk you through and talk a little bit about 
tuples from this form, because there's a kind  
54:08 - of a cheat sheet, if you like for you to use. 
And we'll give you a rundown of what a tuple  
54:13 - is. And then we'll give you some examples of 
codes, we can actually start understanding  
54:18 - how to work with tuples. So Python knows of 
for compound data types, lists, tuples, sets,  
54:26 - and dictionaries. Okay, on the documentation, 
it talks about lists that Tutorial for Beginners  
54:30 - documentation, but they don't really talk too 
much about sets, dictionaries and tuples. So I  
54:35 - thought I'd put three videos together to help you 
out. And also put the documentation together so  
54:39 - you can reference it. Okay, so tuples are written 
as a list of common separate items surrounded by  
54:44 - parentheses or brackets, and like list, which is 
square brackets, okay? Now, tuples are immutable,  
54:50 - which sets it very, very, very much aside from 
lists that are that are immutable, okay, so you  
54:55 - can't assign items to a tuple where you can Hang 
in a list. Okay, so that's an important difference  
55:03 - between the two tuples have two methods available, 
they've got the count method and an index method.  
55:08 - So you have a tuple dot count will return the 
number of elements with a specified value. And  
55:14 - tuple dot index parentheses returns an index 
of the first element with a specified value.  
55:20 - Okay, there the two methods that we have on 
tuples. Okay, so let's jump straight into a few  
55:27 - code examples. Open up a terminal and fire up 
an interpreter. And what the first line here  
55:34 - is an example of what's called tuple. Packing. We 
will also talk about unpacking of a tuple in a few  
55:40 - moments time. So what we're saying here is t to 
the variable with an assignment operator equals,  
55:46 - and we got three items. So we've got 
an integer, an integer and a string.  
55:50 - We're saying here that we want to assign or pack 
these items to a tuple named T, because that's  
55:57 - the equivalent this expression is the equivalent 
of doing this. Okay, we don't need those  
56:02 - parentheses to do it, because it's a tuple. So we 
can then access the first item by index of zero.  
56:10 - If you don't know much about indexing, 
I'll talk about that in a few moments time,  
56:14 - and then we'll just print it out in the terminal 
in the interpreter. Okay, so T three items,  
56:22 - referencing the first index, which 
is this one here, if we then put t,  
56:27 - one would get the second item in the table. 
But you can see here just by printing T,  
56:34 - that again, that shows you that you don't 
need the parentheses to pack a tuple. Okay.  
56:41 - Tuples can be nested. Okay, so here we've 
got use or assigning t, which is a tuple,  
56:46 - we've got a trailing comma, and then got a fault. 
We've got another tuple here, where essentially  
56:54 - using the package of a tuple to create a one tuple 
with nested tuples. That's really what we're doing  
57:00 - here. So if we put U equals T, trailing comma 
tuple, and then put you you can see we've got  
57:06 - the open parentheses here is the first tuple. And 
then we've got one item, we've got another way,  
57:13 - okay, you can't assign to a tuple, or come up an 
error type error. tuple object does not support  
57:21 - item assignment. Okay, that's a demonstration 
of a tuple that is immutable. You cannot  
57:27 - assign values to items in a tuple, where you 
can in a list and a dictionary and set. So  
57:36 - they can contain mutable objects, however, 
so let's create another variable with V. And  
57:43 - here we put V, you got a tuple with 
two lists in it. So we can now go V  
57:47 - first as we the first list, and then 
we can say first index, that'd be one  
57:55 - equals two. Okay, if we now put v 223. So although 
the tuple itself is immutable, the lists that are  
58:05 - mutable that are within the tuple can be altered, 
you can assign values to items in the list. Okay,  
58:12 - so that's the example I've got there, you can see 
that we looked at the first zero index zero index,  
58:18 - which which this here is the one. So this becomes 
the zero index of the tuple. And that is the zero  
58:24 - index of the list. And we're equals using 
the assignment operator to. So that's why  
58:33 - this comes to 23321. Okay, indexing, I've talked 
about this in previous videos, but I love this,  
58:40 - it's really, really helpful. It just shows that if 
you're referencing a string, or list or a tuple,  
58:44 - from left to right, then the first item in the 
list or a tuple of string or so on and so forth,  
58:49 - is zero. Second one is 123, all the way up, so 
it's going from left to right, if you reference  
58:54 - it from right to left, then it's minus one minus 
two minus three minus four. So you have options of  
59:00 - actually identifying certain counters or items in 
objects by that index really, really helpful. So  
59:06 - we can get the zero index of t, which we know is 
12345, we can get the last index of t minus one,  
59:17 - but we know there's only three 
items in a tuple. So we can also  
59:20 - reference the last item with two because two is 
also the same index in this instance as minus one.  
59:27 - Okay, that makes sense. Trailing 
comma. Okay, let's get this example in  
59:33 - here. So we're creating a variable with an empty 
tuple called empty. And then we're creating.  
59:41 - That's I had a test in the last time I did 
this. Let's do that again. do apologize. Okay,  
59:51 - so an empty variable. So empty becomes a variable 
that contains a tuple, which is empty itself.  
59:57 - Singleton has just one string with a tray then 
comma, that's how Singleton is going to be created  
60:04 - as a tuple. That's how we know we do it, you only 
need a trailing comma when a tuple contains one  
60:09 - item. So we then use the len function to 
calculate the length of empty, and we know  
60:15 - that there's nothing and then so it expected to be 
zero. Singleton has one. So if we print Singleton,  
60:20 - it says hello with a trailing comma. Okay. There 
we have it. And we then got unpacking of a tuple.  
60:28 - So at the start, we said t equals and we had 
an integer, integer and a string, we can do  
60:33 - the opposite of that and create three variables, 
I do apologize, create three variable variables  
60:39 - and equals t. And what that does, it does the 
complete opposite. So it takes each item from a  
60:44 - tuple, when it signs it to its corresponding 
variable in order. So x becomes index 01,  
60:51 - and two, so we'll expect that to be 12345. So 
on and so forth. So let's go ahead and do that.  
61:00 - Copy. We don't need that. Okay, so is unpacked 
it. So x becomes 1-234-554-3212, y and ends,  
61:10 - it becomes Hello, that is called unpacking a tuple 
is really, really helpful when you're working with  
61:15 - tuples. And you'll see that in quite a lot in code 
examples. Then you've got built in functions. So  
61:20 - we've got tuple as a function, so tuple, open 
parentheses. And basically, in this example,  
61:27 - here, I've just got a list that contains a 
whole bunch of string. And when you add the  
61:30 - function tuple to it, it converts that list into a 
tuple. Okay, so although it starts off as a list,  
61:39 - by using the tuple function, it converts that 
list into a tuple. And now that is immutable,  
61:43 - okay, we can't assign anything 
to x. So if we went x one equals,  
61:52 - but it was a, you can't do it. Whereas beforehand, 
I would have been able to because it was a list.  
61:58 - Okay, then you've got tuple comprehension, 
which is very similar to list comprehension,  
62:02 - except you're, you're using the tuple 
function to convert that into a tuple, as  
62:09 - you know, is quite, it's just an example 
of how you can use the tuple function.  
62:14 - Okay, so that is it. So if I stick that in here, 
look, it's just an example. Okay, so just use  
62:22 - normal list comprehension and can use the tuple 
function to convert into a tuple. So I won't  
62:28 - go into great detail about what that's doing, 
because we're using the SX. It's an example of  
62:34 - a control flow, which is a for loop. And use list 
comprehension to change what could be five lines  
62:40 - of code into one easy to read line of code. That's 
the list comprehension for you, in a nutshell,  
62:44 - but we'll look at that a little bit later. It's 
kind of an advanced or intermediate kind of topic.  
62:48 - So let's not worry about that. So that is tuples. 
Thank you very much for watching this video.  
62:54 - And I'll see you in the next video, we'll start 
looking at sets. Okay, thank you. Bye bye.  
63:06 - Okay, so we're looking at sets today, you 
can see here I've got a VS code instance,  
63:10 - open in a file called sets dot p y, if you don't 
know where this is, or how to get hold of it,  
63:15 - then a few videos ago, we cloned down a supporting 
documentation repository for this course. So get  
63:21 - your hands on that. And you can follow along. But 
the structure of this course and these videos is  
63:26 - that I'm showing you and explaining what certain 
things are. And then we've got some code examples  
63:30 - to walk you through nice and easy. So let's talk 
about sets. Suppose the nodes of for compound  
63:36 - data types, which I'll keep repeating, because 
I said at the start of all of these videos,  
63:40 - and it's lists, dictionaries, tuples, and 
sets. Today, we're talking about sets.  
63:45 - You look at the documentation, they don't really 
talk too much about sets in a beginners tutorial.  
63:49 - So I thought I'd do a video just to walk, 
walk you through it and help you out. So sets,  
63:54 - they are an unordered collection with no duplicate 
elements, like a dictionary is set as defined with  
63:59 - curly brackets. So sets are really handy. They're 
kind of like lists, except a set cannot have  
64:07 - duplication. Okay, so at least you can have 
duplicate item after Jukai. All day long, not  
64:12 - a problem, where is a set? It cannot. It has to 
have unique items. So that's what's kind of where  
64:19 - it stands apart from lists. Now, I can talk about 
this in a future video perhaps. But when you use  
64:27 - the set function combined with lists is really, 
really helpful to look at all unique items within  
64:32 - a list and do a comparison and do some analytics. 
Really helpful stuff. So I use sets all the time.  
64:38 - Anyway, so a sets a set is mutable. It's like 
a list. A set is mutable, you can assign values  
64:45 - to items in a list, you can't in a tuple Okay, so 
that's important to understand. And also sets come  
64:50 - with a whole bunch of handy methods. Okay, so to 
add to add an element to a set, you've got clear  
64:55 - removes all elements from a set, so on and so 
forth. I'll let you read through those methods. In  
65:00 - your own time, but like quite a lot of objects and 
bits and pieces in Python, read up on the methods  
65:06 - because they can save you a hell of a lot of time. 
Because if you don't know of the methods, you will  
65:11 - try to code that in yourself. And you might use 
10 or 20 lines of code to do what essentially one  
65:16 - little snippet of code can do for you in seconds. 
Okay, so read up on those are really, really  
65:20 - helpful. So code this open up a terminal and 
fire up a Python interpreter. There we have it.  
65:29 - So all we doing is copying the code and dropping 
it in here. Okay. I'm hoping it's big enough for  
65:36 - you to read. Okay, so here we go. Basket equals, 
and then we've got curly brackets, curly brackets,  
65:42 - now when you're just glancing at code is easy 
to get confused with a set and a dictionary  
65:48 - because a dictionary has also curly brackets. 
But what is different in a set is that it's  
65:54 - just comma separated, whereas the dictionary has 
key value pairs, which are comma separated. Okay,  
66:00 - so looking at this, I know that this is a set, 
but you can see here we've got apple and Apple,  
66:09 - which is duplication. Okay, so if we were to 
then print basket, what it does, it prints  
66:16 - the variable without the duplication. 
Okay? Does that make sense? So although  
66:20 - we're assigning this set to the variable, 
Python in the background is taking that set,  
66:26 - and it's removing the duplication, okay, but there 
is some funky little ordering that they do, which  
66:31 - you then have to sort. But we won't 
come on to that in this tutorial.  
66:36 - But when you're tinkering with compound data 
types, you will find some weird and wacky  
66:40 - stuff that goes on. So you'd have to get quite 
creative. So we've then got orange in basket. So  
66:48 - fast membership testing. Okay, so we're saying 
does basket as a variable contain the string  
66:58 - orange, okay, which we know it does, because 
we're printed out here. So we've got orange.  
67:02 - So we're saying orange in basket, fast 
membership testing. Really, really helpful.  
67:11 - crabgrass says false, so it's just a Boolean, 
true, false, but really helpful to understand,  
67:16 - okay, and then you can demonstrate set set 
operations on unique letters from two words. Okay,  
67:21 - so we're using set as a built in function. 
So we've got a set. And we've got be set  
67:32 - to two variables. So I put a, no put B. Okay, you 
can see here that D, B, C, ra, so it's removed  
67:40 - the duplication of B, remove the duplication of A, 
and so on and so forth. So you can say, A minus B.  
67:52 - Okay, so we're now comparing sets against 
one another. And we're using these operators  
67:56 - here. So these are all of the different 
operators that we can use to compare.  
68:02 - These are called set operations. 
Okay, so we've got the bar.  
68:06 - So let us in all B, or both really helpful when 
comparing data in these compound data types,  
68:16 - letters in both A and B. So we use the ampersand 
symbol there. And then we're using this operator  
68:23 - to say let is in A or B, but not both, okay, 
that's what that operator means. Okay. So  
68:29 - there's always do research on sets. When you're 
looking at sets and lists and comparing it to and  
68:35 - doing some sort functions on them, it's really 
helpful to understand what we're doing here,  
68:39 - because you can actually get a lot of output 
with very little input by using these methods and  
68:45 - operators. Okay, so in your own time, have a 
good read up. But this is your cheat sheet. So  
68:49 - if you find something interesting on Python or 
a YouTube video, and add it in a cheat sheet,  
68:54 - you can always reference back I do all the time, 
by the way, then you're set set comprehension.  
69:00 - So in the last video, I just did list 
comprehension and use the, the tuple function,  
69:05 - but you can actually use squirrely brackets 
here just to go straight into set comprehension.  
69:11 - There we go. Got a There we go. So we're 
saying extract. So this is control flow.  
69:19 - So like I said in the previous two videos, so 
using comprehension is allows us to create a set  
69:25 - or list or tuple by doing a loop of a variable 
or another list or so on and so forth dictionary.  
69:34 - But you can do it in one single line of 
code. And it's much easier to read them,  
69:37 - let's say four or five lines in a for loop. Okay,  
69:40 - there's an example in my list video. And then 
you got a built in function. So we've got an set,  
69:45 - which we talked about a moment ago. So we've got 
Bobby Bobby at decoding comm creates a set object.  
69:53 - There we go. So again, the ordering is all 
squiffy, you know. Bobby bobby@decoding.com  
69:58 - I'm sure there's some logic as work comes 
out like this. But we've got COMM At  
70:02 - decoding dot Bobby. But essentially, it's done 
the work. So it's gone through that, in this  
70:06 - case tuple is converted it to a set and remove the 
duplication. So in a background of Python is doing  
70:12 - that work for you. Like I say, when you're coding 
hundreds and hundreds of lines of code, it's  
70:18 - so good that we can use these functions to really 
minimize what we're doing and get the same output,  
70:23 - low amount of input, the same amount of output, 
that is the key. And that marks the end of this  
70:28 - video. So thank you very much for watching. I'll 
enjoy putting it together. Join me in the next  
70:32 - video, we'll start looking at dictionaries. Thank 
you, bye. Okay, so we're looking at dictionaries  
70:44 - today. So I've got VS code open up on my screen, 
and it's in the dictionaries dot p y file in the  
70:49 - supporting docs for this course, please, please, 
please clone down from my GitHub repository.  
70:54 - If you do that, which we've gone through in 
all of the previous videos, you will have a  
70:58 - directory that looks like this. It's essentially a 
a directory tree of Python files that can be your  
71:04 - cheat sheet. So when you're learning Python always 
reference back to these really, really helpful.  
71:09 - Okay, so in dictionaries.pi, structure these 
videos is that I'm going to just talk about what  
71:13 - dictionaries are, give me some code examples, 
we'll fire up an interpreter and we just  
71:18 - put some code in and have a little blank. Okay, 
so like I said, in the last three videos, Python  
71:23 - knows of four different compound data types. Now 
we've got lists, tuples, sets, and dictionaries.  
71:28 - I love dictionaries. They're like a powerhouse. 
So you can store data really, really easily.  
71:34 - They're very similar, in a lot of ways to Jason. 
So you reference values by keys, and they're just  
71:41 - really, really helpful, you'll be using them a 
lot. So dictionaries are great for storing data  
71:46 - values. And it's an a key value pair. So I've got 
an example of a dictionary here, but we won't put  
71:50 - it in the interpreter because we'll be doing that 
in a second or two. But essentially, like a set,  
71:56 - a dictionary is referenced by curly brackets. But 
unlike a set, we have key value pairs separated by  
72:00 - colons. So we've got a key, which is a string in 
this instance, and we've got a value. So it's a  
72:07 - string, so it's a key value. And it's separated 
by a comma. So is he dictionary is a great in  
72:13 - TextEdit is when they're expressed in this way. 
So each key separated by a space and with some  
72:19 - whitespace here, and then you can have your value 
is much easier to read. So the second item here,  
72:23 - which got a key, and then you've got a key, 
this is a string, third one, we're actually  
72:27 - using a list as the value. And then the last one, 
we've got a dictionary as a value, okay? So you  
72:33 - don't just have to have strings, you can have 
lists, sets, dictionaries, you can use integers,  
72:37 - strings, whatever you whatever you like, as the 
value itself. Again, dictionaries are mutable,  
72:42 - this means that item values can be changed, 
which is important. Okay, we've then got this,  
72:48 - which I like, I've enjoyed putting these together, 
right? So lists, sets, tuples, and dictionaries  
72:53 - all have a bunch of methods we can tap into. 
Now, when you're coding these methods are really,  
72:58 - really helpful I can, if you don't know of them, 
or if you've never heard of these methods, and you  
73:02 - might find yourself doing line after line of the 
line of code, just to do the same thing as this  
73:06 - little snippet can do. Essentially, it would 
be dictionary dot, and then you could have  
73:11 - clear, open bracket, close bracket, and that 
will remove all elements from a dictionary, okay.  
73:17 - All of these methods, tinker with them in your own 
time, open up a text editor, have a play, run some  
73:21 - code, and you will become fluent in these very, 
very soon, but you got a whole bunch of things you  
73:26 - can tinker with. So do that. I urge you. Okay, so 
let's open up a terminal and a Python interpreter.  
73:36 - Okay, and then we'll dump in some code. 
So we'll put the dictionary that we were  
73:39 - talking about a moment ago in here, okay, and 
we've assigned it to some decks. So we put some  
73:46 - debt interpreter will express a dictionary in 
this way, which is hard to read. Like I said,  
73:51 - in the last video about sets. Sometimes you 
can look at this and go oh, curly brackets is  
73:55 - a set or its addiction and get it wrong because 
you for it to be a dictionary. It's key value.  
74:00 - Key value items separated by commas. A set is just 
item item item, okay, but that you'll get used to  
74:07 - it after a while. So this is key value separated 
by separated by colon. But each item is separated  
74:14 - by a comma. So it's key colon value, comma, key 
colon, list is the value, comma, okay? You'll  
74:22 - get used to it. We've then got there. So this will 
return an error. So if we were to unlike a list,  
74:29 - so if we were to reference an item in a list or 
set or tuple, we could reference the item by its  
74:35 - index. So the very first one item in a list suit 
set or tuple. You can reference by index zero. By  
74:42 - do that on the dict. It will come up with an error 
because you don't reference items in that way.  
74:48 - Got key error, okay, there's no such key zero. 
You need to reference key value pairs by key.  
74:55 - Okay, so in this case, we could put some decked 
Kiera Sorry, Nakia, aka sort of referencing a key,  
75:03 - and a value is a value. And this one we put 
a key for, we should get a dictionary back.  
75:08 - There we go, because we're then referencing this 
really helpful. But you manage dictionaries in  
75:13 - a slightly different ways what you would a list 
tuple, or a set, you've then got creating a dict  
75:18 - copy, this is one of the methods I was talking 
about. Really helpful. If you want to create a  
75:23 - copy of a dictionary, you can then assign that 
to a new variable, and you can alter it, you can  
75:28 - change some of the values, and then you've got 
just a an absolute copy of a previous dictionary,  
75:33 - and the previous variable is safe, and you have to 
worry about that. So again, that's quite helpful  
75:39 - method for you. So you've got Ultra an addict, 
so we can like a list, we can use the assignment  
75:44 - operator and assign a new value to a key value 
pair. Okay, so add the cube of six as a hangover.  
75:56 - I use a lot the same code examples across 
these, but some decks. So what we're doing here,  
76:02 - we're assigning a new value to there. And then 
we're printing out the value for key a key,  
76:09 - which is now new value. Okay, so we're assigning 
a new value to a key value pair, use again, Len,  
76:16 - which is the len function Length function. 
And that should return in this case, four,  
76:21 - because we got four items in a dictionary, we can 
then use the keys, method, return all the keys.  
76:32 - Okay, you got the values method, we've sent 
all the values, okay. So if you want to do  
76:40 - some analysis of the keys of the values or key 
value pairs, you can do that by using some of  
76:46 - these methods, like I said, spend some time going 
through them. So what we got here, keys returns a  
76:51 - list of containing the dictionaries keys, you 
got pop, that will remove the element with the  
76:56 - specified key, okay, so you can specify the key 
pop, and it will remove it from the dictionary.  
77:00 - Okay, so there's all these different fancy things 
you can do. So spend some time going through that,  
77:04 - you've then got dict comprehension, 
which is the same very similar  
77:08 - to list comprehension that we've we looked 
at in the last few videos. So again,  
77:14 - I won't spend too much time about control flows, 
because we're covering that in a future video.  
77:18 - But list dictionary to port and set comprehension 
essentially means that you can create a dictionary  
77:25 - using just one line of code. It's much 
easier to read, do your research and list a  
77:31 - list comprehension and dict comprehension outside 
of this tutorial, I've got this example here.  
77:36 - So you can actually see what it's doing, or at 
least understand the syntax. But if we do this,  
77:44 - there you go create an a dictionary with a 
key of two value for key or four value, 16,  
77:49 - and so on, and so forth. Okay. So we're basically 
looping through this tuple, and we're creating a  
77:54 - key, and then a value of it, we value to the 
power of two. That's why we're getting for 1636.  
78:02 - Okay, so I'm not glossing over comprehension, 
they're really, really powerful. But this is a  
78:07 - beginners course. And I don't want to get bogged 
down in some of the bits and pieces that you don't  
78:11 - necessarily need to know at this point, I'll do a 
future course that would be an intermediate level,  
78:15 - we'll start looking at comprehension 
and things like that. Tips and tricks  
78:20 - that we've got built in function deck. So this 
is on all of those forms. So you can just,  
78:25 - we can check. So the dict function will take keys 
and values and it will just convert them into a  
78:33 - dict. So it creates a dictionary object. So if we 
use this, there we go. So we've got a equals one,  
78:41 - so is a one and B two. Yeah, so it's converting 
that syntax using the DAX function. And it  
78:47 - converts that into a dictionary, which is 
really helpful, right? It saves you having  
78:50 - to use comprehension saves you having to 
manually write that in your code base. So  
78:55 - I hope I've done dictionary some justice. 
dictionaries are like I say, it's a powerhouse.  
79:00 - We use them all of the time. I certainly do. And 
when you become a master on dictionaries that can  
79:05 - really really be helpful when you're writing 
code, when you start tinkering with modules,  
79:10 - such as Jason is so closely aligned is really, 
really helpful to understand. So that marks the  
79:16 - end of this video. I hope you've enjoyed watching 
it. I've enjoyed putting it together and I'll see  
79:19 - you in the next video where we'll start having 
a look at control flows. Catch you later bye.  
79:32 - Okay, so if statements really looking forward 
to this one, I use if statements all of the  
79:36 - time that's fantastic, okay, I've got VS code 
opening if statements dot p y, which forms one  
79:42 - file from the wider supporting 
documentation for this course.  
79:46 - Download or clone it down from GitHub. Please 
do that. If you're learning to code. It's always  
79:50 - good to have a reference point. And you can 
always reference back to these files as and  
79:55 - when required when you're just scratching your 
head a little bit, so please leave please do that.  
79:58 - Okay, let's move on. So let me talk about if 
statements a little bit, I will try not to  
80:02 - butcher my explanation of what an if statement 
is, and then we'll look at a code example. Okay?  
80:07 - If statements, so that conditional statements 
right now, you and I, as human beings, we kind  
80:13 - of worked through lists logic, naturally in our 
day to day lives. Okay? There's an if statement  
80:19 - is just a way of taking that logic and putting 
it into your program or into your code. Okay,  
80:24 - so an example of that logic would be walking 
down a road or down a pathway, and you want  
80:28 - to cross a road, okay? So you don't just die 
out across the road and run across the road,  
80:32 - you're gonna get hit by a vehicle, right? It's not 
going to be pretty. Instead, you use some logic,  
80:39 - okay, you approach the crossing, or your you 
get to a point where you want to cross the road,  
80:44 - and you stop. You check to see if cars are coming. 
Are there any cars coming? Yes or No? If yes,  
80:51 - you don't cross If no, then you may cross or 
you might then say, Well, is it safe for me to  
80:56 - cross? If yes, cross, if no, check again, loop 
through that process over and over until you are  
81:02 - completely safe that you are ready to cross 
it? Right. Okay. It's kind of one example of  
81:09 - logic that you're using the real world. 
You want to make a cup of coffee?  
81:12 - Do we have milk? Yes, we do. Make the cup 
of coffee, okay, logic, and an if statement  
81:17 - would take that logic and allow you to use 
that in your program into your code. Okay.  
81:24 - Probably butchered that a little bit. But as 
if statements that fantastic. So think of an if  
81:28 - statement is a way to check to see if conditions 
are met. If a condition is met, do something else  
81:33 - do something different. That's kind of what I was 
trying to explain. Elif stands for else F. Okay,  
81:39 - so you do if you have elsif now and elsif is 
optional. And then at the end of the statement,  
81:44 - you could have else which kind of a catch all. 
That's optional to end if statement only needs  
81:50 - to consist of the if statement itself. 
Okay. Both Elif and else optional. Okay,  
81:56 - no, it will be defined. Or I will be so it can't 
read. I will be defining a function in this demo.  
82:04 - We'll talk about functions in a later video, but 
just bear with me, okay. He may or may not know  
82:09 - what functions are. But this is using a keyword 
def calling it number play. That's the function  
82:15 - name. And we've got parentheses where we're 
passing through a parameter or an argument,  
82:20 - followed by a colon, and then this essentially, 
forget the function that statement are you seeing  
82:26 - on the screen here, that is the if statement, 
but I'm just putting it into a function so that I  
82:30 - can make calls against it. So let's have a 
little look. So all of this here is optional,  
82:34 - because it's LF LF lf you don't need any of that 
you don't need it is optional. But if is the start  
82:42 - at the if statement. So x, so x is a variable 
here. So imagine x is 10. An integer. Okay,  
82:50 - so we're saying we're using this expression here, 
which is less than So if x is less than zero,  
82:55 - so it's a negative number, so minus one minus 
two, what we say is x equals one also is zero.  
83:02 - It's been a long day. And then we print negative 
changed to zero. So that will appear in our  
83:08 - terminal or in our Python interpreter. lf, so else 
if x equals equals, so this is checking to see if  
83:17 - x is equals to something. So saying if x equals 
zero, print zero, if x equals one, print single  
83:25 - else. So this is the catch all. So all other 
numbers, so that could be 467. So if x equals 472,  
83:35 - it will just print more. Okay, so that's 
the kachel. So by calling this function,  
83:40 - if I pass through negative one, we would 
expect to see this zero, then the third  
83:46 - one down here would be single. And the last 
one would be more that could be, like I said,  
83:50 - that could be whatever number, it would just print 
out more. Okay, so let's get out in our terminal.  
83:56 - Let's open up p y, Python interpreter, 
and it's dump this function. There we go.  
84:04 - This may work I might need a little bit 
more whitespace. But let's have a look.  
84:08 - can never be too careful with There we go. 
So that's now working right? So number play.  
84:15 - Number play is now a function. It looks a little 
bit messy in interpreter when you see these  
84:20 - three periods there, that's basically means that 
it's expecting another line. Because a function  
84:26 - very much like an if statement has a colon at 
the end. That means that the the actual code  
84:31 - appears in the next line after some whitespace. 
Okay, which could be four spaces or one tab.  
84:37 - So function is in there. Now let's call it now 
we'll call number play. And we'll call it with  
84:44 - an argument minus one, negative change to zero. 
Okay, so let's go and we'll change it to zero.  
84:51 - Printing zero because this was not met. So is 
there a car coming down the road? Yes, there is.  
85:00 - Is it safe across the road, okay? I want to make 
a cup of coffee is if there's milk in the fridge  
85:09 - is that sugar in the cupboard? So on and so 
forth. Okay, that's kind of what we're doing.  
85:13 - Sorry, I'm really butchering if statements 
here, but I'm having fun. So, okay, and then  
85:20 - this last one here, there isn't actually a 
number deleted it. So we can put a DLL up. It's  
85:25 - just a more. Okay. So that is just 
a single example of if statements,  
85:35 - I could do so many examples of if statements 
occurred, I can make this video last an hour long,  
85:43 - I don't need to this is a beginner's course, I'm 
just trying to show you what an if statement is,  
85:48 - what a control flow is, how your mind should 
work when you're writing code that contains  
85:53 - if statements, why, why and where to use them. 
There is actually another video I'm going to put  
85:58 - together about match statements which are pretty 
new to python three point 10, which kind of take  
86:04 - if statements to the next level, they're kind 
of like a switch statement in other languages.  
86:08 - But if statements are kind of entry 
level, so one example after this video,  
86:17 - don't watch anymore, open up VS code and just 
start coding if statements and have a play,  
86:22 - you will have so much fun, you can really have 
some fun with statements. So actually do watch  
86:28 - the rest of videos, please do but I'm just 
saying have a play with statements. Right?  
86:31 - Okay, so that marks the end of this video. 
Okay, thank you very much for watching.  
86:35 - I really enjoyed putting it together. 
I'll see you in the next video. Bye bye.  
86:47 - Okay, so my VS code is open up on match.py, 
because we'll be looking at match statements.  
86:52 - Okay, this file is one of the supporting 
documentation files. So get them cloned down  
86:58 - from GitHub, they is your cheat sheet. So you 
can always reference back to this whenever you  
87:02 - see fit. But I have pulled this a paragraph 
from pythons own website. And this explains  
87:08 - exactly what a match statement is. But I will 
then demonstrate match statements because I  
87:14 - don't think this is really kind of beginner 
proof. So structural pattern matching has been  
87:18 - added in the form of a match statement and catch 
statements of patterns with associated actions.  
87:25 - Patterns consist of sequences, mapping primitive 
data types, as well as class instances.  
87:30 - That's an action enables programs to 
extract information from complex data types  
87:35 - branch on the structure of data and apply specific 
actions based on different forms of data. Okay,  
87:41 - so that is the official description of a match 
statement. But I'll show you what it all means.  
87:46 - Okay, so a match statement takes an expression 
and compares its value to successive patterns  
87:50 - given as one or more case blocks. So we have 
a class in this demo. So in the code examples,  
87:58 - here, I've got a class, which we haven't touched 
on yet, I will be putting a class video together  
88:02 - as part of this course. So don't get too caught 
up in the actual class itself. So let's look  
88:07 - at this code. So I'll open up a terminal and a 
Python interpreter, but essentially this look at  
88:11 - this function. So it's HTTP error, TPP error, and 
we're passing through an argument called status,  
88:19 - then we've got the match statement with a 
colon. So everything after that colon is  
88:22 - the match statement, and everything after 
the case colon is a case to be matched,  
88:28 - or compared against, so we're passing status 
through to match and then we're comparing the  
88:33 - status against this case statement. Does it 
match yay or nay? Does it match yay or nay?  
88:39 - So on and so forth. Now at the bottom here, 
we've got an underscore. And that's a catch all.  
88:44 - If the previous three cases blocks 
in this instance, are not met,  
88:49 - then this one will match. It's kind of the 
else statement in an if statement. So let's  
88:53 - have a look. Let's get this in a terminal in a 
Python interpreter. P y, and we'll dump that in  
89:00 - here. Okay, so if I was to call HTTP error, 
and pass through 400, we know that that will  
89:12 - match. So the status which is 400 will match 
this case statement. Okay. So if we do it again,  
89:20 - plus 244, found an error, which you'd expect 
because as me in that cache case, statement,  
89:27 - 418 is I'm a teapot. But if 
we were to pass through 401,  
89:31 - something went wrong with the internet. 
That's the case. That's the catch all. Okay?  
89:35 - So that's kind of a very, very basic of a match 
statement. You can write that as an if statement,  
89:40 - of course you could. And so if status 
equals equals 400, so on and so forth.  
89:46 - But match statements come into the row when you 
get a little bit more complex, and it takes a lot  
89:50 - less code to get the same output. I'm all about 
less input, same output, or even more output.  
89:55 - So this example is using the bar two As an 
all statements, so if status is 400 or 401,  
90:04 - or dented editor, then not allowed for a 
zombie teapot and then a catch all again.  
90:11 - Okay, so let's go HTTP error, and this time we'll 
go 400 not allowed, because it's part of the  
90:20 - case statement here. Again, if we go for three, 
it'll be exactly the same, because that is part  
90:25 - of this isn't kind of a, an all statement. So 400, 
or 4143. So if we put 418, that's me matching the,  
90:37 - I'm a teapot. And then if you put 500, it will say 
something went wrong with the Internet. So that's  
90:43 - a little bit more advanced than the first one. 
So we were stringing them along. And using all  
90:49 - patents can look like unpacking assignments 
and can be used to bind variables. So point  
90:57 - is xy tuple. So point here is a tuple 
of xy. Okay. So that's copy that.  
91:05 - Oh, sorry. There we go. This, I'm sharing 
the screen I've got zoomed so far in,  
91:10 - that becomes very difficult to highlight. So I 
do apologize. Let's dump that in there. Okay,  
91:18 - so we've now got a new HTTP error function. 
And then we'll pass through we'll call  
91:25 - point tuple. Sorry, we'll add these two 
point tuple. Okay. So we'll do the first one.  
91:36 - So we go, HTTP error. tuple. Origin, okay. So 
that's what we're doing there. So we're just  
91:49 - changing the variable, point to port. 
So this is 00. So that's meeting this.  
91:55 - Okay, what we're then doing is we're actually 
assigning y. So this is what the patents can look  
92:01 - like unpacking assignments can be used to bind 
variables. So we are binding, in this point, the  
92:07 - index one of the tuple, two variable y, and then 
we got variable x, and we're using that as an in  
92:13 - an F string. Okay, so let me show you what that 
means. If I'm butchering the explanation of this,  
92:20 - then you can have a play outside of this video 
of this video. So now, if I call that again, what  
92:27 - we've done here, so it'd be easier now to explain 
so by passing through the tuple, zero, comma 123,  
92:34 - and calling it with them getting this printed 
out. And the reason we're getting this printed  
92:38 - out is because we are assigning the first 
index, so which would be in this case,  
92:46 - in a tuple, it'd be zero and one, we're 
assigning that from point to a variable y.  
92:52 - That makes sense. And in this case, we're 
assigning it to x. So x becomes the first  
92:58 - point in the or the item in the tuple. And 
why it becomes the second item in a tuple.  
93:05 - I'm, I've butchered that as well. But let's 
have another go. So this will be assigning  
93:10 - 123 to the variable x. So if I now call There we 
go, x is 123. And the last, the last one is x y.  
93:26 - Okay, so that is matching this one here. 
So x y, so we've, we're assigning the first  
93:34 - time to x and the second one of y is meat 
in this case. So it's printing out this,  
93:38 - this F string, which is basically I'm using 
placeholders to put the variables in. But  
93:43 - again, you can look into that haven't I didn't go 
into that in any great detail in the string video.  
93:49 - But that's just one way of handling strings 
with strings, and placeholders. Okay, so else,  
93:54 - we've got a capital and it's a value area, 
not a point. Okay, so that is a little bit  
93:58 - more advanced match statement. And lastly, we've 
got this one. Okay, so we will copy all of this  
94:12 - to our interpreter. Okay. So we've got a class 
here, and we're using the we're importing data  
94:21 - class from data class, and we're using that as 
a decorator. And essentially what that's doing  
94:25 - is adding a whole bunch of methods to the class 
point, one of them is a done deal in it, you got  
94:32 - the report, you got all of these different things. 
Don't worry about that. I've used that because  
94:36 - it's made this class a lot more powerful without 
the need to actually code more. We'll talk about  
94:40 - classes and whatnot in a future video. We've then 
got Where is so this is just a function. Again,  
94:45 - we're pointing three point, sorry, we're 
passing through point as an argument, and  
94:50 - then we're matching point against the different 
case statements. Okay, and you can see here we're  
94:55 - actually calling the class point. So this is where 
match starts. coming into its own, because trying  
95:01 - to do this in an if statement would be an absolute 
pain, and it will be very, very difficult to read.  
95:07 - But essentially, the case statement is now a call 
on the Point class. So if we now pass through,  
95:16 - we'll call the where function and 
pass through the point class with 00.  
95:21 - We get an origin. Okay? That makes 
sense. So we're calling the function,  
95:27 - we're passing through an instance of the class 
with two arguments, zero and 10. And it's just  
95:34 - giving you all of it is matching the cases, 
we don't necessarily need to go through this.  
95:38 - But what I've essentially given you here is a 
cheat sheet on match. It's very, very new. There's  
95:44 - not many videos out there, I've probably butchered 
match. But what you what you've got here,  
95:50 - what you've got here is just some very, very basic 
to intermediate examples of how match statements  
95:56 - are differentiated between if statements, okay, so 
you can, you are still matching, you'd still check  
96:04 - in a parameter or an argument against a case or a 
statement. And if it meets, then you do something  
96:10 - very much like an if statement in that regards, 
but you can do so much more. And when you get  
96:14 - used to them, you can write some pretty complex 
match statements that are very easy to read,  
96:20 - which is important. So okay, that's my video on 
Match statements. I hope it was clear and concise,  
96:25 - please, please get the supporting documents from 
GitHub. And you can have a play in your own time.  
96:31 - But the important one is this one here, but 
classes because you'll be using that quite  
96:36 - a lot when you get more advanced. Thank you 
very, very much for watching. I hope you've  
96:39 - enjoyed it. hope it's been useful. And I'll 
see you in the next video. Thank you. Bye.  
96:50 - So my Visual Studio Code has opened up on 
a loops dot P why? Because we're looking at  
96:54 - for loops, we're looking at while loops today. 
So controls control flows. This file is part of  
96:59 - the supporting documentation that you can claim 
from GitHub, please do have a look at that. And  
97:06 - that's half a go of explaining what loops are. And 
then I'll give you some code examples that we can  
97:10 - actually practice on. So pythons for statement 
iterates over items in a sequence. So give me a  
97:19 - list a set a tuple, a dictionary or a string. And 
it iterates in the order in which they appear in  
97:25 - a sequence. Okay, so at layer two a from left 
to right. If you were to then sort that list,  
97:31 - for instance, whatever the result of the sort 
is, it would then iterate left to right. Okay,  
97:35 - so it's important to note that, so the built in 
range function comes in really handy when you  
97:39 - want to iterate over a sequence of numbers, 
or a length of numbers or length of an item,  
97:44 - as it generates arithmetic progressions. So 
the range function can just take one integer,  
97:49 - and that is the stop argument. Okay, 
so it has a start a stop and a step.  
97:54 - Okay, if you don't pass a step, sorry, a start 
point, it will assume you mean zero. So the  
98:00 - integer that you pass through to a range is always 
the stop. If you pass through a third integer,  
98:04 - that will be the step. Okay? So a start 
is the value of the Start parameter,  
98:08 - zero, if you if you fail to pass it through value 
as the start and the step is, how many steps  
98:15 - you want to do, I've got some examples of it 
that will that will kind of hit that one home,  
98:20 - then we've got a very basic example of a loop. 
So we're creating a list here. So it's got cats  
98:25 - got window, and then they've got defense straight. 
Okay, so we've got three items in the list. Okay.  
98:30 - Four is what we use when we want to do a for 
loop. So we want to loop through each item in this  
98:38 - expression in this in this case, you could 
use a string, but this is a list so it's  
98:42 - cat window. Defense, right? Okay. And then we're 
assigning it to a variable. Now that very can  
98:50 - be any anything you want, is a variable. So I 
thought when I first started coding in Python,  
98:56 - or coding in general, that that variable had to 
be W because words starts with W, it doesn't, you  
99:03 - can call that horse house, parrot, Bobby, whatever 
you want. Every time you loop through that list,  
99:11 - the the item, the resulting item is assigned 
to that variable. So it can be whatever you  
99:16 - like. Okay, so the first loop would be cat, W is 
assigned the string cat. So when we then print W,  
99:26 - we're printing W, just cat and the length of that 
string, which is three. So the result will be cat  
99:34 - three, the second loop will be window, so 
it would be window. Six, and then you'd have  
99:40 - defense straight, which is I think 
it's 10 or 11. So be done with defense,  
99:44 - right and then the length of that string. So 
okay, let's dump that into a Python interpreter.  
99:52 - There we go. Thumper in. There we go. So like I 
say, cat three, window six and different always 12  
100:00 - sets of length was 12. Okay, so that's what we're 
doing that very, very basic. But the for loop,  
100:05 - like I said, at the top, you're just looping 
through every single loop, you're assigning what  
100:10 - is found as an item or a character, whatever the 
case may be, you're assigning it to a variable,  
100:15 - you can do something with that variable, you 
can print it, you can do a sum on a number,  
100:21 - you can assign a variable to a key value pair and 
addiction, eight, whatever you like that you're  
100:27 - doing a for loop, you can nest an if statement 
in there and do something based on a condition  
100:32 - you can nest and match statement in there, based 
on a case statement. The world is your oyster.  
100:39 - Okay, so create a sample collection. So let's have 
users Well, we do in here, create a dictionary  
100:47 - called users. Okay, so we've got queen, 
active, Eleanor inactive, John active.  
100:53 - So this is a dictionary, the content contains 
users, and their status, active or inactive.  
100:59 - Okay, what we've then got is iterate over a copy. 
So we're making a copy of users, again. So we're  
101:08 - making a copy of that dictionary. Remember, 
that was a method that we looked through,  
101:11 - in the dictionary video that I did a few videos 
ago. So four, so four, for each user status. So  
101:20 - you work with dictionaries in a for loop, in 
a set, or tuple, or list or character for it's  
101:26 - just one variable. But because we are looping 
through key value pairs, you need to express it  
101:34 - in this way. So for each key value, in this case, 
we just call it you can call a key value, you can  
101:38 - call them user status. In this case, I like to use 
key value doesn't matter for each user status. So  
101:46 - use that status, user status, user status, in a 
copy of users, dictionary dot items. So these are  
101:55 - the items each item in a dictionary. Okay, so 
what this expression here is basically saying,  
102:02 - that's one item. So we're looping through 
that. But we're assigning it to Quinn. Active  
102:09 - user status. Next item, Eleanor inactive. Next 
item, John active. I hope I'm kind of explain what  
102:15 - this means. This is a dictionary, so we looked for 
it slightly different. It's essentially what I'm  
102:19 - saying. Then I've got an if statement. So we've 
got an if statement in here to say that if status.  
102:25 - Yeah, so that's the variable. So if status in this 
case, active equals equals inactive, do something.  
102:32 - In this case, we use the delete 
function, this will actually delete users  
102:39 - user. So we're referencing the item by the 
keyword, which in this case will be Quinn.  
102:47 - So if the status is inactive, well, that condition 
hasn't been met, so it won't do anything. So it  
102:52 - does another loop. So do another loop. The 
second loop, Eleanor, if status is inactive,  
102:58 - delete it. So we will delete that because that 
condition was met. And then we'll do a second  
103:02 - a third loop. If John is active, we won't do 
anything. So the resulting copy of users because  
103:09 - this is a copy of the dictionary will just 
be two items Quinn active John active, okay.  
103:20 - Okay, so if we go users, there we go. So 
that's exactly what we would have expected.  
103:27 - So the inactive user has been deleted from the 
dictionary. That's what we just done. Okay,  
103:32 - so create a new collection. So the new collection 
is an empty dictionary called active users.  
103:40 - So this time, we are going to do a for loop over 
users items. So this is the original dictionary.  
103:48 - It's not a copy. And this one, this time, 
what we're doing is we're saying if the active  
103:55 - then add the key into the empty dictionary 
with the value status, so we're creating a  
104:04 - new dictionary. Okay, so if doing the same for 
loop, except we're now checking that if the  
104:10 - user is active, if the user is active, then we're 
creating a key value pair and we're adding it into  
104:15 - the dictionary. That's how it works. If it finds 
the key, it will use assignment and it will assign  
104:21 - the value to the key value pair. If it can't 
find the key it will add a new key value pair.  
104:28 - Okay, then we've got range 
sis have a little Tinker  
104:35 - Okay, let's dump that in here. So for 
i in range five print I was that done?  
104:46 - That's really, really helpful. Okay, so for i in 
range five. So remember, we've just, we've just  
104:51 - put one argument in the range function. Remember 
I said that the start would be assumed to be zero,  
104:57 - and we haven't used a step. So the one integer 
with pass through is the stop. So we've added  
105:03 - five, the first iteration of that range is 
always zero when we use in indices, so 01234,  
105:11 - that's four loops of the range function, it's 
where it's really helpful, then what we can  
105:19 - do is the start stop, remember, so if we do two 
integers is start start, if we do three integers,  
105:25 - it will be zero, 10, three. So let me walk 
you through this because this is interesting.  
105:31 - So this is a start stop. So the first one is five, 
and then it stops at 10. And when we're 10, would  
105:38 - be nine, because if we did from zero to 10, it 
will be 0123456789. So because we started at five,  
105:46 - it's five to nine. Yeah, get that. And we use 
the list function to then convert that range into  
105:53 - a list. We've then got naught 
10, three, so start at zero,  
106:02 - finish at nine, so it's, so finish at 10. So it's 
not 12343 to nine. So yeah, we've got 10 integers  
106:10 - not to nine, but we're doing steps in three. So 
it's only show every third step, or every step  
106:17 - of three in the range. So it starts at zero, then 
it's 123, then it's 456789. So that's where the  
106:25 - step function comes into it. And then you've got 
another example using negative integers. Okay,  
106:31 - so start at negative 10. Finish at 
negative 100, in steps of 13, so is 10  
106:37 - minus 10. So minus 20 3040 minus 50 6070. Okay, 
it's really helpful to know. So we then have Mary  
106:47 - Had a Little Lamb or sign in that as a list to 
variable a. And then we're saying for I, to copy.  
106:57 - So let's see what we've just done 
that, see if I can explain it.  
107:01 - So for i, so remember, that variable could 
be anything we want. So for Bobby, in range,  
107:07 - Len a select the length of A, that would be 
12345. So remember, where and we're adding Len  
107:16 - a into the range function. So that's, that will be 
an integer of five. So for range five, so 01234,  
107:25 - that a five Ranger print the variable, which will 
be Mary Had a Little Lamb, followed by a integer.  
107:35 - So i is the i is those not 1234. So it's not 
and then we're returning the index, not from a.  
107:48 - But makes sense. So this is the list. And the 
zero index is marry, the one index is had,  
107:55 - and so on, and so forth. Have I got that in here? 
I haven't. Let me open up lists, show you there we  
108:04 - go. That's what I wanted to show you. So indexing, 
I was losing myself that indexing is really,  
108:09 - really helpful. There's a little diagram here of 
what it means to a string or a list. So the first  
108:14 - item in the list is zero index 01234. 
So the first loop would be range zero,  
108:21 - in the list would be Mary, and so on and 
so forth. Okay, so we don't need list open.  
108:26 - So that's what we've done there. And then we've 
got some range for and that some range for  
108:37 - six. Okay, so what I was doing is not four, 
so it's not 123. So zero plus one, plus two,  
108:47 - plus three equals six. That's what that's doing. 
Okay. So it's loop some itself is looping through  
108:54 - the response of range for an insane zero plus 
one plus two plus three equals six. That is what  
109:00 - that's doing. So I've given you a whistle stop 
tour of for loops, or looping and conditionals  
109:06 - statements in Python, I hope it's been beneficial. 
Spend some time doing it. So you now know if  
109:14 - you've been following along with this course 
we've gone through if statements match statements,  
109:17 - we're now going through for loops, we've gone 
through strings, lists, dictionaries, tuple, sets,  
109:21 - and everything in between. Now you're starting 
to get enough tools in your toolbox to actually  
109:26 - start coding so please have a play reference this 
document outside of this video and just start  
109:31 - tinkering, start programming. Okay, so for loops, 
very, very important. And it's hugely, hugely  
109:36 - helpful when you're programming. So this marks 
the end of the video. I hope you've enjoyed it.  
109:41 - I hope it's been useful and I'll be seeing 
you in the next video. Thank you bye bye  
109:53 - Okay, so loot clauses today. We are looking at 
these now because we looked at loops in the last  
109:58 - video. So look clauses is a natural progression 
from that. Visual Studio code is opened up on  
110:04 - loop clauses dot p y, which is one of the files in 
the supporting documentation. So close that down,  
110:10 - it is a cheat sheet for you to use. So let's 
talk about what loop clauses are. So Python  
110:15 - has a few statements or clauses that we can use in 
loops. They include break, continue else and pass.  
110:21 - Okay, so loop statements may have an else clause 
it is executed when the loop terminates for an  
110:27 - exhaustion of an iterable. As for a for loop, or 
when a condition becomes false with a while loop,  
110:33 - but not when a loop is terminated by a break 
statement. So what does that mean as a beginner  
110:38 - is difficult to understand. So I've got some code 
examples to walk you through it. Okay. So this  
110:44 - is a little bit more complex in terms of a for 
loop. So I'll try and walk you through it. Okay.  
110:49 - So we'll put this in interpreter as well. But this 
little statement here follows. So we know range,  
110:54 - we're possible, we're starting to stop. So for 
n in range to 10 is the equivalent same for n  
111:00 - in this little bad boy. So they say 
it's a list 123456789. So the first  
111:06 - iterable is to the first time it does 
a loop it assigns to to the variable n  
111:13 - keep the end in mind, the second for 
loop. So every time it does a loop,  
111:18 - it then goes through this part of the code, 
okay, this part of the for loop. Okay?  
111:22 - So this is for x in range two, so a starting 
point is two, and the end point is a variable n,  
111:29 - which we know is two, because that's the first 
one. So range two, two, is the equivalent of  
111:37 - a list that looks like that. It's got 
nothing in it, okay, so it hasn't got an  
111:45 - x becomes nothing essentially is nothing right. 
So, there is nothing there is no loop to be had.  
111:52 - So when we then do this if statement, so if 
an A and modulus x equals equals zero, well,  
112:00 - the comparison isn't there. Because you know, 
comparing one against something that isn't there,  
112:05 - equals equals zero. So that isn't false, that 
condition is not met. So it does else print  
112:10 - statement on a prime number. The second loop 
is a three, so this range becomes two, three.  
112:16 - Okay. So it then compares that statement, if 
it's matches, so if modulus x equals equals zero,  
112:24 - then it prints this statement here. So n 
equals x, there's got little string of star,  
112:31 - then it's prime. So it's floor division, NX. 
Okay. So let's have that in our we've learned  
112:39 - all about floor division in numbers right at the 
start of this course, you should understand what  
112:43 - we're doing here. So copy this go terminal new 
and do this and dump it in. And what we have,  
112:52 - there we go. So we expect it to to be a prime 
number because the condition wasn't met, we  
112:57 - expect three to be a prime number, okay? And then 
it's four. So the print statement is four equals  
113:04 - two times two. Okay? So it goes through, 
that's what that's doing is a basic kind of  
113:09 - for loop was followed with a for loop with 
an if statement. So it's not basic at all.  
113:15 - But we've got a little break statement here. 
So it prints out and then it breaks. So that  
113:21 - for loop finished, so it does the loop again. 
So that's what the break statements doing.  
113:28 - Okay, so continue statement. So for now I'm in 
range 210. Okay, so if num, modulus two equals  
113:35 - two, then do something and it continues. 
So this will continue with the next loop.  
113:39 - Okay, so this is another example. So it's 
just doing something slightly different.  
113:46 - So found an even number or an odd number, bound 
and even found an odd found an even found an odd,  
113:52 - right from the to through tonight. Then you've 
got a past statement. past statements are really,  
113:58 - really useful. When you're coding, you might 
write classes or functions that you need to  
114:02 - call in another function, but you don't 
want it to do anything. Because you're  
114:05 - not actually at that point of the code 
yet, you might be testing something  
114:08 - past just means that it does nothing, it doesn't 
break or anything like that is just allows you to  
114:15 - I can call my past class and it won't do anything. 
Okay. So this is an example of a function you can  
114:23 - add to pass and I can call that function. So my 
pass death. Okay, it doesn't do anything because  
114:33 - it's just got past statement if it didn't have the 
past statement, and it'll come up with an error.  
114:37 - Actually, it will show you in a text editor here 
that you can't do that. It just doesn't let you  
114:41 - do it. So that is closed loops. Again, like 
with this course, I'm explaining what they are.  
114:48 - I'm giving you some code examples all that have 
been extrapolated from pythons own documentation  
114:54 - for you to read up in your own time and have a 
tinker and kind of understand what I'm doing.  
114:58 - What pythons doing. I have tweets Some of 
them. But yeah, that is Luke closer hope  
115:03 - you've enjoyed this video that is the end of this 
one. I'll see you in the next video. Thank you Bye  
115:16 - okay modules today, so it won't take long to 
explain what modules are. So before we jump into  
115:21 - it, my VS code is opened up in the modules.py 
file. You can reference this whenever you like,  
115:26 - look, it is your cheat sheet, but you can get the 
supporting docs on GitHub. So all of that will be  
115:32 - in the description. Okay, so module so in Python, 
we're able to write a long program and save it as  
115:38 - a module. This is known as creating scripts, we're 
able to input modules across modules and into the  
115:43 - Python interpreter, right. So what you don't 
want to do is write a function numerous times,  
115:51 - what's the best situation is to just write it 
once and do not repeat yourself. The reason for  
115:56 - this is because if your function is incorrect and 
not working correctly, you need to debug it. If  
116:00 - you've got to hit multiple currencies or that 
function across your project, you need to debug  
116:04 - all of them, what you need to do is create one 
function and import it as a module to your other  
116:10 - application or other file in your project. So 
do not repeat yourself dry. That's what this is,  
116:16 - you may see that a lot in your career. Python, 
Python standard library can be found here, they've  
116:23 - got a whole bunch of modules and fancy stuff 
that you can import and take advantage of. Please  
116:28 - look at that your own time, we've got it here in 
modules, have a look at this page. And it talks  
116:34 - about different modules. So import flow, which 
is the Fibonacci module, there's loads and loads  
116:41 - of different modules you can import. But we're 
not going to look at those. Today, we're going  
116:44 - to look at our own that we've already created. So 
in the last video, we were looking at functions,  
116:48 - and we create a function called Demo funk in 
the functions file. So that's a script that we  
116:54 - can import. So if you look here, I've got from 
functions import demo funk. Now, that will print  
116:58 - out some gobbly goo closer to us because it's got 
some other functions in the file. But essentially,  
117:03 - with this line of code here will allow us 
to import that function. So we can call  
117:09 - it and pass it through to these functions. 
Let's get that open up a terminal, open up  
117:15 - a interpreter. We dump it in there. Okay. So we've 
imported demo funk, and yet it's printed out a  
117:23 - load of two's because we've got some functions in 
there, don't worry about that. It just now means  
117:28 - that we can access demo funk, so we can say my 
int equals demo funk. And we'll pass through 28.  
117:38 - Okay, so my int now becomes data because that 
function is taking an integer addition, adding  
117:47 - on six and then returning the new calculation. 
So we're expecting 32. But what we can do,  
117:52 - we can now pass that through to my funk one, 
so we can say my funk will pass through my int  
118:04 - my funk, what we're talking about is funk one, 
funk one, my ENT. There we go, do apologize.  
118:11 - Okay, so you can see how we're importing 
a module. And when we're using that module  
118:17 - to interact with other functions. Now we 
can import funk one into another module.  
118:24 - Does that make sense? We you know, you can, it's 
so important to make sure that your code is as dry  
118:29 - as possible, do not repeat yourself is really 
important. So we then got funk, too. So funk  
118:39 - underscore two, is that 
right? Funk underscore two,  
118:42 - we won't we won't use the demo funk this song. 
This is actually yes, we will. We'll go my int.  
118:49 - And this is this has given us the power of so 
my in this case it will be 32 to the power of  
118:55 - 16. Well, that's a big number. But that's a good 
explanation of modules. Okay, that like I said,  
119:05 - So pythons standard library can be found here 
on this page. So if you look here on Zoom In,  
119:13 - I was not working. It's not liking 
that. Yeah, there you go. docstoc  
119:19 - python.org/three/tutorial/modules.html. 
That's where you'll find this standard  
119:23 - library or documentation about their standard 
library, their link to the library is  
119:32 - whereas it let me crash that out. Or there 
we go. Can you see that on the screen? Yeah,  
119:37 - Doc's dot python.org. Three dash load library. 
So actually, that's open that in the browser.  
119:47 - There we go. So you've got a list of everything 
in here. Okay, so text position services. We've  
119:55 - got Date Time, which is which is a great 
one. So you'd say import In the terminal  
120:02 - p y said say import, Jason, 
he say import, daytime.  
120:14 - Or you can go further and save from Date Time 
import, I think is delta. Now there isn't, there  
120:23 - is a date time actually go from date, time, import 
date time. So these are different functions and  
120:29 - classes and stuff within those packages. So have 
a good read up on all of these. They're fantastic.  
120:36 - Again, like the methods in lists and things like 
that, when you really understand this, it can  
120:41 - save you lots and lots of time when you're coding. 
So that marks the end of this video. Hope you've  
120:48 - enjoyed it hope it's been very beneficial. And 
I'll see you in the next video. Thank you, bye.  
121:00 - Okay, so we're nearing the end of this course. Now 
we're looking at classes in the next video. And  
121:05 - we'll look at a small bit of programming a little 
API that we're right, that comes after this,  
121:09 - which is all about exceptions and errors. So my 
VS code is opened up on errors dot p y, this is  
121:15 - your cheat sheet, you can clone this down from 
GitHub, always reference back to this is really,  
121:19 - really helpful as a programmer. So Python has 
at least two distinguishable kinds of errors.  
121:23 - So you got syntax, you got exceptions, okay, as 
a noob, you'll be getting a lot of syntax errors,  
121:28 - you'll not need to look at colons after functions. 
And if statements and loops, you need to look at  
121:34 - whitespace loads and loads of problems. But 
that's where text editors are really, really  
121:38 - helpful. So look at my text editor video, get 
one installed, we've got VS code in this course,  
121:45 - syntax errors. As you become better, you'll know 
what the errors are. So exceptions are and you'll  
121:51 - know how to handle them. So I've got all of the 
exceptions here. So you got name of exception  
121:56 - description about what it actually means. Okay, 
so we'll be having a look at some of these. We've  
122:02 - already seen some of these during this course. 
But some of the bottom here you got type error,  
122:06 - you nightmare, you got zero division error, okay? 
So work through them when you got a bit of time.  
122:13 - But we've got here some examples of code that will 
be coming up with an error, okay, so if we get  
122:19 - p y here, dumping some code, this will be 
zero division, because 10 times one over zero  
122:24 - is zero division raised when a second operator 
in a division is zero, you've got four plus spam  
122:31 - multiplied by three, well, spam doesn't exist. So 
I've got a name error, if I put spam equals two  
122:38 - in our exists, so we don't get the error, then 
we've got a string plus integer doesn't like that,  
122:44 - okay, but if we go to plus two, it will like 
that. There are exceptions. So now we need to  
122:50 - look at how we can handle exceptions. So we've 
got a little while loop here and my example.  
122:57 - Let's get that dumped into the interpreter and 
see what's going on. So we've got a while loop.  
123:01 - So while true, you do a try and accept statement. 
So I haven't talked about trying to accept  
123:05 - statements, you can read up on them on Python 
docs. But we've got one in here. So essentially,  
123:10 - it's trying to run a piece of code. But we accept 
that if any of these exceptions occur when running  
123:17 - the code, we print this, okay? So this, this code 
could say anything really, but basically, we're  
123:24 - trying something we've got a break clause there, 
and we're accepting if these exceptions occur,  
123:29 - then we do something. So this is how you manage 
exceptions. So if we were to run a try and accept  
123:35 - on the code earlier, we could say if there's zero 
division error occurs, then do something else you  
123:41 - can just print a fancy statement, okay, so we put 
five in here it won't have an error, okay. But if  
123:47 - we would find narrow then it will do this it will 
print Oops, that was not a valid number try again.  
123:54 - Okay, so then we've got a function 
try this fails, so we say this  
124:02 - BIOS division error, okay, so one 
over zero division error, but if we  
124:11 - stick it in a try accept statement and Bonga in 
here is calling this file so try this file. So  
124:20 - we're calling the function and we're accepting 
zero division error. Okay, and because we're  
124:24 - accepting that, we can then say what happens 
in this case we just did a print statement  
124:29 - handling runtime error division by zero. Good so 
the train except statement has an optional else  
124:34 - clause which can be present must follow an except 
clause is useful for code that must be executed  
124:40 - if the try clause does not raise an exception. 
Okay. So if a finally finally clauses present  
124:47 - finally clause will execute a last task before 
the try statement completes. The finally clause  
124:52 - runs whether or not the try statement produces 
it as an exception. The following points discuss  
124:58 - more complex cases when an exception occurs. 
So let's get this little function in here.  
125:08 - Okay, well, we got several get it all on the 
screen. So okay, so we've got a function called  
125:15 - divide, and we're passing through two positional 
arguments, x and y. Okay? So it must have two  
125:21 - arguments. So we're trying result equals x divided 
by y. So that is what we're trying. That's the  
125:28 - little bit of code we're trying to run. But we're 
saying except, if we receive a zero division  
125:34 - error, then we just print that we get type 
error must be an in if we else print result is  
125:42 - result. Okay? So result equals, and then finally 
we print executing, executing. Finally, finally,  
125:50 - clause, tongue twister. So that will be printed 
anyway. Okay, so if we now pick up those commands,  
125:57 - and dump them in here, you should see 
an example. Oh, I didn't like that.  
126:05 - Do apologize, as pick this up, copy.  
126:11 - Delete that. stumped them in. Okay, so the 
first example, divide to one result is two,  
126:19 - okay? Because one is an integer above zero, 
so we don't get the zero. And what does it  
126:25 - say? So the result is two. So this actually 
it tried it, okay. So result equals x over y  
126:33 - to zero, that is a zero division error. So 
we're getting division by zero, then we've got  
126:42 - strings instead of integers, it's 
printing out must be an integer.  
126:46 - So they're the three times we've 
called it but you know, is every time  
126:49 - we get an executing finally clause, that's 
because this is run every time it tries. Okay,  
126:55 - so this is the finally clause. And that's what 
we're talking about in here. Okay, so that  
127:02 - is a save the changes I made. That is a whistle 
stop tour of errors and exceptions. I hope this  
127:09 - made sense is really, really helpful. You'll find 
a lot of this when you're reading other people's  
127:12 - code, people that have been coding in Python a 
lot, you'll find a lot of this type of stuff.  
127:17 - So try to understand it, read up on the exceptions 
on the Python website, understand what they do and  
127:21 - what they are and how to handle them. And you'll 
be good to go. That's the end of this video. I'll  
127:26 - see you in the next video where we will start 
to look at classes, or certainly I'll try to  
127:32 - catch you later. Bye bye. Okay, so looking forward 
to this one, because classes are the cornerstone  
127:43 - of OOP or object orientated programming in Python. 
Okay, we looked at functions a few videos ago,  
127:50 - and I said that look at a function as a container, 
you have some script, what have you, when you save  
127:56 - that container, you can call it and you give it an 
input, you get an output, okay, we do some fancy  
128:00 - stuff in the function, but essentially, his input 
and output class goes so much more further than  
128:06 - that, it gives you the ability to bundle data, 
and functions together, they are a powerhouse,  
128:13 - okay? And unlike any other datatype in Python, 
okay, so not that you can store data in  
128:19 - dictionaries, and lists and what have you. But 
classes gives you the ability to store data and  
128:24 - give it functionality at the same time. So if you 
look at VS code, on the screen here, I've got open  
128:30 - on cluster dot p y, which is one of the files in 
the supporting documents that you can clone down  
128:34 - from GitHub. This is your cheat sheet. So please 
do that. It's massively helpful when you're coding  
128:39 - and looking back, forget certain things. This 
could be your reference point. So please do  
128:44 - I've extrapolated a whole bunch of data 
from pythons own docs, which are in docstoc  
128:52 - python.org/three/tutorial/classes. They go 
into great depth about classes, objects, names,  
128:56 - namespaces, inheritance, base classes, instance 
variables, class variables, and everything in  
129:02 - between. Okay, so a bit of bedtime reading view. 
This course in this video is all about beginners,  
129:08 - and helping you get started. So you can 
start tinkering and coding. So this is very,  
129:15 - very much geared towards beginners, and I've just 
extrapolated what I think is what you need to know  
129:20 - to start. So classes provide a means of 
bundling data and functionality together,  
129:25 - creating a new class creates a new type of object 
allowing new instances of that type to be made  
129:30 - Python classes by all the standard features 
of Opie the class inheritance mechanism that  
129:35 - we'll look at soon allows multiple base classes. a 
derived class can override any method of his base  
129:41 - class or classes. And a method can call a method 
of his base class with the same name. That's all  
129:46 - about inheritance. It frames it very, very well, 
but I'll walk you through that in a few minutes.  
129:51 - simplest form of a class definition looks 
like this. So you have a class keyword,  
129:55 - followed by class name, colon, and you 
have a bit of whitespace in all of this  
130:00 - And these your methods and class variables, okay? 
So look at that in a second have a function,  
130:07 - you must save or a D must define a class before 
you can make, or before it takes any effect.  
130:13 - So let's look at some of my class examples here. 
Let's open up a terminal and a Python interpreter.  
130:21 - So we'll dump this in the interpreter quickly. So 
we've got my class available. So class keyword,  
130:29 - and you got my class, colon, and then you've got 
some of this, the first line here is text literal,  
130:34 - I would urge you, I urge you to added texture to 
all of your classes. Because if you're looking  
130:39 - back at a class that you wrote years ago, or 
somebody else's code, they may if it hadn't  
130:44 - got a text literal, there's no way of knowing what 
that class does without really doing a deep dive,  
130:49 - where you can call a magic method called doc, 
and it will tell you exactly what's going on.  
130:53 - Mine's very simple, but you can put whatever 
you want in there, it could be 200 lines,  
130:57 - if you like, you then got a class variable, 
which is accessible to all instances of a class,  
131:01 - which I'll give you an example of in a 
second. And then you got the F method, just a,  
131:07 - we're just calling it f, we call it anything 
you like. But that is a method for this class  
131:10 - that can be called Okay, and it will just 
return a string called hello world. So we  
131:15 - can now call my class I and get back the integer 
12345, we can call F and get a function method.  
131:25 - Okay, and we can call the magic method doc to 
get the string literal. Okay, so you can call  
131:32 - double underscore doc dollar, double underscore 
any class and it will return the string literal  
131:36 - if it has one. So let's go ahead and instantiate 
this class and assign it to a variable x. So the  
131:43 - class is now instantiated, and we can access it 
using a variable x. So again, we'll go extra I  
131:50 - move my mouse X to Y, we have access to 12345, 
which is a class variable. Now, if we go x dot F,  
131:58 - but this time we have parentheses, it will pass 
it will bring hello world. The reason is bringing  
132:04 - back hello world is because we are parsing 
through self. Let's talk about that. So we pass  
132:12 - the methods instance object in as the 
first argument of all methods. So x dot F,  
132:20 - which is what we called here, is the equivalent of 
saying a my class dot F, and in passing through X,  
132:28 - okay, self has no special meaning 
in Python, the word self doesn't,  
132:32 - it's just his normal convention to do so. So 
in this class, we're possibly self. So that  
132:38 - is where we're instantiating all of this to x. 
And then the first argument and the method is  
132:43 - x itself. That's how we can act. That's how we 
can access that method and call that method. Okay.  
132:52 - Hope that makes sense being see we're doing 
it again here. So we expanded on our class.  
132:56 - Let's get that in here. And talk about it text 
literal, no change, but we're now using a new  
133:03 - magic method or Dunder init method called in 
it. And we're passing through self, which we do,  
133:09 - because we pass through the instance itself or 
the object itself. And then we're passing for  
133:13 - a positional argument called My int. And it has 
to be an integer. Okay, so if I didn't have this  
133:19 - in there, you can pass or anything, but it won't 
like it because we're actually using an integer as  
133:23 - a sum. So that's what that's doing. And within 
that method, we are assigning my integer to a  
133:33 - instance variable called self dot i, okay. So 
that is only accessible to the instance itself.  
133:40 - So whereas the first example, I was a class 
variable, this is an instance variable. And  
133:46 - then with the F method, we're just doing a 
quick sum. So new variable equals, we get any  
133:52 - integer that we're passing through as a keyword, 
positional argument, and we were doing a sum,  
133:57 - which is the power of three. So if we pass 
through four, it's four times four times four,  
134:02 - which is 64. And we're returning. So that's 
instantiate the class to x again. Now x.ai  
134:12 - is four. It's not 12345. Now because we passed 
four through as the positional argument, okay.  
134:21 - Now, if we go x dot F, is 64. 
Okay, so we're calling this method,  
134:29 - it has access to self.ai, because we're passing 
self through as the instance. So x is accessible  
134:36 - in F. Self that I, that makes sense? I hope it 
does. So we're passing the instance through as  
134:44 - the first positional argument is doing assignment 
is returning the new sandwich is 64. Good.  
134:51 - Now let's talk about adding an attribute so we can 
add an attribute to our instance called counter.  
134:57 - It's not in the class, we're just adding 
this To the instance of the class,  
135:01 - so now we have access to x dot counter, 
which should be one. If we were to do a  
135:09 - little while loop, just on the sum. So while 
x dot count is under one, we do something.  
135:16 - And then so we changing count to another number 
in every loop, we just checks. Is it on 10? Is it  
135:22 - under 10? Is it under 10 hours over 10. Now stop. 
That's what a while loop is doing. So essentially,  
135:28 - I put a description. So the first loop returns 
two, because it's one multiplied by two,  
135:35 - and then x becomes two. So it's two times two is 
four, four times two is eight. Eight times eight  
135:41 - is 16. And at this point, it hits the loop and 
says, ah, 16 is above 10. So stop, so loop then  
135:48 - stops, so the fifth loop does not happen. So we 
know that x is 16, down here. So if we print x,  
135:58 - it will be 16. But now we can delete that 
attribute of the instance x by using Dell. Now,  
136:05 - if we try and print it again, it just won't like 
it. Okay? It won't like it. But what we can say is  
136:14 - attribute or we can call it,  
136:18 - attribute to ohms. And we didn't assign 
anything. Yeah, X attribute so and then we can  
136:29 - find out Yeah, we could do another 
someone else. But then we can go del  
136:33 - x dot attribute, do an L delete it, and then we 
don't have it. Okay. So once we've instantiated  
136:41 - a class, we can add attributes, remove attributes 
really, really helpful. And you can't do that with  
136:45 - dictionaries or anything like that, you can, 
you can add data to dictionaries. And because  
136:50 - they're mutable, you can change values and things 
like that. But with classes, you get so much more  
136:55 - that you can tinker with. So now let's talk about 
in a little bit more depth instance variables.  
137:01 - So you can actually understand it a little bit 
more, let's create another class called Dog.  
137:07 - Now, what we're doing is a class variable that's 
available to all. And I've got instance variables  
137:12 - that are only available to the instance. So when 
we instantiate the class, we will have access to  
137:17 - a name and tricks variables. And then we've got 
a method called add trick, and we pass through a  
137:22 - trick and it appends it to this list of the 
instance variable, not the class variable.  
137:29 - Okay, so don't count the class variable is 
canines, every instance of this class will have  
137:34 - a variable called kind, and that will be equals 
to canine. So let's create an instance assign it  
137:40 - to D. Okay, in this instance, I'm gonna assign it 
to E. So D has the name Fido and he has the name,  
137:48 - buddy, because we're passing through a positional 
argument called name. So you have to pass a string  
137:52 - through. Actually, you know, you don't even pass 
anything you like through, but we could do that.  
138:01 - We could do that. And it has to be a 
string. Okay, let's save that. So he kind,  
138:09 - d dot kind will be exactly the same. This is 
a class variable, but e dot name, we buddy,  
138:17 - d dot name will be five eight, because that is 
specific to the instance. Now we can go one step  
138:23 - further, we can assign a trick to D. And it'll be 
specific today, we can assign another trick to a  
138:31 - and all this is doing is taking that string, 
and it's appending it to the instance next  
138:36 - list, which is an instance dict. So a list is 
not a class list. That was a class list and we  
138:44 - added roll over and play dead, then both instances 
will have access to those tricks in this case. So  
138:50 - we now put D we don't want that. We want it down 
here d dot trick you can see. Sorry, the dot trick  
139:07 - was tricks side. There we go. D dot tracks, 
rollover a dot Trix. Play dead. So we can then add  
139:17 - another one to a ATREX. It's now got two in there. 
Dietrich's still got the one because we're only  
139:26 - using instance variables. Okay, does that makes 
more sense? So we instantiate in more than one  
139:31 - class and we tinkering with those instances of 
that class. So let's talk about inheritance.  
139:39 - Oh, let me just come back in here and make some 
changes. Inheritance so the class can inherit  
139:47 - from other classes. Okay, so base classes now you 
can inherit from numerous different base classes.  
139:53 - Indeed, a base class can then inherit from another 
base class. Now this is really handy when you're  
139:57 - trying to write clean code, because what you don't 
want If duplication of methods across numerous  
140:02 - different classes, it's good to have a base class 
that has common attributes and methods that you  
140:06 - can use elsewhere. And you can then inherit 
from the derived class from a base class. So  
140:12 - think of it as kind of a, a tree so that you have 
a base class, which two classes can inherit from,  
140:18 - or two or more, and, and so on, and so on and so 
forth. Okay. So for instance, this example here,  
140:24 - this dog class, could inherit from the 
animal class. Because a dog is an animal,  
140:32 - you could have a class called Cat, that would 
also inherit from the animal class. And that  
140:37 - animal class could have a whole bunch of methods 
in there that are useful to derived classes.  
140:45 - I've got another example here. So actually, 
this is an example of a derived class,  
140:50 - he got the class name, and you got a bracket and 
all of the classes that is inheriting from, okay,  
140:55 - and then again, you then state you're 
the same, you're doing a normal class.  
140:59 - But remember, a derived class can overwrite the 
methods of its inherited classes. For instance,  
141:06 - the dog class might have a special method, or a 
special way of handling the tail method that is  
141:15 - different to a frog that doesn't have a tail or 
loses its tail when it goes from tadpole to Frog.  
141:23 - That's quite a good explanation of methods and 
overriding Okay, so execution of a derived class  
141:31 - definition precedes the same as for a base class, 
when a class object is constructed, the base  
141:36 - class is remembered, this is used for resolving 
attribute references. If a requested attribute  
141:42 - is not found in the class, the search proceeds to 
look for that base class or in that base class,  
141:46 - this rule is applied recursively if the base class 
itself is derived from another class, so it keeps  
141:52 - looking and looking and looking recursively 
derived classes may extend or override methods  
141:57 - from the base classes. Okay, so really, really, 
really helpful. And it allows you to write really  
142:03 - clean code. Otherwise, you could have one class 
that is crazy long, and then you're duplicating  
142:08 - some of those methods in another class that is 
crazy long as best to have two smaller classes,  
142:13 - a base class that they both feed from. Okay, 
so I've got a couple of classes here that  
142:18 - kind of walk you through that. So there's open 
dump all that in my interpreter. And let's see  
142:25 - if we can walk through this. Okay, so we've got 
mapping, that is our base class, in this example,  
142:32 - private variable example. So check out 
double underscore update. This is called  
142:37 - name mangling. There's a bit about name mangling 
in pythons own Docs. So have a look at that.  
142:44 - It's, that's what that's the example. 
Actually, they're using our own Docs.  
142:48 - So but we don't necessarily need to do need to 
talk about that in great detail at all in this  
142:53 - explanation, it basically means that this 
update can appear where it appears in a class  
142:59 - is done without regard of syntactical syntactical 
position. So normally, you can only access certain  
143:08 - variables because they appear above them. So but 
because we're using name mangling, we can access  
143:14 - update, no matter where we put it. So do a deeper 
dive of that, and Python docs that's a bit beyond  
143:22 - beginner level. So mappings got a special method 
called in it. And we've got items list and  
143:29 - iterable. As instance variables, we then got 
an update method. So for item in self iterable,  
143:36 - we have access to self editable, because it's 
an instance variable, we then append it to this  
143:41 - empty list of the instance. Then we've got 
a class called mapping subclass. And we,  
143:47 - which derived is a derived class. And a base class 
in this case is mapping which is the class we've  
143:52 - just talked about here. So this inherits from 
mapping. But you can see here we're overriding  
143:59 - the update method again, so that we've got it in 
here. This mapping subclass is actually got its  
144:05 - own method called Update, which would do its own 
thing. Okay, so, so don't worry about the actual  
144:13 - functionality of the methods and what 
they're actually doing. And a result,  
144:15 - don't worry about that, just more or less, just 
look at what we're actually doing here with the  
144:19 - class and the inheritance. Okay, that's the 
whole point in it. So we will instantiate  
144:26 - mapping subclass, and we'll, we'll call that 
or we'll assign it to a variable called M.  
144:32 - Okay? So we can then say M items list. 
Okay. So the instance variable is an empty  
144:42 - list. We will then call update. So in 
this case, we call an update and it's a  
144:48 - list 123 And another one these are values 
okay, so now we can quite simply add that  
144:56 - and it will create one These two are three 
values. Okay? So what it's doing, it's,  
145:04 - it's creating what we're doing here. So, okay, 
there's talk about the method and what we're doing  
145:09 - because it's actually quite confusing. Okay, so 
we've got two lists, we've got 123. And these are  
145:14 - values. So what this update method is doing, it's 
for item in zip, and what we're doing that that is  
145:21 - a built in method called Zip. And it basically 
zips, two lists together to key value pairs.  
145:27 - And then what we're doing is we are using self 
dot items list to append item to the list that  
145:34 - we just created in the instance variable. 
So that's why we've got a tuple. One, these  
145:38 - two are three values. That's why we've got that 
result. So but if we were just calling the update  
145:46 - method, we wouldn't get that because all it's 
doing is it's iterating. Through what we're  
145:52 - passing through, in this cases, it's a list in 
a list. And it's just self items dot append,  
145:59 - and it's just appending the item so we'd 
get a very different result if we weren't  
146:05 - superseding the update method. Okay, I don't 
know if I've just butchered that inheritance  
146:10 - explanation, but it's a beginners class. 
So hopefully, that's given you enough to  
146:16 - actually work. I mean, I've just used the zip 
method there. And, and I probably could have  
146:21 - gone with a much more simple explanation. But if 
we were just using the base class update method,  
146:27 - it would do one thing, but because we are 
actually overwriting that update method,  
146:32 - we're doing something very, very different. 
Okay. So that is the end of this video,  
146:38 - they are all of my code snippets that we've walked 
through, it's taken me nearly 20 minutes to do it.  
146:44 - I hope I've done it justice. Again, I would just 
re kind of reinforce what I was saying. This is a  
146:51 - very much a beginners course or a a polishing 
up course, if you like. But read pythons own  
146:57 - documentation, because it will give you a good 
rundown of everything in regards to everything  
147:02 - we've gone through in this course actually, 
because this is the last video about coding.  
147:07 - The next video, we'll actually be taking what 
we've learned throughout the course and just  
147:12 - using it to write a short program. So thank you 
very much for watching this video. I've enjoyed  
147:17 - putting it together. Hope you've enjoyed it. And 
I'll see you in the next video. Thank you bye bye  
147:28 - so virtual environments today, they're an 
important part of any project. So we're  
147:34 - open here on pythons own documentation on 
Doc's that python.org/three/tutorial/v Envy,  
147:41 - which is shorthand for virtual environment. 
Okay, so have a read of this in your own time. So  
147:48 - virtual environments, why 
are they so important? Well,  
147:51 - when you're programming when you're a 
freelancer, or software engineer or developer,  
147:55 - whatever the case may be, when you are throughout 
your career working on different projects,  
147:59 - you will soon realize that these projects 
can only function if they've got a whole  
148:04 - list of different dependencies installed. Okay, 
they might be third party packages in there,  
148:11 - say a web framework called Django, you'd first 
have to install Django, and then they say install  
148:16 - pillow or requests or Django rest framework, you 
would have heard of these some of these anyway.  
148:22 - However, all of these third party packages will 
have different versions, the reason they have  
148:27 - different versions because they are configured in 
a certain way to work. alongside other packages,  
148:32 - such as Python, we've got python three point 10 
installed, or three point 10.2 installed on this  
148:38 - project. Older projects might be using Python 
2.7. For instance, in which case, the third  
148:44 - party packages that you're installing have to be 
able to work with those different dependencies.  
148:50 - And this is where virtual environments come into 
it. Because if you were to install all of the  
148:54 - dependencies globally, you will have a whole bunch 
of conflicts. So project one will need Python 2.7,  
149:03 - and Django 1.8, for instance. And if you had all 
of those installed globally on your machine, well,  
149:10 - you'd be in a spot of bother when trying to run 
project B that requires Python, three point 10,  
149:16 - for instance. So this is where virtual 
environments come in, you are able to create  
149:20 - this little environment on your machine, install 
project dependencies within just that environment,  
149:26 - and fire that up and work with that 
environment on your project. That way,  
149:29 - you can have one container for project one 
using dependency A, B and C, you'll have  
149:33 - another project project B using dependency X, Y 
and Zed. Okay, they are really, really helpful.  
149:40 - Now you can follow the walkthrough tutorial on 
the page that I'm on here using Python or in  
149:46 - my case it'd be p y dash M, V and V and you 
can create a virtual environment like that.  
149:52 - By all means, go ahead, it will create the virtual 
environment in the path tree that we're in in the  
150:00 - video. to code however, I find using a third 
party package called virtual EMV wrapper to be  
150:07 - a much better direction to go. So if you 
visit this here, which is a zoom in, so  
150:19 - P ypi.org/project/virtual env V wrapper. So let's 
have a look again, virtually in V Rapidash. When  
150:24 - that's the Windows version of this, what it does, 
it allows us to install this package globally.  
150:29 - And then we can use commands such as, make 
virtual environment, and then name it.  
150:34 - And it always saves and creates and configures 
a virtual environment in the same destination.  
150:39 - Normally, users slash your name slash NV, and then 
you'll have a whole bunch of environments very,  
150:46 - very easy to manage. Whereas when you use the 
Python alternative, this virtual environment  
150:50 - is saved normally in the project that you're 
working in, and I just find virtually in V  
150:54 - rapid to be much, much easier to work with. So 
all you do is you copy that command. Because  
151:01 - we've installed Python globally, we have access 
to pi pi, or sorry, Pip P IP, new terminal,  
151:08 - and all you need to do is pip install, probably 
got that actually copied on my copy that there.  
151:21 - There we have it same requirements already 
satisfied, because I have already got that  
151:24 - installed globally. So now what we do, we 
will go and use a command, make virtual  
151:31 - envy. And we'll call this Python dash 
course, when I press Enter, they'll  
151:41 - go ahead and install or create a 
virtual environment on my machine.  
151:46 - In the folder, C drive uses Bobby slash e n v. 
And then there'll be a folder in there called or  
151:53 - directory in there called Python dash course. And 
within now we'll have a whole bunch of different  
151:58 - directory trees. And that's the environment. 
So that's the new path that we'll be using and  
152:05 - installing project of installing packages into. 
And the reason I know is working is because  
152:10 - I've got parentheses followed by the name of 
the virtual envy. And now that is ready for  
152:15 - me to start installing things. So just 
a bit about package manager called PIP,  
152:21 - they've got the pi pi library here. And you 
can easily find packages by a simple Google.  
152:28 - Or you can go onto the main website. 
And you can simply search here. So one,  
152:36 - normal, regular one that you'll see is pillow 
that allows you to work with images in Python,  
152:42 - we've got recorded, this is one that we'll be 
using in this in the next video sorry, requests  
152:46 - I want, which is a library that allows us to make 
API calls. So in conjunction with other programs,  
152:53 - you've got another one is Django rest 
framework. Oh, what have I done there.  
153:03 - There you go Django rest framework, a very, very 
famous third party package that you can install  
153:07 - that allows you to use Django just which is a web 
framework just as a API back end. And then you can  
153:15 - link the web framework with a front end 
such as react, for instance, anyway,  
153:19 - that is P IP, that is a package manager, and we 
install from there using P IP to the PIP command.  
153:26 - And that's actually install have already done 
virtually in V wrapper. Let's go pip install  
153:36 - requests. See that just behind my head, there are 
pip install requests that will go about an install  
153:43 - requests into that environment. I might as well 
just open up the environment whilst we're here.  
153:51 - C Drive users, Bobby, in V invece. Well, 
we got Python course Python course.  
153:58 - Lovely. Okay, so this is the environment 
we've got fired up. If you go into lib  
154:03 - site packages, a lot of these 
packages, can you see that very well.  
154:09 - That's probably a little bit easier, right? A lot 
of these packages come straight out of the box,  
154:14 - right? So if I'd shown you this before installing 
requests, it might look a little bit different,  
154:19 - but we've just installed requests, can you see 
that going to requests and this is the requests  
154:25 - package, there's a load of pi files all working 
together. All we need to do is now import request  
154:30 - as a module into our project and we have full 
access to all of these files, all of the classes,  
154:37 - functions and everything else has gone on 
as function funky in that package we have  
154:41 - access to if we install it into our project, 
it has come up with a command here saying  
154:48 - you can upgrade PIP so we need to do is just 
copy that part there. You see that? There we  
154:54 - go copy that whole part there. And that 
will go ahead and it will ask They Pip.  
155:01 - And that's all you need to do. So that is virtual 
environments. I hope I did it justice hope you  
155:06 - now understand why we actually use them. It's 
just the way of containing all the dependencies  
155:12 - of your project in a nice little bubble on 
your machine, a nice little directory tree,  
155:16 - so that you can access them willy nilly, 
and that I can deactivate. The activate  
155:26 - that. So now I know the virtual environment is 
no longer working. And I can say work on demo.  
155:33 - There is no virtual environment called demo, I 
think there is called demo one. There you go.  
155:36 - So I've got another virtual environment in there 
called demo one. So I can turn one off and turn  
155:40 - one on, turn one off, turn one on. And that's a 
good way of just working on different projects.  
155:44 - So I won't drivel on any longer than I need to. 
That's the end of this video. Thanks for watching.  
155:48 - Hope you've enjoyed it. Hope you found it useful. 
And I'll see you in the next video where we're  
155:52 - designing and writing our very, very first program 
in this course. Thanks for watching. Bye bye.  
156:04 - Guys, so we write in our first project today, with 
everything we've learned throughout this course,  
156:08 - it's opened up VS code has opened up a project of 
P why you won't find that in a GitHub repository,  
156:13 - because I want to be coding this myself. So 
you can follow along with how I think and also  
156:18 - see how poor I am at typing. Okay, so you'll be 
following along with this one hopefully won't be  
156:22 - too clunky. But the previous videos have been 
all prepared beforehand. This one hasn't. So  
156:31 - hopefully you will see what I'm trying to do here. 
So the project will consist of us writing an API,  
156:37 - which is an application programming interface. 
So our program will be talking to somebody else's  
156:42 - program. In this case, it's the Chuck 
Norris API. So we'll make a request,  
156:46 - and it will respond a joke. Can't be too bad, 
right. So we will be using the requests library,  
156:52 - which is something we installed in 
the last video into virtually envy,  
156:55 - that is a library specifically for this. So we 
use requests to make get post PUT and DELETE  
157:01 - requests to API's and get the response. So that's 
what we're going to do. So if I open a terminal,  
157:08 - if I go work on Python, course, that will fire 
up the virtual environment, because I've got the  
157:16 - parentheses there. And if I now put PIP 
freeze out list, everything is installed  
157:24 - in that virtual environment, you can see here 
we've got requests, because we installed that  
157:27 - in the last video. So happy days this close 
that down or minimize that we don't need it.  
157:32 - So if you watch the models, video modules 
video, say, you will know that we can now import  
157:37 - requests, because it's in a virtual environment. 
So it's in our extended directory, directory tree,  
157:44 - we will also import now we'll leave it as 
requests. So I'm going to using classes, because  
157:53 - I want to show you a base class in a real world 
and a derived class. So here's a base class to  
157:58 - make the request to make the call. And 
I'll use the derived class to actually  
158:04 - build the request itself, and then maybe call 
a function a solid method in a base class. So  
158:09 - that's what we'll try and do, we'll be using 
an if statement maybe or a match statement,  
158:14 - we'll be writing or raising a type errors or 
exceptions, and use an F string. So it'd be  
158:20 - basically using a lot of the stuff we've 
learned not everything but so you'll be  
158:24 - able to see that I'm using certain things that I 
know, from my Python skills and actually writing  
158:30 - a program with it. So without further ado, 
let's jump straight into it. So this class,  
158:35 - we'll call this API call, nice and 
simple. And we use a text literal to say,  
158:44 - base class to make a basic API call with requests.  
158:55 - Happy days. And then what we'll do is so 
the method we'll use this will kind of be a  
159:03 - global method, that will be a eight. We can 
use this across numerous API's. That's why  
159:07 - we're putting in a base base class. So this one 
just needs to be a method that allows us to call  
159:15 - and will pass yourself. So a password the instance 
of itself and what we need to have posted through  
159:22 - be the method to get post put 
delete. So method, and also  
159:29 - the endpoint the API. So API, yes, got a 
URL. Okay. So, first thing we want to do  
159:36 - is do a if statement, we'll do 
an if statement. So if method.  
159:46 - method equals equals no method lower, so we don't 
know if there's going to be uppercase or not.  
159:52 - equals equals get. And we'll do something. So 
get we will make the request itself. So our dot  
160:01 - requests dot get more parser API URL. Okay, nice 
and easy. Now we could use an else statement.  
160:13 - I'll use a raise exceptions later on this won't 
be is something that you can use, you'd have to  
160:17 - change this if you're going to use this in your 
own program, because we need to capture the post  
160:20 - the PERT the Delete methods also. So we're not 
going to use an else or an if else or anything  
160:26 - like that, because to save time, but we will now 
do a match on the response. So with requests,  
160:36 - you get a status that you can tap into a status 
status code that you can use to check whether  
160:42 - or not the API call was a success or success is 
200. Or two, I want to it depends on the API.  
160:50 - But we want to check to make sure that the status 
code of the API response is 200. And if it is,  
160:58 - then we'll return and if not, we'll raise a 
Type error. Okay, so match our dots status code.  
161:11 - There we go. And we'll have a case statement 
for this. And that will be 200. We'll have a  
161:17 - little bar to I want is basically saying 
or, and in which case, we want to return.  
161:29 - And we just this just return a 
string. Now it will be our dot Jason.  
161:37 - And I think it comes back as text. 
Obviously, this is all you can change this  
161:42 - as value. So this particular API 
is it returns a response, Jason,  
161:48 - you can then get the text specific text for 
this called value. Now, obviously, that's  
161:53 - not gonna be the same on every API. But let's 
assume it is for this, this example. And then  
161:57 - we'll have another case statement, which catches 
everything else. And we'll say res type error. But  
162:08 - we just say, API error, shall we. So it doesn't 
come if it doesn't come back as 200, it would  
162:16 - just raise API error. Not the best description. 
But you can imagine using you can use different  
162:23 - exceptions and different strings and what have 
you. And it can just basically work through the  
162:28 - different exceptions. So this is the cool method 
that we'll be using in our derived class. So in  
162:34 - upper class, and we'll call this Chuck Norris. And 
we will be putting API call in them because this  
162:43 - is the base class for the derived class. We'll 
have another text literal, it will say, this is  
162:50 - the Chuck Norris API doesn't really know for this 
example, but you can add a description. Okay, so  
162:59 - we want to club because this is specific for Chuck 
Norris, we can have a class variable called URL.  
163:06 - And what I'll do HTTP s, and this is API dot API 
dot Chuck norris.io. That's not going to work.  
163:21 - I still IO slash jokes, slash 
random. Call Westermarck cat, gory,  
163:31 - equals, okay. And then what we'll do, we'll 
construct an API URL by using a placeholder, okay,  
163:37 - and I'll show you what that means in a second. 
Categories, equals and we'll have we'll just have  
163:46 - animal and also they have one called dev as well, 
they have more but we'll keep it as dev animal.  
163:53 - And then we will not going to add 
that now we will have done doing it so  
164:02 - in it partially self as we normally do, 
and we'll also pass through category  
164:09 - because this will allow us to instantiate the 
class with animal or Dev, okay, so we'll have self  
164:16 - dot category equals cat that glory, there 
we go. And then now you could have if not,  
164:28 - self dot category in categories 10 I will 
write it cat self dot category sorry.  
164:39 - So this is if instance variable is not in class 
variable categories, then we can then raise  
164:47 - TypeError. Cat, not  
164:54 - options. Animal Okay, so that's 
just the typo that will be shown.  
165:06 - Now we'll have DEF, and we'll have this one called 
Get or parser itself. So this is the get request  
165:11 - for the derived class, you can also have a post 
request, PUT request. Well, it depends on what  
165:16 - you want to do and how you want to construct it. 
But essentially, the first thing we want to do  
165:19 - here is we want to construct the API URL. So we 
want to use an F string with placeholders. And  
165:27 - the first placeholder will be self dot URL, 
because that is the class variable we've got here.  
165:34 - Okay. Second one, we want to pass through the 
category that we're passing through. So self dot  
165:40 - category. Okay. And then what we can do is return 
self dot cool. This is the base class function.  
165:50 - This one here, you see, we need to pass through 
method API URL. So we will go these positional  
165:58 - arguments, we don't need to use keywords. So we 
can put get, or you can even put get like that,  
166:04 - because we're actually using the lower method. And 
then we'll have API URL, we don't need to use self  
166:11 - because this this is just a variable that we're 
using within the function there or a method. And  
166:19 - is that coming through value? returned on Jason?  
166:30 - Yeah, no shit, don't just just return 
the strings. And that'll be just string.  
166:34 - That looks like it could work. Okay, so I'm 
gonna make, I'm gonna go ahead and test that.  
166:39 - Hopefully, that'll work. So let's go to terminal. 
And what we'll do, we'll go work on Python.  
166:47 - Course, that will fire up the virtual 
environment, I know that I've got  
166:50 - parentheses followed by the name of the 
virtual environment. Now we'll fire up our  
166:56 - Python interpreter. So we can use the modules 
import, so import projects, or project,  
167:04 - which is this file here. Okay, so we're importing 
project into the Python interpreter. And now what  
167:10 - we can do is we can go to API call dot 
doc. API call not found also be projects  
167:27 - dot API call, dot doc. There we go. So 
that we use in the Dunder doc method,  
167:35 - Dad's just to print out the text literal. 
Actually, what we'll do is import know from  
167:41 - from, it doesn't matter. It doesn't 
matter. Okay, so we now have access  
167:46 - to these classes in our Python interpreter. 
So now what we'll do, we will instantiate  
167:51 - Chuck Norris to a variable c. So he if 
we go, project, Chuck Norris. And women,  
168:02 - we need to pass through a category. So if I 
just put a he'll come through and say, Look,  
168:07 - category options, animal death, because we've got 
the TypeError. If we were to put through animal,  
168:13 - we now got C. So I can say see, dots. Get our 
call it get Yeah, there we go get and we'll  
168:24 - pass through. Actually, we don't need to pass 
or anything was work. Happy Days, it works. So  
168:33 - we just call the get method, the get method 
is constructed a URL, and then it's called the  
168:37 - self cool method from the base class pass, we get 
the new URL, and then it's going around in Bali,  
168:42 - this match statement. So it's matched, we used 
an if statement for the actual GET request,  
168:47 - we could use a match statement. And then we use 
the match statement with a case statement to look  
168:52 - at the status code. If the status code matches all 
of this, then we get the value keyword from the  
168:58 - JSON response. And then we just return it into the 
Python interpreter. So what is that joke? Well,  
169:03 - we got they say curiosity killed the cat. This is 
false. Chuck Norris killed the cat, every single  
169:10 - one of them again, and then you can do it again. 
Oh, always coming back for the same or no, this is  
169:17 - the same one the first time and then it made 
another call. So Chuck Norris once wrote a nine  
169:21 - foot grizzly bear for an automatic carwash instead 
of taking a shower. Okay. Should we make one more?  
169:28 - Oh is the same one that keeps 
coming up with the same one.  
169:33 - There we go. So that works. That is the project. 
You can see. If we go back to the code here,  
169:39 - you could easily just create a new 
class. We could call this NASA.  
169:51 - Yeah, we can make an API call to the NASA API. We 
would just need to change the URL would change the  
169:57 - categories if that was indeed the case that there 
wasn't categories of was a few different sorts of  
170:01 - categories. I know in a nicer API, they've got 
different cameras, and what have you. So you  
170:07 - might just configure the class slightly different. 
But what won't change or possibly won't change is  
170:13 - the cool method in here. And if it was to change 
slightly, you could overwrite it or extend it in  
170:20 - derived class. Okay, so I'm really happy with 
that that actually did work really, really well.  
170:27 - So that is the end of this course, we've written 
our first project is an API call to the Chuck  
170:36 - Norris API works really well. We're using classes, 
base classes, derived classes, match statements,  
170:41 - if statements, we're using strings, we're using 
all sorts of stuff, we're using lists here,  
170:48 - you can even go one step further. And you can, you 
can maybe do a random pick of all of the different  
170:52 - categories. So you always got a randomized 
response rather than animal. So when you  
170:56 - instantiate it, you won't get similar jokes. But 
hopefully, you can see now from this project that,  
171:03 - you know, the world is your oyster, just play. 
You've spent the last few hours going through  
171:08 - this course, I've showed you the absolute basics, 
what I think are the fundamentals of understanding  
171:13 - Python. Okay, take what you've learned, write 
some programs, that is the best possible way  
171:19 - that you can learn how to code in Python. Also, 
always reference back to this cheat sheet. I'll  
171:26 - say it again, you can clone this down from my 
GitHub repository, this is your cheat sheet,  
171:30 - please, please, please use it in two years time, 
or two months time, you might look back and go,  
171:37 - ah, what did I What was that about dictionaries? 
What is that about? tuples? Why can't I do X,  
171:40 - Y and Zed? What the methods did that whatever the 
case may be, you've got a cheat sheet to clone it  
171:45 - down. It's for you or made it for you. So like 
I say, this is the last video. This is the end  
171:52 - of the course. I've thoroughly enjoyed putting 
it together. I hope a truly hope that you've  
171:58 - enjoyed watching it. Please, please please get 
in touch if you have any questions whatsoever.  
172:03 - Thank you very much for watching, and I will 
see you in the next course. Thank you. Bye bye

Cleaned transcript:

You're about to learn the Python programming language from scratch, you'll learn everything from setting up your system to program with Python to working with API's, Bobby Stearman from dig coding teaches this course. Hi, everyone. I'm Bobby stemming from decoding. And this is my Python course for beginners. So if you're looking to learn Python, or polish up on some skills you've already got, then you are in the right place. Because in this course, we'll be covering topics such as setting up our system to use Python, we'll be looking at numbers, strings, data types, control flows, classes, and all the fundamental things that sit in between. And before we close off the course, we'll then use those newfound Python skills to write some Python programs. But before we jump into it, I just like to say a big thank you to the guys at Freako camp for publishing this course, you guys are fantastic, you're doing an outstanding job, keep up the good work, and also keep that content coming that is absolutely free. So without further ado, let's jump straight into it. So you can see here that I'm on pythons main website, this is python.org. So this course has been designed around their own documentation. I've extrapolated out the parts that I feel are the fundamentals for you as a beginner. But we will be becoming familiar with their site because like I say, I've referenced the documentation quite a lot. So if you visit python.org, hover over downloads on the nav bar, you can see here, it's given me the option to download three, point 10.2. That's the latest and greatest stable version of Python as of the time of recording this video. So if I click that, that will download an installer, minus download. And it will say that as you become better at Python, and you become a freelance or a software engineer, then you will start working on projects that may have been built some time ago, in which case, you may need an older version of Python on your machine. To do that, hover over your machine, type on the left hand side and click that will take you through to a different page and you have all of the different releases that you can download. So for instance, if I wanted to download 3.9 point 10, I could click this here and it would download the installer and I can go about and just install it in the same way as we are now about to for three point 10.2. It's a little bit more advanced than beginner, but I thought it'd be worthwhile just noting it down. So the installer is hit and ready to open up. Okay, so it's given me the option. Let me just zoom in a little bit that you can see that a little bit better. So it's giving me the option to install now. Now you can click that and it will go ahead and he'll install Python in that path. I don't find it very intuitive. I like to keep Python in my own path of choice, because if I want to download more versions, I know exactly where they are. And I can just flick between them as when necessary. So we're going to go with custom install. And we're also going to click the Add python three point center path. Because if you're using let's say a web framework, such as Django, Django, we need to look in your environment variables in your path to understand where Python is on your machine. So it's important we click that OK, zoom out quick. So we will click that, click on Customize. And you can see a whole bunch of things ticked, just keep them ticked. Okay, this is the first install that you've done. So let's get the documentation that's get a package manager called PIP. We'll be using that later on in the course. So keep that ticked. Okay, and keep everything else ticked for now. Click Next. And then we've got zoom in again, we've got a few other options here, just keep it as as you can see that the fourth one down, says as Python, add python two environment variables, that is important, we'll do that. Okay. So all we need to do is click on Browse and change the customized install location. So I'll go ahead and do that. And I like to keep my Python versions in my PC, C drive. And in here, I'll create a directory called Python. session which contained by Okay, we got one cool place and have we we have Okay, great. We will then go in there and create a new folder. And we'll call this Python. We tend to click enter. So if I was to install Python 397, I'll create a file called Three point 9.7. And I'll install all of the Python packages and files and configurations in that directory. So it keeps it all in his own little container so you can keep flicking between them. Okay, that's why I do it that way. So we click that, click OK. You can see now where it says customize install location is now changed to Python, Python 3102. Okay, now we want to click Install. There we go. It shouldn't take more than a few seconds, but that's now going ahead and it's fetching and installing all of the Python bits and bobs and adding it to the directory that we just created. And to test to make sure that it is on our machine present correct and working as expected, we need now need to fire up what's called a command prompt on Windows. Now it's called a terminal on Mac. But you, you fire it up on Windows by going to the search bar and just type in CLM, it'll come up with command prompt. Mine looks a little bit different to what yours would because I've changed the settings, yours will probably be black. But all you need to do is type Python, put python three or three point 10. If you're on Mac or Unix, you put dash dash version. Okay, actually, because we've got the pi dot exe file installed from this install, we can actually reference on a Windows machine machine, Python with pi. And that should still give us python three, point 10.2. You can see that there you go. Happy Day. So we've now installed Python on our machine, we're now ready to start looking at the interpreter, which will then start looking at things like text editors and IDs and things like that. So let's call it a day with this video. And I'll be seeing you in the next video. So I'm on a Windows machine. So I'm using a command prompt. So if you are on a UNIX, Mac or Linux, then he is a different command to me when firing up the interpreter or using just general Python commands, you'd use python three point 10. Now I use Python or p y. The reason I know I use the command p y is because this paragraph here, I installed p y dot exe launcher in the last video I put together which we use to install Python on our machine. So when I'm on my command prompt, and I'm typing things such as p y dash dash version, you would put python three point 10 dash dash version to do exactly the same thing. Oh, typo there, but you see what I'm saying? Okay, so let's fire up the interpreter with p y. This autonomy, the interpreter is open. And in interactive mode. That's what these three great n symbols are telling me. So give me some code, I want to do something with it. But before I type into it, this understand what the interpreter is doing. So as I typed Python code into this interpreter, it's translating it into a universal language Binary. Binary is ones and zeros. Yeah. And like this. difficult to read, you can understand this is the programming language that software engineers used to use back in the day when writing programs 1000s and 1000s and 1000s of lines, ones and zeros. Joe Average could not just sit on a seat and start coding, it's a pain in the ass. Okay, so and it wasn't very scalable. So from binary, the assembly language was put together and this kind of streamlined binary, it allowed you to use much more easier to understand commands to do the same thing. But assembly languages weren't transferable between machines. So my Windows assembly language didn't work on a different operating system. Okay, so then high level languages were designed, okay. And this took the assembly language to the next level. This allows programmers to write code in a humanized way in an elegant way to a cent and then translate it to binary. Okay, so that's what so these high level languages, PHP, C++, you've got Java. And of course, you got Python, right. So these languages allow us to code in an elegant way, and then things like the interpreter, but then translate that into binary code. So our machines know what you're trying to do. Now, I hope it didn't just butcher the explanation. But I've just tried to break down what the interpreter actually doing. Because when I started, I didn't get explanation, I just wondered what the hell I was doing, I just start typing away and it magically done something in the background. So I hope now you understand what it is and how it works. But before I close this video off this just buyer in some code, and just see it working, so I can just put a simple one plus one, so integer plus integer, in this case, one plus one, if I press Enter, it will then run that command. And the result is two. So we can go 10 multiplied by six, or we can use the multiplication operator, which in this case is a star, press enter, and it spits out 60. So that is the interpreter, okay. All it's doing is taken our code, in this case Python, and it's just translating it so that your machine can do something with it. Okay, so let's close this video off. In the next video, we will start looking at text editors and it is so thanks for watching. I'll see you in the next video. Bye bye Okay, so my browser is open on microsoft.com on our Visual Studio Code page, because we will be installed in VS code. In today's video vs. Code is a text editor. Now we use text editors. Because in the interpreter, we can easily write single lines of code. We can run scripts, but it doesn't really help us with things like syntax, errors and debugging. That's where text editors come into it. And also, they will help us as a developer manage things like directory trees and the hundreds of files. Okay, that's why we use text editors, there are apps that we can install that help us just do our day to day job. Now, IDE, which are integrated development environments, take text editors to the next level, they do everything that a text editor can do. But with all the bells and whistles, so they help you with things like debugging, and deployment. Okay, I will be installing a text editor called VS code because it behaves like an IDE because it has been called extensions. And it's fantastic. And in fact, the reason I'm installing VS code is because on their own website, they've got a tool here, that helps you decide what's best for you, based on what you do. Okay, so under the languages, platforms and workflows, you can click, so you can click the machine you're using, then the languages, platforms and workflows, you can click, in my case, desktop, Python, JavaScript. And it's telling me that the right job for what I do or sorry, the right app for my job is download Visual Studio code. So let's go ahead and do that. It will download the installer, redirect us First, download an installer. And then if we open that, I'll open up the installer, I will zoom in because it's quite small on my screen here. Okay, so it's asking us to read the T's and C's, please do that. It's always worth doing that I've already read them. So I'm going to go ahead and click the I accept the agreement. Click Next. It will then ask you where you want VS code to be saved, I'm going to go ahead and just keep it with the default, it then asks you to was this select Start menu folder, just keep that as next it's fine, then it's giving you some extra options. One of them is quite important is telling you to add it to your path. So same as installing Python, let's get this added to our PATH environment variable so that it's accessible, and we know exactly where it is on our machine. And then if we click next, it will summarize and we can then click Install should only take a minute or two. But it's now installing all of the files and all of the configurations in the path that it suggested. When it's done, it asks us if we want to launch VS code, we will keep that text and click Finish. And in a future video, I'll show you how to open VS code in a certain directory as and when necessary. So I already had an instance VS code on my machine, and it's opened up in the directory, which is going to be the cheat sheet for this course. And you can see that it's got all of the different topics that we'll be going through. But this is VS code, okay. So if I just zoom in a little bit, there we go, we've got an explorer, here, we don't necessarily need to open, it doesn't really matter. So we've got an explorer, tab or panel, we've got a panel here that we can actually write straight into. So if I open up a new file here, and just put hello with an extension P why, because it's a python file that I'll open this up, and I can write straight into it. Okay, but what is beautiful about VS code is we can install a an extension that will help us with syntax errors, click Extensions on the left type in Python, that'll give you a whole bunch of Python extensions. Now I've got this one installed. It's called Python. And it's been installed by over 50 million people actually, I looked at this the other day, and it was 49 and a half million. So there's a lot of people installing this extension. So not that, you got to assume that 50 million people can't be wrong, right. So it's good, it's gonna help you with syntax errors, get it installed, or select another one and get that installed on your VS code instance. And it will help you with syntax. Let's go back into the panel here. And also was good about VS code is got a terminal built in. So where I've got my command prompt here, let me close that down, I will open up a terminal. Mine defaults to CMD. Because I've changed the settings, yours might be PowerShell. But you can select the type with this pulldown list, click Command Prompt. And then you can simply put p y, happy days. Now I can type straight into here, one plus one. And you can see that that works. And you can see here that actually this is what is under underlined squiggle here or underlined squiggle. It's telling me that actually that's a syntax error, and that's coming up as a problem and is explaining it here. That's because we've got the extension installed. So that is done right Got a text editor installed on our machine, we've got VS code installed, we've got a text editor, we now can start coding in Python. In fact, whilst I've got this directory open, you can see that we're going to start going through these files and talking about each of the topics in detail using VS code. So that marks the end of this video. Thank you very much for watching. In the next video, we will install Git Bash. And the reason we'll install Git Bash is because this repository is on GitHub, and you need to clone it down to get access to it on your machine. So thanks for watching. I'll see you in the next video. Bye bye. So Git is a version control system. And with Git installed in your machine, you can manage version control using places such as GitHub, GitLab, and BitBucket. Okay, so it's important you got git on your machine, I have already got 2.3 5.1 on my machine, which is the latest and greatest version at the point of recording. So I won't be following along with this video because it gets a bit clunky, and it switches my video off and it's just not pretty when you're trying to watch and follow along. So I'll show you the steps get installed, get get installed in your machine and come back to the video. Okay, so click the link here. Oh, sorry, right, we are on get dash scm.com. Okay, that's where you will find get. And you need to click on a version of when get for your machine type miners window. So click on download for Windows, when you get redirected, click on the link that is the right one for your machine. Mine's a 64 bit Windows, so I need the installer. For that, I would click this here. And that will download the installer. When downloaded, open up the installer and follow along with the easy step by step guide. And that will get gets on your machine. Okay, so now that you've got get this open up VS code in the correct directory, or in your directory that you want this to be, I want mine to be in my course directory, click here. This is an easy way of opening an instance of VS code without opening and then scrolling and trying to navigate, type CMD. When your command prompt opens, just put code space period and that will open an instance of VS code in your development directory. So now we need to clone down so open a terminal from a drop down, open up Git Bash. Now you'll only have this option if you've got git on your machine. So that's why it's important. You've got Git. Okay, so now we want to use the command git clone. And then after that, we need to dump in there the URL of the repository. So in GitHub, the repository that you want to look for is github.com/bobbyd, coding slash Python course for beginners, this is a public repository, and all of the documentation is in there. Okay, so we've got all of these different Python files. So click code and the main branch and copied this code here, open up VS code, dump it in there, space, full stop, and that will clone down a repository into your directory. It's asking me for a passcode. Because I've got an S H. SSH key. There we have it. Okay, so you probably won't get asked for a passphrase. And no bother. So this is the supporting documentation. So there's open up one of the first ones we'll be looking at numbers. So numbers dot p y, this is the first thing we'll be looking at. These other supporting documentation, use these as cheat sheets. So at the end of this course, you can always refer back to these files, make your own notes, it's really, really helpful. I do use cheap seats, there are some certain things that I might not necessarily use on a daily or weekly basis, I just need a refresher. So that would be my advice, save these on your machine and keep referring back to them. So that is the end of this video. Hopefully now we'll be ready to start really jumping into this course, and start looking at Python code itself. And we'll be signed with numbers. So thanks for watching. I've enjoyed making this video. I'll see you in the next video. Thank you bye bye so I've got VS code opened up on my screen here in the file called numbers dot p y. There are a few of these files in the supporting documentation that we cloned down from GitHub in the last video, but we're looking at numbers. So we're close the Explorer because I want to use as much real estate as possible. You see here I've got a terminal with the interpreter up and running. Okay, that's what these great symbols mean. You do that simply by if we put exit Hello myself though a little bit in their terminal or command prompt, just put p y, if you're on Windows, and there you go, there's the interpreter. But we'll be using the interpreter to take an input and return an output. So the input will be a sum, the output will be the result. That's what we're doing. We're using it as a calculator. In Python, we have a whole bunch of operators that we can tap into. Let's make a bit bigger. We've got the symbols, that's the operator and what it does the description here, okay, so we've got pluses addition, subtraction, multiplication, nice and easy, right basic stuff, division. Now that will always return a float, which is a number type, we'll talk about that in a second. So 10 divided by four be 2.5. Floor division is the same but returns the integer version, so four divided, so 10 divided by four would be two, so 2.5, remove the decimal and a five is two. So less floor division modulus is the remainder of 10 divided by four, which would be two, so that's the remainder. So four goes into 10 twice, the remainder is two, so four plus four is eight. The remainder is two, as modulus, then you've got power of so star star is if you put a five star star two would be five to the power of two. So five, times five, five star star three would be five times five times five, which would be one to five. That's power of you've then got assignment operators got equals, okay, yeah, there are other ones we've got equals equals got equals great and, and so on and so forth. Now, if you go to pythons doc page, if you look up here, we've got Doc's dot org slash three slash tutorial slash introduction to HTML, that is pythons documentation, to an introduction to numbers. I've extrapolated everything I feel is basic stuff, you can do a deeper dive on their docks, please feel free. This course has been designed around that documentation. So I wanted to give you the very, very basics, okay. Okay, so got number types. But integers, we've got floats, integers are whole numbers. Floats are numbers with decimal places. Okay, you've then got fractions. But again, this is a beginners class. Okay, so look at INTZ and floats. Today, you got some built in functions we're using round today. So if we were to use round function on this number here, you could pass through a number and then pass through the amount of decimal places you want. And it will, it would return the rounded version. So for instance, if I pass 5.6667 data, there are three to this function here, as the number change decimals to two, that would return 5.67. Okay, we use in dev mode, we're also going to use what else power. So these are a couple of other functions that we've got here that are built in to numbers, really, really helpful. dev mode returns a tuple of the result of the floor division, and modulus. So dev mod 10, four would return to two. We'll look at that in a second. Lastly, before we jump into actually throwing in inputs and getting outputs, Python is a really handy way of representing large integers. So 4 billion, which looks a bit hard to read, can be represented as this for underscore three zeros, underscore three zeros underscore three zeros, I think is a really handy way of representing large numbers, especially if your code in so Okay, let's look at some of these basics here. And we will dump them straight into the interpreter. So anything that comes after a hash is a comment and the interpreter knows to ignore it. Okay, the comment is for you. Excuse me. So two plus two simple addition is four, five minus two is three, seven times 10 is 70. Simple stuff, right? All we're using is the interpreter as a calculator, then you got division, so 10 over four would be 2.5. Okay, which is a float 2.5 flow mod is the same calculation, but rather than 2.5, it would be two because it would disregard the decimal place and 510. Modulus four would be two. Okay, and then div mod would be two and two. Because it's this sum, this sum of 10 and four, they show you what I mean. Go in here, right click, press enter. Fine. Now. It's a bit hard when you zoom so far in when you're doing a screen share too. Show you what we're doing here, right so 10 over four is 2.5 10 divided by four 2.5 10 floor division over four so 10 With flow division four, b two, because rather than 2.5, you're removing the point five, that leaves to 10. Modulus four is four goes into 10, twice, whole, okay? That gives you eight and the remainder of that sum is two. That's why it's two in dev mode, which is a built in function is doing floor division, and then modulus. So 10, we possibly 1014 is essentially doing two calculations, two, and two. Brilliant. Again, you can spend as much time as you like adding these into your own interpreter, you can always add other sums to give you a much better rounded knowledge of numbers in your own time. But there's a kind of a simple walkthrough for you as a beginner. Okay, I now copy this, these are fancy some, so think of BOD mass when you're looking at these sums. So brackets are the division, multiplication, addition, subtraction in that order. And what will happen is, oh, let's copy this copy, there we go. So it will do this part first, because that is the multiplication. So five times six is 3050 minus 30, is 20. It will do this first because the brackets, and I will do this inside the brackets first, because there's multiplication. So it's 50 minus 30, is 2020 divided by four is five, which is division, so it would turn a float, then you got five times three plus two, so 15 plus 270. Okay. I say five fancy, some sums can get a lot more fancy than that, then you have five power of two, which would be 25. And I did say earlier, five, multiple power of three would be one to five, which is correct. So two to the power of seven is one to eight, if I remember rightly, that was more than that, oh is one to eight. But you can also use a built in function called pal, which saves the use of the star star, I don't know what's easier to read, but two to the power of seven, returns the same as one to eight, then variables. So it's not really numbers, but you can assign anything to a variable. And today, we were assigning numbers to one. So 60 is assigned to the variable width, we're using that assignment operator, height equals 21, three times seven. So width multiplied by height, I think is 12801260. There you go. I was tinkering with this earlier. So rather than doing 60, times by three times seven, which is essentially the sum, you're assigning the numbers to a variable, and you're using the variables to do the sum itself. Okay, which is all fun. And lastly, before I close off this video, let's look at this. So in interactive mode in the interpreter, the last printed expression, which is really handy, gets saved to an automatically saved to a variable underscore, so you don't need to assign it at all it knows to assign it to an underscore variable. So we bought this into the interpreter. Okay, price times tax has now automatically been assigned to underscore, okay. So if I can, if I now do price plus underscore hope it's just type it in RBZ. There you go. So price plus underscore is one, one 3.0 65. Now that expression has been saved to the variable underscore, so you see how they've gone underscores and consistent every expression on the last one is assigned to it. Okay. Now, if I use round, it's not liking it. So I type it, round, underscore, comma to remember that function we looked at earlier. There we go. Round underscore, underscore is one one 3.0 65 decimal places to says One, one 3.06. Okay, so this is my whistlestop tour of numbers. Okay, there's a lot more to learn. There's fractions. There's all of the different operators, you can do really, really fancy sums using numbers. Please look at the documentation on Python. There's no better place to learn numbers than Python numbers page. There's like I say this is just all for beginners. So keep the supporting documentation add more notes as you find something else that is interesting. But that is the end of this video. Thanks for watching, have enjoyed making it and I'll see you in the next video which will all be about strings. Bye bye. So again, I've got a VS code instance open on my screen here in settings dot p y, which is one of the files we downloaded or cloned from GitHub. We look in the Explorer here. You can see there's a whole bunch of other files, but we're looking at strings today. So Python can be used to manipulate strings, which can be expressed in a few different ways. They can be enclosed in single quotes or double quotes. So it doesn't matter, it is still a string, if expressed in one or the other way. Now, a backslash is used to escape out of a string, or a quote should I say, and that's really helpful. And one of the examples that I've got in a moment or two, because there's certain words that use this A and apostrophe, and if you're using single quotes, then you can imagine that you're in a whole spot of bother with that string unless you escape out. Okay? So Python strings cannot be changed, they aren't immutable. So you cannot isolate a character in a string and replace it with something else. Okay, you have to create a new string altogether, which is completely possible, we'll be looking at a built in function called Len in this video. Now Lenny's really helpful, you can use it on strings, lists, dictionaries, tuple sets, and it returns the number of items or characters in any one of those objects. Really helpful with strings. So if we called Len on my name, which is Bobby, it will return five because Bobby has got five characters in it. Okay? strings have a whole bunch of methods. Now these are really, really helpful. Okay, so I've listed out all of the different methods that you can use on a string. So for instance, capitalized there, you've got a bit of space. So if I put bA, bB y as a string, capitalize would return Bobby, okay, as a string, really helpful method to use. And you've got a whole bunch of other stuff here as well, you've got case fold sent accounting code. Where else other examples so that he got right at the bottom that you got apart. So that would just be Bobby would return. Bobby is all uppercase, okay. So really helpful methods when managing strings, you'll be using them a lot. Okay, you now need to open up a terminal and open up a interpreter. So I mean windows at p y. I've got my three Greatland symbols there. So it's ready for an input. So I've got a few examples here that if I bought them straight into the interpreter, we can see what's actually going on here. Okay, so the top here, we've got sperm and eggs in single quotes, as an input, so the output is a string, span x doesn't has an apostrophe, okay, so single quotes, single quotes, because we need to use a single quote in the string, you need to escape out using backslash, and it converts the single quotes or double quotes, and then you return your output is doesn't have double quotes, really helpful understanding the backslash. Or you could just write that string as double quotes, and you won't have any problem whatsoever. Now in this example, we've got double quotes in the string itself that haven't been escaped out. So of course, what gets returned is that whole string, the double quotes within the string are characters. way you can escape out and use the double quotes. In the string itself, sorry, would be to use the escape and it changed the double quotes to single quotes. That is pretty much the polar opposite of the dozen example. So if we had single quotes, we use an apostrophe in that example, we use in double quotes. And actually, we want to use double quotes in the string. And in which case, you need the escape, backslash, okay. If you look at the documentation on Python, if you look in 3.1, point two, on docs.python.org/three/tutorial/introduction, that is their intro to strings, do a deeper dive in there, I've extrapolated out a whole bunch of stuff. Hopefully, that is just the basics that I've got in my video here. Okay, so next, we've got new lines. So new line is represented in Python with backslash n, okay, and it will just use the interpreter, it comes out as a single string, it just ignores the new line. But if you print it from a variable, it will pick up that new line and print it as first line second line in this example. So if I use this copy, puppet in there, so we're saving first line, new line, second line into an S variable, we just return s, it just prints out the return statement, it doesn't do anything. But if we use the print statement, and pass through S, then it picks up that new line. First line, second line, that's really, really helpful when you're trying to format certain strings to a user maybe in an API message, something like that. Right. Next, we've got raw strings. So we can use our for regular expression to print out raw strings because you can imagine a path here we'll have backslashes. And this example is a great one because it got a backslash n. So if we were to print that it's just going to Come out something silly, because we know backslash n is new line in a print statement. But if we use our as a regular expression, you can see that we see see some name has been done, see slash some, and then it's printed out this. But if we use reg x, then it's absolutely fine. Okay, string literals. So you can use three quotes, whether it be single or doubles. And that will print out everything under that. So it's sort of like a comment. So a comment is a hash, but it's a single line, string literal can can span numerous lines. And I've done that at the top of the page here for my description, okay, so that's what a string literal is. Copy that, dump it in here, that will print out exactly as you want it to be. Okay, then you got concatenated, basically glued together. So if we use the number three, multiplied by UN that would basically do un un un. And then the plus symbol, the operator in this case is concatenate. Now, glue, un un un with our UN. So that should bring that in there. There you go. You don't even need to use the operator plus, if it's two strings put together like that Python knows what you're trying to do. And it will actually join it together. The coding really helpful stuff. But that's really helpful when your strings in a text or parentheses there, span more than one line. Python knows what you're doing. And it will just join those together. Okay. So this only works for two literals though, not variables or expressions, so we're gonna have an error here, try and dump this in here. Okay, so it's basically because we've got a variable and a string, whereas what you need is two strings. So prefix equals dead, and then you got prefix with that, we then need to use the operator and then it will work just nicely, okay, so the removing the operator will only work for us in two strings. That's what I'm trying to put there. In indexing. So strings, so I keep hitting my mouse bonds really annoying. indexing. So we need to understand indexing for things like strings and lists, okay. And I love this, I took it straight from the Python website. But an index allows us to play with certain characters in string based on where that character is in the string by index. So the first point in a string is zero. And the last point is, in this case, eight or minus one, so you can reference the string from the front. So not one, two, or you can reference it from the back minus one minus two minus three. So when we're working with a word such as dead coding, if we go word, square bracket, zero, we're referencing the first index of the word dead code in which would be D. Okay, let's dump all of these in my interpreter and see ya spits out okay? So, so Right, so the word is decoding. So word index zero, that's the first as per this diagram at the top here. 012. Okay. Word five would be always printing out little D, so it's not 12345. So it's D, okay, so you can see that that's working, you can reference so if you put zero colon, two, that will be include an exclude, so it's include 01 and exclude two, which is Di, include 234, but exclude five. That's what that means. Okay? So be DCO. If you missed the first integer, in this expression, it assumes you mean zero. So that'll be 01 exclude two, which is Di, if you move, if you ignore the last integer, it assumes you mean the very last but that's a minus one. Okay? So that will be everything from four to the end. And then we've got some other examples there. Okay. So we've got minus four, so we're referencing minus one minus two to the end, which would be Engie. There we go. N G. And then you got you can bring these two together so you can join them together. So is everything up until but excluding to and everything from to everything to the end, you joined into it brings together decoded, and then again, you've got another one here, which is an example of bringing that together. Okay. So that's indexing is really really really helpful. So changing strings. So if we wanted to change so referencing the D, but assigning p it says none and and and I type error string object does not support item assignment is immutable. So, if what we do is have the string p plus word which will be including the first. So this will be everything from O onwards, that will work and we'll change it to peer decoding. Or equally, we can do this. The ID, di, di, di, okay, so we are just manipulating strings. That's what we're trying to do and demonstrate in this video. Okay, we use a lens. So if we look at Bobby decoding, which is the GitHub username, it's got 15 characters in that using the len function really, really helpful function, you'll be using that quite a lot. Handy built in functions. So when you don't need fancy outputs, but just want a quick display of some variables. for debugging purposes, you can convert any value to a string with the wrapper, or the SDR functions. So here's a list of just some handy little functions that you can you can use, okay, and here are some examples of what you can do. So x, y, y 400, what you can do is dump them in here. And that will just give you a really handy representation of what you're trying to achieve. Same with str, it will just change everything to a string. Okay. And then you've got which, there we go. So let's give those examples there. So we've got format, okay, so this, there's a bit of an explained explanation here. In python three, you can use the F string, which is F followed by two quotes. And then you can use placeholders placeholders to add variables. But you can also use format, which is valid for Python two, and three. And what we're doing here is we're doing a print statement, we're adding placeholders. That's what these squiggly brackets are. So it's placeholder and placeholder, and then dot format, which is the method and it goes in order. So the span will be injected into this placeholder and eggs will be in that placeholder. And equally, in a second example here, we're just changing them around. So nor is the first item one is the second item in this tuple. And that would just change it around eggs and spam. Okay, so that's my whistlestop tour of strings, there is more to go in and do a deeper dive on Python's website here. But do that in your own time, do a bit of bedtime reading. Okay. But that is the end of this video. I'm glad that I put it together. Hope you've enjoyed it. And I'll be seeing you in the next video. Thank you, bye. Okay, like always, I've got Visual Studio Code open on my screen in the list.pi file. So this is just one of the pages in my supporting documentation that we cloned out from GitHub a couple of videos ago, we don't need the Explorer open, we want as much real estate on the screen here as possible. So we'll be manipulating lists today. A list is a datatype. So there's four different data types that Python knows of lists, dictionaries, sets, and tuples. I'm going to do a video on each so I don't need to explain that explain the difference in them, except for lists are written as a list of comma separated values or items between square brackets. Okay, so a list will look like this, okay? That would be considered a list in Python, okay? Now, lists are mutable. So, unlike strings are immutable and tuples are immutable. A list is mutable, you can change and alter the items in lists. So you can identify a certain item, and you can replace it with something else. Okay? So they're mutable, which is really, really helpful. I have also added on all of these pages, if there's any methods that are associated to a particular let's say, data type, or let's say numbers of strings, or anything, I've listed those methods in the files themselves. So lists have got methods such as append, which allows you to add an element to the end of the list, you've got count, extend in next reverse sort, so on and so forth. When you have a bit more time outside of this video, just have a tinker with lists and just play with these methods. They're really, really, really, really helpful. Okay, so into the basics, we will need a terminal open and we will need a Python interpreter interact Interactive Mode. Okay, we've done that 100 times in this course already. So all you need to do is fire up three greater than symbols shows me that it's ready for an input. So this is a basic list and we're, we're assigning that to a variable called squares. Okay, so dump that in here. And now we can access squares by just doing that and it will just print out in the interpreter, the list okay. So that is a list in Python. Okay, we've then got it scroll down indices. So this is exactly the same as we went through in the string. I haven't changed this to a list. But essentially imagine that this is a list, you can change these two square brackets if you like. But essentially, each item in a list, you can reference by its index. So in this case, this is zero, this is one, this is two, this is three, and this is four in the same way as in the string, you've got 0123, and four, you can reference it from left to right, not 123, and four, you can reference it right to left, which would be minus 12345. Okay, same as string. But understanding indexing is paramount in Python is really, really helpful. So if we put squares zero, it would turn one, squares minus one would return 25 minus three. So slicing, when you use a colon, that syntax means include everything from minus three, having a missing integer means to the end, or assumes you mean to the end. So minus three b naught 123. So it would return all of that. Okay, so if we copy all of this, we bump that in here. There you go. There we are, right. Okay. So creating a list copy, this is quite handy, sometimes just open bracket, close bracket with a colon in the middle, now do an outright copy of the list, you can assign that to a variable, and then you can change that copy as much as you like, it doesn't affect the original. It's a handy way of creating a copy. concatenation. So saying the strings, you can glue things together, you can glue strings together, you can glue lists together. Okay, so if we take the variable squares, we can glue a second list to it, and then what you've got is a much bigger list. Oh, sorry. So I Okay, let's go. Squares underscore two equals, and then we'll dump that in there. If we then put squares underscore to There you go. Oh, my typing fantastic. So squares remains the same, because we didn't assign to a variable, then I did sign it to a variable called squares to, and this then becomes this. Okay, so that's concatenation, that is essentially gluing two lists together, which again, is really, really helpful. Right, you can alter items. So unlike strings, where you can index the character, but you can't change it in a list, you can so I can find one bytes index, I can then replace it. So in cubes, you can see we've got one 827 65. That's incorrect. Okay, that should be 64. So three to the power, so four to the power of three equals 64. So we need to reference this by index, which in this case is indexed three, so it's not not 123. Or you can go minus two. So that could just be minus two is the same way, you're just referencing it from a different direction. And you can then put equals 64. So you're referencing the item in the list and replacing it with a new number. And then we'll print cubes again. Okay, so now the new list is 18207604125. So it's mutable, you can change the items by indexing them, and then assigning them with the operator equals. And as the same way, as we do it in dictionaries, actually, you reference the key using this method with the key name, and then we use equals to assign a value. Okay, so it's the same as in dictionaries, list methods, so we've got a pen so accused, we can append to one six, just do that. Hmm. We use a pen to do an operate of seven to the power of three. And then if we put cubes, you can see that list has just grown by two because we've appended to one, six, and then 343. Okay, so we use an a method, append, adds an element to the end of the list, this is your cheat sheet, you'll be referencing this page a lot in the near future. So keep adding to it. If you find other methods are really helpful, just keep adding to this cheat sheet and save it and you've got it as reference point in the future. So length, we look this in lists is sorry, in strings, it just returns the amount of characters or in this case by items in a list. So that should return four because I've got 123 and four. Okay, four, really, really helpful. Then you've got nesting. So nesting, we've got one list ABC and D. We've got another 112 and three, we assigned both of them within another list to a variable X. X is a list that contains lists. Show you what I mean. Okay, so you got square brackets that contain one list and a second list. Hopefully that makes sense. So to get this list from its parent list, you reference x with index zero, because this is index zero, this is index one. So x zero will return the first list. So then if we want to get B from this list, it would be x zero, and then index one. So we're grabbing that list from that list, we're then grabbing be by that integer. And that's what we're doing here. So spend some time understanding that it's really, really useful with lists, but especially with dictionaries, as well, because you might be working with dictionaries, or Jason. And in which case, you're referencing keyword after keyword after keyword just to access different values, especially with API calls and things like that. So it's really, really helpful to understand that. list comprehension. Now, this is a little bit more advanced than what I would normally put in one of these kinds of courses. But because we're using a control flow, so we're using a for loop. So list comprehension allows us to write this piece of code here in one line, essentially. So I'll just gloss over it quickly. So don't worry about this, we'll go through control flows in another video. But using this piece of code, we're creating a list, I won't go through the ins and outs of what we're actually doing and how we're looping through. But we're creating this list here. Okay. By using this one line of code, which is called list comprehension, you don't need to use multiple lines of code to create that same list, you can just go with one line. And lo and behold, it creates exactly the same list, but with a much easier syntax. Okay, we'll go through loops a little bit later. But list comprehension is massively powerful. So please read up on it. If you go to Python docs on this page, which is docs.python.org/three/tutorial/introduction. It gives you a rundown of numbers, strings and lists. If you scroll down to the bottom near enough to the bottom here, we've got Where Are We There we go. 3.1 point three lists. So it goes into great detail there. And if you do a deeper dive into Python docs, you've got a lot more to read about this comprehension. Okay, so, go back in Visual Studio Code, we've then got the final bit of this video, which is built in function, which is called list. So this function will convert. In this case, it's a tuple into a list. So it just takes one object and it converts it or tries to convey into a list if it can. So this is just a tuple. And a tuple is defined similar to a list but instead of square brackets, it uses just standard parentheses. This function is converting that into a list. So we'll change that to square brackets. Okay, so there we go. bobby@decoding.com. Okay, so that's my whistlestop tour of lists. Like I said, this is geared towards beginners, you've got supporting documentation. This is your cheat sheet that you've got on your screen here, read up on lists, play with lists and add to this cheat sheet as and when you find something interesting, you can keep referring back to this as long as you want 2345 years down the line in your career, and you may find something useful. Okay. So that marks the end of this video. Thanks for watching. I've enjoyed putting it together. I'll see you in the next video. Bye bye. Okay, so we're looking at tables today. This is my Visual Studio Code instance opened up in a tuples.py file that is contained within the supporting documentation that you can clone down from GitHub. Okay, there's loads of files in here. The structure of this course is that I will just walk you through and talk a little bit about tuples from this form, because there's a kind of a cheat sheet, if you like for you to use. And we'll give you a rundown of what a tuple is. And then we'll give you some examples of codes, we can actually start understanding how to work with tuples. So Python knows of for compound data types, lists, tuples, sets, and dictionaries. Okay, on the documentation, it talks about lists that Tutorial for Beginners documentation, but they don't really talk too much about sets, dictionaries and tuples. So I thought I'd put three videos together to help you out. And also put the documentation together so you can reference it. Okay, so tuples are written as a list of common separate items surrounded by parentheses or brackets, and like list, which is square brackets, okay? Now, tuples are immutable, which sets it very, very, very much aside from lists that are that are immutable, okay, so you can't assign items to a tuple where you can Hang in a list. Okay, so that's an important difference between the two tuples have two methods available, they've got the count method and an index method. So you have a tuple dot count will return the number of elements with a specified value. And tuple dot index parentheses returns an index of the first element with a specified value. Okay, there the two methods that we have on tuples. Okay, so let's jump straight into a few code examples. Open up a terminal and fire up an interpreter. And what the first line here is an example of what's called tuple. Packing. We will also talk about unpacking of a tuple in a few moments time. So what we're saying here is t to the variable with an assignment operator equals, and we got three items. So we've got an integer, an integer and a string. We're saying here that we want to assign or pack these items to a tuple named T, because that's the equivalent this expression is the equivalent of doing this. Okay, we don't need those parentheses to do it, because it's a tuple. So we can then access the first item by index of zero. If you don't know much about indexing, I'll talk about that in a few moments time, and then we'll just print it out in the terminal in the interpreter. Okay, so T three items, referencing the first index, which is this one here, if we then put t, one would get the second item in the table. But you can see here just by printing T, that again, that shows you that you don't need the parentheses to pack a tuple. Okay. Tuples can be nested. Okay, so here we've got use or assigning t, which is a tuple, we've got a trailing comma, and then got a fault. We've got another tuple here, where essentially using the package of a tuple to create a one tuple with nested tuples. That's really what we're doing here. So if we put U equals T, trailing comma tuple, and then put you you can see we've got the open parentheses here is the first tuple. And then we've got one item, we've got another way, okay, you can't assign to a tuple, or come up an error type error. tuple object does not support item assignment. Okay, that's a demonstration of a tuple that is immutable. You cannot assign values to items in a tuple, where you can in a list and a dictionary and set. So they can contain mutable objects, however, so let's create another variable with V. And here we put V, you got a tuple with two lists in it. So we can now go V first as we the first list, and then we can say first index, that'd be one equals two. Okay, if we now put v 223. So although the tuple itself is immutable, the lists that are mutable that are within the tuple can be altered, you can assign values to items in the list. Okay, so that's the example I've got there, you can see that we looked at the first zero index zero index, which which this here is the one. So this becomes the zero index of the tuple. And that is the zero index of the list. And we're equals using the assignment operator to. So that's why this comes to 23321. Okay, indexing, I've talked about this in previous videos, but I love this, it's really, really helpful. It just shows that if you're referencing a string, or list or a tuple, from left to right, then the first item in the list or a tuple of string or so on and so forth, is zero. Second one is 123, all the way up, so it's going from left to right, if you reference it from right to left, then it's minus one minus two minus three minus four. So you have options of actually identifying certain counters or items in objects by that index really, really helpful. So we can get the zero index of t, which we know is 12345, we can get the last index of t minus one, but we know there's only three items in a tuple. So we can also reference the last item with two because two is also the same index in this instance as minus one. Okay, that makes sense. Trailing comma. Okay, let's get this example in here. So we're creating a variable with an empty tuple called empty. And then we're creating. That's I had a test in the last time I did this. Let's do that again. do apologize. Okay, so an empty variable. So empty becomes a variable that contains a tuple, which is empty itself. Singleton has just one string with a tray then comma, that's how Singleton is going to be created as a tuple. That's how we know we do it, you only need a trailing comma when a tuple contains one item. So we then use the len function to calculate the length of empty, and we know that there's nothing and then so it expected to be zero. Singleton has one. So if we print Singleton, it says hello with a trailing comma. Okay. There we have it. And we then got unpacking of a tuple. So at the start, we said t equals and we had an integer, integer and a string, we can do the opposite of that and create three variables, I do apologize, create three variable variables and equals t. And what that does, it does the complete opposite. So it takes each item from a tuple, when it signs it to its corresponding variable in order. So x becomes index 01, and two, so we'll expect that to be 12345. So on and so forth. So let's go ahead and do that. Copy. We don't need that. Okay, so is unpacked it. So x becomes 12345543212, y and ends, it becomes Hello, that is called unpacking a tuple is really, really helpful when you're working with tuples. And you'll see that in quite a lot in code examples. Then you've got built in functions. So we've got tuple as a function, so tuple, open parentheses. And basically, in this example, here, I've just got a list that contains a whole bunch of string. And when you add the function tuple to it, it converts that list into a tuple. Okay, so although it starts off as a list, by using the tuple function, it converts that list into a tuple. And now that is immutable, okay, we can't assign anything to x. So if we went x one equals, but it was a, you can't do it. Whereas beforehand, I would have been able to because it was a list. Okay, then you've got tuple comprehension, which is very similar to list comprehension, except you're, you're using the tuple function to convert that into a tuple, as you know, is quite, it's just an example of how you can use the tuple function. Okay, so that is it. So if I stick that in here, look, it's just an example. Okay, so just use normal list comprehension and can use the tuple function to convert into a tuple. So I won't go into great detail about what that's doing, because we're using the SX. It's an example of a control flow, which is a for loop. And use list comprehension to change what could be five lines of code into one easy to read line of code. That's the list comprehension for you, in a nutshell, but we'll look at that a little bit later. It's kind of an advanced or intermediate kind of topic. So let's not worry about that. So that is tuples. Thank you very much for watching this video. And I'll see you in the next video, we'll start looking at sets. Okay, thank you. Bye bye. Okay, so we're looking at sets today, you can see here I've got a VS code instance, open in a file called sets dot p y, if you don't know where this is, or how to get hold of it, then a few videos ago, we cloned down a supporting documentation repository for this course. So get your hands on that. And you can follow along. But the structure of this course and these videos is that I'm showing you and explaining what certain things are. And then we've got some code examples to walk you through nice and easy. So let's talk about sets. Suppose the nodes of for compound data types, which I'll keep repeating, because I said at the start of all of these videos, and it's lists, dictionaries, tuples, and sets. Today, we're talking about sets. You look at the documentation, they don't really talk too much about sets in a beginners tutorial. So I thought I'd do a video just to walk, walk you through it and help you out. So sets, they are an unordered collection with no duplicate elements, like a dictionary is set as defined with curly brackets. So sets are really handy. They're kind of like lists, except a set cannot have duplication. Okay, so at least you can have duplicate item after Jukai. All day long, not a problem, where is a set? It cannot. It has to have unique items. So that's what's kind of where it stands apart from lists. Now, I can talk about this in a future video perhaps. But when you use the set function combined with lists is really, really helpful to look at all unique items within a list and do a comparison and do some analytics. Really helpful stuff. So I use sets all the time. Anyway, so a sets a set is mutable. It's like a list. A set is mutable, you can assign values to items in a list, you can't in a tuple Okay, so that's important to understand. And also sets come with a whole bunch of handy methods. Okay, so to add to add an element to a set, you've got clear removes all elements from a set, so on and so forth. I'll let you read through those methods. In your own time, but like quite a lot of objects and bits and pieces in Python, read up on the methods because they can save you a hell of a lot of time. Because if you don't know of the methods, you will try to code that in yourself. And you might use 10 or 20 lines of code to do what essentially one little snippet of code can do for you in seconds. Okay, so read up on those are really, really helpful. So code this open up a terminal and fire up a Python interpreter. There we have it. So all we doing is copying the code and dropping it in here. Okay. I'm hoping it's big enough for you to read. Okay, so here we go. Basket equals, and then we've got curly brackets, curly brackets, now when you're just glancing at code is easy to get confused with a set and a dictionary because a dictionary has also curly brackets. But what is different in a set is that it's just comma separated, whereas the dictionary has key value pairs, which are comma separated. Okay, so looking at this, I know that this is a set, but you can see here we've got apple and Apple, which is duplication. Okay, so if we were to then print basket, what it does, it prints the variable without the duplication. Okay? Does that make sense? So although we're assigning this set to the variable, Python in the background is taking that set, and it's removing the duplication, okay, but there is some funky little ordering that they do, which you then have to sort. But we won't come on to that in this tutorial. But when you're tinkering with compound data types, you will find some weird and wacky stuff that goes on. So you'd have to get quite creative. So we've then got orange in basket. So fast membership testing. Okay, so we're saying does basket as a variable contain the string orange, okay, which we know it does, because we're printed out here. So we've got orange. So we're saying orange in basket, fast membership testing. Really, really helpful. crabgrass says false, so it's just a Boolean, true, false, but really helpful to understand, okay, and then you can demonstrate set set operations on unique letters from two words. Okay, so we're using set as a built in function. So we've got a set. And we've got be set to two variables. So I put a, no put B. Okay, you can see here that D, B, C, ra, so it's removed the duplication of B, remove the duplication of A, and so on and so forth. So you can say, A minus B. Okay, so we're now comparing sets against one another. And we're using these operators here. So these are all of the different operators that we can use to compare. These are called set operations. Okay, so we've got the bar. So let us in all B, or both really helpful when comparing data in these compound data types, letters in both A and B. So we use the ampersand symbol there. And then we're using this operator to say let is in A or B, but not both, okay, that's what that operator means. Okay. So there's always do research on sets. When you're looking at sets and lists and comparing it to and doing some sort functions on them, it's really helpful to understand what we're doing here, because you can actually get a lot of output with very little input by using these methods and operators. Okay, so in your own time, have a good read up. But this is your cheat sheet. So if you find something interesting on Python or a YouTube video, and add it in a cheat sheet, you can always reference back I do all the time, by the way, then you're set set comprehension. So in the last video, I just did list comprehension and use the, the tuple function, but you can actually use squirrely brackets here just to go straight into set comprehension. There we go. Got a There we go. So we're saying extract. So this is control flow. So like I said in the previous two videos, so using comprehension is allows us to create a set or list or tuple by doing a loop of a variable or another list or so on and so forth dictionary. But you can do it in one single line of code. And it's much easier to read them, let's say four or five lines in a for loop. Okay, there's an example in my list video. And then you got a built in function. So we've got an set, which we talked about a moment ago. So we've got Bobby Bobby at decoding comm creates a set object. There we go. So again, the ordering is all squiffy, you know. Bobby bobby@decoding.com I'm sure there's some logic as work comes out like this. But we've got COMM At decoding dot Bobby. But essentially, it's done the work. So it's gone through that, in this case tuple is converted it to a set and remove the duplication. So in a background of Python is doing that work for you. Like I say, when you're coding hundreds and hundreds of lines of code, it's so good that we can use these functions to really minimize what we're doing and get the same output, low amount of input, the same amount of output, that is the key. And that marks the end of this video. So thank you very much for watching. I'll enjoy putting it together. Join me in the next video, we'll start looking at dictionaries. Thank you, bye. Okay, so we're looking at dictionaries today. So I've got VS code open up on my screen, and it's in the dictionaries dot p y file in the supporting docs for this course, please, please, please clone down from my GitHub repository. If you do that, which we've gone through in all of the previous videos, you will have a directory that looks like this. It's essentially a a directory tree of Python files that can be your cheat sheet. So when you're learning Python always reference back to these really, really helpful. Okay, so in dictionaries.pi, structure these videos is that I'm going to just talk about what dictionaries are, give me some code examples, we'll fire up an interpreter and we just put some code in and have a little blank. Okay, so like I said, in the last three videos, Python knows of four different compound data types. Now we've got lists, tuples, sets, and dictionaries. I love dictionaries. They're like a powerhouse. So you can store data really, really easily. They're very similar, in a lot of ways to Jason. So you reference values by keys, and they're just really, really helpful, you'll be using them a lot. So dictionaries are great for storing data values. And it's an a key value pair. So I've got an example of a dictionary here, but we won't put it in the interpreter because we'll be doing that in a second or two. But essentially, like a set, a dictionary is referenced by curly brackets. But unlike a set, we have key value pairs separated by colons. So we've got a key, which is a string in this instance, and we've got a value. So it's a string, so it's a key value. And it's separated by a comma. So is he dictionary is a great in TextEdit is when they're expressed in this way. So each key separated by a space and with some whitespace here, and then you can have your value is much easier to read. So the second item here, which got a key, and then you've got a key, this is a string, third one, we're actually using a list as the value. And then the last one, we've got a dictionary as a value, okay? So you don't just have to have strings, you can have lists, sets, dictionaries, you can use integers, strings, whatever you whatever you like, as the value itself. Again, dictionaries are mutable, this means that item values can be changed, which is important. Okay, we've then got this, which I like, I've enjoyed putting these together, right? So lists, sets, tuples, and dictionaries all have a bunch of methods we can tap into. Now, when you're coding these methods are really, really helpful I can, if you don't know of them, or if you've never heard of these methods, and you might find yourself doing line after line of the line of code, just to do the same thing as this little snippet can do. Essentially, it would be dictionary dot, and then you could have clear, open bracket, close bracket, and that will remove all elements from a dictionary, okay. All of these methods, tinker with them in your own time, open up a text editor, have a play, run some code, and you will become fluent in these very, very soon, but you got a whole bunch of things you can tinker with. So do that. I urge you. Okay, so let's open up a terminal and a Python interpreter. Okay, and then we'll dump in some code. So we'll put the dictionary that we were talking about a moment ago in here, okay, and we've assigned it to some decks. So we put some debt interpreter will express a dictionary in this way, which is hard to read. Like I said, in the last video about sets. Sometimes you can look at this and go oh, curly brackets is a set or its addiction and get it wrong because you for it to be a dictionary. It's key value. Key value items separated by commas. A set is just item item item, okay, but that you'll get used to it after a while. So this is key value separated by separated by colon. But each item is separated by a comma. So it's key colon value, comma, key colon, list is the value, comma, okay? You'll get used to it. We've then got there. So this will return an error. So if we were to unlike a list, so if we were to reference an item in a list or set or tuple, we could reference the item by its index. So the very first one item in a list suit set or tuple. You can reference by index zero. By do that on the dict. It will come up with an error because you don't reference items in that way. Got key error, okay, there's no such key zero. You need to reference key value pairs by key. Okay, so in this case, we could put some decked Kiera Sorry, Nakia, aka sort of referencing a key, and a value is a value. And this one we put a key for, we should get a dictionary back. There we go, because we're then referencing this really helpful. But you manage dictionaries in a slightly different ways what you would a list tuple, or a set, you've then got creating a dict copy, this is one of the methods I was talking about. Really helpful. If you want to create a copy of a dictionary, you can then assign that to a new variable, and you can alter it, you can change some of the values, and then you've got just a an absolute copy of a previous dictionary, and the previous variable is safe, and you have to worry about that. So again, that's quite helpful method for you. So you've got Ultra an addict, so we can like a list, we can use the assignment operator and assign a new value to a key value pair. Okay, so add the cube of six as a hangover. I use a lot the same code examples across these, but some decks. So what we're doing here, we're assigning a new value to there. And then we're printing out the value for key a key, which is now new value. Okay, so we're assigning a new value to a key value pair, use again, Len, which is the len function Length function. And that should return in this case, four, because we got four items in a dictionary, we can then use the keys, method, return all the keys. Okay, you got the values method, we've sent all the values, okay. So if you want to do some analysis of the keys of the values or key value pairs, you can do that by using some of these methods, like I said, spend some time going through them. So what we got here, keys returns a list of containing the dictionaries keys, you got pop, that will remove the element with the specified key, okay, so you can specify the key pop, and it will remove it from the dictionary. Okay, so there's all these different fancy things you can do. So spend some time going through that, you've then got dict comprehension, which is the same very similar to list comprehension that we've we looked at in the last few videos. So again, I won't spend too much time about control flows, because we're covering that in a future video. But list dictionary to port and set comprehension essentially means that you can create a dictionary using just one line of code. It's much easier to read, do your research and list a list comprehension and dict comprehension outside of this tutorial, I've got this example here. So you can actually see what it's doing, or at least understand the syntax. But if we do this, there you go create an a dictionary with a key of two value for key or four value, 16, and so on, and so forth. Okay. So we're basically looping through this tuple, and we're creating a key, and then a value of it, we value to the power of two. That's why we're getting for 1636. Okay, so I'm not glossing over comprehension, they're really, really powerful. But this is a beginners course. And I don't want to get bogged down in some of the bits and pieces that you don't necessarily need to know at this point, I'll do a future course that would be an intermediate level, we'll start looking at comprehension and things like that. Tips and tricks that we've got built in function deck. So this is on all of those forms. So you can just, we can check. So the dict function will take keys and values and it will just convert them into a dict. So it creates a dictionary object. So if we use this, there we go. So we've got a equals one, so is a one and B two. Yeah, so it's converting that syntax using the DAX function. And it converts that into a dictionary, which is really helpful, right? It saves you having to use comprehension saves you having to manually write that in your code base. So I hope I've done dictionary some justice. dictionaries are like I say, it's a powerhouse. We use them all of the time. I certainly do. And when you become a master on dictionaries that can really really be helpful when you're writing code, when you start tinkering with modules, such as Jason is so closely aligned is really, really helpful to understand. So that marks the end of this video. I hope you've enjoyed watching it. I've enjoyed putting it together and I'll see you in the next video where we'll start having a look at control flows. Catch you later bye. Okay, so if statements really looking forward to this one, I use if statements all of the time that's fantastic, okay, I've got VS code opening if statements dot p y, which forms one file from the wider supporting documentation for this course. Download or clone it down from GitHub. Please do that. If you're learning to code. It's always good to have a reference point. And you can always reference back to these files as and when required when you're just scratching your head a little bit, so please leave please do that. Okay, let's move on. So let me talk about if statements a little bit, I will try not to butcher my explanation of what an if statement is, and then we'll look at a code example. Okay? If statements, so that conditional statements right now, you and I, as human beings, we kind of worked through lists logic, naturally in our day to day lives. Okay? There's an if statement is just a way of taking that logic and putting it into your program or into your code. Okay, so an example of that logic would be walking down a road or down a pathway, and you want to cross a road, okay? So you don't just die out across the road and run across the road, you're gonna get hit by a vehicle, right? It's not going to be pretty. Instead, you use some logic, okay, you approach the crossing, or your you get to a point where you want to cross the road, and you stop. You check to see if cars are coming. Are there any cars coming? Yes or No? If yes, you don't cross If no, then you may cross or you might then say, Well, is it safe for me to cross? If yes, cross, if no, check again, loop through that process over and over until you are completely safe that you are ready to cross it? Right. Okay. It's kind of one example of logic that you're using the real world. You want to make a cup of coffee? Do we have milk? Yes, we do. Make the cup of coffee, okay, logic, and an if statement would take that logic and allow you to use that in your program into your code. Okay. Probably butchered that a little bit. But as if statements that fantastic. So think of an if statement is a way to check to see if conditions are met. If a condition is met, do something else do something different. That's kind of what I was trying to explain. Elif stands for else F. Okay, so you do if you have elsif now and elsif is optional. And then at the end of the statement, you could have else which kind of a catch all. That's optional to end if statement only needs to consist of the if statement itself. Okay. Both Elif and else optional. Okay, no, it will be defined. Or I will be so it can't read. I will be defining a function in this demo. We'll talk about functions in a later video, but just bear with me, okay. He may or may not know what functions are. But this is using a keyword def calling it number play. That's the function name. And we've got parentheses where we're passing through a parameter or an argument, followed by a colon, and then this essentially, forget the function that statement are you seeing on the screen here, that is the if statement, but I'm just putting it into a function so that I can make calls against it. So let's have a little look. So all of this here is optional, because it's LF LF lf you don't need any of that you don't need it is optional. But if is the start at the if statement. So x, so x is a variable here. So imagine x is 10. An integer. Okay, so we're saying we're using this expression here, which is less than So if x is less than zero, so it's a negative number, so minus one minus two, what we say is x equals one also is zero. It's been a long day. And then we print negative changed to zero. So that will appear in our terminal or in our Python interpreter. lf, so else if x equals equals, so this is checking to see if x is equals to something. So saying if x equals zero, print zero, if x equals one, print single else. So this is the catch all. So all other numbers, so that could be 467. So if x equals 472, it will just print more. Okay, so that's the kachel. So by calling this function, if I pass through negative one, we would expect to see this zero, then the third one down here would be single. And the last one would be more that could be, like I said, that could be whatever number, it would just print out more. Okay, so let's get out in our terminal. Let's open up p y, Python interpreter, and it's dump this function. There we go. This may work I might need a little bit more whitespace. But let's have a look. can never be too careful with There we go. So that's now working right? So number play. Number play is now a function. It looks a little bit messy in interpreter when you see these three periods there, that's basically means that it's expecting another line. Because a function very much like an if statement has a colon at the end. That means that the the actual code appears in the next line after some whitespace. Okay, which could be four spaces or one tab. So function is in there. Now let's call it now we'll call number play. And we'll call it with an argument minus one, negative change to zero. Okay, so let's go and we'll change it to zero. Printing zero because this was not met. So is there a car coming down the road? Yes, there is. Is it safe across the road, okay? I want to make a cup of coffee is if there's milk in the fridge is that sugar in the cupboard? So on and so forth. Okay, that's kind of what we're doing. Sorry, I'm really butchering if statements here, but I'm having fun. So, okay, and then this last one here, there isn't actually a number deleted it. So we can put a DLL up. It's just a more. Okay. So that is just a single example of if statements, I could do so many examples of if statements occurred, I can make this video last an hour long, I don't need to this is a beginner's course, I'm just trying to show you what an if statement is, what a control flow is, how your mind should work when you're writing code that contains if statements, why, why and where to use them. There is actually another video I'm going to put together about match statements which are pretty new to python three point 10, which kind of take if statements to the next level, they're kind of like a switch statement in other languages. But if statements are kind of entry level, so one example after this video, don't watch anymore, open up VS code and just start coding if statements and have a play, you will have so much fun, you can really have some fun with statements. So actually do watch the rest of videos, please do but I'm just saying have a play with statements. Right? Okay, so that marks the end of this video. Okay, thank you very much for watching. I really enjoyed putting it together. I'll see you in the next video. Bye bye. Okay, so my VS code is open up on match.py, because we'll be looking at match statements. Okay, this file is one of the supporting documentation files. So get them cloned down from GitHub, they is your cheat sheet. So you can always reference back to this whenever you see fit. But I have pulled this a paragraph from pythons own website. And this explains exactly what a match statement is. But I will then demonstrate match statements because I don't think this is really kind of beginner proof. So structural pattern matching has been added in the form of a match statement and catch statements of patterns with associated actions. Patterns consist of sequences, mapping primitive data types, as well as class instances. That's an action enables programs to extract information from complex data types branch on the structure of data and apply specific actions based on different forms of data. Okay, so that is the official description of a match statement. But I'll show you what it all means. Okay, so a match statement takes an expression and compares its value to successive patterns given as one or more case blocks. So we have a class in this demo. So in the code examples, here, I've got a class, which we haven't touched on yet, I will be putting a class video together as part of this course. So don't get too caught up in the actual class itself. So let's look at this code. So I'll open up a terminal and a Python interpreter, but essentially this look at this function. So it's HTTP error, TPP error, and we're passing through an argument called status, then we've got the match statement with a colon. So everything after that colon is the match statement, and everything after the case colon is a case to be matched, or compared against, so we're passing status through to match and then we're comparing the status against this case statement. Does it match yay or nay? Does it match yay or nay? So on and so forth. Now at the bottom here, we've got an underscore. And that's a catch all. If the previous three cases blocks in this instance, are not met, then this one will match. It's kind of the else statement in an if statement. So let's have a look. Let's get this in a terminal in a Python interpreter. P y, and we'll dump that in here. Okay, so if I was to call HTTP error, and pass through 400, we know that that will match. So the status which is 400 will match this case statement. Okay. So if we do it again, plus 244, found an error, which you'd expect because as me in that cache case, statement, 418 is I'm a teapot. But if we were to pass through 401, something went wrong with the internet. That's the case. That's the catch all. Okay? So that's kind of a very, very basic of a match statement. You can write that as an if statement, of course you could. And so if status equals equals 400, so on and so forth. But match statements come into the row when you get a little bit more complex, and it takes a lot less code to get the same output. I'm all about less input, same output, or even more output. So this example is using the bar two As an all statements, so if status is 400 or 401, or dented editor, then not allowed for a zombie teapot and then a catch all again. Okay, so let's go HTTP error, and this time we'll go 400 not allowed, because it's part of the case statement here. Again, if we go for three, it'll be exactly the same, because that is part of this isn't kind of a, an all statement. So 400, or 4143. So if we put 418, that's me matching the, I'm a teapot. And then if you put 500, it will say something went wrong with the Internet. So that's a little bit more advanced than the first one. So we were stringing them along. And using all patents can look like unpacking assignments and can be used to bind variables. So point is xy tuple. So point here is a tuple of xy. Okay. So that's copy that. Oh, sorry. There we go. This, I'm sharing the screen I've got zoomed so far in, that becomes very difficult to highlight. So I do apologize. Let's dump that in there. Okay, so we've now got a new HTTP error function. And then we'll pass through we'll call point tuple. Sorry, we'll add these two point tuple. Okay. So we'll do the first one. So we go, HTTP error. tuple. Origin, okay. So that's what we're doing there. So we're just changing the variable, point to port. So this is 00. So that's meeting this. Okay, what we're then doing is we're actually assigning y. So this is what the patents can look like unpacking assignments can be used to bind variables. So we are binding, in this point, the index one of the tuple, two variable y, and then we got variable x, and we're using that as an in an F string. Okay, so let me show you what that means. If I'm butchering the explanation of this, then you can have a play outside of this video of this video. So now, if I call that again, what we've done here, so it'd be easier now to explain so by passing through the tuple, zero, comma 123, and calling it with them getting this printed out. And the reason we're getting this printed out is because we are assigning the first index, so which would be in this case, in a tuple, it'd be zero and one, we're assigning that from point to a variable y. That makes sense. And in this case, we're assigning it to x. So x becomes the first point in the or the item in the tuple. And why it becomes the second item in a tuple. I'm, I've butchered that as well. But let's have another go. So this will be assigning 123 to the variable x. So if I now call There we go, x is 123. And the last, the last one is x y. Okay, so that is matching this one here. So x y, so we've, we're assigning the first time to x and the second one of y is meat in this case. So it's printing out this, this F string, which is basically I'm using placeholders to put the variables in. But again, you can look into that haven't I didn't go into that in any great detail in the string video. But that's just one way of handling strings with strings, and placeholders. Okay, so else, we've got a capital and it's a value area, not a point. Okay, so that is a little bit more advanced match statement. And lastly, we've got this one. Okay, so we will copy all of this to our interpreter. Okay. So we've got a class here, and we're using the we're importing data class from data class, and we're using that as a decorator. And essentially what that's doing is adding a whole bunch of methods to the class point, one of them is a done deal in it, you got the report, you got all of these different things. Don't worry about that. I've used that because it's made this class a lot more powerful without the need to actually code more. We'll talk about classes and whatnot in a future video. We've then got Where is so this is just a function. Again, we're pointing three point, sorry, we're passing through point as an argument, and then we're matching point against the different case statements. Okay, and you can see here we're actually calling the class point. So this is where match starts. coming into its own, because trying to do this in an if statement would be an absolute pain, and it will be very, very difficult to read. But essentially, the case statement is now a call on the Point class. So if we now pass through, we'll call the where function and pass through the point class with 00. We get an origin. Okay? That makes sense. So we're calling the function, we're passing through an instance of the class with two arguments, zero and 10. And it's just giving you all of it is matching the cases, we don't necessarily need to go through this. But what I've essentially given you here is a cheat sheet on match. It's very, very new. There's not many videos out there, I've probably butchered match. But what you what you've got here, what you've got here is just some very, very basic to intermediate examples of how match statements are differentiated between if statements, okay, so you can, you are still matching, you'd still check in a parameter or an argument against a case or a statement. And if it meets, then you do something very much like an if statement in that regards, but you can do so much more. And when you get used to them, you can write some pretty complex match statements that are very easy to read, which is important. So okay, that's my video on Match statements. I hope it was clear and concise, please, please get the supporting documents from GitHub. And you can have a play in your own time. But the important one is this one here, but classes because you'll be using that quite a lot when you get more advanced. Thank you very, very much for watching. I hope you've enjoyed it. hope it's been useful. And I'll see you in the next video. Thank you. Bye. So my Visual Studio Code has opened up on a loops dot P why? Because we're looking at for loops, we're looking at while loops today. So controls control flows. This file is part of the supporting documentation that you can claim from GitHub, please do have a look at that. And that's half a go of explaining what loops are. And then I'll give you some code examples that we can actually practice on. So pythons for statement iterates over items in a sequence. So give me a list a set a tuple, a dictionary or a string. And it iterates in the order in which they appear in a sequence. Okay, so at layer two a from left to right. If you were to then sort that list, for instance, whatever the result of the sort is, it would then iterate left to right. Okay, so it's important to note that, so the built in range function comes in really handy when you want to iterate over a sequence of numbers, or a length of numbers or length of an item, as it generates arithmetic progressions. So the range function can just take one integer, and that is the stop argument. Okay, so it has a start a stop and a step. Okay, if you don't pass a step, sorry, a start point, it will assume you mean zero. So the integer that you pass through to a range is always the stop. If you pass through a third integer, that will be the step. Okay? So a start is the value of the Start parameter, zero, if you if you fail to pass it through value as the start and the step is, how many steps you want to do, I've got some examples of it that will that will kind of hit that one home, then we've got a very basic example of a loop. So we're creating a list here. So it's got cats got window, and then they've got defense straight. Okay, so we've got three items in the list. Okay. Four is what we use when we want to do a for loop. So we want to loop through each item in this expression in this in this case, you could use a string, but this is a list so it's cat window. Defense, right? Okay. And then we're assigning it to a variable. Now that very can be any anything you want, is a variable. So I thought when I first started coding in Python, or coding in general, that that variable had to be W because words starts with W, it doesn't, you can call that horse house, parrot, Bobby, whatever you want. Every time you loop through that list, the the item, the resulting item is assigned to that variable. So it can be whatever you like. Okay, so the first loop would be cat, W is assigned the string cat. So when we then print W, we're printing W, just cat and the length of that string, which is three. So the result will be cat three, the second loop will be window, so it would be window. Six, and then you'd have defense straight, which is I think it's 10 or 11. So be done with defense, right and then the length of that string. So okay, let's dump that into a Python interpreter. There we go. Thumper in. There we go. So like I say, cat three, window six and different always 12 sets of length was 12. Okay, so that's what we're doing that very, very basic. But the for loop, like I said, at the top, you're just looping through every single loop, you're assigning what is found as an item or a character, whatever the case may be, you're assigning it to a variable, you can do something with that variable, you can print it, you can do a sum on a number, you can assign a variable to a key value pair and addiction, eight, whatever you like that you're doing a for loop, you can nest an if statement in there and do something based on a condition you can nest and match statement in there, based on a case statement. The world is your oyster. Okay, so create a sample collection. So let's have users Well, we do in here, create a dictionary called users. Okay, so we've got queen, active, Eleanor inactive, John active. So this is a dictionary, the content contains users, and their status, active or inactive. Okay, what we've then got is iterate over a copy. So we're making a copy of users, again. So we're making a copy of that dictionary. Remember, that was a method that we looked through, in the dictionary video that I did a few videos ago. So four, so four, for each user status. So you work with dictionaries in a for loop, in a set, or tuple, or list or character for it's just one variable. But because we are looping through key value pairs, you need to express it in this way. So for each key value, in this case, we just call it you can call a key value, you can call them user status. In this case, I like to use key value doesn't matter for each user status. So use that status, user status, user status, in a copy of users, dictionary dot items. So these are the items each item in a dictionary. Okay, so what this expression here is basically saying, that's one item. So we're looping through that. But we're assigning it to Quinn. Active user status. Next item, Eleanor inactive. Next item, John active. I hope I'm kind of explain what this means. This is a dictionary, so we looked for it slightly different. It's essentially what I'm saying. Then I've got an if statement. So we've got an if statement in here to say that if status. Yeah, so that's the variable. So if status in this case, active equals equals inactive, do something. In this case, we use the delete function, this will actually delete users user. So we're referencing the item by the keyword, which in this case will be Quinn. So if the status is inactive, well, that condition hasn't been met, so it won't do anything. So it does another loop. So do another loop. The second loop, Eleanor, if status is inactive, delete it. So we will delete that because that condition was met. And then we'll do a second a third loop. If John is active, we won't do anything. So the resulting copy of users because this is a copy of the dictionary will just be two items Quinn active John active, okay. Okay, so if we go users, there we go. So that's exactly what we would have expected. So the inactive user has been deleted from the dictionary. That's what we just done. Okay, so create a new collection. So the new collection is an empty dictionary called active users. So this time, we are going to do a for loop over users items. So this is the original dictionary. It's not a copy. And this one, this time, what we're doing is we're saying if the active then add the key into the empty dictionary with the value status, so we're creating a new dictionary. Okay, so if doing the same for loop, except we're now checking that if the user is active, if the user is active, then we're creating a key value pair and we're adding it into the dictionary. That's how it works. If it finds the key, it will use assignment and it will assign the value to the key value pair. If it can't find the key it will add a new key value pair. Okay, then we've got range sis have a little Tinker Okay, let's dump that in here. So for i in range five print I was that done? That's really, really helpful. Okay, so for i in range five. So remember, we've just, we've just put one argument in the range function. Remember I said that the start would be assumed to be zero, and we haven't used a step. So the one integer with pass through is the stop. So we've added five, the first iteration of that range is always zero when we use in indices, so 01234, that's four loops of the range function, it's where it's really helpful, then what we can do is the start stop, remember, so if we do two integers is start start, if we do three integers, it will be zero, 10, three. So let me walk you through this because this is interesting. So this is a start stop. So the first one is five, and then it stops at 10. And when we're 10, would be nine, because if we did from zero to 10, it will be 0123456789. So because we started at five, it's five to nine. Yeah, get that. And we use the list function to then convert that range into a list. We've then got naught 10, three, so start at zero, finish at nine, so it's, so finish at 10. So it's not 12343 to nine. So yeah, we've got 10 integers not to nine, but we're doing steps in three. So it's only show every third step, or every step of three in the range. So it starts at zero, then it's 123, then it's 456789. So that's where the step function comes into it. And then you've got another example using negative integers. Okay, so start at negative 10. Finish at negative 100, in steps of 13, so is 10 minus 10. So minus 20 3040 minus 50 6070. Okay, it's really helpful to know. So we then have Mary Had a Little Lamb or sign in that as a list to variable a. And then we're saying for I, to copy. So let's see what we've just done that, see if I can explain it. So for i, so remember, that variable could be anything we want. So for Bobby, in range, Len a select the length of A, that would be 12345. So remember, where and we're adding Len a into the range function. So that's, that will be an integer of five. So for range five, so 01234, that a five Ranger print the variable, which will be Mary Had a Little Lamb, followed by a integer. So i is the i is those not 1234. So it's not and then we're returning the index, not from a. But makes sense. So this is the list. And the zero index is marry, the one index is had, and so on, and so forth. Have I got that in here? I haven't. Let me open up lists, show you there we go. That's what I wanted to show you. So indexing, I was losing myself that indexing is really, really helpful. There's a little diagram here of what it means to a string or a list. So the first item in the list is zero index 01234. So the first loop would be range zero, in the list would be Mary, and so on and so forth. Okay, so we don't need list open. So that's what we've done there. And then we've got some range for and that some range for six. Okay, so what I was doing is not four, so it's not 123. So zero plus one, plus two, plus three equals six. That's what that's doing. Okay. So it's loop some itself is looping through the response of range for an insane zero plus one plus two plus three equals six. That is what that's doing. So I've given you a whistle stop tour of for loops, or looping and conditionals statements in Python, I hope it's been beneficial. Spend some time doing it. So you now know if you've been following along with this course we've gone through if statements match statements, we're now going through for loops, we've gone through strings, lists, dictionaries, tuple, sets, and everything in between. Now you're starting to get enough tools in your toolbox to actually start coding so please have a play reference this document outside of this video and just start tinkering, start programming. Okay, so for loops, very, very important. And it's hugely, hugely helpful when you're programming. So this marks the end of the video. I hope you've enjoyed it. I hope it's been useful and I'll be seeing you in the next video. Thank you bye bye Okay, so loot clauses today. We are looking at these now because we looked at loops in the last video. So look clauses is a natural progression from that. Visual Studio code is opened up on loop clauses dot p y, which is one of the files in the supporting documentation. So close that down, it is a cheat sheet for you to use. So let's talk about what loop clauses are. So Python has a few statements or clauses that we can use in loops. They include break, continue else and pass. Okay, so loop statements may have an else clause it is executed when the loop terminates for an exhaustion of an iterable. As for a for loop, or when a condition becomes false with a while loop, but not when a loop is terminated by a break statement. So what does that mean as a beginner is difficult to understand. So I've got some code examples to walk you through it. Okay. So this is a little bit more complex in terms of a for loop. So I'll try and walk you through it. Okay. So we'll put this in interpreter as well. But this little statement here follows. So we know range, we're possible, we're starting to stop. So for n in range to 10 is the equivalent same for n in this little bad boy. So they say it's a list 123456789. So the first iterable is to the first time it does a loop it assigns to to the variable n keep the end in mind, the second for loop. So every time it does a loop, it then goes through this part of the code, okay, this part of the for loop. Okay? So this is for x in range two, so a starting point is two, and the end point is a variable n, which we know is two, because that's the first one. So range two, two, is the equivalent of a list that looks like that. It's got nothing in it, okay, so it hasn't got an x becomes nothing essentially is nothing right. So, there is nothing there is no loop to be had. So when we then do this if statement, so if an A and modulus x equals equals zero, well, the comparison isn't there. Because you know, comparing one against something that isn't there, equals equals zero. So that isn't false, that condition is not met. So it does else print statement on a prime number. The second loop is a three, so this range becomes two, three. Okay. So it then compares that statement, if it's matches, so if modulus x equals equals zero, then it prints this statement here. So n equals x, there's got little string of star, then it's prime. So it's floor division, NX. Okay. So let's have that in our we've learned all about floor division in numbers right at the start of this course, you should understand what we're doing here. So copy this go terminal new and do this and dump it in. And what we have, there we go. So we expect it to to be a prime number because the condition wasn't met, we expect three to be a prime number, okay? And then it's four. So the print statement is four equals two times two. Okay? So it goes through, that's what that's doing is a basic kind of for loop was followed with a for loop with an if statement. So it's not basic at all. But we've got a little break statement here. So it prints out and then it breaks. So that for loop finished, so it does the loop again. So that's what the break statements doing. Okay, so continue statement. So for now I'm in range 210. Okay, so if num, modulus two equals two, then do something and it continues. So this will continue with the next loop. Okay, so this is another example. So it's just doing something slightly different. So found an even number or an odd number, bound and even found an odd found an even found an odd, right from the to through tonight. Then you've got a past statement. past statements are really, really useful. When you're coding, you might write classes or functions that you need to call in another function, but you don't want it to do anything. Because you're not actually at that point of the code yet, you might be testing something past just means that it does nothing, it doesn't break or anything like that is just allows you to I can call my past class and it won't do anything. Okay. So this is an example of a function you can add to pass and I can call that function. So my pass death. Okay, it doesn't do anything because it's just got past statement if it didn't have the past statement, and it'll come up with an error. Actually, it will show you in a text editor here that you can't do that. It just doesn't let you do it. So that is closed loops. Again, like with this course, I'm explaining what they are. I'm giving you some code examples all that have been extrapolated from pythons own documentation for you to read up in your own time and have a tinker and kind of understand what I'm doing. What pythons doing. I have tweets Some of them. But yeah, that is Luke closer hope you've enjoyed this video that is the end of this one. I'll see you in the next video. Thank you Bye okay modules today, so it won't take long to explain what modules are. So before we jump into it, my VS code is opened up in the modules.py file. You can reference this whenever you like, look, it is your cheat sheet, but you can get the supporting docs on GitHub. So all of that will be in the description. Okay, so module so in Python, we're able to write a long program and save it as a module. This is known as creating scripts, we're able to input modules across modules and into the Python interpreter, right. So what you don't want to do is write a function numerous times, what's the best situation is to just write it once and do not repeat yourself. The reason for this is because if your function is incorrect and not working correctly, you need to debug it. If you've got to hit multiple currencies or that function across your project, you need to debug all of them, what you need to do is create one function and import it as a module to your other application or other file in your project. So do not repeat yourself dry. That's what this is, you may see that a lot in your career. Python, Python standard library can be found here, they've got a whole bunch of modules and fancy stuff that you can import and take advantage of. Please look at that your own time, we've got it here in modules, have a look at this page. And it talks about different modules. So import flow, which is the Fibonacci module, there's loads and loads of different modules you can import. But we're not going to look at those. Today, we're going to look at our own that we've already created. So in the last video, we were looking at functions, and we create a function called Demo funk in the functions file. So that's a script that we can import. So if you look here, I've got from functions import demo funk. Now, that will print out some gobbly goo closer to us because it's got some other functions in the file. But essentially, with this line of code here will allow us to import that function. So we can call it and pass it through to these functions. Let's get that open up a terminal, open up a interpreter. We dump it in there. Okay. So we've imported demo funk, and yet it's printed out a load of two's because we've got some functions in there, don't worry about that. It just now means that we can access demo funk, so we can say my int equals demo funk. And we'll pass through 28. Okay, so my int now becomes data because that function is taking an integer addition, adding on six and then returning the new calculation. So we're expecting 32. But what we can do, we can now pass that through to my funk one, so we can say my funk will pass through my int my funk, what we're talking about is funk one, funk one, my ENT. There we go, do apologize. Okay, so you can see how we're importing a module. And when we're using that module to interact with other functions. Now we can import funk one into another module. Does that make sense? We you know, you can, it's so important to make sure that your code is as dry as possible, do not repeat yourself is really important. So we then got funk, too. So funk underscore two, is that right? Funk underscore two, we won't we won't use the demo funk this song. This is actually yes, we will. We'll go my int. And this is this has given us the power of so my in this case it will be 32 to the power of 16. Well, that's a big number. But that's a good explanation of modules. Okay, that like I said, So pythons standard library can be found here on this page. So if you look here on Zoom In, I was not working. It's not liking that. Yeah, there you go. docstoc python.org/three/tutorial/modules.html. That's where you'll find this standard library or documentation about their standard library, their link to the library is whereas it let me crash that out. Or there we go. Can you see that on the screen? Yeah, Doc's dot python.org. Three dash load library. So actually, that's open that in the browser. There we go. So you've got a list of everything in here. Okay, so text position services. We've got Date Time, which is which is a great one. So you'd say import In the terminal p y said say import, Jason, he say import, daytime. Or you can go further and save from Date Time import, I think is delta. Now there isn't, there is a date time actually go from date, time, import date time. So these are different functions and classes and stuff within those packages. So have a good read up on all of these. They're fantastic. Again, like the methods in lists and things like that, when you really understand this, it can save you lots and lots of time when you're coding. So that marks the end of this video. Hope you've enjoyed it hope it's been very beneficial. And I'll see you in the next video. Thank you, bye. Okay, so we're nearing the end of this course. Now we're looking at classes in the next video. And we'll look at a small bit of programming a little API that we're right, that comes after this, which is all about exceptions and errors. So my VS code is opened up on errors dot p y, this is your cheat sheet, you can clone this down from GitHub, always reference back to this is really, really helpful as a programmer. So Python has at least two distinguishable kinds of errors. So you got syntax, you got exceptions, okay, as a noob, you'll be getting a lot of syntax errors, you'll not need to look at colons after functions. And if statements and loops, you need to look at whitespace loads and loads of problems. But that's where text editors are really, really helpful. So look at my text editor video, get one installed, we've got VS code in this course, syntax errors. As you become better, you'll know what the errors are. So exceptions are and you'll know how to handle them. So I've got all of the exceptions here. So you got name of exception description about what it actually means. Okay, so we'll be having a look at some of these. We've already seen some of these during this course. But some of the bottom here you got type error, you nightmare, you got zero division error, okay? So work through them when you got a bit of time. But we've got here some examples of code that will be coming up with an error, okay, so if we get p y here, dumping some code, this will be zero division, because 10 times one over zero is zero division raised when a second operator in a division is zero, you've got four plus spam multiplied by three, well, spam doesn't exist. So I've got a name error, if I put spam equals two in our exists, so we don't get the error, then we've got a string plus integer doesn't like that, okay, but if we go to plus two, it will like that. There are exceptions. So now we need to look at how we can handle exceptions. So we've got a little while loop here and my example. Let's get that dumped into the interpreter and see what's going on. So we've got a while loop. So while true, you do a try and accept statement. So I haven't talked about trying to accept statements, you can read up on them on Python docs. But we've got one in here. So essentially, it's trying to run a piece of code. But we accept that if any of these exceptions occur when running the code, we print this, okay? So this, this code could say anything really, but basically, we're trying something we've got a break clause there, and we're accepting if these exceptions occur, then we do something. So this is how you manage exceptions. So if we were to run a try and accept on the code earlier, we could say if there's zero division error occurs, then do something else you can just print a fancy statement, okay, so we put five in here it won't have an error, okay. But if we would find narrow then it will do this it will print Oops, that was not a valid number try again. Okay, so then we've got a function try this fails, so we say this BIOS division error, okay, so one over zero division error, but if we stick it in a try accept statement and Bonga in here is calling this file so try this file. So we're calling the function and we're accepting zero division error. Okay, and because we're accepting that, we can then say what happens in this case we just did a print statement handling runtime error division by zero. Good so the train except statement has an optional else clause which can be present must follow an except clause is useful for code that must be executed if the try clause does not raise an exception. Okay. So if a finally finally clauses present finally clause will execute a last task before the try statement completes. The finally clause runs whether or not the try statement produces it as an exception. The following points discuss more complex cases when an exception occurs. So let's get this little function in here. Okay, well, we got several get it all on the screen. So okay, so we've got a function called divide, and we're passing through two positional arguments, x and y. Okay? So it must have two arguments. So we're trying result equals x divided by y. So that is what we're trying. That's the little bit of code we're trying to run. But we're saying except, if we receive a zero division error, then we just print that we get type error must be an in if we else print result is result. Okay? So result equals, and then finally we print executing, executing. Finally, finally, clause, tongue twister. So that will be printed anyway. Okay, so if we now pick up those commands, and dump them in here, you should see an example. Oh, I didn't like that. Do apologize, as pick this up, copy. Delete that. stumped them in. Okay, so the first example, divide to one result is two, okay? Because one is an integer above zero, so we don't get the zero. And what does it say? So the result is two. So this actually it tried it, okay. So result equals x over y to zero, that is a zero division error. So we're getting division by zero, then we've got strings instead of integers, it's printing out must be an integer. So they're the three times we've called it but you know, is every time we get an executing finally clause, that's because this is run every time it tries. Okay, so this is the finally clause. And that's what we're talking about in here. Okay, so that is a save the changes I made. That is a whistle stop tour of errors and exceptions. I hope this made sense is really, really helpful. You'll find a lot of this when you're reading other people's code, people that have been coding in Python a lot, you'll find a lot of this type of stuff. So try to understand it, read up on the exceptions on the Python website, understand what they do and what they are and how to handle them. And you'll be good to go. That's the end of this video. I'll see you in the next video where we will start to look at classes, or certainly I'll try to catch you later. Bye bye. Okay, so looking forward to this one, because classes are the cornerstone of OOP or object orientated programming in Python. Okay, we looked at functions a few videos ago, and I said that look at a function as a container, you have some script, what have you, when you save that container, you can call it and you give it an input, you get an output, okay, we do some fancy stuff in the function, but essentially, his input and output class goes so much more further than that, it gives you the ability to bundle data, and functions together, they are a powerhouse, okay? And unlike any other datatype in Python, okay, so not that you can store data in dictionaries, and lists and what have you. But classes gives you the ability to store data and give it functionality at the same time. So if you look at VS code, on the screen here, I've got open on cluster dot p y, which is one of the files in the supporting documents that you can clone down from GitHub. This is your cheat sheet. So please do that. It's massively helpful when you're coding and looking back, forget certain things. This could be your reference point. So please do I've extrapolated a whole bunch of data from pythons own docs, which are in docstoc python.org/three/tutorial/classes. They go into great depth about classes, objects, names, namespaces, inheritance, base classes, instance variables, class variables, and everything in between. Okay, so a bit of bedtime reading view. This course in this video is all about beginners, and helping you get started. So you can start tinkering and coding. So this is very, very much geared towards beginners, and I've just extrapolated what I think is what you need to know to start. So classes provide a means of bundling data and functionality together, creating a new class creates a new type of object allowing new instances of that type to be made Python classes by all the standard features of Opie the class inheritance mechanism that we'll look at soon allows multiple base classes. a derived class can override any method of his base class or classes. And a method can call a method of his base class with the same name. That's all about inheritance. It frames it very, very well, but I'll walk you through that in a few minutes. simplest form of a class definition looks like this. So you have a class keyword, followed by class name, colon, and you have a bit of whitespace in all of this And these your methods and class variables, okay? So look at that in a second have a function, you must save or a D must define a class before you can make, or before it takes any effect. So let's look at some of my class examples here. Let's open up a terminal and a Python interpreter. So we'll dump this in the interpreter quickly. So we've got my class available. So class keyword, and you got my class, colon, and then you've got some of this, the first line here is text literal, I would urge you, I urge you to added texture to all of your classes. Because if you're looking back at a class that you wrote years ago, or somebody else's code, they may if it hadn't got a text literal, there's no way of knowing what that class does without really doing a deep dive, where you can call a magic method called doc, and it will tell you exactly what's going on. Mine's very simple, but you can put whatever you want in there, it could be 200 lines, if you like, you then got a class variable, which is accessible to all instances of a class, which I'll give you an example of in a second. And then you got the F method, just a, we're just calling it f, we call it anything you like. But that is a method for this class that can be called Okay, and it will just return a string called hello world. So we can now call my class I and get back the integer 12345, we can call F and get a function method. Okay, and we can call the magic method doc to get the string literal. Okay, so you can call double underscore doc dollar, double underscore any class and it will return the string literal if it has one. So let's go ahead and instantiate this class and assign it to a variable x. So the class is now instantiated, and we can access it using a variable x. So again, we'll go extra I move my mouse X to Y, we have access to 12345, which is a class variable. Now, if we go x dot F, but this time we have parentheses, it will pass it will bring hello world. The reason is bringing back hello world is because we are parsing through self. Let's talk about that. So we pass the methods instance object in as the first argument of all methods. So x dot F, which is what we called here, is the equivalent of saying a my class dot F, and in passing through X, okay, self has no special meaning in Python, the word self doesn't, it's just his normal convention to do so. So in this class, we're possibly self. So that is where we're instantiating all of this to x. And then the first argument and the method is x itself. That's how we can act. That's how we can access that method and call that method. Okay. Hope that makes sense being see we're doing it again here. So we expanded on our class. Let's get that in here. And talk about it text literal, no change, but we're now using a new magic method or Dunder init method called in it. And we're passing through self, which we do, because we pass through the instance itself or the object itself. And then we're passing for a positional argument called My int. And it has to be an integer. Okay, so if I didn't have this in there, you can pass or anything, but it won't like it because we're actually using an integer as a sum. So that's what that's doing. And within that method, we are assigning my integer to a instance variable called self dot i, okay. So that is only accessible to the instance itself. So whereas the first example, I was a class variable, this is an instance variable. And then with the F method, we're just doing a quick sum. So new variable equals, we get any integer that we're passing through as a keyword, positional argument, and we were doing a sum, which is the power of three. So if we pass through four, it's four times four times four, which is 64. And we're returning. So that's instantiate the class to x again. Now x.ai is four. It's not 12345. Now because we passed four through as the positional argument, okay. Now, if we go x dot F, is 64. Okay, so we're calling this method, it has access to self.ai, because we're passing self through as the instance. So x is accessible in F. Self that I, that makes sense? I hope it does. So we're passing the instance through as the first positional argument is doing assignment is returning the new sandwich is 64. Good. Now let's talk about adding an attribute so we can add an attribute to our instance called counter. It's not in the class, we're just adding this To the instance of the class, so now we have access to x dot counter, which should be one. If we were to do a little while loop, just on the sum. So while x dot count is under one, we do something. And then so we changing count to another number in every loop, we just checks. Is it on 10? Is it under 10? Is it under 10 hours over 10. Now stop. That's what a while loop is doing. So essentially, I put a description. So the first loop returns two, because it's one multiplied by two, and then x becomes two. So it's two times two is four, four times two is eight. Eight times eight is 16. And at this point, it hits the loop and says, ah, 16 is above 10. So stop, so loop then stops, so the fifth loop does not happen. So we know that x is 16, down here. So if we print x, it will be 16. But now we can delete that attribute of the instance x by using Dell. Now, if we try and print it again, it just won't like it. Okay? It won't like it. But what we can say is attribute or we can call it, attribute to ohms. And we didn't assign anything. Yeah, X attribute so and then we can find out Yeah, we could do another someone else. But then we can go del x dot attribute, do an L delete it, and then we don't have it. Okay. So once we've instantiated a class, we can add attributes, remove attributes really, really helpful. And you can't do that with dictionaries or anything like that, you can, you can add data to dictionaries. And because they're mutable, you can change values and things like that. But with classes, you get so much more that you can tinker with. So now let's talk about in a little bit more depth instance variables. So you can actually understand it a little bit more, let's create another class called Dog. Now, what we're doing is a class variable that's available to all. And I've got instance variables that are only available to the instance. So when we instantiate the class, we will have access to a name and tricks variables. And then we've got a method called add trick, and we pass through a trick and it appends it to this list of the instance variable, not the class variable. Okay, so don't count the class variable is canines, every instance of this class will have a variable called kind, and that will be equals to canine. So let's create an instance assign it to D. Okay, in this instance, I'm gonna assign it to E. So D has the name Fido and he has the name, buddy, because we're passing through a positional argument called name. So you have to pass a string through. Actually, you know, you don't even pass anything you like through, but we could do that. We could do that. And it has to be a string. Okay, let's save that. So he kind, d dot kind will be exactly the same. This is a class variable, but e dot name, we buddy, d dot name will be five eight, because that is specific to the instance. Now we can go one step further, we can assign a trick to D. And it'll be specific today, we can assign another trick to a and all this is doing is taking that string, and it's appending it to the instance next list, which is an instance dict. So a list is not a class list. That was a class list and we added roll over and play dead, then both instances will have access to those tricks in this case. So we now put D we don't want that. We want it down here d dot trick you can see. Sorry, the dot trick was tricks side. There we go. D dot tracks, rollover a dot Trix. Play dead. So we can then add another one to a ATREX. It's now got two in there. Dietrich's still got the one because we're only using instance variables. Okay, does that makes more sense? So we instantiate in more than one class and we tinkering with those instances of that class. So let's talk about inheritance. Oh, let me just come back in here and make some changes. Inheritance so the class can inherit from other classes. Okay, so base classes now you can inherit from numerous different base classes. Indeed, a base class can then inherit from another base class. Now this is really handy when you're trying to write clean code, because what you don't want If duplication of methods across numerous different classes, it's good to have a base class that has common attributes and methods that you can use elsewhere. And you can then inherit from the derived class from a base class. So think of it as kind of a, a tree so that you have a base class, which two classes can inherit from, or two or more, and, and so on, and so on and so forth. Okay. So for instance, this example here, this dog class, could inherit from the animal class. Because a dog is an animal, you could have a class called Cat, that would also inherit from the animal class. And that animal class could have a whole bunch of methods in there that are useful to derived classes. I've got another example here. So actually, this is an example of a derived class, he got the class name, and you got a bracket and all of the classes that is inheriting from, okay, and then again, you then state you're the same, you're doing a normal class. But remember, a derived class can overwrite the methods of its inherited classes. For instance, the dog class might have a special method, or a special way of handling the tail method that is different to a frog that doesn't have a tail or loses its tail when it goes from tadpole to Frog. That's quite a good explanation of methods and overriding Okay, so execution of a derived class definition precedes the same as for a base class, when a class object is constructed, the base class is remembered, this is used for resolving attribute references. If a requested attribute is not found in the class, the search proceeds to look for that base class or in that base class, this rule is applied recursively if the base class itself is derived from another class, so it keeps looking and looking and looking recursively derived classes may extend or override methods from the base classes. Okay, so really, really, really helpful. And it allows you to write really clean code. Otherwise, you could have one class that is crazy long, and then you're duplicating some of those methods in another class that is crazy long as best to have two smaller classes, a base class that they both feed from. Okay, so I've got a couple of classes here that kind of walk you through that. So there's open dump all that in my interpreter. And let's see if we can walk through this. Okay, so we've got mapping, that is our base class, in this example, private variable example. So check out double underscore update. This is called name mangling. There's a bit about name mangling in pythons own Docs. So have a look at that. It's, that's what that's the example. Actually, they're using our own Docs. So but we don't necessarily need to do need to talk about that in great detail at all in this explanation, it basically means that this update can appear where it appears in a class is done without regard of syntactical syntactical position. So normally, you can only access certain variables because they appear above them. So but because we're using name mangling, we can access update, no matter where we put it. So do a deeper dive of that, and Python docs that's a bit beyond beginner level. So mappings got a special method called in it. And we've got items list and iterable. As instance variables, we then got an update method. So for item in self iterable, we have access to self editable, because it's an instance variable, we then append it to this empty list of the instance. Then we've got a class called mapping subclass. And we, which derived is a derived class. And a base class in this case is mapping which is the class we've just talked about here. So this inherits from mapping. But you can see here we're overriding the update method again, so that we've got it in here. This mapping subclass is actually got its own method called Update, which would do its own thing. Okay, so, so don't worry about the actual functionality of the methods and what they're actually doing. And a result, don't worry about that, just more or less, just look at what we're actually doing here with the class and the inheritance. Okay, that's the whole point in it. So we will instantiate mapping subclass, and we'll, we'll call that or we'll assign it to a variable called M. Okay? So we can then say M items list. Okay. So the instance variable is an empty list. We will then call update. So in this case, we call an update and it's a list 123 And another one these are values okay, so now we can quite simply add that and it will create one These two are three values. Okay? So what it's doing, it's, it's creating what we're doing here. So, okay, there's talk about the method and what we're doing because it's actually quite confusing. Okay, so we've got two lists, we've got 123. And these are values. So what this update method is doing, it's for item in zip, and what we're doing that that is a built in method called Zip. And it basically zips, two lists together to key value pairs. And then what we're doing is we are using self dot items list to append item to the list that we just created in the instance variable. So that's why we've got a tuple. One, these two are three values. That's why we've got that result. So but if we were just calling the update method, we wouldn't get that because all it's doing is it's iterating. Through what we're passing through, in this cases, it's a list in a list. And it's just self items dot append, and it's just appending the item so we'd get a very different result if we weren't superseding the update method. Okay, I don't know if I've just butchered that inheritance explanation, but it's a beginners class. So hopefully, that's given you enough to actually work. I mean, I've just used the zip method there. And, and I probably could have gone with a much more simple explanation. But if we were just using the base class update method, it would do one thing, but because we are actually overwriting that update method, we're doing something very, very different. Okay. So that is the end of this video, they are all of my code snippets that we've walked through, it's taken me nearly 20 minutes to do it. I hope I've done it justice. Again, I would just re kind of reinforce what I was saying. This is a very much a beginners course or a a polishing up course, if you like. But read pythons own documentation, because it will give you a good rundown of everything in regards to everything we've gone through in this course actually, because this is the last video about coding. The next video, we'll actually be taking what we've learned throughout the course and just using it to write a short program. So thank you very much for watching this video. I've enjoyed putting it together. Hope you've enjoyed it. And I'll see you in the next video. Thank you bye bye so virtual environments today, they're an important part of any project. So we're open here on pythons own documentation on Doc's that python.org/three/tutorial/v Envy, which is shorthand for virtual environment. Okay, so have a read of this in your own time. So virtual environments, why are they so important? Well, when you're programming when you're a freelancer, or software engineer or developer, whatever the case may be, when you are throughout your career working on different projects, you will soon realize that these projects can only function if they've got a whole list of different dependencies installed. Okay, they might be third party packages in there, say a web framework called Django, you'd first have to install Django, and then they say install pillow or requests or Django rest framework, you would have heard of these some of these anyway. However, all of these third party packages will have different versions, the reason they have different versions because they are configured in a certain way to work. alongside other packages, such as Python, we've got python three point 10 installed, or three point 10.2 installed on this project. Older projects might be using Python 2.7. For instance, in which case, the third party packages that you're installing have to be able to work with those different dependencies. And this is where virtual environments come into it. Because if you were to install all of the dependencies globally, you will have a whole bunch of conflicts. So project one will need Python 2.7, and Django 1.8, for instance. And if you had all of those installed globally on your machine, well, you'd be in a spot of bother when trying to run project B that requires Python, three point 10, for instance. So this is where virtual environments come in, you are able to create this little environment on your machine, install project dependencies within just that environment, and fire that up and work with that environment on your project. That way, you can have one container for project one using dependency A, B and C, you'll have another project project B using dependency X, Y and Zed. Okay, they are really, really helpful. Now you can follow the walkthrough tutorial on the page that I'm on here using Python or in my case it'd be p y dash M, V and V and you can create a virtual environment like that. By all means, go ahead, it will create the virtual environment in the path tree that we're in in the video. to code however, I find using a third party package called virtual EMV wrapper to be a much better direction to go. So if you visit this here, which is a zoom in, so P ypi.org/project/virtual env V wrapper. So let's have a look again, virtually in V Rapidash. When that's the Windows version of this, what it does, it allows us to install this package globally. And then we can use commands such as, make virtual environment, and then name it. And it always saves and creates and configures a virtual environment in the same destination. Normally, users slash your name slash NV, and then you'll have a whole bunch of environments very, very easy to manage. Whereas when you use the Python alternative, this virtual environment is saved normally in the project that you're working in, and I just find virtually in V rapid to be much, much easier to work with. So all you do is you copy that command. Because we've installed Python globally, we have access to pi pi, or sorry, Pip P IP, new terminal, and all you need to do is pip install, probably got that actually copied on my copy that there. There we have it same requirements already satisfied, because I have already got that installed globally. So now what we do, we will go and use a command, make virtual envy. And we'll call this Python dash course, when I press Enter, they'll go ahead and install or create a virtual environment on my machine. In the folder, C drive uses Bobby slash e n v. And then there'll be a folder in there called or directory in there called Python dash course. And within now we'll have a whole bunch of different directory trees. And that's the environment. So that's the new path that we'll be using and installing project of installing packages into. And the reason I know is working is because I've got parentheses followed by the name of the virtual envy. And now that is ready for me to start installing things. So just a bit about package manager called PIP, they've got the pi pi library here. And you can easily find packages by a simple Google. Or you can go onto the main website. And you can simply search here. So one, normal, regular one that you'll see is pillow that allows you to work with images in Python, we've got recorded, this is one that we'll be using in this in the next video sorry, requests I want, which is a library that allows us to make API calls. So in conjunction with other programs, you've got another one is Django rest framework. Oh, what have I done there. There you go Django rest framework, a very, very famous third party package that you can install that allows you to use Django just which is a web framework just as a API back end. And then you can link the web framework with a front end such as react, for instance, anyway, that is P IP, that is a package manager, and we install from there using P IP to the PIP command. And that's actually install have already done virtually in V wrapper. Let's go pip install requests. See that just behind my head, there are pip install requests that will go about an install requests into that environment. I might as well just open up the environment whilst we're here. C Drive users, Bobby, in V invece. Well, we got Python course Python course. Lovely. Okay, so this is the environment we've got fired up. If you go into lib site packages, a lot of these packages, can you see that very well. That's probably a little bit easier, right? A lot of these packages come straight out of the box, right? So if I'd shown you this before installing requests, it might look a little bit different, but we've just installed requests, can you see that going to requests and this is the requests package, there's a load of pi files all working together. All we need to do is now import request as a module into our project and we have full access to all of these files, all of the classes, functions and everything else has gone on as function funky in that package we have access to if we install it into our project, it has come up with a command here saying you can upgrade PIP so we need to do is just copy that part there. You see that? There we go copy that whole part there. And that will go ahead and it will ask They Pip. And that's all you need to do. So that is virtual environments. I hope I did it justice hope you now understand why we actually use them. It's just the way of containing all the dependencies of your project in a nice little bubble on your machine, a nice little directory tree, so that you can access them willy nilly, and that I can deactivate. The activate that. So now I know the virtual environment is no longer working. And I can say work on demo. There is no virtual environment called demo, I think there is called demo one. There you go. So I've got another virtual environment in there called demo one. So I can turn one off and turn one on, turn one off, turn one on. And that's a good way of just working on different projects. So I won't drivel on any longer than I need to. That's the end of this video. Thanks for watching. Hope you've enjoyed it. Hope you found it useful. And I'll see you in the next video where we're designing and writing our very, very first program in this course. Thanks for watching. Bye bye. Guys, so we write in our first project today, with everything we've learned throughout this course, it's opened up VS code has opened up a project of P why you won't find that in a GitHub repository, because I want to be coding this myself. So you can follow along with how I think and also see how poor I am at typing. Okay, so you'll be following along with this one hopefully won't be too clunky. But the previous videos have been all prepared beforehand. This one hasn't. So hopefully you will see what I'm trying to do here. So the project will consist of us writing an API, which is an application programming interface. So our program will be talking to somebody else's program. In this case, it's the Chuck Norris API. So we'll make a request, and it will respond a joke. Can't be too bad, right. So we will be using the requests library, which is something we installed in the last video into virtually envy, that is a library specifically for this. So we use requests to make get post PUT and DELETE requests to API's and get the response. So that's what we're going to do. So if I open a terminal, if I go work on Python, course, that will fire up the virtual environment, because I've got the parentheses there. And if I now put PIP freeze out list, everything is installed in that virtual environment, you can see here we've got requests, because we installed that in the last video. So happy days this close that down or minimize that we don't need it. So if you watch the models, video modules video, say, you will know that we can now import requests, because it's in a virtual environment. So it's in our extended directory, directory tree, we will also import now we'll leave it as requests. So I'm going to using classes, because I want to show you a base class in a real world and a derived class. So here's a base class to make the request to make the call. And I'll use the derived class to actually build the request itself, and then maybe call a function a solid method in a base class. So that's what we'll try and do, we'll be using an if statement maybe or a match statement, we'll be writing or raising a type errors or exceptions, and use an F string. So it'd be basically using a lot of the stuff we've learned not everything but so you'll be able to see that I'm using certain things that I know, from my Python skills and actually writing a program with it. So without further ado, let's jump straight into it. So this class, we'll call this API call, nice and simple. And we use a text literal to say, base class to make a basic API call with requests. Happy days. And then what we'll do is so the method we'll use this will kind of be a global method, that will be a eight. We can use this across numerous API's. That's why we're putting in a base base class. So this one just needs to be a method that allows us to call and will pass yourself. So a password the instance of itself and what we need to have posted through be the method to get post put delete. So method, and also the endpoint the API. So API, yes, got a URL. Okay. So, first thing we want to do is do a if statement, we'll do an if statement. So if method. method equals equals no method lower, so we don't know if there's going to be uppercase or not. equals equals get. And we'll do something. So get we will make the request itself. So our dot requests dot get more parser API URL. Okay, nice and easy. Now we could use an else statement. I'll use a raise exceptions later on this won't be is something that you can use, you'd have to change this if you're going to use this in your own program, because we need to capture the post the PERT the Delete methods also. So we're not going to use an else or an if else or anything like that, because to save time, but we will now do a match on the response. So with requests, you get a status that you can tap into a status status code that you can use to check whether or not the API call was a success or success is 200. Or two, I want to it depends on the API. But we want to check to make sure that the status code of the API response is 200. And if it is, then we'll return and if not, we'll raise a Type error. Okay, so match our dots status code. There we go. And we'll have a case statement for this. And that will be 200. We'll have a little bar to I want is basically saying or, and in which case, we want to return. And we just this just return a string. Now it will be our dot Jason. And I think it comes back as text. Obviously, this is all you can change this as value. So this particular API is it returns a response, Jason, you can then get the text specific text for this called value. Now, obviously, that's not gonna be the same on every API. But let's assume it is for this, this example. And then we'll have another case statement, which catches everything else. And we'll say res type error. But we just say, API error, shall we. So it doesn't come if it doesn't come back as 200, it would just raise API error. Not the best description. But you can imagine using you can use different exceptions and different strings and what have you. And it can just basically work through the different exceptions. So this is the cool method that we'll be using in our derived class. So in upper class, and we'll call this Chuck Norris. And we will be putting API call in them because this is the base class for the derived class. We'll have another text literal, it will say, this is the Chuck Norris API doesn't really know for this example, but you can add a description. Okay, so we want to club because this is specific for Chuck Norris, we can have a class variable called URL. And what I'll do HTTP s, and this is API dot API dot Chuck norris.io. That's not going to work. I still IO slash jokes, slash random. Call Westermarck cat, gory, equals, okay. And then what we'll do, we'll construct an API URL by using a placeholder, okay, and I'll show you what that means in a second. Categories, equals and we'll have we'll just have animal and also they have one called dev as well, they have more but we'll keep it as dev animal. And then we will not going to add that now we will have done doing it so in it partially self as we normally do, and we'll also pass through category because this will allow us to instantiate the class with animal or Dev, okay, so we'll have self dot category equals cat that glory, there we go. And then now you could have if not, self dot category in categories 10 I will write it cat self dot category sorry. So this is if instance variable is not in class variable categories, then we can then raise TypeError. Cat, not options. Animal Okay, so that's just the typo that will be shown. Now we'll have DEF, and we'll have this one called Get or parser itself. So this is the get request for the derived class, you can also have a post request, PUT request. Well, it depends on what you want to do and how you want to construct it. But essentially, the first thing we want to do here is we want to construct the API URL. So we want to use an F string with placeholders. And the first placeholder will be self dot URL, because that is the class variable we've got here. Okay. Second one, we want to pass through the category that we're passing through. So self dot category. Okay. And then what we can do is return self dot cool. This is the base class function. This one here, you see, we need to pass through method API URL. So we will go these positional arguments, we don't need to use keywords. So we can put get, or you can even put get like that, because we're actually using the lower method. And then we'll have API URL, we don't need to use self because this this is just a variable that we're using within the function there or a method. And is that coming through value? returned on Jason? Yeah, no shit, don't just just return the strings. And that'll be just string. That looks like it could work. Okay, so I'm gonna make, I'm gonna go ahead and test that. Hopefully, that'll work. So let's go to terminal. And what we'll do, we'll go work on Python. Course, that will fire up the virtual environment, I know that I've got parentheses followed by the name of the virtual environment. Now we'll fire up our Python interpreter. So we can use the modules import, so import projects, or project, which is this file here. Okay, so we're importing project into the Python interpreter. And now what we can do is we can go to API call dot doc. API call not found also be projects dot API call, dot doc. There we go. So that we use in the Dunder doc method, Dad's just to print out the text literal. Actually, what we'll do is import know from from, it doesn't matter. It doesn't matter. Okay, so we now have access to these classes in our Python interpreter. So now what we'll do, we will instantiate Chuck Norris to a variable c. So he if we go, project, Chuck Norris. And women, we need to pass through a category. So if I just put a he'll come through and say, Look, category options, animal death, because we've got the TypeError. If we were to put through animal, we now got C. So I can say see, dots. Get our call it get Yeah, there we go get and we'll pass through. Actually, we don't need to pass or anything was work. Happy Days, it works. So we just call the get method, the get method is constructed a URL, and then it's called the self cool method from the base class pass, we get the new URL, and then it's going around in Bali, this match statement. So it's matched, we used an if statement for the actual GET request, we could use a match statement. And then we use the match statement with a case statement to look at the status code. If the status code matches all of this, then we get the value keyword from the JSON response. And then we just return it into the Python interpreter. So what is that joke? Well, we got they say curiosity killed the cat. This is false. Chuck Norris killed the cat, every single one of them again, and then you can do it again. Oh, always coming back for the same or no, this is the same one the first time and then it made another call. So Chuck Norris once wrote a nine foot grizzly bear for an automatic carwash instead of taking a shower. Okay. Should we make one more? Oh is the same one that keeps coming up with the same one. There we go. So that works. That is the project. You can see. If we go back to the code here, you could easily just create a new class. We could call this NASA. Yeah, we can make an API call to the NASA API. We would just need to change the URL would change the categories if that was indeed the case that there wasn't categories of was a few different sorts of categories. I know in a nicer API, they've got different cameras, and what have you. So you might just configure the class slightly different. But what won't change or possibly won't change is the cool method in here. And if it was to change slightly, you could overwrite it or extend it in derived class. Okay, so I'm really happy with that that actually did work really, really well. So that is the end of this course, we've written our first project is an API call to the Chuck Norris API works really well. We're using classes, base classes, derived classes, match statements, if statements, we're using strings, we're using all sorts of stuff, we're using lists here, you can even go one step further. And you can, you can maybe do a random pick of all of the different categories. So you always got a randomized response rather than animal. So when you instantiate it, you won't get similar jokes. But hopefully, you can see now from this project that, you know, the world is your oyster, just play. You've spent the last few hours going through this course, I've showed you the absolute basics, what I think are the fundamentals of understanding Python. Okay, take what you've learned, write some programs, that is the best possible way that you can learn how to code in Python. Also, always reference back to this cheat sheet. I'll say it again, you can clone this down from my GitHub repository, this is your cheat sheet, please, please, please use it in two years time, or two months time, you might look back and go, ah, what did I What was that about dictionaries? What is that about? tuples? Why can't I do X, Y and Zed? What the methods did that whatever the case may be, you've got a cheat sheet to clone it down. It's for you or made it for you. So like I say, this is the last video. This is the end of the course. I've thoroughly enjoyed putting it together. I hope a truly hope that you've enjoyed watching it. Please, please please get in touch if you have any questions whatsoever. Thank you very much for watching, and I will see you in the next course. Thank you. Bye bye
