With timestamps:

00:00 - hey everyone welcome to the advanced
00:02 - computer vision course in this course we
00:05 - are going to learn advanced techniques
00:07 - to better our skills of computer vision
00:10 - now you might think that the term
00:12 - advance
00:13 - might not be for you now this does not
00:15 - mean that the topics are very difficult
00:18 - it just means that they are on an
00:20 - advanced level and we will do our best
00:22 - to learn it as simple as possible we
00:25 - will break it down into basic code and
00:28 - then we will create modules out of this
00:30 - so that we can use them in different
00:33 - projects once we are done
00:35 - and we will be learning four different
00:37 - chapters including hand tracking pose
00:41 - estimation face detection and face mesh
00:44 - and not just that we will also be
00:46 - creating five different projects so that
00:49 - we can learn some real world
00:51 - applications for example volume gesture
00:53 - control ai trainer ai mouse control and
00:57 - a lot more if you would like to see more
01:00 - of such content do check out my channel
01:02 - murza's workshop where we create
01:05 - projects related to computer vision
01:07 - artificial intelligence and robotics
01:10 - so without further ado let's get started
01:18 - hey everyone welcome to my channel in
01:20 - this video we will learn hand tracking
01:22 - in real time we will first write the
01:25 - bare minimum code to run and then learn
01:28 - how to convert it into a module so we
01:30 - don't have to write it again and again
01:32 - for different projects the best part is
01:34 - we do not have to configure 100
01:36 - parameters along with 20 different
01:38 - installs to make it run within 10 to 15
01:41 - minutes you will have your model working
01:44 - the framework we will be using today is
01:46 - called the
01:47 - media pipe which is developed by google
01:50 - they created these amazing models that
01:52 - allow us to quickly get started with
01:54 - some of the very fundamental ai problems
01:57 - such as face detection facial landmarks
02:01 - hand tracking object detection and quite
02:03 - a bit more so we will be covering the
02:06 - rest of these as well so make sure to
02:08 - subscribe to keep updated now the model
02:11 - we are working with today is the hand
02:13 - tracking it uses two main modules at the
02:15 - back end so
02:17 - one of them is the palm detection and
02:19 - the other one is hand landmarks now the
02:23 - palm detection basically works on
02:25 - complete image
02:26 - and it basically provides a cropped
02:29 - image of the hand
02:30 - from there the hand landmark module
02:33 - finds 21 different landmarks on this
02:36 - cropped image of the hand
02:37 - to train this hand landmark
02:40 - they manually annotated 30 000 images of
02:43 - different hands so that is a lot of work
02:47 - and this is one of the reasons it works
02:50 - so well and the best part is that it is
02:52 - cross platform and we don't have to dive
02:55 - deep into the sea of configurations and
02:58 - installations so within just two clicks
03:00 - we will be up and running so let's have
03:03 - a look at the implementation
03:05 - so right now i am in pycharm and we are
03:08 - going to first create a new project so
03:11 - you can see that i have created this
03:13 - hand tracking project
03:15 - and we will go to file settings
03:19 - and we will go to our project then the
03:22 - interpreter and we will add
03:24 - so here we are going to add our packages
03:27 - so we will write here opencv
03:31 - python
03:32 - we will install that
03:34 - and then we will write media
03:37 - pipe
03:40 - and we will install that
03:42 - so these are the only two packages that
03:45 - we will be needing
03:46 - so within
03:48 - two clicks we are ready to start coding
03:52 - so that is amazing
03:54 - okay
03:55 - so now we will create a new file
04:00 - we will call it
04:02 - let's say hand tracking
04:06 - tracking
04:08 - minimum so the bare minimum code that is
04:11 - required to run this so the first thing
04:14 - we will do we will write here import cv2
04:17 - and then we will import
04:20 - media pipe as
04:22 - mp
04:24 - and then we will import time
04:27 - so this is to check the frame rate so
04:30 - first we are going to create our video
04:32 - object so we will write here cv2 dot
04:35 - video capture and i'm going to use my
04:37 - webcam number one you can use your
04:40 - webcam number zero
04:42 - so then we will write file true
04:45 - and then we have success
04:48 - success and we have our image
04:52 - is equals to cap dot read
04:55 - so that will give us our frame we will
04:57 - write cb2 dot
04:59 - weight key 1 and we will write cv2 dot
05:03 - i am show
05:04 - i am show
05:07 - and we will write here image and
05:10 - image
05:12 - and we will write img
05:14 - so this is basically what we always do
05:17 - to run a webcam
05:19 - and what we can do as well is right here
05:23 - that if
05:24 - more doing it or we can skip it it's
05:27 - fine
05:28 - we don't need to write
05:30 - that we have to close with the q button
05:32 - so here we can right click and we can
05:35 - press the run button
05:37 - and let's see
05:40 - so there you go this is my webcam you
05:42 - can see my hand there you go and we are
05:45 - going to
05:46 - detect this hand
05:48 - so the first thing we have to do is we
05:50 - have to create an object from our class
05:54 - hands
05:55 - so here we are going to write now this
05:57 - is related to the hand detection modules
06:00 - or the hand detection model
06:02 - so later on we will create our own
06:04 - module so that we can learn how to
06:08 - use it easily in different projects so
06:11 - getting the values of these different
06:12 - points or the landmarks is a little bit
06:15 - tricky
06:16 - but
06:17 - we will create a module so that we can
06:19 - just say i want uh the point number five
06:23 - of the hand so tell me the location
06:25 - so that will become quite easy to use in
06:28 - different projects
06:29 - so first of all we are going to write
06:32 - here
06:33 - mp hands
06:35 - is equals to
06:37 - mp.solution now this is you can say a
06:41 - formality that you have to do
06:43 - before you can start
06:46 - using this
06:47 - model
06:48 - so you will write mp.solutions.hands
06:53 - and then we are going to write that we
06:56 - are going to create an object called
06:58 - hands we will write mp hands
07:01 - dot
07:02 - hands
07:04 - and then inside that we have to write
07:06 - our parameters
07:07 - now what are these parameters so let's
07:10 - go and check them out so we will click
07:12 - on we will press the control button and
07:14 - we will right click
07:16 - on this
07:17 - and it takes us to that function so here
07:20 - we can check what exactly are we getting
07:24 - uh what exactly do we have to input so
07:27 - here the first thing is the static image
07:29 - mode so static image mode they have this
07:32 - configuration where they will
07:35 - track and detect so if you put this as
07:39 - false then sometimes it will detect and
07:42 - sometimes it will track based on the
07:44 - confidence level
07:46 - but if you put it as static mode then
07:49 - the whole time it will do the detection
07:52 - part which will make it quite slow
07:54 - so
07:55 - we will keep it false so that it detects
07:59 - and if it has a good tracking uh
08:01 - confidence it will keep tracking so this
08:03 - way it will be much faster whenever the
08:06 - tracking confidence
08:07 - goes lower than a certain range then it
08:10 - will do the uh detection again
08:12 - so then you have the maximum number of
08:14 - hands so here we have two
08:17 - and then we have the minimum detection
08:19 - confidence so this is 50
08:22 - and then minimum tracking confidence
08:24 - which is 50 so it means if it goes below
08:27 - 50 percent it will do the detection
08:30 - again
08:31 - okay so now that we know our parameters
08:33 - we can go back and we can write here
08:36 - false
08:38 - so actually we are not going to write
08:40 - anything because these are the default
08:42 - parameters and they have already given
08:43 - the default values
08:45 - so
08:46 - we do not have to change or write
08:48 - anything here if we want to we can
08:50 - otherwise we can skip it as well so for
08:53 - this instance we are going to skip and
08:55 - later on we are going to write whatever
08:58 - we need
08:59 - so then
09:00 - we are going to go
09:02 - actually we will need to go back
09:04 - okay so then here in the loop we are
09:07 - going to send in our rgb image
09:10 - to this
09:12 - object
09:13 - so here we have to first convert it so
09:15 - we will write here image rgb
09:19 - is equals to cv2 dot cvt color and then
09:23 - we will write our image
09:26 - y is a double bracket okay we will write
09:28 - our image then we will write cv2 dot
09:32 - color underscore
09:34 - bgr to
09:36 - rgb
09:37 - so this is our idea that we want to
09:40 - convert it into rgb because this class
09:44 - or this object
09:45 - only uses rgb images so we need to
09:48 - convert that first so we will write here
09:51 - that our results
09:54 - results is equals to
09:57 - hands so we are calling this object
10:00 - dot process so there is a method inside
10:02 - this object called process
10:06 - that will process the frame for us and
10:08 - it will give us the results
10:11 - so that's how simple this is now all we
10:13 - need to know is how to extract this
10:16 - information and use it
10:18 - so
10:20 - after this what we can do is we can
10:23 - simply display this
10:24 - but at this point we are not really
10:26 - displaying or doing anything but i still
10:29 - want to run it to see if everything is
10:32 - working so far so it will be processing
10:34 - it but it will not display anything for
10:36 - us so let's try it out
10:43 - so there you go and now you can see even
10:46 - though it's processing
10:47 - the frame rate has not decreased it's
10:50 - uh it seems real time
10:52 - we will later on check the exact uh
10:55 - speed as well the exact frame rate so
10:57 - don't worry about that
10:59 - okay so then we are going to
11:02 - open this object up
11:05 - the the one that we have received and we
11:07 - are going to extract the information
11:09 - within so as we have seen the parameters
11:11 - we can have multiple hands so what we
11:14 - can do is we can extract these multiple
11:17 - hands so we will have to put in a for
11:19 - loop
11:20 - to check if we have multiple hands or
11:23 - not
11:24 - and we have to extract them one by one
11:27 - now before we do that we have to make
11:29 - sure that there is something in the
11:31 - results so we can print out the results
11:36 - and we can run it
11:40 - and it just gives us that it is a media
11:43 - python solution based
11:44 - solutions output
11:46 - and if i bring in my hand nothing really
11:49 - changes so we need to know when
11:51 - something is detected or not
11:53 - so to check if something is detected or
11:55 - not we can write here dot
11:58 - multiple
12:00 - uh multi underscore hand
12:03 - underscore
12:05 - and underscore landmark
12:08 - landmarks
12:10 - so let's run this and see what happens
12:14 - so here it says none
12:16 - and if i put my hand and there you go so
12:19 - straight away we are getting some values
12:23 - so what we will do is we will say that
12:25 - if
12:28 - we can remove the print or let's keep
12:30 - the print we can copy this part
12:33 - and we can go down and we can write here
12:36 - if this is
12:39 - true
12:40 - then we are going to go in
12:43 - and for each hand
12:46 - so we can say for each hand landmark
12:51 - landmarks let's say
12:54 - in results
12:56 - dot
12:57 - multi whatever we wrote here multi-hand
13:00 - landmarks so you saw that we were
13:02 - getting some results so is it of one
13:05 - hand or two hands we don't know well we
13:07 - actually know because i just put one
13:09 - hand but it could be of multiple hands
13:11 - so here
13:13 - we will have each hand and then we will
13:16 - get the information or extract the
13:18 - information of each hand so once we do
13:20 - that we have a method
13:23 - provided by the media pipe that actually
13:26 - helps us draw all these points because
13:28 - there are a lot of them
13:30 - and we you have almost how many were
13:32 - there 21 points and between each points
13:36 - if you want to draw a line
13:37 - it will be quite a lot of maths that
13:40 - would be involved there so they provided
13:42 - us with the function
13:44 - or a method for that so we are going to
13:46 - write that down
13:48 - and that is basically
13:50 - mp draw we will call it mp draw is
13:53 - equals to
13:55 - mp.solutions
13:57 - so lucian's
13:59 - dot drawing utilities
14:02 - so we will write that and now we will
14:04 - use mp draw to actually draw it so we
14:07 - will write here empty draw and then we
14:10 - are going to write draw landmarks
14:14 - and inside that we will give in our
14:16 - image that we want to draw on so we
14:18 - don't want to draw on the rgb image
14:20 - because we are not displaying the rgb
14:22 - image we are displaying the original
14:25 - image bgr
14:27 - so we will write image
14:29 - and then we are going to write
14:31 - hand
14:32 - lms so this is a single hand
14:36 - okay so there could be multiple hands
14:38 - this is let's say hand number zero then
14:40 - there could be hand number one
14:42 - so this is that single hand so if i run
14:44 - this now that should draw the
14:47 - hand for us let's try it out
14:52 - and there you go so now you can see it
14:54 - is drawing the hand for us
14:57 - and it looks pretty good
15:00 - so but these are points and i told you
15:02 - that we could draw the connections as
15:04 - well
15:05 - so how can we do that we can do that by
15:08 - writing here
15:11 - mp
15:13 - hands
15:15 - dots
15:17 - and underscore connections
15:20 - so that is it so we are using mp hands
15:23 - dot hand connections and this will draw
15:25 - the connections for us so let's try that
15:28 - out
15:31 - and there you go
15:33 - so now you can see how easily
15:35 - we got our
15:38 - uh what he called hand position
15:41 - and we got all the 21 landmarks
15:45 - if you like the video so far give it a
15:47 - thumbs up and don't forget to subscribe
15:50 - so this is good but the problem is we
15:53 - don't still know how to use these values
15:56 - so where are these values how can i
15:58 - extract and use them so for example if i
16:00 - want to track one of these positions to
16:03 - perform a certain task what exactly can
16:05 - i do
16:07 - so that is still remaining and we will
16:09 - learn how to do that but before we go
16:11 - there i want to do the frame rates so we
16:15 - are going to write the fps
16:18 - so to do that we are going to write here
16:21 - that our previous time is equals to zero
16:23 - and our current time is equals to
16:27 - time is equals to zero
16:30 - okay so once we have done that we will
16:33 - go down here
16:34 - and before we display
16:36 - we are going to write here
16:40 - current time
16:42 - is equals to time dot time
16:45 - and this will give us the current time
16:47 - and then our fps will be
16:51 - one divided by
16:53 - our current time minus
16:56 - the previous time
16:58 - previous time okay
17:00 - so then our previous time will become
17:04 - the current time
17:07 - our previous time will be the current
17:09 - time
17:11 - so
17:12 - yeah that seems good and
17:15 - what else can we do can we
17:17 - yeah i think we should display it on the
17:19 - screen so that we can see it rather than
17:22 - putting it on the console
17:24 - so we can write here cv2.cv2.put
17:28 - text
17:29 - and we want to put it on our image
17:32 - we want to convert it into a string
17:34 - because it is time
17:36 - so
17:37 - we are using what do we call fps
17:41 - fps and we also have to round it
17:44 - because or should we
17:47 - if we round it it will give us decimal
17:49 - values we don't want decimal values for
17:51 - fps we can just put integer
17:54 - so that will give us that and then
17:56 - we can give it a value the position
18:00 - let's say 10 and 70
18:02 - and then we can give in our font cb2 dot
18:06 - font
18:07 - whatever comes first
18:09 - and then we write
18:12 - then we write the scale
18:14 - and then we write the color
18:17 - so let's put purple
18:21 - or
18:22 - let's put blue whatever let's put purple
18:25 - and then we have the uh i think i missed
18:29 - something i missed a comma here
18:33 - okay and then we need to put i think the
18:36 - scale
18:37 - or the thickness the thickness let's put
18:39 - as 2 or let's put a 3.
18:43 - okay so that seems good
18:47 - and what else i think that should be
18:49 - fine let's run it
18:54 - so here we have it
18:56 - so now we can see that the time is
19:00 - around 30
19:02 - 30 fps the frame rate it goes to 20
19:04 - sometimes but most of the times it's 30.
19:07 - you can see it's quite fast
19:09 - very responsive thumbs up oh thumbs up
19:13 - makes it go away
19:15 - thumbs up
19:16 - yeah
19:18 - this time it worked thumbs up
19:20 - great
19:21 - let me try my other hand as well
19:35 - so that seems fine and it is working
19:37 - quite good so we can move on
19:40 - so now we are going to get the
19:42 - information within this hand so for each
19:45 - of these hands so we will get the id
19:47 - number and we will also get the landmark
19:50 - information so the landmark information
19:53 - will give us the x and y coordinates
19:55 - and we also have their id numbers
19:59 - and they are already listed
20:01 - in the correct order so all we have to
20:04 - do is we have to check their index
20:06 - number and that's it
20:08 - so what we can do is
20:10 - we can write here
20:12 - for id
20:14 - and the landmark
20:16 - we are going to find it or we are going
20:19 - to enumerate
20:20 - and then we are going to find it inside
20:23 - the hand
20:25 - lms
20:27 - dot landmark
20:32 - so
20:33 - this is basically our landmark
20:36 - uh this is basically our landmark that
20:38 - we are getting
20:39 - from here
20:41 - and this is the id number or the index
20:43 - number that we are getting which will
20:46 - relate to the exact index number of our
20:50 - finger landmarks
20:51 - so if it is zero it will be the bottom
20:54 - middle one
20:55 - uh then if it's four it will be a tip
20:57 - and things like that
20:59 - so what we can do is we can print here
21:02 - and we can write id
21:04 - and landmark so we can see at least what
21:07 - is happening so let's run that
21:12 - and there you go so let's see what did
21:15 - we get
21:17 - so if we go up here you can see that
21:19 - this is id number 20 19 18. so if we
21:23 - keep going back
21:25 - we keep going back we will start from
21:27 - zero so each id has a corresponding
21:32 - landmark and the landmark has x y and
21:35 - set
21:37 - so we are going to use the x and y
21:39 - coordinates to find the information or
21:42 - to find the location for the landmark on
21:44 - the hand but the thing is if you see
21:46 - here these values are decimal places
21:50 - so the location should be in pixels so
21:52 - it should be for example 500 pixels
21:56 - in the width and 200 pixels in the
21:58 - height something like that but here you
22:00 - can see these are picks these are
22:02 - decimal places so basically what they
22:04 - are giving is they are giving a ratio of
22:06 - the image so we will multiply it with
22:08 - the width and the height
22:10 - and then we will get the pixel value
22:13 - so this is how we can get it directly
22:16 - so here what we are going to do we are
22:18 - going to first check out the heights
22:21 - the width
22:22 - and the channels of our image
22:26 - which will be
22:28 - which will be
22:30 - image dot shape
22:34 - so we can write this and this will give
22:35 - us the
22:36 - width and height
22:38 - and then what we can do is
22:41 - we can
22:42 - find the position so we can write here
22:44 - cx
22:45 - and cy
22:47 - is our position of the center
22:50 - and
22:50 - basically it will be an integer because
22:53 - it is decimal places so we have to
22:56 - convert it into integer
22:58 - so we will multiply our landmark
23:01 - dot x value
23:03 - multiplied by the width
23:07 - and for the second one it will be
23:09 - integer and then landmark dot y value
23:13 - multiplied by the height
23:15 - so this will give us the cx and the cy
23:18 - position
23:22 - so
23:23 - now we can print this out but the thing
23:25 - is
23:26 - that it is
23:27 - not for a specific one it is for all of
23:30 - them so if we print it now
23:32 - let's remove this and we will
23:34 - print we will print cx and
23:39 - cy
23:40 - so if we run this now
23:43 - it will give us for all
23:45 - 21 values
23:47 - so how do we know which one is for which
23:50 - which one is for
23:52 - landmark one which one is for landmark
23:54 - two so we need to write the id of that
23:57 - as well
24:01 - so we can write it like this so there
24:04 - you go
24:05 - so now we have this information
24:08 - so
24:10 - if we look here this is the
24:15 - this is the
24:16 - id number and this is the cx and the cy
24:19 - position so what we can do is we can use
24:21 - any of these to actually
24:24 - uh
24:25 - use it to our benefit to actually print
24:27 - out any of these landmarks so i can
24:30 - write here if id is equals to zero
24:34 - this means we are talking about the
24:36 - first landmark
24:38 - then we are going to
24:40 - let's say draw the circle so we will
24:42 - write here cv2 dot circle we are drawing
24:45 - it on the previous one and we will color
24:48 - it a different way and we will make it a
24:50 - little bit bigger so it is easier for us
24:52 - to know that this is the one that we are
24:55 - uh printing so
24:57 - it shouldn't be an issue so we can write
24:59 - here that our radius is let's say five
25:02 - and then our color will be different
25:05 - it will be purple
25:07 - and then we have
25:08 - cv2 dot filled
25:11 - so
25:12 - once we have that
25:14 - now it will only draw
25:16 - for
25:17 - what you call the id number one so if i
25:20 - run this now
25:24 - and there you go so you can see here at
25:26 - the bottom
25:27 - you get okay let me make it bigger it's
25:29 - very small
25:31 - so let's make it 25
25:36 - there you go so now you can see clearly
25:38 - that we are detecting that landmark
25:40 - which is 0.
25:42 - so
25:43 - if i remember correctly 4 is also
25:46 - 4 is a tip of one of the fingers
25:49 - let's make it 15.
25:52 - 25 is too big
25:56 - there you go so it is the tip of the
25:58 - thumb
25:59 - so you can see now we are getting this
26:00 - information and what we can do is we can
26:03 - put all of this in a list
26:05 - and we can use it to print
26:07 - or we can use it to
26:09 - find the location and move around
26:12 - and do all sort of different things with
26:14 - this
26:18 - what we can do is we can also remove
26:20 - this and then it will draw on all of
26:22 - them but that's that's not useful
26:25 - because we are already drawing on all of
26:27 - them
26:28 - so here you can see
26:30 - looks quite weird
26:33 - anyways so that is the basic idea that
26:36 - this is how you get the cx and cy
26:38 - information which is basically for each
26:40 - one of these and we can put them in a
26:42 - list
26:43 - so that
26:45 - we can later on uh return this list and
26:48 - use it to our benefit if we want to
26:50 - track the index finger at the tip of it
26:53 - or the bottom part of it whatever we
26:55 - want to track we can do that
27:02 - so now that we are done with this we are
27:04 - going to create a module out of this so
27:06 - that next time if we are using it in a
27:09 - project we don't have to write all of
27:11 - this again we can simply ask for the
27:14 - list of these values of these 21 values
27:17 - of each hand for example we can say give
27:20 - us for the first hand give us for the
27:21 - second hand whatever
27:23 - and then we can simply say
27:25 - okay i need point number 10 and it will
27:28 - give us the value of point number 10
27:29 - which is
27:30 - let's say at this point it is 4 four
27:33 - four and two one zero
27:36 - so that will make it very easy for us to
27:38 - uh create new projects so let's see how
27:41 - we can do that
27:42 - so now we will create a modules file so
27:45 - here we will call its
27:48 - hand
27:50 - tracking module
27:53 - so
27:54 - we will copy pretty much all of this
27:57 - code
27:58 - and we will paste it here
28:03 - first of all
28:05 - we will write here if
28:09 - name
28:11 - is equals to
28:13 - main
28:14 - this means that if we are running this
28:16 - script
28:18 - then
28:19 - do this
28:20 - so whatever we write in the main parts
28:23 - will be like a dummy code
28:26 - that will be used
28:27 - to
28:28 - [Music]
28:29 - showcase what can this module do
28:32 - so we will write here
28:34 - def main
28:36 - and
28:38 - we are going to put our while loop
28:40 - inside of this
28:41 - so
28:42 - while true
28:46 - and in fact all of this as well
28:50 - uh
28:51 - not that let's copy this part first
28:56 - so we'll put this here and then this
28:59 - part here also
29:02 - for the frames
29:04 - fps we will put it down here
29:08 - and what else
29:09 - what else do we need
29:11 - yeah the video capture
29:15 - we can put it here
29:20 - wait why did it show here okay i think i
29:22 - copied it or what
29:24 - yeah so we need to remove this
29:28 - okay and then
29:32 - what else
29:33 - what else i think that is fine for now
29:37 - so now what we have to do
29:40 - we have to create our class
29:42 - so i thought of doing it in functional
29:44 - programming
29:45 - but i think it will be better if we
29:47 - create a class
29:49 - so we are going to create a class here
29:52 - we will call it class
29:55 - and detector
30:00 - and inside that we will write
30:02 - def inits
30:05 - in itself and inside that we have to
30:08 - give in our parameters so these
30:10 - parameters are the basic parameters
30:13 - that are required for this hands
30:17 - so if you remember
30:18 - we went to the hand and we have all
30:20 - these parameters so these are the ones
30:22 - that we will be using to input that
30:25 - so so that we have the flexibility of
30:28 - changing these
30:30 - so here we have the mode so we will
30:33 - write here mode
30:35 - is equals to false
30:38 - then we are going to write the
30:41 - max number of hands
30:43 - so we can write here
30:44 - max
30:46 - hands is equals to
30:48 - 2. then we can write the
30:53 - detection
30:54 - the direction confidence
30:57 - is equals to 0.5
30:59 - and the track confidence
31:02 - is equals to 0.5
31:08 - so then we can remove all of this
31:12 - and now the first thing we have to do is
31:14 - we have to write self dot mode
31:19 - is equals to mode
31:21 - this means that
31:23 - we are going to create an object and the
31:25 - object will have its own variable
31:28 - so this is that variable whenever we are
31:30 - using the variable of the object
31:33 - we will call it self dot something
31:37 - and we are assigning it initially we are
31:39 - assigning it a value provided by the
31:42 - user
31:43 - so we are calling uh we are calling it
31:45 - mode and we are providing it the value
31:47 - of the mode
31:49 - so the same thing we have to do with the
31:51 - other parameters so we will write here
31:53 - max
31:54 - hands is equals to max hands
31:59 - self dot
32:01 - detection
32:04 - confidence is equals to detection
32:07 - confidence self dot
32:10 - tracking confidence
32:14 - track
32:15 - confidence
32:16 - is equals to track confidence
32:19 - and then all of these have to be
32:22 - inside this initialization as well so if
32:25 - you remember
32:26 - they are part of the initial code where
32:30 - we are initializing everything and then
32:31 - there is the while loop so we need to
32:33 - initialize these as well
32:35 - over here and again we will write here
32:38 - self dots
32:41 - so we will keep putting self dot
32:43 - everywhere
32:46 - and we also have to
32:49 - so why is this
32:50 - giving an error empty hands
32:53 - because we need to add the self here as
32:56 - well
32:57 - so we will write here
32:59 - self.mphands.hands
33:03 - so that should be good
33:07 - and inside that we have to give in our
33:09 - parameters so the parameters will be
33:13 - self
33:14 - mode
33:16 - then the max
33:18 - hands
33:22 - the confidence
33:25 - and the tracking confidence
33:35 - there you go so this should be fine
33:39 - so i think the
33:41 - initialization is done
33:43 - so now we can move on to the
33:46 - uh detection part so we can write here
33:48 - let's say
33:49 - we will call it
33:52 - find hands
33:56 - and inside that we have to just copy
34:00 - this part
34:02 - so
34:03 - do we need to convert we do need to
34:05 - convert
34:07 - and we need to put this as well so we
34:09 - will put all of this
34:12 - we will put it here
34:14 - inside
34:16 - and then
34:17 - we will
34:18 - go back up here
34:21 - and let's start from here so first of
34:23 - all we will need an image to find the
34:25 - hands-on
34:26 - so that will be this image and then
34:28 - hands is not
34:30 - being recognized because it has to be
34:32 - self-taught hands
34:34 - so we are talking about this object
34:37 - within this uh object
34:40 - so then we have mp.draw so this should
34:45 - be self.mp draw and then self dot hands
34:49 - connection
34:50 - so that should be good
34:52 - and should we draw it inside
34:57 - i i don't think we need to draw it here
35:00 - in fact
35:02 - we
35:03 - do not even need to get the landmarks
35:05 - from here
35:07 - what we can do is we can keep this
35:09 - outside
35:10 - and we can comment this
35:13 - so here this is what we need basically
35:16 - to draw the hands so we can put a flag
35:19 - here we can write here draw
35:22 - and we can put it by default as true
35:27 - and we can check if we want to draw or
35:29 - not so here we can write here if draw
35:32 - then do this
35:37 - okay so it will only draw
35:39 - if we ask it to draw
35:41 - so i think this is good enough to
35:45 - actually run
35:46 - the code or the run the
35:49 - class without uh actually getting the
35:52 - list
35:53 - so for testing this should be fine
35:56 - so what we can do here so we will create
35:59 - a new method
36:01 - within this class that will find the
36:04 - position for us it will give that list
36:06 - for us
36:07 - but for now we will just test to see
36:10 - everything is working so far or not
36:12 - so here we will first
36:14 - create our object we will call it
36:16 - detector
36:18 - is equals to hand detector
36:21 - and we will not give in any parameters
36:24 - because we know that we have these
36:26 - default parameters already there
36:29 - so once that is done we will get our
36:32 - image
36:33 - and once we get the image we are going
36:35 - to send this image
36:37 - we are going to write here detector
36:40 - dot now this is the method here find
36:43 - hands so this is the method within our
36:47 - class so we will write here
36:49 - find hands and we have to give in our
36:51 - image so that is the most
36:53 - important component
36:56 - so we might need to draw on it so we
36:57 - need to return the image if we have
36:59 - drawn on it
37:01 - so we will return
37:04 - the image
37:06 - so
37:07 - then we can go back and take the image
37:09 - over here so image is equals to
37:12 - this
37:13 - so if we run this now as a module it
37:16 - should work
37:18 - so let's see if we did any mistake
37:26 - uh
37:28 - yeah it's working
37:30 - oh yeah that's good
37:33 - so
37:34 - now our module is running is the main
37:37 - reason for creating this module is to
37:39 - get those position values of the
37:41 - landmarks very easily so we need to
37:44 - create that find position function
37:46 - or the method so we will write here
37:49 - find
37:51 - position
37:53 - and we are going to give in the
37:56 - parameters of our image
37:58 - now we don't really need the parameter
38:00 - of the image but we need it for the
38:02 - width and the height so if you remember
38:04 - here we need the shape
38:07 - so we can do it in other ways but this
38:09 - is simple so we will try it now later we
38:12 - can improve on it
38:14 - then we need the hand number
38:16 - so if you are detecting with if you want
38:18 - the information of hand number one hand
38:20 - number two and number three whichever
38:22 - hand you want you can ask the
38:23 - information of that
38:26 - and then we will have the parameter for
38:29 - draw
38:30 - so again we will put it as true by
38:32 - default so now we can uncomment this
38:35 - and we can bring it back
38:38 - okay so that should work
38:40 - now
38:42 - here the issue is that we were using a
38:45 - for loop
38:46 - to actually run this but now we need to
38:49 - first check again
38:52 - we will go back here and we will create
38:54 - a list here
38:56 - lm
38:57 - this is the landmark list that we are
38:59 - going to return so this list will have
39:02 - all the landmark positions
39:04 - so we can return this whether it is
39:06 - filled or not we will return it
39:10 - so we will return this
39:12 - and then we are going to check again
39:15 - that whether any landmarks were detected
39:17 - or not or any hands were detected or not
39:20 - so to do this we use basically
39:23 - this part here
39:24 - so if the self results
39:27 - multi-hand landmarks if that is
39:29 - available
39:30 - then we are going to check
39:32 - the next things
39:34 - so here we will write this
39:36 - and we will put all of this inside that
39:41 - so but here we are getting the results
39:44 - this is
39:46 - the results it should be self.results
39:51 - self.results
39:52 - and now i can use
39:54 - the results here as well
39:57 - okay
39:58 - so
39:59 - now we need to replace this here as well
40:02 - okay
40:03 - so if it's not self then i cannot use it
40:06 - in this method
40:08 - to use it in all the methods you have to
40:10 - make sure this is
40:12 - for this object
40:14 - this variable
40:16 - okay
40:17 - so now
40:18 - we have to write down that which
40:22 - hand are we talking about because
40:24 - earlier we were getting it for all the
40:26 - hands so if you want you can get it for
40:28 - all hands it's up to you but i'm
40:30 - creating this method to get the
40:33 - uh to get for one particular hand if you
40:36 - want you can change that too so here we
40:39 - are going to write so earlier we had
40:40 - four hands this this this
40:43 - now we will get this
40:46 - and we will point to
40:49 - we will point to
40:50 - a particular number and that number will
40:53 - be the hand number
40:55 - so we will say
40:57 - that our
40:58 - let's say
41:00 - our hand let's say we'll call it my hand
41:04 - is equals to this
41:05 - and we will put this over here
41:09 - so it will get the first elements the
41:12 - first hand
41:13 - and then within that hand it will get
41:15 - all the landmarks
41:17 - and it will put them in a list so here
41:19 - we are just printing them out so here we
41:22 - can write
41:23 - uh lm lists
41:26 - list dot append
41:28 - and we want to append the values of id
41:32 - cx and cy
41:37 - and we can remove the print because
41:39 - we're getting it anyways
41:41 - so
41:43 - yeah so that is
41:44 - i think that is good
41:46 - and here we have the option of draw as
41:48 - well
41:49 - so we can write here
41:51 - if draw
41:53 - then do this
41:56 - otherwise don't so by default it is true
41:58 - so it is going to draw
42:01 - so yeah let's see how that works out so
42:04 - we can return this list
42:06 - so i can call this
42:10 - so we can go down here and i can call
42:12 - find position
42:14 - and we can remove the self and we have
42:17 - the image
42:19 - and do we need anything else i don't
42:21 - think so
42:23 - okay copying this was a bad idea
42:26 - anyway so finding positions of image
42:29 - yeah
42:30 - and it will give us the list so we can
42:32 - copy this and we can paste here
42:35 - so now what i can do is by the way we
42:38 - have to write detector dot find position
42:41 - so now what i can do is i can print the
42:43 - value
42:44 - of
42:45 - my list at any index so if i want let's
42:49 - say
42:50 - uh the zero index then i will write here
42:53 - zero if i want the landmark number four
42:56 - i will write here four so if you
42:57 - remember the 4 was the tip of the thumb
43:00 - so this will give us that position so
43:02 - let's run this and see what happens
43:07 - index is out of range okay so that is uh
43:12 - understandable why because
43:15 - here we have to check if
43:17 - nothing is found which means lm list
43:20 - the length of it is zero so we will
43:22 - write here that the length of this list
43:25 - is 0
43:26 - then we will
43:28 - if it's not equal to 0 then we will
43:30 - print
43:34 - so let's run it again
43:37 - and there you go so if i put my hands
43:41 - so now you can see it's drawing for all
43:43 - of them but it is showing me only
43:46 - landmark number four so if if you look
43:49 - at my thumb
43:50 - so if you look at my thumb
43:53 - if i'm going really to the okay it's not
43:56 - moving the values
44:00 - okay so now
44:02 - if i go
44:03 - till the very end you can see it is 600
44:06 - something
44:07 - because the value is 640 the max value
44:11 - and now if i go around to
44:13 - the starting point it goes
44:16 - uh
44:17 - around
44:18 - 150 something
44:21 - so i'm talking about the x position by
44:23 - the way
44:24 - so the x position is changing like this
44:26 - then we have the y position here it is
44:28 - going towards zero
44:30 - and down here
44:32 - if we go down here it is going towards
44:34 - 400 something so this is a 640 by 480
44:38 - image
44:40 - it works well with 1280 and 720 as well
44:44 - so it's still around 20 something frames
44:47 - per second
44:49 - so that is quite good
44:51 - okay so now this is working as a module
44:55 - and what we can do is
44:57 - we can use this in a different project
44:59 - now you might say how can we do that
45:01 - well here is the dummy code so
45:05 - this dummy code we can use to actually
45:09 - uh run in a different project so i can
45:11 - copy this
45:13 - and i can
45:14 - create let's say
45:18 - my
45:19 - new
45:20 - game
45:23 - game
45:24 - hand tracking
45:26 - blah blah blah okay that's a very long
45:28 - name
45:29 - um so i can i can paste this here
45:33 - uh the complete code and i can
45:36 - remove the indentation
45:39 - and then i can import
45:43 - i can import these
45:48 - so then i need to check what is missing
45:50 - so here
45:52 - now i need to imports
45:54 - i will import hand tracking module
45:58 - and tracking module
46:01 - as
46:03 - h
46:04 - t m
46:07 - so now i will write htm
46:10 - dot hand detector
46:12 - and the rest will remain the same so
46:14 - that is pretty much it
46:16 - so if i run this now
46:18 - it should run exactly the same
46:22 - so there you have it
46:24 - and there you go so now it's giving me
46:26 - the values of the index uh not the index
46:30 - the tip of the thumb
46:32 - which is uh landmark number four and it
46:34 - is showing me all the landmarks
46:37 - uh as we have drawn so if i if i go back
46:40 - here
46:42 - if you like the video so far give it a
46:44 - thumbs up and don't forget to subscribe
46:47 - to my
46:49 - module i can change the color or i can
46:52 - change the size of these as well again
46:54 - all these parameters you can change you
46:56 - can add to your methods
46:58 - if you wish
46:59 - and it could become easier for you it
47:02 - depends on your project so
47:04 - if you have a lot of different um things
47:07 - that you want to accomplish within one
47:10 - project then you can add more methods to
47:13 - this
47:13 - to compensate for that
47:16 - so here let's say we will make it a
47:18 - little bit smaller so 15 is too big we
47:21 - will make it seven let's say
47:23 - and let's change the color so it's bgr
47:27 - so let's make it blue
47:32 - and there you go so now we have changed
47:34 - it
47:35 - and if we go back actually i preferred
47:38 - the previous one
47:40 - even the big aspect
47:42 - so um
47:44 - here what we can do is if you don't want
47:46 - to show it
47:47 - we can write here
47:49 - false
47:52 - and it will not display
47:56 - oh it's displaying wait why is it
47:57 - displaying
48:00 - so
48:02 - why is it displaying let's go back
48:07 - here and if draw
48:12 - then only we do this
48:16 - okay maybe it's drawing here as well
48:22 - am i running this
48:27 - yeah i'm running the correct file
48:30 - but when i write false here
48:34 - oh there are more arguments that's the
48:37 - problem
48:38 - there are more arguments so we cannot
48:40 - just write here we have to write draw is
48:42 - equals to false
48:44 - my bad straw is equals to false
48:51 - and there you go the drawing is gone
48:53 - that the custom drawing that we did now
48:56 - if you want to remove this drawing as
48:57 - well you can write here
49:00 - draw is equals to false
49:07 - and there you go so now you will see
49:09 - that you are getting the value of the
49:11 - thumb
49:12 - but nothing has been drawn
49:14 - so this way you can
49:17 - customize it to your needs
49:25 - hey everyone welcome to my channel in
49:27 - this video we will learn pose estimation
49:30 - we will detect 33 different landmarks
49:32 - within a human body and all of this will
49:34 - be done in real time that's right more
49:37 - than 24 frames per second and only
49:40 - running cpu
49:41 - we will first look into the basic code
49:44 - required and then we will create a
49:46 - module out of this so that we don't have
49:48 - to write the code again and again and
49:50 - yes we will be creating a lot of
49:52 - projects with this so don't forget to
49:54 - subscribe and hit that like button
49:57 - so here we are in our python project and
50:00 - you can see that we have named it pose
50:03 - estimation project
50:04 - and we have a folder here with post
50:07 - videos
50:08 - so if i open this up
50:12 - you can see that we have a lot of
50:14 - different types of videos we have a
50:16 - total of nine videos
50:18 - so let me play a few so here you can see
50:26 - this one is a little bit smaller
50:30 - and some of these videos are actually
50:32 - slow motion so when we are running it it
50:34 - will look like it's slow but it's not
50:36 - actually slow it's actually slow motion
50:39 - so
50:40 - like this video and then i think
50:43 - what else i think this video as well
50:45 - it's slow motion
50:48 - and
50:49 - i think this one is fine
50:51 - this one is normal this one is slo-mo as
50:54 - well
50:57 - so i took these videos i think from
50:59 - pixels.com
51:01 - so
51:02 - we are going to test these videos out
51:05 - and see how well does our
51:08 - pose estimation work so we will select
51:10 - all of this
51:12 - or let's let's create a new file let's
51:14 - delete this one
51:17 - so let's delete this
51:20 - and now we are going to create a new
51:23 - file and we will write here pose as the
51:26 - mason
51:28 - uh minimum so this is the bare minimum
51:30 - code that is required to run it and
51:32 - later on we are going to see how we can
51:34 - create a module out of this so that we
51:36 - don't have to write the code again and
51:38 - again for a lot of different projects
51:41 - so let's start
51:43 - by importing cv2
51:46 - and then importing
51:49 - media
51:50 - pipe
51:51 - as
51:53 - mp
51:54 - but now you can see that we get an error
51:56 - this is because we did not
51:59 - include these packages in our project so
52:02 - how can we include those so we will go
52:04 - to file settings
52:06 - and we will go to
52:08 - our project interpreter and open that up
52:12 - and here we will write opencv dash
52:15 - python
52:16 - and we will hit install and then we will
52:19 - write media pipe
52:21 - and we will hit install
52:24 - so now both the packages have been
52:26 - installed and we can go back and you can
52:28 - see the error is now gone
52:30 - so opencv is the library that we will be
52:33 - using for image processing and media
52:35 - pipe is the framework that will allow us
52:37 - to get our pose estimation
52:41 - so now the first thing we will do we
52:43 - will read our video so we will write
52:45 - here cap is equals to
52:48 - cv2 dot video capture
52:50 - and we will simply give in our video
52:53 - number so here we will write pose
52:56 - videos
52:58 - videos and we will write
53:02 - video number one dot mp4
53:05 - i think the one is
53:07 - quite big let's let's try it out and
53:10 - later we can change it if we want
53:12 - and then we will write while true
53:16 - and we will write success and
53:20 - image is equals to cap dot read
53:24 - so that will give its
53:26 - uh our image and then we can write here
53:28 - cv2 dot i am show
53:31 - and we will write here image
53:34 - image and then we will write here
53:37 - image
53:38 - and then we will write cv2 dot
53:40 - weight key and we will write one so that
53:43 - we get a one millisecond delay
53:46 - okay so let's run this and see if it
53:48 - works
53:51 - and there we have it so our
53:53 - video went quite fast so
53:57 - the frame rate is actually quite high at
53:59 - this point what we can do is we can
54:01 - check the frame rate by writing here
54:04 - time
54:06 - let's say current time is equals to
54:10 - uh we need to import time as well so we
54:12 - will write here import time
54:14 - and then we will write
54:16 - time
54:17 - dot time
54:20 - then we will write that our fps is
54:23 - equals to
54:25 - 1
54:27 - divided by
54:29 - our current time
54:31 - minus our previous time
54:34 - and our previous time
54:36 - is equals to current time
54:38 - and we need to define the previous time
54:40 - up here at the top
54:42 - so we'll write here previous time is
54:44 - equals to zero
54:46 - and then we can simply put our text so
54:48 - we will write here put
54:50 - cv2
54:51 - dot put text and we will write in our
54:53 - image
54:54 - and then we will write in
54:57 - the text itself so we will write string
55:00 - fps
55:02 - but we will convert it into an integer
55:04 - before we do that then after that
55:08 - we have our origin so let's say 70
55:12 - and 50
55:13 - and let's say
55:14 - the cv2 dot
55:17 - font plane and let's say
55:20 - uh three
55:23 - and then for the color we can put
55:26 - two five five
55:27 - zero and two five and zero
55:30 - and then we can put
55:32 - three so this should give us our frame
55:36 - rate let's try that out
55:39 - uh wait what happened
55:41 - okay
55:42 - this should be below
55:44 - over here my bad
55:46 - so
55:47 - let's run it again
55:49 - and there we have it so you can see it's
55:52 - a hundred something frames per second so
55:54 - that's quite a lot if you want to reduce
55:56 - it we can put here let's say 10
55:59 - so
56:01 - now it's like 50 60 frames per second
56:03 - but when we are using our model it will
56:05 - automatically slow it down so we don't
56:07 - need to worry about that
56:09 - so
56:10 - the next step would be to create our
56:14 - model so our objects so that we can
56:17 - detect our pose
56:20 - so here we are going to write
56:22 - mp pose
56:24 - pose is equals to
56:26 - mp.solutions
56:28 - so solutions
56:31 - dot pose
56:33 - so we are going to use this and then we
56:35 - are going to create our object we are
56:37 - going to say pose is equals to mp pose
56:41 - mp pose
56:43 - dot pose
56:45 - and then we will give in our parameters
56:47 - so if we go to the parameters you can
56:50 - see that we have the static image mode
56:52 - this is basically that when you are
56:56 - detecting and when you are tracking so
56:58 - if you put it as true then it will
57:01 - always detect based on the model
57:03 - it will always try to find the new
57:05 - detections but when you put it as false
57:08 - it will try to detect and when the
57:10 - confidence is high it will keep tracking
57:13 - so there will be a tracking confidence
57:15 - and then there will be a detection
57:17 - confidence so whenever it detects
57:20 - if the confidence is more than 0.5 it
57:22 - will say okay now we have detected now i
57:25 - will go to tracking now the tracking
57:27 - will check if the tracking confidence is
57:30 - more than 0.5 it will keep tracking
57:33 - whenever it goes below 0.5 then it will
57:36 - come back to detection so this way we do
57:39 - not use
57:40 - the heavy model again and again for
57:42 - detection instead we use detection then
57:45 - tracking then whenever it's lost we use
57:47 - the detection again
57:49 - so this is what this does and then we
57:52 - have the upper body only so you can
57:54 - decide if you want to detect only the
57:57 - upper part so it will have you can see
57:59 - here
58:00 - we have 33 poses landmarks or only 25 so
58:05 - it's up to you which one do you want to
58:06 - use and here we also have a feature to
58:09 - smooth
58:10 - which is by default true so we will keep
58:13 - it as true so we can define all of these
58:15 - parameters or we can skip them it's up
58:18 - to us so for the initial purposes we are
58:21 - going to skip all of these for the
58:23 - simplicity
58:24 - so then we are going to go down here
58:29 - and simply we are going to convert our
58:31 - image so we will say image rgb is equals
58:34 - to
58:35 - cv2 dot cvt color so this image is in
58:39 - bgr
58:40 - but this
58:42 - library or this framework uses rgb so to
58:47 - make it compatible we have to convert it
58:50 - so we will write here image and then we
58:51 - will write cv2 dot
58:54 - cv2 dot what color
58:57 - underscore
58:59 - bgr to rgb
59:05 - so this is our conversion and once we
59:07 - have done the conversion we are simply
59:09 - going to send this image to our model so
59:13 - we will write here results
59:15 - is equals to
59:17 - pose dot
59:19 - process
59:20 - and we will write image rgb so that's
59:23 - pretty much it
59:25 - so that will give us our
59:28 - detection of our pose but it will not
59:31 - draw anything but for now we can just
59:34 - run it to see if everything is working
59:36 - and now you can see that the frame rate
59:38 - has decreased
59:40 - so this is good to see
59:42 - that our model is actually working but
59:44 - you can see that it's almost uh real
59:47 - time so that is really good
59:49 - so now what we can do is we can draw our
59:52 - landmarks or whatever we have detected
59:53 - we can draw it but before we do that we
59:56 - can print the results as well so we can
59:58 - write here results
59:59 - and let's see what do we get so here you
60:02 - can see we get nothing so it's just a
60:04 - class but we don't see any information
60:06 - so how do we see the information
60:09 - we simply write results dot
60:12 - pose
60:13 - landmarks
60:15 - land
60:16 - marks
60:18 - so if we run that
60:20 - now you will see that we are getting
60:22 - actual landmarks so each landmark will
60:25 - have the x y and z value and then it
60:28 - will also have a visibility value so how
60:31 - visible is it
60:33 - so this is
60:34 - the information that we get
60:36 - so we can put all of this in a list
60:38 - later on so that it's easier to access
60:42 - so then we will check if it is detected
60:45 - or not so we will say that if
60:48 - this is present
60:51 - if this is true
60:53 - then
60:54 - we are going to write here
60:56 - that mp
60:58 - draw
61:01 - dot draw landmarks
61:03 - draw underscore landmarks
61:07 - and then we are going to define our
61:09 - parameters but here you can see we don't
61:11 - have anything called mpdraw so we are
61:13 - going to declare that we will write here
61:15 - mpdraw
61:18 - draw
61:19 - is equals to mp.solutions
61:24 - solutions dot draw utilities
61:27 - so we will use that and then we can
61:29 - write here
61:30 - uh within our landmarks we can send in
61:32 - our image then we can write results
61:36 - dot
61:37 - uh pose landmark so this is the same
61:39 - thing that we are printing out that we
61:41 - got so we will write here land marks
61:44 - and then what do we have
61:47 - uh i think that is good let's do that
61:50 - let's run it
61:52 - and there you go so now you can see we
61:54 - are getting all the points you can see
61:56 - that it is in red now what we can do is
61:59 - we can also add the connections or the
62:02 - lines between these so here we can write
62:07 - mp
62:08 - dot
62:08 - not mp pose dot
62:11 - pose connections
62:13 - so that will fill up the connections
62:17 - there you go so now you can see we have
62:19 - the green lines which are the
62:20 - connections and then we have the points
62:22 - as well and we are detecting them all at
62:26 - real time so that is very very amazing
62:30 - so
62:31 - now we know that we are getting this
62:33 - information but how can we know which is
62:37 - for which so here it just says landmark
62:39 - this landmark this
62:41 - there is no indication of which landmark
62:44 - represents what
62:45 - so what we need to do is we need to
62:47 - organize a little bit so that it is in a
62:50 - list and we can simply use these values
62:54 - um in our project so for example i will
62:56 - say i want landmark number five i want
63:00 - landmark number three so if we go to the
63:02 - media pipe
63:04 - website
63:05 - you can see here
63:07 - that these are the landmarks that they
63:09 - have given so for example if i want the
63:12 - right ear so i can just say i want the
63:14 - element number five element number eight
63:17 - so give me that element if i want the
63:19 - nose i can say give me the element
63:21 - number zero so
63:23 - based on this it will become very easy
63:25 - for us to actually uh create our new
63:28 - projects so gesture recognition and
63:32 - lots of different applications will
63:34 - become very very easy
63:36 - so how can we extract the information
63:39 - within this object
63:41 - so what we can do is we can write here
63:44 - for id
63:46 - and landmark
63:49 - in
63:51 - enumerate
63:53 - we will write this result so we are
63:56 - going to loop through this
63:59 - and we want the count as well that's why
64:01 - we have written enumerate so it will
64:04 - give us the loop count over here so 0 1
64:06 - 2 3 and so on
64:08 - then we are going to get the shape
64:12 - actually this will be
64:15 - we have to add here landmarks
64:19 - landmark
64:21 - and then we are going to write here
64:24 - height width and channel is equals to
64:27 - img
64:30 - dot shape
64:31 - and the reason we need this shape is
64:33 - because
64:35 - uh let me actually show you why and you
64:37 - will understand so what we can do is we
64:38 - can write here print
64:40 - and we can write lm
64:42 - dot x
64:44 - or let's just print lm so you can see
64:47 - what is happening and we can print the
64:49 - id number as well so you know
64:51 - what exactly are we extracting here
64:54 - so let's run this
64:58 - so there you go so now you can see we
65:00 - have the id number and this is the
65:02 - information of the landmark
65:04 - so
65:05 - 30 is this
65:07 - 21 is this
65:09 - and it goes all the way to
65:12 - wait why is this showing i think i
65:14 - didn't remove the other print anyways so
65:16 - you can see here from 0 to 32 we will
65:19 - have all these 33 landmarks so
65:23 - let's go down
65:26 - and let's just remove the previous print
65:28 - first
65:29 - okay
65:30 - so now we know that we have the id and
65:32 - we have the landmark but you can see the
65:34 - landmarks they are actually in decimal
65:36 - places so this is basically a ratio of
65:40 - the image
65:41 - so what we can do is to get the actual
65:44 - pixel value
65:45 - we can say that
65:47 - lm.x
65:49 - this will give us this x value
65:51 - multiplied by
65:53 - the width of the image
65:56 - so that will give us the
65:58 - uh x of our
66:00 - what do you call
66:02 - the point or the landmark so it will
66:04 - give us the exact pixel value the same
66:06 - thing we can do for lm dots
66:10 - y
66:11 - and we can multiply it with the height
66:14 - so we can do that and then what we can
66:16 - do is we can put them in our cx and cy
66:20 - variables
66:21 - so this way it will be easy for us to
66:23 - use
66:24 - the indentation is wrong
66:27 - that is why it's giving an error okay so
66:30 - also we need to convert this into
66:32 - integer because
66:34 - we have to make sure it's not a float or
66:36 - a double
66:39 - because we are talking about pixel
66:40 - values so then what we can do is to
66:43 - confirm that this is happening and we
66:45 - are getting the correct values we can
66:47 - simply print the circle
66:49 - uh on top of this point so we can write
66:51 - here cv2 dot
66:53 - circle
66:54 - and in the circle we will write image
66:57 - and then we will write cx and cy
67:02 - and then we can write let's say the
67:04 - value of 15
67:05 - 15 will be too big let's say 10
67:08 - then 2 5 5
67:10 - 0 2 5 5
67:12 - this is purple let's make it blue
67:15 - and then we will write cv2
67:18 - dot filled
67:23 - so this will overlay on the previous
67:26 - points if we are detecting it properly
67:29 - so let's try it out so there you go so
67:31 - now you can see we have those blue dots
67:33 - and these are the ones that we put
67:35 - ourselves so this means that we are
67:38 - getting the correct information at the
67:40 - correct pixel values and it is working
67:42 - good we can reduce this to five
67:47 - there you go much better
67:48 - actually let's try another video we have
67:51 - been using the same video we have like
67:53 - nine videos so let's try a random one
67:56 - number five
67:58 - yeah that looks good
68:00 - let's try number six
68:05 - yep that is good
68:07 - number
68:09 - three
68:12 - there you go
68:14 - okay here we had an issue but now it's
68:16 - fine
68:18 - that's good
68:20 - so we can see that we are getting good
68:22 - results and that should be good enough
68:24 - for us
68:25 - so
68:31 - next what we can do is we can convert
68:33 - this into a module so that we can
68:35 - use these values very easily so the
68:38 - first thing we will do we will go here
68:40 - and right click
68:41 - and we will create our module let's call
68:44 - it
68:45 - pose
68:47 - module
68:50 - and we will copy all of the bare minimum
68:52 - code
68:53 - and we will paste it here
68:56 - so that looks good
69:00 - now the first thing to make it a module
69:03 - we have to write
69:04 - here
69:06 - if
69:07 - underscore underscore name
69:10 - is equals to
69:12 - underscore underscore main
69:16 - then we are going to write main
69:19 - so what this does is that if we are
69:21 - running this
69:22 - by itself then it will run the main
69:25 - function and if we are just calling
69:28 - another function it will not run this
69:30 - part
69:31 - so this is what it means so we will
69:34 - write here
69:37 - main
69:38 - and within the main we are going to
69:40 - write everything or we will write the
69:42 - dummy code in the main so whenever you
69:44 - want to see what a module is capable of
69:47 - or the testing script you can put it in
69:50 - the main function
69:51 - so here
69:54 - we will
69:56 - we will take this
69:59 - till here we will cancel it from here we
70:02 - will cut it and we will paste it in the
70:05 - main
70:07 - then we will take all of this as well
70:12 - we will cut it and paste it in the main
70:14 - again
70:16 - so
70:19 - that should be good
70:22 - and what else so now we are going to
70:25 - create
70:26 - a class
70:27 - so in that class what we should be able
70:29 - to do is we should be able to create
70:31 - objects and we should be able to have
70:34 - methods that will allow us to detect the
70:36 - pose
70:37 - and find all these points for us
70:40 - okay
70:41 - so here we are going to say that our
70:44 - class
70:45 - let's say is pose detector
70:50 - and
70:51 - inside that we will have our first
70:53 - method which is the init
70:56 - this is the initialization
70:58 - so we will write here in itself
71:01 - and then we are going to write in the
71:04 - parameters that are required so whatever
71:07 - parameters we are expecting we will
71:08 - write here
71:10 - so here we are going to write mode
71:12 - so if i go to where is it
71:15 - okay let's go to pause estimation and
71:18 - here
71:19 - we are going to go to pose
71:22 - so i will copy all these parameters
71:25 - and we will just paste them here
71:29 - and we will write so the first one is
71:31 - mode so we will keep it as false so that
71:34 - we get fast detections
71:36 - uh
71:37 - fast detection plus tracking and then we
71:40 - will write here upper body so upper body
71:44 - is equals to false
71:46 - and then we have the smoothness
71:50 - smooth is equals to true
71:53 - and then we have
71:55 - the the
71:57 - detection confidence
72:00 - is equals to 0.5
72:02 - and then we have the tracking confidence
72:05 - is equals to
72:06 - 0.5
72:08 - so these will be our initial parameters
72:11 - and then
72:12 - we can remove this
72:14 - and then we can write here that self
72:18 - self dot mode
72:20 - is equals to mode now if you are not
72:22 - familiar with object oriented
72:24 - programming then this basically means
72:26 - that uh whenever we create a new object
72:29 - it will have its own variables so this
72:32 - whenever you write self dot something it
72:35 - is the variable of that object so
72:38 - whenever we are using um a variable
72:41 - within our class we will uh write self
72:45 - dot something so self dot objects sorry
72:48 - self dot mode dot self.upbody so we are
72:50 - going to write that so here we are
72:52 - saying
72:53 - that
72:54 - the specific variable of our class or
72:58 - our object is basically the one
73:01 - that the user has provided
73:03 - so it will set this
73:06 - instance of that object to false
73:09 - so this is what it does
73:11 - so here we will copy all of these and we
73:13 - will write up body
73:16 - is equals to up body
73:19 - and then we will write smooth
73:22 - is equals to smooth
73:24 - and then we will write detection
73:26 - confidence is equals to detection
73:28 - confidence and we will write track
73:30 - confidence is equals to track confidence
73:33 - so as i mentioned before we just have to
73:35 - put self dot
73:37 - in front of each one of these and that
73:39 - should be good to go
73:42 - so next we also have to
73:45 - declare these
73:46 - so again this will be part of that
73:48 - object so we need to write self so here
73:52 - we will write
73:54 - self.draw
73:55 - self.impose and self.pose
73:59 - and we will write here self dot impose
74:03 - so this is good and what we can do is
74:07 - earlier we were not using any of these
74:09 - parameters but now we have to so here we
74:12 - are going to send in all the parameters
74:14 - so we will write yourself that mode
74:16 - so self.body
74:21 - self.smooth
74:26 - self thought detection confidence
74:31 - and self thought tracking confidence
74:36 - so that is
74:37 - pretty much it okay we need to put a
74:39 - comma here
74:41 - yeah so our initialization is pretty
74:43 - much done
74:45 - and now what we can do is
74:47 - we can
74:48 - uh create a method to find the pose so
74:51 - we can write here
74:52 - find pose
74:57 - and we do have to write self here so
75:00 - whenever we are creating a new method we
75:02 - have to write cell first
75:03 - and then we have to give in our image
75:06 - and then we will also have a flag called
75:10 - draw
75:11 - and we will put it as true so this
75:14 - basically what it will do is it will ask
75:16 - the user do you want to draw or not do
75:19 - you want to display it on the image or
75:21 - not
75:22 - so we want to
75:23 - we want to display so we are going to
75:25 - put this
75:26 - inside here
75:28 - and then
75:32 - uh
75:33 - this draw if results draw this this this
75:36 - yeah this will be separate
75:39 - this for loop will be separate and this
75:42 - results will be here so
75:44 - let's
75:45 - push this in
75:47 - and we can remove this
75:53 - and what else so now we need to
75:56 - write the self dot so here we will write
75:58 - self dot pose
76:00 - process and self dot mp draw
76:04 - then we can also write
76:07 - self.mppose
76:10 - so anything missing
76:13 - uh
76:14 - no it seems fine now what we need to do
76:17 - is we need to put that flag so we will
76:19 - write here if draw
76:22 - then we basically do this
76:28 - so that should be good
76:34 - so let's try it out
76:38 - or should we put it inside
76:40 - let's put it inside that so we will say
76:42 - that if
76:44 - landmarks are present
76:49 - or
76:49 - [Music]
76:52 - let's put the draw inside so if the
76:55 - landmarks are detected and we set draw
76:58 - then you need to draw
77:01 - so that is good
77:03 - so
77:05 - by now
77:06 - we should have a working class
77:09 - so we can create an object from it
77:12 - and then we can run it so let's try that
77:14 - out so here we will write our detector
77:19 - detector is equals to
77:22 - our
77:24 - pose detector
77:26 - and we will give in the default
77:27 - parameters
77:28 - and here what is happening here
77:32 - this should be inside the while loop
77:34 - so here we are going to write detector
77:38 - dots find
77:41 - what was it find
77:42 - or detect
77:44 - find pause
77:47 - find
77:48 - pause
77:51 - why is it not detecting
77:54 - oh the indentation is wrong
77:59 - so now it will detect
78:01 - okay so detector dots find pose
78:05 - and then we have to give in our image
78:09 - so that should be it
78:10 - and we need to return the image so we
78:13 - will write here
78:16 - return
78:17 - image
78:20 - and we can
78:22 - bring in the image back
78:24 - here so if we run this it should draw
78:30 - on our video so let's run the pose
78:32 - module
78:35 - and there you go
78:37 - so now it is running and it looks good
78:40 - let's try it on the first image
78:45 - there you go
78:47 - so this is quite good
78:49 - and what we can do next is we can do the
78:52 - main part which is to
78:54 - find the points so we need to get those
78:56 - points
78:57 - here we are going to define
79:00 - the
79:01 - get
79:02 - position
79:05 - and we will write inside that we want
79:09 - an image and then again we want the draw
79:13 - flag
79:14 - so by default we are going to
79:17 - yeah let's put it as true
79:20 - and then we can uncomment this
79:24 - okay
79:26 - so now what we will do is we will first
79:29 - of all here we are getting an error for
79:31 - result because we need to write self dot
79:34 - results
79:35 - here
79:37 - and here
79:39 - and here
79:41 - and here
79:42 - okay so that should be good
79:44 - and what else so we need to push this in
79:47 - in the for loop
79:49 - so now
79:50 - we are we are just looping we need to
79:52 - check first as well if the results are
79:55 - available
79:56 - so if the results are available
79:59 - then we will use this for loop
80:02 - and then
80:05 - we need to put it in a list
80:08 - so we are going to write a list lm list
80:12 - which is for our landmarks
80:14 - and we will append our values so here it
80:16 - depends on you what kind of values do
80:19 - you want to append
80:21 - so i'm going to append only the x and y
80:24 - values and the id if you want to append
80:27 - the z and the
80:29 - uh what was the other one the visibility
80:32 - you can do that too so here i will write
80:36 - lmlist
80:38 - dot append
80:39 - and i will write in the id
80:43 - so here i will write id and then i will
80:47 - write
80:48 - the
80:49 - cx and the cy
80:53 - and i will add the option here
80:56 - that if draw
80:59 - then do this
81:03 - so this looks pretty good
81:06 - so let's go down and try it out
81:10 - so where is it
81:11 - here so we can write here that our lm
81:14 - list
81:16 - is equals to
81:18 - detector
81:20 - dot find position
81:23 - is it find position or get position
81:26 - let's keep it find position so it's
81:28 - similar to the previous one
81:31 - find position
81:33 - find position and then we will give in
81:36 - our image
81:37 - and let's keep it as true for drawing so
81:40 - we know it is detecting
81:42 - and we can print out
81:44 - the list as well so we can print out lm
81:47 - list
81:51 - and there you go
81:53 - so now you can see
81:56 - we are
81:57 - wait why is it printing this that is not
81:59 - right
82:02 - uh
82:03 - okay this is printing this parts
82:08 - any other prints
82:11 - uh no
82:13 - so let's write again
82:15 - yeah so right now it's none
82:18 - wait why is it none
82:20 - the lm list is none
82:26 - lm list oh we didn't return it
82:30 - forgot to return
82:31 - return lm list
82:35 - okay so now we can run it
82:38 - and there you go so now we have the list
82:40 - and if we go till the end you will see
82:42 - we have a total of 32 points
82:45 - so
82:46 - we have 33 points because we are
82:48 - starting from zero so now i can easily
82:50 - say for example i want
82:52 - number 0 i want number 8 i want number 5
82:56 - number 23 whatever i want i can write
82:59 - down here
83:01 - so let's say we want number 8
83:04 - or
83:05 - let's say we want number 14.
83:08 - let's try that
83:10 - number 14.
83:15 - and there we have it so this is the
83:16 - number 14 and if i wanted to
83:20 - i could draw this number 14 so i can
83:24 - i can put this as
83:26 - draw
83:27 - false
83:29 - and then here
83:31 - i can write
83:33 - uh lm14
83:37 - at
83:38 - one and two
83:40 - so this will be one
83:42 - and this will be
83:44 - two
83:46 - and i can make this really big so i can
83:48 - see what exactly i'm am i tracking and i
83:51 - can change the color of it so that it is
83:53 - a little bit different than all of these
83:55 - so i can put it as red
84:00 - and there you go so now you can see
84:04 - we are tracking this elbow
84:06 - so this is how easy it can be
84:09 - uh by the way whenever it finishes the
84:11 - video it will give you an error
84:13 - you can loop through that there's a
84:15 - function for that as well but we're not
84:17 - going to do that
84:19 - so this is the basic idea
84:21 - of how you can convert this into a
84:23 - module and now you can use this in any
84:26 - project that you want and you can easily
84:28 - find the position so how exactly can you
84:31 - do that
84:32 - so let's create a new file
84:35 - and we will call this
84:38 - our
84:39 - awesome
84:41 - pose projects
84:44 - so we will copy
84:46 - the parts
84:48 - from the main
84:49 - so as i said this is the testing code so
84:52 - we will copy all of that
84:55 - and we will paste it in our awesome
84:57 - project and now
84:59 - we have to import
85:01 - so we will write here import cv2
85:06 - and then we have to import
85:09 - time
85:10 - and then we have to import
85:13 - our module
85:15 - so our module needs to be in the same
85:18 - folder if it's not in the same folder it
85:20 - will not work so you have to write
85:21 - import
85:23 - pose module
85:24 - as pm
85:27 - because it's a smaller name so we can
85:29 - write here pm dot
85:31 - pose detector so this will create the
85:33 - detector and everything else will run
85:35 - the same way
85:37 - so
85:38 - if we run this now our awesome projects
85:42 - and you can see it runs exactly the same
85:44 - way
85:46 - so now i can use this in many different
85:49 - applications so one thing we can do is
85:52 - we can test some other videos so let's
85:54 - say number two
85:57 - there you go again we are detecting the
85:59 - right elbow and you can see it's
86:01 - tracking really well
86:03 - that's pretty awesome even when it's a
86:05 - little bit hidden it's still tracking it
86:08 - that's really good
86:11 - and then let's try number three
86:20 - what happened to number three
86:23 - there is an error
86:26 - list index out of frame okay so
86:29 - yeah this is a problem because we are
86:31 - not checking
86:33 - uh if the list
86:35 - if actually the list is filled or not so
86:37 - we need to check if
86:39 - lm list
86:41 - is not equals to zero
86:44 - actually the length of it is not equal
86:45 - to zero
86:46 - if the length of this is not equals to
86:50 - zero
86:51 - then only we can do these two things
86:54 - so
86:55 - actually we should change that at the
86:58 - main module as well
86:59 - so
87:00 - where is it here
87:05 - so let's run the awesome project again
87:07 - and this time it works so probably the
87:09 - first frame it was not able to detect
87:11 - that's why it was giving this error so
87:13 - now you can see it's detecting that
87:15 - elbow
87:16 - let's try number four
87:20 - there you go
87:21 - detecting the right elbow very nicely
87:25 - let's try number five
87:29 - there we have it
87:31 - excellent the frame rate is amazing so
87:33 - you are getting real time
87:35 - number six
87:42 - pretty good
87:44 - and the best part is it's running on cpu
87:47 - it's not actually using gpu to run this
87:52 - so that is very good
87:54 - then we have number eights let's try
87:57 - that
87:59 - okay that looks good
88:04 - and then we have number nine
88:13 - so yeah that is pretty good
88:15 - so
88:16 - there are a few
88:18 - instances where it gets it wrong but
88:21 - overall you can see it's really good
88:31 - hey everyone welcome to my channel in
88:33 - this video we are going to learn the
88:35 - latest face and eye detection method
88:37 - that runs at an amazing 60 frames per
88:40 - second and all of this on an hd
88:43 - resolution this is a lightweight model
88:45 - provided by google so it runs on cpu and
88:49 - mobile devices as well
88:52 - so here we are in our pycharm project
88:54 - and the first thing we will do we'll go
88:56 - to file
88:58 - settings and we will go to our project
89:02 - and the interpreter and we will add
89:06 - so here we are going to add opencv dash
89:09 - python
89:11 - and we will also install
89:14 - media pipe
89:16 - which is the library that will help us
89:19 - detect faces
89:21 - okay so now both of them are installed
89:24 - and here on the side you can see that
89:26 - our project is called face detection
89:28 - project
89:29 - and then we have a folder called videos
89:33 - so let's open that up and see what it
89:35 - contains
89:37 - so here is the folder and we have a
89:40 - total of six videos that we are going to
89:43 - test on
89:44 - now you could do it on a webcam as well
89:46 - but
89:47 - i'm going to do it on a video
89:49 - because
89:50 - one it will be more clear and second
89:54 - with the webcam you will have a limit of
89:56 - the frame rate so
89:58 - with the videos you will have faster
90:00 - frame rates
90:01 - okay so we are going to right click and
90:04 - we will go to python file and here we
90:07 - are going to create our project so we
90:10 - will call this face detection
90:14 - basics so the idea is that we are going
90:17 - to look at the very basics
90:19 - the bare minimum code that is required
90:21 - to run it and once we understand that we
90:24 - are going to go ahead and create a
90:26 - module out of this so that we do not
90:28 - have to write it again and again for
90:30 - different projects
90:32 - so the first thing we will do is to
90:34 - import cv2
90:36 - and then import media pipe as
90:39 - mp
90:40 - this is so that we don't have to write
90:42 - media pipe again and again we can just
90:44 - write mp
90:46 - and then we will import time
90:48 - this will be to display the frame rate
90:51 - so uh first of all we are going to
90:55 - run our video so we will write here cap
90:57 - is equals to cv2 dot video capture
91:00 - and we are going to capture from within
91:03 - our video folder
91:04 - so we will write here video slash
91:07 - one dot mp4 so this is the video that we
91:10 - will be using
91:12 - and then we will write here while true
91:17 - we are going to write success and image
91:21 - is equals to
91:22 - uh cap dot read
91:26 - so that will give us our frame and then
91:29 - we are going to write cv2 dot weight key
91:32 - as one
91:34 - and we will also write cv2 dot i am show
91:38 - we will write image and then image
91:41 - so this is pretty much you can see the
91:43 - boilerplate
91:46 - of our projects that we have been doing
91:49 - so we can simply right click and run
91:51 - this
91:53 - and we have an issue cb2
91:57 - uh is it
91:59 - oh it's called videos it's not video
92:03 - okay
92:04 - so there you go so this is the video
92:06 - that we will be using and as you can see
92:08 - it is going pretty fast
92:10 - because it is running at a higher frame
92:12 - rate
92:13 - so you could reduce the frame rate from
92:16 - here for example if i put 10
92:18 - you will see that the frame rate is
92:22 - uh
92:23 - it's much closer to real time but we are
92:26 - not going to do that instead we are
92:28 - going to display the actual value
92:30 - so to do that we will simply write here
92:36 - c time
92:38 - is equals to time
92:40 - dot time
92:42 - and then we will write fbs is equals to
92:45 - one divided by
92:47 - our current time minus the previous time
92:51 - and then we are going to write that our
92:54 - previous time is equals to the current
92:56 - time
92:58 - and then we can display it so we will
93:00 - write cv2 dot put text we'll put it on
93:03 - our image
93:05 - we are going to write
93:06 - fps
93:08 - oh i wrote it wrong f and then f
93:12 - p s and then we will write
93:16 - a curly bracket and inside that we are
93:18 - going to write integer and then fbs
93:23 - and what else then we need to define the
93:25 - position so let's say 20 and 70.
93:31 - and then we are going to
93:35 - write down the font so cb2 dot font
93:39 - let's take the plain one then we have
93:43 - the scale let's put it as three
93:45 - color let's put it as
93:48 - blue or green let's put it as blue
93:53 - uh two five five two five five
93:56 - zero and two
93:59 - no zero okay then we will write
94:03 - let's say the thickness
94:05 - and yeah that's pretty much it
94:08 - one more thing we have to do we have to
94:09 - declare the p time for the initial frame
94:12 - because it is not defined before and we
94:16 - are using it here
94:17 - so we need to define before that and all
94:20 - of this needs to be
94:22 - before the image show
94:25 - so
94:25 - we are going to put it down here and we
94:28 - can simply run this and see what happens
94:31 - there you go so you can see the frame
94:33 - rate is extremely high 140s 160s
94:36 - something like that
94:38 - um
94:38 - blue might not be the best color so
94:42 - let's put a screen
94:46 - let's try that
94:48 - yep that's much better okay so now that
94:51 - we have our frame rate by the way uh as
94:53 - i was mentioning before you can reduce
94:55 - the frame rate from here let's say i put
94:57 - 20
94:58 - so now you will see
95:01 - that yeah it's much closer to real time
95:03 - it's around 30 something 40. by the way
95:06 - this video is a slo-mo
95:09 - so that's why it looks a little bit
95:11 - slower
95:12 - because the video itself is a slow
95:14 - motion video
95:16 - so if i open it up
95:19 - and i play this
95:22 - you can see this is actually a slow
95:24 - motion video
95:26 - okay um we could use the second one as
95:29 - well
95:32 - yeah this one looks real time or
95:38 - it's hard to tell
95:40 - okay um we could try it with the second
95:42 - one here let's see how that works out
95:48 - yeah it's it's not real time either
95:52 - okay so uh anyways so that's the idea so
95:55 - we will keep it as one because we are
95:57 - going to process it and
95:59 - hopefully we are going to get a good
96:00 - frame rate so you can see it's quite
96:02 - fast
96:04 - so
96:05 - what is the next step
96:07 - the next step is to import our media
96:11 - pipe functions or classes so that we can
96:14 - use them
96:15 - so here what we will do is we will use
96:17 - the face detection module
96:19 - so we will write here mp
96:21 - face detection
96:23 - detection
96:25 - is equals to
96:26 - mp
96:27 - dot solutions
96:31 - dot face detection
96:35 - detection
96:37 - yeah okay
96:38 - so then we need something to draw
96:41 - now
96:42 - we can draw ourselves as well
96:45 - but
96:46 - we can import the drawing part here as
96:49 - well let's say mp draw
96:51 - is equals to mp.solutions
96:54 - solutions
96:58 - and then draw
97:01 - drawing utilities okay
97:03 - so basically this will allow us to draw
97:05 - without going into the details but if we
97:08 - want to draw ourselves we can do that
97:10 - too because the rectangle drawing
97:12 - rectangle should not be that hard but we
97:14 - are getting a few points as well we will
97:17 - be getting six points
97:18 - so for the eyes and the nose and the
97:21 - ears so we could we could simply draw
97:24 - them by using this
97:27 - okay then we are going to write face
97:29 - detection is equals to
97:32 - mp face mp face detection
97:37 - dot face detection
97:39 - so this basically initializes
97:42 - that we are going to use a face
97:43 - detection again my spellings are wrong
97:47 - to fix that okay
97:49 - so then we can simply go and
97:53 - this is an bgr image so we need to
97:55 - convert it into rgb before we do that
97:58 - before we send it to the media pipe
98:01 - library so we will write here image rgb
98:05 - is equals to cv2
98:07 - dot cvt color
98:09 - and we will give in our image and then
98:11 - we will write cv2 dots
98:13 - color
98:14 - underscore bgr to rgb
98:19 - to rgb
98:22 - okay so then we will write here that our
98:25 - results is equals to
98:27 - face detection
98:29 - dot process
98:31 - and we want to process our rgb image
98:35 - so this is the idea whatever the
98:38 - the output is it will be stored in the
98:40 - results
98:41 - and then we can process these results so
98:44 - we can print this out we can write your
98:46 - results
98:48 - and let's try it and see what happens
98:52 - there you go so now all of a sudden you
98:54 - have seen that the frame rate has
98:56 - decreased so if i don't run this
98:59 - and i don't print this
99:01 - you will see that the frame rate is very
99:03 - high
99:04 - but as soon as i run it
99:08 - the frame rate reduces to around 60 70
99:12 - i can even see 90s
99:15 - so yeah so it means it's working at the
99:17 - back end and it is giving us a class so
99:19 - they have their own class by media pi
99:22 - python solutions so
99:24 - what we need to do is we need to know
99:26 - how to extract the information out of
99:28 - this
99:29 - so we are going to do that next
99:33 - so here we are going to write
99:35 - so it can be multiple faces actually
99:37 - let's go to a video let's go to the
99:39 - first video again because it has
99:40 - multiple faces
99:42 - so
99:43 - we will check if the results
99:45 - dot detections detections
99:49 - is available then we are going to write
99:52 - for id
99:54 - and then detection
99:56 - detection
99:58 - in
100:00 - results
100:01 - dot detections
100:03 - the text
100:04 - actions okay so we are going to find in
100:07 - that but it should be
100:10 - enumerate because we want the
100:14 - id number as well
100:16 - so we will write this and then we can
100:19 - loop through each one of the results and
100:21 - we can display them so we can write here
100:24 - print detection so whatever we have it
100:26 - is being processed here and what we can
100:29 - do is we can
100:30 - display it with the id so we can write
100:32 - id and then it will show us the
100:34 - detection
100:35 - so let's run that
100:40 - okay there is some issue here
100:44 - where is it
100:47 - results start again the spellings the
100:51 - detections
100:53 - okay
100:54 - so if i close this and if i go up here
100:58 - you can see these are the key points so
101:00 - here it is saying
101:02 - that this is detection number
101:04 - one this is id number one
101:07 - and they have given it a label of zero
101:09 - this is the score this is 91 percent
101:12 - sure that it is a phase
101:14 - then there's location data within it
101:17 - which means the bounding box
101:19 - and then there are key points so one two
101:22 - three four five and six key points
101:25 - so
101:27 - you can use these key points as well but
101:29 - we are more interested in the face
101:31 - itself so here you can see
101:33 - this is zero this is face number zero
101:37 - and this is face number one so the label
101:41 - id is same because both of them are
101:43 - faces
101:44 - and here we have face number one and
101:47 - here we have face number zero
101:50 - so now we need to know how to extract
101:51 - this information so we already know that
101:54 - this is a class so what we can do is we
101:56 - can for example if we wanted the score
101:59 - we will write detection dot score
102:01 - so if i write here
102:03 - detection dot score
102:06 - that will give me the value of the score
102:08 - so i can print that out
102:11 - what happened there
102:16 - so if i print that out
102:19 - you will see i'm getting the detection
102:21 - by itself
102:22 - so separately i'm getting the value
102:25 - so i can get that then how can i get the
102:28 - for example the x minimum so this is
102:31 - the x y position that we want
102:35 - so to do that you can see that we have
102:37 - first of all location data inside
102:39 - location data we have relative bounding
102:41 - box so we need to write that so we will
102:43 - write here print
102:45 - we will say location data
102:48 - first default detection
102:49 - detection dot
102:51 - location data
102:53 - and then we will write dot relative
102:56 - bounding box
102:58 - so that should give us the values so
103:00 - let's
103:02 - comment these and let's run this
103:06 - and there you go so now we simply have
103:08 - the information of our bounding box
103:12 - okay so that is good
103:15 - now what else can we do now the thing is
103:17 - that these are uh you can say normalized
103:20 - values so they are normalized between 0
103:23 - and 1.
103:24 - so what we need to do is we need to
103:25 - multiply them with the width and the
103:27 - height to get the pixel values so we can
103:30 - draw
103:31 - but before we actually go into the
103:33 - drawing
103:34 - we can also draw by the function that
103:36 - they have provided
103:38 - so that function is mp draw
103:42 - dot
103:44 - draw landmarks or draw detection
103:48 - and then we have image
103:50 - and then we have the detection
103:54 - so yeah that should draw
103:57 - the faces for us there you go so now you
104:00 - can see we are getting the points and we
104:02 - are getting the faces uh the bounding
104:04 - box around the faces
104:06 - now the thing is for me the the points
104:08 - are not very accurate i don't see them
104:11 - being useful
104:12 - you can see
104:13 - sometimes maybe you will get a better
104:15 - result maybe
104:17 - let's say video number two let's try
104:19 - that
104:21 - yeah here it's a little bit better you
104:23 - can see the eyes and the nose
104:25 - and let's try number three
104:29 - yeah here for the baby you can see it's
104:31 - quite good
104:32 - so
104:33 - again if you want to use the
104:35 - points then you should make sure that
104:37 - the video is quite zoomed in the focus
104:40 - is on the face
104:41 - so if you want that you can use the
104:44 - points for the eyes and for the nose and
104:47 - for the ears so the same way we got the
104:50 - information of the
104:51 - x and y and the score the same way you
104:53 - would get the information of the
104:55 - landmarks but i'm not going to go into
104:57 - the landmarks i will just keep on the
105:00 - bounding box we will focus on the
105:02 - bounding box and we will also focus on
105:04 - the score so these three things are what
105:06 - we are interested in if you want more
105:09 - you can add on to it
105:11 - so
105:12 - now that we know how to draw this
105:14 - uh what we need is
105:16 - we need to draw ourselves
105:19 - we need to get the bounding box
105:20 - information so that if we want to use it
105:24 - um just the numerical values we should
105:26 - have access to those
105:28 - so what we will do is
105:30 - instead of using all of this so if i
105:33 - wanted
105:34 - if i wanted the value of x minimum
105:37 - i would have to go inside this as well
105:39 - and i will write x minimum here
105:42 - now that is a very long call
105:46 - for just one value so we need to shorten
105:49 - it so that it is easier to work with
105:52 - so what we are going to do is we are
105:54 - going to store all this information in a
105:56 - bounding box and from that we are going
106:00 - to extract these information we are
106:02 - going to multiply so what do i mean by
106:04 - that let's have a look so we will say
106:06 - that our bounding box
106:08 - coming from the class is equals to
106:12 - detection all of this detection dot
106:15 - local location data relative bounding
106:18 - box all of that
106:20 - so that is the the bounding box coming
106:22 - from the class that's why we wrote c in
106:24 - front of it but then we are going to
106:26 - convert it
106:27 - in our own language so that we can work
106:30 - with pixel values rather than just the
106:33 - normalized values
106:34 - so we will call that the simple boundary
106:37 - box without the c
106:39 - and what we need to do is we need to
106:41 - write here
106:42 - that our bounding box
106:44 - c
106:46 - dot x minimum
106:48 - multiplied by our width
106:51 - now but we don't have the width so what
106:54 - we will do is
106:55 - we will write up here
106:58 - that our image height
107:00 - then our image width
107:02 - and our image channels is equals to
107:05 - image dot shape
107:07 - and then i can use here i width image
107:10 - width
107:11 - by the way this i here is not a big deal
107:14 - because
107:15 - defining variables is about scope
107:18 - where is it being used
107:20 - if it is being used in a lot of
107:23 - different places it has a very wide
107:25 - scope maybe it's being used out of the
107:28 - function out of the loop
107:29 - then yes then you need to define long
107:32 - names that are clear like here
107:35 - location data relative bounding box and
107:37 - what not but if you are using it in a
107:39 - small scope for example when you use for
107:42 - loops you write for i in range right so
107:46 - why did you write i
107:47 - you wrote i because you are not going to
107:49 - use that i outside this for loop the
107:51 - scope is very limited so if you are
107:54 - writing i w i h or even wh
107:58 - it's not a big deal
108:00 - so then we are going to convert this
108:03 - into integer
108:05 - and then we are going to copy this
108:10 - and here we are going to write
108:13 - that we need the y minimum and we are
108:16 - going to multiply this with the height
108:19 - so that's the idea
108:20 - and then
108:22 - let's go to the next line so we'll put a
108:23 - backslash
108:26 - and then we will copy this
108:28 - and here we are going to write width
108:34 - and we will keep it iw and here we will
108:37 - write height
108:39 - so now our bounding box will have
108:42 - x
108:43 - y
108:44 - and width and height so we can simply
108:46 - use to draw this
108:47 - uh
108:48 - using a rectangle function or we can use
108:51 - these values outside uh in our project
108:55 - so that should be good so what we can do
108:57 - is
108:58 - we can write here cv2 dot rectangle
109:01 - and we will put the image
109:03 - and we will say the bounding box we can
109:05 - simply feed in the value because
109:08 - it contains all the four values it will
109:10 - understand
109:12 - and then we will let's make it purple
109:16 - zero two five five and let's make the
109:19 - thickness of two
109:21 - so
109:22 - that should be enough
109:25 - let's remove this so note that we are
109:28 - not drawing by default so we are not
109:30 - using the default function to draw we
109:32 - are drawing by ourselves
109:34 - so let's run that
109:37 - and there you go so now we are getting a
109:39 - clean box
109:41 - a bounding box that is quite nice
109:46 - there you go
109:48 - you saw here yeah you can see here we
109:50 - are getting some false detections as
109:51 - well
109:53 - so what you can do is you can you can
109:55 - change the
109:58 - uh what you call there there is
110:00 - a parameter here minimum detection
110:02 - confidence so you can change this
110:05 - so you can write here
110:06 - it's by default at 0.5 you can write
110:09 - let's say 0.75
110:11 - hopefully that will remove that
110:13 - there you go so now you don't see the
110:16 - false positives
110:18 - okay
110:19 - so that is good
110:21 - now what else can we do so
110:25 - this is quite good and
110:28 - the only thing we might want to see is
110:30 - the confidence value so the confidence
110:33 - value or the score as i mentioned you
110:35 - can get by
110:36 - detection.score and we can put it let's
110:39 - copy this we can put it on the bounding
110:41 - box
110:42 - and here we can write for example
110:48 - that we have let's keep it integer we
110:51 - have detection dot score
110:54 - and
110:55 - we are going to
110:56 - get the first element of it
110:59 - uh if you don't get the first element it
111:00 - it will just put a bracket
111:02 - around it
111:03 - so it has only one value but it will put
111:06 - a bracket around it so we are just
111:07 - removing that bracket and we can
111:09 - multiply it by hundred so that it is a
111:12 - percentage and we can write outside that
111:15 - this is a percentage
111:16 - and we don't need to write anything at
111:19 - the beginning and the location should be
111:22 - bounding box
111:23 - at zero bb
111:25 - ox
111:27 - at zero
111:28 - and then bounding box i think that is
111:31 - way too much
111:34 - okay let's bring that down too so
111:36 - bounding box bounding box
111:39 - at one
111:41 - but we are going to subtract -20 from it
111:44 - so that um
111:46 - it is easier to see it is not
111:48 - overlapping with the box
111:51 - okay so let's run that and see if it
111:54 - works
111:55 - there you go
111:56 - so we are getting 90
111:59 - something percent of uh
112:01 - score the confidence level so i think it
112:04 - should be the same color so it looks
112:07 - blended in so we will put it here
112:10 - two five five what else i think the size
112:13 - was big too so we can change it to two
112:18 - yeah that looks much better
112:21 - so
112:22 - let's try out
112:24 - the first video
112:28 - there you go
112:30 - so that's pretty good
112:32 - we are able to detects with the score
112:34 - and with the
112:36 - bounding box value
112:43 - so now this is good but the problem is
112:46 - that you can see that there is quite a
112:47 - bit of code
112:48 - that you have to write
112:50 - to find the face and to get the values
112:53 - that you can use
112:54 - so what we can do is instead of
112:56 - initializing and writing all of this
112:58 - code again and again for different
112:59 - projects what we will do is we will
113:01 - create a module out of this so that we
113:03 - just import that module and use it
113:05 - whenever we want
113:07 - okay so how can we do that
113:09 - so we are going to go to python file and
113:12 - we will call this
113:14 - face detection
113:17 - module
113:19 - and here we are going to copy all of our
113:21 - basic code
113:25 - now the first thing for the module we
113:27 - need is our if statement
113:30 - so if
113:32 - we have the name
113:34 - underscore name is equals to
113:38 - main so this means that if we are
113:40 - running this file
113:42 - then we need to run main
113:44 - so whatever is in main is like the dummy
113:46 - code it is kind of a hint that this is
113:49 - how you can use this module
113:51 - so we are going to declare here that
113:53 - this is main
113:55 - and inside main we are going to write
113:59 - our while statements
114:01 - so
114:04 - so yeah let's copy this part
114:09 - we will paste it in the main
114:12 - then we have the while
114:14 - so we will just read the frame
114:17 - and then we have the ending part
114:21 - we will
114:22 - put the frame rate as well
114:25 - over here
114:28 - so yeah that should work
114:30 - fine
114:34 - then
114:35 - we are going to
114:38 - okay so then we are going to create our
114:39 - class so we are going to call this
114:43 - face
114:44 - the tech
114:46 - tour
114:48 - and we are going to define our initial
114:51 - function
114:53 - uh initial method in it
114:56 - and then inside that we are going to
114:59 - write
115:00 - um okay let's let's leave it for now or
115:02 - let's write it that's all right
115:05 - minimum detection
115:07 - confidence
115:08 - the
115:10 - the tech
115:12 - shun confidence okay
115:14 - that should be fine and we will give it
115:16 - a default value of 0.5
115:19 - now the thing is that we need to put
115:23 - everything
115:24 - which is related to initializations over
115:26 - here inside so we will take this and we
115:29 - will put this in
115:31 - and we will remove some spaces first of
115:33 - all we need to write here self
115:36 - dot
115:38 - minimum detection confidence
115:42 - is equals to minimum detection
115:44 - confidence so in in objects or in the
115:47 - classes all we need to do is we need to
115:50 - write here self dot
115:52 - and here we will write self dot self dot
115:55 - and self dot so it is not a generic
115:59 - variable or a global variable it is now
116:02 - an instant variable so whatever we are
116:04 - defining is for this class or for this
116:07 - object
116:08 - so that's why we are writing self
116:11 - okay so that is good now we need to
116:13 - define another function or a method
116:17 - called find faces
116:21 - and we need an image
116:23 - do we need anything else we can put a
116:25 - flag
116:27 - of draw
116:29 - so draw is equals to true by default
116:33 - so we are going to put all of this in
116:36 - and
116:38 - let's see what do we need to change
116:39 - first of all we need to write the self
116:41 - dot so here we will write self dot face
116:43 - detection
116:45 - and
116:46 - then we will also write self dot results
116:50 - self thought results in case we want to
116:53 - use it later it's not really required at
116:55 - this point but anyways
116:57 - so
116:58 - we will comment this
117:01 - we can remove all of this
117:06 - and what else okay so now we need to
117:08 - return something so we are finding the
117:10 - faces that is all good but we need to
117:13 - return all these faces
117:15 - so what we will do is we will return
117:18 - the bounding box information the id
117:21 - number and also the score if you want to
117:24 - return the landmarks you can return that
117:26 - to here
117:27 - so what we will do is we will create a
117:29 - new variable
117:31 - a new list and we will call it bounding
117:34 - boxes
117:36 - plural
117:37 - so we will make it empty
117:40 - and
117:41 - all of this is being done for one phase
117:44 - so it is showing and it is processing
117:47 - face by face so what we need to do is
117:50 - whenever it processes we need to put
117:52 - that in our bounding boxes
117:54 - so here
117:56 - when we have our bounding box value then
117:59 - we can send in whatever we want so in
118:02 - this case we are going to send
118:04 - bounding boxes dot append
118:07 - and we are going to append
118:09 - uh first of all the bounding box
118:12 - and then we are going to append the
118:16 - uh detection dot score
118:20 - so if you want you can append the id as
118:22 - well but normally it is the same
118:25 - uh what you call
118:28 - it will have the same list number the
118:30 - index of the list
118:32 - so
118:33 - it is a bit redundant but anyways if you
118:34 - want you can add this too
118:36 - so this is the idea then we simply
118:39 - return
118:41 - these
118:42 - uh bounding boxes so we return
118:45 - bounding boxes and we also returned the
118:47 - image that has all these detections on
118:50 - it
118:52 - so that is the idea
118:54 - so
118:56 - by now we should have it running
119:00 - let's try it out so we are going to
119:02 - create an object from our class we will
119:04 - call it detector
119:07 - and
119:08 - we are going to write that
119:11 - our face detector
119:16 - we are not going to give in any value so
119:18 - by default it's 0.5 we will keep it 0.5
119:22 - so once we get the frame we are going to
119:24 - write here
119:25 - image is equals to detector
119:28 - dot find faces
119:31 - and we will give in our image
119:33 - and we will keep it the draw as default
119:37 - so that is good now if we run this it
119:39 - should pretty much run the same way as
119:41 - it did before
119:44 - and there's an error
119:46 - so inside of main
119:49 - okay so
119:55 - here we are facing an issue with the
119:57 - bracket probably
119:59 - what is it
120:03 - image
120:04 - this
120:05 - is fine
120:25 - i think it seems fine to me
120:30 - let's go here and copy this
120:42 - yeah it's exactly the same
120:45 - so it should work uh the error is not
120:48 - here
120:48 - it's probably because it's not finding
120:51 - the image
120:58 - okay
121:02 - let's remove this part
121:04 - and try it
121:08 - yeah
121:09 - it is about the image it's not able to
121:12 - get the video
121:14 - why are you not able to get the video
121:18 - um are you not able to get
121:22 - videos1.mp4
121:37 - okay let's remove this as well
121:43 - okay i get it my bad
121:45 - there are two parameters that
121:48 - needs to be returned so we need to write
121:50 - here bounding boxes
121:54 - yeah
121:55 - that was the issue so let's run this
121:59 - and there you go now this is the module
122:01 - yes this is the module running
122:03 - okay so that is good now it is running
122:06 - and
122:07 - okay it's not detecting properly why
122:12 - did we change the
122:19 - we can we can change the value here
122:22 - so
122:23 - maybe let's say 0.4
122:26 - but it was working before yeah here it's
122:28 - 0.75 that's the issue so we need to put
122:31 - this here
122:33 - minimum detection
122:35 - self dot minimum detection
122:39 - okay so that is good
122:41 - now we do not need to do 0.4 here it by
122:44 - default at 0.5 so it should work fine
122:48 - there you go
122:49 - so now
122:51 - it is detecting properly
122:53 - okay so that is good
122:55 - now it is working as a module and we can
122:58 - get the information by the way you can
123:00 - just print here
123:01 - print the bounding boxes
123:04 - and let's see what do we get
123:07 - there you go so now you're getting the
123:08 - information so this is face number zero
123:11 - this is the bounding box this is the
123:13 - confidence
123:14 - this face number one bounding box and
123:16 - the confidence
123:18 - so you can extract this information and
123:20 - use it very easily
123:22 - so by now we are pretty much done but i
123:24 - want to do something else
123:26 - now this is you can say kind of a fancy
123:29 - thing if you want to do this you can add
123:31 - it
123:32 - but it is of course not necessary so
123:35 - what i want to do is we are always
123:36 - showing these bounding boxes uh the same
123:40 - way we are just drawing a rectangle and
123:42 - it's very plain it doesn't look good
123:44 - this is a new method so i want to show
123:46 - it in a new way
123:48 - so what can we do
123:49 - so what i was thinking is that we can
123:51 - put some corner what do you call lines
123:55 - a little bit thicker so that will give
123:57 - it
123:58 - um
124:00 - that will give it an image of like a
124:02 - target so whenever you have a target you
124:04 - have these edges that are thicker and
124:06 - then you have the bounding box in
124:08 - between something like that so let's try
124:11 - to add that here
124:13 - so what i will do is i will
124:15 - create a new method here and i will call
124:18 - that
124:19 - um
124:20 - let's say
124:22 - fancy draw
124:24 - instead of regular draw we are going to
124:26 - do fancy draw so we are going to write
124:28 - here that we need our image
124:31 - and we need the bounding box
124:34 - so
124:35 - uh we will do one at a time so just send
124:38 - us one bounding box and we will
124:40 - put the bounding box around it then send
124:43 - the next one and then so on it will not
124:45 - take an array
124:47 - okay so
124:48 - then first of all we are going to open
124:51 - it up we are going to extract the
124:53 - information from it so we are going to
124:55 - write here x
124:56 - y
124:57 - width and height is equals to
125:00 - the bounding box
125:03 - and then
125:05 - we also need the x1
125:08 - and the y1
125:10 - which is basically equals to the
125:12 - diagonal point
125:14 - so x
125:15 - x and y is the first point or you can
125:18 - say the origin point and then x1 and y1
125:22 - is the
125:23 - bottom right point so the corner points
125:26 - at the diagonal position
125:28 - so rather than calculating it again
125:30 - again we can just define it right now so
125:32 - we can write it as x plus width and y
125:35 - plus height
125:37 - so now we have all the information we
125:39 - need
125:40 - now we can start drawing the lines so
125:43 - here we will write cv2.line
125:45 - and inside the line we need to send in
125:48 - our image and then we need the starting
125:50 - point so i will say the starting point
125:52 - is x and y
125:54 - then
125:55 - we have
125:57 - the x plus a certain value so this is
126:00 - the length of that line
126:02 - so let's write here
126:04 - length is equals to let's say 30
126:07 - we will write here length
126:09 - and then we are going to give in the
126:11 - value of y so y will stay the same
126:15 - so then we will give it the color the
126:17 - color will be the same as the
126:20 - what you call rectangle so we will write
126:22 - here two five five zero two five five
126:25 - and here we have to write the thickness
126:28 - so
126:29 - let's write here
126:32 - that this is the thickness is equals to
126:35 - let's say 10.
126:37 - so i will write here
126:39 - uh sorry t
126:42 - so uh it might be a little bit confusing
126:44 - at this point but let me show you how it
126:46 - works so
126:48 - let's remove this rectangle from here
126:52 - and i will put this here
126:55 - rectangle
126:57 - and then
126:59 - i will write here
127:02 - fancy
127:05 - self
127:06 - dot fancy draw
127:08 - and i will give in the image
127:10 - and the bounding box
127:13 - so that's the idea and it will return
127:15 - the image
127:17 - so we can write here return image return
127:22 - image
127:25 - okay so let's run this and see what
127:27 - happens
127:31 - so there you go so now you see there's a
127:33 - thick line
127:34 - on the corner now we need to draw the
127:36 - line at the bottom
127:38 - so let's draw that
127:40 - so we will copy this
127:42 - and we will paste it here now this time
127:45 - around the x will be without any extra
127:48 - value no length for the x we will add
127:50 - the length to the y
127:54 - so if we run it again
127:56 - now you see we have a corner point
127:58 - so we have a corner we have two lines at
128:00 - the corner
128:02 - so what we need to do now is we need to
128:04 - replicate this on the others
128:07 - i think the thickness for this should be
128:08 - one
128:10 - we can give it let's say rectangle
128:12 - thickness is equals to one and we can
128:14 - put here
128:15 - rt
128:18 - uh let's run that
128:21 - yeah this looks much better
128:23 - okay so and even the thickness for this
128:26 - is too much let's put it as seven let's
128:29 - say
128:32 - yeah
128:32 - it's getting better maybe five
128:37 - yeah that looks good
128:40 - so next what we can do is
128:42 - we can write here
128:44 - that this is for the top
128:46 - left
128:47 - which is basically for x and y
128:50 - okay
128:51 - this is the point x and y
128:53 - then we will copy this and we will paste
128:55 - it here
128:56 - and we are going to say that this is for
128:58 - the top right
129:00 - and now our position will be x 1
129:03 - and y
129:05 - so we will just change this to x one
129:09 - and that should work fine
129:11 - x one
129:12 - and y yeah so one more thing is that if
129:16 - i run this now you will see the issue it
129:19 - is going outwards we need to bring it
129:21 - inwards
129:22 - so how do you bring it inwards you
129:24 - simply subtract the length instead of
129:27 - adding
129:28 - in the x direction
129:30 - so there you go so now it's inwards and
129:33 - it's done
129:34 - so we need to do the same for the next
129:37 - two
129:38 - so we will copy this and we will paste
129:41 - here
129:43 - so
129:44 - for the bottom left
129:46 - and then we have the bottom right
129:51 - so for the bottom left we will have x
129:53 - and y one
129:55 - so we will just replace this with y one
129:58 - y 1 everywhere and then this will remain
130:02 - positive but this will be negative
130:05 - again you can play with these and you
130:06 - can see if it gives you a problem then
130:09 - you can replace it if you don't
130:10 - understand it directly
130:12 - so this is the third one and then for
130:14 - the fourth one it will be x1 and y1
130:17 - so we will write here x1 and y1
130:20 - and the values will be both minus so
130:23 - both of them will be inwards
130:27 - there you go
130:28 - so now
130:29 - it looks much better than just a
130:31 - rectangle drawn around it
130:34 - so and yeah one more thing i forgot to
130:36 - add
130:37 - is the condition for drawing so if we
130:40 - want to draw or not so here
130:42 - i can write
130:44 - if draw
130:46 - then we do this
130:47 - otherwise no need
130:49 - so if i run this
130:52 - it will draw
130:53 - if i go back here
130:56 - and where is it here and if i put this
130:59 - as false
131:01 - it will give us the values but it is not
131:03 - going to draw
131:05 - oh
131:06 - what is that
131:07 - uh
131:08 - we didn't put that in the draw
131:11 - yeah this needs to be in the draw there
131:13 - you go
131:16 - there you go so now it's not drawing
131:18 - anything at all
131:19 - and if we go down
131:21 - and we write here nothing
131:24 - then it will
131:25 - run because by default it's true
131:31 - so as you can see now we have our face
131:33 - detection which is running almost at 60
131:36 - plus frame rate
131:38 - which is pretty amazing given that we
131:40 - are only using a cpu
131:42 - and this is an hd video so it is
131:45 - 1280 by 720
131:48 - if we are running even lower than this
131:50 - for example 640 by 480
131:53 - the frame rate will be crazy high so
131:56 - you can keep that in mind
131:58 - let's try this one
132:00 - it's pretty good
132:02 - let's try how many do we have we have
132:04 - six videos let's try all of them
132:07 - this is number four
132:09 - it's pretty good and you can see here
132:11 - see that's the thing with our cascades
132:13 - that it does not detect on the sides so
132:16 - if you rotate your face it will not
132:18 - detect at all but this one does so that
132:21 - is pretty cool
132:24 - there you go oh this kid is really
132:27 - enthusiastic
132:31 - then number six
132:34 - there you go
132:37 - so even on the side but if it's gone too
132:40 - far maybe it will not detect but here
132:42 - you can see it's blurry and it's on the
132:44 - side and
132:45 - even then it is detecting uh quite a bit
132:49 - that there is a person there
132:52 - so that is pretty amazing
133:00 - hey everyone welcome to my channel in
133:02 - this video we are going to learn how to
133:05 - detect
133:06 - 468 different landmarks on faces
133:10 - we will use the model provided by google
133:12 - that runs in real time on cpu and on
133:16 - mobile devices
133:18 - so here we are in our pycharm project
133:20 - and we have created a new project called
133:23 - face mesh project
133:25 - now we have a special folder here by the
133:28 - name videos and if you go inside you
133:30 - will see that we have a couple of videos
133:33 - in fact more than a couple
133:37 - you can see here that we have a total of
133:41 - eight videos
133:42 - and each of these videos they have a
133:45 - different size
133:46 - so they are not actually the same width
133:49 - and height
133:50 - you can see this one is smaller so the
133:52 - frame rate might vary based on the size
133:58 - so let's try this one yeah this one is
134:00 - quite i think this one is hd
134:03 - or even full hd probably
134:06 - so yeah
134:07 - so these are some of the videos that we
134:09 - are going to test on so what we will do
134:11 - is we will right click and we will
134:13 - create
134:14 - a new python file and we are going to
134:16 - call it face
134:17 - mesh
134:19 - basics
134:22 - so what we will do is we will learn the
134:24 - basics and once we know the basics we
134:27 - are going to create a module out of it
134:28 - so that we don't have to write it again
134:30 - and again
134:31 - for different projects
134:33 - so
134:34 - the first thing will be to install our
134:36 - libraries we will go to file
134:39 - settings and the project interpreter
134:43 - and we will add
134:45 - the
134:46 - opencv
134:49 - python and we will also add media pipe
134:54 - which is the library provided by google
134:57 - that we will be using to detect all
134:59 - these different 400 plus points
135:03 - on the faces
135:04 - so
135:05 - one of them is already done the other
135:08 - one is also done great
135:11 - so now we are going to import cv2 and
135:14 - then we are going to import
135:17 - media pipe as mp
135:20 - and then we will also import time to see
135:23 - the frame rate
135:25 - so as always the first thing we will do
135:28 - we will run our video and we will use
135:32 - cap is equals to cv2 dot video capture
135:36 - and we are going to give in
135:38 - our video path so here it is in videos
135:43 - videos slash one dot
135:46 - mp4
135:48 - let's use the second one because the
135:50 - second one has two faces in it
135:53 - so that will be better when we are
135:56 - testing
135:57 - okay so then we are going to write while
136:01 - true
136:03 - we are going to say
136:05 - uh success
136:08 - and image is equals to cap dot read
136:12 - we are going to read our image and then
136:14 - we will say cv2 dot i am show we will
136:18 - say that it is an image
136:21 - img
136:22 - and then cv2 dot weight key as one
136:26 - so
136:27 - that is pretty much it so let's run it
136:31 - and see if it works
136:33 - and there you go
136:34 - so you can see the video is now running
136:37 - and we have two faces uh the first one i
136:40 - believe has only one yeah and it is
136:43 - quite big so it is i think hd
136:46 - i mean full hd
136:48 - so
136:49 - let's try let's
136:51 - work on number two and later on once we
136:54 - are done we can try number one number
136:56 - three four five
136:57 - and so on
136:58 - okay so the next thing we will do is to
137:02 - write the frame rate so here we are
137:04 - going to write
137:06 - c time is equals to
137:09 - time dot time
137:11 - and then we are going to write fps is
137:14 - equals to 1 divided by
137:17 - c time
137:19 - minus p time
137:21 - so p stands for previous c stands for
137:24 - current time
137:25 - so then we will write that our previous
137:27 - time is equals to current time
137:30 - and up here we are going to define the
137:33 - previous time is equals to zero
137:36 - so that should give us the frame rate
137:38 - and then all we need to do is we need to
137:41 - put it on our image so we will write put
137:44 - text on the image
137:46 - and we are going to write fps
137:50 - and in the curly brackets we are going
137:53 - to write
137:55 - integer of fps
137:59 - and yeah that should be it and then we
138:01 - have to give in
138:03 - the location so 2070
138:06 - and then we will given the font cv2 dot
138:09 - font
138:10 - let's give it a plain font
138:13 - and what else then we will give the
138:16 - scale
138:17 - then the color we will keep it as green
138:21 - and then we will give in the thickness
138:25 - so yeah that should be enough
138:29 - so let's try that out
138:33 - and there we have it so now we are
138:34 - getting the frame rate
138:36 - it is quite high at the moment
138:40 - okay so that is pretty good
138:43 - we can bring this down
138:47 - now the next step would be to use our
138:49 - media pipe library to actually find the
138:53 - points the different points on the face
138:56 - so what do we need
138:58 - first of all we are going to write here
139:02 - mp draw
139:04 - is equals to mp.solutions
139:08 - solutions dot drawing utilities
139:11 - so this will help us draw on our faces
139:15 - now we could draw ourselves as well but
139:17 - the thing is that when they are using
139:20 - their own function they actually
139:23 - make some lines in between some
139:25 - connections
139:27 - between these points and that is quite
139:29 - complicated so rather than doing it
139:32 - manually we could use their function for
139:34 - displaying purposes but if you just want
139:37 - to see the points you can just draw
139:39 - circles by yourself as well i will show
139:42 - you how to do that as well
139:44 - okay then we are going to write mp face
139:48 - mesh is equals to
139:51 - face mesh
139:52 - is equals to mp dot
139:55 - solutions
139:58 - dot face underscore mesh
140:02 - so we will be using uh this to actually
140:05 - create our face mesh so we will write
140:07 - here face mesh
140:09 - is equals to mp phase
140:12 - mesh
140:13 - dot face mesh i know it's quite a bit of
140:16 - repetition
140:17 - but this is what we need to actually
140:20 - create our object and from where we can
140:24 - actually find our
140:26 - faces
140:27 - so then inside this if i
140:31 - press the control button and i click on
140:33 - this it will take me to the
140:36 - function itself
140:37 - to the class
140:39 - face mesh and here it will tell me that
140:42 - what is the
140:43 - what are the input arguments so here we
140:45 - can see its static image mode
140:48 - is false
140:50 - then we have the total number of faces
140:52 - then minimum detection confidence and
140:54 - the minimum tracking confidence
140:56 - so the static image is whether you are
140:59 - using it
141:01 - only for detection or you are using
141:03 - detection and tracking so if it is a
141:06 - static image mode it will always detect
141:09 - in each and every single image but if it
141:12 - is false then it will detect and then it
141:15 - will track so detection is always
141:18 - heavier than tracking
141:19 - so
141:20 - therefore
141:21 - we will detect first
141:23 - whatever the confidence is above 0.5
141:26 - which means that it has found the
141:28 - probability of 50
141:30 - for a face then we are going to detect
141:33 - and then
141:34 - we are going to keep tracking that face
141:38 - if the tracking confidence is higher
141:40 - than 50 as well so we can change these
141:43 - parameters as well
141:44 - but for now we are not going to do
141:46 - anything here
141:48 - uh actually we can change the maximum
141:50 - number of faces because
141:52 - uh we want to detect two faces so here
141:54 - we can write max number of faces is
141:56 - equals to two
141:58 - uh the rest we can keep it as it is
142:02 - so then we are going to go down here and
142:05 - this actually
142:06 - accepts
142:08 - this class actually accepts only an rgb
142:11 - image so we have to convert it so here
142:15 - this image is bgr so we will convert it
142:17 - so we will write image
142:19 - rgb
142:20 - is equals to cv2 dot cvt color
142:24 - and then we will write image cb 2 dot
142:27 - color
142:29 - underscore bg r to rgb
142:34 - so that is the idea and then we can
142:37 - simply write results
142:39 - is equals to face mesh dots
142:42 - process and we are going to send in our
142:44 - rgb image
142:47 - so that is the idea
142:49 - and now what you will see is that the
142:52 - frame rate has dramatically reduced
142:55 - there you go so now we are getting right
142:57 - 50s to 60s
142:59 - which is actually quite high considering
143:01 - that i'm only using cpu but if we do it
143:04 - on the first one
143:06 - uh it will be slower because that is
143:09 - full hd video
143:12 - yeah so it's around 40s
143:14 - and if we are doing it on an hd video
143:17 - then it is around 60s
143:18 - so that is pretty amazing
143:22 - okay so that is good and now we are
143:24 - getting some results but now we need to
143:26 - display them so to display them
143:29 - we are going to write
143:31 - if results
143:33 - dot multi-face
143:36 - multi
143:37 - underscore face underscore landmarks
143:43 - then if something is detected then we
143:46 - are going to go ahead and draw but the
143:49 - thing is that you can have multiple
143:51 - faces here so you need to loop through
143:54 - the faces before we actually draw
143:57 - so to do that we will write here
143:59 - for face
144:01 - landmarks let's say face
144:04 - landmarks
144:06 - in results
144:08 - dot multi
144:11 - multi
144:12 - underscore face underscore landmarks
144:18 - we are going to go ahead and loop
144:20 - through that
144:21 - and for that we are going to now draw we
144:24 - will write here mp draw
144:27 - dot draw landmarks
144:30 - and then we are going to give in our
144:32 - parameters
144:33 - so if we go over here
144:35 - you can see that you have the image you
144:38 - have the landmark list you have the
144:39 - connections
144:40 - so here first of all we will give in our
144:43 - image
144:44 - then we have the landmarks which is
144:46 - basically
144:48 - your face
144:49 - lms these are the face landmarks
144:52 - and then the connections
144:54 - so we are going to write
144:57 - uh mp face
144:59 - mesh dot
145:01 - face
145:02 - connections
145:04 - so
145:05 - let's try that out
145:07 - let's move it a little bit here okay
145:09 - let's try that out and there you go
145:13 - so as you can see now we are getting the
145:16 - faces
145:17 - and both the faces are being detected
145:20 - and if you go back and you write here
145:22 - one
145:23 - you will see that only one face is
145:25 - detected
145:27 - there you go
145:28 - and you can see how
145:30 - fast and accurate that is which is
145:33 - pretty amazing to see
145:34 - okay
145:35 - so
145:36 - what if you want to change the size of
145:40 - let's say the thickness of the circles
145:43 - or the thickness of the lines around it
145:46 - so what what if you want to do that
145:48 - well
145:49 - to do that you can write here some
145:52 - specifications so you can write here
145:55 - draw
145:57 - no not mp draw draw
146:00 - specs
146:01 - is equals to
146:03 - mp draw
146:05 - dot drawing specifications
146:08 - and there you can write that my
146:10 - thickness is equals to 1
146:13 - and my circle radius is equals to 2.
146:16 - let's see because i'm changing right now
146:19 - i think initially it is 1 1 or 2 2
146:21 - something like that so we are changing
146:23 - it a little bit so that we can see an
146:25 - effect
146:26 - so once we do that then we will go to
146:29 - our mp draw over here
146:31 - and
146:32 - we are going to write our specifications
146:35 - here
146:37 - so we will say that landmark
146:40 - landmark
146:41 - uh drawing spec i think it is the next
146:44 - one so we can directly write yeah so
146:46 - these are the next two parameters
146:48 - so we can directly write them
146:50 - so we can write here that it is draw
146:53 - specs
146:54 - and then again draw specs
146:58 - so
146:59 - let's run that and there you go
147:01 - so now you can see it has changed
147:04 - and
147:05 - um
147:06 - let's say i increase the radius like
147:08 - dramatically let's put it five
147:12 - so there you go so now you can see all
147:13 - these
147:15 - weird points and let's see let's
147:17 - increase this as well to five
147:21 - and there you go so now it is
147:23 - completely blocked
147:25 - so anyways you get the idea so you can
147:28 - put one one here one one with an hd
147:31 - video is fine you know it looks good
147:34 - but if you have a full hd video then one
147:38 - one is
147:39 - is way too subtle at least to me
147:42 - like
147:43 - i can't really see the points here
147:45 - so
147:46 - if you put maybe two
147:50 - and you put here two then it is more
147:52 - visible
147:54 - yeah something like that
147:58 - so anyways you can play around with this
147:59 - all day and you can see which one suits
148:02 - you the best
148:03 - so this is basically the
148:05 - the basic idea of how you can draw now
148:08 - that is all well and good but
148:10 - in reality when you are creating a
148:12 - project you need to use these points you
148:15 - need to know their positioning to
148:17 - actually use them in a project so how
148:20 - can you get the actual points
148:23 - now there are a total of 406
148:26 - points so that's a lot
148:28 - but what we can do is we can at least
148:31 - look at them and we can maybe number
148:33 - them maybe you don't know which one is
148:35 - which so we can
148:37 - put the numbering over there to see
148:39 - which is the nose which are the starting
148:41 - of the lips starting off the eye edge of
148:43 - the eye and so on
148:45 - so
148:46 - how do you get these values
148:49 - so what we will do is
148:51 - now here we are getting into one face so
148:54 - face lms is the landmarks of one face
148:58 - now in order to
149:03 - now in order to get further deep and
149:06 - find out all the different points we are
149:08 - going to add another loop
149:10 - so we will write here for
149:12 - lm
149:14 - in face
149:15 - landmarks dot landmark
149:21 - we are going to get each of these
149:23 - landmarks and we are going to print it
149:26 - so we are going to write here print lm
149:30 - so if i run this now
149:35 - you will see these are the landmarks so
149:38 - you get the x position ui position and z
149:40 - position so this is the basic idea
149:45 - so
149:45 - now these landmarks we are going to
149:47 - first convert them
149:49 - into pixels so that we can
149:52 - use them right now they are normalized
149:54 - from zero to one
149:56 - so we are going to write here i h
149:59 - iw
150:00 - and ic i stands for image image height
150:03 - image width image channels is equals to
150:06 - image
150:07 - dot shape
150:09 - so when when we get the shape
150:12 - now we can multiply it with the
150:14 - normalized values to get the actual
150:16 - pixel values so what we are going to
150:18 - look at is the x and y
150:20 - if you want the z as well you can add
150:23 - that as well but i'm going to write x
150:25 - and y only so to get the x and y value
150:28 - all we have to do is we have to write l
150:30 - m dot x and then we have to multiply it
150:34 - with the width
150:36 - and for the height we will write
150:39 - lm
150:41 - dot y
150:42 - multiplied by eye height
150:45 - so that is the basic idea so now we have
150:48 - our values uh in terms of pixels and we
150:52 - can do whatever we want with them so
150:54 - let's first of all print them out so we
150:56 - will write here x and
150:58 - y and we can comment this part
151:02 - so let's run that
151:05 - and if we go back you can see these are
151:07 - the points that we are getting
151:10 - so if we want to get the id for it well
151:13 - we can put it in a list and we can check
151:15 - the index of that list but if you just
151:18 - want to look at it you can write here
151:20 - enumerate
151:21 - and here you can write
151:25 - id
151:26 - and what you can do is you can write
151:28 - here id
151:29 - so that will give you the id number and
151:31 - then it will tell you the actual value
151:34 - so here you can see
151:36 - it starts at
151:38 - or does it start
151:40 - okay it starts here at zero
151:43 - and then all the way it goes till
151:47 - 467 so we have a total of 468 values
151:51 - and each value has an x and a y
151:55 - point
151:56 - so
151:57 - a y x and a y number
152:00 - so here what we will do is
152:02 - we will put this in a list
152:06 - so
152:06 - what we can do or
152:10 - or let's let's keep it still here and
152:13 - then now what we can do is we can create
152:15 - this into a module and in the module we
152:18 - are going to put it in a list and we
152:19 - will return something
152:21 - so let's keep the basics still here that
152:23 - we are getting the numbers and
152:25 - everything and yeah that should be good
152:27 - so let's run it for two phases
152:31 - and let's run it
152:33 - with video number two
152:37 - there you go
152:39 - so if we go down here you will see
152:41 - a lot of values being generated
152:46 - that's good
152:50 - we could also add uh an enumerate here
152:54 - and we could write which face number are
152:57 - we talking about face number one or face
152:59 - number two
153:00 - but uh let's let's forget that
153:03 - and let's go ahead and do the
153:07 - what you call module
153:14 - so the idea of the module is that once
153:16 - you create the module you don't have to
153:17 - write all of this
153:19 - initializations and all of this
153:21 - conversions again and again so all you
153:24 - need to do is you need to call that
153:26 - function or that method within our class
153:29 - and that will do the magic for you and
153:31 - it will return you the values and you
153:33 - will be happy to work with it
153:36 - so how do we do that we right click we
153:38 - go to new we create a python file we
153:41 - call it face
153:42 - mesh module
153:46 - module okay
153:50 - so what we will do is we will go ahead
153:52 - and copy all of our code and now we are
153:54 - going to convert this into a module
153:57 - so for the module the first thing we
153:58 - have to do is we have to
154:02 - write what to do if you are running the
154:04 - module by itself so we will write here
154:06 - if
154:07 - underscore underscore name
154:10 - is equals to
154:13 - underscore underscore main
154:16 - then we are going to run our main
154:18 - function
154:19 - and we will define our main function
154:21 - here
154:22 - main and we will write down our loop
154:26 - inside it so we will copy this part
154:29 - actually we will cut it
154:32 - and we will paste it here and then we
154:33 - will go here and we will cut this
154:37 - and we will paste it here
154:39 - and what else
154:41 - we will cut this
154:43 - and we will place it above the while
154:46 - so that gives us the
154:49 - initial part so if we were to
154:52 - comment all of this
154:54 - and if we were to run this it should run
154:57 - so let's try that
155:00 - there we go
155:02 - so this is like we are starting from the
155:04 - scratch
155:05 - um
155:06 - [Music]
155:07 - okay so then we are going to convert it
155:10 - into
155:11 - a class
155:12 - so here we are going to write
155:15 - class is equals to
155:18 - face
155:19 - mesh
155:21 - detector you can write a better name
155:23 - probably but we are going to use face
155:26 - mesh detector and then we are going to
155:29 - define our initial method
155:31 - uh for initialization and we are going
155:34 - to given some parameters
155:37 - now these parameters will be the ones
155:39 - that are
155:41 - uh where is it this one so for the face
155:44 - mesh so whatever parameters we have here
155:47 - we are going to
155:48 - give in to our object
155:51 - so let me write down here
155:53 - so we have static image mode
155:55 - so we will write here static mode
155:59 - is equals to false
156:01 - so this will be by default false
156:04 - and then max faces
156:06 - is equals to 2 by default
156:09 - then minimum
156:12 - detection
156:14 - confidence is equal to 0.5
156:17 - and then minimum
156:19 - track
156:21 - confidence is equals to 0.5
156:26 - so we are going to write these and then
156:29 - we have to
156:31 - tell that these are the values of this
156:34 - instance
156:35 - so we will copy this twice
156:38 - then we will copy this again
156:43 - we will copy this again
156:46 - and we will copy this again so here we
156:50 - will put equals to equals to
156:53 - equals to an equals to and here we will
156:56 - write self
156:58 - self
157:00 - dot
157:01 - this
157:03 - so we will copy that self.self.self.
157:07 - so if you are not familiar with this i
157:08 - would highly recommend that you check
157:10 - out uh object oriented programming uh
157:13 - the basics of object oriented
157:15 - programming
157:17 - so then we are going to
157:20 - uncomment this
157:22 - and we are going to write self in front
157:24 - of each of these
157:27 - and then we are going to write self here
157:30 - as well and here
157:33 - in the max number of faces and all of
157:36 - this
157:37 - we need to write
157:39 - our
157:41 - new variables so here we have
157:43 - self.static mode
157:46 - self dot faces
157:49 - then
157:51 - minimum detection
157:53 - let's write it in a new line
157:55 - and then minimum tracking
157:59 - so that is the idea
158:02 - so that is good for initializations uh
158:05 - this if you want to make it a parameter
158:07 - here as well
158:09 - feel free to do that i think it should
158:11 - be fine without it
158:13 - okay so next we are going to write a
158:16 - function called or a method called
158:20 - find
158:21 - mesh
158:22 - face or faces
158:25 - i don't know find face mesh let's say
158:30 - face mesh
158:32 - and then we will write of course self
158:35 - and then why is it not okay the
158:37 - indentation is wrong it should be here
158:40 - okay so then we are going to write image
158:43 - and draw
158:45 - so we will have a option to
158:47 - uh draw or not draw so it will be a flag
158:51 - so we can
158:53 - uncomment this
158:56 - and we can go back up here
158:59 - and then we will see what is missing so
159:02 - this indentation is wrong so we need to
159:04 - go back
159:06 - okay
159:06 - so then we will just copy this self dot
159:09 - and again we will start putting the self
159:11 - dot
159:12 - everywhere
159:14 - and
159:16 - self dot results
159:19 - uh
159:20 - self.mp draw whatever it's giving an
159:22 - error just put a self dots
159:26 - okay so that is good
159:29 - and
159:30 - wait what happened here
159:34 - i need to go back okay
159:36 - so that is good and now
159:40 - we should be able to see
159:44 - our results without going into the
159:46 - returning part
159:48 - we should be able to see the result but
159:51 - we didn't create an object or we didn't
159:53 - call the find face so it will not do
159:56 - anything so we need to do that
159:58 - we will write here detector
160:01 - detector is equals to
160:05 - uh face
160:06 - mesh detector
160:08 - and then here
160:09 - we are going to write here that our
160:12 - image
160:13 - is equals to
160:17 - detector
160:19 - dot face
160:21 - mesh
160:22 - or is it find find face mesh here find
160:25 - face mesh and we will give in our image
160:27 - and we will keep its
160:31 - true for the drawing part and here we
160:33 - are going to return our image
160:36 - so we will write here return
160:38 - image
160:40 - so that should be good and let's see if
160:42 - it works
160:44 - there you go so now it's working
160:47 - as
160:48 - an object
160:50 - but
160:51 - the last thing we have to do is we have
160:53 - to convert this
160:55 - so that we are getting our values in
160:59 - return so that's the main thing so and
161:02 - again the drawing part again is optional
161:05 - so we can directly put here if draw
161:09 - then do this
161:12 - so if i run this now
161:14 - it should draw
161:15 - if i go down here and i write here false
161:19 - false it should not draw
161:22 - it will work but it will not draw
161:24 - anything
161:26 - so that's good
161:28 - okay so what is next yeah so now we need
161:31 - to uncomment this
161:34 - and for every
161:36 - face we are going to go through every
161:39 - landmark
161:40 - and through every landmark we are going
161:42 - to convert it into x and y and then we
161:45 - need to store it so where do we store it
161:49 - we store it
161:50 - in let's say
161:52 - a variable called face
161:55 - so this will be a list so we will store
161:57 - it in list
161:59 - face dot append
162:01 - and we are going to append
162:04 - the x and y
162:06 - so this will be the x and y value
162:08 - now that is good for one face
162:11 - but we have multiple faces
162:14 - so what do we do we create another list
162:17 - we call it faces
162:19 - plural
162:20 - and this time around
162:23 - we append
162:25 - after the loop
162:27 - we append
162:28 - faces dot append
162:31 - face
162:34 - so basically
162:35 - when we are
162:38 - looking for the landmarks we append the
162:41 - landmarks in the faces
162:43 - and then once we have that face with all
162:45 - the landmarks then we append the faces
162:48 - so that we get the final result
162:51 - so that is the basic idea actually let's
162:54 - put it outside so it doesn't give random
162:56 - error
162:57 - that uh it has been used before
163:00 - declaration
163:02 - so yeah
163:04 - so in any case we are going to return
163:06 - faces
163:07 - so
163:09 - even if it's empty it doesn't matter
163:11 - we are going to return it
163:15 - so that's the idea and then in the image
163:17 - here i can write here faces
163:19 - and that should return the faces um
163:22 - what we can do we can print here so we
163:25 - can write here
163:26 - if
163:27 - the
163:30 - how can we write this
163:31 - uh the length of faces
163:35 - but if we write the length of faces it
163:37 - will be
163:39 - yeah it will be something okay yeah that
163:40 - should work if the length of faces is
163:42 - not equals to zero
163:44 - then we are going to print
163:47 - the length of faces let's say
163:51 - so let's see how many faces do we get
163:55 - okay we are printing a lot of things
163:57 - that's why we are not having
163:59 - a clear picture so
164:03 - yeah let's run it again
164:06 - there you go so now it is showing one
164:08 - face and why is it showing one face
164:10 - because
164:12 - we
164:14 - put we put maximum two phases why is it
164:16 - showing one
164:19 - that is weird
164:20 - max faces is two
164:25 - did we say something here
164:27 - are we running the module yeah we are
164:29 - running the
164:30 - module still saying one
164:34 - okay let's see why does it say one
164:38 - so
164:39 - it should be four
164:43 - oh this should be inside the loop my bad
164:46 - so now it should work
164:49 - there you go
164:50 - so now you have two faces being detected
164:54 - and if we go to video number one
164:59 - uh where is that with your number one
165:02 - then
165:03 - it will be one face so you can see here
165:06 - it's only one face
165:08 - so that is the idea and then what we can
165:10 - do is to check whether we are on the
165:13 - uh correct path or not we can write here
165:17 - faces at zero
165:19 - let's see what does it print
165:21 - so oh actually it's printing the length
165:23 - no no we yeah actually it's good to see
165:26 - that it has 468 points so that means we
165:30 - are getting all the points that is good
165:32 - but now let's print all the points
165:35 - it will be a long list there you go
165:39 - so now you can see these are all the
165:41 - different points
165:42 - that we have
165:45 - so this is quite good
165:47 - okay so one more thing we can do
165:50 - now if you're not familiar with which
165:52 - point is which number
165:54 - then what you can do is you can print
165:57 - the id number over here
165:59 - so you can write
166:01 - that
166:02 - cv2 actually we wrote it somewhere yeah
166:05 - why write it again if we have it already
166:08 - we can write here that cv2.put text
166:12 - and we are going to put the text of our
166:14 - id
166:15 - so let's just write here string
166:19 - id
166:21 - and where do we need to put it we need
166:24 - to put it at x and y
166:28 - so this is the x and y position uh 3 is
166:32 - way too big so we are going to put it as
166:35 - 1 1.
166:37 - let's see how that works out so this is
166:39 - going to print out the id number
166:41 - of each of the points
166:44 - oh boy
166:47 - okay
166:48 - so it's like a matrix
166:51 - okay so that is bad
166:53 - um maybe we need to look at a video that
166:56 - is
166:58 - uh more focused on the face
167:00 - doesn't have a lot of other stuff
167:03 - let's
167:04 - see maybe this one
167:07 - maybe this one will be better let's try
167:10 - that
167:11 - this
167:12 - number six
167:18 - there you go so now it's much better
167:21 - so
167:22 - still not that good we
167:25 - uh first of all let's let's change the
167:27 - maximum
167:29 - to
167:30 - uh max faces is equals to one so we only
167:34 - look at one face
167:36 - and then
167:37 - let's put this
167:40 - as 0.5
167:45 - okay it's going to the kid i was hoping
167:48 - it will attach to the elderly person but
167:52 - no it did not happen okay let's keep the
167:55 - maximum faces as 2
167:57 - and let's make this even smaller 0.3
168:01 - let's try that
168:02 - no that's not readable
168:05 - 0.5 is let's try that again
168:10 - okay so i can see 1 is here 4 5 then it
168:14 - goes to 195.
168:16 - 151 9 8
168:19 - so yeah it's a little bit harder to read
168:21 - still 1.7
168:26 - yeah now it's
168:28 - a little bit better here at the edges
168:30 - you can see very clearly what are the
168:32 - points numbers so 21 54 103 is 67 and so
168:37 - on but in the middle area especially
168:40 - with the nose
168:41 - i think one i can see one here
168:44 - so one is the nose
168:46 - uh the center of the nose
168:48 - let's let's try another video hopefully
168:50 - we will get something better
168:53 - so number by the way you can read all of
168:55 - this in the paper so if you go to media
168:58 - pipe website
168:59 - they have a paper listed there and if
169:02 - you go in the paper you will find these
169:05 - you'll find more information on these
169:07 - points
169:10 - so yeah now it's hard to see
169:14 - with this uh maybe if you have just an
169:16 - image and you apply that apply this
169:19 - method on the image and then you scale
169:21 - it up to see
169:22 - the numbers maybe that will work
169:25 - so anyways this is the basic idea of how
169:29 - you can detect
169:31 - 468 points
169:33 - on a face
169:35 - and that running on a cpu all of this
169:38 - running only on a cpu so that is a
169:42 - pretty amazing task and the results are
169:45 - pretty good you can see
169:47 - let's try out different videos so we
169:50 - have video number one you can see it is
169:52 - pretty good video number two actually
169:55 - let's let's uh remove this part
169:58 - let's remove the id
170:00 - and uh
170:01 - let's keep its normal yeah
170:04 - so let's try it again
170:09 - wait what happened there
170:12 - uh oh yeah the draw is false so we need
170:14 - to remove that
170:17 - there you go that is pretty good you can
170:20 - see it is very smooth it's very smooth
170:23 - yeah
170:26 - then let's try number three
170:32 - there you go
170:34 - even when the faces are a bit far
170:37 - it is detecting quite well
170:41 - number four
170:42 - that is good
170:44 - okay when it goes to the side it
170:45 - disappears
170:47 - and that is understandable
170:50 - then let's try number five
170:56 - this seems like a
170:58 - like a zoom meeting
171:00 - yeah
171:02 - could be used in that with the frame
171:04 - rate we are getting
171:06 - it could be used in a zoom meeting
171:09 - okay let's try number six
171:13 - there you go
171:14 - uh it's flickering a little bit here
171:18 - maybe because they're merging the faces
171:20 - at some point
171:23 - yeah probably because of that
171:27 - then let's try number seven how many do
171:30 - we have eight yes
171:33 - okay
171:35 - that's good okay when she goes down
171:38 - then uh of course it will not detect but
171:41 - as soon as she gets back up
171:44 - uh the face is detected
171:47 - there you go
171:49 - the person is laughing and you can see
171:52 - that that is pretty good okay so this is
171:56 - it uh for today's video i hope you have
171:58 - learned something new
172:00 - if you like the video give it a thumbs
172:02 - up and don't forget to subscribe and
172:03 - share it with your friends
172:05 - and i will see you in the next one
172:16 - hey everyone welcome to my channel in
172:18 - this video we are going to learn how to
172:20 - use gesture control to change the volume
172:23 - of a computer we will first look into
172:25 - hand tracking and then we will use the
172:27 - hand landmarks to find the gesture of
172:30 - our hand to change the volume
172:32 - this project is module based which means
172:34 - we will be using a previously created
172:37 - hand module which makes the hand
172:39 - tracking very easy
172:41 - so here we are in our pyjama project
172:43 - this is the same one that we used in the
172:46 - previous video so in the previous video
172:48 - we learned about
172:50 - hand tracking minimum code the bare
172:52 - minimum code that is required to run
172:54 - hand tracking and then we created a
172:57 - module out of this so that we don't have
172:59 - to write it again and again we can
173:01 - simply import this module and run it as
173:03 - it is now if you haven't checked this
173:05 - video i highly recommend that you go and
173:08 - check that video out first and then you
173:10 - can come back here and we will continue
173:12 - with the
173:14 - uh hand tracking project so the project
173:17 - that we are working on is the
173:20 - let's call it
173:21 - volume
173:23 - control
173:24 - or let's call it volume hand control
173:30 - so
173:30 - we are going to control the volume of
173:34 - our computer with our hand so that is
173:36 - something very interesting
173:38 - now the first thing is that we will go
173:40 - to file and we will go to settings we
173:42 - will make sure
173:44 - that our
173:45 - uh
173:47 - libraries or packages are installed so
173:49 - we will write here
173:51 - opencv
173:53 - python so this is the first one that we
173:55 - need we will hit install
173:57 - and then i've already done it that's why
173:59 - i'm not doing it then we are going to
174:01 - write media
174:03 - pipe
174:04 - and we will click on that and we will
174:06 - hit install so these are the two main
174:08 - libraries that we need for now
174:10 - and later on we can check what we need
174:13 - uh afterwards the first thing you have
174:15 - to do is you have to import your
174:17 - packages so we will write here import
174:19 - cv2 then we will import time and then we
174:23 - have to import numpy
174:25 - numpy as np
174:28 - so these are the basic packages that we
174:31 - will be using later on we will add some
174:33 - more as well
174:35 - so the first thing we want to do is we
174:37 - want to check if the webcam is working
174:39 - and everything is running fine so we
174:42 - will write here
174:43 - that cap is equals to video capture
174:46 - cv2.videocap
174:49 - and we will write the id number so
174:51 - i'm using id1
174:53 - most probably you will need id 0.
174:56 - then we will write while true
175:01 - we are going to
175:03 - check the success
175:05 - of the capture
175:06 - and then we will write image
175:09 - and then we will write
175:11 - cap
175:12 - dot read
175:13 - so this is the main idea and then we
175:16 - will write cv2 dot im show we will write
175:19 - the image and then img
175:22 - and then we will write cv2 dot
175:25 - white key as one
175:28 - so that will give it a one millisecond
175:30 - delay
175:32 - so
175:33 - this is looking good let's run it and
175:35 - see what happens
175:39 - there you go
175:40 - so this is my hand that we will be
175:42 - tracking
175:43 - and we will change the volume from and
175:45 - this is our webcam
175:48 - so what can we do okay one more thing we
175:50 - can do here
175:51 - is we can write here
175:53 - let's say this is the part
175:55 - where we have our
175:59 - parameters
176:00 - so we can write here that our cam width
176:04 - let's write width of our camera
176:07 - and the height of our camera is equals
176:10 - to
176:12 - 640 by 480 so we are basically defining
176:16 - it here and then we can use it here we
176:18 - can say cap dot set
176:21 - prop id
176:22 - number three is width
176:24 - so we will write with cam
176:27 - and then
176:28 - prop
176:30 - id
176:32 - at number four is
176:34 - height cam so we can write height gap
176:37 - so that should be good
176:40 - and let's try it with the different
176:42 - value 1280 by 720
176:45 - so this will make it a little bit bigger
176:48 - yeah there you go
176:51 - so
176:52 - but we are going to use 640
176:55 - by 480 instead
176:57 - okay
176:58 - so that is good what else can we do
177:02 - we can
177:03 - add the frame rate so here we are going
177:06 - to write that our current time
177:10 - is equals to
177:12 - time dot time
177:14 - and then we have the fps is equals to
177:18 - 1 divided by
177:19 - our current time minus the previous time
177:25 - and then previous time
177:27 - previous time is equals to current time
177:31 - so we can define the previous time as 0
177:35 - over here
177:37 - and what else
177:39 - so now we can put this
177:41 - fps on our image so we can write here
177:44 - cv2 dot
177:46 - put text and we will write image and
177:48 - then we will write f
177:51 - p s
177:53 - and we will write the value of the fps
177:55 - let's say
177:56 - integer
177:59 - fps because it's decimal we don't want
178:02 - decimal places
178:03 - and then we can write the
178:06 - the location 70
178:09 - and then we write the font
178:11 - so we can put any font
178:14 - that we want and then we will write
178:17 - the scale
178:19 - and the color
178:20 - so let's write two five five zero two
178:23 - five five
178:24 - and then we will write
178:26 - the thickness
178:28 - so that should be good so let's run this
178:31 - and see if it works
178:35 - oh it does work but looks really bad
178:38 - okay so first of all the color is bad so
178:41 - let's change it to blue
178:43 - so we can remove this
178:45 - and
178:46 - then let's try the blue color first
178:49 - yeah the blue color is much better then
178:52 - we can
178:53 - make it smaller it's really big so scale
178:56 - let's put it as one
179:01 - yeah that seems good thickness
179:04 - thickness is fine i think it's fine we
179:06 - can reduce a little bit but
179:09 - and then we can push it up a little bit
179:12 - let's say 50
179:16 - yeah now it really looks good
179:18 - and in the correct place
179:20 - okay so now that we are all set now we
179:23 - will do the magic part the magic part
179:25 - here is that we already have our
179:28 - hand tracking module so we don't have to
179:30 - write a lot of code we will just use its
179:33 - functionality
179:34 - and we will be able to
179:36 - get our hand very quickly the landmarks
179:39 - of our hand very quickly so we will
179:41 - write here imports
179:44 - hand
179:45 - hand tracking module
179:47 - now if you don't see hand tracking
179:49 - module that is because you need to put
179:51 - it in the same folder as your
179:54 - project so if it's in the it's not in
179:56 - the same folder or if it's not even here
179:59 - then you will not be able to use it so
180:01 - you need to make sure it is in the same
180:02 - folder
180:03 - and we can import it as something else
180:06 - hdm let's say hand tracking module
180:09 - because we don't want to write that
180:10 - complete name it's quite big
180:13 - okay
180:14 - so
180:15 - then we will create an object
180:17 - so this is a class inside here we have a
180:19 - class
180:21 - where is it
180:22 - here hand detector
180:24 - so we will uh create an object from it
180:27 - we will call it detector
180:30 - detector
180:31 - is equals to
180:33 - uh what was the name htm dot
180:36 - hand detector
180:38 - and then we have our default parameters
180:41 - already
180:42 - here so we don't need to write anything
180:43 - for now
180:45 - so we will keep it like that
180:47 - and then what else can we do then after
180:50 - doing this we need to find the
180:53 - location or we need to find the hand so
180:56 - we will write here
180:58 - that detector
180:59 - detector
181:01 - dot find hands so this is the method
181:04 - that we created
181:05 - so this is this method find hands
181:08 - and all we need to do is we need to send
181:10 - in the image
181:15 - so this will give us the hands
181:18 - so
181:19 - we want to draw it so we will not
181:22 - put it as false we will keep the draw as
181:25 - true and it gives us the image back so
181:28 - we will accept that image back again
181:32 - so that is pretty much it so we can
181:35 - we can separate this code
181:37 - not too much we can separate this code
181:39 - so that it is easier to read so now we
181:43 - can run it and see if it works
181:48 - and there you go
181:50 - so now we are getting good detection
181:52 - and
181:53 - it seems quite good
181:56 - so what happens sometimes you can see it
181:58 - detects a little bit on the side and
182:00 - then it detects
182:02 - small hand as well so what we want to do
182:04 - is
182:05 - we want to change the
182:08 - detection
182:09 - confidence here so
182:11 - at default it is 0.5
182:14 - so the detection confidence is 0.5
182:17 - we wanted to be really sure that it is a
182:19 - hand and then only detect the hand this
182:22 - way when you are changing the volume it
182:24 - will be a little bit smoother because it
182:26 - will not flicker too much
182:28 - so we can right here detection
182:30 - confidence is let's say 0.7 so you can
182:33 - play around with this value if you want
182:35 - but i will keep it at 0.7
182:39 - yeah seems fine to me
182:43 - and then
182:44 - we are going to go to the next part
182:46 - which is the best part
182:49 - of
182:50 - getting the position so now
182:53 - all we have to do to get this position
182:56 - is to write that our landmark list
182:59 - is equals to
183:01 - detector
183:02 - dot
183:03 - find position
183:05 - and then we just send in our image
183:08 - that's it
183:09 - uh
183:11 - and we will also write draw is equals to
183:13 - false we don't want to draw it because
183:14 - we are already drawing it
183:17 - so we will keep that as false
183:19 - and now let's run it
183:24 - and there you go we are getting it
183:27 - but i forgot to print
183:29 - so print
183:31 - lm list
183:33 - so let's run that
183:37 - and there you go so at the bottom you
183:39 - can see that we are getting that list
183:42 - so here we are getting that list
183:47 - and we have a total of 20 values here uh
183:51 - 21 values because we are counting 0 as
183:53 - well
183:54 - so we have a total of 21 values
183:58 - now if we want to get the value of a
184:01 - particular point then we can write that
184:04 - point itself so here for example we need
184:06 - point number two so this is the landmark
184:09 - number two
184:10 - so if we run that again
184:13 - okay so this is a good point we are
184:15 - getting an error because the index is
184:18 - out of range so before we actually print
184:21 - or before we actually do anything
184:24 - related to the points we have to make
184:25 - sure that there are some points so we
184:28 - will write here
184:29 - if
184:30 - lm list
184:32 - the length of it
184:35 - is not equals to zero
184:38 - not equals to zero
184:40 - then we are going to do this otherwise
184:43 - it will skip it
184:45 - so let's try that
184:48 - and there you go so now i'm only getting
184:50 - landmark number two
184:52 - so this is good
184:54 - but how do we know which landmark do we
184:56 - need
184:57 - so here is the media pipe website and
185:00 - they have given us the landmark model
185:02 - information so these are all the values
185:06 - that we get all the landmarks that we
185:08 - get
185:09 - so
185:10 - here we will need the value number four
185:12 - which is for our thumb
185:14 - and we will need the value number eight
185:15 - which will be for our index so we need
185:18 - the tip of both the thumb and the index
185:21 - so we will go back here and here i can
185:24 - write i need the value number four
185:26 - and i need
185:28 - the
185:29 - landmark list i need the value number
185:32 - eight
185:33 - so this way
185:34 - we will get only these two values
185:39 - there you go so now i have these values
185:42 - and you can see they are changing
185:44 - but to make sure that we are using the
185:46 - correct ones we are going to
185:48 - create a circle around them
185:50 - so we will write here
185:52 - cv2 dot circle
185:56 - and in the circle we are going to say
185:58 - that we want to put it on our image and
186:01 - then we have to give in the center value
186:03 - now here what we can do is we can create
186:05 - some variables so that we don't have to
186:07 - write all of this again and again so we
186:10 - can write here x1 and y1 is equals to
186:15 - lm list at number four
186:18 - and we need the
186:20 - first element of it so this is the id
186:23 - number zero
186:24 - then this is number one element which is
186:27 - the x and this is the second element
186:29 - which is the y so we need the first
186:32 - element as x
186:33 - and then we need the second element as
186:36 - y
186:38 - and then we can copy this
186:41 - and we can do it for the
186:43 - index as well
186:45 - so we will write here this is 8
186:49 - and this one is 8 as well
186:52 - so now i can simply write x1 and x2
186:57 - x1 and white one
186:59 - and then we are going to write the
187:01 - radius let's say 15
187:04 - and then we will give in the color let's
187:06 - say 255
187:08 - 0 and then 255
187:10 - and then we will write cb2
187:12 - dot filled
187:20 - okay
187:21 - so we can copy this for the other one
187:23 - and we can paste it here and we can
187:25 - write x2
187:27 - and y2
187:30 - so this will
187:33 - create two circles at that point so if
187:36 - we are getting the correct points then
187:38 - it should draw on the thumb and the
187:40 - index and there you go
187:42 - so now you can see that it is drawing on
187:44 - the thumb and the index
187:49 - so this is good
187:50 - now the next thing we can do is we can
187:53 - create a line between them
187:56 - so we can write here cv2.line
187:58 - and within the line we'll give in our
188:00 - image and then we will give an x1 and y1
188:04 - and then we will give in x 2 and
188:09 - x 2 and y 2
188:11 - and then we will give in
188:14 - what else do we have we have the color
188:16 - so 2 5 5
188:18 - 0 two five five and then we have the
188:22 - thickness
188:24 - so let's try that out
188:32 - there you go
188:33 - so now we are getting
188:35 - the line
188:37 - as well in between
188:40 - okay so next thing what we have to do
188:44 - is we have to get the center of this
188:46 - line so we can do that simply by writing
188:50 - here cx
188:52 - and cy
188:53 - is equals to
188:56 - x1
188:58 - plus x2
189:00 - divided by 2 and then
189:03 - y1
189:05 - plus y2
189:07 - divided by
189:09 - 2. so we can simply write it like this
189:12 - and this will give us the cx and cy and
189:14 - we can
189:16 - put a circle for that as well
189:22 - so let's write here c x and let's write
189:24 - here
189:24 - c y
189:27 - so let's try that out
189:29 - and there you go so now we are getting a
189:31 - nice circle in between
189:34 - so this is good
189:37 - now next thing we can do
189:39 - is to find the length so this is the
189:41 - most important thing we need to know
189:43 - what is the length between these two
189:45 - points or what is the length of this
189:47 - line
189:48 - when we know the length of this line
189:50 - then we can change the volume based on
189:52 - that
189:53 - so what we can do is we can write our
189:56 - own function and we can do a little bit
189:58 - of maths to square it and then square
190:00 - root but
190:02 - instead we are going to import
190:05 - math
190:06 - and within math we have the hypotenuse
190:08 - function so we will use that so we will
190:11 - write here that our length
190:15 - is equals to math
190:17 - dot
190:19 - hypotenuse and then inside that we are
190:22 - going to write x2 minus x1
190:26 - and then y2
190:29 - minus y1
190:32 - so that will give us our length
190:34 - so we can print it out
190:39 - so let's try that
190:41 - i think we are printing something else
190:42 - else as well so we need to remove that
190:44 - first
190:46 - okay let's try it
190:57 - okay so
190:59 - here
191:00 - you can see that when i
191:03 - increase the distance the value
191:06 - increases when i decrease it
191:08 - the value decreases so the maximum you
191:11 - can say is around 300 something
191:14 - so
191:14 - we can say
191:16 - let's say it's 300
191:18 - and the minimum
191:19 - let's say is 50. okay so this is the
191:23 - maximum and minimum that we have
191:26 - so
191:27 - one thing we can do is we can write here
191:29 - that if our length
191:32 - is less than 50
191:34 - then we want to change the color of our
191:37 - center circle
191:39 - so
191:41 - let's make it green
191:46 - so this will give it like a button
191:48 - effect so when you're pressing it it
191:50 - changes
191:52 - so here
191:54 - let's let it load okay so here when we
191:57 - come closer
191:59 - there you go
192:00 - so now it actually feels like a button
192:03 - and
192:05 - it is very soothing i don't know why but
192:07 - it's pretty cool
192:09 - and it's quite fast so it is good
192:13 - so this is good and now what we can do
192:17 - is
192:18 - we can
192:20 - uh change the volume based on this
192:23 - length so how can we do that well we
192:26 - have a couple of libraries that can help
192:28 - us with this the one that i found was
192:31 - paiko
192:33 - i don't know why it says call
192:36 - but it is developed by andrey miras so
192:40 - thanks to him for developing this
192:42 - awesome library which allows us to
192:45 - change the volume of our computer so it
192:48 - is
192:48 - under the mit license
192:51 - and if you go down
192:53 - you have to just write pip install pico
192:55 - and then you can use this code as the
192:59 - template so i will copy this
193:02 - because i'm lazy and i will paste it
193:04 - here
193:10 - okay so now what we have to do is we
193:12 - have to simply
193:14 - go to file
193:16 - settings
193:17 - and we will add
193:19 - pico by call you can do pip install as
193:22 - well it's the same thing so we can click
193:25 - on pico and we can click on install
193:32 - so that is installed and we're good to
193:34 - go if we go back you will see all the
193:36 - errors are gone
193:38 - so we will copy the imports
193:41 - and we will we will cut them and we will
193:44 - paste it at the top
193:46 - and the rest of it we are going to see
193:48 - what do we need and what we don't
193:50 - so what we can see here here is that we
193:53 - have the volume get mute so this seems
193:56 - like
193:58 - the initializations so we are not going
194:00 - to change anything there
194:02 - then here we have volume dot get mute uh
194:05 - we don't want that
194:06 - then we have get master volume level um
194:11 - do we need i don't think we need that we
194:13 - might need the volume range
194:15 - and then we have volume dot master
194:18 - volume so we can set the volume so
194:21 - before we set it
194:22 - let's see what is the range
194:24 - so i can print this
194:33 - and there you go so our range is from
194:35 - -65
194:37 - to zero
194:39 - so this is our range
194:41 - so we are going to use these two
194:42 - parameters
194:43 - so 0 will be maximum
194:45 - and
194:46 - 65 will be minimum we will ignore this
194:49 - value
194:52 - so if i set the volume
194:58 - as -20 let's run it
195:02 - and see what happens
195:05 - so right now it is at 26 the volume goes
195:08 - to 26.
195:10 - if i set it as
195:12 - let's say minus 5
195:15 - let's see what happens to the volume it
195:18 - goes to 72.
195:20 - and if i put it as 0
195:27 - then you can see it goes to 100
195:30 - so this is basically the idea so what we
195:33 - can do is we can get the minimum and
195:35 - maximum range
195:36 - so we can write here
195:39 - that our volume range
195:42 - is equals to volume
195:44 - get volume range and then we will say
195:47 - that
195:48 - um or we will keep it like this
195:51 - let's keep it like this we can
195:53 - take the values later on
195:56 - or i think it's better to write so we'll
195:58 - write here minimum volume
196:00 - is equals to
196:02 - uh
196:03 - volume range
196:06 - at
196:08 - one visit yeah at zero
196:11 - and then
196:12 - maximum volume
196:14 - is at
196:17 - one
196:18 - so this is our range
196:20 - okay so now we can use minimum volume
196:22 - and maximum volume instead of using this
196:26 - okay so what is the next thing that we
196:27 - need to do
196:28 - now the next thing is we need to convert
196:31 - our volume ranges
196:33 - so as you saw
196:35 - that our minimum and maximum was 350
196:41 - so we were getting let's write it after
196:44 - the length
196:46 - so here we know that our
196:50 - our hand range
196:53 - was
196:54 - from
196:55 - 300 was the maximum and the minimum was
196:59 - 50. so it was from 50 to 300. now we
197:02 - need to convert it
197:04 - to our volume range so our volume range
197:10 - is from uh minus 65
197:14 - to
197:16 - zero
197:17 - so we need to convert this range
197:20 - into this range
197:22 - so in order to do that
197:23 - we have a very simple function in numpy
197:27 - so we have did we include yes we
197:29 - included numpy
197:30 - so in numpy we can write here
197:33 - volume is equals to
197:36 - numpy dot
197:38 - interpret
197:40 - and inside that we are going to give in
197:43 - the value that we want to convert
197:46 - so we want to convert the length
197:48 - and now we have to give in the range
197:50 - so our range was 50 to 300
197:55 - and then now we have to give in the
197:57 - range to which we want to convert
197:59 - so our range here is the minimum
198:03 - minimum volume
198:05 - and this will be the maximum volume
198:09 - so let's print this out
198:12 - so let's print the volume
198:16 - so let's remove that
198:20 - and let's see if this works
198:26 - so right now it's minus 25 if i go down
198:32 - it goes to minus 65
198:34 - so here our volume is zero
198:37 - and if i go up
198:39 - you can see it should go till zero yeah
198:41 - there you go this is the maximum so this
198:44 - is good
198:45 - uh if you are a little bit confused you
198:47 - can write the length here as well
198:51 - so the length and the volume you can see
198:53 - side by side we can make it let's make
198:55 - it integer
198:57 - that doesn't give weird values
199:06 - so
199:07 - yeah here you can see
199:09 - when we have the minimum volume
199:12 - then it gives us minus 65
199:15 - and then when the length is maximum it
199:17 - gives us zero so this is exactly what we
199:19 - wanted
199:23 - so now that we have converted this we
199:26 - can simply send it to our master volume
199:30 - so we have the function here
199:33 - we can actually remove it from here
199:36 - and we can go down and after the volume
199:39 - we can
199:40 - paste it here
199:41 - so set master volume level we are going
199:44 - to set it as our volume
199:49 - so
199:50 - let's
199:51 - try this
199:52 - so i will open up my volume
199:55 - and let's try this
199:59 - there you go so if i go to zero
200:01 - it
200:02 - goes to zero as well if i increase the
200:04 - length you can see
200:06 - and now it goes to the maximum
200:08 - i think 300 is a little too far
200:12 - well it's fine you can see i can change
200:14 - the volume from here
200:18 - you can make it a little more smoother
200:20 - as well by changing the range of these
200:23 - two over here and even this you can play
200:26 - around with because i can see it's not
200:28 - very proportional
200:29 - so you can play around with those values
200:31 - to make some changes
200:33 - now the last thing we can do is we can
200:35 - show the volume bar
200:38 - on the side so that it looks a little
200:40 - bit nice to see what is the volume at
200:43 - any given point
200:44 - so what we can do here
200:46 - is that we can create a rectangle
200:50 - so we will go down
200:52 - and we will write here
200:54 - cv2 dot rectangle
200:56 - and we will put it on our image
200:58 - we will give it
201:00 - uh the initial position
201:02 - and then we will give it the ending
201:05 - position
201:07 - so
201:09 - we will give that and then we will give
201:10 - in the color so let's make it green
201:13 - and then we will write cb2 dot filled
201:18 - so this is the idea
201:21 - so the width of our bar is basically 85
201:24 - minus 50 which is 35
201:27 - so if we run this
201:30 - there you go so this is our bar
201:32 - and what we have to do is we have to
201:34 - remove the fill
201:36 - we don't want to fill we want let's say
201:39 - three
201:41 - so let's run that yeah so there is our
201:43 - bar
201:44 - and then the next part will be filled
201:48 - so the next part here we will copy this
201:50 - and now
201:52 - we will give in the volume
201:54 - so we will say that our width is the
201:57 - same but the height will be different so
202:00 - we will write here
202:02 - integer our height so
202:05 - volume
202:08 - of this
202:09 - and do we need to change anything else
202:12 - uh not really so here we need to change
202:14 - cv2 dot filled
202:17 - so if we run this
202:21 - volume is not defined oh yeah volume is
202:24 - not defined here so we can write here
202:26 - volume is equals to zero
202:32 - okay there you go so now you can see
202:34 - that
202:35 - it's going out of the
202:37 - uh what he called image so if i try to
202:40 - change
202:42 - let's try to change does it change
202:44 - no
202:45 - because it is too big for us so what we
202:48 - need to do is we need to convert our
202:50 - range again
202:52 - so in this instance
202:55 - our range is from
202:57 - let's say 400
202:58 - so 400 let me show you here
203:02 - so 400 is at this point so this is the
203:05 - height 400 so when our volume is 0 it
203:08 - should be 400
203:10 - and at this point we have what do we
203:12 - have we have 150 when the volume is
203:15 - maximum it should be 150 so our new
203:18 - range
203:19 - so we can write here
203:22 - that this is volume for the bar
203:27 - so we will write here it's again 50 from
203:30 - 300 till 300 but the minimum
203:33 - now is
203:35 - 400
203:36 - and the maximum is 150
203:40 - so instead of volume we will send in
203:43 - volume bar
203:45 - so let's run that
203:48 - okay now volume bar is not defined so we
203:51 - need to write here volume bar
203:53 - and let's do volume as well
203:56 - volume is equals to zero
204:00 - okay let's run it
204:09 - still the same why
204:11 - where did i make a mistake
204:14 - volume bar
204:16 - is from
204:21 - so where is the issue
204:24 - let's run it again and see
204:28 - if i put my hand in
204:30 - ah okay so the first value is wrong
204:34 - so we need to go up here and volume bar
204:38 - should be 400 so it is at the first
204:41 - point it should be zero
204:43 - so our zero is at 400 so there you go
204:46 - so now if i bring in my hand
204:48 - and now if i change you can see it
204:50 - changes the value
204:54 - there you go
204:56 - so the last thing we can do is to add a
204:58 - percentage at the bottom
205:00 - so we can copy this
205:03 - and we can paste it here
205:07 - and in the text
205:08 - we are going to given our percentage but
205:11 - again we don't have any percentage so we
205:14 - can create
205:15 - another
205:17 - conversion here we can write here volume
205:19 - percentage
205:21 - equals to 50 to 300 and now it will be
205:24 - from 0 to 100 so we need the percentage
205:27 - of that
205:28 - and then we can write here
205:32 - that
205:33 - our volume
205:35 - this is our volume
205:37 - should we write volume or let's just
205:39 - keep it like this
205:41 - and then we can write here volume
205:44 - percentage and then we can write
205:47 - percentage in front of
205:48 - that but the location let's put it 440
205:53 - let's keep it at 40 and then let's put
205:55 - this as 450
205:57 - and let's keep the rest same or let's
206:00 - change the color
206:01 - let's make it green
206:03 - so it matches that
206:08 - so let's try that out
206:11 - okay volume percent
206:13 - i always forget this
206:15 - volume percentage is not defined you
206:17 - need to define it as zero
206:19 - or should it be zero
206:22 - uh yeah it should be zero
206:25 - okay
206:26 - so zero percent
206:30 - sixty-four it's hard to see this color
206:34 - let's change the color completely
206:36 - so let's keep it as blue
206:39 - so i will copy the blue color where is
206:42 - it
206:43 - from the
206:44 - fps and we will put it for all of these
206:54 - okay let's try it again
206:58 - yeah now it's much much clearer
207:01 - so here we can see
207:04 - so 100 is a little bit hard to reach so
207:06 - instead of 300 i can make it 250 for
207:09 - example 275
207:11 - but now you can see the percentage is
207:13 - changing let me show the volume bar
207:16 - and you can see here
207:19 - that the percentage
207:23 - is changing
207:50 - hey everyone welcome to my channel in
207:52 - this video we are going to learn how to
207:54 - count fingers we will first look into
207:57 - hand tracking and then we will use the
207:59 - hand landmarks to count the fingers and
208:02 - all of this will be happening in real
208:04 - time and it requires close to no
208:07 - installations and configurations
208:11 - so here we are in our python project and
208:14 - you can see that this is the same
208:16 - project
208:17 - that we used in our previous two videos
208:20 - in the first video we looked at the bare
208:23 - minimum code that is required to do the
208:25 - hand tracking parts and once that was
208:27 - done we created that into a module so
208:31 - that we do not have to write the code
208:33 - again and again and it will be easy for
208:35 - us to create new projects so this will
208:38 - be one of those examples where we create
208:40 - a project out of this module another
208:43 - example that we did earlier was the
208:44 - volume hand control
208:46 - and you can see here
208:48 - that this was the code that we did
208:50 - earlier so all of this is available on
208:53 - my website
208:54 - and now what we will do also there is
208:57 - another folder here
208:58 - you can see that it says finger images
209:01 - so basically what this is that we have
209:05 - the images of different fingers so when
209:08 - it is one when it is two three four five
209:11 - and one it is zero
209:13 - so
209:14 - we can have very specific ones as well
209:17 - where you have the index and the pinky
209:19 - finger up so
209:22 - then you can have only the thumb up
209:25 - and you can have all sorts of different
209:27 - scenarios but for simplicity we are just
209:30 - going to use these six scenarios
209:32 - but if you want to add more later on you
209:34 - can do that and it will pretty much use
209:36 - the same code and you can keep adding on
209:39 - to it
209:40 - okay so
209:42 - once we are in our project we will go to
209:45 - file settings
209:46 - and we will make sure that everything is
209:49 - installed now because this is the same
209:51 - project i know that the packages are
209:53 - already installed but if somebody is
209:55 - doing this for the first time then i
209:57 - will show you what you have to do so
209:59 - here you will write
210:01 - cv
210:02 - dash python
210:03 - and you will install this
210:06 - and then you will go to media pipe
210:10 - media
210:12 - pipe and then you will install this
210:14 - so both of these are installed
210:16 - so we don't have to worry about that and
210:18 - then we will go to our project we will
210:20 - create a new file and this time around
210:23 - we are going to call it
210:25 - finger something finger
210:28 - counting projects
210:30 - let's say
210:32 - so the first thing we will do is to
210:34 - import our cv2 the opencv library then
210:37 - we will import
210:39 - time and do we need anything else we
210:42 - will also import os
210:44 - so i will tell you why we need os
210:47 - later on now the first thing as always
210:49 - we will turn on our webcam so here we
210:52 - will write cap is equals to
210:54 - cv2 dot video capture and we are going
210:58 - to give in device number one most
211:00 - probably for you it will be device
211:02 - number zero
211:04 - and then you have the option of giving
211:06 - the size
211:07 - so you can write for example cap dot set
211:11 - and here we are going to write that this
211:13 - is number three number three is for the
211:15 - width so i can write
211:17 - the width of the cam
211:20 - and then i can write cap dot sets
211:23 - and the heights
211:24 - of the cam
211:26 - so we need to define the width and
211:28 - height so the width of the cam and the
211:31 - height of the camera is equals to 640 by
211:35 - 480.
211:37 - so we can write it like this
211:40 - and what else so then we have to
211:43 - write our while loop so while true
211:47 - then we are going to write here success
211:51 - and image is equals to
211:53 - cv2 dot
211:57 - cap dot read
211:59 - so it will read our frame then we write
212:01 - cv2 dot
212:03 - i am show
212:05 - and inside that we write image
212:08 - and then img
212:11 - and at the end of the day we have to
212:12 - give it a delay so cb2 dot
212:15 - weight key as one so this will give it a
212:18 - one millisecond delay so that we can see
212:22 - our images
212:24 - okay so what else okay the spellings
212:27 - here are wrong
212:30 - success okay
212:33 - so let's try this out and see if we are
212:35 - on the right track
212:38 - so this is my webcam and you can see my
212:41 - hand
212:42 - and that seems good okay so next we are
212:46 - going to
212:48 - do something new here
212:50 - and that will be to import our images
212:54 - so we have all these images so what we
212:57 - need to do is we need to get them one by
212:59 - one
213:00 - and then we want to store them so that
213:02 - later on whenever we have
213:05 - the certain amount of fingers shown then
213:08 - we can display that image so we need to
213:10 - store them first
213:12 - so how do you store it you will use os
213:15 - so what we can do is we can write here
213:18 - that let's say our list
213:21 - my list is equals to
213:24 - os dot list directory
213:26 - so we want to list the directory
213:29 - we want to list all the files that are
213:31 - present in finger images so we will say
213:34 - that our folder path
213:38 - is equals to
213:40 - finger
213:42 - finger
213:43 - images
213:45 - so i will copy this and i will paste it
213:47 - here
213:48 - so now if we print this out
213:52 - you will see that we get a complete list
213:56 - there you go so we get all the names
213:59 - so one thing to note here is that i have
214:02 - put them in order
214:03 - and the last one is zero
214:06 - so when there are no fingers then it
214:08 - will be zero here now you might say why
214:10 - didn't you put it here in the beginning
214:12 - and there is a reason why and i will
214:14 - show you later on
214:16 - why this is the reason
214:18 - what is the reason
214:20 - so then we are going to
214:24 - create
214:25 - a list of images so we can say list of
214:29 - images or we can say let's say overlay
214:33 - because we want to overlay this image on
214:36 - our main image so we will say overlay
214:38 - list is equals to empty
214:40 - and now we can loop through our list so
214:42 - we can say that for
214:45 - image paths
214:47 - in our
214:49 - list
214:51 - we want to
214:52 - create we want to import our image so we
214:55 - will write here image
214:57 - is equals to cv to
214:59 - dot i am read
215:02 - and then we have to given the path of
215:04 - the image so this is the path of the
215:06 - image so it is in finger images and it
215:08 - is one dot jpg so one dot jpg is
215:11 - basically this i am path
215:14 - and then our folder path is basically
215:17 - finger images so we can write here
215:20 - f
215:21 - and then we can write here folder
215:25 - path
215:26 - okay f needs to be small
215:29 - folder path
215:30 - and then we can write slash
215:34 - and then we can write our image path
215:38 - so we can write here
215:41 - image
215:43 - path
215:44 - impact
215:46 - okay so
215:48 - now if you're confused let me show you
215:50 - what this will look like so you can go
215:52 - here and we can print this
215:54 - and we can skip the import or we can
215:56 - import doesn't really matter
215:59 - so there you go
216:01 - so for each of the images you get this
216:03 - finger images at one dot gpg then finger
216:07 - images 2.jpg and so on
216:10 - so this way we get all the paths and we
216:13 - can simply import
216:14 - now we have imported it let's keep it
216:17 - there we have imported it but we didn't
216:20 - save it so we need to save it in our
216:22 - list so we will say overlay list dot
216:25 - append
216:26 - and we want to impend our image
216:29 - so that will give us our image list now
216:32 - to confirm that everything is working
216:34 - fine we can write here length of our
216:38 - overlay list
216:39 - and we can write here print
216:42 - so if that list is six then we should be
216:46 - good to go
216:48 - and there you go so the value is six
216:51 - so this means we have imported all these
216:53 - images
216:54 - and we are good to go
216:56 - so how exactly do we overlay an image
217:00 - now the thing is that image itself is a
217:02 - matrix so what we can do is we can
217:05 - define that our new image we want to put
217:08 - in our old image based on this location
217:13 - so what we can say is that our image is
217:15 - equals to so if i wanted the elements
217:18 - the first element of this list i would
217:20 - say overlay list 1 or overlay list 0
217:23 - right so the same way if i want to
217:25 - target a specific region of my image
217:28 - then i can write that target
217:31 - space in this bracket
217:33 - so this is also called slicing so what
217:36 - we will do is we will give in the height
217:39 - first the range of the height and then
217:41 - we will give the range of the width so
217:43 - we will say that i want to put my image
217:46 - this overlay image
217:48 - whatever it is let's say we are using
217:50 - overlay
217:52 - list
217:54 - at number zero so we are using the first
217:56 - image
217:57 - so i want to put that at zero
218:00 - wait what happens uh
218:03 - i think insert is pressed or
218:06 - yeah okay zero and then 200
218:10 - this is the limit of my height
218:13 - and then 0 to
218:15 - 200 this is the limit of my width
218:18 - so
218:19 - now
218:20 - now the reason i'm putting 200 is
218:22 - because these images are 200 so the size
218:26 - of this image
218:28 - is basically 200 by 200
218:31 - so we can automate that i will show you
218:33 - how to do that too
218:34 - so let's try this and see if it works
218:37 - so i will run this
218:40 - and there you go so now you can see the
218:42 - image number one is displayed at 200 by
218:45 - 200
218:47 - so this is 0 0 and this is 200 200 so
218:51 - our image is now displayed properly if i
218:53 - wanted to shift this i can write for
218:55 - example 100 here and then 100 here
219:01 - so we are getting an error that
219:04 - we have hundred and two
219:06 - hundred uh okay so
219:10 - the problem is that the image is of size
219:13 - 200 by 200 and they are saying that you
219:16 - cannot convert it to 100 by 100 so here
219:19 - hours if i'm increasing 100 here i need
219:22 - to increase 100 here as well so that it
219:25 - maintains that 200 size
219:27 - so if we run this now
219:30 - then you can see that the image has
219:32 - shifted down
219:34 - so this is how you can place your image
219:37 - within our original image
219:39 - so
219:40 - here we are going to write 0 and 200
219:44 - and 0 and 200
219:47 - but now we want to automate this so
219:50 - let's say you don't have a 200 by 200
219:52 - image you have something else
219:55 - you're the size of the image is
219:56 - something else and even the size of each
219:59 - image could be different
220:00 - so what can we do then
220:02 - what we can do is we can write here
220:05 - that for example we are using overlay
220:08 - list 0 okay so we will write here
220:10 - overlay list 0 dot shape
220:13 - so this will give us that shape and we
220:16 - can store it in
220:17 - height
220:18 - width and channel
220:21 - because we have
220:23 - these three things and then we can
220:24 - replace this with height and we can
220:26 - replace this with
220:27 - word
220:30 - so if we run this now
220:32 - then it will give us the same effect
220:34 - because we don't have to worry about
220:36 - uh the size of the image it will put it
220:39 - on the corner
220:41 - so this is good now we understand how to
220:44 - overlay our finger image on the original
220:47 - image now what we can do is we can
220:49 - display the frame rate so here we can
220:53 - write
220:54 - current time is equals to root time
220:58 - dot time
221:00 - and then we have to write fbs
221:04 - is equals to 1 divided by
221:06 - current time
221:08 - minus the previous time
221:11 - and the previous time we have to declare
221:14 - up
221:15 - here in
221:18 - we will put it as zero
221:20 - and then we will say that our previous
221:23 - time
221:24 - is equals to the current time
221:27 - so this will update every loop and then
221:30 - we can simply write
221:31 - cv2
221:33 - dot put text
221:35 - we will write in our image and then we
221:37 - will write
221:39 - the
221:41 - then we will write the fps
221:45 - as an integer and we will write here fbs
221:51 - and what else then we will write the
221:55 - uh what do you call
221:57 - the location so we can put
222:00 - 470
222:03 - and then we will write cv2 dot
222:06 - font any of these and then we will have
222:11 - the scale
222:13 - and then the color
222:17 - and then
222:19 - the
222:20 - thickness
222:21 - so
222:22 - let's try this out and see if we get
222:25 - a good image
222:27 - whoa that is really big
222:30 - so
222:32 - let's change this to
222:34 - font
222:35 - plane
222:39 - there you go so now it is quite good
222:42 - and we can see that it is working
222:45 - so that is good
222:47 - so the next thing would be to actually
222:50 - go into our hand tracking part
222:53 - so here we are going to go up and we
222:55 - will import
222:57 - we will import our module which is the
223:01 - hand tracking module and we will import
223:03 - it as h m
223:07 - so this is what we will do
223:09 - or let's say htm hand tracking module
223:13 - and then we will create
223:16 - uh not here we will go down and here we
223:19 - are going to create
223:20 - a detector so we will write here the
223:23 - detector is equals to
223:25 - htm dot
223:28 - hand detector
223:29 - and we will not give it any
223:32 - values or should we we can give it the
223:35 - detection confidence
223:37 - so we can keep it a little bit higher
223:40 - so 0.75 let's say later on if we get
223:43 - some errors we can change that too so
223:46 - that is good so here we are going to
223:49 - write that we want our detector to find
223:52 - the hands
223:53 - and we will send in our image
223:56 - and we will just ask it ask it to return
223:59 - our image so if we go to the hand
224:01 - tracking module you will remember that
224:03 - this is our class
224:05 - hand detector class inside that we have
224:07 - a method called find hands and it just
224:10 - needs an image and it will output the
224:13 - image with the drawing so we can write
224:15 - here image we will return image back
224:18 - and if we print this
224:21 - it should
224:22 - uh draw our hand
224:25 - so there you go so we have our hand and
224:27 - it is drawing nicely
224:29 - so that should be good and then what we
224:32 - can do is we can
224:33 - create a list
224:36 - of the landmarks that we detect so we
224:38 - will say that detector dot
224:41 - find position
224:43 - and we want it to find the position
224:46 - within our image
224:47 - and we want to
224:50 - draw
224:51 - as false
224:53 - because we are already drawing so we
224:54 - don't want to draw again so we will
224:56 - write here that drawing is false
224:58 - and then we can print our lm list
225:03 - to see if we are getting something
225:08 - so right now it's empty and when i bring
225:10 - in my hand you can see that the list
225:13 - fills up
225:15 - so that is good and now what we can do
225:18 - is we can write here
225:20 - that if
225:22 - the length of our lm list
225:26 - is
225:27 - not equals to zero
225:29 - then we are going to do something
225:32 - so that something could be anything
225:35 - so what we are trying to do is that we
225:37 - are trying to get the tip of our fingers
225:41 - and based on that tip we can decide
225:43 - whether our fingers are open or closed
225:46 - so here is the website of media pipe
225:51 - and we can see that
225:54 - these are our landmarks so what we have
225:57 - to do is we have to first of all get all
225:59 - these points so we need point number
226:01 - four
226:02 - point number eights 12 16 and 20. so we
226:06 - need to use these and then we need to
226:08 - check
226:09 - whether these are below
226:12 - let's say number six or number seven i
226:15 - think it's better to take number
226:17 - six
226:18 - you can even use number five but i think
226:20 - number 5 will be too much
226:22 - so you can say that if number 8
226:25 - is below
226:26 - number 6
226:27 - then it is
226:29 - what you call closed then the finger is
226:32 - closed and if it is
226:35 - above six then the finger is open
226:38 - so what we can do is we can pick one of
226:40 - these and we can try it out and then we
226:43 - can apply it to the rest of them
226:45 - so let's say we pick our index finger so
226:47 - this is eight and six
226:50 - so what we will do is we will write here
226:54 - that if
226:56 - the lm list
226:58 - at number 8
227:01 - we will get the value of the y
227:05 - not the x
227:06 - so y is the third element so it will be
227:08 - 0 1 and 2 so we will write here 2. so if
227:12 - the point number 8
227:15 - is less than
227:17 - the point number
227:22 - point number
227:23 - six then it means it is open
227:27 - so in that case
227:30 - we will write here print
227:33 - index
227:35 - finger
227:37 - open
227:40 - so
227:42 - because we are using the
227:44 - opencv orientation so up means lower
227:47 - values so our image is starting from the
227:50 - top so the maximum value at the maximum
227:53 - height is zero
227:54 - so to check
227:56 - for example here our value is 50 and
227:59 - here our value is 100 then it means our
228:02 - finger is open if it's the opposite if
228:05 - it's 100 here and then 50 here then it
228:08 - is it means it is closed
228:11 - so here we are going to try out and see
228:14 - if it says finger open
228:20 - so here right now it's saying finger
228:22 - open if i close it you will see that it
228:25 - stops saying actually let me remove the
228:28 - print it's quite annoying
228:31 - so
228:32 - let's run it again
228:37 - so right now it will say index finger
228:39 - open
228:40 - if i stop if i close then it will stop
228:44 - and if i open it again it will say index
228:46 - finger open so this is how you can tell
228:49 - if the finger is open or not
228:52 - so now we need the tip points for each
228:54 - one of these so for each finger we need
228:57 - a point
228:58 - now we could write a lot of if
229:00 - statements and if you are using a lot of
229:02 - different types for example if you have
229:05 - the pinky finger and the index one up as
229:07 - well and then you consider that a
229:09 - different gesture than
229:11 - your two fingers of any kind for example
229:14 - the index finger and the middle finger
229:16 - up so if you want to differentiate
229:17 - between these then you have to create
229:19 - lots of different images lots of
229:21 - different scenarios but here we are only
229:23 - going to use six scenarios so we can
229:25 - simply use a for loop
229:27 - so what we will do is we will create a
229:30 - list here and we will call it tip ids
229:34 - and this tip ids will be basically
229:37 - number four
229:39 - which is for the thumb
229:40 - number eight for the index
229:43 - number 12 for the middle finger then 16
229:46 - for
229:47 - the
229:47 - ring finger and then 20 for the
229:51 - pinky finger
229:52 - so these are the tips
229:54 - and then what we can do is we can put a
229:57 - for loop here and then we can change
230:00 - this value
230:01 - so here we can say
230:04 - for let's say id in range
230:10 - what is the range from 0
230:12 - to
230:14 - 5
230:15 - we are going to
230:18 - repeat this
230:19 - and here we are going to put in the
230:22 - value so the idea is that we have our id
230:25 - number four
230:27 - so we can write here tip ids
230:32 - at number id
230:36 - okay
230:37 - and the other value so here you can see
230:39 - it is eight and here it is six
230:42 - so it is minus two
230:44 - so whatever value we have here
230:47 - minus 2
230:48 - so this minus 2
230:51 - so
230:53 - this should basically
230:55 - loop and it should tell us
230:57 - for each one of these but once it tells
231:00 - us that if the finger is open or not we
231:04 - need to save that so here we can write
231:07 - fingers
231:09 - fingers is equals to
231:12 - empty and here we can write
231:14 - fingers dot append
231:17 - we can append either one
231:20 - or
231:21 - we can append
231:26 - zero
231:28 - so if the finger is open
231:33 - then we will append one
231:36 - if the finger is closed then we will
231:38 - append zero so here we will write
231:41 - prince
231:42 - fingers
231:44 - so let's see how that works out
231:48 - so if we have our
231:50 - hand in you can see all the fingers are
231:53 - open if i close
231:56 - all of them close except for the thumb
231:59 - so we will discuss the thumb but let's
232:01 - try the other ones out so here we have
232:03 - one the index finger
232:05 - then the middle finger
232:07 - then the
232:08 - ring finger
232:10 - and then the
232:12 - pinky finger
232:14 - so you can see it is really good i can
232:17 - do one two three and four
232:19 - there you go so that is amazing so what
232:22 - i was saying earlier is that for example
232:24 - if you have this pose
232:26 - it will show you
232:28 - that
232:29 - the index is open and the pinky is open
232:32 - but for images we are still going to use
232:35 - this image
232:36 - that it will show us that there are two
232:38 - fingers open
232:39 - because we are not using all the
232:41 - scenarios
232:43 - now one thing you have noted is that the
232:45 - in the thumb is an issue
232:48 - and the reason is that the tip of the
232:50 - thumb is not acting the same way so we
232:54 - are using the tip at this point
232:57 - so this is the point where we are using
232:58 - the tip and we are saying that when it
233:00 - is below this point
233:02 - because -2 will be here
233:05 - at this point so this basically is never
233:08 - going below that if i really push my
233:10 - finger
233:12 - maybe
233:13 - not even then so that is not a good way
233:15 - to check it
233:16 - so how can we check it can we say that
233:19 - if this is below
233:22 - instead we can write -1
233:24 - even in that case it is very hard to
233:27 - bring it below that
233:29 - maybe now it will say 0
233:32 - but it will be very hard so how can you
233:34 - tell if the thumb is closed or not so
233:37 - for the thumb what we actually do is
233:40 - naturally when we are closing we put it
233:43 - on the side
233:44 - we don't bring it down we put it on the
233:46 - side so we can check
233:49 - whether this point here at the top is on
233:52 - the left of the
233:54 - second point or on the right so right
233:57 - now it's on the right now it's on the
233:59 - left
234:00 - so when it comes to the left side we
234:03 - will say it is closed and when it's on
234:05 - the right side we will say it's open
234:08 - so this is the idea so let's see how we
234:11 - can do that
234:13 - so what we will do is we will keep this
234:15 - for loop for the four fingers so we will
234:18 - just make it one to five
234:20 - and then
234:21 - over here we are going to create another
234:23 - loop uh not another loop just an if
234:26 - statement
234:27 - and we will say that
234:29 - the id number one which is the x axis
234:33 - is less than
234:35 - this point id number one and then we
234:38 - will check minus one not the uh
234:42 - two values below only one value below
234:44 - only one landmark below
234:48 - so if you are not clear about this i'm
234:50 - talking about this point number three so
234:53 - if this point
234:54 - is on this side
234:56 - then we will consider it closed if this
234:58 - point is on this side
235:01 - of the point so here it is on the left
235:04 - then we will consider it
235:06 - open
235:07 - so keep in mind for the left and for the
235:09 - right hand it will be different
235:11 - so if you are doing it for the right
235:13 - hand uh it will be the same what i am
235:15 - doing if you are doing it for the left
235:17 - hand then you can uh do it the other way
235:20 - around now you might say that if i am
235:22 - using it with the left hand with this
235:24 - code it will not work yes it will not
235:26 - work but there is a possibility of
235:29 - checking
235:30 - whether it's a left hand or a right hand
235:32 - and then based on that you can change
235:34 - your parameters you can change the if
235:36 - statement
235:37 - based on that
235:38 - so it is not something very complicated
235:40 - it's very simple but right now we will
235:42 - just focus on the right hand
235:44 - so here what we will do is
235:47 - uh okay we have already written the code
235:49 - so we don't need to do anything else
235:51 - so
235:52 - we can write here thumb
235:56 - thumb and we can write here
236:01 - uh four
236:03 - fingers
236:05 - so
236:06 - that is the idea so let's try this out
236:09 - if it works or not
236:15 - okay we have another
236:18 - must be integers or slices
236:26 - okay
236:27 - uh oh there's no id my bad
236:30 - so there's no id we have to get our id
236:33 - by itself so this will be number zero
236:42 - so let's run that again
236:47 - okay then we have another issue
236:51 - tip ids
236:52 - zero one
236:57 - okay i think there's an issue with the
236:58 - brackets
237:00 - so there should be a bracket here
237:05 - so tip ids
237:08 - add zero
237:10 - yeah
237:12 - and then the first part of it so the
237:14 - bracket should be here
237:18 - and over here
237:20 - uh it will be tip ids minus one and
237:23 - there you go
237:24 - so it should be like that
237:29 - okay so now you can see it is zero
237:32 - when it should be one so it is basically
237:34 - opposite so we need to make it
237:36 - greater than
237:42 - so now you can see all of them are one
237:44 - if i put my thumb if i close it you can
237:47 - see it says zero
237:49 - so that's how easy it is
237:52 - so now if i put all of them closed you
237:54 - can see it says zero and if i open i can
237:57 - open one by one
237:59 - two three four and five
238:02 - and i can get all the detections
238:05 - so that is good
238:07 - now the next thing we have to do we have
238:09 - to change our image
238:11 - so to change the image first of all we
238:13 - need to know
238:14 - how many fingers did we actually get
238:18 - so to do that
238:20 - we can actually let's go up here let's
238:23 - comment this and instead we are going to
238:26 - write here
238:27 - that our total fingers
238:30 - total
238:34 - total
238:35 - fingers is equals to
238:38 - fingers
238:39 - dot count
238:40 - so this is a method in our list
238:44 - so we have a list
238:46 - in which we can use the count method to
238:49 - count the number of values present of
238:53 - what of the number one
238:56 - so basically we are saying find how many
238:59 - uh ones do you have
239:01 - i think the
239:02 - indentation of this is wrong
239:05 - so we need to fix that
239:08 - okay so then we can print
239:12 - the total fingers
239:15 - let's try that
239:19 - oh
239:20 - it has no attribute counts
239:23 - because c is supposed to be small
239:30 - okay so let's try that
239:35 - here we have 5
239:37 - 0
239:38 - 1
239:39 - 2
239:40 - 3 4
239:42 - 5
239:43 - 4
239:45 - 3
239:46 - 2
239:46 - 1 0. there you go
239:49 - so now it's looking good and all we have
239:52 - to do now is to change our image so how
239:55 - can we change the image so here we have
239:57 - the code for changing so we will bring
240:00 - it in the loop
240:02 - or what is it
240:04 - in the if statement so we will bring it
240:06 - in the if statement and then we have to
240:09 - change the value over here
240:12 - so we have to put a value
240:14 - based on the total fingers so already we
240:17 - have laid down if it is finger number
240:19 - one it should be element number zero so
240:22 - we can take this total fingers
240:27 - wait what happened total fingers
240:30 - minus one
240:31 - so if it is one
240:34 - it will become zero so it will take this
240:36 - image
240:37 - if it is two
240:38 - it will become one and it will take this
240:41 - image
240:42 - so this is how it will work so let's see
240:45 - if it changes
240:47 - we are taking the shape of zero we
240:48 - should take the shape of the same image
240:54 - even though all of them are same doesn't
240:56 - matter at this point but overall
240:58 - it could be different okay so we have 5
241:01 - now
241:02 - and then we have zero one
241:05 - two three four five
241:09 - so that's how easy it is
241:11 - one two three four five
241:12 - and it looks like an animation if i do
241:14 - it fast
241:15 - and it's running real time so it looks
241:17 - really good now you might say we didn't
241:19 - add zero we didn't we actually never
241:22 - said
241:23 - go till six
241:24 - so this value of total fingers can be
241:27 - let's say at five maximum right and then
241:30 - five minus 1 is 4 how is it going to 6
241:33 - that does not make any sense right
241:36 - so this is why i put it here as 6.
241:39 - what happens is that when the value of
241:42 - total fingers is 0
241:45 - it gives the value of minus one
241:47 - and in python what we have is that if we
241:50 - write minus one
241:52 - of the list it will take the last
241:54 - element so the last element is the value
241:57 - number zero
241:59 - so that's why i put the image at the end
242:01 - so it will take that minus one value and
242:04 - whenever it is zero it will become minus
242:06 - one and it will take the last element
242:08 - which is the sixth element
242:10 - so this is uh
242:13 - the results so you can see here
242:15 - whenever it is zero
242:17 - it gives us
242:18 - that a fifth image which is image number
242:21 - six
242:23 - so this is good and we are pretty much
242:25 - done the only thing we can do is we can
242:28 - add a rectangle to show the count so
242:31 - that it is a little more appealing you
242:34 - can say
242:35 - so here we can write cv2
242:38 - dot rectangle
242:40 - we will put in an image
242:42 - and then we have to give it the
242:46 - uh the points the starting point and the
242:49 - ending point
242:51 - uh 170 so i have
242:53 - uh tried out this before so i know the
242:55 - values that will work properly so i'm
242:58 - directly inputting those so then we can
243:01 - put the color
243:02 - let's say green
243:05 - and then we can write cv2 dot
243:07 - filled
243:10 - so if we run this
243:13 - uh you will see whenever we have our
243:16 - image or whenever we have our detection
243:18 - we get that green rectangle
243:21 - so this is only coming when we have the
243:23 - hand because it is in the if statement
243:26 - so if we put it outside the if statement
243:28 - it will it will always appear
243:30 - but i prefer that it disappears whenever
243:33 - the detection is not there
243:36 - so then we are going to put the text we
243:38 - will write cb2 dot
243:40 - put text
243:41 - and inside that we will add our image
243:44 - and we will change
243:45 - the text to total fingers
243:49 - and then
243:50 - we will give in the location
243:54 - and then we have to give in the font
243:57 - so we will pick
243:58 - the
244:00 - fonts
244:01 - plain font and then we have to give in
244:03 - the scale we will keep it really big so
244:06 - we can see
244:08 - two five five zero and zero
244:10 - and then we will put 25
244:13 - so this is the thickness
244:16 - so let's try that out
244:19 - and we'll bring in our hands
244:21 - and if we close it's zero one two three
244:25 - four five
244:27 - i will do it again one two three
244:30 - four and five
244:35 - one two three four five
244:56 - so as you can see it works really well
244:59 - and the detection is really great but
245:02 - again if i use these two
245:04 - two fingers it will still show me the
245:06 - image of two
245:07 - and if i let's say put these three up it
245:10 - will still show me the three default
245:13 - image that we have so if you want to
245:15 - change these you will have to put if
245:17 - statements
245:19 - for each of these you will have to have
245:21 - an if statement rather than a loop
245:24 - and you can define
245:25 - if this is the case then this should be
245:27 - the image if this is the case then this
245:29 - should be the image so each of the
245:30 - fingers can be like a binary so if that
245:34 - is 0 0 1 1 then you do this if it's 1 1
245:37 - 1 you do this 1 1 0 0 you do this and so
245:41 - on so you can do it like that
245:48 - hey everyone welcome to my channel in
245:50 - this video we are going to create a
245:52 - personal ai trainer we will use the pose
245:55 - estimation running on cpu to find the
245:58 - correct points and using these points we
246:00 - will get the desired angles
246:02 - then based on these angles we can find
246:05 - many gestures including the number of
246:07 - bicep curves
246:08 - we will write the code in a way that you
246:10 - will be able to find angles between any
246:13 - three points with just a single line of
246:15 - code
246:16 - so here we are in our python project and
246:19 - you can see that this is the exact same
246:21 - one that we used in our previous video
246:25 - so we started off with the bare minimum
246:28 - code so you can see this is all of the
246:31 - bare minimum code that we required to
246:33 - run our pose estimation
246:35 - and then we created a module out of this
246:38 - so this is that module which allows us
246:40 - to create these projects very quickly so
246:43 - today will be one of these examples
246:45 - where we create a project very rapidly
246:49 - so then here is our awesome project so
246:53 - this was the demo of how you can
246:55 - actually utilize this
246:57 - to run your module
247:00 - so these were the things or these were
247:02 - the files that we created last time so
247:04 - if you haven't checked that video i
247:06 - highly recommend that you do go through
247:09 - that video before you continue here
247:11 - now today we are going to do the ai
247:13 - trainer so we have a new folder here
247:16 - called the ai trainer
247:18 - let's open that up
247:20 - and let's check out the contents
247:23 - so here we have
247:25 - a test image
247:27 - so basically the idea is that we want to
247:30 - find the angle
247:32 - of any
247:33 - three given points so point number one
247:36 - point number two and point number three
247:38 - so
247:39 - this is actually explained here in the
247:41 - summary
247:42 - so what we will be doing is
247:44 - we will be using these three points
247:48 - and based on these three points we are
247:49 - going to find the angle between these
247:52 - two lines
247:53 - so that will tell us
247:55 - uh how much angle we are at and based on
247:58 - that we can do some calculations for the
248:00 - gestures or for the poster so that we
248:03 - can tell the person okay you have done
248:06 - this many curls so what we will be doing
248:09 - is we will be counting the number of
248:11 - curls that a person has done you can
248:14 - apply to other techniques as well to see
248:16 - the posture whether they are using
248:18 - correct ones for yoga or something like
248:20 - that
248:21 - so
248:22 - the main idea is that we will do this in
248:25 - two steps the first one will be to find
248:28 - the angles so we will create a method
248:32 - where we we can input any three points
248:35 - and it will give us the angle of these
248:37 - three points so this way we do not have
248:40 - to
248:40 - worry about getting other angles for
248:43 - example if i want for the leg i will
248:45 - have that information as well if i want
248:47 - for the arm
248:48 - and the shoulder i can have that
248:50 - information as well for the elbow and
248:52 - the wrist i can have that so
248:55 - with one single line of code i will be
248:57 - able to have all of these different
249:00 - angles so i will just have to specify
249:03 - the landmark number for example uh
249:06 - for this arm it is 11
249:08 - 13 and 15 so i can say 11 13 15 and it
249:12 - will give me that one if i say
249:14 - 12
249:15 - 14 and 16 it will give me for this one
249:19 - so
249:20 - for sorry for this one so this is the
249:23 - idea that we will create this
249:25 - method and the second part is where we
249:28 - will try to find the angle and no
249:31 - actually we will have the angle and
249:33 - based on that angle we will see how many
249:36 - curls did the person do
249:38 - so this is our idea
249:41 - so we will start off with this is by the
249:43 - way the video
249:45 - let me bring it here so this is the one
249:47 - we will be using
249:49 - again both of these images and videos i
249:51 - got from pexels.com
249:53 - so you can check it from there or you
249:56 - can find these documents in my
249:59 - website so you will find this folder
250:01 - over there
250:02 - so what we will do is we will right
250:04 - click and we will create a new file
250:07 - and we are going to call this let's say
250:10 - our
250:11 - a
250:12 - ai
250:13 - trainer
250:15 - project
250:19 - so the first thing we will do we will
250:20 - import our packages so we will write
250:22 - here import cv2 then import
250:25 - numpy as
250:27 - np
250:28 - and what else do we need we need time
250:31 - so we will import that so all of these
250:34 - packages we have imported earlier so if
250:36 - you are new and you haven't seen the
250:39 - previous video you can go to settings
250:41 - python interpreter and you can add and
250:44 - here you can write
250:46 - opencv dash python
250:49 - and you can hit install and then you can
250:52 - write media pipe
250:54 - media pipe and there you can install
250:58 - so these are the two libraries
251:00 - that are
251:01 - the most important ones
251:03 - okay so once we have that we are going
251:05 - to import our image and the video so
251:08 - here you can see
251:10 - we have the
251:11 - image
251:12 - not this one the test image and the
251:14 - video so we will be using the test image
251:18 - at first for the angles and once we have
251:21 - that then we will use the video for the
251:23 - curls
251:25 - now uh we will write the while loop
251:27 - anyway so that we don't have to switch
251:31 - at the end we just can remove one line
251:34 - and it will convert to video
251:36 - so we will write here first that we have
251:39 - a video capture device so we will write
251:42 - here
251:43 - uh cv2 dot video capture and we will say
251:47 - this is
251:48 - the ai
251:50 - trainer
251:52 - slash what is it
251:54 - girls dot mp4
251:58 - and then we will say while
252:00 - true we are going to
252:03 - check the success and the image and we
252:07 - will say cap dot read
252:09 - and oh and then we will say
252:12 - cb2 dot im show
252:15 - we will write here image
252:18 - image
252:20 - and then we will write image
252:23 - and cv2 dot weight key and layoff one
252:27 - so if we run this we should get our
252:30 - video running
252:32 - so
252:32 - let's run that
252:34 - and there you go
252:35 - so as you can see this is quite
252:38 - a big video it's quite huge we can
252:40 - resize it we can write here image is
252:43 - equals to cv2
252:45 - dot resize
252:47 - and we want to give it a specific one so
252:50 - we will write here
252:52 - one two eight zero by 720
252:55 - so let's try that
252:57 - and there you go so now this is good and
253:00 - we are ready for the girls part but as i
253:04 - mentioned before we are going to use the
253:05 - image first and later on we are going to
253:08 - use this so we are going to comment this
253:11 - and here instead we are going to write
253:13 - image is equals to cv2 dot
253:16 - i am
253:17 - read
253:18 - and then we can read our
253:21 - image so it will be a i
253:24 - trainer slash what is it
253:28 - test.jpg
253:29 - so we can actually put it outside
253:33 - so let's run that
253:36 - and there you go so we are getting our
253:38 - image so we will check the angle of this
253:42 - and we will see how we can calculate
253:44 - that okay
253:46 - so that is good now we need to find our
253:49 - pose so to find the pose what we have to
253:52 - do is we have to import our pose module
253:55 - so here is our pose module that we did
253:57 - in our earlier video
253:59 - so here
254:00 - we have the class pose detector
254:03 - we are going to use that to create an
254:05 - object once we have the object we can
254:07 - use find pose to find the pose and then
254:10 - find position to get all the data in
254:13 - that list
254:15 - so here we are going to say
254:17 - detector
254:19 - the
254:20 - detector
254:22 - is equals to
254:24 - oh i didn't import forgot to import so
254:27 - imports
254:29 - pause module pose
254:32 - module as pm
254:34 - and then we can write here pm dot post
254:37 - detector and we do not need to give any
254:41 - inputs at this point
254:43 - so then we can come down here and we can
254:46 - write here
254:47 - that uh detector
254:50 - dot find pose
254:52 - and do we need to input anything
254:55 - uh we need to put input the image and
254:58 - then we need to tell whether we want to
255:00 - draw or not so by default it's true so
255:02 - we will draw
255:04 - and what else so do we need anything
255:07 - back
255:08 - uh no not really we can yeah we need the
255:11 - image back
255:13 - so let's run that
255:15 - and there you go
255:17 - so now you can see
255:19 - uh okay this is not good we need to put
255:21 - it inside
255:25 - so it's
255:26 - detecting again and again
255:28 - there you go
255:29 - so now you can see it is detecting the
255:32 - pose
255:33 - and now we can try to find the
255:36 - angle
255:37 - but how do we get the landmark
255:39 - values so we can use the get position so
255:43 - we will write here nlm list is equals to
255:47 - detector dot get position
255:51 - wait why is it not showing
255:54 - detector dot
255:56 - is it oh it's find position okay so find
256:00 - position and then we will write image
256:02 - and we don't want to draw so we will
256:05 - write here false
256:07 - i think there are only two arguments so
256:09 - we can directly write false yeah
256:11 - so that's fine
256:14 - so let's run that
256:16 - actually we need to print to see if
256:18 - we're getting anything
256:20 - lm list
256:21 - and let's do that
256:23 - and there you go so this is our list
256:26 - and we can see we have all these 32
256:28 - points
256:30 - so that is good okay so now we can
256:36 - uh first of all we need to make sure
256:37 - that
256:38 - we have a list where we have uh the post
256:41 - detected otherwise it will give us an
256:43 - error so we can write here the length of
256:46 - our lm list
256:48 - is not equals to zero
256:52 - then we are going to do something
256:54 - magical so what is the magic that we are
256:57 - going to do
256:58 - so
256:59 - now here the thing is that we can write
257:02 - the code here
257:03 - but then it will be for this project
257:05 - only we can write here pass for now
257:08 - so that will be for this project only
257:11 - but we don't want to do that we want to
257:14 - we want to enhance our pose module by
257:16 - adding a method to it
257:18 - so this pose class which is the pose
257:22 - detector
257:23 - it will have another
257:25 - method that will allow us to get the
257:27 - angle of any three
257:30 - landmarks so instead of giving the
257:33 - points for example 485 and 281 what we
257:37 - will do is we will say we want to find
257:40 - the points between three
257:42 - four and five
257:43 - and because it already has this method
257:46 - and it already has this list
257:49 - we will make it an instant list so that
257:52 - it is for that particular object so then
257:55 - we will not have to even input the point
257:57 - value we just have to input the number
258:00 - so we need to know which
258:02 - landmark numbers we are talking about
258:05 - so how can we do that let's start by
258:08 - writing our code so the first thing we
258:10 - will do is we will create a new method
258:12 - we will call it find
258:15 - angle
258:16 - or angle no find the angle because it's
258:18 - just one angle then we will give in our
258:21 - image
258:23 - um the image
258:25 - the image is for drawing so we will
258:28 - input that
258:29 - and then we will need the three points
258:31 - so we will call it p1
258:33 - p2 and p3 so these are the three point
258:37 - uh landmarks that we need and then we
258:40 - can have the flag for drawing as always
258:43 - so we will keep it as true
258:48 - okay
258:49 - so now as i said instead of giving in
258:52 - the points we are just using the values
258:56 - so we are using value number four value
258:58 - number three you can call them index
259:01 - index number two three
259:02 - four
259:03 - so these are basic basically index
259:06 - values so what we need to do is we need
259:08 - to get the
259:10 - values of the points
259:12 - based on our index value so how can we
259:14 - do that so in the find position you can
259:17 - see we have the lm list
259:19 - so what we can do is here we can send
259:22 - this lm list back again
259:24 - to our
259:25 - object but that is not a good way to do
259:27 - it because we already have it we can
259:29 - just use it internally so we can write
259:32 - here self dot
259:34 - and now this is part of that object
259:38 - so we will write here self dot
259:40 - and we will write here self dot
259:44 - so now what we can do is
259:46 - we can write here
259:48 - that our x1
259:50 - and
259:51 - x1 and y1
259:54 - is equals to
259:55 - self
259:57 - dot
259:58 - self
259:59 - dot
260:00 - lm list
260:02 - at
260:04 - point number one
260:06 - so let's say we want landmark number
260:08 - three
260:09 - so that will give us this landmark
260:11 - number three but the thing is it has
260:14 - three things inside it has number three
260:17 - it has 485 and 281
260:20 - so what we can do is we can slice it so
260:22 - here we will write
260:24 - we need for from point number one
260:27 - till the end
260:28 - so it will take this
260:31 - and this
260:33 - and it will ignore this
260:35 - so then it will store it in x one and x
260:37 - uh in y one you can also do it like this
260:41 - so you can ignore the first one
260:44 - and you can you can remove this one and
260:47 - you can ignore the first one and you can
260:49 - take just the
260:51 - last two
260:52 - but uh let's do the first method let's
260:55 - do it like this
260:56 - and then
261:00 - we are going to write here x2
261:04 - y2 and then x3 and white by three
261:09 - and here we are going to write point
261:11 - number two and point number three
261:14 - now to make sure we are getting the
261:16 - correct points we are going to draw
261:19 - so here we will write
261:21 - if draw
261:24 - we are going to write a circle so let's
261:27 - just copy because we are lazy
261:31 - and we will just change this to x1
261:34 - and x2
261:37 - okay so
261:39 - yeah that should be good
261:41 - we can copy this
261:44 - and we can make it
261:46 - x
261:48 - wait what did i do
261:49 - x 1 x 2 why did i do x 1 x this should
261:52 - be
261:53 - y 1
261:55 - i always make that mistake y 2
261:58 - x 2 and then
262:00 - y 2
262:01 - and then x three and then y three
262:06 - okay
262:07 - so
262:08 - that should give us but we didn't call
262:10 - it so we need to call it
262:12 - here so we are going to write
262:16 - that detector dot get angle
262:20 - or find angle
262:22 - and we will give in our image
262:25 - so now we need to give in the points
262:28 - so if we go to media pipe and we check
262:30 - for the points you can see that we want
262:34 - point number 11
262:35 - 13 and 15
262:38 - and then 12 14 and 16
262:41 - so based on if we want right or left so
262:44 - the left one is the odd one so 11 13 and
262:48 - 15 is the left one
262:50 - so here i think the right one is visible
262:53 - so we will use the right one so 12 14
262:57 - and 16
262:58 - and the draw we will keep it as true
263:01 - so
263:02 - now let's run this and see what happens
263:05 - and there you go so now you can see
263:07 - these have turned blue
263:09 - so we know that these are the ones that
263:11 - we are using
263:13 - uh
263:15 - should we decorate it more or should we
263:17 - do it later let's do it now so what we
263:19 - can do is we can make it look a little
263:22 - bit nicer
263:24 - just to make sure
263:26 - that we are using these correct points
263:27 - because uh at some point we are going to
263:30 - remove all the other
263:31 - uh what do you call the detection the
263:33 - pose estimates
263:35 - so here we are going to
263:38 - create
263:39 - a bigger circle and let's
263:42 - put it as
263:44 - 15 and let's
263:46 - put this as 10
263:48 - and we will not fill it and we will put
263:50 - the value of 2 here
263:52 - and for the color let's put it as red
263:56 - so here we are going to write 255
263:59 - and
264:01 - we are going to write here
264:04 - all of these as red
264:07 - um
264:08 - yeah and then what else so we will copy
264:11 - this
264:14 - we'll paste it here and paste it here
264:17 - we'll make it two
264:19 - and two and then three and three
264:22 - so let's try that
264:24 - there you go
264:25 - uh oh we forgot to remove the filled
264:30 - no we did remove the fill oh we didn't
264:32 - do the
264:33 - size we forgot to change the size
264:37 - okay
264:38 - there you go so these are the three
264:40 - points and
264:41 - what else we can do the line as well
264:44 - so let's do the line before that because
264:46 - uh the circles we want to draw on the
264:49 - line
264:50 - so we will write here cv2 dot line
264:53 - and the first line will be on the image
264:56 - and
264:57 - we will have two points
265:00 - and then we will have we will put the
265:02 - color of white so it's really visible
265:06 - and then we will put the thickness of
265:08 - three
265:09 - so here our first
265:11 - uh what do you call points will be x1
265:14 - and y1
265:15 - and then the second one will be x2 and
265:18 - y2
265:19 - we will copy this
265:21 - and here we will have what happened
265:24 - there
265:25 - here we will have
265:27 - x3
265:29 - so 2 will be common for both of them
265:33 - one and three will be changing so let's
265:35 - try this
265:38 - uh nothing happens why
265:40 - didn't anything happen because i
265:43 - put this in the wrong place
265:47 - this should be outside
265:51 - okay
265:53 - there you go so now we have the white
265:55 - line
265:56 - and so now we can go back and we can
266:00 - make this false
266:03 - so that we can just focus on these three
266:06 - points and the rest will be gone so
266:07 - there you go so now we have these three
266:10 - points and we want to know the angle
266:13 - between these points
266:15 - so
266:16 - we will go back to our module and here
266:21 - now we need to find the angle so the
266:23 - angle finding is not actually hard
266:26 - so here we can write for example get the
266:29 - land
266:31 - marks and here
266:33 - we are going to write
266:36 - calculate the
266:39 - angle
266:41 - and then here we will write
266:43 - draw
266:45 - well
266:46 - you know
266:47 - it's written draw here and we're writing
266:49 - draw here
266:50 - very redundant
266:52 - but anyways so we will write here angle
266:54 - is equals to we are going to use math
266:58 - so we will write here imports
267:01 - import math
267:04 - so this is just basic trigonometry so we
267:06 - don't have to worry too much about this
267:08 - so what we can do is we can write here
267:11 - math
267:12 - dot tan 2
267:15 - sorry a tan 2
267:17 - a tan 2 and then we have to give in y 3
267:22 - minus y 2
267:24 - and then x3
267:26 - minus x2
267:29 - then we will subtract
267:32 - and we will write here math dot a tan 2
267:37 - and then we will write y1
267:39 - minus
267:40 - y two and then we will write
267:43 - x one minus
267:45 - x two
267:48 - so again i'm missing some brackets
267:52 - so that should be good so this will give
267:55 - us our angle in radians so we can
267:57 - convert it into degrees so math dot
268:01 - degrees
268:03 - and
268:05 - there you go
268:06 - so if you have three points
268:08 - and you want to find the angle between
268:11 - the two lines the this is the method
268:13 - this is the equation that you can use so
268:15 - here we can simply write print angle
268:18 - and we can see what exactly is our angle
268:22 - okay
268:23 - uh what happened there so there's a
268:25 - mistake for sure it's the brackets
268:29 - yeah and this is extra
268:34 - so
268:36 - yeah i put one extra
268:39 - my bad okay
268:41 - so here we are getting our angle 87
268:44 - which
268:46 - makes sense like it is almost 90 degrees
268:49 - you can see that
268:51 - so
268:52 - 87.3 it's not bad
268:54 - so what we can do is we can put this on
268:58 - the actual text
268:59 - or the actual image so that we can see
269:03 - so we can write here cb2 dot put text
269:07 - and we will write image and we will
269:09 - write the angle
269:11 - but let's convert it into integer
269:14 - and
269:16 - then we will convert it into string
269:18 - otherwise it will not accept
269:20 - and then we will write here
269:23 - uh the value so
269:25 - the position so here we will write x2 so
269:28 - this is the center point so we have x1
269:32 - and x2 these are the further points and
269:35 - x2 is the middle point so we want to
269:37 - write the value near the middle point
269:40 - so we are using x2 but we don't want to
269:43 - write it exactly at that position so we
269:46 - can subtract like 20 from it
269:48 - and then we can write y2
269:51 - and we can let's say add 50 to it
269:54 - so we can change these values if we are
269:56 - not
269:58 - satisfied
269:59 - okay then we can write cb2 dot font
270:02 - let's pick the plain one and then we
270:04 - will write the scale and the color
270:07 - so color let's put
270:10 - purple
270:12 - and then we will write the thickness
270:17 - so let's run that
270:20 - there you go
270:21 - so we are getting 88.87
270:24 - so that's good
270:26 - uh the x is bad
270:28 - so
270:29 - let's
270:30 - do
270:32 - we did minus right so minus
270:35 - 50 let's see
270:38 - yeah it's better now
270:40 - maybe let's convert this into blue
270:43 - that's more visible
270:47 - now
270:48 - the background is a little bit black
270:51 - so it's not that visible maybe red
270:54 - will be more visible or green
270:59 - yeah red is not bad so 88 degrees is
271:02 - what we are getting
271:04 - and sometimes what happens is that we
271:06 - get a negative value
271:08 - so for that case we can write here
271:13 - should we actually
271:14 - let's remove this
271:16 - and for those cases we can write if our
271:18 - angle
271:20 - is less than zero then we will say our
271:23 - angle we want to add 360 to it
271:26 - so 360 minus whatever the value will be
271:31 - so that will
271:32 - solve that problem
271:34 - so now what we can do is
271:37 - we can use any
271:39 - three points to find our angle so let's
271:42 - say i want for this is for the right one
271:45 - so we can say here right
271:48 - right
271:49 - arm let's say
271:51 - and then i can do the exact same thing
271:54 - with just one single line of code i can
271:57 - write here left arm
271:58 - and i will just change the values
272:02 - 11 13 and
272:05 - 15
272:06 - and now you will see it will do for both
272:08 - of them
272:09 - and that is pretty amazing
272:12 - so it is telling the angle for both of
272:14 - them at the same time
272:16 - so uh the last uh the the one that is
272:20 - hidden is not very clear so you cannot
272:22 - rely on that angle
272:24 - but the one that is here is quite good
272:27 - so
272:29 - we can remove this so now we can try
272:32 - this on our video so for the video as i
272:36 - mentioned we want to do it on the left
272:37 - arm rather than the right
272:40 - and by the way you can do it on the legs
272:42 - as well so it's up to you now which
272:45 - three points you want to take for
272:46 - example you can take 23 25 and 27 so it
272:50 - will tell you the angle between
272:52 - these two lines then you can use 24 26
272:55 - 28 it will tell you the angle between
272:57 - these
272:58 - so it is up to you which ones you want
273:01 - to use for your own
273:03 - project but for now we will use the left
273:05 - arm for the bicep curls
273:08 - so now we will remove this
273:12 - we will uncomment this and we will
273:13 - remove
273:14 - the image part
273:16 - and let's try to see if we get
273:20 - the angle there you go
273:21 - so now we are getting our angle
273:24 - and as you can see probably it's going
273:26 - to negative and all so that's why it's
273:29 - giving
273:30 - this value
273:32 - so what we can do is we can find the
273:34 - minimum and the maximum and based on
273:37 - that we can check if it has reached that
273:40 - point or not
273:42 - so let's try to figure out the minimum
273:44 - and maximum now the good thing is if you
273:46 - click on the window it will stop
273:49 - so
273:50 - we can check our values very easily so
273:54 - here you can see it's 338 but that's not
273:56 - the last one so here i saw 190 something
274:02 - yeah 180
274:05 - probably
274:07 - or let's say 200 yeah 200 is not bad
274:11 - or just to be on the safe side we can
274:13 - keep it a little bit higher like 220 or
274:16 - something like that so that
274:18 - it goes to zero easily
274:20 - and then
274:21 - over here we can see it goes to 300
274:24 - something
274:25 - so 340
274:26 - but again
274:28 - might not go always there
274:30 - so
274:33 - 3
274:34 - 30 maybe
274:37 - 20
274:39 - or 310 i can see it goes again and again
274:42 - to 328
274:45 - so it went to 340
274:48 - 340
274:50 - oh it's going to 40.
274:53 - now it's 28
274:55 - 27
274:58 - 29 okay so to be on the safe side we can
275:00 - we can say that it is um
275:03 - 20 right so or we can say 15.
275:06 - so what we can do is we can convert our
275:09 - range we want it from 0 to 100 we want
275:11 - to know how much curl uh we are at so
275:14 - the percentage of curls so at the zero
275:17 - point or at the 100 point
275:19 - so
275:20 - what we will do is we will create a
275:22 - percentage and we will say that
275:25 - did we import numpy yes so we will use
275:28 - numpy to convert our range so we will
275:31 - say numpy dot inter
275:34 - interp and then we will given our angle
275:39 - not range angle
275:42 - oh we didn't get it back that's why it's
275:44 - saying this angle is equals to so i
275:47 - think i forgot to
275:49 - return
275:50 - yeah so we need to return
275:53 - return angle
275:55 - so that will return our angle over here
275:58 - and then we can use this here angle is
276:01 - equals to
276:03 - what else do we need so we need the
276:06 - first range so our range will be let's
276:08 - say 210
276:10 - to 310 let's say
276:13 - and we want to convert it
276:15 - into 0 to 100 so this is already 100 so
276:20 - we can easily just subtract but if we
276:22 - had a difficult range you can use this
276:24 - method
276:27 - so
276:28 - that should be good so let's
276:31 - print out this value
276:33 - and we will print out the angle
276:36 - uh not the angle the percentage
276:40 - so or we can print the angle and the
276:42 - percentage that would be good to see
276:46 - are we printing anything
276:48 - here
276:51 - no
276:52 - okay that's good so we can run this
276:57 - so here we can see
277:01 - so it's zero going hundred percent then
277:03 - going back to zero
277:04 - then two hundred percent going to zero
277:07 - hundred
277:08 - zero excellent so now we can see that we
277:11 - are getting the correct values so
277:15 - we should not face any issues because we
277:18 - have taken quite safe values if you go
277:20 - too far you might not get good results
277:23 - you have to
277:25 - check the trade-off between accuracy and
277:28 - taking the risks of getting error
277:31 - okay so
277:33 - then we are going to check
277:35 - when are we reaching
277:37 - the
277:38 - the first curl when are we reaching the
277:40 - second we need to count so here we are
277:43 - going to go up and we are going to
277:45 - define two things the first one will be
277:48 - count which will be zero and the other
277:50 - one will be direction which will be zero
277:53 - now we will have two directions
277:55 - direction number zero and direction
277:56 - number one
277:58 - direction number zero will be when it is
278:00 - going up
278:01 - and direction number one will be when
278:03 - it's going down so we will consider a
278:06 - full curve only if it does both of these
278:09 - so it goes up and then it goes down to
278:12 - zero so from zero to hundred and hundred
278:15 - to zero so if we get that then we will
278:18 - consider it as first curve
278:20 - so
278:22 - we could do the other way around but i
278:24 - want to keep it
278:25 - like this where we have
278:28 - um
278:28 - the complete curl if we go back and
278:31 - forth the whole thing
278:32 - so we are going to write here
278:36 - that we want to check
278:39 - check
278:40 - for the
278:43 - dumbbell
278:44 - dumbbell curl
278:48 - girls
278:50 - okay
278:51 - so then we are going to write here that
278:54 - if our percentage
278:56 - is equals to 100
278:59 - and then we are going to check if our
279:02 - direction
279:05 - direction is equals to zero
279:08 - so this is the first direction it means
279:10 - we are going up now you might say why
279:12 - didn't you just write and here
279:14 - if percentage is hundred and if
279:17 - direction is zero i will tell you why
279:19 - later there's the reason
279:21 - so then we are going to say count
279:25 - plus equals 0.5 so we will add 0.5 to
279:30 - the count so
279:32 - if it's going up and it has reached 100
279:35 - it will be 0.5 and then it's going down
279:38 - and it reaches 0 then it will be 0.5 so
279:41 - that will be a complete curve
279:44 - so what i can do now is i can
279:47 - change the direction so direction is
279:49 - equals to 1
279:51 - and then i can check here
279:53 - that if my percentage is equals to 0
279:58 - and
279:58 - my direction
280:00 - is equals to
280:03 - one
280:04 - then i will write count is equals to
280:08 - plus is equals to 0.5
280:10 - so the same thing that we did earlier
280:12 - and then we will make the direction one
280:15 - uh no we will make the direction zero
280:18 - okay so this will
280:21 - keep adding to our count
280:23 - and this way we will know
280:25 - which direction we are moving and how
280:27 - many counts
280:28 - uh did we have so far
280:30 - so here we can remove this and we can
280:32 - simply print the count
280:36 - so we can write here print
280:39 - count
280:40 - and let's see what do we get
280:43 - so 0.5
280:45 - down 1.
280:46 - 1.5 down 2.
280:49 - 2.5 down 3
280:51 - 3.5 down 4.
280:54 - so excellent
280:55 - so if you
280:57 - um okay let's just display it first and
280:59 - then i can discuss
281:01 - so
281:02 - we can display it like this cv2 dot put
281:05 - text
281:06 - and we can write here image
281:08 - and we can write our string
281:12 - so we can write inside
281:14 - that
281:15 - integer so if you want to directly show
281:18 - the decimal places so if you want to
281:21 - show the 0.5 count as well
281:24 - then you can keep it like this so you
281:26 - can write simply count but i don't like
281:28 - that uh or let's try it now i will show
281:31 - you and then we will change it
281:33 - and then we will write here
281:38 - let's say 50 and 100
281:41 - and then we will write cb2 dot
281:45 - font
281:46 - let's put the plain one 15
281:49 - and then we will put 2 5 5
281:52 - 0 0 and then
281:55 - 25
281:56 - actually these are very big values we
281:58 - will put big values later on but for now
282:01 - we just want to see if we are getting
282:03 - the output properly
282:06 - okay so what is the problem
282:11 - it's not callable
282:23 - is that the issue
282:39 - oh okay i forgot to write
282:44 - comma
282:45 - okay so here we are getting 1.5 to
282:50 - 2.5 3
282:52 - 3.5 that is good so what i was saying is
282:55 - that if you don't want that you can
282:57 - simply write here
282:58 - int
282:59 - and then you can put it like that
283:02 - so if we see that now it's zero it
283:05 - becomes one
283:07 - two
283:10 - three
283:11 - so
283:12 - it's up to you which one do you prefer
283:15 - okay so now that we have this we can
283:19 - make it a little more appealing
283:21 - so
283:22 - what we can do is we can first of all
283:24 - add our
283:27 - fps
283:29 - so we didn't add that earlier so we can
283:31 - add it now so we can write here c time
283:34 - is equals to time
283:36 - time dot time
283:38 - and then we can write fbs is equals to
283:42 - 1 divided by current time minus the
283:46 - previous time and then we will write our
283:49 - previous time
283:50 - is equals to current time and then
283:54 - we will put the text
283:56 - so we can copy this
283:58 - and we can paste it here
284:00 - and then we can change it to fps
284:05 - so that should be good
284:08 - now
284:09 - we need to put
284:11 - previous time as zero
284:13 - over here
284:15 - okay so that will give us the time and
284:18 - we can comment this
284:21 - to check the fps
284:24 - so there you go so we are getting good
284:26 - fps now this video is 1080p and we are
284:29 - reducing the size of it
284:31 - and that's why it's giving a lower frame
284:33 - rate otherwise you will have a better
284:36 - frame rate if you
284:38 - uh because here we are resizing so if
284:39 - you directly use maybe this size or even
284:42 - lower you will get higher frame rate
284:45 - okay so then what we can do is we can
284:48 - put our
284:50 - what you call the number of count
284:53 - in a box
284:54 - so let's create a box
284:57 - so i have already checked the values of
284:59 - this box so i will directly input it so
285:03 - we will write here cv2.rectangle
285:06 - rectangle and we will put in our image
285:10 - and we will put in 0
285:12 - 450
285:14 - and then
285:16 - 250 and 720 so this is for a 1280 by 720
285:21 - which is hd image so it is for that
285:25 - so 255 and 0 and then cb2 dot
285:30 - filled
285:32 - so this will give us a green box
285:34 - and what we can do is we can
285:37 - uncomment this
285:39 - and we can
285:41 - format it
285:43 - and then here we need to change the
285:45 - value let's put it as 45
285:48 - and
285:49 - 670.
285:52 - let's run that there we go
285:54 - okay we need to change the size of this
285:56 - so 15
285:58 - and 25
286:01 - 25 okay
286:05 - so there you go so now we are getting
286:07 - this nice and big so we can see what is
286:09 - happening
286:10 - that is quite good and it is giving us
286:13 - the angle do we need the angle
286:16 - uh no i don't like the angle
286:19 - let's remove the angle from here
286:24 - so let's run it again
286:26 - there you go so now we are getting
286:27 - without the angle so it looks good
286:29 - now what else can we do okay let's put
286:32 - the bar so
286:36 - if you remember we did it in one of the
286:38 - other videos for the volume gesture
286:40 - control so you can check that out as
286:42 - well it was to control the volume of a
286:45 - computer using your hand gestures so we
286:48 - use the bar in that one as well so here
286:50 - we are going to use the bar again
286:53 - so
286:54 - for the bar first of all we need some
286:56 - values so we will write here bar
286:58 - is equals to
287:00 - np dot interp and we will convert our
287:04 - angle
287:06 - from the range of 220 to
287:08 - 300
287:10 - uh not 300 310
287:12 - and we will put it
287:14 - as 650 and 100 so this is the maximum
287:19 - value of our bar
287:20 - uh no the minimum value of our bar and
287:22 - this is the maximum value of our bar
287:25 - because the opencv convention is
287:27 - opposite so this is the minimum this is
287:29 - the maximum
287:32 - okay so why is not giving a space here
287:34 - okay
287:36 - so
287:37 - then we need to create that rectangle so
287:39 - here we can create that rectangle
287:42 - we will copy this because we are lazy
287:46 - we will copy twice and we will also put
287:49 - the text
287:51 - okay
287:52 - so now we need to change the values here
287:54 - so the starting will be 1100
287:58 - and then hundred
288:00 - then we have
288:02 - one one
288:04 - seven five and we have six fifty
288:08 - then
288:09 - we have
288:10 - uh what we call
288:12 - 1100 here
288:15 - and then we have our bar value so
288:19 - integer bar
288:21 - not bad bar
288:23 - and then we have eleven seven five and
288:27 - then six five zero
288:29 - so for the text we will have our
288:32 - percentage
288:34 - so we will make a string
288:37 - and we will write here
288:40 - integer and then we will write
288:43 - our percentage and at the end we will
288:45 - write percent
288:47 - so this we will display at
288:50 - eleven hundred and seventy five
288:55 - and the size will be four and four
289:01 - okay
289:02 - so
289:03 - we can write here that this is for our
289:06 - bar
289:10 - draw
289:11 - bar
289:12 - and let's say we write here
289:16 - uh
289:17 - show or let's try draw
289:21 - girl count
289:23 - okay
289:25 - so
289:26 - then let's try it out
289:28 - there you go
289:30 - but
289:31 - [Music]
289:32 - the bar value is not changing
289:37 - what did we do wrong
289:39 - oh
289:51 - so apparently the value of the bar is
289:54 - not changing because it is filled come
289:56 - on
289:57 - so this should be
290:00 - let's say three
290:02 - and let's try that
290:04 - yep
290:05 - so it goes down it goes up it goes down
290:08 - it goes up
290:10 - now
290:10 - one more thing we can do is
290:12 - when it reaches the zero or the maximum
290:15 - position we can change the color so that
290:18 - we know it's it's like
290:20 - when you reach a certain point and or
290:22 - you press a button it changes color so
290:24 - you can you kind of get a feedback so it
290:27 - looks good
290:28 - so that is the reason why we put an if
290:32 - within an if
290:34 - so here we are going to write
290:36 - color
290:38 - is equals to by default we are going to
290:40 - write the color as purple
290:45 - and if it reaches we are going to change
290:47 - the color
290:49 - as green
290:50 - so we will put the color
290:54 - as green
290:55 - so
290:56 - 2 5 5
290:58 - and 0.
291:02 - and the same thing we can do for our
291:06 - zero if you want to change the color for
291:07 - zero make it different than the other
291:10 - ones you can do that too but we are
291:12 - going to keep it like that
291:14 - so
291:16 - here we are going to
291:18 - write
291:21 - we are going to write here color
291:24 - and then here we are going to write
291:27 - color
291:28 - and
291:30 - here
291:31 - we are going to write color so all of
291:33 - them are same
291:37 - so now it's green purple
291:40 - purple green
291:41 - purple
291:42 - green
291:44 - green yeah
291:46 - so that's how you can tell
291:47 - if you have reached the correct point or
291:49 - not
291:52 - so as you can see it works very well
291:55 - and again if you want to use a webcam
291:57 - you can simply
291:59 - enter the value or the id number of your
292:02 - webcam and it should run pretty much the
292:04 - same way just make sure that your face
292:07 - is
292:07 - visible
292:09 - within the camera and
292:11 - you are at a good distance because a lot
292:14 - of this depends on the face as well so
292:17 - if you are not within the
292:19 - uh
292:20 - if your face is not in the camera it
292:22 - will not detect properly
292:25 - so that is pretty good
292:31 - so i i had a hard time finding uh these
292:34 - videos with
292:37 - bicep curls
292:39 - so
292:39 - that's why i just had this one
292:42 - but i will try to find some more
292:44 - but yeah so that is the idea the error
292:47 - is because the video ends that's why it
292:49 - gives this
292:50 - error it's not something that we
292:53 - made a mistake here
293:00 - hey everyone welcome to my channel in
293:02 - this video we are going to create a
293:04 - virtual painter using ai we will first
293:08 - track our hand and get its landmarks and
293:11 - then use the points to draw on the
293:13 - screen we will use two fingers for
293:15 - selection and one finger for drawing and
293:18 - the best part is that all of this will
293:20 - be done in real time
293:22 - so the first thing we will do here is to
293:24 - go to canva.com
293:26 - and if you're not familiar with canva it
293:28 - is basically a design tool it's an
293:30 - online website
293:31 - that helps you create all these
293:33 - different designs for brochures business
293:36 - cards flyers whatever you want you can
293:39 - basically design here
293:41 - so this is a free website so you can go
293:43 - and
293:44 - start you can start by just signing up
293:47 - so here we have a canvas of 1280x720
293:51 - so we are expecting our webcam to be of
293:53 - this size that's why we are using this
293:56 - size so the idea here is that we are
293:59 - going to create a design to actually
294:02 - make it look more appealing and make it
294:05 - look more like a software so this is up
294:07 - to you if you want to skip this step you
294:09 - can do that too
294:11 - there will be files to download from my
294:13 - website the ones that i already did
294:16 - so if you want to skip you can go ahead
294:18 - and do that too
294:20 - but here we are going to start off with
294:22 - a
294:23 - rectangle
294:26 - and what we will do is
294:28 - we can we can put it on the side
294:31 - but the issue with the side is that it
294:34 - will be hard to select different
294:36 - elements so what we will do is we will
294:38 - put the menu on the top
294:41 - so our menu will be here at the top
294:44 - now for the width let's keep it at 100
294:49 - 100 is too small maybe 120
294:55 - 125
294:57 - yeah that looks good
294:59 - so then we can lock this
295:02 - or let's change the color first
295:05 - so i like this blue
295:07 - or maybe this one
295:09 - yeah this one looks better
295:11 - so let's lock this so it doesn't move
295:13 - around
295:14 - then we are going to add
295:17 - let's add the logo first so i'm going to
295:19 - go to photos and
295:22 - right here logo
295:24 - uh no it's in upload
295:27 - my bad
295:39 - so i have my logo here i'm going to
295:41 - place it on the side
295:43 - and
295:45 - yeah that looks about right
295:47 - then we are going to add
295:49 - some brushes
295:51 - so here we will go to the elements and
295:54 - we will search for brushes
295:56 - so
295:57 - let's write here brush
296:02 - uh
296:02 - okay so these are strokes
296:07 - we are not getting actual brushes
296:10 - here we have
296:12 - let's write paint brush maybe
296:17 - yeah i think now we have better results
296:20 - uh i want to look for something that is
296:23 - free this is free
296:25 - okay
296:26 - so
296:28 - maybe something else that is free this
296:30 - is free as well
296:32 - so i'm looking for something free so
296:34 - that everyone can use it
296:37 - not just the pro users
296:41 - um
296:41 - [Music]
296:45 - maybe this one no it's pro
296:48 - this one is free too do we have a color
296:50 - of i think this one is the best
296:53 - okay let's keep it this way
296:55 - and if we want to we can change it later
296:57 - on
296:58 - so
296:59 - let's take this part
297:01 - right about here
297:03 - and we will zoom in
297:05 - and
297:07 - maybe a little bit smaller
297:11 - there you go so i think that looks good
297:14 - now the good thing is that most probably
297:16 - this is an svg file so we can change the
297:19 - color for it
297:20 - so let's say we want
297:23 - pink
297:23 - what is that purple
297:26 - let's try pink
297:28 - and what we can do is we can have
297:30 - another one
297:31 - that is a little bit bigger than this
297:34 - at its back
297:36 - so that will indicate that this has been
297:39 - clicked
297:41 - so we can put it okay let's change the
297:43 - color first we can put it as white
297:46 - or gray
297:49 - or dark gray
297:51 - let's put it at the back
297:57 - i think white will be better
298:00 - okay i'm no designer i'm just
298:04 - eyeballing this
298:05 - so
298:06 - i'm gonna put it as whites
298:09 - yeah okay so then what we can do is we
298:12 - can copy both of these
298:15 - and we can paste them here
298:18 - so
298:20 - somewhere in the middle
298:22 - and we can paste another one
298:25 - and then we need
298:29 - an eraser so we don't need the last one
298:32 - actually the one at the back
298:36 - or do we okay let's keep it
298:38 - let's keep it for now
298:40 - i will tell you why later on okay so now
298:43 - we need an eraser
298:45 - so let's write here eraser
298:50 - okay this one is pro pro pro
298:53 - this one is free
298:58 - no not really
299:04 - all of these are paid
299:11 - oh this one is free
299:16 - yeah i think that could work
299:19 - so
299:20 - let's put that
299:22 - a little bit bigger
299:26 - i think i'm putting it too big
299:27 - anyways you can change the design later
299:29 - on
299:30 - uh we are learning the concept here
299:34 - uh or let's just make it a little bit
299:37 - smaller
299:43 - so
299:44 - i think that will be better
299:49 - so we can
299:50 - grab these two and we can place them
299:53 - here
299:54 - this one
299:56 - in the middle
299:58 - this one a little bit further
300:02 - okay i think that is better and then we
300:04 - can make this
300:06 - a little bit smaller
300:08 - and there you go so i think that looks
300:10 - good
300:11 - now what we can do okay these are not at
300:13 - the top to put it at the top here
300:25 - okay
300:26 - so now what we will do is we will change
300:28 - the color for these
300:30 - so the first one is let's say pink the
300:33 - second one let's say is
300:36 - blue
300:37 - or dark blue
300:40 - in between maybe this looks weird
300:43 - okay let's keep this as blue and then
300:46 - the last one let's keep it as green
300:48 - so these are the let's say three colors
300:50 - that we want and then what we will do is
300:55 - we will
300:56 - this doesn't seem right i think at the
300:58 - back
301:00 - needs to go higher maybe
301:04 - yeah maybe like this
301:06 - okay i'm going to copy this
301:09 - and we will paste it here
301:20 - so we'll put it at
301:22 - back
301:24 - and the same thing to the last one
301:37 - okay so you can move it around with your
301:40 - keys
301:41 - your arrow
301:42 - keys so
301:45 - maybe a little bit higher
301:48 - again you can spend a lot of time on
301:50 - this but we are going to skip that
301:53 - we will not put a lot of effort here
301:57 - just for a demonstration purpose but you
301:59 - can of course go ahead and try a lot of
302:01 - different things
302:03 - so um
302:04 - now what we will do is we will copy all
302:06 - of these we will duplicate them
302:09 - so here you can see
302:11 - or let's change the size first so we
302:13 - already know that our size is 1280 by
302:19 - 125 so we will go to resize
302:22 - and we will change this to
302:25 - 125
302:26 - and we will copy and resize or you can
302:29 - resize is up to you i'm going to press
302:31 - resize so it will do it on the same one
302:34 - then i can unlock this
302:36 - and i can grab all of this and i will
302:39 - scale it up
302:40 - so it should fit perfectly
302:43 - because it is the same size
302:46 - there you go so this is the image that
302:48 - we need so we are going to copy this
302:51 - four times
302:53 - because we will have a selection for
302:55 - each one of these so we can delete
302:59 - the selection for this
303:01 - and the selection for this
303:04 - and this is the first one so first one
303:07 - this is the one selected the second one
303:08 - this is selected and for the third one
303:12 - we will have this one selected
303:15 - and the fourth one we will have the
303:18 - rubber selected
303:19 - so here we are going to
303:23 - it is whites
303:25 - let's
303:26 - change this to
303:28 - let's change this one to the same color
303:30 - as this
303:32 - and
303:34 - let's make it a little darker
303:37 - like let's make all of them darker
303:39 - so
303:41 - yeah and then let's make this
303:44 - it's a black
303:47 - that's too much
303:52 - okay i think that is enough indication
303:54 - so we just need an indication that that
303:56 - has been pressed
303:58 - so that should be fine so now what we
304:01 - can do is we can download all these four
304:04 - images and the idea here is that
304:06 - whenever we detect a click we are going
304:09 - to uh change these images so we will see
304:12 - which one do we need so if we have
304:15 - clicked the first one then we will
304:17 - change the image to this if the second
304:19 - one is clicked we will change the image
304:20 - to this then the third one and the
304:22 - fourth one which is the eraser
304:25 - so at any given point
304:27 - only one of them can be selected
304:29 - so that's the idea so we can go and we
304:31 - can write here
304:33 - that this is our virtual painter let's
304:36 - say
304:39 - and we can download
304:41 - all of these
304:42 - in jpg or png whatever format you want
304:46 - let's do it jpg and we can download all
304:49 - of these
304:52 - so here i am in the pycharm project now
304:55 - this is the same project that we have
304:57 - been using for the hand tracking for the
304:59 - finger counter for the hand uh what he
305:02 - called volume control so we have done
305:04 - quite a bit of projects earlier than
305:05 - this
305:06 - so
305:07 - this is the exact same uh what do you
305:09 - call project
305:11 - and you can go to file settings
305:15 - and you can see that we have already
305:17 - installed our media pipe and we have
305:20 - already installed opencv but if you are
305:23 - new you can go to the add button you can
305:26 - write here opencv dash python
305:30 - and you can install this and then you
305:32 - can go to mediapipe
305:35 - mediapipe is the google library that we
305:37 - will be using for hand tracking so you
305:39 - can download and install this
305:42 - so this is the main idea
305:44 - now what we will do is first of all we
305:46 - will right click this and we will open
305:48 - it up in the explorer
305:53 - now once we are in our project we are
305:55 - going to create a new folder
305:58 - and we are going to call it
306:03 - header
306:04 - so we will have our header images in
306:06 - here so these are our images that we
306:09 - downloaded
306:10 - so i will copy all of this and i will
306:12 - paste them here
306:15 - and now you can see that these are our
306:17 - header files so we have a total of four
306:20 - header files
306:23 - so when we go back to our pycharm
306:25 - project you will see that we have a new
306:27 - folder by the name header and we are
306:29 - going to use that for our images
306:32 - so then we are going to right click and
306:34 - we will create a new python file and we
306:37 - will call this
306:38 - virtual
306:40 - painter
306:44 - so now we are going to import our
306:46 - libraries so we will write here import
306:48 - cv2 import
306:50 - numpy as np
306:53 - and then we will need imports time if we
306:56 - want to show the frame rate
306:58 - and then we will also need imports os
307:03 - because we need to access these files so
307:06 - we will need that
307:07 - what else we also need our hand module
307:10 - so we will write here
307:13 - import hand tracking module
307:16 - as
307:17 - htm
307:19 - so this will be our hand tracking module
307:22 - now if you are not familiar with this if
307:24 - you haven't watched the previous uh
307:26 - tutorial then make sure you go ahead and
307:29 - look at that because
307:30 - this is the tutorial in which we went
307:33 - step by step and we created this hand
307:36 - tracking module so this is very
307:38 - important this basically tracks the hand
307:41 - so if i run this you will see
307:44 - if i right click here
307:47 - this should open up my webcam
307:52 - and if i bring in my hand you can see it
307:54 - tracks the hand so this is the idea of
307:57 - the hand tracking module and based on
307:59 - these values we are going to
308:02 - do some painting
308:04 - okay
308:05 - so
308:06 - now first of all we are going to import
308:09 - our images so that is the first thing we
308:12 - are going to do we will write here
308:14 - that our folder path
308:17 - is equals to
308:19 - header
308:21 - so these are the header images and we
308:24 - are going to say that my list is equals
308:27 - to os dot list directory
308:30 - list directory and then we will get the
308:34 - name of all our folder
308:37 - uh path files
308:39 - so this is the idea if we print this out
308:42 - if we print my list you will see that
308:46 - we get all these
308:49 - uh images name
308:51 - so here you can see one dot jpg two
308:54 - three and four
308:55 - so what we have to do is we have to
308:56 - import them so that we can use them
308:58 - later on to overlay on the top
309:01 - so here we are going to write for
309:04 - image path
309:06 - in my list
309:08 - my list
309:10 - we are going to loop and we are going to
309:12 - import so we will see that our image
309:16 - is equals to cv2 dot im read
309:19 - and we are going to read
309:22 - from a string and that will be
309:25 - the folder path
309:27 - slash
309:29 - the
309:31 - folder
309:32 - the image path
309:34 - so this will be
309:36 - our complete path that we need to read
309:38 - from
309:39 - and then we are going to store it in a
309:41 - list
309:42 - so
309:43 - let's call this list overlay
309:47 - list so this will have all the images
309:50 - that we want to overlay
309:52 - so we will write here overlay dot append
309:56 - and we want to append our
309:58 - image
310:00 - okay so this will overlay
310:03 - our images
310:05 - uh no it will import all our images now
310:07 - what we can do is we can print the
310:09 - length of our
310:12 - overlay
310:13 - list so we can see that whether we have
310:15 - imported all of them correctly or not
310:18 - so
310:19 - let's run that
310:22 - we have imported indeed four
310:24 - so that is good so far
310:26 - and next what can we do next
310:30 - next we can run our webcam
310:33 - and then once we have our webcam we can
310:35 - simply overlay one of these images by
310:37 - default so we can call our image let's
310:40 - say header
310:42 - and we are going to give it an initial
310:45 - value we will say that over list at zero
310:48 - so now this is our image
310:50 - so whenever we get our original image we
310:53 - are going to overlay this
310:55 - on top of that
310:56 - okay so this is good for now
311:00 - what we can do next is we can create our
311:02 - loop and we can run our webcam so here
311:06 - we are going to write cap is equals to
311:09 - cv2 dot video capture
311:12 - video capture and we will say that
311:15 - device number one now you should write
311:17 - device number zero
311:19 - because i have multiple cameras i'm
311:21 - using one
311:22 - then i will write cap dot set now this
311:25 - is important because we want the exact
311:28 - same size we want one two eight zero by
311:31 - seven twenty so we have to make sure
311:33 - that the width and the height are
311:35 - exactly the same so we are going to
311:37 - write one two eight zero by seven twenty
311:40 - then we are going to write here while
311:44 - true we want to run our webcam
311:48 - and we want to get our images so we will
311:51 - write here that the success and the
311:54 - image is equals to
311:56 - cap dot read
311:59 - and then we are going to
312:02 - um okay let's just display it first so
312:05 - cb2 dot weight key
312:08 - is one and we have cv2 dot i am show
312:12 - i will say image and image
312:16 - so
312:17 - that should be enough so let's run it
312:24 - we have an error
312:30 - oh i wrote i am read no no no
312:32 - i am show
312:35 - what happened there
312:41 - okay so there you go so this is our
312:43 - image and you can see my hand
312:46 - so what we will do
312:49 - we are going to
312:51 - overlay our image now so how can we do
312:54 - that
312:55 - so we can simply write
312:58 - that our image
313:00 - so you might think it's a little bit
313:01 - difficult but it's not it's very easy
313:04 - because our image is a matrix we just
313:06 - need to define
313:07 - where is the location of this new image
313:10 - so we will slice it
313:12 - so here we are going to say that our
313:14 - height is from 0 to 125 because we know
313:18 - that the image size is 125
313:21 - and then the width we are going to say
313:23 - is from 0
313:25 - to 1 2 8 0.
313:27 - so
313:28 - at this region we are going to say
313:31 - our image is equals to header
313:35 - and that's how simple it is
313:36 - so if we run this
313:43 - there you go so now you can see that we
313:45 - have our image and on top of that we
313:48 - have overlaid our first image now this
313:52 - is good because by default we want our
313:55 - first uh paint brush selected which is
313:59 - the pink one
314:00 - so
314:01 - we are already up to a good start so
314:04 - here we can write
314:06 - that we are
314:09 - setting the
314:10 - header
314:12 - image setting
314:15 - the header image okay
314:17 - so this is good and now we can just
314:19 - separate this because we are going to
314:20 - write our code over here
314:23 - so what else can we do
314:26 - now the next step is
314:28 - in before we go into the details of the
314:32 - project let's split it up into pieces so
314:35 - first of all we will import the image
314:39 - okay so that's the first step
314:41 - we have pretty much already done that
314:44 - uh there is another thing we need to do
314:46 - i will tell you later
314:49 - this is the first step let's write it
314:50 - here
314:51 - one
314:53 - then the second step
314:56 - is that
314:58 - we want to find the landmarks so find
315:02 - hand
315:03 - landmarks so this can be easily done
315:06 - with our hand tracking module so that
315:10 - should not be an issue
315:11 - then number three
315:13 - is basically
315:15 - checking which fingers are up
315:17 - so check
315:19 - which
315:21 - fingers
315:22 - are up
315:23 - now this is because we want to draw when
315:26 - one finger is up which is the index
315:28 - finger
315:29 - and we want to select only
315:32 - when two fingers are up
315:34 - this will allow us to easily move around
315:37 - the canvas without painting so when our
315:39 - two fingers are up it will not draw
315:41 - anything if we want to draw we have to
315:43 - put one finger up
315:45 - the index finger
315:47 - so this will allow us to easily navigate
315:50 - through the canvas
315:52 - then we have the selection mode so we
315:55 - will check here at the fourth stage
315:58 - we will say
315:59 - if selection mode
316:02 - which is when two fingers are up
316:07 - two
316:09 - fingers
316:10 - are up then we have to
316:14 - what do you call
316:16 - we have to select not draw
316:18 - then in the fifth one we have to check
316:21 - if
316:22 - we have the drawing
316:24 - mode mode when
316:28 - index
316:29 - finger
316:31 - is up
316:32 - so this is the idea
316:35 - now let's go on to the next parts
316:39 - actually do we have a next part
316:42 - no so this is pretty much it we have
316:44 - five different steps we are going to go
316:46 - step by step and see how we can achieve
316:49 - each one of these
316:50 - so the first thing is that for importing
316:53 - image it is pretty much done
316:55 - the only thing we have to do is we have
316:57 - to flip the image so we are going to
316:58 - flip horizontally
317:00 - this is because when you are drawing
317:03 - if you want to draw on the right side
317:06 - then when you move to the left it will
317:08 - draw on the right so
317:10 - to flip the image we are going to
317:12 - right here flip
317:14 - and we will write image
317:16 - and we want to flip in the first
317:19 - selection now this will allow us to
317:22 - solve that problem
317:24 - so let's try that
317:30 - so now the image is flipped so if i go
317:33 - on the right side it's going to the
317:34 - right if i go on the left it's going to
317:36 - the left so it will be easier to draw
317:39 - because it will be more intuitive now
317:41 - the second step here is to find the
317:42 - landmarks now the landmarks we can find
317:45 - but we need to import first
317:48 - so we are going to write here that our
317:50 - detector
317:52 - is equals to
317:54 - hand tracking module dots
317:56 - hand detector
317:58 - and then we are going to give in uh
318:00 - detection confidence so this is up to us
318:03 - what value do we want to use but we are
318:06 - going to keep a high confidence
318:08 - because
318:10 - we want it to be
318:12 - uh good in painting we don't want
318:15 - a lot of mistakes here and there so by
318:18 - default it's 0.5 we have changed it to
318:20 - 0.85
318:24 - then over here we are going to say that
318:27 - our image is equals to
318:30 - detector dot
318:32 - find hands
318:35 - and we are going to send in our image
318:38 - so this will draw on our image and it
318:40 - will
318:41 - uh detect the hand so let's try that
318:48 - there you go so now we can see it's
318:51 - detecting properly so that is good
318:56 - the next step is to get all the landmark
318:59 - positions so we are going to write here
319:01 - landmark list is equals to detector dot
319:05 - find position
319:07 - and we will write image
319:08 - and we do not want to draw so draw is
319:11 - equals to false
319:14 - and then we can check
319:17 - if the length
319:19 - of our landmark list is not equals to
319:23 - zero
319:25 - not equals to zero
319:27 - then we are going to do something let's
319:29 - print the lm list
319:34 - so let's try that
319:41 - so let's see if it prints
319:44 - there you go so it's printing the
319:45 - landmarks if i move around
319:47 - if i go out of the image it does not
319:49 - print anything if i come back in it
319:52 - prints
319:53 - the
319:54 - what do you call landmarks so that is
319:57 - good
319:58 - so now that we have this
320:01 - we need to know the
320:04 - the tip points of our index finger and
320:07 - the middle finger
320:08 - so what we will do is we will
320:12 - call the
320:14 - index finger tip as x1 and y1 so we will
320:17 - say x1
320:18 - and y1
320:20 - is equals to lm list
320:23 - at point number eight so this is the
320:25 - landmark eight
320:28 - so here you can see this is the landmark
320:30 - eight
320:31 - and we have the value of 729 and 396 for
320:34 - example in this case so this is the tip
320:37 - of our index finger
320:39 - so here i can write
320:43 - tip
320:45 - tip of index and
320:48 - middle
320:49 - finger
320:50 - zoom
320:51 - okay so then uh
320:54 - as you can see it is basically the
320:57 - first and the second element
320:59 - not the zero one so here we have to
321:02 - write
321:03 - from one till the end so we will write
321:06 - it like this so it will grab only these
321:08 - two
321:10 - so we are unpacking them here so x1 and
321:13 - y1 so we will do the same thing here for
321:16 - the middle finger
321:19 - and for the middle finger we will write
321:20 - x2 and y2
321:23 - and the number for middle finger is 12
321:26 - so that should be
321:28 - good
321:32 - so
321:33 - now that we have our landmarks
321:36 - and everything is good
321:38 - now we need to check which finger is up
321:42 - so
321:43 - this thing we did in our one of our
321:45 - previous videos
321:47 - and that was
321:50 - i believe in the finger counting project
321:53 - so if you remember here if we go back
321:55 - here
321:57 - so here is the code
321:59 - that when it is thumb it will check
322:02 - if it is up or down
322:04 - then it will check the rest of the four
322:06 - fingers if they are up or down
322:09 - so and then it will give us the total
322:12 - finger count and it will also give us
322:14 - the list where is the list yeah the
322:17 - fingers is basically the list which will
322:20 - tell us which of these are up and which
322:22 - of these are down
322:23 - so what we can do is we can pretty much
322:26 - copy paste this part
322:28 - and we can create
322:30 - a method in our hand tracking module so
322:33 - earlier we did not do it as a method in
322:36 - our class but this time around because
322:38 - we are using it again and again it is
322:41 - better to create a class rather than
322:42 - putting it in
322:44 - different projects every time
322:47 - so this is our hand tracking module we
322:49 - are going to open that up and you can
322:51 - see right now we have only two methods
322:53 - find hands and we have find position
322:57 - so next we are going to put another
322:59 - method and that will be called fingers
323:02 - up
323:03 - so we will write here
323:06 - def
323:07 - fingers
323:09 - up
323:10 - so that will tell us which of the
323:12 - fingers are up
323:14 - so we will go to our finger counter
323:16 - project
323:17 - and from here we can copy
323:20 - so we have
323:22 - from fingers
323:24 - till
323:25 - this part i think that should be enough
323:27 - so we will copy that
323:30 - and here we are going to paste it
323:33 - so what we are doing is we are first
323:35 - creating a list called fingers
323:37 - and then we are basically checking
323:41 - if the tip
323:43 - of our
323:44 - thumb
323:45 - is on the right or on the left
323:48 - so that will tell us if it's open or
323:50 - closed and then for the fingers we are
323:52 - checking if the tip of the finger
323:54 - is above
323:56 - uh the other landmark which is two steps
324:00 - below it or it is not so if it is below
324:03 - that then it means it is closed if it's
324:05 - above that it means it is open so it is
324:08 - storing the value of 1 when it is open
324:11 - it is storing the value of 0 when it is
324:13 - closed
324:14 - but why are these errors over here
324:17 - these errors are here because it does
324:20 - not recognize tip ids
324:23 - and tip ids was something that we
324:25 - declared
324:26 - over here so this is the list so we can
324:29 - copy that
324:30 - and in our module because we know that
324:33 - it will not going to change the tip
324:36 - numbers the tip ids they are not going
324:38 - to change we are going to write it in
324:40 - our initialization so we will write here
324:42 - self
324:44 - dot
324:45 - tip ids is equals to this
324:47 - so now if we go back and instead of just
324:51 - using tips
324:52 - we use self.tips it should work
324:57 - so we will do that and there you go
325:01 - so that works but now the lm list it
325:03 - doesn't uh recognize it because
325:06 - we did not define it as a self
325:09 - as an instance so we need to write here
325:11 - self dot lm list
325:13 - and i can copy that self again
325:17 - and we can paste it here
325:20 - we can paste it here
325:22 - so we can paste it here we can paste it
325:25 - here and here and here
325:28 - so what happened now was that not only
325:32 - we are returning this lm list when we
325:34 - find the positions
325:36 - we are also storing it so that if we
325:38 - want it
325:40 - in our other functions or our other
325:42 - methods we can use it as well so we do
325:44 - not need to send it out and then receive
325:46 - it back again internally it is available
325:49 - for us to use
325:51 - okay so that should be good and if we
325:54 - just return these fingers up it should
325:56 - give us if the fingers are up or not
325:59 - which of them are up or not
326:01 - so we can just return the
326:03 - fingers
326:06 - and if we go back to our let's close the
326:08 - finger counter if we go to our virtual
326:11 - painter
326:12 - here we are going to ask
326:15 - we will say that
326:17 - detector
326:19 - dot fingers up
326:22 - fingers up
326:24 - and
326:25 - do we need to send something in
326:29 - no not really so that is good we don't
326:32 - need to send anything and we can simply
326:34 - receive the values
326:37 - in the variable or the list fingers
326:41 - so
326:42 - let's print that out so fingers
326:45 - and let's remove the previous prints
326:52 - so
326:52 - let's run this and see what happens
327:00 - so something is out oh it needs to be
327:02 - inside this my bad
327:09 - okay so this is our image
327:12 - i will bring in my hand
327:15 - oh nothing is happening
327:17 - why is that okay
327:19 - so it takes a little bit uh to detect
327:22 - now you can see uh how many fingers are
327:26 - there
327:27 - uh okay the issue is i will tell you
327:30 - what the issue is
327:32 - for the thumb it's showing one when it
327:34 - is open when it is
327:37 - closed and 0 when it's open
327:40 - because we are not checking the left and
327:42 - right
327:43 - so this is an issue that needs to be
327:45 - solved more precisely but for now we'll
327:48 - just
327:49 - change this what was it before it was
327:52 - greater than
327:54 - less than
327:55 - so by writing less than it will solve
327:57 - the issue for now but later on we do
327:59 - have to fix this so i'm not going to fix
328:02 - it now for this one but
328:04 - in this case you can only use your right
328:06 - hand to draw so if you use your left
328:09 - hand it will be an issue
328:11 - actually it won't be an issue because we
328:13 - are not using the thumb at all but it
328:15 - will give you wrong values so here you
328:17 - can see the thumb
328:19 - you can see two of them
328:21 - then three then four
328:23 - so you can see all of these fingers they
328:25 - are being detected properly so now if i
328:27 - do this i should be able to select
328:30 - any of these and then if i do if i do
328:34 - this i should be able to draw so this is
328:36 - the main idea
328:38 - so we need to check
328:41 - uh now we know that which fingers are up
328:44 - now we need to check if it's selection
328:46 - mode or it is drawing mode so how can we
328:48 - do that that is very simple
328:51 - let me bring that in because i will
328:53 - forget again
328:56 - okay so now we need to check
328:58 - if
329:00 - uh the second oh no the first elements
329:04 - so we have fingers
329:07 - at first
329:09 - and fingers at second
329:12 - if both of them are up
329:14 - this means if both of them are true
329:17 - then it means it is selection mode so we
329:19 - will print here
329:21 - say selection
329:25 - mode
329:28 - and if that is not the case
329:31 - we will write here
329:35 - then we will write here that this is
329:37 - equals to false
329:41 - we only have the index finger up then we
329:43 - will say
329:45 - drawing
329:46 - mode
329:48 - so this is the idea
329:50 - now what we do after that is a different
329:51 - story but for now we just want to check
329:54 - if it is able to understand this or not
329:57 - so let's try that
330:02 - we should remove the previous
330:04 - print let's remove that
330:07 - let's run this
330:14 - so this is selection mode because two
330:17 - fingers are up
330:18 - and now it's drawing mode so now it's
330:20 - working very well
330:22 - we can see
330:24 - when it is so when it is nothing it
330:26 - doesn't do anything
330:27 - when
330:29 - for detection you have to make sure
330:32 - a lot of the image or a lot of the hand
330:34 - is available in the image
330:36 - so yeah so this is drawing mode we can
330:38 - draw this is the selection mode and
330:40 - everything is good so far
330:43 - okay so the next step what we can do is
330:48 - we can uh change or we can draw
330:51 - some circle around it
330:53 - so here if it is selection mode
330:57 - let's draw a rectangle so we are going
330:59 - to write here cv2
331:02 - dot rectangle
331:04 - and we are going to write their image
331:06 - and then we are going to write
331:09 - that we want
331:11 - from x1
331:12 - to y1
331:14 - minus
331:16 - let's say 15 we want to go
331:18 - above
331:19 - because we are creating uh let's say a
331:22 - rectangle using two points so we don't
331:25 - want to just give those points we want
331:26 - to
331:27 - make it a little bit higher and a little
331:29 - bit lower
331:30 - so
331:31 - then we are going to use
331:34 - x2 and y2 and this time we will make it
331:38 - plus 15.
331:40 - so then we will give it a color so let's
331:43 - say 255 0 255 this is purple and then we
331:48 - will say cb2 dot fill
331:52 - now we are drawing a rectangle here
331:54 - because we are going to draw a circle
331:57 - when it is time to draw
331:59 - so for the circle
332:00 - we are simply going to write here
332:04 - cb2 dot
332:06 - circle
332:07 - and we are going to give in our image
332:09 - and we are going to draw from x1 and y1
332:12 - so we will write here
332:14 - x1 and y1
332:17 - and then we are going to say 15
332:20 - and the draw color again 2 5 5
332:23 - 0 2 5 5
332:25 - and then we are going to write cb2 dot
332:28 - filled
332:31 - so this will be a visual indication of
332:33 - when we are in selection mode and when
332:35 - we are in drawing mode so
332:38 - for selection it will be rectangle for
332:40 - drawing it will be circle
332:42 - so let's try that out so here it is
332:45 - rectangle
332:46 - and then if we do this it becomes circle
332:52 - so here the detection is not that good
332:54 - but still
332:56 - you can see
332:59 - the rectangle is very small
333:01 - 15 is not a good value
333:03 - let's make it
333:06 - 25
333:08 - and 25.
333:18 - yeah now it is better so here i can say
333:21 - it is selection mode
333:23 - and here i can say it is drawing mode
333:26 - so it will be easy for us to detect so
333:29 - my hand should be really back and then i
333:32 - should be able to draw easily but
333:34 - because i'm near to the computer so it's
333:36 - a little bit difficult to do it this way
333:39 - but it should work fine
333:41 - so far we have done well
333:44 - okay so we have the selection mode now
333:46 - and we have the drawing mode so let's
333:48 - work with the selection mode first
333:51 - what we have to do now is we have to
333:52 - check
333:53 - if we are at the top of the image
333:57 - now if we are at the top of the image we
333:59 - are going to change our
334:01 - uh image or selection mode based on the
334:05 - location so first of all we will check
334:08 - if
334:09 - y1
334:11 - is less than
334:13 - 125
334:14 - so this was the value
334:16 - of our header so if we are in the header
334:20 - then we are going to do something
334:23 - so we will say that
334:25 - if
334:26 - our value is between 250
334:31 - if our x1 is between 250 and 450
334:35 - then it means it is clicking the first
334:37 - one so here let me just write it here
334:42 - checking for the click
334:44 - so that is what we are doing here
334:46 - so we will write here that if this is
334:48 - the case then our header
334:51 - is equals to
334:53 - overlay list at zero
334:56 - so that's the first one so by default it
334:59 - is the first one because
335:01 - we are using it here
335:03 - the value of header is already
335:06 - where is it
335:08 - yeah it's already the first one
335:12 - then we are going to copy this
335:15 - and we are going to paste it down here
335:19 - and we will write that else if
335:23 - else if the value is between 550
335:27 - and 750 so these values i have checked
335:29 - before
335:30 - so
335:31 - if it's not the same we can change a
335:34 - little bit
335:35 - so then it is 750 then it should be
335:39 - overlay list one
335:43 - and then we are going to copy this we
335:46 - will paste it here
335:48 - and then one more time so we have a
335:50 - total of four
335:52 - so here it will be 800
335:56 - to 950 and this will be
335:59 - 1200
336:02 - and one zero five zero
336:06 - so this will be
336:07 - two and this will be
336:09 - three
336:12 - okay so
336:13 - let's try that out so if we move around
336:16 - we should be able to select
336:19 - so if i go up you can see it selects if
336:23 - i go here it selects if i go here it's
336:25 - an x
336:27 - so wherever i go it selects the correct
336:29 - one
336:31 - and the visual indicator is quite nice
336:34 - so it tells us which one did we select
336:37 - and if i go with one finger
336:40 - it's not going to do it
336:41 - because this is the drawing mode
336:44 - in the selection mode we can select
336:47 - okay so that is the difference here
336:50 - so now we are able to select properly so
336:52 - that is quite good
336:54 - next we are going to
336:56 - change the color so whenever we select
337:00 - something we want to
337:02 - indicate that the color has changed so
337:05 - here for example for the drawing circle
337:07 - or even for the rectangle we want to
337:10 - change the color for it so what we will
337:12 - do is
337:13 - we will declare a color we will
337:16 - go up here
337:18 - and over here we are going to say now
337:20 - the first image is for purple so if we
337:23 - go to the header and we see the first
337:25 - image it is for purple
337:27 - or you can say pink
337:29 - whatever color you want to
337:31 - anyways so we are going to say that by
337:33 - default
337:34 - our draw color
337:37 - color is equals to
337:39 - purple
337:42 - so whenever
337:44 - the value is selected another value is
337:46 - selected we are going to change this
337:48 - draw color
337:49 - so and we will use it to actually draw
337:52 - so instead of putting a random color for
337:55 - the rectangle and for the circle this is
337:58 - the color that we are going to draw
338:00 - and let's draw it after we have
338:03 - uh checked for the click
338:06 - okay we will put it here is it in the if
338:09 - no it should be here
338:11 - okay
338:12 - so
338:13 - what can we do now
338:15 - is that we can change this color
338:17 - individually
338:18 - so here we will say that draw color
338:21 - is equals to
338:22 - for this case it should be purple so it
338:25 - should be two five five zero two five
338:26 - five
338:28 - and for the second one
338:30 - it is blue
338:31 - so it is
338:33 - b g r
338:35 - so this should be on and this should be
338:38 - off
338:40 - and then
338:42 - we have green so b g r so this should be
338:46 - 0 this should be 2 5 5
338:49 - and this should be zero
338:51 - and then for the eraser we will just
338:54 - make it black
338:55 - so black will erase everything so we
338:58 - will make it zero zero zero two five
339:00 - five two five five two five five is one
339:02 - and zero zero zero is black
339:06 - so let's run that
339:12 - let's try this
339:14 - so here our color is purple
339:17 - and both of them are purple we go to
339:19 - selection mode and now it's changed to
339:21 - blue
339:22 - you can see for both of them it's
339:23 - changed to blue we go to green and now
339:26 - you can see it's changed to green
339:28 - right so and if we go to the eraser it's
339:31 - changed to black so we can erase it for
339:34 - the black actually
339:35 - we can make an exception for the black
339:37 - because
339:38 - for erasing normally the tool is quite
339:41 - bigger
339:43 - but again we will discuss that later so
339:45 - now this is done so the selection mode
339:48 - is done we are able to select our color
339:52 - and it changes the color that is perfect
339:54 - now what we need to do is we need to
339:56 - draw
339:57 - so we already know when we are in
339:59 - drawing mode
340:01 - we now need to draw based on our points
340:05 - okay
340:06 - so now the easiest method and this is
340:08 - one that i have been using before as
340:10 - well because it is very simple whenever
340:14 - you are learning a new concept you
340:16 - should go with the simple thing rather
340:18 - than the most advanced or complicated
340:20 - one
340:20 - so earlier what i did was i created
340:23 - using
340:24 - uh simple points
340:26 - so
340:27 - whenever you have a point you just draw
340:30 - that single
340:31 - circle and then whenever you move the
340:33 - finger you draw the circle there as well
340:36 - but the issue with that is whenever you
340:38 - have a rapid movement it will not draw
340:41 - continuously as a line
340:43 - it will have some gaps so that is not a
340:46 - good way to draw so what we will do now
340:49 - is instead of drawing just a circle we
340:51 - are going to draw lines
340:53 - but the issue with lines is that we need
340:56 - a starting point and we need an ending
340:58 - point
340:59 - so here
341:00 - whatever current position we are in we
341:02 - just have that single point
341:04 - so we need to know the previous point as
341:07 - well once we know those both points then
341:09 - we can simply draw a line
341:12 - so
341:13 - let's draw that
341:15 - so here we are going to write
341:17 - that
341:18 - our cv2 dot line
341:21 - and we are going to draw on our image
341:27 - and where exactly do we want to draw
341:30 - we are going to draw at our x previous
341:32 - position
341:33 - and x y previous position
341:36 - and then the new position
341:39 - which is x1
341:41 - and y1
341:44 - then we are going to say which color do
341:46 - we want to draw it with
341:48 - we are going to say
341:50 - the draw color
341:55 - and then we are going to give in the
341:57 - thickness so here we can declare a
342:00 - variable we can say it
342:02 - we can say that it is brush
342:04 - thickness
342:05 - and if we want to change it we can
342:07 - change it from the top here so here
342:10 - we can create our variables
342:17 - and we can write here that let's say our
342:18 - brush thickness is
342:20 - 15.
342:22 - so
342:23 - we can easily change it up
342:26 - and now we have the x and the y previous
342:31 - so we will go up here
342:33 - and we will declare that the x previous
342:35 - and the y previous
342:37 - are 0 and 0
342:42 - and then we will go down here
342:45 - now the issue here is that at the very
342:47 - first iteration at the very first frame
342:50 - we will not have any xp and
342:53 - yp we will have the value of 0 0 so it
342:56 - will draw a line from 0 0 to whatever
342:59 - the point you are at and that will look
343:01 - really bad so this should not be the
343:03 - case so how can we fix it
343:06 - we can fix it by writing here that if
343:09 - our xp
343:11 - our xp is equals to 0
343:14 - and our yb
343:16 - is equals to zero it means it is the
343:18 - very first frame that we have detected
343:21 - the hand or we are starting to draw
343:24 - then we are going to say that xp
343:26 - and yp is equals to x1 and y1
343:31 - so instead of putting 0 0 we are saying
343:34 - whatever value it you are at draw
343:36 - exactly at the same point so instead of
343:38 - drawing a line it will just draw a point
343:41 - so the very first
343:43 - time we
343:44 - see our finger it will just draw a point
343:47 - instead of a line
343:48 - after that it will keep drawing as a
343:50 - line so whenever we have the new points
343:53 - we are going to say that our xp and yp
343:57 - is equals to our x1 and y1 so these are
344:01 - our previous points so it will keep
344:04 - updating those
344:06 - so hopefully that was clear
344:09 - now
344:10 - let's try to run it and see if it draws
344:18 - so here
344:20 - if i do this
344:23 - it is drawing
344:25 - but it is
344:27 - removing at the same time
344:28 - so as you can see
344:30 - it is drawing something but it is
344:32 - removing
344:33 - if i go really fast then you can see it
344:35 - is drawing
344:36 - so this means
344:38 - that our image is updating every
344:40 - iteration so we cannot draw on our
344:44 - actual image
344:45 - so if we want to do that we will have to
344:48 - uh do something else i will tell you
344:50 - what that something is later on
344:52 - but for now we need to create a new
344:54 - canvas on which we can draw
344:57 - so what we will do is we will go up here
345:00 - and at the very top we are going to
345:02 - create a new image
345:04 - and we are going to call it
345:07 - image
345:08 - canvas
345:10 - and this will be the canvas on which we
345:12 - will draw so we are using numpy to draw
345:15 - our canvas and we will use the zeros
345:17 - method
345:18 - and the size is 720
345:21 - by 1280 they use heights
345:24 - before the width so we are writing it
345:26 - like this and it has three channels
345:28 - because we want colors and it is
345:31 - unsigned
345:32 - uh unsigned integer of 8 bits which
345:35 - means it will have 0 to 255 values
345:38 - so that is pretty much it
345:41 - and now instead of drawing
345:43 - on our original image we are going to
345:45 - draw on the canvas
345:47 - so where did it go here so we will copy
345:50 - this
345:51 - and we'll paste it here
345:53 - and we will say image canvas
345:56 - and we will
345:58 - show the image canvas as well
346:06 - canvas okay so let's try that
346:10 - so now we should have two images so this
346:12 - is the image canvas
346:13 - and this is the original image i will
346:15 - keep this at the top
346:17 - and if i if i bring in my hand and if i
346:20 - draw
346:21 - now you can see it draws
346:24 - and that is very
346:26 - very satisfactory
346:28 - okay
346:29 - so
346:30 - this is the idea but now the thing is
346:32 - it's not drawing here which is fine
346:35 - if you want to you can draw there as
346:36 - well and i will show you how to do that
346:38 - but before we go there let's try out
346:41 - different colors
346:43 - so that we know that it is working well
346:50 - so i will keep this in the front
346:53 - but it will be hard to see
346:56 - okay let's try to put it here on the
346:58 - side
347:01 - and i will try to
347:05 - run that okay so this is a selection
347:07 - mode i will select blue
347:10 - and now i will draw with blue
347:12 - then we have the
347:14 - uh
347:15 - green mode
347:16 - the selection mode and then i will draw
347:18 - with green
347:20 - now
347:21 - i want to show you something else if i
347:23 - don't put this part
347:26 - if i don't put the fist frame condition
347:28 - what it will do is it will draw a line
347:31 - from the very start so if i bring it
347:34 - here
347:38 - uh okay this is very annoying uh we need
347:40 - to fix this first
347:43 - okay let's say i am uh
347:46 - here is my hand
347:48 - and then i start drawing there you go so
347:51 - did you see it started from the zero
347:53 - zero point and it drew all the way to
347:56 - the current point
347:58 - so whenever you have
348:00 - uh the new points
348:02 - let's say i go to the blue one and i
348:04 - select that
348:06 - you will see that
348:07 - okay
348:08 - not now but
348:10 - in the previous one you saw that
348:12 - whenever you
348:13 - have the first first frame then it will
348:17 - create this problem
348:20 - so we are going to open that up so that
348:22 - we don't have this issue okay next we
348:24 - can also try the uh erasing parts
348:28 - so the black one should erase whatever
348:30 - we have drawn earlier
348:33 - but what we can do is we can make it a
348:35 - little bit bigger because if it is
348:36 - bigger it is easier to erase
348:39 - so let's first select
348:42 - so let's draw
348:46 - and now i will go to the eraser
348:48 - and i will
348:51 - come here and you can see it is erasing
348:54 - but this is not very good because it's
348:56 - very small
348:57 - so what we can do is we can have a
348:59 - special condition for the erasing
349:02 - so we can write here
349:04 - that if the draw color
349:08 - is equals to 0 0 0
349:12 - then we will have the size different
349:18 - so here we will copy this part
349:21 - uh actually we will copy both of these
349:25 - and here we are going to write
349:27 - that instead of the brush thickness it
349:29 - is the eraser thickness so we will write
349:31 - here eraser
349:33 - and we will also write here that this is
349:36 - eraser thickness
349:37 - so we will go up
349:39 - and here we are going to write eraser
349:43 - thickness
349:44 - is equals to let's say 50. so it will be
349:48 - easier to erase
349:50 - and here we can simply write
349:54 - else
349:55 - we do this
349:57 - so that should be good so if we have the
350:00 - eraser tool now
350:05 - so
350:08 - let's draw
350:11 - now let's go to the eraser tool
350:13 - and
350:15 - it's a little bit hard for me because
350:16 - i'm sitting very next
350:18 - to the webcam
350:20 - and there you go so i can erase now very
350:23 - easily
350:24 - and all of this will get very very nice
350:27 - and very very good looking
350:29 - once we do it on the original image the
350:31 - only thing is that we have two images
350:33 - now and it is very hard to see what is
350:35 - happening
350:36 - so now all we need to do is we need to
350:39 - put it on the original image so we need
350:41 - to draw on the original image
350:43 - so how can we do that we cannot draw on
350:45 - the original image because it refreshes
350:48 - every time
350:49 - so instead of doing that we are going to
350:51 - add our two images
350:53 - so what we can do is we can go down here
350:57 - so here what we can do is we can write
350:59 - here that
351:01 - image
351:02 - is equals to cv2 dot
351:05 - uh
351:07 - add weighted
351:08 - and then we have to give in our image
351:10 - the first image and then we give in the
351:13 - value 0.5 let's say and then we give in
351:17 - the second image which is image canvas
351:19 - and then we given the value let's say
351:21 - 0.5
351:23 - so this will add these two images and it
351:25 - will blend them
351:28 - so
351:29 - let's try that out
351:32 - oh there is a
351:33 - argument missing
351:41 - there you go
351:43 - so if i draw you can see now it is
351:47 - drawing
351:48 - again i need to go back a little bit
351:51 - okay so now you can see it is drawing
351:55 - when the hand is really at the back like
351:57 - this it will draw well but because i'm
351:59 - very close to the pc and the camera it
352:02 - is hard for me to do this i can go back
352:04 - a little bit and there you go
352:08 - but the issue here is that this does not
352:10 - look very good i can change these values
352:12 - but still it will be a blend it will not
352:15 - be an actual uh merging of the images it
352:18 - the colors will not be that bright there
352:20 - will be a transparency on it
352:22 - so if you don't want that what can you
352:24 - do
352:26 - now it is a little bit complicated but
352:28 - if you break it down it is very simple
352:32 - so what we will do is we will write here
352:36 - uh let's where is the statement
352:40 - right here okay so we need to go here
352:43 - and we will write here
352:45 - first of all we are going to create a
352:48 - gray image so we will write here image
352:50 - gray
352:51 - is equals to cv2 dot
352:53 - cvt color
352:55 - and we are going to say that image
352:57 - canvas
352:59 - and
353:00 - cv2 dot
353:03 - color underscore
353:07 - bgr
353:08 - to gray
353:09 - tr
353:11 - to
353:12 - gray
353:13 - so we are converting it into gray image
353:16 - you might be wondering wait why are we
353:18 - converting it to gray image i will
353:20 - explain in a bit
353:22 - then we are going to convert it
353:25 - uh into a binary image
353:29 - then we will write here
353:32 - image inverse
353:34 - is equals to
353:35 - now we are creating we are converting
353:37 - this into a binary image and we are also
353:40 - inversing it what does that mean i will
353:42 - explain as well cv2 dot
353:46 - threshold
353:47 - and image gray
353:50 - and we are going to write
353:52 - 50 and 255
353:55 - and then cv2 dot threshold
353:59 - binary inverse
354:02 - so the idea basically is that we want
354:07 - let me actually run it so you can see
354:09 - better
354:12 - so let's say i draw something
354:16 - let's say i drew this
354:18 - and now i have this image
354:20 - so
354:21 - what i want to do i want to convert this
354:23 - image
354:24 - into black and white
354:26 - so wherever
354:28 - i have black
354:30 - i want it to be white
354:32 - and wherever i have this colored image i
354:36 - want it to be black
354:37 - so what this will do is
354:40 - it will create a mask with all this
354:42 - white
354:43 - and only this region as black
354:47 - and then
354:48 - i will go to this image and in this
354:51 - image i will make all of this black
354:55 - and then i will merge
354:57 - this image with
354:59 - this
355:00 - previous image
355:01 - with the black area so it will overlay
355:04 - these two
355:05 - so i know it sounds a little bit
355:08 - complicated but you will see how it
355:10 - works so we first of all we are creating
355:13 - that inverse image so that all that
355:15 - region where we drew
355:17 - uh it is black
355:19 - then we are going to
355:22 - write here that our image inverse
355:25 - is equal to cv2 dot
355:27 - cvt color and we are going to write that
355:30 - our image inverse
355:32 - is basically cv2 dot
355:35 - color
355:37 - color
355:38 - underscore gray to
355:41 - bgr now we are converting it back
355:43 - because we want to add it to our
355:45 - original image so we cannot add it if
355:47 - they are not the same dimension you
355:49 - cannot add a gray image to a
355:52 - colored image so we need to make sure
355:53 - both of them have three dimensions
355:57 - then we are going to do
355:59 - image is equals to cv2 dot
356:02 - bitwise and
356:04 - and we are going to add our original
356:06 - image with the inverse image
356:10 - image inverse
356:12 - and then we are going to add our image
356:14 - is equals to cv2 dot bitwise
356:18 - or
356:21 - and then we are going to write image and
356:23 - image canvas
356:25 - so again this might be a little bit
356:27 - confusing but let's see the results and
356:29 - i will go step by step and explain it as
356:31 - well
356:40 - so now here you can see i can draw
356:43 - oh it went down here you can see i can
356:46 - draw easily
356:48 - it's not updating this value it seems
356:51 - yeah
356:53 - okay it's not updating the value
356:55 - okay so
356:57 - this is drawing on the canvas now which
356:59 - is good
357:01 - but actually on the original image but
357:03 - the issue is that it's drawing this
357:05 - straight line whenever it is detecting
357:07 - again
357:08 - so what is happening is
357:10 - that whenever the hand is detected we
357:13 - should put
357:15 - this x p and y p as zero
357:18 - so we will copy this part
357:20 - and whenever the hand is detected
357:23 - then we will make it zero
357:27 - actually no whenever the hand is
357:29 - detected no no no
357:31 - whenever we start drawing again so yeah
357:35 - whenever we start drawing again
357:39 - or whenever we have a selection
357:43 - whenever we have a selection then we are
357:45 - going to do
357:47 - that
357:52 - okay let's try that
358:03 - yeah
358:05 - now it's starting from the right
358:06 - position instead of a random position
358:11 - there you go so that is good
358:13 - so let me explain what is happening at
358:16 - the back
358:17 - so first of all we have our gray image
358:20 - and then we are converting it into an
358:22 - image inverse
358:23 - so let me display that image inverse
358:37 - so this is our inverse image so wherever
358:40 - i draw something it is going to draw but
358:43 - with black area
358:45 - so let's try that
358:47 - so as you can see it will draw with that
358:49 - black area
358:51 - right so that is the idea
358:56 - then the next step is that we add these
358:59 - images
359:00 - so we are adding
359:02 - with and we are adding the image inverse
359:05 - and the image
359:07 - so let me show you how that looks like
359:11 - so i will remove this part
359:16 - and we will run it
359:22 - we will see here
359:24 - that when we draw
359:29 - you will see that
359:30 - now it is showing us black region
359:33 - wherever we drew
359:36 - so all we have to do now is we have to
359:38 - add this image
359:40 - to this image
359:42 - so when we add this because here we have
359:44 - colored part here it's black here we
359:47 - have colored part and here it's black so
359:49 - if we do an or operation between these
359:52 - two
359:53 - it will give us our final image so here
359:55 - we were doing an and operation with the
359:57 - original image and the image inverse
359:59 - here we will do an or operation to add
360:02 - these two up
360:10 - and there you go
360:11 - so now it's moving around and the
360:13 - flickering you can improve
360:16 - if you have a better detection if you
360:18 - don't have a lot of noise
360:19 - so again uh it cannot be completely
360:22 - uncontrolled environment yeah the
360:24 - environment should be a little bit
360:25 - controlled to have some good results so
360:28 - if i go back
360:36 - you can see i can draw a few things and
360:38 - then if i go to the eraser
360:40 - if i go to the eraser and i select
360:44 - the eraser it will rub quite a bit
360:50 - again my conditions are not very well
360:52 - but you can get the idea
360:56 - and if i want to increase the size of
360:58 - the brush or the paint or whatever i can
361:01 - change it from here i can make this 100
361:03 - for the eraser thickness
361:05 - and
361:06 - it will erase better
361:09 - so here
361:11 - if i draw
361:12 - something and then i can do this
361:17 - and i can go to the eraser and then i
361:20 - can
361:21 - erase
361:22 - you can see how that's
361:24 - how simple that is
361:31 - hey everyone welcome to my channel in
361:34 - this video we are going to create an ai
361:36 - based mouse controller we will first
361:39 - detect the hand landmarks and then track
361:41 - and click based on these points
361:44 - we will also apply some smoothing
361:46 - techniques to make it more usable
361:49 - so here we are in our pycharm project
361:51 - and we have created it by the name ai
361:54 - virtual mouse
361:56 - so
361:58 - what we have here is the hand tracking
362:00 - module now if you have not been
362:02 - following we have written this module
362:04 - from scratch
362:05 - so
362:06 - from the very beginning from the very
362:09 - first project we have
362:11 - added a lot of different methods to this
362:14 - particular
362:15 - class so now the thing is that
362:18 - in our previous project we added the
362:21 - fingers up
362:22 - method and the fine distance method and
362:24 - this will allow us to very easily create
362:28 - this new project so we will have a look
362:30 - at that how we can do that and this file
362:32 - of course will be available online on my
362:34 - website so a lot of you ask how do you
362:37 - access the
362:39 - code on the website you have to log in
362:41 - and you have to enroll to get access and
362:44 - of course it is free just enroll and you
362:46 - will get the access
362:49 - now
362:50 - if you have not been following you have
362:52 - to go to file
362:54 - settings and you have to go to the
362:56 - interpreter
362:58 - and you have to add the open cv
363:01 - open cv python
363:03 - and we have to install it and then we
363:06 - also have to install media pipe
363:09 - through which we will get all this hand
363:12 - tracking functionality
363:13 - so media pipe
363:17 - and we are going to hit install
363:21 - okay so now both of these are installed
363:23 - and we can hit ok
363:25 - so the first thing we will do we will go
363:28 - and create a new python file and we will
363:31 - call it
363:33 - ai
363:35 - virtual
363:36 - mouse
363:37 - project
363:40 - okay so what we will do is we will first
363:44 - import cv2
363:46 - then we are going to import numpy
363:49 - as np and then we will import
363:53 - our
363:54 - module which is
363:56 - hand
363:57 - hand tracking module as htm
364:00 - and then we are going to imports
364:04 - import time
364:06 - now apart from all of this that we have
364:09 - been doing earlier as well
364:11 - what we will do is we will also add a
364:13 - new library which will allow us to move
364:16 - around with our mouse
364:18 - so with the python script we will be
364:20 - able to move our mouse we will be able
364:22 - to click on it there are a lot of these
364:25 - that you can use the one we are going to
364:27 - use is called auto pi
364:30 - so we are going to hit install on that
364:35 - so an error occurred so
364:37 - let me check
364:40 - again if we can install it
364:58 - okay
364:59 - so he was giving an error earlier but
365:01 - then i clicked on it again and it
365:03 - installed fine
365:05 - so we can close this and we can go back
365:08 - and now we can also import
365:11 - auto pi
365:13 - okay so
365:14 - the first thing we will do is we will
365:16 - run our webcam to see everything is
365:18 - working so we will write here
365:20 - cap is equals to cv2 dot video capture
365:24 - and we are going to write that our video
365:27 - id is one now you will use zero if you
365:30 - have one camera i have multiple so i'm
365:32 - using one
365:34 - now the second thing is that we have to
365:36 - have a fixed width and height so we
365:39 - cannot leave it to the default of the
365:41 - camera so we need to change our width
365:44 - and height so we will write here cap dot
365:46 - set
365:46 - and the
365:49 - prop id for width is three
365:54 - then the prop id for height is 4
365:57 - so we will make it 480.
366:00 - so that's how you can define the word
366:02 - and height
366:03 - actually
366:05 - what we can do is
366:06 - we can put them in variables because we
366:09 - need to use them later on as well
366:11 - so let's declare our variables over here
366:15 - so we are going to write here
366:18 - that our width of the cam and the height
366:21 - of the cam is equals to
366:23 - 640 by
366:25 - 480
366:28 - and we can just input these values here
366:32 - so this is the height of the cam
366:34 - and then we can simply go let's remove
366:37 - this and then we can simply go and write
366:39 - while
366:41 - true
366:42 - we are going to say success
366:45 - and image is equals to cap dot read
366:49 - and we are going to get our frame value
366:52 - so once we have this frame value
366:56 - then we are going to say cb2 dot im show
366:59 - and we will say that our image and then
367:02 - i
367:03 - mg and then cb2.weight key and one so
367:08 - this is pretty much
367:09 - that we have been doing in all our
367:11 - projects
367:13 - so let's run this and see if it works
367:18 - there you go so now you can see my
367:19 - webcam and there is my hand
367:22 - so that is all good
367:25 - so next what we can do is we can add our
367:27 - detector for the hand tracking but
367:30 - actually let's discuss what are the
367:32 - steps that we are going to take today to
367:34 - create this project so the first step
367:37 - will be
367:38 - uh let's put some numbering as well so
367:41 - it is easier to remember so the first
367:43 - step will be to find the hand landmarks
367:48 - so that will be the first step
367:50 - then the second step will be to get the
367:53 - tip of the
367:54 - index and the middle finger so the idea
367:56 - is that if we have just the index finger
367:59 - then the mouse will move if we have the
368:03 - middle finger up as well then it will be
368:06 - in
368:07 - clicking mode so if it is in clicking
368:09 - mode and if the distance between the two
368:12 - fingers is
368:13 - less than a certain value then we will
368:15 - detect it as a click so you can bring
368:17 - your fingers together and it will click
368:19 - so in that mode we are not going to move
368:22 - the mouse but in the index mode where we
368:25 - are moving
368:26 - uh that is the only
368:28 - mode in which we will move
368:30 - so
368:31 - what we can do here
368:33 - is that our second
368:35 - what do you call
368:37 - our second step will be to get the tip
368:43 - tip of the index
368:45 - and middle
368:47 - fingers
368:48 - so once we have the tip of the index and
368:52 - middle finger what we will do is we will
368:54 - check which of these fingers are up
368:57 - so we will write here number three
369:00 - check
369:01 - which
369:03 - fingers are up
369:06 - then in the fourth step
369:08 - based on this information
369:10 - we will check if it is in moving mode so
369:12 - we will write here
369:14 - only
369:16 - index finger
369:18 - which means
369:20 - it is in moving mode
369:23 - so we will move our mouse
369:25 - and if it is in moving mode
369:28 - then we are going to
369:31 - then we are going to convert our
369:33 - coordinates
369:35 - the units
369:37 - now why do we need to convert
369:39 - because our webcam will give us a value
369:42 - of let's say 640 to 480.
369:46 - so for my screen i have a full hd which
369:49 - means 920 by 1080
369:52 - so we need to convert these coordinates
369:55 - so that we get the correct positioning
370:01 - okay so then
370:04 - okay it's bringing it back
370:06 - we can change that later then we will
370:09 - add another step to actually smooth in
370:11 - the values
370:13 - so why do we need to do that so that it
370:15 - is not very uh jittery it doesn't
370:18 - flicker a lot
370:19 - so we will write here smoothen
370:23 - values
370:24 - so we will smoothen these values and
370:27 - once that is done we can simply move our
370:30 - mouse so move mouse
370:34 - okay so this might seem a lot but it
370:37 - these steps are very easy some of them
370:39 - are single lines some of them just two
370:40 - lines so don't worry about these
370:43 - then number eight will be to
370:46 - check if we are in clicking mode so when
370:49 - both
370:51 - index and middle
370:53 - fingers are up
370:56 - then it is
370:58 - clicking mode
371:00 - so once it is clicking mode we will find
371:04 - the distance between these fingers
371:07 - so we will find
371:09 - distance
371:11 - this tends
371:13 - between
371:15 - fingers
371:17 - and if the finger is
371:19 - if the distance is short then we are
371:22 - going to click
371:23 - so we will write here click mouse
371:26 - if
371:27 - distance
371:29 - short
371:31 - so these are the 10 steps we have to
371:34 - follow and the 11th and 12th step is
371:37 - fairly easy
371:38 - so the 11th step
371:40 - is the frame rate to see if we are
371:43 - getting a decent amount of frame rate
371:45 - and the 12th step is to display
371:50 - so we have already done this
371:53 - display thing
371:54 - so we do not need to do anything more in
371:57 - that now what we can do is we can go on
371:59 - to the frame rate the frame rate is very
372:01 - simple as well we have done this quite a
372:04 - lot of times
372:05 - by now so
372:06 - we will simply write time.time
372:09 - and then we are going to write fps
372:13 - is equals to 1 divided by c time which
372:17 - is the current time minus the previous
372:19 - time
372:22 - and then we will write that the previous
372:24 - time
372:25 - is equals to the current time
372:28 - and then we will write cb2 dot put text
372:32 - image then our string
372:35 - which will we will first convert it into
372:38 - integer and then we will write our fps
372:42 - and then we are going to write the
372:44 - position
372:45 - so we will write 10 and let's say 50
372:48 - or let's say 20 and 50
372:51 - then we will write cv2
372:54 - dot font
372:56 - cv2 dot font
373:01 - plane and then let's say for the
373:03 - thickness or this is the scale let's put
373:05 - it as three
373:07 - and then we have okay we need to go back
373:11 - then we have
373:12 - the color two five five
373:15 - uh let's keep it blue
373:18 - yeah
373:20 - and then we will write three
373:22 - this is the thickness
373:24 - so if we run this
373:26 - we should have here p time
373:30 - p times equals to zero
373:33 - so if we run this
373:36 - we should have our frame rate
373:39 - there we go
373:42 - so that is quite good
373:46 - okay
373:47 - so
373:48 - next we have the frame rate we have the
373:51 - display now we are going to do the
373:52 - actual part of all of these steps so
373:56 - first of all we have to get the
373:57 - landmarks to get the landmarks we have
373:59 - to declare here the detector we have to
374:02 - create the object so detector
374:06 - is equals to
374:08 - hdm
374:10 - dot hand detector
374:12 - and inside that do we need to add
374:15 - something we can add for example the
374:17 - maximum hands
374:18 - because we are only expecting one hand
374:21 - so we can write here one
374:23 - and the rest we can keep same
374:27 - then
374:27 - here we are going to go down and we are
374:30 - going to write
374:31 - that our image
374:34 - image is equals to detector dot
374:37 - find hands
374:40 - not fingers up find hands find
374:44 - hands
374:45 - and then we are going to
374:48 - uh find the positions of these hands so
374:52 - we are going to write here lm list
374:54 - and the bounding box so this is
374:56 - something that we added in our previous
374:58 - project
374:59 - and we will write here detector detector
375:03 - dot
375:05 - uh find position i think the spellings
375:09 - detector
375:10 - find position
375:12 - and then we will write image so we are
375:15 - sending in our image
375:17 - and that should
375:18 - detect it and it should also draw
375:21 - so let's run this and see if it detects
375:26 - we have an issue
375:28 - uh finance oh we have to give the
375:31 - argument of image my bad
375:35 - okay so there you go so now we are
375:37 - detecting our bounding box and we are
375:39 - detecting
375:40 - the fingers and the landmarks as well so
375:44 - that is pretty good so we are done with
375:46 - step number one and now
375:48 - we will check
375:51 - that if
375:53 - if our length of our lm list
375:58 - is not equals to zero then we are going
376:01 - to
376:03 - get the tip info
376:05 - so
376:06 - we can actually put this up
376:08 - here so here we will write x1 and y1 so
376:13 - these are the points of the index finger
376:15 - so we are going to write lm list
376:17 - and we will write that it is point
376:19 - number eight
376:21 - and we want
376:22 - from we want the element number one and
376:25 - two
376:26 - so we will write it like this
376:28 - uh the same thing we will do for our
376:32 - second
376:33 - finger which is the middle finger we
376:34 - will write x2 and y2 and here instead of
376:38 - 8 we will write 12. so this will give us
376:40 - the coordinates
376:43 - of our index and middle fingers
376:45 - so we do not need to draw these at this
376:48 - point
376:49 - so we can just print them out if you
376:51 - want to see
376:52 - we can print x1
376:55 - y1 and then x2 and y2
376:59 - so we can print those
377:03 - and we are getting an
377:04 - error
377:06 - x1 y1
377:09 - not enough values to unpack
377:11 - expect it to got one
377:14 - why is that
377:19 - lm list
377:22 - let me check here what is the issue
377:31 - this is find position yeah
377:35 - and this is lm list and bounding box yes
377:40 - so that should be fine
377:43 - okay let's print out the lm list first
377:48 - print
377:49 - lm list
377:52 - let's check that
377:59 - yeah we are getting some values and they
378:01 - seem fine
378:04 - uh
378:08 - oh okay my bad
378:10 - should be one
378:12 - one
378:13 - and colin
378:17 - okay there you go so now we are getting
378:19 - the points
378:28 - there you go so now we are getting all
378:30 - these points
378:31 - so for the index finger and the middle
378:33 - finger
378:34 - we move them around you can see
378:37 - the values they change
378:39 - okay so this is good
378:41 - we are done with our second parts
378:44 - now we will go on to the third part
378:47 - check which fingers are up now this is
378:49 - extremely simple because we have already
378:51 - created a method by the name fingers up
378:54 - all we have to do is we have to call it
378:56 - we will write here
378:59 - detector
379:00 - dot
379:02 - find
379:03 - uh not find fingers up and we will store
379:06 - it in fingers
379:09 - so we can push this in
379:15 - and let's print out so print
379:19 - fingers
379:20 - and we will
379:21 - remove the print from here
379:23 - so let's run that
379:29 - so there you go so all the fingers are
379:31 - up all of them are closed
379:34 - one
379:35 - two three four and five
379:37 - so we are getting these values so that
379:39 - is pretty good
379:41 - now let's go to the next step which is
379:43 - okay let me push those all of these in
379:47 - okay so step number four is only index
379:50 - finger moving mode so now we need to
379:53 - check
379:54 - if only the index finger is up so we
379:57 - will write here
379:59 - if
380:01 - if fingers
380:03 - at
380:04 - 1
380:05 - which is the index finger
380:07 - is equals to
380:08 - one
380:09 - and fingers
380:12 - at two
380:14 - is equals to zero
380:16 - so this is when the index finger is up
380:18 - and the middle finger is down
380:20 - so this will be moving mode so now we
380:22 - need to move our finger
380:26 - uh now we need to
380:28 - check where our finger is moving so we
380:30 - get those points and we send it to the
380:32 - mouse
380:33 - coordinates
380:34 - okay
380:35 - so first of all what we will do is we
380:38 - will write here
380:39 - that we need to convert
380:41 - so here we are converting our
380:43 - coordinates so we will write here that
380:46 - x3
380:47 - is equals to we will write np dot interp
380:52 - we are going to convert one range to
380:54 - another range
380:55 - so here we are converting the x one
380:58 - value
380:59 - and the initial range is basically from
381:02 - zero
381:04 - to the width of our webcam
381:08 - and then the second range
381:11 - is from 0
381:13 - to
381:14 - the width of the screen but we didn't
381:17 - get the width of the screen
381:19 - now i know that my screen is this size
381:21 - but it could be different for yours so
381:24 - in order to get the exact value what we
381:26 - will do is we will go up here
381:28 - and we will write here that our width of
381:31 - the screen
381:33 - and the height of the screen is equals
381:36 - to
381:37 - auto pi dot screen
381:40 - dot size
381:42 - so this will give us the size of the
381:43 - screen so if we remove the print from
381:46 - here
381:47 - and if we remove this
381:50 - statement and all of this
381:53 - uh yeah so then we can print this
381:56 - print
381:58 - w screen and
382:00 - height screen
382:02 - okay let's run this
382:05 - and there you go so now you can see it's
382:07 - telling me it's 9 to 1920 by
382:10 - 1080 so this is the idea now that we
382:13 - have these values
382:14 - let's comment this
382:16 - now that we have these values we'll go
382:19 - back here
382:21 - and
382:25 - we are going to continue
382:28 - that
382:29 - it is from 0 to the width
382:32 - of the screen
382:34 - so the same thing we will do with the
382:36 - height we will copy this and we will
382:38 - write here y3
382:40 - and then we will write here y1
382:43 - and then we will write here height
382:46 - and then height
382:48 - so this is the idea
382:51 - so these are the points that now we have
382:54 - converted and now we will send this
382:56 - value to the mouse we will smoothen
382:59 - these values but we will do that later
383:01 - on first we need to see what is the
383:03 - original
383:04 - result and then we can convert it
383:06 - so here we are going to write auto pi
383:09 - dot move mouse
383:11 - dot move
383:13 - and then we are going to write
383:16 - that
383:16 - our x3
383:18 - and our y3 are our coordinates
383:24 - so let's try this
383:26 - and see what happens
383:30 - so you can see my mouse here
383:33 - if i bring in my hand and this is my
383:35 - index finger and now you can see it is
383:36 - moving but the problem is when i'm going
383:39 - to the right it's going to the left
383:42 - so this is very annoying
383:44 - and it is very
383:46 - it's not intuitive
383:47 - so what we will do is we will flip it
383:50 - in order to flip it we just need to flip
383:52 - the width so what we will say is we will
383:54 - say that whatever the width of the
383:56 - screen is
383:58 - screen is minus this
384:01 - so now if i go to the right it should go
384:03 - to the right
384:04 - so the image here will be
384:06 - flipped but in reality i'm moving to the
384:09 - right and the mouse is also moving to
384:11 - the right now if i move to the left the
384:13 - mouse is also moving to the left
384:16 - so this should be easier to work with
384:19 - so that is good
384:22 - uh what we can do
384:24 - is we can draw a circle
384:26 - so that we know that we are what you
384:29 - call moving the mouse so here we can
384:31 - write cv2 dot circle
384:34 - and we will write image
384:36 - and then we are going to write x1 and y1
384:40 - so we want to draw on that
384:42 - and let's say 15 is the radius and the
384:45 - color is purple
384:48 - and then we will write cb2 dot build cv2
384:53 - dot filled
384:57 - there we go
384:58 - so let's run that
385:03 - yeah so now whenever we are in moving
385:05 - mode
385:06 - then it will show us this big circle so
385:10 - that we know that we are in moving mode
385:13 - okay
385:14 - so this is good
385:17 - so now one of the issues here is that
385:21 - when i am moving
385:23 - when i'm moving
385:25 - i can go up very easily
385:27 - it's not that bad
385:28 - uh it flickers at the top
385:30 - much more than in the center but i can
385:32 - go there but if i want to go down it's
385:35 - very hard because the hand is not
385:37 - detected properly
385:40 - again if i move down you can see it's
385:43 - not detecting property and i'm unable to
385:45 - go down
385:46 - so what we can do is we can set a region
385:49 - where we want to detect the movement
385:52 - instead of the whole
385:53 - image size we can set a particular range
385:56 - so how can we do that
385:58 - first of all let's create that range so
386:01 - we will write here cv2 dot rectangle
386:04 - and we will set in our image
386:07 - and then we are going to call this let's
386:10 - say frame so this will be a certain
386:13 - value for example 100 or 200 something
386:16 - like that so we will call it frame
386:19 - reduction
386:21 - and we will also again call it frame
386:25 - reduction
386:26 - so we can go up
386:28 - and we can declare it here
386:30 - frame reduction is equal to let's say
386:33 - 100
386:34 - so we will write here this is basically
386:36 - frame
386:37 - reduction
386:39 - reduction
386:44 - okay so
386:47 - that should be good
386:50 - now once we have the frame reduction
386:52 - what we can do is
386:54 - now we need to give in the second value
386:56 - so this is the initial value now we need
386:58 - to give the diagonal points so we will
387:00 - write here that the width of the cam
387:04 - minus
387:05 - the frame
387:06 - r and then the
387:09 - second point will be
387:12 - the height of the camera
387:15 - minus
387:16 - frame r
387:19 - then we will given the color 255 0 and
387:22 - 255
387:24 - and then we will give in the thickness
387:27 - so this will draw a rectangle
387:29 - so let's try that
387:31 - so whenever we are in
387:34 - it's not drawing anything oh it is yeah
387:37 - whenever we are in okay
387:39 - um
387:41 - okay maybe we nee we need to put this
387:43 - outside
387:45 - so
387:47 - we can put it outside here
387:49 - because we won't always want to see it
387:51 - whenever we have the hand in
387:53 - we want to see it
387:54 - so now you can see we have our box now
387:58 - the idea here is that when i reach the
388:00 - top of this
388:02 - rectangle it should be the mouse should
388:06 - be at the top of my screen and when i
388:08 - reach the bottom of this it should be at
388:10 - the bottom of the screen
388:12 - so and
388:13 - same thing for the corners if i am
388:15 - moving at this corner it should be at
388:17 - the corner but now you can see it is not
388:19 - at the corner
388:20 - so again you can adjust these values up
388:22 - and down we will keep it in the center
388:24 - for now but later on if you want to you
388:26 - can adjust
388:27 - so how can you reflect this
388:29 - on our x3 and y3 so how can you change
388:33 - these values so all you have to do is
388:35 - it's very simple instead of 0 you will
388:38 - write here frame r
388:40 - you'll write here frame r
388:43 - and here you are going to write width of
388:45 - the cam minus frame r and height of the
388:48 - cam minus frame r that's it so now your
388:51 - values should reflect properly
388:55 - so here if i have my finger at the top
388:59 - right corner you can see it reaches the
389:02 - top right corner if i have it on the
389:04 - other side you can see it's reaching the
389:06 - top
389:07 - and now if i go back
389:09 - and i go down you can see it reaches
389:11 - down
389:12 - so we are having some issues as well
389:15 - it's going out of bounds uh we can fix
389:17 - those issues later uh what we can do is
389:20 - we can push this up as well a little bit
389:23 - so that it is easier for our fingers to
389:25 - move around but we can do that later
389:28 - we can move on
389:31 - to the next step which is to
389:33 - detect the click
389:37 - okay
389:38 - so
389:39 - then we are going to detect the click
389:42 - so here
389:44 - we have to check if both the index and
389:47 - middle fingers are up so we are going to
389:49 - copy this part
389:51 - and we are going to paste it here
389:54 - and we will write one and one
389:57 - so if both of them are up then we need
390:00 - to find the length
390:01 - of uh between our fingers so what we
390:04 - will do here is we will write that our
390:06 - detector
390:08 - dot find distance
390:11 - dot find distance
390:14 - between which points point number eight
390:17 - and point number twelve
390:18 - so uh these are the landmark ids so
390:21 - landmark eight and landmark 12 and then
390:24 - we will write image
390:26 - then it will unpack the values of length
390:31 - and then the image and then the what did
390:35 - i do here it should be comma and then
390:39 - we also get a bunch of info that we are
390:41 - going to ignore
390:44 - so the main thing that we need is the
390:46 - length so we need to know
390:48 - what is the distance between these two
390:50 - fingers so what we can do is we can
390:52 - write here print length
390:54 - and let's try it
390:58 - so when we are in our detection mode it
391:01 - is giving us the length and it is
391:03 - telling us uh there is a good indication
391:06 - because it actually gives a center point
391:08 - as well and it draws a line in between
391:11 - so that is pretty good
391:14 - okay so what we can do next is we can
391:17 - check
391:19 - that if the length is below a certain
391:22 - value then we will detect it as a click
391:24 - but we need to define that
391:26 - threshold
391:28 - so we are going to go back
391:31 - and let's try it out so here it should
391:33 - be open here it should be closed
391:35 - so i can see it's around 30 something
391:42 - so if it's less than 40 maybe
391:48 - yeah okay so we can say if it's around
391:50 - less than 40 then it is detected as a
391:52 - click
391:54 - uh you can
391:56 - do a normalization here as well but that
391:58 - will be quite
392:00 - a detail so we are not going to go into
392:02 - that so we will write here length is
392:05 - less than 40
392:07 - then we are going to
392:09 - cv2 dot
392:12 - circle we are going to draw the same
392:14 - circle
392:15 - that we had drawn here
392:18 - but this time we are going to draw it in
392:20 - green
392:21 - so we have the detection
392:23 - that it has been clicked
392:26 - so let's try that
392:29 - so here
392:31 - there you go
392:35 - um
392:36 - we could draw it to the center one as
392:38 - well it will look better okay how can we
392:40 - do that
392:41 - basically this is the information we are
392:43 - getting for the line
392:45 - so we can write here info line
392:48 - or we can write line
392:50 - info
392:54 - and then based on this line info
392:57 - if we go to our
392:59 - fine distance you can see
393:01 - cx and cy are the last elements so this
393:05 - is the fourth and this is the fifth
393:08 - so we will write here this is the fourth
393:12 - and this here is the fifth
393:17 - push it down
393:19 - okay
393:20 - so let's run this
393:22 - and hopefully this time the center one
393:25 - will be green
393:26 - there you go so now it looks a little
393:28 - bit better
393:30 - so that's good
393:32 - okay so what is next now we actually
393:35 - need to click so
393:37 - rather than just changing it to green we
393:39 - need to click and the clicking part is
393:41 - way easier than you think
393:43 - uh and that is auto pi
393:46 - dot
393:47 - mouse
393:48 - dot click and that's it so now it should
393:51 - click
393:52 - uh by the way these two we are already
393:55 - uh doing so we should write here
393:58 - that we are checking the distance here
394:01 - and then we are clicking the mouse if
394:04 - the distance is short over here
394:06 - so that's the idea
394:08 - okay so let's try it
394:10 - so what i will do is i will try to click
394:13 - and minimize this
394:15 - this part here so
394:17 - here is my finger and if i move around
394:20 - and i click
394:22 - you can see it's shaking a lot
394:26 - yeah it clicked
394:28 - there you go it click again but as you
394:30 - can see it shakes a lot so this is a
394:32 - very big problem which is not allowing
394:35 - us to use this properly so what can we
394:38 - do
394:39 - as i mentioned before
394:41 - if we go up here we can smoothen the
394:44 - values
394:45 - so how can we smoothen the values
394:47 - so what we can do is instead of sending
394:49 - in exactly the same value that for
394:52 - example if it goes from 0 to 100 instead
394:54 - of saying go to 100 directly we will
394:57 - dilute it a little bit so we will
394:59 - smoothen it we will reduce its value so
395:01 - it goes step by step
395:04 - so what we can do
395:06 - is first of all we are going to create a
395:08 - value
395:09 - called
395:12 - smooth
395:13 - the ning
395:17 - is equals to
395:19 - let's say five
395:21 - so this is a random value that i've
395:23 - chosen uh later on we can see what is
395:25 - the effect
395:28 - okay so now what we will do is we will
395:31 - uh we need to also create two variables
395:35 - so what we will do is we will write here
395:38 - in fact we need to create more than two
395:40 - variables
395:41 - so we should separate the
395:43 - variable declarations here
395:47 - yeah that should be fine okay so what we
395:49 - will do is we will say that our previous
395:51 - location
395:53 - we will call it previous location of x
395:56 - and the previous location of y is equals
396:00 - to 0 0
396:02 - and the current location of x
396:05 - location of x
396:08 - and the current location
396:10 - of y so again these will be 0 and 0.
396:14 - so what we will do is
396:16 - what did i do here
396:18 - so what we will do is
396:20 - we will use these values
396:22 - and we will update them each iteration
396:25 - to smoothen our mouse
396:29 - so here we are going to go here now
396:31 - instead of x3 and y3 we are going to
396:34 - send in the smoothened values of current
396:37 - location and
396:39 - we will update our previous location so
396:41 - how can we do that
396:42 - we will write here that our current
396:45 - location
396:46 - of x is equals to our previous location
396:49 - of x
396:51 - plus
396:52 - our x3
396:55 - minus our previous location of x
396:59 - divided by
397:00 - the smoothing value
397:02 - so whatever the value is we will divide
397:04 - it by that and the same thing we will do
397:07 - with our y value
397:09 - so we can write here y
397:11 - you can multiply with this as well you
397:13 - can multiply smoothing as well then you
397:15 - will have to go into points so 0.1 0.2
397:19 - or you can divide and keep it whole
397:21 - numbers it's up to you
397:23 - so we'll write here y3
397:26 - and then we will write y and then we
397:28 - will write that's it
397:30 - okay so then we will just send in our
397:34 - x value and y value instead of x3 and y3
397:40 - and then we will just update these
397:43 - values once we have
397:44 - uh use them so we will write here
397:47 - previous location x and previous
397:50 - location y
397:51 - is equals to current location
397:54 - x
397:55 - okay let's put y first current location
397:58 - uh current location
398:02 - x
398:03 - okay
398:04 - so that is the idea
398:06 - now uh let's put a very dramatic value
398:10 - let's say 20
398:11 - and let's run it
398:16 - so now you will see if i move it around
398:19 - you see it is quite smooth
398:21 - but it is quite slow
398:24 - so we need to find
398:27 - you see when i stop it takes a while to
398:30 - stop
398:31 - so what we need to do is we need to find
398:33 - a good balance
398:34 - so let's try five
398:42 - so i like this
398:43 - it moves nicely and it stops
398:46 - it doesn't shake a lot
398:48 - there you go i can click as well
398:51 - there you go
398:53 - and let's click on the minimize there
398:55 - you go
398:56 - so yeah that looks good
398:58 - uh
399:00 - let's try 10.
399:11 - uh 10 is good but it's a little bit
399:13 - slower yeah it's hard to stop at that
399:16 - point
399:17 - yeah 10 is a little bit fast it is a
399:20 - little bit slower
399:21 - so maybe seven
399:29 - yeah this one is better
399:31 - there you go
399:32 - i can do that i can go to this one
399:35 - i can click on this one
399:38 - and this one again
399:41 - there you go so it is pretty good
399:46 - so that is quite nice
399:50 - so that is pretty much it as you can see
399:53 - it works quite well and we broke it down
399:56 - into different steps and when you go and
399:59 - try to solve each of these steps it
400:01 - becomes very easy
400:03 - to get a solution and all of this is
400:06 - possible thanks to our hand tracking
400:09 - module that we created earlier if we
400:11 - don't do that then it will be quite
400:13 - difficult
400:15 - and it will take quite a lot of time to
400:17 - actually create such a project but as
400:19 - you can see it was quite easy and quite
400:22 - simple what we achieved in this short
400:25 - amount of time
400:27 - so this is it for today's video i hope
400:29 - you have learned something new if you
400:31 - like the video give it a thumbs up and
400:33 - don't forget to subscribe and i will see
400:35 - you in the next one
400:40 - you

Cleaned transcript:

hey everyone welcome to the advanced computer vision course in this course we are going to learn advanced techniques to better our skills of computer vision now you might think that the term advance might not be for you now this does not mean that the topics are very difficult it just means that they are on an advanced level and we will do our best to learn it as simple as possible we will break it down into basic code and then we will create modules out of this so that we can use them in different projects once we are done and we will be learning four different chapters including hand tracking pose estimation face detection and face mesh and not just that we will also be creating five different projects so that we can learn some real world applications for example volume gesture control ai trainer ai mouse control and a lot more if you would like to see more of such content do check out my channel murza's workshop where we create projects related to computer vision artificial intelligence and robotics so without further ado let's get started hey everyone welcome to my channel in this video we will learn hand tracking in real time we will first write the bare minimum code to run and then learn how to convert it into a module so we don't have to write it again and again for different projects the best part is we do not have to configure 100 parameters along with 20 different installs to make it run within 10 to 15 minutes you will have your model working the framework we will be using today is called the media pipe which is developed by google they created these amazing models that allow us to quickly get started with some of the very fundamental ai problems such as face detection facial landmarks hand tracking object detection and quite a bit more so we will be covering the rest of these as well so make sure to subscribe to keep updated now the model we are working with today is the hand tracking it uses two main modules at the back end so one of them is the palm detection and the other one is hand landmarks now the palm detection basically works on complete image and it basically provides a cropped image of the hand from there the hand landmark module finds 21 different landmarks on this cropped image of the hand to train this hand landmark they manually annotated 30 000 images of different hands so that is a lot of work and this is one of the reasons it works so well and the best part is that it is cross platform and we don't have to dive deep into the sea of configurations and installations so within just two clicks we will be up and running so let's have a look at the implementation so right now i am in pycharm and we are going to first create a new project so you can see that i have created this hand tracking project and we will go to file settings and we will go to our project then the interpreter and we will add so here we are going to add our packages so we will write here opencv python we will install that and then we will write media pipe and we will install that so these are the only two packages that we will be needing so within two clicks we are ready to start coding so that is amazing okay so now we will create a new file we will call it let's say hand tracking tracking minimum so the bare minimum code that is required to run this so the first thing we will do we will write here import cv2 and then we will import media pipe as mp and then we will import time so this is to check the frame rate so first we are going to create our video object so we will write here cv2 dot video capture and i'm going to use my webcam number one you can use your webcam number zero so then we will write file true and then we have success success and we have our image is equals to cap dot read so that will give us our frame we will write cb2 dot weight key 1 and we will write cv2 dot i am show i am show and we will write here image and image and we will write img so this is basically what we always do to run a webcam and what we can do as well is right here that if more doing it or we can skip it it's fine we don't need to write that we have to close with the q button so here we can right click and we can press the run button and let's see so there you go this is my webcam you can see my hand there you go and we are going to detect this hand so the first thing we have to do is we have to create an object from our class hands so here we are going to write now this is related to the hand detection modules or the hand detection model so later on we will create our own module so that we can learn how to use it easily in different projects so getting the values of these different points or the landmarks is a little bit tricky but we will create a module so that we can just say i want uh the point number five of the hand so tell me the location so that will become quite easy to use in different projects so first of all we are going to write here mp hands is equals to mp.solution now this is you can say a formality that you have to do before you can start using this model so you will write mp.solutions.hands and then we are going to write that we are going to create an object called hands we will write mp hands dot hands and then inside that we have to write our parameters now what are these parameters so let's go and check them out so we will click on we will press the control button and we will right click on this and it takes us to that function so here we can check what exactly are we getting uh what exactly do we have to input so here the first thing is the static image mode so static image mode they have this configuration where they will track and detect so if you put this as false then sometimes it will detect and sometimes it will track based on the confidence level but if you put it as static mode then the whole time it will do the detection part which will make it quite slow so we will keep it false so that it detects and if it has a good tracking uh confidence it will keep tracking so this way it will be much faster whenever the tracking confidence goes lower than a certain range then it will do the uh detection again so then you have the maximum number of hands so here we have two and then we have the minimum detection confidence so this is 50 and then minimum tracking confidence which is 50 so it means if it goes below 50 percent it will do the detection again okay so now that we know our parameters we can go back and we can write here false so actually we are not going to write anything because these are the default parameters and they have already given the default values so we do not have to change or write anything here if we want to we can otherwise we can skip it as well so for this instance we are going to skip and later on we are going to write whatever we need so then we are going to go actually we will need to go back okay so then here in the loop we are going to send in our rgb image to this object so here we have to first convert it so we will write here image rgb is equals to cv2 dot cvt color and then we will write our image y is a double bracket okay we will write our image then we will write cv2 dot color underscore bgr to rgb so this is our idea that we want to convert it into rgb because this class or this object only uses rgb images so we need to convert that first so we will write here that our results results is equals to hands so we are calling this object dot process so there is a method inside this object called process that will process the frame for us and it will give us the results so that's how simple this is now all we need to know is how to extract this information and use it so after this what we can do is we can simply display this but at this point we are not really displaying or doing anything but i still want to run it to see if everything is working so far so it will be processing it but it will not display anything for us so let's try it out so there you go and now you can see even though it's processing the frame rate has not decreased it's uh it seems real time we will later on check the exact uh speed as well the exact frame rate so don't worry about that okay so then we are going to open this object up the the one that we have received and we are going to extract the information within so as we have seen the parameters we can have multiple hands so what we can do is we can extract these multiple hands so we will have to put in a for loop to check if we have multiple hands or not and we have to extract them one by one now before we do that we have to make sure that there is something in the results so we can print out the results and we can run it and it just gives us that it is a media python solution based solutions output and if i bring in my hand nothing really changes so we need to know when something is detected or not so to check if something is detected or not we can write here dot multiple uh multi underscore hand underscore and underscore landmark landmarks so let's run this and see what happens so here it says none and if i put my hand and there you go so straight away we are getting some values so what we will do is we will say that if we can remove the print or let's keep the print we can copy this part and we can go down and we can write here if this is true then we are going to go in and for each hand so we can say for each hand landmark landmarks let's say in results dot multi whatever we wrote here multihand landmarks so you saw that we were getting some results so is it of one hand or two hands we don't know well we actually know because i just put one hand but it could be of multiple hands so here we will have each hand and then we will get the information or extract the information of each hand so once we do that we have a method provided by the media pipe that actually helps us draw all these points because there are a lot of them and we you have almost how many were there 21 points and between each points if you want to draw a line it will be quite a lot of maths that would be involved there so they provided us with the function or a method for that so we are going to write that down and that is basically mp draw we will call it mp draw is equals to mp.solutions so lucian's dot drawing utilities so we will write that and now we will use mp draw to actually draw it so we will write here empty draw and then we are going to write draw landmarks and inside that we will give in our image that we want to draw on so we don't want to draw on the rgb image because we are not displaying the rgb image we are displaying the original image bgr so we will write image and then we are going to write hand lms so this is a single hand okay so there could be multiple hands this is let's say hand number zero then there could be hand number one so this is that single hand so if i run this now that should draw the hand for us let's try it out and there you go so now you can see it is drawing the hand for us and it looks pretty good so but these are points and i told you that we could draw the connections as well so how can we do that we can do that by writing here mp hands dots and underscore connections so that is it so we are using mp hands dot hand connections and this will draw the connections for us so let's try that out and there you go so now you can see how easily we got our uh what he called hand position and we got all the 21 landmarks if you like the video so far give it a thumbs up and don't forget to subscribe so this is good but the problem is we don't still know how to use these values so where are these values how can i extract and use them so for example if i want to track one of these positions to perform a certain task what exactly can i do so that is still remaining and we will learn how to do that but before we go there i want to do the frame rates so we are going to write the fps so to do that we are going to write here that our previous time is equals to zero and our current time is equals to time is equals to zero okay so once we have done that we will go down here and before we display we are going to write here current time is equals to time dot time and this will give us the current time and then our fps will be one divided by our current time minus the previous time previous time okay so then our previous time will become the current time our previous time will be the current time so yeah that seems good and what else can we do can we yeah i think we should display it on the screen so that we can see it rather than putting it on the console so we can write here cv2.cv2.put text and we want to put it on our image we want to convert it into a string because it is time so we are using what do we call fps fps and we also have to round it because or should we if we round it it will give us decimal values we don't want decimal values for fps we can just put integer so that will give us that and then we can give it a value the position let's say 10 and 70 and then we can give in our font cb2 dot font whatever comes first and then we write then we write the scale and then we write the color so let's put purple or let's put blue whatever let's put purple and then we have the uh i think i missed something i missed a comma here okay and then we need to put i think the scale or the thickness the thickness let's put as 2 or let's put a 3. okay so that seems good and what else i think that should be fine let's run it so here we have it so now we can see that the time is around 30 30 fps the frame rate it goes to 20 sometimes but most of the times it's 30. you can see it's quite fast very responsive thumbs up oh thumbs up makes it go away thumbs up yeah this time it worked thumbs up great let me try my other hand as well so that seems fine and it is working quite good so we can move on so now we are going to get the information within this hand so for each of these hands so we will get the id number and we will also get the landmark information so the landmark information will give us the x and y coordinates and we also have their id numbers and they are already listed in the correct order so all we have to do is we have to check their index number and that's it so what we can do is we can write here for id and the landmark we are going to find it or we are going to enumerate and then we are going to find it inside the hand lms dot landmark so this is basically our landmark uh this is basically our landmark that we are getting from here and this is the id number or the index number that we are getting which will relate to the exact index number of our finger landmarks so if it is zero it will be the bottom middle one uh then if it's four it will be a tip and things like that so what we can do is we can print here and we can write id and landmark so we can see at least what is happening so let's run that and there you go so let's see what did we get so if we go up here you can see that this is id number 20 19 18. so if we keep going back we keep going back we will start from zero so each id has a corresponding landmark and the landmark has x y and set so we are going to use the x and y coordinates to find the information or to find the location for the landmark on the hand but the thing is if you see here these values are decimal places so the location should be in pixels so it should be for example 500 pixels in the width and 200 pixels in the height something like that but here you can see these are picks these are decimal places so basically what they are giving is they are giving a ratio of the image so we will multiply it with the width and the height and then we will get the pixel value so this is how we can get it directly so here what we are going to do we are going to first check out the heights the width and the channels of our image which will be which will be image dot shape so we can write this and this will give us the width and height and then what we can do is we can find the position so we can write here cx and cy is our position of the center and basically it will be an integer because it is decimal places so we have to convert it into integer so we will multiply our landmark dot x value multiplied by the width and for the second one it will be integer and then landmark dot y value multiplied by the height so this will give us the cx and the cy position so now we can print this out but the thing is that it is not for a specific one it is for all of them so if we print it now let's remove this and we will print we will print cx and cy so if we run this now it will give us for all 21 values so how do we know which one is for which which one is for landmark one which one is for landmark two so we need to write the id of that as well so we can write it like this so there you go so now we have this information so if we look here this is the this is the id number and this is the cx and the cy position so what we can do is we can use any of these to actually uh use it to our benefit to actually print out any of these landmarks so i can write here if id is equals to zero this means we are talking about the first landmark then we are going to let's say draw the circle so we will write here cv2 dot circle we are drawing it on the previous one and we will color it a different way and we will make it a little bit bigger so it is easier for us to know that this is the one that we are uh printing so it shouldn't be an issue so we can write here that our radius is let's say five and then our color will be different it will be purple and then we have cv2 dot filled so once we have that now it will only draw for what you call the id number one so if i run this now and there you go so you can see here at the bottom you get okay let me make it bigger it's very small so let's make it 25 there you go so now you can see clearly that we are detecting that landmark which is 0. so if i remember correctly 4 is also 4 is a tip of one of the fingers let's make it 15. 25 is too big there you go so it is the tip of the thumb so you can see now we are getting this information and what we can do is we can put all of this in a list and we can use it to print or we can use it to find the location and move around and do all sort of different things with this what we can do is we can also remove this and then it will draw on all of them but that's that's not useful because we are already drawing on all of them so here you can see looks quite weird anyways so that is the basic idea that this is how you get the cx and cy information which is basically for each one of these and we can put them in a list so that we can later on uh return this list and use it to our benefit if we want to track the index finger at the tip of it or the bottom part of it whatever we want to track we can do that so now that we are done with this we are going to create a module out of this so that next time if we are using it in a project we don't have to write all of this again we can simply ask for the list of these values of these 21 values of each hand for example we can say give us for the first hand give us for the second hand whatever and then we can simply say okay i need point number 10 and it will give us the value of point number 10 which is let's say at this point it is 4 four four and two one zero so that will make it very easy for us to uh create new projects so let's see how we can do that so now we will create a modules file so here we will call its hand tracking module so we will copy pretty much all of this code and we will paste it here first of all we will write here if name is equals to main this means that if we are running this script then do this so whatever we write in the main parts will be like a dummy code that will be used to showcase what can this module do so we will write here def main and we are going to put our while loop inside of this so while true and in fact all of this as well uh not that let's copy this part first so we'll put this here and then this part here also for the frames fps we will put it down here and what else what else do we need yeah the video capture we can put it here wait why did it show here okay i think i copied it or what yeah so we need to remove this okay and then what else what else i think that is fine for now so now what we have to do we have to create our class so i thought of doing it in functional programming but i think it will be better if we create a class so we are going to create a class here we will call it class and detector and inside that we will write def inits in itself and inside that we have to give in our parameters so these parameters are the basic parameters that are required for this hands so if you remember we went to the hand and we have all these parameters so these are the ones that we will be using to input that so so that we have the flexibility of changing these so here we have the mode so we will write here mode is equals to false then we are going to write the max number of hands so we can write here max hands is equals to 2. then we can write the detection the direction confidence is equals to 0.5 and the track confidence is equals to 0.5 so then we can remove all of this and now the first thing we have to do is we have to write self dot mode is equals to mode this means that we are going to create an object and the object will have its own variable so this is that variable whenever we are using the variable of the object we will call it self dot something and we are assigning it initially we are assigning it a value provided by the user so we are calling uh we are calling it mode and we are providing it the value of the mode so the same thing we have to do with the other parameters so we will write here max hands is equals to max hands self dot detection confidence is equals to detection confidence self dot tracking confidence track confidence is equals to track confidence and then all of these have to be inside this initialization as well so if you remember they are part of the initial code where we are initializing everything and then there is the while loop so we need to initialize these as well over here and again we will write here self dots so we will keep putting self dot everywhere and we also have to so why is this giving an error empty hands because we need to add the self here as well so we will write here self.mphands.hands so that should be good and inside that we have to give in our parameters so the parameters will be self mode then the max hands the confidence and the tracking confidence there you go so this should be fine so i think the initialization is done so now we can move on to the uh detection part so we can write here let's say we will call it find hands and inside that we have to just copy this part so do we need to convert we do need to convert and we need to put this as well so we will put all of this we will put it here inside and then we will go back up here and let's start from here so first of all we will need an image to find the handson so that will be this image and then hands is not being recognized because it has to be selftaught hands so we are talking about this object within this uh object so then we have mp.draw so this should be self.mp draw and then self dot hands connection so that should be good and should we draw it inside i i don't think we need to draw it here in fact we do not even need to get the landmarks from here what we can do is we can keep this outside and we can comment this so here this is what we need basically to draw the hands so we can put a flag here we can write here draw and we can put it by default as true and we can check if we want to draw or not so here we can write here if draw then do this okay so it will only draw if we ask it to draw so i think this is good enough to actually run the code or the run the class without uh actually getting the list so for testing this should be fine so what we can do here so we will create a new method within this class that will find the position for us it will give that list for us but for now we will just test to see everything is working so far or not so here we will first create our object we will call it detector is equals to hand detector and we will not give in any parameters because we know that we have these default parameters already there so once that is done we will get our image and once we get the image we are going to send this image we are going to write here detector dot now this is the method here find hands so this is the method within our class so we will write here find hands and we have to give in our image so that is the most important component so we might need to draw on it so we need to return the image if we have drawn on it so we will return the image so then we can go back and take the image over here so image is equals to this so if we run this now as a module it should work so let's see if we did any mistake uh yeah it's working oh yeah that's good so now our module is running is the main reason for creating this module is to get those position values of the landmarks very easily so we need to create that find position function or the method so we will write here find position and we are going to give in the parameters of our image now we don't really need the parameter of the image but we need it for the width and the height so if you remember here we need the shape so we can do it in other ways but this is simple so we will try it now later we can improve on it then we need the hand number so if you are detecting with if you want the information of hand number one hand number two and number three whichever hand you want you can ask the information of that and then we will have the parameter for draw so again we will put it as true by default so now we can uncomment this and we can bring it back okay so that should work now here the issue is that we were using a for loop to actually run this but now we need to first check again we will go back here and we will create a list here lm this is the landmark list that we are going to return so this list will have all the landmark positions so we can return this whether it is filled or not we will return it so we will return this and then we are going to check again that whether any landmarks were detected or not or any hands were detected or not so to do this we use basically this part here so if the self results multihand landmarks if that is available then we are going to check the next things so here we will write this and we will put all of this inside that so but here we are getting the results this is the results it should be self.results self.results and now i can use the results here as well okay so now we need to replace this here as well okay so if it's not self then i cannot use it in this method to use it in all the methods you have to make sure this is for this object this variable okay so now we have to write down that which hand are we talking about because earlier we were getting it for all the hands so if you want you can get it for all hands it's up to you but i'm creating this method to get the uh to get for one particular hand if you want you can change that too so here we are going to write so earlier we had four hands this this this now we will get this and we will point to we will point to a particular number and that number will be the hand number so we will say that our let's say our hand let's say we'll call it my hand is equals to this and we will put this over here so it will get the first elements the first hand and then within that hand it will get all the landmarks and it will put them in a list so here we are just printing them out so here we can write uh lm lists list dot append and we want to append the values of id cx and cy and we can remove the print because we're getting it anyways so yeah so that is i think that is good and here we have the option of draw as well so we can write here if draw then do this otherwise don't so by default it is true so it is going to draw so yeah let's see how that works out so we can return this list so i can call this so we can go down here and i can call find position and we can remove the self and we have the image and do we need anything else i don't think so okay copying this was a bad idea anyway so finding positions of image yeah and it will give us the list so we can copy this and we can paste here so now what i can do is by the way we have to write detector dot find position so now what i can do is i can print the value of my list at any index so if i want let's say uh the zero index then i will write here zero if i want the landmark number four i will write here four so if you remember the 4 was the tip of the thumb so this will give us that position so let's run this and see what happens index is out of range okay so that is uh understandable why because here we have to check if nothing is found which means lm list the length of it is zero so we will write here that the length of this list is 0 then we will if it's not equal to 0 then we will print so let's run it again and there you go so if i put my hands so now you can see it's drawing for all of them but it is showing me only landmark number four so if if you look at my thumb so if you look at my thumb if i'm going really to the okay it's not moving the values okay so now if i go till the very end you can see it is 600 something because the value is 640 the max value and now if i go around to the starting point it goes uh around 150 something so i'm talking about the x position by the way so the x position is changing like this then we have the y position here it is going towards zero and down here if we go down here it is going towards 400 something so this is a 640 by 480 image it works well with 1280 and 720 as well so it's still around 20 something frames per second so that is quite good okay so now this is working as a module and what we can do is we can use this in a different project now you might say how can we do that well here is the dummy code so this dummy code we can use to actually uh run in a different project so i can copy this and i can create let's say my new game game hand tracking blah blah blah okay that's a very long name um so i can i can paste this here uh the complete code and i can remove the indentation and then i can import i can import these so then i need to check what is missing so here now i need to imports i will import hand tracking module and tracking module as h t m so now i will write htm dot hand detector and the rest will remain the same so that is pretty much it so if i run this now it should run exactly the same so there you have it and there you go so now it's giving me the values of the index uh not the index the tip of the thumb which is uh landmark number four and it is showing me all the landmarks uh as we have drawn so if i if i go back here if you like the video so far give it a thumbs up and don't forget to subscribe to my module i can change the color or i can change the size of these as well again all these parameters you can change you can add to your methods if you wish and it could become easier for you it depends on your project so if you have a lot of different um things that you want to accomplish within one project then you can add more methods to this to compensate for that so here let's say we will make it a little bit smaller so 15 is too big we will make it seven let's say and let's change the color so it's bgr so let's make it blue and there you go so now we have changed it and if we go back actually i preferred the previous one even the big aspect so um here what we can do is if you don't want to show it we can write here false and it will not display oh it's displaying wait why is it displaying so why is it displaying let's go back here and if draw then only we do this okay maybe it's drawing here as well am i running this yeah i'm running the correct file but when i write false here oh there are more arguments that's the problem there are more arguments so we cannot just write here we have to write draw is equals to false my bad straw is equals to false and there you go the drawing is gone that the custom drawing that we did now if you want to remove this drawing as well you can write here draw is equals to false and there you go so now you will see that you are getting the value of the thumb but nothing has been drawn so this way you can customize it to your needs hey everyone welcome to my channel in this video we will learn pose estimation we will detect 33 different landmarks within a human body and all of this will be done in real time that's right more than 24 frames per second and only running cpu we will first look into the basic code required and then we will create a module out of this so that we don't have to write the code again and again and yes we will be creating a lot of projects with this so don't forget to subscribe and hit that like button so here we are in our python project and you can see that we have named it pose estimation project and we have a folder here with post videos so if i open this up you can see that we have a lot of different types of videos we have a total of nine videos so let me play a few so here you can see this one is a little bit smaller and some of these videos are actually slow motion so when we are running it it will look like it's slow but it's not actually slow it's actually slow motion so like this video and then i think what else i think this video as well it's slow motion and i think this one is fine this one is normal this one is slomo as well so i took these videos i think from pixels.com so we are going to test these videos out and see how well does our pose estimation work so we will select all of this or let's let's create a new file let's delete this one so let's delete this and now we are going to create a new file and we will write here pose as the mason uh minimum so this is the bare minimum code that is required to run it and later on we are going to see how we can create a module out of this so that we don't have to write the code again and again for a lot of different projects so let's start by importing cv2 and then importing media pipe as mp but now you can see that we get an error this is because we did not include these packages in our project so how can we include those so we will go to file settings and we will go to our project interpreter and open that up and here we will write opencv dash python and we will hit install and then we will write media pipe and we will hit install so now both the packages have been installed and we can go back and you can see the error is now gone so opencv is the library that we will be using for image processing and media pipe is the framework that will allow us to get our pose estimation so now the first thing we will do we will read our video so we will write here cap is equals to cv2 dot video capture and we will simply give in our video number so here we will write pose videos videos and we will write video number one dot mp4 i think the one is quite big let's let's try it out and later we can change it if we want and then we will write while true and we will write success and image is equals to cap dot read so that will give its uh our image and then we can write here cv2 dot i am show and we will write here image image and then we will write here image and then we will write cv2 dot weight key and we will write one so that we get a one millisecond delay okay so let's run this and see if it works and there we have it so our video went quite fast so the frame rate is actually quite high at this point what we can do is we can check the frame rate by writing here time let's say current time is equals to uh we need to import time as well so we will write here import time and then we will write time dot time then we will write that our fps is equals to 1 divided by our current time minus our previous time and our previous time is equals to current time and we need to define the previous time up here at the top so we'll write here previous time is equals to zero and then we can simply put our text so we will write here put cv2 dot put text and we will write in our image and then we will write in the text itself so we will write string fps but we will convert it into an integer before we do that then after that we have our origin so let's say 70 and 50 and let's say the cv2 dot font plane and let's say uh three and then for the color we can put two five five zero and two five and zero and then we can put three so this should give us our frame rate let's try that out uh wait what happened okay this should be below over here my bad so let's run it again and there we have it so you can see it's a hundred something frames per second so that's quite a lot if you want to reduce it we can put here let's say 10 so now it's like 50 60 frames per second but when we are using our model it will automatically slow it down so we don't need to worry about that so the next step would be to create our model so our objects so that we can detect our pose so here we are going to write mp pose pose is equals to mp.solutions so solutions dot pose so we are going to use this and then we are going to create our object we are going to say pose is equals to mp pose mp pose dot pose and then we will give in our parameters so if we go to the parameters you can see that we have the static image mode this is basically that when you are detecting and when you are tracking so if you put it as true then it will always detect based on the model it will always try to find the new detections but when you put it as false it will try to detect and when the confidence is high it will keep tracking so there will be a tracking confidence and then there will be a detection confidence so whenever it detects if the confidence is more than 0.5 it will say okay now we have detected now i will go to tracking now the tracking will check if the tracking confidence is more than 0.5 it will keep tracking whenever it goes below 0.5 then it will come back to detection so this way we do not use the heavy model again and again for detection instead we use detection then tracking then whenever it's lost we use the detection again so this is what this does and then we have the upper body only so you can decide if you want to detect only the upper part so it will have you can see here we have 33 poses landmarks or only 25 so it's up to you which one do you want to use and here we also have a feature to smooth which is by default true so we will keep it as true so we can define all of these parameters or we can skip them it's up to us so for the initial purposes we are going to skip all of these for the simplicity so then we are going to go down here and simply we are going to convert our image so we will say image rgb is equals to cv2 dot cvt color so this image is in bgr but this library or this framework uses rgb so to make it compatible we have to convert it so we will write here image and then we will write cv2 dot cv2 dot what color underscore bgr to rgb so this is our conversion and once we have done the conversion we are simply going to send this image to our model so we will write here results is equals to pose dot process and we will write image rgb so that's pretty much it so that will give us our detection of our pose but it will not draw anything but for now we can just run it to see if everything is working and now you can see that the frame rate has decreased so this is good to see that our model is actually working but you can see that it's almost uh real time so that is really good so now what we can do is we can draw our landmarks or whatever we have detected we can draw it but before we do that we can print the results as well so we can write here results and let's see what do we get so here you can see we get nothing so it's just a class but we don't see any information so how do we see the information we simply write results dot pose landmarks land marks so if we run that now you will see that we are getting actual landmarks so each landmark will have the x y and z value and then it will also have a visibility value so how visible is it so this is the information that we get so we can put all of this in a list later on so that it's easier to access so then we will check if it is detected or not so we will say that if this is present if this is true then we are going to write here that mp draw dot draw landmarks draw underscore landmarks and then we are going to define our parameters but here you can see we don't have anything called mpdraw so we are going to declare that we will write here mpdraw draw is equals to mp.solutions solutions dot draw utilities so we will use that and then we can write here uh within our landmarks we can send in our image then we can write results dot uh pose landmark so this is the same thing that we are printing out that we got so we will write here land marks and then what do we have uh i think that is good let's do that let's run it and there you go so now you can see we are getting all the points you can see that it is in red now what we can do is we can also add the connections or the lines between these so here we can write mp dot not mp pose dot pose connections so that will fill up the connections there you go so now you can see we have the green lines which are the connections and then we have the points as well and we are detecting them all at real time so that is very very amazing so now we know that we are getting this information but how can we know which is for which so here it just says landmark this landmark this there is no indication of which landmark represents what so what we need to do is we need to organize a little bit so that it is in a list and we can simply use these values um in our project so for example i will say i want landmark number five i want landmark number three so if we go to the media pipe website you can see here that these are the landmarks that they have given so for example if i want the right ear so i can just say i want the element number five element number eight so give me that element if i want the nose i can say give me the element number zero so based on this it will become very easy for us to actually uh create our new projects so gesture recognition and lots of different applications will become very very easy so how can we extract the information within this object so what we can do is we can write here for id and landmark in enumerate we will write this result so we are going to loop through this and we want the count as well that's why we have written enumerate so it will give us the loop count over here so 0 1 2 3 and so on then we are going to get the shape actually this will be we have to add here landmarks landmark and then we are going to write here height width and channel is equals to img dot shape and the reason we need this shape is because uh let me actually show you why and you will understand so what we can do is we can write here print and we can write lm dot x or let's just print lm so you can see what is happening and we can print the id number as well so you know what exactly are we extracting here so let's run this so there you go so now you can see we have the id number and this is the information of the landmark so 30 is this 21 is this and it goes all the way to wait why is this showing i think i didn't remove the other print anyways so you can see here from 0 to 32 we will have all these 33 landmarks so let's go down and let's just remove the previous print first okay so now we know that we have the id and we have the landmark but you can see the landmarks they are actually in decimal places so this is basically a ratio of the image so what we can do is to get the actual pixel value we can say that lm.x this will give us this x value multiplied by the width of the image so that will give us the uh x of our what do you call the point or the landmark so it will give us the exact pixel value the same thing we can do for lm dots y and we can multiply it with the height so we can do that and then what we can do is we can put them in our cx and cy variables so this way it will be easy for us to use the indentation is wrong that is why it's giving an error okay so also we need to convert this into integer because we have to make sure it's not a float or a double because we are talking about pixel values so then what we can do is to confirm that this is happening and we are getting the correct values we can simply print the circle uh on top of this point so we can write here cv2 dot circle and in the circle we will write image and then we will write cx and cy and then we can write let's say the value of 15 15 will be too big let's say 10 then 2 5 5 0 2 5 5 this is purple let's make it blue and then we will write cv2 dot filled so this will overlay on the previous points if we are detecting it properly so let's try it out so there you go so now you can see we have those blue dots and these are the ones that we put ourselves so this means that we are getting the correct information at the correct pixel values and it is working good we can reduce this to five there you go much better actually let's try another video we have been using the same video we have like nine videos so let's try a random one number five yeah that looks good let's try number six yep that is good number three there you go okay here we had an issue but now it's fine that's good so we can see that we are getting good results and that should be good enough for us so next what we can do is we can convert this into a module so that we can use these values very easily so the first thing we will do we will go here and right click and we will create our module let's call it pose module and we will copy all of the bare minimum code and we will paste it here so that looks good now the first thing to make it a module we have to write here if underscore underscore name is equals to underscore underscore main then we are going to write main so what this does is that if we are running this by itself then it will run the main function and if we are just calling another function it will not run this part so this is what it means so we will write here main and within the main we are going to write everything or we will write the dummy code in the main so whenever you want to see what a module is capable of or the testing script you can put it in the main function so here we will we will take this till here we will cancel it from here we will cut it and we will paste it in the main then we will take all of this as well we will cut it and paste it in the main again so that should be good and what else so now we are going to create a class so in that class what we should be able to do is we should be able to create objects and we should be able to have methods that will allow us to detect the pose and find all these points for us okay so here we are going to say that our class let's say is pose detector and inside that we will have our first method which is the init this is the initialization so we will write here in itself and then we are going to write in the parameters that are required so whatever parameters we are expecting we will write here so here we are going to write mode so if i go to where is it okay let's go to pause estimation and here we are going to go to pose so i will copy all these parameters and we will just paste them here and we will write so the first one is mode so we will keep it as false so that we get fast detections uh fast detection plus tracking and then we will write here upper body so upper body is equals to false and then we have the smoothness smooth is equals to true and then we have the the detection confidence is equals to 0.5 and then we have the tracking confidence is equals to 0.5 so these will be our initial parameters and then we can remove this and then we can write here that self self dot mode is equals to mode now if you are not familiar with object oriented programming then this basically means that uh whenever we create a new object it will have its own variables so this whenever you write self dot something it is the variable of that object so whenever we are using um a variable within our class we will uh write self dot something so self dot objects sorry self dot mode dot self.upbody so we are going to write that so here we are saying that the specific variable of our class or our object is basically the one that the user has provided so it will set this instance of that object to false so this is what it does so here we will copy all of these and we will write up body is equals to up body and then we will write smooth is equals to smooth and then we will write detection confidence is equals to detection confidence and we will write track confidence is equals to track confidence so as i mentioned before we just have to put self dot in front of each one of these and that should be good to go so next we also have to declare these so again this will be part of that object so we need to write self so here we will write self.draw self.impose and self.pose and we will write here self dot impose so this is good and what we can do is earlier we were not using any of these parameters but now we have to so here we are going to send in all the parameters so we will write yourself that mode so self.body self.smooth self thought detection confidence and self thought tracking confidence so that is pretty much it okay we need to put a comma here yeah so our initialization is pretty much done and now what we can do is we can uh create a method to find the pose so we can write here find pose and we do have to write self here so whenever we are creating a new method we have to write cell first and then we have to give in our image and then we will also have a flag called draw and we will put it as true so this basically what it will do is it will ask the user do you want to draw or not do you want to display it on the image or not so we want to we want to display so we are going to put this inside here and then uh this draw if results draw this this this yeah this will be separate this for loop will be separate and this results will be here so let's push this in and we can remove this and what else so now we need to write the self dot so here we will write self dot pose process and self dot mp draw then we can also write self.mppose so anything missing uh no it seems fine now what we need to do is we need to put that flag so we will write here if draw then we basically do this so that should be good so let's try it out or should we put it inside let's put it inside that so we will say that if landmarks are present or let's put the draw inside so if the landmarks are detected and we set draw then you need to draw so that is good so by now we should have a working class so we can create an object from it and then we can run it so let's try that out so here we will write our detector detector is equals to our pose detector and we will give in the default parameters and here what is happening here this should be inside the while loop so here we are going to write detector dots find what was it find or detect find pause find pause why is it not detecting oh the indentation is wrong so now it will detect okay so detector dots find pose and then we have to give in our image so that should be it and we need to return the image so we will write here return image and we can bring in the image back here so if we run this it should draw on our video so let's run the pose module and there you go so now it is running and it looks good let's try it on the first image there you go so this is quite good and what we can do next is we can do the main part which is to find the points so we need to get those points here we are going to define the get position and we will write inside that we want an image and then again we want the draw flag so by default we are going to yeah let's put it as true and then we can uncomment this okay so now what we will do is we will first of all here we are getting an error for result because we need to write self dot results here and here and here and here okay so that should be good and what else so we need to push this in in the for loop so now we are we are just looping we need to check first as well if the results are available so if the results are available then we will use this for loop and then we need to put it in a list so we are going to write a list lm list which is for our landmarks and we will append our values so here it depends on you what kind of values do you want to append so i'm going to append only the x and y values and the id if you want to append the z and the uh what was the other one the visibility you can do that too so here i will write lmlist dot append and i will write in the id so here i will write id and then i will write the cx and the cy and i will add the option here that if draw then do this so this looks pretty good so let's go down and try it out so where is it here so we can write here that our lm list is equals to detector dot find position is it find position or get position let's keep it find position so it's similar to the previous one find position find position and then we will give in our image and let's keep it as true for drawing so we know it is detecting and we can print out the list as well so we can print out lm list and there you go so now you can see we are wait why is it printing this that is not right uh okay this is printing this parts any other prints uh no so let's write again yeah so right now it's none wait why is it none the lm list is none lm list oh we didn't return it forgot to return return lm list okay so now we can run it and there you go so now we have the list and if we go till the end you will see we have a total of 32 points so we have 33 points because we are starting from zero so now i can easily say for example i want number 0 i want number 8 i want number 5 number 23 whatever i want i can write down here so let's say we want number 8 or let's say we want number 14. let's try that number 14. and there we have it so this is the number 14 and if i wanted to i could draw this number 14 so i can i can put this as draw false and then here i can write uh lm14 at one and two so this will be one and this will be two and i can make this really big so i can see what exactly i'm am i tracking and i can change the color of it so that it is a little bit different than all of these so i can put it as red and there you go so now you can see we are tracking this elbow so this is how easy it can be uh by the way whenever it finishes the video it will give you an error you can loop through that there's a function for that as well but we're not going to do that so this is the basic idea of how you can convert this into a module and now you can use this in any project that you want and you can easily find the position so how exactly can you do that so let's create a new file and we will call this our awesome pose projects so we will copy the parts from the main so as i said this is the testing code so we will copy all of that and we will paste it in our awesome project and now we have to import so we will write here import cv2 and then we have to import time and then we have to import our module so our module needs to be in the same folder if it's not in the same folder it will not work so you have to write import pose module as pm because it's a smaller name so we can write here pm dot pose detector so this will create the detector and everything else will run the same way so if we run this now our awesome projects and you can see it runs exactly the same way so now i can use this in many different applications so one thing we can do is we can test some other videos so let's say number two there you go again we are detecting the right elbow and you can see it's tracking really well that's pretty awesome even when it's a little bit hidden it's still tracking it that's really good and then let's try number three what happened to number three there is an error list index out of frame okay so yeah this is a problem because we are not checking uh if the list if actually the list is filled or not so we need to check if lm list is not equals to zero actually the length of it is not equal to zero if the length of this is not equals to zero then only we can do these two things so actually we should change that at the main module as well so where is it here so let's run the awesome project again and this time it works so probably the first frame it was not able to detect that's why it was giving this error so now you can see it's detecting that elbow let's try number four there you go detecting the right elbow very nicely let's try number five there we have it excellent the frame rate is amazing so you are getting real time number six pretty good and the best part is it's running on cpu it's not actually using gpu to run this so that is very good then we have number eights let's try that okay that looks good and then we have number nine so yeah that is pretty good so there are a few instances where it gets it wrong but overall you can see it's really good hey everyone welcome to my channel in this video we are going to learn the latest face and eye detection method that runs at an amazing 60 frames per second and all of this on an hd resolution this is a lightweight model provided by google so it runs on cpu and mobile devices as well so here we are in our pycharm project and the first thing we will do we'll go to file settings and we will go to our project and the interpreter and we will add so here we are going to add opencv dash python and we will also install media pipe which is the library that will help us detect faces okay so now both of them are installed and here on the side you can see that our project is called face detection project and then we have a folder called videos so let's open that up and see what it contains so here is the folder and we have a total of six videos that we are going to test on now you could do it on a webcam as well but i'm going to do it on a video because one it will be more clear and second with the webcam you will have a limit of the frame rate so with the videos you will have faster frame rates okay so we are going to right click and we will go to python file and here we are going to create our project so we will call this face detection basics so the idea is that we are going to look at the very basics the bare minimum code that is required to run it and once we understand that we are going to go ahead and create a module out of this so that we do not have to write it again and again for different projects so the first thing we will do is to import cv2 and then import media pipe as mp this is so that we don't have to write media pipe again and again we can just write mp and then we will import time this will be to display the frame rate so uh first of all we are going to run our video so we will write here cap is equals to cv2 dot video capture and we are going to capture from within our video folder so we will write here video slash one dot mp4 so this is the video that we will be using and then we will write here while true we are going to write success and image is equals to uh cap dot read so that will give us our frame and then we are going to write cv2 dot weight key as one and we will also write cv2 dot i am show we will write image and then image so this is pretty much you can see the boilerplate of our projects that we have been doing so we can simply right click and run this and we have an issue cb2 uh is it oh it's called videos it's not video okay so there you go so this is the video that we will be using and as you can see it is going pretty fast because it is running at a higher frame rate so you could reduce the frame rate from here for example if i put 10 you will see that the frame rate is uh it's much closer to real time but we are not going to do that instead we are going to display the actual value so to do that we will simply write here c time is equals to time dot time and then we will write fbs is equals to one divided by our current time minus the previous time and then we are going to write that our previous time is equals to the current time and then we can display it so we will write cv2 dot put text we'll put it on our image we are going to write fps oh i wrote it wrong f and then f p s and then we will write a curly bracket and inside that we are going to write integer and then fbs and what else then we need to define the position so let's say 20 and 70. and then we are going to write down the font so cb2 dot font let's take the plain one then we have the scale let's put it as three color let's put it as blue or green let's put it as blue uh two five five two five five zero and two no zero okay then we will write let's say the thickness and yeah that's pretty much it one more thing we have to do we have to declare the p time for the initial frame because it is not defined before and we are using it here so we need to define before that and all of this needs to be before the image show so we are going to put it down here and we can simply run this and see what happens there you go so you can see the frame rate is extremely high 140s 160s something like that um blue might not be the best color so let's put a screen let's try that yep that's much better okay so now that we have our frame rate by the way uh as i was mentioning before you can reduce the frame rate from here let's say i put 20 so now you will see that yeah it's much closer to real time it's around 30 something 40. by the way this video is a slomo so that's why it looks a little bit slower because the video itself is a slow motion video so if i open it up and i play this you can see this is actually a slow motion video okay um we could use the second one as well yeah this one looks real time or it's hard to tell okay um we could try it with the second one here let's see how that works out yeah it's it's not real time either okay so uh anyways so that's the idea so we will keep it as one because we are going to process it and hopefully we are going to get a good frame rate so you can see it's quite fast so what is the next step the next step is to import our media pipe functions or classes so that we can use them so here what we will do is we will use the face detection module so we will write here mp face detection detection is equals to mp dot solutions dot face detection detection yeah okay so then we need something to draw now we can draw ourselves as well but we can import the drawing part here as well let's say mp draw is equals to mp.solutions solutions and then draw drawing utilities okay so basically this will allow us to draw without going into the details but if we want to draw ourselves we can do that too because the rectangle drawing rectangle should not be that hard but we are getting a few points as well we will be getting six points so for the eyes and the nose and the ears so we could we could simply draw them by using this okay then we are going to write face detection is equals to mp face mp face detection dot face detection so this basically initializes that we are going to use a face detection again my spellings are wrong to fix that okay so then we can simply go and this is an bgr image so we need to convert it into rgb before we do that before we send it to the media pipe library so we will write here image rgb is equals to cv2 dot cvt color and we will give in our image and then we will write cv2 dots color underscore bgr to rgb to rgb okay so then we will write here that our results is equals to face detection dot process and we want to process our rgb image so this is the idea whatever the the output is it will be stored in the results and then we can process these results so we can print this out we can write your results and let's try it and see what happens there you go so now all of a sudden you have seen that the frame rate has decreased so if i don't run this and i don't print this you will see that the frame rate is very high but as soon as i run it the frame rate reduces to around 60 70 i can even see 90s so yeah so it means it's working at the back end and it is giving us a class so they have their own class by media pi python solutions so what we need to do is we need to know how to extract the information out of this so we are going to do that next so here we are going to write so it can be multiple faces actually let's go to a video let's go to the first video again because it has multiple faces so we will check if the results dot detections detections is available then we are going to write for id and then detection detection in results dot detections the text actions okay so we are going to find in that but it should be enumerate because we want the id number as well so we will write this and then we can loop through each one of the results and we can display them so we can write here print detection so whatever we have it is being processed here and what we can do is we can display it with the id so we can write id and then it will show us the detection so let's run that okay there is some issue here where is it results start again the spellings the detections okay so if i close this and if i go up here you can see these are the key points so here it is saying that this is detection number one this is id number one and they have given it a label of zero this is the score this is 91 percent sure that it is a phase then there's location data within it which means the bounding box and then there are key points so one two three four five and six key points so you can use these key points as well but we are more interested in the face itself so here you can see this is zero this is face number zero and this is face number one so the label id is same because both of them are faces and here we have face number one and here we have face number zero so now we need to know how to extract this information so we already know that this is a class so what we can do is we can for example if we wanted the score we will write detection dot score so if i write here detection dot score that will give me the value of the score so i can print that out what happened there so if i print that out you will see i'm getting the detection by itself so separately i'm getting the value so i can get that then how can i get the for example the x minimum so this is the x y position that we want so to do that you can see that we have first of all location data inside location data we have relative bounding box so we need to write that so we will write here print we will say location data first default detection detection dot location data and then we will write dot relative bounding box so that should give us the values so let's comment these and let's run this and there you go so now we simply have the information of our bounding box okay so that is good now what else can we do now the thing is that these are uh you can say normalized values so they are normalized between 0 and 1. so what we need to do is we need to multiply them with the width and the height to get the pixel values so we can draw but before we actually go into the drawing we can also draw by the function that they have provided so that function is mp draw dot draw landmarks or draw detection and then we have image and then we have the detection so yeah that should draw the faces for us there you go so now you can see we are getting the points and we are getting the faces uh the bounding box around the faces now the thing is for me the the points are not very accurate i don't see them being useful you can see sometimes maybe you will get a better result maybe let's say video number two let's try that yeah here it's a little bit better you can see the eyes and the nose and let's try number three yeah here for the baby you can see it's quite good so again if you want to use the points then you should make sure that the video is quite zoomed in the focus is on the face so if you want that you can use the points for the eyes and for the nose and for the ears so the same way we got the information of the x and y and the score the same way you would get the information of the landmarks but i'm not going to go into the landmarks i will just keep on the bounding box we will focus on the bounding box and we will also focus on the score so these three things are what we are interested in if you want more you can add on to it so now that we know how to draw this uh what we need is we need to draw ourselves we need to get the bounding box information so that if we want to use it um just the numerical values we should have access to those so what we will do is instead of using all of this so if i wanted if i wanted the value of x minimum i would have to go inside this as well and i will write x minimum here now that is a very long call for just one value so we need to shorten it so that it is easier to work with so what we are going to do is we are going to store all this information in a bounding box and from that we are going to extract these information we are going to multiply so what do i mean by that let's have a look so we will say that our bounding box coming from the class is equals to detection all of this detection dot local location data relative bounding box all of that so that is the the bounding box coming from the class that's why we wrote c in front of it but then we are going to convert it in our own language so that we can work with pixel values rather than just the normalized values so we will call that the simple boundary box without the c and what we need to do is we need to write here that our bounding box c dot x minimum multiplied by our width now but we don't have the width so what we will do is we will write up here that our image height then our image width and our image channels is equals to image dot shape and then i can use here i width image width by the way this i here is not a big deal because defining variables is about scope where is it being used if it is being used in a lot of different places it has a very wide scope maybe it's being used out of the function out of the loop then yes then you need to define long names that are clear like here location data relative bounding box and what not but if you are using it in a small scope for example when you use for loops you write for i in range right so why did you write i you wrote i because you are not going to use that i outside this for loop the scope is very limited so if you are writing i w i h or even wh it's not a big deal so then we are going to convert this into integer and then we are going to copy this and here we are going to write that we need the y minimum and we are going to multiply this with the height so that's the idea and then let's go to the next line so we'll put a backslash and then we will copy this and here we are going to write width and we will keep it iw and here we will write height so now our bounding box will have x y and width and height so we can simply use to draw this uh using a rectangle function or we can use these values outside uh in our project so that should be good so what we can do is we can write here cv2 dot rectangle and we will put the image and we will say the bounding box we can simply feed in the value because it contains all the four values it will understand and then we will let's make it purple zero two five five and let's make the thickness of two so that should be enough let's remove this so note that we are not drawing by default so we are not using the default function to draw we are drawing by ourselves so let's run that and there you go so now we are getting a clean box a bounding box that is quite nice there you go you saw here yeah you can see here we are getting some false detections as well so what you can do is you can you can change the uh what you call there there is a parameter here minimum detection confidence so you can change this so you can write here it's by default at 0.5 you can write let's say 0.75 hopefully that will remove that there you go so now you don't see the false positives okay so that is good now what else can we do so this is quite good and the only thing we might want to see is the confidence value so the confidence value or the score as i mentioned you can get by detection.score and we can put it let's copy this we can put it on the bounding box and here we can write for example that we have let's keep it integer we have detection dot score and we are going to get the first element of it uh if you don't get the first element it it will just put a bracket around it so it has only one value but it will put a bracket around it so we are just removing that bracket and we can multiply it by hundred so that it is a percentage and we can write outside that this is a percentage and we don't need to write anything at the beginning and the location should be bounding box at zero bb ox at zero and then bounding box i think that is way too much okay let's bring that down too so bounding box bounding box at one but we are going to subtract 20 from it so that um it is easier to see it is not overlapping with the box okay so let's run that and see if it works there you go so we are getting 90 something percent of uh score the confidence level so i think it should be the same color so it looks blended in so we will put it here two five five what else i think the size was big too so we can change it to two yeah that looks much better so let's try out the first video there you go so that's pretty good we are able to detects with the score and with the bounding box value so now this is good but the problem is that you can see that there is quite a bit of code that you have to write to find the face and to get the values that you can use so what we can do is instead of initializing and writing all of this code again and again for different projects what we will do is we will create a module out of this so that we just import that module and use it whenever we want okay so how can we do that so we are going to go to python file and we will call this face detection module and here we are going to copy all of our basic code now the first thing for the module we need is our if statement so if we have the name underscore name is equals to main so this means that if we are running this file then we need to run main so whatever is in main is like the dummy code it is kind of a hint that this is how you can use this module so we are going to declare here that this is main and inside main we are going to write our while statements so so yeah let's copy this part we will paste it in the main then we have the while so we will just read the frame and then we have the ending part we will put the frame rate as well over here so yeah that should work fine then we are going to okay so then we are going to create our class so we are going to call this face the tech tour and we are going to define our initial function uh initial method in it and then inside that we are going to write um okay let's let's leave it for now or let's write it that's all right minimum detection confidence the the tech shun confidence okay that should be fine and we will give it a default value of 0.5 now the thing is that we need to put everything which is related to initializations over here inside so we will take this and we will put this in and we will remove some spaces first of all we need to write here self dot minimum detection confidence is equals to minimum detection confidence so in in objects or in the classes all we need to do is we need to write here self dot and here we will write self dot self dot and self dot so it is not a generic variable or a global variable it is now an instant variable so whatever we are defining is for this class or for this object so that's why we are writing self okay so that is good now we need to define another function or a method called find faces and we need an image do we need anything else we can put a flag of draw so draw is equals to true by default so we are going to put all of this in and let's see what do we need to change first of all we need to write the self dot so here we will write self dot face detection and then we will also write self dot results self thought results in case we want to use it later it's not really required at this point but anyways so we will comment this we can remove all of this and what else okay so now we need to return something so we are finding the faces that is all good but we need to return all these faces so what we will do is we will return the bounding box information the id number and also the score if you want to return the landmarks you can return that to here so what we will do is we will create a new variable a new list and we will call it bounding boxes plural so we will make it empty and all of this is being done for one phase so it is showing and it is processing face by face so what we need to do is whenever it processes we need to put that in our bounding boxes so here when we have our bounding box value then we can send in whatever we want so in this case we are going to send bounding boxes dot append and we are going to append uh first of all the bounding box and then we are going to append the uh detection dot score so if you want you can append the id as well but normally it is the same uh what you call it will have the same list number the index of the list so it is a bit redundant but anyways if you want you can add this too so this is the idea then we simply return these uh bounding boxes so we return bounding boxes and we also returned the image that has all these detections on it so that is the idea so by now we should have it running let's try it out so we are going to create an object from our class we will call it detector and we are going to write that our face detector we are not going to give in any value so by default it's 0.5 we will keep it 0.5 so once we get the frame we are going to write here image is equals to detector dot find faces and we will give in our image and we will keep it the draw as default so that is good now if we run this it should pretty much run the same way as it did before and there's an error so inside of main okay so here we are facing an issue with the bracket probably what is it image this is fine i think it seems fine to me let's go here and copy this yeah it's exactly the same so it should work uh the error is not here it's probably because it's not finding the image okay let's remove this part and try it yeah it is about the image it's not able to get the video why are you not able to get the video um are you not able to get videos1.mp4 okay let's remove this as well okay i get it my bad there are two parameters that needs to be returned so we need to write here bounding boxes yeah that was the issue so let's run this and there you go now this is the module yes this is the module running okay so that is good now it is running and okay it's not detecting properly why did we change the we can we can change the value here so maybe let's say 0.4 but it was working before yeah here it's 0.75 that's the issue so we need to put this here minimum detection self dot minimum detection okay so that is good now we do not need to do 0.4 here it by default at 0.5 so it should work fine there you go so now it is detecting properly okay so that is good now it is working as a module and we can get the information by the way you can just print here print the bounding boxes and let's see what do we get there you go so now you're getting the information so this is face number zero this is the bounding box this is the confidence this face number one bounding box and the confidence so you can extract this information and use it very easily so by now we are pretty much done but i want to do something else now this is you can say kind of a fancy thing if you want to do this you can add it but it is of course not necessary so what i want to do is we are always showing these bounding boxes uh the same way we are just drawing a rectangle and it's very plain it doesn't look good this is a new method so i want to show it in a new way so what can we do so what i was thinking is that we can put some corner what do you call lines a little bit thicker so that will give it um that will give it an image of like a target so whenever you have a target you have these edges that are thicker and then you have the bounding box in between something like that so let's try to add that here so what i will do is i will create a new method here and i will call that um let's say fancy draw instead of regular draw we are going to do fancy draw so we are going to write here that we need our image and we need the bounding box so uh we will do one at a time so just send us one bounding box and we will put the bounding box around it then send the next one and then so on it will not take an array okay so then first of all we are going to open it up we are going to extract the information from it so we are going to write here x y width and height is equals to the bounding box and then we also need the x1 and the y1 which is basically equals to the diagonal point so x x and y is the first point or you can say the origin point and then x1 and y1 is the bottom right point so the corner points at the diagonal position so rather than calculating it again again we can just define it right now so we can write it as x plus width and y plus height so now we have all the information we need now we can start drawing the lines so here we will write cv2.line and inside the line we need to send in our image and then we need the starting point so i will say the starting point is x and y then we have the x plus a certain value so this is the length of that line so let's write here length is equals to let's say 30 we will write here length and then we are going to give in the value of y so y will stay the same so then we will give it the color the color will be the same as the what you call rectangle so we will write here two five five zero two five five and here we have to write the thickness so let's write here that this is the thickness is equals to let's say 10. so i will write here uh sorry t so uh it might be a little bit confusing at this point but let me show you how it works so let's remove this rectangle from here and i will put this here rectangle and then i will write here fancy self dot fancy draw and i will give in the image and the bounding box so that's the idea and it will return the image so we can write here return image return image okay so let's run this and see what happens so there you go so now you see there's a thick line on the corner now we need to draw the line at the bottom so let's draw that so we will copy this and we will paste it here now this time around the x will be without any extra value no length for the x we will add the length to the y so if we run it again now you see we have a corner point so we have a corner we have two lines at the corner so what we need to do now is we need to replicate this on the others i think the thickness for this should be one we can give it let's say rectangle thickness is equals to one and we can put here rt uh let's run that yeah this looks much better okay so and even the thickness for this is too much let's put it as seven let's say yeah it's getting better maybe five yeah that looks good so next what we can do is we can write here that this is for the top left which is basically for x and y okay this is the point x and y then we will copy this and we will paste it here and we are going to say that this is for the top right and now our position will be x 1 and y so we will just change this to x one and that should work fine x one and y yeah so one more thing is that if i run this now you will see the issue it is going outwards we need to bring it inwards so how do you bring it inwards you simply subtract the length instead of adding in the x direction so there you go so now it's inwards and it's done so we need to do the same for the next two so we will copy this and we will paste here so for the bottom left and then we have the bottom right so for the bottom left we will have x and y one so we will just replace this with y one y 1 everywhere and then this will remain positive but this will be negative again you can play with these and you can see if it gives you a problem then you can replace it if you don't understand it directly so this is the third one and then for the fourth one it will be x1 and y1 so we will write here x1 and y1 and the values will be both minus so both of them will be inwards there you go so now it looks much better than just a rectangle drawn around it so and yeah one more thing i forgot to add is the condition for drawing so if we want to draw or not so here i can write if draw then we do this otherwise no need so if i run this it will draw if i go back here and where is it here and if i put this as false it will give us the values but it is not going to draw oh what is that uh we didn't put that in the draw yeah this needs to be in the draw there you go there you go so now it's not drawing anything at all and if we go down and we write here nothing then it will run because by default it's true so as you can see now we have our face detection which is running almost at 60 plus frame rate which is pretty amazing given that we are only using a cpu and this is an hd video so it is 1280 by 720 if we are running even lower than this for example 640 by 480 the frame rate will be crazy high so you can keep that in mind let's try this one it's pretty good let's try how many do we have we have six videos let's try all of them this is number four it's pretty good and you can see here see that's the thing with our cascades that it does not detect on the sides so if you rotate your face it will not detect at all but this one does so that is pretty cool there you go oh this kid is really enthusiastic then number six there you go so even on the side but if it's gone too far maybe it will not detect but here you can see it's blurry and it's on the side and even then it is detecting uh quite a bit that there is a person there so that is pretty amazing hey everyone welcome to my channel in this video we are going to learn how to detect 468 different landmarks on faces we will use the model provided by google that runs in real time on cpu and on mobile devices so here we are in our pycharm project and we have created a new project called face mesh project now we have a special folder here by the name videos and if you go inside you will see that we have a couple of videos in fact more than a couple you can see here that we have a total of eight videos and each of these videos they have a different size so they are not actually the same width and height you can see this one is smaller so the frame rate might vary based on the size so let's try this one yeah this one is quite i think this one is hd or even full hd probably so yeah so these are some of the videos that we are going to test on so what we will do is we will right click and we will create a new python file and we are going to call it face mesh basics so what we will do is we will learn the basics and once we know the basics we are going to create a module out of it so that we don't have to write it again and again for different projects so the first thing will be to install our libraries we will go to file settings and the project interpreter and we will add the opencv python and we will also add media pipe which is the library provided by google that we will be using to detect all these different 400 plus points on the faces so one of them is already done the other one is also done great so now we are going to import cv2 and then we are going to import media pipe as mp and then we will also import time to see the frame rate so as always the first thing we will do we will run our video and we will use cap is equals to cv2 dot video capture and we are going to give in our video path so here it is in videos videos slash one dot mp4 let's use the second one because the second one has two faces in it so that will be better when we are testing okay so then we are going to write while true we are going to say uh success and image is equals to cap dot read we are going to read our image and then we will say cv2 dot i am show we will say that it is an image img and then cv2 dot weight key as one so that is pretty much it so let's run it and see if it works and there you go so you can see the video is now running and we have two faces uh the first one i believe has only one yeah and it is quite big so it is i think hd i mean full hd so let's try let's work on number two and later on once we are done we can try number one number three four five and so on okay so the next thing we will do is to write the frame rate so here we are going to write c time is equals to time dot time and then we are going to write fps is equals to 1 divided by c time minus p time so p stands for previous c stands for current time so then we will write that our previous time is equals to current time and up here we are going to define the previous time is equals to zero so that should give us the frame rate and then all we need to do is we need to put it on our image so we will write put text on the image and we are going to write fps and in the curly brackets we are going to write integer of fps and yeah that should be it and then we have to give in the location so 2070 and then we will given the font cv2 dot font let's give it a plain font and what else then we will give the scale then the color we will keep it as green and then we will give in the thickness so yeah that should be enough so let's try that out and there we have it so now we are getting the frame rate it is quite high at the moment okay so that is pretty good we can bring this down now the next step would be to use our media pipe library to actually find the points the different points on the face so what do we need first of all we are going to write here mp draw is equals to mp.solutions solutions dot drawing utilities so this will help us draw on our faces now we could draw ourselves as well but the thing is that when they are using their own function they actually make some lines in between some connections between these points and that is quite complicated so rather than doing it manually we could use their function for displaying purposes but if you just want to see the points you can just draw circles by yourself as well i will show you how to do that as well okay then we are going to write mp face mesh is equals to face mesh is equals to mp dot solutions dot face underscore mesh so we will be using uh this to actually create our face mesh so we will write here face mesh is equals to mp phase mesh dot face mesh i know it's quite a bit of repetition but this is what we need to actually create our object and from where we can actually find our faces so then inside this if i press the control button and i click on this it will take me to the function itself to the class face mesh and here it will tell me that what is the what are the input arguments so here we can see its static image mode is false then we have the total number of faces then minimum detection confidence and the minimum tracking confidence so the static image is whether you are using it only for detection or you are using detection and tracking so if it is a static image mode it will always detect in each and every single image but if it is false then it will detect and then it will track so detection is always heavier than tracking so therefore we will detect first whatever the confidence is above 0.5 which means that it has found the probability of 50 for a face then we are going to detect and then we are going to keep tracking that face if the tracking confidence is higher than 50 as well so we can change these parameters as well but for now we are not going to do anything here uh actually we can change the maximum number of faces because uh we want to detect two faces so here we can write max number of faces is equals to two uh the rest we can keep it as it is so then we are going to go down here and this actually accepts this class actually accepts only an rgb image so we have to convert it so here this image is bgr so we will convert it so we will write image rgb is equals to cv2 dot cvt color and then we will write image cb 2 dot color underscore bg r to rgb so that is the idea and then we can simply write results is equals to face mesh dots process and we are going to send in our rgb image so that is the idea and now what you will see is that the frame rate has dramatically reduced there you go so now we are getting right 50s to 60s which is actually quite high considering that i'm only using cpu but if we do it on the first one uh it will be slower because that is full hd video yeah so it's around 40s and if we are doing it on an hd video then it is around 60s so that is pretty amazing okay so that is good and now we are getting some results but now we need to display them so to display them we are going to write if results dot multiface multi underscore face underscore landmarks then if something is detected then we are going to go ahead and draw but the thing is that you can have multiple faces here so you need to loop through the faces before we actually draw so to do that we will write here for face landmarks let's say face landmarks in results dot multi multi underscore face underscore landmarks we are going to go ahead and loop through that and for that we are going to now draw we will write here mp draw dot draw landmarks and then we are going to give in our parameters so if we go over here you can see that you have the image you have the landmark list you have the connections so here first of all we will give in our image then we have the landmarks which is basically your face lms these are the face landmarks and then the connections so we are going to write uh mp face mesh dot face connections so let's try that out let's move it a little bit here okay let's try that out and there you go so as you can see now we are getting the faces and both the faces are being detected and if you go back and you write here one you will see that only one face is detected there you go and you can see how fast and accurate that is which is pretty amazing to see okay so what if you want to change the size of let's say the thickness of the circles or the thickness of the lines around it so what what if you want to do that well to do that you can write here some specifications so you can write here draw no not mp draw draw specs is equals to mp draw dot drawing specifications and there you can write that my thickness is equals to 1 and my circle radius is equals to 2. let's see because i'm changing right now i think initially it is 1 1 or 2 2 something like that so we are changing it a little bit so that we can see an effect so once we do that then we will go to our mp draw over here and we are going to write our specifications here so we will say that landmark landmark uh drawing spec i think it is the next one so we can directly write yeah so these are the next two parameters so we can directly write them so we can write here that it is draw specs and then again draw specs so let's run that and there you go so now you can see it has changed and um let's say i increase the radius like dramatically let's put it five so there you go so now you can see all these weird points and let's see let's increase this as well to five and there you go so now it is completely blocked so anyways you get the idea so you can put one one here one one with an hd video is fine you know it looks good but if you have a full hd video then one one is is way too subtle at least to me like i can't really see the points here so if you put maybe two and you put here two then it is more visible yeah something like that so anyways you can play around with this all day and you can see which one suits you the best so this is basically the the basic idea of how you can draw now that is all well and good but in reality when you are creating a project you need to use these points you need to know their positioning to actually use them in a project so how can you get the actual points now there are a total of 406 points so that's a lot but what we can do is we can at least look at them and we can maybe number them maybe you don't know which one is which so we can put the numbering over there to see which is the nose which are the starting of the lips starting off the eye edge of the eye and so on so how do you get these values so what we will do is now here we are getting into one face so face lms is the landmarks of one face now in order to now in order to get further deep and find out all the different points we are going to add another loop so we will write here for lm in face landmarks dot landmark we are going to get each of these landmarks and we are going to print it so we are going to write here print lm so if i run this now you will see these are the landmarks so you get the x position ui position and z position so this is the basic idea so now these landmarks we are going to first convert them into pixels so that we can use them right now they are normalized from zero to one so we are going to write here i h iw and ic i stands for image image height image width image channels is equals to image dot shape so when when we get the shape now we can multiply it with the normalized values to get the actual pixel values so what we are going to look at is the x and y if you want the z as well you can add that as well but i'm going to write x and y only so to get the x and y value all we have to do is we have to write l m dot x and then we have to multiply it with the width and for the height we will write lm dot y multiplied by eye height so that is the basic idea so now we have our values uh in terms of pixels and we can do whatever we want with them so let's first of all print them out so we will write here x and y and we can comment this part so let's run that and if we go back you can see these are the points that we are getting so if we want to get the id for it well we can put it in a list and we can check the index of that list but if you just want to look at it you can write here enumerate and here you can write id and what you can do is you can write here id so that will give you the id number and then it will tell you the actual value so here you can see it starts at or does it start okay it starts here at zero and then all the way it goes till 467 so we have a total of 468 values and each value has an x and a y point so a y x and a y number so here what we will do is we will put this in a list so what we can do or or let's let's keep it still here and then now what we can do is we can create this into a module and in the module we are going to put it in a list and we will return something so let's keep the basics still here that we are getting the numbers and everything and yeah that should be good so let's run it for two phases and let's run it with video number two there you go so if we go down here you will see a lot of values being generated that's good we could also add uh an enumerate here and we could write which face number are we talking about face number one or face number two but uh let's let's forget that and let's go ahead and do the what you call module so the idea of the module is that once you create the module you don't have to write all of this initializations and all of this conversions again and again so all you need to do is you need to call that function or that method within our class and that will do the magic for you and it will return you the values and you will be happy to work with it so how do we do that we right click we go to new we create a python file we call it face mesh module module okay so what we will do is we will go ahead and copy all of our code and now we are going to convert this into a module so for the module the first thing we have to do is we have to write what to do if you are running the module by itself so we will write here if underscore underscore name is equals to underscore underscore main then we are going to run our main function and we will define our main function here main and we will write down our loop inside it so we will copy this part actually we will cut it and we will paste it here and then we will go here and we will cut this and we will paste it here and what else we will cut this and we will place it above the while so that gives us the initial part so if we were to comment all of this and if we were to run this it should run so let's try that there we go so this is like we are starting from the scratch um okay so then we are going to convert it into a class so here we are going to write class is equals to face mesh detector you can write a better name probably but we are going to use face mesh detector and then we are going to define our initial method uh for initialization and we are going to given some parameters now these parameters will be the ones that are uh where is it this one so for the face mesh so whatever parameters we have here we are going to give in to our object so let me write down here so we have static image mode so we will write here static mode is equals to false so this will be by default false and then max faces is equals to 2 by default then minimum detection confidence is equal to 0.5 and then minimum track confidence is equals to 0.5 so we are going to write these and then we have to tell that these are the values of this instance so we will copy this twice then we will copy this again we will copy this again and we will copy this again so here we will put equals to equals to equals to an equals to and here we will write self self dot this so we will copy that self.self.self. so if you are not familiar with this i would highly recommend that you check out uh object oriented programming uh the basics of object oriented programming so then we are going to uncomment this and we are going to write self in front of each of these and then we are going to write self here as well and here in the max number of faces and all of this we need to write our new variables so here we have self.static mode self dot faces then minimum detection let's write it in a new line and then minimum tracking so that is the idea so that is good for initializations uh this if you want to make it a parameter here as well feel free to do that i think it should be fine without it okay so next we are going to write a function called or a method called find mesh face or faces i don't know find face mesh let's say face mesh and then we will write of course self and then why is it not okay the indentation is wrong it should be here okay so then we are going to write image and draw so we will have a option to uh draw or not draw so it will be a flag so we can uncomment this and we can go back up here and then we will see what is missing so this indentation is wrong so we need to go back okay so then we will just copy this self dot and again we will start putting the self dot everywhere and self dot results uh self.mp draw whatever it's giving an error just put a self dots okay so that is good and wait what happened here i need to go back okay so that is good and now we should be able to see our results without going into the returning part we should be able to see the result but we didn't create an object or we didn't call the find face so it will not do anything so we need to do that we will write here detector detector is equals to uh face mesh detector and then here we are going to write here that our image is equals to detector dot face mesh or is it find find face mesh here find face mesh and we will give in our image and we will keep its true for the drawing part and here we are going to return our image so we will write here return image so that should be good and let's see if it works there you go so now it's working as an object but the last thing we have to do is we have to convert this so that we are getting our values in return so that's the main thing so and again the drawing part again is optional so we can directly put here if draw then do this so if i run this now it should draw if i go down here and i write here false false it should not draw it will work but it will not draw anything so that's good okay so what is next yeah so now we need to uncomment this and for every face we are going to go through every landmark and through every landmark we are going to convert it into x and y and then we need to store it so where do we store it we store it in let's say a variable called face so this will be a list so we will store it in list face dot append and we are going to append the x and y so this will be the x and y value now that is good for one face but we have multiple faces so what do we do we create another list we call it faces plural and this time around we append after the loop we append faces dot append face so basically when we are looking for the landmarks we append the landmarks in the faces and then once we have that face with all the landmarks then we append the faces so that we get the final result so that is the basic idea actually let's put it outside so it doesn't give random error that uh it has been used before declaration so yeah so in any case we are going to return faces so even if it's empty it doesn't matter we are going to return it so that's the idea and then in the image here i can write here faces and that should return the faces um what we can do we can print here so we can write here if the how can we write this uh the length of faces but if we write the length of faces it will be yeah it will be something okay yeah that should work if the length of faces is not equals to zero then we are going to print the length of faces let's say so let's see how many faces do we get okay we are printing a lot of things that's why we are not having a clear picture so yeah let's run it again there you go so now it is showing one face and why is it showing one face because we put we put maximum two phases why is it showing one that is weird max faces is two did we say something here are we running the module yeah we are running the module still saying one okay let's see why does it say one so it should be four oh this should be inside the loop my bad so now it should work there you go so now you have two faces being detected and if we go to video number one uh where is that with your number one then it will be one face so you can see here it's only one face so that is the idea and then what we can do is to check whether we are on the uh correct path or not we can write here faces at zero let's see what does it print so oh actually it's printing the length no no we yeah actually it's good to see that it has 468 points so that means we are getting all the points that is good but now let's print all the points it will be a long list there you go so now you can see these are all the different points that we have so this is quite good okay so one more thing we can do now if you're not familiar with which point is which number then what you can do is you can print the id number over here so you can write that cv2 actually we wrote it somewhere yeah why write it again if we have it already we can write here that cv2.put text and we are going to put the text of our id so let's just write here string id and where do we need to put it we need to put it at x and y so this is the x and y position uh 3 is way too big so we are going to put it as 1 1. let's see how that works out so this is going to print out the id number of each of the points oh boy okay so it's like a matrix okay so that is bad um maybe we need to look at a video that is uh more focused on the face doesn't have a lot of other stuff let's see maybe this one maybe this one will be better let's try that this number six there you go so now it's much better so still not that good we uh first of all let's let's change the maximum to uh max faces is equals to one so we only look at one face and then let's put this as 0.5 okay it's going to the kid i was hoping it will attach to the elderly person but no it did not happen okay let's keep the maximum faces as 2 and let's make this even smaller 0.3 let's try that no that's not readable 0.5 is let's try that again okay so i can see 1 is here 4 5 then it goes to 195. 151 9 8 so yeah it's a little bit harder to read still 1.7 yeah now it's a little bit better here at the edges you can see very clearly what are the points numbers so 21 54 103 is 67 and so on but in the middle area especially with the nose i think one i can see one here so one is the nose uh the center of the nose let's let's try another video hopefully we will get something better so number by the way you can read all of this in the paper so if you go to media pipe website they have a paper listed there and if you go in the paper you will find these you'll find more information on these points so yeah now it's hard to see with this uh maybe if you have just an image and you apply that apply this method on the image and then you scale it up to see the numbers maybe that will work so anyways this is the basic idea of how you can detect 468 points on a face and that running on a cpu all of this running only on a cpu so that is a pretty amazing task and the results are pretty good you can see let's try out different videos so we have video number one you can see it is pretty good video number two actually let's let's uh remove this part let's remove the id and uh let's keep its normal yeah so let's try it again wait what happened there uh oh yeah the draw is false so we need to remove that there you go that is pretty good you can see it is very smooth it's very smooth yeah then let's try number three there you go even when the faces are a bit far it is detecting quite well number four that is good okay when it goes to the side it disappears and that is understandable then let's try number five this seems like a like a zoom meeting yeah could be used in that with the frame rate we are getting it could be used in a zoom meeting okay let's try number six there you go uh it's flickering a little bit here maybe because they're merging the faces at some point yeah probably because of that then let's try number seven how many do we have eight yes okay that's good okay when she goes down then uh of course it will not detect but as soon as she gets back up uh the face is detected there you go the person is laughing and you can see that that is pretty good okay so this is it uh for today's video i hope you have learned something new if you like the video give it a thumbs up and don't forget to subscribe and share it with your friends and i will see you in the next one hey everyone welcome to my channel in this video we are going to learn how to use gesture control to change the volume of a computer we will first look into hand tracking and then we will use the hand landmarks to find the gesture of our hand to change the volume this project is module based which means we will be using a previously created hand module which makes the hand tracking very easy so here we are in our pyjama project this is the same one that we used in the previous video so in the previous video we learned about hand tracking minimum code the bare minimum code that is required to run hand tracking and then we created a module out of this so that we don't have to write it again and again we can simply import this module and run it as it is now if you haven't checked this video i highly recommend that you go and check that video out first and then you can come back here and we will continue with the uh hand tracking project so the project that we are working on is the let's call it volume control or let's call it volume hand control so we are going to control the volume of our computer with our hand so that is something very interesting now the first thing is that we will go to file and we will go to settings we will make sure that our uh libraries or packages are installed so we will write here opencv python so this is the first one that we need we will hit install and then i've already done it that's why i'm not doing it then we are going to write media pipe and we will click on that and we will hit install so these are the two main libraries that we need for now and later on we can check what we need uh afterwards the first thing you have to do is you have to import your packages so we will write here import cv2 then we will import time and then we have to import numpy numpy as np so these are the basic packages that we will be using later on we will add some more as well so the first thing we want to do is we want to check if the webcam is working and everything is running fine so we will write here that cap is equals to video capture cv2.videocap and we will write the id number so i'm using id1 most probably you will need id 0. then we will write while true we are going to check the success of the capture and then we will write image and then we will write cap dot read so this is the main idea and then we will write cv2 dot im show we will write the image and then img and then we will write cv2 dot white key as one so that will give it a one millisecond delay so this is looking good let's run it and see what happens there you go so this is my hand that we will be tracking and we will change the volume from and this is our webcam so what can we do okay one more thing we can do here is we can write here let's say this is the part where we have our parameters so we can write here that our cam width let's write width of our camera and the height of our camera is equals to 640 by 480 so we are basically defining it here and then we can use it here we can say cap dot set prop id number three is width so we will write with cam and then prop id at number four is height cam so we can write height gap so that should be good and let's try it with the different value 1280 by 720 so this will make it a little bit bigger yeah there you go so but we are going to use 640 by 480 instead okay so that is good what else can we do we can add the frame rate so here we are going to write that our current time is equals to time dot time and then we have the fps is equals to 1 divided by our current time minus the previous time and then previous time previous time is equals to current time so we can define the previous time as 0 over here and what else so now we can put this fps on our image so we can write here cv2 dot put text and we will write image and then we will write f p s and we will write the value of the fps let's say integer fps because it's decimal we don't want decimal places and then we can write the the location 70 and then we write the font so we can put any font that we want and then we will write the scale and the color so let's write two five five zero two five five and then we will write the thickness so that should be good so let's run this and see if it works oh it does work but looks really bad okay so first of all the color is bad so let's change it to blue so we can remove this and then let's try the blue color first yeah the blue color is much better then we can make it smaller it's really big so scale let's put it as one yeah that seems good thickness thickness is fine i think it's fine we can reduce a little bit but and then we can push it up a little bit let's say 50 yeah now it really looks good and in the correct place okay so now that we are all set now we will do the magic part the magic part here is that we already have our hand tracking module so we don't have to write a lot of code we will just use its functionality and we will be able to get our hand very quickly the landmarks of our hand very quickly so we will write here imports hand hand tracking module now if you don't see hand tracking module that is because you need to put it in the same folder as your project so if it's in the it's not in the same folder or if it's not even here then you will not be able to use it so you need to make sure it is in the same folder and we can import it as something else hdm let's say hand tracking module because we don't want to write that complete name it's quite big okay so then we will create an object so this is a class inside here we have a class where is it here hand detector so we will uh create an object from it we will call it detector detector is equals to uh what was the name htm dot hand detector and then we have our default parameters already here so we don't need to write anything for now so we will keep it like that and then what else can we do then after doing this we need to find the location or we need to find the hand so we will write here that detector detector dot find hands so this is the method that we created so this is this method find hands and all we need to do is we need to send in the image so this will give us the hands so we want to draw it so we will not put it as false we will keep the draw as true and it gives us the image back so we will accept that image back again so that is pretty much it so we can we can separate this code not too much we can separate this code so that it is easier to read so now we can run it and see if it works and there you go so now we are getting good detection and it seems quite good so what happens sometimes you can see it detects a little bit on the side and then it detects small hand as well so what we want to do is we want to change the detection confidence here so at default it is 0.5 so the detection confidence is 0.5 we wanted to be really sure that it is a hand and then only detect the hand this way when you are changing the volume it will be a little bit smoother because it will not flicker too much so we can right here detection confidence is let's say 0.7 so you can play around with this value if you want but i will keep it at 0.7 yeah seems fine to me and then we are going to go to the next part which is the best part of getting the position so now all we have to do to get this position is to write that our landmark list is equals to detector dot find position and then we just send in our image that's it uh and we will also write draw is equals to false we don't want to draw it because we are already drawing it so we will keep that as false and now let's run it and there you go we are getting it but i forgot to print so print lm list so let's run that and there you go so at the bottom you can see that we are getting that list so here we are getting that list and we have a total of 20 values here uh 21 values because we are counting 0 as well so we have a total of 21 values now if we want to get the value of a particular point then we can write that point itself so here for example we need point number two so this is the landmark number two so if we run that again okay so this is a good point we are getting an error because the index is out of range so before we actually print or before we actually do anything related to the points we have to make sure that there are some points so we will write here if lm list the length of it is not equals to zero not equals to zero then we are going to do this otherwise it will skip it so let's try that and there you go so now i'm only getting landmark number two so this is good but how do we know which landmark do we need so here is the media pipe website and they have given us the landmark model information so these are all the values that we get all the landmarks that we get so here we will need the value number four which is for our thumb and we will need the value number eight which will be for our index so we need the tip of both the thumb and the index so we will go back here and here i can write i need the value number four and i need the landmark list i need the value number eight so this way we will get only these two values there you go so now i have these values and you can see they are changing but to make sure that we are using the correct ones we are going to create a circle around them so we will write here cv2 dot circle and in the circle we are going to say that we want to put it on our image and then we have to give in the center value now here what we can do is we can create some variables so that we don't have to write all of this again and again so we can write here x1 and y1 is equals to lm list at number four and we need the first element of it so this is the id number zero then this is number one element which is the x and this is the second element which is the y so we need the first element as x and then we need the second element as y and then we can copy this and we can do it for the index as well so we will write here this is 8 and this one is 8 as well so now i can simply write x1 and x2 x1 and white one and then we are going to write the radius let's say 15 and then we will give in the color let's say 255 0 and then 255 and then we will write cb2 dot filled okay so we can copy this for the other one and we can paste it here and we can write x2 and y2 so this will create two circles at that point so if we are getting the correct points then it should draw on the thumb and the index and there you go so now you can see that it is drawing on the thumb and the index so this is good now the next thing we can do is we can create a line between them so we can write here cv2.line and within the line we'll give in our image and then we will give an x1 and y1 and then we will give in x 2 and x 2 and y 2 and then we will give in what else do we have we have the color so 2 5 5 0 two five five and then we have the thickness so let's try that out there you go so now we are getting the line as well in between okay so next thing what we have to do is we have to get the center of this line so we can do that simply by writing here cx and cy is equals to x1 plus x2 divided by 2 and then y1 plus y2 divided by 2. so we can simply write it like this and this will give us the cx and cy and we can put a circle for that as well so let's write here c x and let's write here c y so let's try that out and there you go so now we are getting a nice circle in between so this is good now next thing we can do is to find the length so this is the most important thing we need to know what is the length between these two points or what is the length of this line when we know the length of this line then we can change the volume based on that so what we can do is we can write our own function and we can do a little bit of maths to square it and then square root but instead we are going to import math and within math we have the hypotenuse function so we will use that so we will write here that our length is equals to math dot hypotenuse and then inside that we are going to write x2 minus x1 and then y2 minus y1 so that will give us our length so we can print it out so let's try that i think we are printing something else else as well so we need to remove that first okay let's try it okay so here you can see that when i increase the distance the value increases when i decrease it the value decreases so the maximum you can say is around 300 something so we can say let's say it's 300 and the minimum let's say is 50. okay so this is the maximum and minimum that we have so one thing we can do is we can write here that if our length is less than 50 then we want to change the color of our center circle so let's make it green so this will give it like a button effect so when you're pressing it it changes so here let's let it load okay so here when we come closer there you go so now it actually feels like a button and it is very soothing i don't know why but it's pretty cool and it's quite fast so it is good so this is good and now what we can do is we can uh change the volume based on this length so how can we do that well we have a couple of libraries that can help us with this the one that i found was paiko i don't know why it says call but it is developed by andrey miras so thanks to him for developing this awesome library which allows us to change the volume of our computer so it is under the mit license and if you go down you have to just write pip install pico and then you can use this code as the template so i will copy this because i'm lazy and i will paste it here okay so now what we have to do is we have to simply go to file settings and we will add pico by call you can do pip install as well it's the same thing so we can click on pico and we can click on install so that is installed and we're good to go if we go back you will see all the errors are gone so we will copy the imports and we will we will cut them and we will paste it at the top and the rest of it we are going to see what do we need and what we don't so what we can see here here is that we have the volume get mute so this seems like the initializations so we are not going to change anything there then here we have volume dot get mute uh we don't want that then we have get master volume level um do we need i don't think we need that we might need the volume range and then we have volume dot master volume so we can set the volume so before we set it let's see what is the range so i can print this and there you go so our range is from 65 to zero so this is our range so we are going to use these two parameters so 0 will be maximum and 65 will be minimum we will ignore this value so if i set the volume as 20 let's run it and see what happens so right now it is at 26 the volume goes to 26. if i set it as let's say minus 5 let's see what happens to the volume it goes to 72. and if i put it as 0 then you can see it goes to 100 so this is basically the idea so what we can do is we can get the minimum and maximum range so we can write here that our volume range is equals to volume get volume range and then we will say that um or we will keep it like this let's keep it like this we can take the values later on or i think it's better to write so we'll write here minimum volume is equals to uh volume range at one visit yeah at zero and then maximum volume is at one so this is our range okay so now we can use minimum volume and maximum volume instead of using this okay so what is the next thing that we need to do now the next thing is we need to convert our volume ranges so as you saw that our minimum and maximum was 350 so we were getting let's write it after the length so here we know that our our hand range was from 300 was the maximum and the minimum was 50. so it was from 50 to 300. now we need to convert it to our volume range so our volume range is from uh minus 65 to zero so we need to convert this range into this range so in order to do that we have a very simple function in numpy so we have did we include yes we included numpy so in numpy we can write here volume is equals to numpy dot interpret and inside that we are going to give in the value that we want to convert so we want to convert the length and now we have to give in the range so our range was 50 to 300 and then now we have to give in the range to which we want to convert so our range here is the minimum minimum volume and this will be the maximum volume so let's print this out so let's print the volume so let's remove that and let's see if this works so right now it's minus 25 if i go down it goes to minus 65 so here our volume is zero and if i go up you can see it should go till zero yeah there you go this is the maximum so this is good uh if you are a little bit confused you can write the length here as well so the length and the volume you can see side by side we can make it let's make it integer that doesn't give weird values so yeah here you can see when we have the minimum volume then it gives us minus 65 and then when the length is maximum it gives us zero so this is exactly what we wanted so now that we have converted this we can simply send it to our master volume so we have the function here we can actually remove it from here and we can go down and after the volume we can paste it here so set master volume level we are going to set it as our volume so let's try this so i will open up my volume and let's try this there you go so if i go to zero it goes to zero as well if i increase the length you can see and now it goes to the maximum i think 300 is a little too far well it's fine you can see i can change the volume from here you can make it a little more smoother as well by changing the range of these two over here and even this you can play around with because i can see it's not very proportional so you can play around with those values to make some changes now the last thing we can do is we can show the volume bar on the side so that it looks a little bit nice to see what is the volume at any given point so what we can do here is that we can create a rectangle so we will go down and we will write here cv2 dot rectangle and we will put it on our image we will give it uh the initial position and then we will give it the ending position so we will give that and then we will give in the color so let's make it green and then we will write cb2 dot filled so this is the idea so the width of our bar is basically 85 minus 50 which is 35 so if we run this there you go so this is our bar and what we have to do is we have to remove the fill we don't want to fill we want let's say three so let's run that yeah so there is our bar and then the next part will be filled so the next part here we will copy this and now we will give in the volume so we will say that our width is the same but the height will be different so we will write here integer our height so volume of this and do we need to change anything else uh not really so here we need to change cv2 dot filled so if we run this volume is not defined oh yeah volume is not defined here so we can write here volume is equals to zero okay there you go so now you can see that it's going out of the uh what he called image so if i try to change let's try to change does it change no because it is too big for us so what we need to do is we need to convert our range again so in this instance our range is from let's say 400 so 400 let me show you here so 400 is at this point so this is the height 400 so when our volume is 0 it should be 400 and at this point we have what do we have we have 150 when the volume is maximum it should be 150 so our new range so we can write here that this is volume for the bar so we will write here it's again 50 from 300 till 300 but the minimum now is 400 and the maximum is 150 so instead of volume we will send in volume bar so let's run that okay now volume bar is not defined so we need to write here volume bar and let's do volume as well volume is equals to zero okay let's run it still the same why where did i make a mistake volume bar is from so where is the issue let's run it again and see if i put my hand in ah okay so the first value is wrong so we need to go up here and volume bar should be 400 so it is at the first point it should be zero so our zero is at 400 so there you go so now if i bring in my hand and now if i change you can see it changes the value there you go so the last thing we can do is to add a percentage at the bottom so we can copy this and we can paste it here and in the text we are going to given our percentage but again we don't have any percentage so we can create another conversion here we can write here volume percentage equals to 50 to 300 and now it will be from 0 to 100 so we need the percentage of that and then we can write here that our volume this is our volume should we write volume or let's just keep it like this and then we can write here volume percentage and then we can write percentage in front of that but the location let's put it 440 let's keep it at 40 and then let's put this as 450 and let's keep the rest same or let's change the color let's make it green so it matches that so let's try that out okay volume percent i always forget this volume percentage is not defined you need to define it as zero or should it be zero uh yeah it should be zero okay so zero percent sixtyfour it's hard to see this color let's change the color completely so let's keep it as blue so i will copy the blue color where is it from the fps and we will put it for all of these okay let's try it again yeah now it's much much clearer so here we can see so 100 is a little bit hard to reach so instead of 300 i can make it 250 for example 275 but now you can see the percentage is changing let me show the volume bar and you can see here that the percentage is changing hey everyone welcome to my channel in this video we are going to learn how to count fingers we will first look into hand tracking and then we will use the hand landmarks to count the fingers and all of this will be happening in real time and it requires close to no installations and configurations so here we are in our python project and you can see that this is the same project that we used in our previous two videos in the first video we looked at the bare minimum code that is required to do the hand tracking parts and once that was done we created that into a module so that we do not have to write the code again and again and it will be easy for us to create new projects so this will be one of those examples where we create a project out of this module another example that we did earlier was the volume hand control and you can see here that this was the code that we did earlier so all of this is available on my website and now what we will do also there is another folder here you can see that it says finger images so basically what this is that we have the images of different fingers so when it is one when it is two three four five and one it is zero so we can have very specific ones as well where you have the index and the pinky finger up so then you can have only the thumb up and you can have all sorts of different scenarios but for simplicity we are just going to use these six scenarios but if you want to add more later on you can do that and it will pretty much use the same code and you can keep adding on to it okay so once we are in our project we will go to file settings and we will make sure that everything is installed now because this is the same project i know that the packages are already installed but if somebody is doing this for the first time then i will show you what you have to do so here you will write cv dash python and you will install this and then you will go to media pipe media pipe and then you will install this so both of these are installed so we don't have to worry about that and then we will go to our project we will create a new file and this time around we are going to call it finger something finger counting projects let's say so the first thing we will do is to import our cv2 the opencv library then we will import time and do we need anything else we will also import os so i will tell you why we need os later on now the first thing as always we will turn on our webcam so here we will write cap is equals to cv2 dot video capture and we are going to give in device number one most probably for you it will be device number zero and then you have the option of giving the size so you can write for example cap dot set and here we are going to write that this is number three number three is for the width so i can write the width of the cam and then i can write cap dot sets and the heights of the cam so we need to define the width and height so the width of the cam and the height of the camera is equals to 640 by 480. so we can write it like this and what else so then we have to write our while loop so while true then we are going to write here success and image is equals to cv2 dot cap dot read so it will read our frame then we write cv2 dot i am show and inside that we write image and then img and at the end of the day we have to give it a delay so cb2 dot weight key as one so this will give it a one millisecond delay so that we can see our images okay so what else okay the spellings here are wrong success okay so let's try this out and see if we are on the right track so this is my webcam and you can see my hand and that seems good okay so next we are going to do something new here and that will be to import our images so we have all these images so what we need to do is we need to get them one by one and then we want to store them so that later on whenever we have the certain amount of fingers shown then we can display that image so we need to store them first so how do you store it you will use os so what we can do is we can write here that let's say our list my list is equals to os dot list directory so we want to list the directory we want to list all the files that are present in finger images so we will say that our folder path is equals to finger finger images so i will copy this and i will paste it here so now if we print this out you will see that we get a complete list there you go so we get all the names so one thing to note here is that i have put them in order and the last one is zero so when there are no fingers then it will be zero here now you might say why didn't you put it here in the beginning and there is a reason why and i will show you later on why this is the reason what is the reason so then we are going to create a list of images so we can say list of images or we can say let's say overlay because we want to overlay this image on our main image so we will say overlay list is equals to empty and now we can loop through our list so we can say that for image paths in our list we want to create we want to import our image so we will write here image is equals to cv to dot i am read and then we have to given the path of the image so this is the path of the image so it is in finger images and it is one dot jpg so one dot jpg is basically this i am path and then our folder path is basically finger images so we can write here f and then we can write here folder path okay f needs to be small folder path and then we can write slash and then we can write our image path so we can write here image path impact okay so now if you're confused let me show you what this will look like so you can go here and we can print this and we can skip the import or we can import doesn't really matter so there you go so for each of the images you get this finger images at one dot gpg then finger images 2.jpg and so on so this way we get all the paths and we can simply import now we have imported it let's keep it there we have imported it but we didn't save it so we need to save it in our list so we will say overlay list dot append and we want to impend our image so that will give us our image list now to confirm that everything is working fine we can write here length of our overlay list and we can write here print so if that list is six then we should be good to go and there you go so the value is six so this means we have imported all these images and we are good to go so how exactly do we overlay an image now the thing is that image itself is a matrix so what we can do is we can define that our new image we want to put in our old image based on this location so what we can say is that our image is equals to so if i wanted the elements the first element of this list i would say overlay list 1 or overlay list 0 right so the same way if i want to target a specific region of my image then i can write that target space in this bracket so this is also called slicing so what we will do is we will give in the height first the range of the height and then we will give the range of the width so we will say that i want to put my image this overlay image whatever it is let's say we are using overlay list at number zero so we are using the first image so i want to put that at zero wait what happens uh i think insert is pressed or yeah okay zero and then 200 this is the limit of my height and then 0 to 200 this is the limit of my width so now now the reason i'm putting 200 is because these images are 200 so the size of this image is basically 200 by 200 so we can automate that i will show you how to do that too so let's try this and see if it works so i will run this and there you go so now you can see the image number one is displayed at 200 by 200 so this is 0 0 and this is 200 200 so our image is now displayed properly if i wanted to shift this i can write for example 100 here and then 100 here so we are getting an error that we have hundred and two hundred uh okay so the problem is that the image is of size 200 by 200 and they are saying that you cannot convert it to 100 by 100 so here hours if i'm increasing 100 here i need to increase 100 here as well so that it maintains that 200 size so if we run this now then you can see that the image has shifted down so this is how you can place your image within our original image so here we are going to write 0 and 200 and 0 and 200 but now we want to automate this so let's say you don't have a 200 by 200 image you have something else you're the size of the image is something else and even the size of each image could be different so what can we do then what we can do is we can write here that for example we are using overlay list 0 okay so we will write here overlay list 0 dot shape so this will give us that shape and we can store it in height width and channel because we have these three things and then we can replace this with height and we can replace this with word so if we run this now then it will give us the same effect because we don't have to worry about uh the size of the image it will put it on the corner so this is good now we understand how to overlay our finger image on the original image now what we can do is we can display the frame rate so here we can write current time is equals to root time dot time and then we have to write fbs is equals to 1 divided by current time minus the previous time and the previous time we have to declare up here in we will put it as zero and then we will say that our previous time is equals to the current time so this will update every loop and then we can simply write cv2 dot put text we will write in our image and then we will write the then we will write the fps as an integer and we will write here fbs and what else then we will write the uh what do you call the location so we can put 470 and then we will write cv2 dot font any of these and then we will have the scale and then the color and then the thickness so let's try this out and see if we get a good image whoa that is really big so let's change this to font plane there you go so now it is quite good and we can see that it is working so that is good so the next thing would be to actually go into our hand tracking part so here we are going to go up and we will import we will import our module which is the hand tracking module and we will import it as h m so this is what we will do or let's say htm hand tracking module and then we will create uh not here we will go down and here we are going to create a detector so we will write here the detector is equals to htm dot hand detector and we will not give it any values or should we we can give it the detection confidence so we can keep it a little bit higher so 0.75 let's say later on if we get some errors we can change that too so that is good so here we are going to write that we want our detector to find the hands and we will send in our image and we will just ask it ask it to return our image so if we go to the hand tracking module you will remember that this is our class hand detector class inside that we have a method called find hands and it just needs an image and it will output the image with the drawing so we can write here image we will return image back and if we print this it should uh draw our hand so there you go so we have our hand and it is drawing nicely so that should be good and then what we can do is we can create a list of the landmarks that we detect so we will say that detector dot find position and we want it to find the position within our image and we want to draw as false because we are already drawing so we don't want to draw again so we will write here that drawing is false and then we can print our lm list to see if we are getting something so right now it's empty and when i bring in my hand you can see that the list fills up so that is good and now what we can do is we can write here that if the length of our lm list is not equals to zero then we are going to do something so that something could be anything so what we are trying to do is that we are trying to get the tip of our fingers and based on that tip we can decide whether our fingers are open or closed so here is the website of media pipe and we can see that these are our landmarks so what we have to do is we have to first of all get all these points so we need point number four point number eights 12 16 and 20. so we need to use these and then we need to check whether these are below let's say number six or number seven i think it's better to take number six you can even use number five but i think number 5 will be too much so you can say that if number 8 is below number 6 then it is what you call closed then the finger is closed and if it is above six then the finger is open so what we can do is we can pick one of these and we can try it out and then we can apply it to the rest of them so let's say we pick our index finger so this is eight and six so what we will do is we will write here that if the lm list at number 8 we will get the value of the y not the x so y is the third element so it will be 0 1 and 2 so we will write here 2. so if the point number 8 is less than the point number point number six then it means it is open so in that case we will write here print index finger open so because we are using the opencv orientation so up means lower values so our image is starting from the top so the maximum value at the maximum height is zero so to check for example here our value is 50 and here our value is 100 then it means our finger is open if it's the opposite if it's 100 here and then 50 here then it is it means it is closed so here we are going to try out and see if it says finger open so here right now it's saying finger open if i close it you will see that it stops saying actually let me remove the print it's quite annoying so let's run it again so right now it will say index finger open if i stop if i close then it will stop and if i open it again it will say index finger open so this is how you can tell if the finger is open or not so now we need the tip points for each one of these so for each finger we need a point now we could write a lot of if statements and if you are using a lot of different types for example if you have the pinky finger and the index one up as well and then you consider that a different gesture than your two fingers of any kind for example the index finger and the middle finger up so if you want to differentiate between these then you have to create lots of different images lots of different scenarios but here we are only going to use six scenarios so we can simply use a for loop so what we will do is we will create a list here and we will call it tip ids and this tip ids will be basically number four which is for the thumb number eight for the index number 12 for the middle finger then 16 for the ring finger and then 20 for the pinky finger so these are the tips and then what we can do is we can put a for loop here and then we can change this value so here we can say for let's say id in range what is the range from 0 to 5 we are going to repeat this and here we are going to put in the value so the idea is that we have our id number four so we can write here tip ids at number id okay and the other value so here you can see it is eight and here it is six so it is minus two so whatever value we have here minus 2 so this minus 2 so this should basically loop and it should tell us for each one of these but once it tells us that if the finger is open or not we need to save that so here we can write fingers fingers is equals to empty and here we can write fingers dot append we can append either one or we can append zero so if the finger is open then we will append one if the finger is closed then we will append zero so here we will write prince fingers so let's see how that works out so if we have our hand in you can see all the fingers are open if i close all of them close except for the thumb so we will discuss the thumb but let's try the other ones out so here we have one the index finger then the middle finger then the ring finger and then the pinky finger so you can see it is really good i can do one two three and four there you go so that is amazing so what i was saying earlier is that for example if you have this pose it will show you that the index is open and the pinky is open but for images we are still going to use this image that it will show us that there are two fingers open because we are not using all the scenarios now one thing you have noted is that the in the thumb is an issue and the reason is that the tip of the thumb is not acting the same way so we are using the tip at this point so this is the point where we are using the tip and we are saying that when it is below this point because 2 will be here at this point so this basically is never going below that if i really push my finger maybe not even then so that is not a good way to check it so how can we check it can we say that if this is below instead we can write 1 even in that case it is very hard to bring it below that maybe now it will say 0 but it will be very hard so how can you tell if the thumb is closed or not so for the thumb what we actually do is naturally when we are closing we put it on the side we don't bring it down we put it on the side so we can check whether this point here at the top is on the left of the second point or on the right so right now it's on the right now it's on the left so when it comes to the left side we will say it is closed and when it's on the right side we will say it's open so this is the idea so let's see how we can do that so what we will do is we will keep this for loop for the four fingers so we will just make it one to five and then over here we are going to create another loop uh not another loop just an if statement and we will say that the id number one which is the x axis is less than this point id number one and then we will check minus one not the uh two values below only one value below only one landmark below so if you are not clear about this i'm talking about this point number three so if this point is on this side then we will consider it closed if this point is on this side of the point so here it is on the left then we will consider it open so keep in mind for the left and for the right hand it will be different so if you are doing it for the right hand uh it will be the same what i am doing if you are doing it for the left hand then you can uh do it the other way around now you might say that if i am using it with the left hand with this code it will not work yes it will not work but there is a possibility of checking whether it's a left hand or a right hand and then based on that you can change your parameters you can change the if statement based on that so it is not something very complicated it's very simple but right now we will just focus on the right hand so here what we will do is uh okay we have already written the code so we don't need to do anything else so we can write here thumb thumb and we can write here uh four fingers so that is the idea so let's try this out if it works or not okay we have another must be integers or slices okay uh oh there's no id my bad so there's no id we have to get our id by itself so this will be number zero so let's run that again okay then we have another issue tip ids zero one okay i think there's an issue with the brackets so there should be a bracket here so tip ids add zero yeah and then the first part of it so the bracket should be here and over here uh it will be tip ids minus one and there you go so it should be like that okay so now you can see it is zero when it should be one so it is basically opposite so we need to make it greater than so now you can see all of them are one if i put my thumb if i close it you can see it says zero so that's how easy it is so now if i put all of them closed you can see it says zero and if i open i can open one by one two three four and five and i can get all the detections so that is good now the next thing we have to do we have to change our image so to change the image first of all we need to know how many fingers did we actually get so to do that we can actually let's go up here let's comment this and instead we are going to write here that our total fingers total total fingers is equals to fingers dot count so this is a method in our list so we have a list in which we can use the count method to count the number of values present of what of the number one so basically we are saying find how many uh ones do you have i think the indentation of this is wrong so we need to fix that okay so then we can print the total fingers let's try that oh it has no attribute counts because c is supposed to be small okay so let's try that here we have 5 0 1 2 3 4 5 4 3 2 1 0. there you go so now it's looking good and all we have to do now is to change our image so how can we change the image so here we have the code for changing so we will bring it in the loop or what is it in the if statement so we will bring it in the if statement and then we have to change the value over here so we have to put a value based on the total fingers so already we have laid down if it is finger number one it should be element number zero so we can take this total fingers wait what happened total fingers minus one so if it is one it will become zero so it will take this image if it is two it will become one and it will take this image so this is how it will work so let's see if it changes we are taking the shape of zero we should take the shape of the same image even though all of them are same doesn't matter at this point but overall it could be different okay so we have 5 now and then we have zero one two three four five so that's how easy it is one two three four five and it looks like an animation if i do it fast and it's running real time so it looks really good now you might say we didn't add zero we didn't we actually never said go till six so this value of total fingers can be let's say at five maximum right and then five minus 1 is 4 how is it going to 6 that does not make any sense right so this is why i put it here as 6. what happens is that when the value of total fingers is 0 it gives the value of minus one and in python what we have is that if we write minus one of the list it will take the last element so the last element is the value number zero so that's why i put the image at the end so it will take that minus one value and whenever it is zero it will become minus one and it will take the last element which is the sixth element so this is uh the results so you can see here whenever it is zero it gives us that a fifth image which is image number six so this is good and we are pretty much done the only thing we can do is we can add a rectangle to show the count so that it is a little more appealing you can say so here we can write cv2 dot rectangle we will put in an image and then we have to give it the uh the points the starting point and the ending point uh 170 so i have uh tried out this before so i know the values that will work properly so i'm directly inputting those so then we can put the color let's say green and then we can write cv2 dot filled so if we run this uh you will see whenever we have our image or whenever we have our detection we get that green rectangle so this is only coming when we have the hand because it is in the if statement so if we put it outside the if statement it will it will always appear but i prefer that it disappears whenever the detection is not there so then we are going to put the text we will write cb2 dot put text and inside that we will add our image and we will change the text to total fingers and then we will give in the location and then we have to give in the font so we will pick the fonts plain font and then we have to give in the scale we will keep it really big so we can see two five five zero and zero and then we will put 25 so this is the thickness so let's try that out and we'll bring in our hands and if we close it's zero one two three four five i will do it again one two three four and five one two three four five so as you can see it works really well and the detection is really great but again if i use these two two fingers it will still show me the image of two and if i let's say put these three up it will still show me the three default image that we have so if you want to change these you will have to put if statements for each of these you will have to have an if statement rather than a loop and you can define if this is the case then this should be the image if this is the case then this should be the image so each of the fingers can be like a binary so if that is 0 0 1 1 then you do this if it's 1 1 1 you do this 1 1 0 0 you do this and so on so you can do it like that hey everyone welcome to my channel in this video we are going to create a personal ai trainer we will use the pose estimation running on cpu to find the correct points and using these points we will get the desired angles then based on these angles we can find many gestures including the number of bicep curves we will write the code in a way that you will be able to find angles between any three points with just a single line of code so here we are in our python project and you can see that this is the exact same one that we used in our previous video so we started off with the bare minimum code so you can see this is all of the bare minimum code that we required to run our pose estimation and then we created a module out of this so this is that module which allows us to create these projects very quickly so today will be one of these examples where we create a project very rapidly so then here is our awesome project so this was the demo of how you can actually utilize this to run your module so these were the things or these were the files that we created last time so if you haven't checked that video i highly recommend that you do go through that video before you continue here now today we are going to do the ai trainer so we have a new folder here called the ai trainer let's open that up and let's check out the contents so here we have a test image so basically the idea is that we want to find the angle of any three given points so point number one point number two and point number three so this is actually explained here in the summary so what we will be doing is we will be using these three points and based on these three points we are going to find the angle between these two lines so that will tell us uh how much angle we are at and based on that we can do some calculations for the gestures or for the poster so that we can tell the person okay you have done this many curls so what we will be doing is we will be counting the number of curls that a person has done you can apply to other techniques as well to see the posture whether they are using correct ones for yoga or something like that so the main idea is that we will do this in two steps the first one will be to find the angles so we will create a method where we we can input any three points and it will give us the angle of these three points so this way we do not have to worry about getting other angles for example if i want for the leg i will have that information as well if i want for the arm and the shoulder i can have that information as well for the elbow and the wrist i can have that so with one single line of code i will be able to have all of these different angles so i will just have to specify the landmark number for example uh for this arm it is 11 13 and 15 so i can say 11 13 15 and it will give me that one if i say 12 14 and 16 it will give me for this one so for sorry for this one so this is the idea that we will create this method and the second part is where we will try to find the angle and no actually we will have the angle and based on that angle we will see how many curls did the person do so this is our idea so we will start off with this is by the way the video let me bring it here so this is the one we will be using again both of these images and videos i got from pexels.com so you can check it from there or you can find these documents in my website so you will find this folder over there so what we will do is we will right click and we will create a new file and we are going to call this let's say our a ai trainer project so the first thing we will do we will import our packages so we will write here import cv2 then import numpy as np and what else do we need we need time so we will import that so all of these packages we have imported earlier so if you are new and you haven't seen the previous video you can go to settings python interpreter and you can add and here you can write opencv dash python and you can hit install and then you can write media pipe media pipe and there you can install so these are the two libraries that are the most important ones okay so once we have that we are going to import our image and the video so here you can see we have the image not this one the test image and the video so we will be using the test image at first for the angles and once we have that then we will use the video for the curls now uh we will write the while loop anyway so that we don't have to switch at the end we just can remove one line and it will convert to video so we will write here first that we have a video capture device so we will write here uh cv2 dot video capture and we will say this is the ai trainer slash what is it girls dot mp4 and then we will say while true we are going to check the success and the image and we will say cap dot read and oh and then we will say cb2 dot im show we will write here image image and then we will write image and cv2 dot weight key and layoff one so if we run this we should get our video running so let's run that and there you go so as you can see this is quite a big video it's quite huge we can resize it we can write here image is equals to cv2 dot resize and we want to give it a specific one so we will write here one two eight zero by 720 so let's try that and there you go so now this is good and we are ready for the girls part but as i mentioned before we are going to use the image first and later on we are going to use this so we are going to comment this and here instead we are going to write image is equals to cv2 dot i am read and then we can read our image so it will be a i trainer slash what is it test.jpg so we can actually put it outside so let's run that and there you go so we are getting our image so we will check the angle of this and we will see how we can calculate that okay so that is good now we need to find our pose so to find the pose what we have to do is we have to import our pose module so here is our pose module that we did in our earlier video so here we have the class pose detector we are going to use that to create an object once we have the object we can use find pose to find the pose and then find position to get all the data in that list so here we are going to say detector the detector is equals to oh i didn't import forgot to import so imports pause module pose module as pm and then we can write here pm dot post detector and we do not need to give any inputs at this point so then we can come down here and we can write here that uh detector dot find pose and do we need to input anything uh we need to put input the image and then we need to tell whether we want to draw or not so by default it's true so we will draw and what else so do we need anything back uh no not really we can yeah we need the image back so let's run that and there you go so now you can see uh okay this is not good we need to put it inside so it's detecting again and again there you go so now you can see it is detecting the pose and now we can try to find the angle but how do we get the landmark values so we can use the get position so we will write here nlm list is equals to detector dot get position wait why is it not showing detector dot is it oh it's find position okay so find position and then we will write image and we don't want to draw so we will write here false i think there are only two arguments so we can directly write false yeah so that's fine so let's run that actually we need to print to see if we're getting anything lm list and let's do that and there you go so this is our list and we can see we have all these 32 points so that is good okay so now we can uh first of all we need to make sure that we have a list where we have uh the post detected otherwise it will give us an error so we can write here the length of our lm list is not equals to zero then we are going to do something magical so what is the magic that we are going to do so now here the thing is that we can write the code here but then it will be for this project only we can write here pass for now so that will be for this project only but we don't want to do that we want to we want to enhance our pose module by adding a method to it so this pose class which is the pose detector it will have another method that will allow us to get the angle of any three landmarks so instead of giving the points for example 485 and 281 what we will do is we will say we want to find the points between three four and five and because it already has this method and it already has this list we will make it an instant list so that it is for that particular object so then we will not have to even input the point value we just have to input the number so we need to know which landmark numbers we are talking about so how can we do that let's start by writing our code so the first thing we will do is we will create a new method we will call it find angle or angle no find the angle because it's just one angle then we will give in our image um the image the image is for drawing so we will input that and then we will need the three points so we will call it p1 p2 and p3 so these are the three point uh landmarks that we need and then we can have the flag for drawing as always so we will keep it as true okay so now as i said instead of giving in the points we are just using the values so we are using value number four value number three you can call them index index number two three four so these are basic basically index values so what we need to do is we need to get the values of the points based on our index value so how can we do that so in the find position you can see we have the lm list so what we can do is here we can send this lm list back again to our object but that is not a good way to do it because we already have it we can just use it internally so we can write here self dot and now this is part of that object so we will write here self dot and we will write here self dot so now what we can do is we can write here that our x1 and x1 and y1 is equals to self dot self dot lm list at point number one so let's say we want landmark number three so that will give us this landmark number three but the thing is it has three things inside it has number three it has 485 and 281 so what we can do is we can slice it so here we will write we need for from point number one till the end so it will take this and this and it will ignore this so then it will store it in x one and x uh in y one you can also do it like this so you can ignore the first one and you can you can remove this one and you can ignore the first one and you can take just the last two but uh let's do the first method let's do it like this and then we are going to write here x2 y2 and then x3 and white by three and here we are going to write point number two and point number three now to make sure we are getting the correct points we are going to draw so here we will write if draw we are going to write a circle so let's just copy because we are lazy and we will just change this to x1 and x2 okay so yeah that should be good we can copy this and we can make it x wait what did i do x 1 x 2 why did i do x 1 x this should be y 1 i always make that mistake y 2 x 2 and then y 2 and then x three and then y three okay so that should give us but we didn't call it so we need to call it here so we are going to write that detector dot get angle or find angle and we will give in our image so now we need to give in the points so if we go to media pipe and we check for the points you can see that we want point number 11 13 and 15 and then 12 14 and 16 so based on if we want right or left so the left one is the odd one so 11 13 and 15 is the left one so here i think the right one is visible so we will use the right one so 12 14 and 16 and the draw we will keep it as true so now let's run this and see what happens and there you go so now you can see these have turned blue so we know that these are the ones that we are using uh should we decorate it more or should we do it later let's do it now so what we can do is we can make it look a little bit nicer just to make sure that we are using these correct points because uh at some point we are going to remove all the other uh what do you call the detection the pose estimates so here we are going to create a bigger circle and let's put it as 15 and let's put this as 10 and we will not fill it and we will put the value of 2 here and for the color let's put it as red so here we are going to write 255 and we are going to write here all of these as red um yeah and then what else so we will copy this we'll paste it here and paste it here we'll make it two and two and then three and three so let's try that there you go uh oh we forgot to remove the filled no we did remove the fill oh we didn't do the size we forgot to change the size okay there you go so these are the three points and what else we can do the line as well so let's do the line before that because uh the circles we want to draw on the line so we will write here cv2 dot line and the first line will be on the image and we will have two points and then we will have we will put the color of white so it's really visible and then we will put the thickness of three so here our first uh what do you call points will be x1 and y1 and then the second one will be x2 and y2 we will copy this and here we will have what happened there here we will have x3 so 2 will be common for both of them one and three will be changing so let's try this uh nothing happens why didn't anything happen because i put this in the wrong place this should be outside okay there you go so now we have the white line and so now we can go back and we can make this false so that we can just focus on these three points and the rest will be gone so there you go so now we have these three points and we want to know the angle between these points so we will go back to our module and here now we need to find the angle so the angle finding is not actually hard so here we can write for example get the land marks and here we are going to write calculate the angle and then here we will write draw well you know it's written draw here and we're writing draw here very redundant but anyways so we will write here angle is equals to we are going to use math so we will write here imports import math so this is just basic trigonometry so we don't have to worry too much about this so what we can do is we can write here math dot tan 2 sorry a tan 2 a tan 2 and then we have to give in y 3 minus y 2 and then x3 minus x2 then we will subtract and we will write here math dot a tan 2 and then we will write y1 minus y two and then we will write x one minus x two so again i'm missing some brackets so that should be good so this will give us our angle in radians so we can convert it into degrees so math dot degrees and there you go so if you have three points and you want to find the angle between the two lines the this is the method this is the equation that you can use so here we can simply write print angle and we can see what exactly is our angle okay uh what happened there so there's a mistake for sure it's the brackets yeah and this is extra so yeah i put one extra my bad okay so here we are getting our angle 87 which makes sense like it is almost 90 degrees you can see that so 87.3 it's not bad so what we can do is we can put this on the actual text or the actual image so that we can see so we can write here cb2 dot put text and we will write image and we will write the angle but let's convert it into integer and then we will convert it into string otherwise it will not accept and then we will write here uh the value so the position so here we will write x2 so this is the center point so we have x1 and x2 these are the further points and x2 is the middle point so we want to write the value near the middle point so we are using x2 but we don't want to write it exactly at that position so we can subtract like 20 from it and then we can write y2 and we can let's say add 50 to it so we can change these values if we are not satisfied okay then we can write cb2 dot font let's pick the plain one and then we will write the scale and the color so color let's put purple and then we will write the thickness so let's run that there you go so we are getting 88.87 so that's good uh the x is bad so let's do we did minus right so minus 50 let's see yeah it's better now maybe let's convert this into blue that's more visible now the background is a little bit black so it's not that visible maybe red will be more visible or green yeah red is not bad so 88 degrees is what we are getting and sometimes what happens is that we get a negative value so for that case we can write here should we actually let's remove this and for those cases we can write if our angle is less than zero then we will say our angle we want to add 360 to it so 360 minus whatever the value will be so that will solve that problem so now what we can do is we can use any three points to find our angle so let's say i want for this is for the right one so we can say here right right arm let's say and then i can do the exact same thing with just one single line of code i can write here left arm and i will just change the values 11 13 and 15 and now you will see it will do for both of them and that is pretty amazing so it is telling the angle for both of them at the same time so uh the last uh the the one that is hidden is not very clear so you cannot rely on that angle but the one that is here is quite good so we can remove this so now we can try this on our video so for the video as i mentioned we want to do it on the left arm rather than the right and by the way you can do it on the legs as well so it's up to you now which three points you want to take for example you can take 23 25 and 27 so it will tell you the angle between these two lines then you can use 24 26 28 it will tell you the angle between these so it is up to you which ones you want to use for your own project but for now we will use the left arm for the bicep curls so now we will remove this we will uncomment this and we will remove the image part and let's try to see if we get the angle there you go so now we are getting our angle and as you can see probably it's going to negative and all so that's why it's giving this value so what we can do is we can find the minimum and the maximum and based on that we can check if it has reached that point or not so let's try to figure out the minimum and maximum now the good thing is if you click on the window it will stop so we can check our values very easily so here you can see it's 338 but that's not the last one so here i saw 190 something yeah 180 probably or let's say 200 yeah 200 is not bad or just to be on the safe side we can keep it a little bit higher like 220 or something like that so that it goes to zero easily and then over here we can see it goes to 300 something so 340 but again might not go always there so 3 30 maybe 20 or 310 i can see it goes again and again to 328 so it went to 340 340 oh it's going to 40. now it's 28 27 29 okay so to be on the safe side we can we can say that it is um 20 right so or we can say 15. so what we can do is we can convert our range we want it from 0 to 100 we want to know how much curl uh we are at so the percentage of curls so at the zero point or at the 100 point so what we will do is we will create a percentage and we will say that did we import numpy yes so we will use numpy to convert our range so we will say numpy dot inter interp and then we will given our angle not range angle oh we didn't get it back that's why it's saying this angle is equals to so i think i forgot to return yeah so we need to return return angle so that will return our angle over here and then we can use this here angle is equals to what else do we need so we need the first range so our range will be let's say 210 to 310 let's say and we want to convert it into 0 to 100 so this is already 100 so we can easily just subtract but if we had a difficult range you can use this method so that should be good so let's print out this value and we will print out the angle uh not the angle the percentage so or we can print the angle and the percentage that would be good to see are we printing anything here no okay that's good so we can run this so here we can see so it's zero going hundred percent then going back to zero then two hundred percent going to zero hundred zero excellent so now we can see that we are getting the correct values so we should not face any issues because we have taken quite safe values if you go too far you might not get good results you have to check the tradeoff between accuracy and taking the risks of getting error okay so then we are going to check when are we reaching the the first curl when are we reaching the second we need to count so here we are going to go up and we are going to define two things the first one will be count which will be zero and the other one will be direction which will be zero now we will have two directions direction number zero and direction number one direction number zero will be when it is going up and direction number one will be when it's going down so we will consider a full curve only if it does both of these so it goes up and then it goes down to zero so from zero to hundred and hundred to zero so if we get that then we will consider it as first curve so we could do the other way around but i want to keep it like this where we have um the complete curl if we go back and forth the whole thing so we are going to write here that we want to check check for the dumbbell dumbbell curl girls okay so then we are going to write here that if our percentage is equals to 100 and then we are going to check if our direction direction is equals to zero so this is the first direction it means we are going up now you might say why didn't you just write and here if percentage is hundred and if direction is zero i will tell you why later there's the reason so then we are going to say count plus equals 0.5 so we will add 0.5 to the count so if it's going up and it has reached 100 it will be 0.5 and then it's going down and it reaches 0 then it will be 0.5 so that will be a complete curve so what i can do now is i can change the direction so direction is equals to 1 and then i can check here that if my percentage is equals to 0 and my direction is equals to one then i will write count is equals to plus is equals to 0.5 so the same thing that we did earlier and then we will make the direction one uh no we will make the direction zero okay so this will keep adding to our count and this way we will know which direction we are moving and how many counts uh did we have so far so here we can remove this and we can simply print the count so we can write here print count and let's see what do we get so 0.5 down 1. 1.5 down 2. 2.5 down 3 3.5 down 4. so excellent so if you um okay let's just display it first and then i can discuss so we can display it like this cv2 dot put text and we can write here image and we can write our string so we can write inside that integer so if you want to directly show the decimal places so if you want to show the 0.5 count as well then you can keep it like this so you can write simply count but i don't like that uh or let's try it now i will show you and then we will change it and then we will write here let's say 50 and 100 and then we will write cb2 dot font let's put the plain one 15 and then we will put 2 5 5 0 0 and then 25 actually these are very big values we will put big values later on but for now we just want to see if we are getting the output properly okay so what is the problem it's not callable is that the issue oh okay i forgot to write comma okay so here we are getting 1.5 to 2.5 3 3.5 that is good so what i was saying is that if you don't want that you can simply write here int and then you can put it like that so if we see that now it's zero it becomes one two three so it's up to you which one do you prefer okay so now that we have this we can make it a little more appealing so what we can do is we can first of all add our fps so we didn't add that earlier so we can add it now so we can write here c time is equals to time time dot time and then we can write fbs is equals to 1 divided by current time minus the previous time and then we will write our previous time is equals to current time and then we will put the text so we can copy this and we can paste it here and then we can change it to fps so that should be good now we need to put previous time as zero over here okay so that will give us the time and we can comment this to check the fps so there you go so we are getting good fps now this video is 1080p and we are reducing the size of it and that's why it's giving a lower frame rate otherwise you will have a better frame rate if you uh because here we are resizing so if you directly use maybe this size or even lower you will get higher frame rate okay so then what we can do is we can put our what you call the number of count in a box so let's create a box so i have already checked the values of this box so i will directly input it so we will write here cv2.rectangle rectangle and we will put in our image and we will put in 0 450 and then 250 and 720 so this is for a 1280 by 720 which is hd image so it is for that so 255 and 0 and then cb2 dot filled so this will give us a green box and what we can do is we can uncomment this and we can format it and then here we need to change the value let's put it as 45 and 670. let's run that there we go okay we need to change the size of this so 15 and 25 25 okay so there you go so now we are getting this nice and big so we can see what is happening that is quite good and it is giving us the angle do we need the angle uh no i don't like the angle let's remove the angle from here so let's run it again there you go so now we are getting without the angle so it looks good now what else can we do okay let's put the bar so if you remember we did it in one of the other videos for the volume gesture control so you can check that out as well it was to control the volume of a computer using your hand gestures so we use the bar in that one as well so here we are going to use the bar again so for the bar first of all we need some values so we will write here bar is equals to np dot interp and we will convert our angle from the range of 220 to 300 uh not 300 310 and we will put it as 650 and 100 so this is the maximum value of our bar uh no the minimum value of our bar and this is the maximum value of our bar because the opencv convention is opposite so this is the minimum this is the maximum okay so why is not giving a space here okay so then we need to create that rectangle so here we can create that rectangle we will copy this because we are lazy we will copy twice and we will also put the text okay so now we need to change the values here so the starting will be 1100 and then hundred then we have one one seven five and we have six fifty then we have uh what we call 1100 here and then we have our bar value so integer bar not bad bar and then we have eleven seven five and then six five zero so for the text we will have our percentage so we will make a string and we will write here integer and then we will write our percentage and at the end we will write percent so this we will display at eleven hundred and seventy five and the size will be four and four okay so we can write here that this is for our bar draw bar and let's say we write here uh show or let's try draw girl count okay so then let's try it out there you go but the bar value is not changing what did we do wrong oh so apparently the value of the bar is not changing because it is filled come on so this should be let's say three and let's try that yep so it goes down it goes up it goes down it goes up now one more thing we can do is when it reaches the zero or the maximum position we can change the color so that we know it's it's like when you reach a certain point and or you press a button it changes color so you can you kind of get a feedback so it looks good so that is the reason why we put an if within an if so here we are going to write color is equals to by default we are going to write the color as purple and if it reaches we are going to change the color as green so we will put the color as green so 2 5 5 and 0. and the same thing we can do for our zero if you want to change the color for zero make it different than the other ones you can do that too but we are going to keep it like that so here we are going to write we are going to write here color and then here we are going to write color and here we are going to write color so all of them are same so now it's green purple purple green purple green green yeah so that's how you can tell if you have reached the correct point or not so as you can see it works very well and again if you want to use a webcam you can simply enter the value or the id number of your webcam and it should run pretty much the same way just make sure that your face is visible within the camera and you are at a good distance because a lot of this depends on the face as well so if you are not within the uh if your face is not in the camera it will not detect properly so that is pretty good so i i had a hard time finding uh these videos with bicep curls so that's why i just had this one but i will try to find some more but yeah so that is the idea the error is because the video ends that's why it gives this error it's not something that we made a mistake here hey everyone welcome to my channel in this video we are going to create a virtual painter using ai we will first track our hand and get its landmarks and then use the points to draw on the screen we will use two fingers for selection and one finger for drawing and the best part is that all of this will be done in real time so the first thing we will do here is to go to canva.com and if you're not familiar with canva it is basically a design tool it's an online website that helps you create all these different designs for brochures business cards flyers whatever you want you can basically design here so this is a free website so you can go and start you can start by just signing up so here we have a canvas of 1280x720 so we are expecting our webcam to be of this size that's why we are using this size so the idea here is that we are going to create a design to actually make it look more appealing and make it look more like a software so this is up to you if you want to skip this step you can do that too there will be files to download from my website the ones that i already did so if you want to skip you can go ahead and do that too but here we are going to start off with a rectangle and what we will do is we can we can put it on the side but the issue with the side is that it will be hard to select different elements so what we will do is we will put the menu on the top so our menu will be here at the top now for the width let's keep it at 100 100 is too small maybe 120 125 yeah that looks good so then we can lock this or let's change the color first so i like this blue or maybe this one yeah this one looks better so let's lock this so it doesn't move around then we are going to add let's add the logo first so i'm going to go to photos and right here logo uh no it's in upload my bad so i have my logo here i'm going to place it on the side and yeah that looks about right then we are going to add some brushes so here we will go to the elements and we will search for brushes so let's write here brush uh okay so these are strokes we are not getting actual brushes here we have let's write paint brush maybe yeah i think now we have better results uh i want to look for something that is free this is free okay so maybe something else that is free this is free as well so i'm looking for something free so that everyone can use it not just the pro users um maybe this one no it's pro this one is free too do we have a color of i think this one is the best okay let's keep it this way and if we want to we can change it later on so let's take this part right about here and we will zoom in and maybe a little bit smaller there you go so i think that looks good now the good thing is that most probably this is an svg file so we can change the color for it so let's say we want pink what is that purple let's try pink and what we can do is we can have another one that is a little bit bigger than this at its back so that will indicate that this has been clicked so we can put it okay let's change the color first we can put it as white or gray or dark gray let's put it at the back i think white will be better okay i'm no designer i'm just eyeballing this so i'm gonna put it as whites yeah okay so then what we can do is we can copy both of these and we can paste them here so somewhere in the middle and we can paste another one and then we need an eraser so we don't need the last one actually the one at the back or do we okay let's keep it let's keep it for now i will tell you why later on okay so now we need an eraser so let's write here eraser okay this one is pro pro pro this one is free no not really all of these are paid oh this one is free yeah i think that could work so let's put that a little bit bigger i think i'm putting it too big anyways you can change the design later on uh we are learning the concept here uh or let's just make it a little bit smaller so i think that will be better so we can grab these two and we can place them here this one in the middle this one a little bit further okay i think that is better and then we can make this a little bit smaller and there you go so i think that looks good now what we can do okay these are not at the top to put it at the top here okay so now what we will do is we will change the color for these so the first one is let's say pink the second one let's say is blue or dark blue in between maybe this looks weird okay let's keep this as blue and then the last one let's keep it as green so these are the let's say three colors that we want and then what we will do is we will this doesn't seem right i think at the back needs to go higher maybe yeah maybe like this okay i'm going to copy this and we will paste it here so we'll put it at back and the same thing to the last one okay so you can move it around with your keys your arrow keys so maybe a little bit higher again you can spend a lot of time on this but we are going to skip that we will not put a lot of effort here just for a demonstration purpose but you can of course go ahead and try a lot of different things so um now what we will do is we will copy all of these we will duplicate them so here you can see or let's change the size first so we already know that our size is 1280 by 125 so we will go to resize and we will change this to 125 and we will copy and resize or you can resize is up to you i'm going to press resize so it will do it on the same one then i can unlock this and i can grab all of this and i will scale it up so it should fit perfectly because it is the same size there you go so this is the image that we need so we are going to copy this four times because we will have a selection for each one of these so we can delete the selection for this and the selection for this and this is the first one so first one this is the one selected the second one this is selected and for the third one we will have this one selected and the fourth one we will have the rubber selected so here we are going to it is whites let's change this to let's change this one to the same color as this and let's make it a little darker like let's make all of them darker so yeah and then let's make this it's a black that's too much okay i think that is enough indication so we just need an indication that that has been pressed so that should be fine so now what we can do is we can download all these four images and the idea here is that whenever we detect a click we are going to uh change these images so we will see which one do we need so if we have clicked the first one then we will change the image to this if the second one is clicked we will change the image to this then the third one and the fourth one which is the eraser so at any given point only one of them can be selected so that's the idea so we can go and we can write here that this is our virtual painter let's say and we can download all of these in jpg or png whatever format you want let's do it jpg and we can download all of these so here i am in the pycharm project now this is the same project that we have been using for the hand tracking for the finger counter for the hand uh what he called volume control so we have done quite a bit of projects earlier than this so this is the exact same uh what do you call project and you can go to file settings and you can see that we have already installed our media pipe and we have already installed opencv but if you are new you can go to the add button you can write here opencv dash python and you can install this and then you can go to mediapipe mediapipe is the google library that we will be using for hand tracking so you can download and install this so this is the main idea now what we will do is first of all we will right click this and we will open it up in the explorer now once we are in our project we are going to create a new folder and we are going to call it header so we will have our header images in here so these are our images that we downloaded so i will copy all of this and i will paste them here and now you can see that these are our header files so we have a total of four header files so when we go back to our pycharm project you will see that we have a new folder by the name header and we are going to use that for our images so then we are going to right click and we will create a new python file and we will call this virtual painter so now we are going to import our libraries so we will write here import cv2 import numpy as np and then we will need imports time if we want to show the frame rate and then we will also need imports os because we need to access these files so we will need that what else we also need our hand module so we will write here import hand tracking module as htm so this will be our hand tracking module now if you are not familiar with this if you haven't watched the previous uh tutorial then make sure you go ahead and look at that because this is the tutorial in which we went step by step and we created this hand tracking module so this is very important this basically tracks the hand so if i run this you will see if i right click here this should open up my webcam and if i bring in my hand you can see it tracks the hand so this is the idea of the hand tracking module and based on these values we are going to do some painting okay so now first of all we are going to import our images so that is the first thing we are going to do we will write here that our folder path is equals to header so these are the header images and we are going to say that my list is equals to os dot list directory list directory and then we will get the name of all our folder uh path files so this is the idea if we print this out if we print my list you will see that we get all these uh images name so here you can see one dot jpg two three and four so what we have to do is we have to import them so that we can use them later on to overlay on the top so here we are going to write for image path in my list my list we are going to loop and we are going to import so we will see that our image is equals to cv2 dot im read and we are going to read from a string and that will be the folder path slash the folder the image path so this will be our complete path that we need to read from and then we are going to store it in a list so let's call this list overlay list so this will have all the images that we want to overlay so we will write here overlay dot append and we want to append our image okay so this will overlay our images uh no it will import all our images now what we can do is we can print the length of our overlay list so we can see that whether we have imported all of them correctly or not so let's run that we have imported indeed four so that is good so far and next what can we do next next we can run our webcam and then once we have our webcam we can simply overlay one of these images by default so we can call our image let's say header and we are going to give it an initial value we will say that over list at zero so now this is our image so whenever we get our original image we are going to overlay this on top of that okay so this is good for now what we can do next is we can create our loop and we can run our webcam so here we are going to write cap is equals to cv2 dot video capture video capture and we will say that device number one now you should write device number zero because i have multiple cameras i'm using one then i will write cap dot set now this is important because we want the exact same size we want one two eight zero by seven twenty so we have to make sure that the width and the height are exactly the same so we are going to write one two eight zero by seven twenty then we are going to write here while true we want to run our webcam and we want to get our images so we will write here that the success and the image is equals to cap dot read and then we are going to um okay let's just display it first so cb2 dot weight key is one and we have cv2 dot i am show i will say image and image so that should be enough so let's run it we have an error oh i wrote i am read no no no i am show what happened there okay so there you go so this is our image and you can see my hand so what we will do we are going to overlay our image now so how can we do that so we can simply write that our image so you might think it's a little bit difficult but it's not it's very easy because our image is a matrix we just need to define where is the location of this new image so we will slice it so here we are going to say that our height is from 0 to 125 because we know that the image size is 125 and then the width we are going to say is from 0 to 1 2 8 0. so at this region we are going to say our image is equals to header and that's how simple it is so if we run this there you go so now you can see that we have our image and on top of that we have overlaid our first image now this is good because by default we want our first uh paint brush selected which is the pink one so we are already up to a good start so here we can write that we are setting the header image setting the header image okay so this is good and now we can just separate this because we are going to write our code over here so what else can we do now the next step is in before we go into the details of the project let's split it up into pieces so first of all we will import the image okay so that's the first step we have pretty much already done that uh there is another thing we need to do i will tell you later this is the first step let's write it here one then the second step is that we want to find the landmarks so find hand landmarks so this can be easily done with our hand tracking module so that should not be an issue then number three is basically checking which fingers are up so check which fingers are up now this is because we want to draw when one finger is up which is the index finger and we want to select only when two fingers are up this will allow us to easily move around the canvas without painting so when our two fingers are up it will not draw anything if we want to draw we have to put one finger up the index finger so this will allow us to easily navigate through the canvas then we have the selection mode so we will check here at the fourth stage we will say if selection mode which is when two fingers are up two fingers are up then we have to what do you call we have to select not draw then in the fifth one we have to check if we have the drawing mode mode when index finger is up so this is the idea now let's go on to the next parts actually do we have a next part no so this is pretty much it we have five different steps we are going to go step by step and see how we can achieve each one of these so the first thing is that for importing image it is pretty much done the only thing we have to do is we have to flip the image so we are going to flip horizontally this is because when you are drawing if you want to draw on the right side then when you move to the left it will draw on the right so to flip the image we are going to right here flip and we will write image and we want to flip in the first selection now this will allow us to solve that problem so let's try that so now the image is flipped so if i go on the right side it's going to the right if i go on the left it's going to the left so it will be easier to draw because it will be more intuitive now the second step here is to find the landmarks now the landmarks we can find but we need to import first so we are going to write here that our detector is equals to hand tracking module dots hand detector and then we are going to give in uh detection confidence so this is up to us what value do we want to use but we are going to keep a high confidence because we want it to be uh good in painting we don't want a lot of mistakes here and there so by default it's 0.5 we have changed it to 0.85 then over here we are going to say that our image is equals to detector dot find hands and we are going to send in our image so this will draw on our image and it will uh detect the hand so let's try that there you go so now we can see it's detecting properly so that is good the next step is to get all the landmark positions so we are going to write here landmark list is equals to detector dot find position and we will write image and we do not want to draw so draw is equals to false and then we can check if the length of our landmark list is not equals to zero not equals to zero then we are going to do something let's print the lm list so let's try that so let's see if it prints there you go so it's printing the landmarks if i move around if i go out of the image it does not print anything if i come back in it prints the what do you call landmarks so that is good so now that we have this we need to know the the tip points of our index finger and the middle finger so what we will do is we will call the index finger tip as x1 and y1 so we will say x1 and y1 is equals to lm list at point number eight so this is the landmark eight so here you can see this is the landmark eight and we have the value of 729 and 396 for example in this case so this is the tip of our index finger so here i can write tip tip of index and middle finger zoom okay so then uh as you can see it is basically the first and the second element not the zero one so here we have to write from one till the end so we will write it like this so it will grab only these two so we are unpacking them here so x1 and y1 so we will do the same thing here for the middle finger and for the middle finger we will write x2 and y2 and the number for middle finger is 12 so that should be good so now that we have our landmarks and everything is good now we need to check which finger is up so this thing we did in our one of our previous videos and that was i believe in the finger counting project so if you remember here if we go back here so here is the code that when it is thumb it will check if it is up or down then it will check the rest of the four fingers if they are up or down so and then it will give us the total finger count and it will also give us the list where is the list yeah the fingers is basically the list which will tell us which of these are up and which of these are down so what we can do is we can pretty much copy paste this part and we can create a method in our hand tracking module so earlier we did not do it as a method in our class but this time around because we are using it again and again it is better to create a class rather than putting it in different projects every time so this is our hand tracking module we are going to open that up and you can see right now we have only two methods find hands and we have find position so next we are going to put another method and that will be called fingers up so we will write here def fingers up so that will tell us which of the fingers are up so we will go to our finger counter project and from here we can copy so we have from fingers till this part i think that should be enough so we will copy that and here we are going to paste it so what we are doing is we are first creating a list called fingers and then we are basically checking if the tip of our thumb is on the right or on the left so that will tell us if it's open or closed and then for the fingers we are checking if the tip of the finger is above uh the other landmark which is two steps below it or it is not so if it is below that then it means it is closed if it's above that it means it is open so it is storing the value of 1 when it is open it is storing the value of 0 when it is closed but why are these errors over here these errors are here because it does not recognize tip ids and tip ids was something that we declared over here so this is the list so we can copy that and in our module because we know that it will not going to change the tip numbers the tip ids they are not going to change we are going to write it in our initialization so we will write here self dot tip ids is equals to this so now if we go back and instead of just using tips we use self.tips it should work so we will do that and there you go so that works but now the lm list it doesn't uh recognize it because we did not define it as a self as an instance so we need to write here self dot lm list and i can copy that self again and we can paste it here we can paste it here so we can paste it here we can paste it here and here and here so what happened now was that not only we are returning this lm list when we find the positions we are also storing it so that if we want it in our other functions or our other methods we can use it as well so we do not need to send it out and then receive it back again internally it is available for us to use okay so that should be good and if we just return these fingers up it should give us if the fingers are up or not which of them are up or not so we can just return the fingers and if we go back to our let's close the finger counter if we go to our virtual painter here we are going to ask we will say that detector dot fingers up fingers up and do we need to send something in no not really so that is good we don't need to send anything and we can simply receive the values in the variable or the list fingers so let's print that out so fingers and let's remove the previous prints so let's run this and see what happens so something is out oh it needs to be inside this my bad okay so this is our image i will bring in my hand oh nothing is happening why is that okay so it takes a little bit uh to detect now you can see uh how many fingers are there uh okay the issue is i will tell you what the issue is for the thumb it's showing one when it is open when it is closed and 0 when it's open because we are not checking the left and right so this is an issue that needs to be solved more precisely but for now we'll just change this what was it before it was greater than less than so by writing less than it will solve the issue for now but later on we do have to fix this so i'm not going to fix it now for this one but in this case you can only use your right hand to draw so if you use your left hand it will be an issue actually it won't be an issue because we are not using the thumb at all but it will give you wrong values so here you can see the thumb you can see two of them then three then four so you can see all of these fingers they are being detected properly so now if i do this i should be able to select any of these and then if i do if i do this i should be able to draw so this is the main idea so we need to check uh now we know that which fingers are up now we need to check if it's selection mode or it is drawing mode so how can we do that that is very simple let me bring that in because i will forget again okay so now we need to check if uh the second oh no the first elements so we have fingers at first and fingers at second if both of them are up this means if both of them are true then it means it is selection mode so we will print here say selection mode and if that is not the case we will write here then we will write here that this is equals to false we only have the index finger up then we will say drawing mode so this is the idea now what we do after that is a different story but for now we just want to check if it is able to understand this or not so let's try that we should remove the previous print let's remove that let's run this so this is selection mode because two fingers are up and now it's drawing mode so now it's working very well we can see when it is so when it is nothing it doesn't do anything when for detection you have to make sure a lot of the image or a lot of the hand is available in the image so yeah so this is drawing mode we can draw this is the selection mode and everything is good so far okay so the next step what we can do is we can uh change or we can draw some circle around it so here if it is selection mode let's draw a rectangle so we are going to write here cv2 dot rectangle and we are going to write their image and then we are going to write that we want from x1 to y1 minus let's say 15 we want to go above because we are creating uh let's say a rectangle using two points so we don't want to just give those points we want to make it a little bit higher and a little bit lower so then we are going to use x2 and y2 and this time we will make it plus 15. so then we will give it a color so let's say 255 0 255 this is purple and then we will say cb2 dot fill now we are drawing a rectangle here because we are going to draw a circle when it is time to draw so for the circle we are simply going to write here cb2 dot circle and we are going to give in our image and we are going to draw from x1 and y1 so we will write here x1 and y1 and then we are going to say 15 and the draw color again 2 5 5 0 2 5 5 and then we are going to write cb2 dot filled so this will be a visual indication of when we are in selection mode and when we are in drawing mode so for selection it will be rectangle for drawing it will be circle so let's try that out so here it is rectangle and then if we do this it becomes circle so here the detection is not that good but still you can see the rectangle is very small 15 is not a good value let's make it 25 and 25. yeah now it is better so here i can say it is selection mode and here i can say it is drawing mode so it will be easy for us to detect so my hand should be really back and then i should be able to draw easily but because i'm near to the computer so it's a little bit difficult to do it this way but it should work fine so far we have done well okay so we have the selection mode now and we have the drawing mode so let's work with the selection mode first what we have to do now is we have to check if we are at the top of the image now if we are at the top of the image we are going to change our uh image or selection mode based on the location so first of all we will check if y1 is less than 125 so this was the value of our header so if we are in the header then we are going to do something so we will say that if our value is between 250 if our x1 is between 250 and 450 then it means it is clicking the first one so here let me just write it here checking for the click so that is what we are doing here so we will write here that if this is the case then our header is equals to overlay list at zero so that's the first one so by default it is the first one because we are using it here the value of header is already where is it yeah it's already the first one then we are going to copy this and we are going to paste it down here and we will write that else if else if the value is between 550 and 750 so these values i have checked before so if it's not the same we can change a little bit so then it is 750 then it should be overlay list one and then we are going to copy this we will paste it here and then one more time so we have a total of four so here it will be 800 to 950 and this will be 1200 and one zero five zero so this will be two and this will be three okay so let's try that out so if we move around we should be able to select so if i go up you can see it selects if i go here it selects if i go here it's an x so wherever i go it selects the correct one and the visual indicator is quite nice so it tells us which one did we select and if i go with one finger it's not going to do it because this is the drawing mode in the selection mode we can select okay so that is the difference here so now we are able to select properly so that is quite good next we are going to change the color so whenever we select something we want to indicate that the color has changed so here for example for the drawing circle or even for the rectangle we want to change the color for it so what we will do is we will declare a color we will go up here and over here we are going to say now the first image is for purple so if we go to the header and we see the first image it is for purple or you can say pink whatever color you want to anyways so we are going to say that by default our draw color color is equals to purple so whenever the value is selected another value is selected we are going to change this draw color so and we will use it to actually draw so instead of putting a random color for the rectangle and for the circle this is the color that we are going to draw and let's draw it after we have uh checked for the click okay we will put it here is it in the if no it should be here okay so what can we do now is that we can change this color individually so here we will say that draw color is equals to for this case it should be purple so it should be two five five zero two five five and for the second one it is blue so it is b g r so this should be on and this should be off and then we have green so b g r so this should be 0 this should be 2 5 5 and this should be zero and then for the eraser we will just make it black so black will erase everything so we will make it zero zero zero two five five two five five two five five is one and zero zero zero is black so let's run that let's try this so here our color is purple and both of them are purple we go to selection mode and now it's changed to blue you can see for both of them it's changed to blue we go to green and now you can see it's changed to green right so and if we go to the eraser it's changed to black so we can erase it for the black actually we can make an exception for the black because for erasing normally the tool is quite bigger but again we will discuss that later so now this is done so the selection mode is done we are able to select our color and it changes the color that is perfect now what we need to do is we need to draw so we already know when we are in drawing mode we now need to draw based on our points okay so now the easiest method and this is one that i have been using before as well because it is very simple whenever you are learning a new concept you should go with the simple thing rather than the most advanced or complicated one so earlier what i did was i created using uh simple points so whenever you have a point you just draw that single circle and then whenever you move the finger you draw the circle there as well but the issue with that is whenever you have a rapid movement it will not draw continuously as a line it will have some gaps so that is not a good way to draw so what we will do now is instead of drawing just a circle we are going to draw lines but the issue with lines is that we need a starting point and we need an ending point so here whatever current position we are in we just have that single point so we need to know the previous point as well once we know those both points then we can simply draw a line so let's draw that so here we are going to write that our cv2 dot line and we are going to draw on our image and where exactly do we want to draw we are going to draw at our x previous position and x y previous position and then the new position which is x1 and y1 then we are going to say which color do we want to draw it with we are going to say the draw color and then we are going to give in the thickness so here we can declare a variable we can say it we can say that it is brush thickness and if we want to change it we can change it from the top here so here we can create our variables and we can write here that let's say our brush thickness is 15. so we can easily change it up and now we have the x and the y previous so we will go up here and we will declare that the x previous and the y previous are 0 and 0 and then we will go down here now the issue here is that at the very first iteration at the very first frame we will not have any xp and yp we will have the value of 0 0 so it will draw a line from 0 0 to whatever the point you are at and that will look really bad so this should not be the case so how can we fix it we can fix it by writing here that if our xp our xp is equals to 0 and our yb is equals to zero it means it is the very first frame that we have detected the hand or we are starting to draw then we are going to say that xp and yp is equals to x1 and y1 so instead of putting 0 0 we are saying whatever value it you are at draw exactly at the same point so instead of drawing a line it will just draw a point so the very first time we see our finger it will just draw a point instead of a line after that it will keep drawing as a line so whenever we have the new points we are going to say that our xp and yp is equals to our x1 and y1 so these are our previous points so it will keep updating those so hopefully that was clear now let's try to run it and see if it draws so here if i do this it is drawing but it is removing at the same time so as you can see it is drawing something but it is removing if i go really fast then you can see it is drawing so this means that our image is updating every iteration so we cannot draw on our actual image so if we want to do that we will have to uh do something else i will tell you what that something is later on but for now we need to create a new canvas on which we can draw so what we will do is we will go up here and at the very top we are going to create a new image and we are going to call it image canvas and this will be the canvas on which we will draw so we are using numpy to draw our canvas and we will use the zeros method and the size is 720 by 1280 they use heights before the width so we are writing it like this and it has three channels because we want colors and it is unsigned uh unsigned integer of 8 bits which means it will have 0 to 255 values so that is pretty much it and now instead of drawing on our original image we are going to draw on the canvas so where did it go here so we will copy this and we'll paste it here and we will say image canvas and we will show the image canvas as well canvas okay so let's try that so now we should have two images so this is the image canvas and this is the original image i will keep this at the top and if i if i bring in my hand and if i draw now you can see it draws and that is very very satisfactory okay so this is the idea but now the thing is it's not drawing here which is fine if you want to you can draw there as well and i will show you how to do that but before we go there let's try out different colors so that we know that it is working well so i will keep this in the front but it will be hard to see okay let's try to put it here on the side and i will try to run that okay so this is a selection mode i will select blue and now i will draw with blue then we have the uh green mode the selection mode and then i will draw with green now i want to show you something else if i don't put this part if i don't put the fist frame condition what it will do is it will draw a line from the very start so if i bring it here uh okay this is very annoying uh we need to fix this first okay let's say i am uh here is my hand and then i start drawing there you go so did you see it started from the zero zero point and it drew all the way to the current point so whenever you have uh the new points let's say i go to the blue one and i select that you will see that okay not now but in the previous one you saw that whenever you have the first first frame then it will create this problem so we are going to open that up so that we don't have this issue okay next we can also try the uh erasing parts so the black one should erase whatever we have drawn earlier but what we can do is we can make it a little bit bigger because if it is bigger it is easier to erase so let's first select so let's draw and now i will go to the eraser and i will come here and you can see it is erasing but this is not very good because it's very small so what we can do is we can have a special condition for the erasing so we can write here that if the draw color is equals to 0 0 0 then we will have the size different so here we will copy this part uh actually we will copy both of these and here we are going to write that instead of the brush thickness it is the eraser thickness so we will write here eraser and we will also write here that this is eraser thickness so we will go up and here we are going to write eraser thickness is equals to let's say 50. so it will be easier to erase and here we can simply write else we do this so that should be good so if we have the eraser tool now so let's draw now let's go to the eraser tool and it's a little bit hard for me because i'm sitting very next to the webcam and there you go so i can erase now very easily and all of this will get very very nice and very very good looking once we do it on the original image the only thing is that we have two images now and it is very hard to see what is happening so now all we need to do is we need to put it on the original image so we need to draw on the original image so how can we do that we cannot draw on the original image because it refreshes every time so instead of doing that we are going to add our two images so what we can do is we can go down here so here what we can do is we can write here that image is equals to cv2 dot uh add weighted and then we have to give in our image the first image and then we give in the value 0.5 let's say and then we give in the second image which is image canvas and then we given the value let's say 0.5 so this will add these two images and it will blend them so let's try that out oh there is a argument missing there you go so if i draw you can see now it is drawing again i need to go back a little bit okay so now you can see it is drawing when the hand is really at the back like this it will draw well but because i'm very close to the pc and the camera it is hard for me to do this i can go back a little bit and there you go but the issue here is that this does not look very good i can change these values but still it will be a blend it will not be an actual uh merging of the images it the colors will not be that bright there will be a transparency on it so if you don't want that what can you do now it is a little bit complicated but if you break it down it is very simple so what we will do is we will write here uh let's where is the statement right here okay so we need to go here and we will write here first of all we are going to create a gray image so we will write here image gray is equals to cv2 dot cvt color and we are going to say that image canvas and cv2 dot color underscore bgr to gray tr to gray so we are converting it into gray image you might be wondering wait why are we converting it to gray image i will explain in a bit then we are going to convert it uh into a binary image then we will write here image inverse is equals to now we are creating we are converting this into a binary image and we are also inversing it what does that mean i will explain as well cv2 dot threshold and image gray and we are going to write 50 and 255 and then cv2 dot threshold binary inverse so the idea basically is that we want let me actually run it so you can see better so let's say i draw something let's say i drew this and now i have this image so what i want to do i want to convert this image into black and white so wherever i have black i want it to be white and wherever i have this colored image i want it to be black so what this will do is it will create a mask with all this white and only this region as black and then i will go to this image and in this image i will make all of this black and then i will merge this image with this previous image with the black area so it will overlay these two so i know it sounds a little bit complicated but you will see how it works so we first of all we are creating that inverse image so that all that region where we drew uh it is black then we are going to write here that our image inverse is equal to cv2 dot cvt color and we are going to write that our image inverse is basically cv2 dot color color underscore gray to bgr now we are converting it back because we want to add it to our original image so we cannot add it if they are not the same dimension you cannot add a gray image to a colored image so we need to make sure both of them have three dimensions then we are going to do image is equals to cv2 dot bitwise and and we are going to add our original image with the inverse image image inverse and then we are going to add our image is equals to cv2 dot bitwise or and then we are going to write image and image canvas so again this might be a little bit confusing but let's see the results and i will go step by step and explain it as well so now here you can see i can draw oh it went down here you can see i can draw easily it's not updating this value it seems yeah okay it's not updating the value okay so this is drawing on the canvas now which is good but actually on the original image but the issue is that it's drawing this straight line whenever it is detecting again so what is happening is that whenever the hand is detected we should put this x p and y p as zero so we will copy this part and whenever the hand is detected then we will make it zero actually no whenever the hand is detected no no no whenever we start drawing again so yeah whenever we start drawing again or whenever we have a selection whenever we have a selection then we are going to do that okay let's try that yeah now it's starting from the right position instead of a random position there you go so that is good so let me explain what is happening at the back so first of all we have our gray image and then we are converting it into an image inverse so let me display that image inverse so this is our inverse image so wherever i draw something it is going to draw but with black area so let's try that so as you can see it will draw with that black area right so that is the idea then the next step is that we add these images so we are adding with and we are adding the image inverse and the image so let me show you how that looks like so i will remove this part and we will run it we will see here that when we draw you will see that now it is showing us black region wherever we drew so all we have to do now is we have to add this image to this image so when we add this because here we have colored part here it's black here we have colored part and here it's black so if we do an or operation between these two it will give us our final image so here we were doing an and operation with the original image and the image inverse here we will do an or operation to add these two up and there you go so now it's moving around and the flickering you can improve if you have a better detection if you don't have a lot of noise so again uh it cannot be completely uncontrolled environment yeah the environment should be a little bit controlled to have some good results so if i go back you can see i can draw a few things and then if i go to the eraser if i go to the eraser and i select the eraser it will rub quite a bit again my conditions are not very well but you can get the idea and if i want to increase the size of the brush or the paint or whatever i can change it from here i can make this 100 for the eraser thickness and it will erase better so here if i draw something and then i can do this and i can go to the eraser and then i can erase you can see how that's how simple that is hey everyone welcome to my channel in this video we are going to create an ai based mouse controller we will first detect the hand landmarks and then track and click based on these points we will also apply some smoothing techniques to make it more usable so here we are in our pycharm project and we have created it by the name ai virtual mouse so what we have here is the hand tracking module now if you have not been following we have written this module from scratch so from the very beginning from the very first project we have added a lot of different methods to this particular class so now the thing is that in our previous project we added the fingers up method and the fine distance method and this will allow us to very easily create this new project so we will have a look at that how we can do that and this file of course will be available online on my website so a lot of you ask how do you access the code on the website you have to log in and you have to enroll to get access and of course it is free just enroll and you will get the access now if you have not been following you have to go to file settings and you have to go to the interpreter and you have to add the open cv open cv python and we have to install it and then we also have to install media pipe through which we will get all this hand tracking functionality so media pipe and we are going to hit install okay so now both of these are installed and we can hit ok so the first thing we will do we will go and create a new python file and we will call it ai virtual mouse project okay so what we will do is we will first import cv2 then we are going to import numpy as np and then we will import our module which is hand hand tracking module as htm and then we are going to imports import time now apart from all of this that we have been doing earlier as well what we will do is we will also add a new library which will allow us to move around with our mouse so with the python script we will be able to move our mouse we will be able to click on it there are a lot of these that you can use the one we are going to use is called auto pi so we are going to hit install on that so an error occurred so let me check again if we can install it okay so he was giving an error earlier but then i clicked on it again and it installed fine so we can close this and we can go back and now we can also import auto pi okay so the first thing we will do is we will run our webcam to see everything is working so we will write here cap is equals to cv2 dot video capture and we are going to write that our video id is one now you will use zero if you have one camera i have multiple so i'm using one now the second thing is that we have to have a fixed width and height so we cannot leave it to the default of the camera so we need to change our width and height so we will write here cap dot set and the prop id for width is three then the prop id for height is 4 so we will make it 480. so that's how you can define the word and height actually what we can do is we can put them in variables because we need to use them later on as well so let's declare our variables over here so we are going to write here that our width of the cam and the height of the cam is equals to 640 by 480 and we can just input these values here so this is the height of the cam and then we can simply go let's remove this and then we can simply go and write while true we are going to say success and image is equals to cap dot read and we are going to get our frame value so once we have this frame value then we are going to say cb2 dot im show and we will say that our image and then i mg and then cb2.weight key and one so this is pretty much that we have been doing in all our projects so let's run this and see if it works there you go so now you can see my webcam and there is my hand so that is all good so next what we can do is we can add our detector for the hand tracking but actually let's discuss what are the steps that we are going to take today to create this project so the first step will be uh let's put some numbering as well so it is easier to remember so the first step will be to find the hand landmarks so that will be the first step then the second step will be to get the tip of the index and the middle finger so the idea is that if we have just the index finger then the mouse will move if we have the middle finger up as well then it will be in clicking mode so if it is in clicking mode and if the distance between the two fingers is less than a certain value then we will detect it as a click so you can bring your fingers together and it will click so in that mode we are not going to move the mouse but in the index mode where we are moving uh that is the only mode in which we will move so what we can do here is that our second what do you call our second step will be to get the tip tip of the index and middle fingers so once we have the tip of the index and middle finger what we will do is we will check which of these fingers are up so we will write here number three check which fingers are up then in the fourth step based on this information we will check if it is in moving mode so we will write here only index finger which means it is in moving mode so we will move our mouse and if it is in moving mode then we are going to then we are going to convert our coordinates the units now why do we need to convert because our webcam will give us a value of let's say 640 to 480. so for my screen i have a full hd which means 920 by 1080 so we need to convert these coordinates so that we get the correct positioning okay so then okay it's bringing it back we can change that later then we will add another step to actually smooth in the values so why do we need to do that so that it is not very uh jittery it doesn't flicker a lot so we will write here smoothen values so we will smoothen these values and once that is done we can simply move our mouse so move mouse okay so this might seem a lot but it these steps are very easy some of them are single lines some of them just two lines so don't worry about these then number eight will be to check if we are in clicking mode so when both index and middle fingers are up then it is clicking mode so once it is clicking mode we will find the distance between these fingers so we will find distance this tends between fingers and if the finger is if the distance is short then we are going to click so we will write here click mouse if distance short so these are the 10 steps we have to follow and the 11th and 12th step is fairly easy so the 11th step is the frame rate to see if we are getting a decent amount of frame rate and the 12th step is to display so we have already done this display thing so we do not need to do anything more in that now what we can do is we can go on to the frame rate the frame rate is very simple as well we have done this quite a lot of times by now so we will simply write time.time and then we are going to write fps is equals to 1 divided by c time which is the current time minus the previous time and then we will write that the previous time is equals to the current time and then we will write cb2 dot put text image then our string which will we will first convert it into integer and then we will write our fps and then we are going to write the position so we will write 10 and let's say 50 or let's say 20 and 50 then we will write cv2 dot font cv2 dot font plane and then let's say for the thickness or this is the scale let's put it as three and then we have okay we need to go back then we have the color two five five uh let's keep it blue yeah and then we will write three this is the thickness so if we run this we should have here p time p times equals to zero so if we run this we should have our frame rate there we go so that is quite good okay so next we have the frame rate we have the display now we are going to do the actual part of all of these steps so first of all we have to get the landmarks to get the landmarks we have to declare here the detector we have to create the object so detector is equals to hdm dot hand detector and inside that do we need to add something we can add for example the maximum hands because we are only expecting one hand so we can write here one and the rest we can keep same then here we are going to go down and we are going to write that our image image is equals to detector dot find hands not fingers up find hands find hands and then we are going to uh find the positions of these hands so we are going to write here lm list and the bounding box so this is something that we added in our previous project and we will write here detector detector dot uh find position i think the spellings detector find position and then we will write image so we are sending in our image and that should detect it and it should also draw so let's run this and see if it detects we have an issue uh finance oh we have to give the argument of image my bad okay so there you go so now we are detecting our bounding box and we are detecting the fingers and the landmarks as well so that is pretty good so we are done with step number one and now we will check that if if our length of our lm list is not equals to zero then we are going to get the tip info so we can actually put this up here so here we will write x1 and y1 so these are the points of the index finger so we are going to write lm list and we will write that it is point number eight and we want from we want the element number one and two so we will write it like this uh the same thing we will do for our second finger which is the middle finger we will write x2 and y2 and here instead of 8 we will write 12. so this will give us the coordinates of our index and middle fingers so we do not need to draw these at this point so we can just print them out if you want to see we can print x1 y1 and then x2 and y2 so we can print those and we are getting an error x1 y1 not enough values to unpack expect it to got one why is that lm list let me check here what is the issue this is find position yeah and this is lm list and bounding box yes so that should be fine okay let's print out the lm list first print lm list let's check that yeah we are getting some values and they seem fine uh oh okay my bad should be one one and colin okay there you go so now we are getting the points there you go so now we are getting all these points so for the index finger and the middle finger we move them around you can see the values they change okay so this is good we are done with our second parts now we will go on to the third part check which fingers are up now this is extremely simple because we have already created a method by the name fingers up all we have to do is we have to call it we will write here detector dot find uh not find fingers up and we will store it in fingers so we can push this in and let's print out so print fingers and we will remove the print from here so let's run that so there you go so all the fingers are up all of them are closed one two three four and five so we are getting these values so that is pretty good now let's go to the next step which is okay let me push those all of these in okay so step number four is only index finger moving mode so now we need to check if only the index finger is up so we will write here if if fingers at 1 which is the index finger is equals to one and fingers at two is equals to zero so this is when the index finger is up and the middle finger is down so this will be moving mode so now we need to move our finger uh now we need to check where our finger is moving so we get those points and we send it to the mouse coordinates okay so first of all what we will do is we will write here that we need to convert so here we are converting our coordinates so we will write here that x3 is equals to we will write np dot interp we are going to convert one range to another range so here we are converting the x one value and the initial range is basically from zero to the width of our webcam and then the second range is from 0 to the width of the screen but we didn't get the width of the screen now i know that my screen is this size but it could be different for yours so in order to get the exact value what we will do is we will go up here and we will write here that our width of the screen and the height of the screen is equals to auto pi dot screen dot size so this will give us the size of the screen so if we remove the print from here and if we remove this statement and all of this uh yeah so then we can print this print w screen and height screen okay let's run this and there you go so now you can see it's telling me it's 9 to 1920 by 1080 so this is the idea now that we have these values let's comment this now that we have these values we'll go back here and we are going to continue that it is from 0 to the width of the screen so the same thing we will do with the height we will copy this and we will write here y3 and then we will write here y1 and then we will write here height and then height so this is the idea so these are the points that now we have converted and now we will send this value to the mouse we will smoothen these values but we will do that later on first we need to see what is the original result and then we can convert it so here we are going to write auto pi dot move mouse dot move and then we are going to write that our x3 and our y3 are our coordinates so let's try this and see what happens so you can see my mouse here if i bring in my hand and this is my index finger and now you can see it is moving but the problem is when i'm going to the right it's going to the left so this is very annoying and it is very it's not intuitive so what we will do is we will flip it in order to flip it we just need to flip the width so what we will say is we will say that whatever the width of the screen is screen is minus this so now if i go to the right it should go to the right so the image here will be flipped but in reality i'm moving to the right and the mouse is also moving to the right now if i move to the left the mouse is also moving to the left so this should be easier to work with so that is good uh what we can do is we can draw a circle so that we know that we are what you call moving the mouse so here we can write cv2 dot circle and we will write image and then we are going to write x1 and y1 so we want to draw on that and let's say 15 is the radius and the color is purple and then we will write cb2 dot build cv2 dot filled there we go so let's run that yeah so now whenever we are in moving mode then it will show us this big circle so that we know that we are in moving mode okay so this is good so now one of the issues here is that when i am moving when i'm moving i can go up very easily it's not that bad uh it flickers at the top much more than in the center but i can go there but if i want to go down it's very hard because the hand is not detected properly again if i move down you can see it's not detecting property and i'm unable to go down so what we can do is we can set a region where we want to detect the movement instead of the whole image size we can set a particular range so how can we do that first of all let's create that range so we will write here cv2 dot rectangle and we will set in our image and then we are going to call this let's say frame so this will be a certain value for example 100 or 200 something like that so we will call it frame reduction and we will also again call it frame reduction so we can go up and we can declare it here frame reduction is equal to let's say 100 so we will write here this is basically frame reduction reduction okay so that should be good now once we have the frame reduction what we can do is now we need to give in the second value so this is the initial value now we need to give the diagonal points so we will write here that the width of the cam minus the frame r and then the second point will be the height of the camera minus frame r then we will given the color 255 0 and 255 and then we will give in the thickness so this will draw a rectangle so let's try that so whenever we are in it's not drawing anything oh it is yeah whenever we are in okay um okay maybe we nee we need to put this outside so we can put it outside here because we won't always want to see it whenever we have the hand in we want to see it so now you can see we have our box now the idea here is that when i reach the top of this rectangle it should be the mouse should be at the top of my screen and when i reach the bottom of this it should be at the bottom of the screen so and same thing for the corners if i am moving at this corner it should be at the corner but now you can see it is not at the corner so again you can adjust these values up and down we will keep it in the center for now but later on if you want to you can adjust so how can you reflect this on our x3 and y3 so how can you change these values so all you have to do is it's very simple instead of 0 you will write here frame r you'll write here frame r and here you are going to write width of the cam minus frame r and height of the cam minus frame r that's it so now your values should reflect properly so here if i have my finger at the top right corner you can see it reaches the top right corner if i have it on the other side you can see it's reaching the top and now if i go back and i go down you can see it reaches down so we are having some issues as well it's going out of bounds uh we can fix those issues later uh what we can do is we can push this up as well a little bit so that it is easier for our fingers to move around but we can do that later we can move on to the next step which is to detect the click okay so then we are going to detect the click so here we have to check if both the index and middle fingers are up so we are going to copy this part and we are going to paste it here and we will write one and one so if both of them are up then we need to find the length of uh between our fingers so what we will do here is we will write that our detector dot find distance dot find distance between which points point number eight and point number twelve so uh these are the landmark ids so landmark eight and landmark 12 and then we will write image then it will unpack the values of length and then the image and then the what did i do here it should be comma and then we also get a bunch of info that we are going to ignore so the main thing that we need is the length so we need to know what is the distance between these two fingers so what we can do is we can write here print length and let's try it so when we are in our detection mode it is giving us the length and it is telling us uh there is a good indication because it actually gives a center point as well and it draws a line in between so that is pretty good okay so what we can do next is we can check that if the length is below a certain value then we will detect it as a click but we need to define that threshold so we are going to go back and let's try it out so here it should be open here it should be closed so i can see it's around 30 something so if it's less than 40 maybe yeah okay so we can say if it's around less than 40 then it is detected as a click uh you can do a normalization here as well but that will be quite a detail so we are not going to go into that so we will write here length is less than 40 then we are going to cv2 dot circle we are going to draw the same circle that we had drawn here but this time we are going to draw it in green so we have the detection that it has been clicked so let's try that so here there you go um we could draw it to the center one as well it will look better okay how can we do that basically this is the information we are getting for the line so we can write here info line or we can write line info and then based on this line info if we go to our fine distance you can see cx and cy are the last elements so this is the fourth and this is the fifth so we will write here this is the fourth and this here is the fifth push it down okay so let's run this and hopefully this time the center one will be green there you go so now it looks a little bit better so that's good okay so what is next now we actually need to click so rather than just changing it to green we need to click and the clicking part is way easier than you think uh and that is auto pi dot mouse dot click and that's it so now it should click uh by the way these two we are already uh doing so we should write here that we are checking the distance here and then we are clicking the mouse if the distance is short over here so that's the idea okay so let's try it so what i will do is i will try to click and minimize this this part here so here is my finger and if i move around and i click you can see it's shaking a lot yeah it clicked there you go it click again but as you can see it shakes a lot so this is a very big problem which is not allowing us to use this properly so what can we do as i mentioned before if we go up here we can smoothen the values so how can we smoothen the values so what we can do is instead of sending in exactly the same value that for example if it goes from 0 to 100 instead of saying go to 100 directly we will dilute it a little bit so we will smoothen it we will reduce its value so it goes step by step so what we can do is first of all we are going to create a value called smooth the ning is equals to let's say five so this is a random value that i've chosen uh later on we can see what is the effect okay so now what we will do is we will uh we need to also create two variables so what we will do is we will write here in fact we need to create more than two variables so we should separate the variable declarations here yeah that should be fine okay so what we will do is we will say that our previous location we will call it previous location of x and the previous location of y is equals to 0 0 and the current location of x location of x and the current location of y so again these will be 0 and 0. so what we will do is what did i do here so what we will do is we will use these values and we will update them each iteration to smoothen our mouse so here we are going to go here now instead of x3 and y3 we are going to send in the smoothened values of current location and we will update our previous location so how can we do that we will write here that our current location of x is equals to our previous location of x plus our x3 minus our previous location of x divided by the smoothing value so whatever the value is we will divide it by that and the same thing we will do with our y value so we can write here y you can multiply with this as well you can multiply smoothing as well then you will have to go into points so 0.1 0.2 or you can divide and keep it whole numbers it's up to you so we'll write here y3 and then we will write y and then we will write that's it okay so then we will just send in our x value and y value instead of x3 and y3 and then we will just update these values once we have uh use them so we will write here previous location x and previous location y is equals to current location x okay let's put y first current location uh current location x okay so that is the idea now uh let's put a very dramatic value let's say 20 and let's run it so now you will see if i move it around you see it is quite smooth but it is quite slow so we need to find you see when i stop it takes a while to stop so what we need to do is we need to find a good balance so let's try five so i like this it moves nicely and it stops it doesn't shake a lot there you go i can click as well there you go and let's click on the minimize there you go so yeah that looks good uh let's try 10. uh 10 is good but it's a little bit slower yeah it's hard to stop at that point yeah 10 is a little bit fast it is a little bit slower so maybe seven yeah this one is better there you go i can do that i can go to this one i can click on this one and this one again there you go so it is pretty good so that is quite nice so that is pretty much it as you can see it works quite well and we broke it down into different steps and when you go and try to solve each of these steps it becomes very easy to get a solution and all of this is possible thanks to our hand tracking module that we created earlier if we don't do that then it will be quite difficult and it will take quite a lot of time to actually create such a project but as you can see it was quite easy and quite simple what we achieved in this short amount of time so this is it for today's video i hope you have learned something new if you like the video give it a thumbs up and don't forget to subscribe and i will see you in the next one you
