With timestamps:

00:00 - tonight i'm going to talk about what i'm
00:02 - calling the modern web and i mean that
00:04 - from a user's experience as well as a
00:06 - developer's experience so i'll try to
00:08 - refer to that back and forth
00:10 - basically i want to talk about how
00:13 - this rich javascript ecosystem developed
00:16 - and kind of some of the big milestones
00:18 - along the way and then
00:20 - i'll show a couple samples of how that
00:22 - used to look and how it looks today
00:25 - a little bit about me i work at vmware
00:29 - i am a user interface engineer on the
00:31 - clarity design team
00:33 - and the clarity design system is
00:36 - a tool kit of ui
00:40 - guidelines and resources as well as a ui
00:45 - javascript html component library and
00:49 - then the really advanced components are
00:51 - actually written in angular so that you
00:53 - can add data and functionality and
00:54 - really make them work
00:56 - with an angular app internally they're
00:59 - heavily used throughout vmware's
01:00 - products so
01:02 - we kind of evolved the project with a
01:04 - focus on the enterprise
01:07 - and
01:08 - that kind of led us to take a different
01:10 - approach to our design system
01:12 - because we were starting on the desktop
01:14 - and degrading for mobile because most of
01:17 - our customers work on a desktop so that
01:19 - kind of influenced some of the design
01:21 - choices we made along the way
01:24 - [Music]
01:25 - so a little more about me i started
01:28 - writing javascript i don't know around
01:29 - 2004 or 2005 and
01:32 - this was back in the day when
01:34 - there wasn't any modern frameworks there
01:36 - wasn't any one way to do things
01:39 - and
01:41 - let's see
01:44 - as i moved through my career i started
01:46 - working with different people and when i
01:49 - started up a group out in westlake
01:51 - village that just wanted just
01:52 - like-minded people who wanted to meet up
01:54 - i often got questions about why is it so
01:56 - complicated
01:58 - um
02:00 - actually sorry i'm gonna back up i
02:02 - messed up so tonight we're gonna talk
02:04 - about the history and where javascript
02:05 - came from
02:07 - we're going to
02:08 - look at some of the
02:09 - dev tools that have evolved to help the
02:12 - developer experience
02:13 - and then i'm going to walk through
02:16 - what i call this timer app which is a
02:18 - simple
02:19 - application
02:20 - that has you know some specifications we
02:23 - could talk about
02:25 - and then show you how it could have been
02:26 - written 10 or 15 years ago in ecmascript
02:28 - 5 or earlier
02:31 - show you how you can
02:32 - turn it into
02:33 - a more modern syntax with es6
02:37 - and then i'll try to walk through a high
02:39 - level of what that could look like as an
02:41 - angular application in today's ecosystem
02:46 - so
02:46 - back when i started really trying to
02:49 - meet like-minded folks and and hang out
02:52 - with them i'd have conversations with
02:53 - some of the people who showed up to the
02:55 - meetup out in westlake village and
02:57 - they'd say things like
02:59 - um
03:00 - you know why is the web so complicated
03:02 - or i'm here i'm an engineer but i'm a
03:04 - backend engineer and i hate javascript
03:08 - or
03:09 - you know has anyone ever heard someone
03:11 - say i just want to use jquery
03:13 - in in a way that says
03:16 - it's not a good thing to be using jquery
03:18 - for what they're trying to do
03:19 - um so that's kind of who this this is
03:22 - for people who are new to web
03:23 - development or people who are voluntold
03:26 - to work on the web client
03:27 - and they
03:28 - have a lot to chew off and a lot to
03:31 - understand why things are the way they
03:33 - are
03:34 - so this will hopefully walk us through
03:37 - how we got to here
03:39 - you know we had things that people may
03:41 - be familiar with there's backbone.js
03:44 - knockout angularjs angular react vue we
03:47 - have javascript es6 typescript babel
03:50 - webpack gulp grunt
03:53 - and many
03:54 - many more that i didn't put on the slide
03:58 - even more than that there's so much out
04:00 - there there's no way
04:01 - any one person can be
04:03 - an expert or even know kind of all the
04:05 - tools
04:06 - so
04:07 - we got here
04:09 - you know by a couple different um
04:12 - important evolutions in javascript and i
04:14 - think it's important to understand those
04:16 - so that as you
04:17 - are bombarded with new tools every day
04:19 - you can kind of say you know what kind
04:21 - of niche does this fill and where did it
04:23 - come from you know what drove the
04:25 - evolution of this tool i'm using
04:29 - and the way i see it
04:31 - you know javascript has had a 20 plus
04:33 - year evolution and it has really five
04:37 - four or five
04:38 - phases or errors we could call them
04:42 - in the beginning
04:44 - it was very simple html css javascript
04:47 - throw it on a web server you're good
04:50 - then things got a little more
04:51 - complicated users want a little more
04:54 - functionality in their app it'll got a
04:56 - little more difficult for a couple
04:58 - reasons we'll outline in a minute but
05:00 - jquery came along and kind of helped
05:02 - solve those problems it helped really
05:04 - address some developer pain points and
05:06 - made things a little better for the end
05:09 - users of those apps
05:11 - but jquery had some problems too the
05:13 - more it got used
05:14 - the more
05:16 - pain that developers had using it and
05:19 - you know the some really smart
05:21 - developers said we can do better than
05:22 - this so
05:24 - what i call frameworks part one
05:27 - came about and these projects really
05:29 - helped kind of organize code bases
05:31 - organize teams around concepts and
05:32 - design patterns
05:34 - and then
05:35 - make it you know a better developer
05:37 - experience make apps a little bit closer
05:39 - to native uh a native app which users
05:42 - are really coming to expect around this
05:44 - time in the evolution
05:47 - and then i put tooling in between
05:49 - frameworks and
05:50 - um the the two framework parts mainly
05:53 - because
05:54 - it needs a home but it evolves kind of
05:56 - along the same time as the the
06:01 - the frameworks one and two there's a lot
06:02 - going on during that time and so we'll
06:05 - look at some of those tools and kind of
06:07 - how they they look in practice
06:10 - and then we'll we'll end up the history
06:11 - lesson with
06:13 - frameworks part two i'll look at two of
06:15 - the big big heavyweights in the industry
06:18 - today and then we'll go to a a
06:21 - demonstration i have of looking at that
06:23 - timer app three different ways
06:27 - um so way back when
06:29 - where did where did it where did it
06:31 - begin in 1989
06:33 - tim berners-lee
06:34 - created the world wide web he he started
06:37 - sharing documents with his friends
06:40 - around the world and making new friends
06:41 - kind of laying the foundation for what
06:43 - the web could become
06:45 - and
06:47 - he did it with html and css you know a
06:49 - little bit information a little bit of
06:51 - style um it wasn't real pretty by
06:53 - today's standards but it was you know
06:56 - leaps and bounds ahead of what anything
06:58 - else was at the time
06:59 - and that lasted for a couple years and
07:02 - folks started kind of expecting a little
07:04 - bit more out of the web pages or
07:06 - products needed to do a little more with
07:08 - their web pages collect information
07:10 - submit forms other things had to be you
07:13 - know people said what if we could do
07:14 - that
07:15 - and
07:16 - in a short two-week burst i think around
07:19 - 1995 or so brendan ike coded up
07:23 - javascript and
07:25 - you know here we are today but it all
07:28 - really started in the evolution of
07:30 - javascript you know that two-week period
07:33 - and it enabled a lot of things it
07:35 - created a lot of problems but those
07:36 - problems got solved and new
07:39 - new
07:40 - tools were built to address those
07:42 - problems
07:43 - so it was actually a really exciting
07:45 - time even though by today's standards
07:46 - you know a 1995 website probably looks
07:49 - pretty
07:50 - pretty
07:51 - arcane right now
07:53 - so some of the problems that they had
07:55 - were around the issues with standards
07:58 - and
07:59 - the need to do
08:01 - the same functionality for addressing
08:04 - multiple browsers and
08:06 - you know that was a big big pain point
08:09 - for developers because they spent all
08:10 - their time coding a feature
08:12 - five eight ten different ways depending
08:14 - on how many browsers
08:16 - were out there that they wanted to
08:17 - support and the browsers weren't crop
08:19 - cooperating because there's some nascent
08:21 - standards committees out there but
08:23 - the browsers didn't implement the
08:25 - standards the same way so you know it
08:27 - had a lot of problems for developers and
08:29 - they solved them they got through it
08:32 - but they needed another tool and around
08:35 - 2005 or so
08:37 - i think
08:38 - john
08:39 - john resig was his name he's the initial
08:41 - creator of jquery
08:44 - and there were a couple other tools out
08:45 - there at the time that are worth
08:46 - mentioning um
08:50 - my notes are gone
08:53 - um but the tools that i remember are yui
08:56 - framework the mootools i think prototype
08:59 - was another tool
09:01 - that tried to solve these problems in a
09:02 - way that developers didn't have to worry
09:05 - about
09:06 - browsers they could abstract the layer
09:07 - on top of the the code that would work
09:10 - and then
09:11 - the client delivered to the browser
09:12 - would figure out
09:13 - how to address each browser quirk as it
09:16 - as it is probably called
09:18 - um but jquery did five things really
09:21 - really well
09:22 - and it really enabled a massive adoption
09:26 - and
09:27 - the first thing that it did really
09:29 - really well is it exposed something
09:31 - called the jquery object
09:33 - and this was a thing that no matter what
09:35 - else jquery would do for you it let you
09:39 - extend it it let you build your own
09:41 - functionality so when you use jquery and
09:43 - it solves some of those other problems
09:45 - but you had a new problem
09:47 - you could write your own custom solution
09:49 - in jquery style
09:51 - and plug that into your app without
09:52 - having to
09:53 - worry about the browser quirks the
09:57 - other things that were going on
09:59 - the other thing it enabled with
10:02 - plugins is it was really the first time
10:05 - i saw a massive sharing of these tools
10:07 - people were saying well we solved this
10:09 - drop down menu issue and now if you want
10:11 - a drop down menu you can go to the
10:14 - there was a a
10:16 - sort of a pseudo repository of jquery
10:18 - plugins you could look for something see
10:21 - who was developing it and and use it in
10:23 - their your project and maybe even
10:26 - contribute back to it in the early days
10:27 - before github
10:29 - so that was one of the big things that i
10:31 - think helped jquery become the de facto
10:34 - tool that developers use when they
10:36 - really started looking for some
10:38 - structure and organization in their apps
10:41 - and then the second thing they did is
10:44 - they standardized dom access they made
10:46 - it
10:47 - very simple to find an element
10:50 - and do things to it and they did it in a
10:53 - way that abstracted above almost all of
10:55 - the
10:57 - browser quirks that were causing
10:59 - developers to
11:00 - not waste time but spend a lot of time
11:03 - making sure their app was performant and
11:05 - working in a wide variety of browsers i
11:08 - think that one was really important
11:12 - event handlers is a similar
11:14 - pattern to the dom access but basically
11:17 - they provided a standard way to
11:20 - find elements attach functionality to
11:22 - those elements and have it and not have
11:24 - to worry about
11:25 - it working in one browser and not
11:27 - another browser so those standard wars
11:29 - drove a lot of what
11:30 - the fundamentals of jquery saw problems
11:33 - that they solved
11:35 - the first thing it did is
11:37 - it baked in simple animations you know
11:39 - hide and show slide up slide down etc if
11:42 - you've ever seen an app that does that
11:44 - jquery provided an easy way to do that
11:48 - and it did two things it made it easier
11:50 - for developers to add some polish to
11:52 - their apps
11:53 - and it also kind of started to raise
11:55 - users
11:56 - expectations for what the web could
11:58 - become like it wasn't just a toy anymore
12:01 - when it looked and behaved a little more
12:03 - like a native app
12:05 - it was actually kind of cool to work on
12:07 - it it was kind of cooler to use it and a
12:09 - little more fun for everyone on both
12:12 - sides of that table
12:14 - and the last thing that jquery really
12:17 - saw the last problem that it solved was
12:20 - ajax and before
12:22 - you know you had a standard
12:24 - jquery library or api if you will
12:28 - you know you had to write ajax for
12:29 - multiple versions of browsers and
12:31 - identify
12:32 - quirks in one but not in the other and
12:35 - and tailor your application to deal with
12:37 - all that well just by using jquery you
12:39 - could abstract above that layer
12:41 - and move on to doing you know
12:44 - app development working on what your
12:46 - users wanted and i think this really
12:48 - drove
12:49 - a large part of the web forward way back
12:52 - in in
12:53 - period between like 2005 and 2010ish
12:58 - where we we got to what i call
13:00 - frameworks part one
13:02 - and this is where
13:04 - the use of jquery has proliferated and
13:06 - adopted you know adopted it been adopted
13:09 - at a massive scale
13:11 - but it started causing some of its own
13:13 - problems and if you notice a pattern
13:14 - here i think it's something that
13:16 - software development has always had and
13:18 - may never be able to get away from is
13:20 - you know you you build a tool that
13:22 - solves a problem you have and that tool
13:24 - is useful and it gets used a lot and
13:27 - the massive use of that tool causes more
13:30 - problems so you build another tool
13:32 - so these tools that came about kind of
13:34 - in this period were
13:35 - some of the early things that i consider
13:37 - is frameworks you could call them
13:38 - libraries
13:39 - collections of utilities
13:42 - the first one i heard about but never
13:44 - really got deep into using was something
13:46 - that called knockout js i believe it was
13:49 - used or came out of microsoft or a
13:51 - microsoft related project
13:54 - and it pioneered this idea of
13:57 - model view view model
13:59 - pattern a design pattern so anyone who's
14:02 - who's kind of
14:04 - educated themselves in computer science
14:06 - will know there's all kinds of design
14:08 - patterns that are useful
14:09 - but before
14:11 - before this time javascript really
14:13 - didn't have an easy way to apply those
14:16 - patterns some folks did it because you
14:18 - know they they figured out how to do it
14:20 - but it wasn't shared
14:22 - it wasn't
14:23 - adopted as a standard way of doing
14:25 - things
14:27 - so knockout kind of identified this
14:30 - pattern and then wrote some code that
14:32 - let you create an app with this pattern
14:34 - in mind and it helps you abstract your
14:36 - app up a level or two understand here's
14:38 - the pieces of my app this is the model
14:41 - this is the view and the view controller
14:43 - is what kind of glues them together
14:45 - fast forward a year or two and backbone
14:49 - said hey
14:50 - we like what you're doing maybe but
14:52 - we're going to do it a slightly
14:53 - different way i don't know if they said
14:54 - that but you know you know what i'm
14:56 - saying is a new tool that was developed
14:58 - in a similar pattern
15:00 - and it was the first one that i used in
15:02 - a real production context but basically
15:06 - the
15:07 - the library
15:09 - gave context and structure to help
15:12 - organize the code base
15:15 - and
15:16 - they did that by providing these three
15:18 - big building blocks models collections
15:21 - and views you know models obviously is
15:23 - where your data will live
15:25 - views is where your data will show up
15:27 - and be presented
15:28 - and then the collections wires them
15:30 - together and in between you know you get
15:32 - to write what happens and figure out how
15:34 - that behavior works so that one was was
15:37 - the first one i used and then the second
15:39 - one that i used starting i think around
15:41 - 2014
15:43 - 2014 or so was when i first came across
15:45 - angularjs
15:47 - just a quick note it is now angularjs
15:50 - and angular not there's two projects
15:52 - with the similar name but they're not
15:54 - the same we'll talk about that in a
15:56 - minute
15:57 - but angularjs
15:59 - did a similar
16:02 - similar thing in that they provided the
16:05 - model view view model
16:08 - controller
16:10 - pattern but they also
16:11 - said we're going to ship this framework
16:13 - with some opinions you know we're
16:15 - it came out of google by the way and
16:17 - they're very some very smart engineers
16:19 - there they had strong opinions on
16:22 - how things should be done how an app
16:24 - should be constructed so baked into
16:26 - their library is a very opinionated way
16:28 - of
16:29 - writing a router for a web a web app you
16:32 - know writing
16:34 - an http
16:35 - api that is used throughout the web app
16:38 - writing services that glue
16:40 - various controllers in your app together
16:43 - so they they put all that out there and
16:45 - angular took off in a very similar way
16:48 - to i think how jquery took off
16:51 - and
16:52 - that was good apps were getting more
16:54 - functional they were getting more
16:55 - native-like
16:56 - but developers were still having
16:58 - problems while these apps were being
16:59 - developed
17:00 - and so we had
17:02 - a wide variety of tooling kind of spring
17:06 - up alongside these frameworks and kind
17:08 - of evolve with these frameworks at the
17:09 - same time
17:11 - and there's really four i want to
17:12 - highlight here because
17:14 - they all sort of
17:16 - signify significant
17:18 - advances that make the developer
17:20 - experience in the modern web
17:21 - a lot better than it used to be
17:24 - the first one was um
17:27 - circa 2011
17:29 - ryan dahl was i his name i believe he he
17:33 - coded up this idea of hey i want to run
17:37 - javascript on my on a server and so he
17:39 - he released it to the world and
17:42 - it was this cross-platform javascript
17:44 - runtime that you could write javascript
17:46 - and run it from your command line on
17:48 - your computer and that was crazy because
17:50 - before that
17:52 - you had needed a web browser to do
17:54 - anything and
17:55 - this sort of gave a lot of fuel to
17:58 - javascript and after that
18:01 - people started scratching all different
18:03 - kinds of itches to make their lives as
18:05 - developers easier with javascript
18:08 - and
18:08 - they needed somewhere to
18:10 - kind of share and store those
18:13 - those utilities they were writing so
18:15 - right after or pretty close after
18:19 - node coming out npm launched and
18:22 - eventually was baked into node but it
18:25 - didn't start they started out as
18:26 - separate projects but basically it
18:29 - became this command line utility that
18:30 - you could use to search
18:33 - find install
18:35 - manage
18:36 - this exponentially growing
18:38 - group of tools and utilities all written
18:41 - in javascript
18:43 - and i'll show a sample package json in a
18:45 - second
18:47 - but fast forward a couple years and
18:50 - people were you know
18:52 - really solidifying how standards work in
18:55 - javascript and they were moving forward
18:56 - but browsers were still kind of causing
18:58 - a little problem they weren't adopting
19:00 - them they weren't shipping browsers that
19:02 - could
19:04 - consume modern
19:05 - javascript constructs so
19:08 - a really smart fella evan lee maybe
19:10 - what's his name i can't remember his
19:12 - name but the the creator of babel
19:15 - basically took that idea and said i want
19:16 - to write
19:18 - modern javascript languages i want to
19:20 - use it in a way that makes sense to me
19:23 - that makes my code easier to understand
19:25 - easier to architect
19:27 - and i want it to run in some of these
19:30 - older browsers that don't understand it
19:32 - and so he wrote this tool that takes
19:34 - that
19:35 - es6 es7 esnex now whatever version you
19:39 - want to write his tool will turn that
19:41 - into something that you know ie11 can
19:44 - run and
19:46 - it's a very powerful tool and what it
19:48 - does is it does this thing called
19:49 - transpiling
19:50 - which
19:51 - i think i i generally use the word
19:53 - compiling although it's not completely
19:55 - accurate but it transpiles your source
19:57 - code into something that the browser
20:00 - understands and
20:03 - you know away you go you get as a
20:05 - developer you get a better experience
20:06 - using the modern language but your your
20:09 - code still works in the the environment
20:12 - that the products live in
20:14 - and then finally
20:16 - all these things kind of highlighted the
20:19 - need for this idea of well how do we
20:22 - okay we can compile it and create it but
20:24 - how do we actually optimize it and split
20:27 - it up and get it ready for this modern
20:30 - web as as
20:32 - we realize you know not all the bits of
20:34 - our javascript are needed right away so
20:36 - how do we figure out how to do that and
20:37 - webpack came along after a couple other
20:40 - sort of orchestration tools
20:42 - were used for a few years
20:44 - and they basically help you package up
20:46 - and optimize your application for
20:48 - delivery to the web
20:52 - so real quick this is a just a sample
20:55 - npm package manifest and i want to
20:57 - highlight three things here that
20:59 - i i think are they're important to me
21:02 - for understanding what npm is and what
21:04 - it does for you
21:06 - it lets you organize your dependencies
21:10 - which
21:11 - is
21:12 - turns into a little javascript object
21:15 - and it basically
21:17 - tells you what the name of your
21:18 - dependency is and tells you what version
21:20 - you have it have in your project
21:22 - and
21:23 - dependencies are things that are going
21:25 - to get packaged up and used inside your
21:28 - app when it's delivered to the client's
21:29 - browser
21:31 - it also lets you manage these things
21:32 - called dev dependencies because as these
21:34 - frameworks were evolving and getting
21:36 - more complicated you know files were
21:38 - getting bigger
21:39 - where webpack and grunt and gulp were
21:41 - doing things like let's concatenate all
21:43 - of our javascript into one massive file
21:46 - but now we need to make that file
21:48 - smaller so there's a bunch of tools that
21:50 - people wrote to help them automate that
21:51 - and do that and the dev dependencies you
21:54 - install will
21:56 - will help along those lines they'll
21:58 - provide some little effort that helps
22:00 - automate your app building experience
22:02 - and typescript is one of those that i
22:05 - use in the angular projects i work on
22:08 - and then scripps was one of the coolest
22:10 - things i think it was one of the first
22:12 - things i gravitated to
22:13 - in npm and basically
22:16 - with this
22:18 - complications that were added to the
22:20 - build process for an app
22:22 - you needed a way to
22:24 - not have to remember
22:26 - babel build command with arguments one
22:29 - and two and at this file in that file so
22:33 - the scripts kind of gives you an area
22:36 - where you can customize the
22:38 - developer experience for your app it it
22:40 - gives you the ability to
22:43 - write a shell script if you want write a
22:45 - node script if you want and then execute
22:48 - it with a simple npm run
22:50 - my command and do a lot of complicated
22:53 - things without having to remember what's
22:55 - going on except for the first time when
22:56 - you write write that script
23:00 - so that was a i think the npm
23:03 - besides jquery the npm evolution and
23:06 - adoption was a big milestone in in the
23:08 - javascript evolution
23:10 - and finally we come to frameworks part
23:12 - two
23:13 - and there are a couple out there i'm not
23:15 - going to
23:16 - talk too much about vue or elm there's a
23:19 - couple others but they're
23:20 - projects that do you guys use album no i
23:23 - do okay cool
23:25 - there's a big fan of it on my team but
23:27 - um
23:28 - they're projects that kind of built on
23:30 - what the first generation of frameworks
23:32 - kind of learned the mistakes they made
23:35 - they figured out how not to make them
23:36 - and the good things they kind of carried
23:38 - them over
23:39 - so react was the the first one i would
23:42 - consider was like the more evolved of
23:44 - the frameworks and it was
23:48 - kind of came out of facebook in 2013.
23:51 - it's its claim to fame was
23:54 - really they wanted to
23:56 - well they had a massive
23:58 - scale for their applications so i don't
24:00 - know there were 700 800
24:02 - million people back in 2013 maybe a
24:04 - billion
24:05 - and so they had a really large data set
24:08 - that needed to
24:09 - get into their apps and use the data
24:11 - and they had a couple key principles
24:14 - that i think helped them manage the
24:17 - large changes that were coming down with
24:19 - these massive data consumptions by
24:21 - client apps
24:22 - and so they oops
24:25 - they
24:26 - they pioneered this concept of one-way
24:28 - data binding if you're familiar with
24:31 - an immutable state they figured out hey
24:34 - it's better if
24:35 - if our app knows
24:37 - there's one source of truth and when
24:39 - that source of truth changes everybody
24:41 - gets the update at the same time
24:44 - and the way they did that is by
24:46 - working with something called the
24:47 - virtual dom
24:49 - because we all know that it's extremely
24:51 - expensive to query the dom dig into the
24:54 - dom make changes to the dom what they
24:56 - said is instead of doing that
24:58 - let's just take a picture of the dom
25:00 - let's see what it looks like and then
25:02 - when we know there's changes let's take
25:04 - another picture that's a very
25:05 - lightweight process and then we'll see
25:07 - what's different and then we can narrow
25:09 - in on those small set of changes
25:12 - zoom in to that part of the the
25:14 - application and update it when it needs
25:16 - it and it helped really kind of increase
25:19 - the performance of apps and helped um
25:22 - i think
25:23 - consumers kind of become really
25:25 - comfortable with some slick apps that
25:27 - started to approach a native feel
25:30 - and then angular 2016 so i mentioned
25:33 - before there's angularjs and there's
25:35 - angular
25:37 - so the first version of angular
25:40 - angularjs today kind of was there was a
25:43 - line drawn in the sand and i think they
25:45 - had some
25:46 - some lessons that they learned and they
25:48 - wanted to move forward but they couldn't
25:50 - move forward with the legacy code base
25:51 - so it ultimately ended up being
25:53 - an a complete rewrite and so
25:56 - you know for developers like me we i i
25:59 - resisted jumping into angular for a
26:01 - while and then
26:03 - now i'm not even sure why i hesitated or
26:06 - waited because a lot of the decisions
26:07 - they made were really good for my
26:09 - developer experience but the couple of
26:11 - things they did that i think are worth
26:13 - highlighting is they wrote it in
26:16 - typescript
26:17 - typescript is a typed
26:20 - language that is a superset of
26:22 - javascript and it compiles down to
26:25 - javascript even more interesting is that
26:28 - you can
26:29 - one you can use it in in any framework
26:31 - if you want but
26:34 - you can target specific versions of
26:36 - ecmascript so you can say i need my code
26:37 - to run an es3 because we've got this
26:40 - ancient thing running on a kiosk in this
26:43 - little mall well
26:44 - typescript will help you do that and
26:46 - give you the tools to write code in a
26:49 - modern way that can run on browsers that
26:51 - may have been around 15-20 years ago
26:55 - the other thing they did was
26:58 - they can't
26:59 - they instead of using the immutable
27:01 - pattern they have this idea of
27:03 - dependency injection
27:04 - which is a i think a carryover the first
27:06 - time i saw it was in java world
27:09 - where you annotate your classes with
27:11 - other bits of information so that when
27:14 - you build your app
27:16 - it knows hey this class needs to know
27:18 - about this service and a service in
27:20 - angular world is really just something
27:22 - that's a singleton that can act as a
27:24 - single source of truth for an
27:26 - application
27:28 - and finally the one thing that i think
27:30 - angular is kind of doing better than
27:32 - even react but react has something
27:34 - similar that's making pretty quick
27:36 - strides is they have this idea of the
27:38 - angular cli
27:40 - so the angular cli is a tool that lets
27:42 - you
27:43 - create a new app with one command line
27:47 - process and
27:49 - it will let you add a component and what
27:52 - it's doing under the hood is it's
27:54 - writing all this boilerplate out to the
27:56 - file so that you don't have to create a
27:58 - new class you don't have to tell your
28:01 - app module about that class because
28:03 - things have gotten a lot more
28:04 - complicated
28:06 - this is a tool that helps kind of
28:07 - alleviate some of that complications
28:11 - so that's
28:12 - that's what i have for the history
28:13 - lesson
28:14 - i'm going to jump over to my computer
28:17 - and kind of walk through that timer app
28:19 - and we'll see how it goes
28:23 - good
28:24 - um
28:26 - miss it sorry
28:28 - thank you
28:34 - all right
28:36 - all right
28:37 - so
28:41 - is that big enough can everyone see
28:44 - if it's too small let me just shout out
28:46 - and i'll bump it up
28:49 - so we have here what i'm calling a
28:51 - native timer app and we're going to look
28:54 - at it in es5
28:56 - ish
28:56 - syntax this is something that i would
28:58 - have written
29:00 - 2000 2005 maybe maybe earlier
29:03 - if you look at the structure of the
29:05 - project you have an index
29:07 - you have a source we're going to ignore
29:09 - this i wasn't sure if i'd have internet
29:10 - access so i didn't want to uninstall my
29:12 - node modules
29:14 - you have this idea of assets where i
29:16 - just put an image and a css file but you
29:19 - might have had another folder for images
29:20 - another file for folder for styles if
29:23 - you had a more complicated web page you
29:24 - might have multiple ones of those
29:26 - but i think you get the idea that it was
29:28 - it was pretty simple it was an easy
29:29 - structure to understand and in order to
29:32 - run this app all you had to do was
29:34 - deliver it to a web server
29:36 - and clients just needed to go to the web
29:38 - url and they're good to go
29:40 - so
29:42 - my timer has
29:43 - some requirements um
29:45 - let me talk about those real quick so
29:47 - basically we need to start the timer we
29:49 - need to stop the timer we need to mark
29:51 - times and list them out somewhere we
29:54 - need to tell the user when the the timer
29:56 - is running and we need to tell the user
29:58 - when they've added a time to their list
30:00 - and
30:02 - the way i i did this in
30:04 - es5 is
30:06 - you know we have a simple html document
30:09 - and we add in our style
30:12 - we add in our script which we'll get to
30:15 - in a minute and in between there we we
30:17 - have
30:20 - an element we call app and that app has
30:23 - three parts
30:24 - i if anyone knows how to get rid of
30:26 - those things in vs code let me know
30:28 - because
30:29 - the things that pop up i don't probably
30:31 - have to disable an extension okay
30:34 - i'll have to look because it's been
30:35 - bugging me for a couple days but there's
30:38 - three sections there's the timer display
30:39 - where we show the the current time then
30:42 - there's the the buttons that let the
30:44 - user start stop mark do do whatever they
30:47 - need to do
30:48 - and then we have a list for each
30:50 - each time that we want to record and
30:52 - make note of
30:54 - so the way i i kind of went back to
30:58 - the early days at least as far as i
31:00 - could remember them
31:02 - is
31:03 - i i wrote it all in one script
31:06 - you know i had to know if it was running
31:08 - so i gave it a global state
31:10 - i had to know where my app was so i used
31:13 - the the native web apis to get the
31:16 - element and get a reference to it
31:20 - then i created a function that i could
31:21 - pass
31:22 - an element to and
31:24 - if you look closely at the code you'll
31:26 - obviously see there's some some room for
31:29 - optimizing it and refactoring it a bit
31:31 - but when you call this function it
31:32 - passes an element that is used in a
31:35 - couple different places to
31:38 - add in the time
31:40 - that is the current one for our
31:42 - calculations
31:44 - and then we have a couple functions that
31:46 - we can use to attach to elements
31:50 - for starting the timer
31:52 - resetting the timer
31:55 - marking the timer
31:56 - resetting the the timer
31:59 - and so that's kind of all encapsulated
32:01 - in a function and this is probably even
32:04 - more advanced than
32:05 - 95 to 2000 javascript was written but
32:09 - it was worth encapsulating for the
32:11 - purposes of this but then in order to
32:13 - get that functionality onto my elements
32:16 - i had to bind those functions to them
32:18 - somehow and the
32:20 - the way we have today is the web api for
32:23 - add event listener
32:24 - so i can isolate the click events and
32:27 - then add a function that does some stuff
32:30 - it checks the global state which we all
32:32 - know is a bad thing but
32:34 - you know we use the tools we have
32:36 - it adds
32:37 - it adds a class list to this app
32:40 - variable that if you remember is defined
32:43 - up top where we we know
32:45 - kind of what that reference is to
32:49 - and finally it
32:51 - it does a
32:52 - it sets an interval that calls this
32:54 - start timer function every 100
32:57 - milliseconds
32:58 - and if you remember that timer function
33:01 - all it's doing is
33:04 - you know looking at what the current
33:06 - time is
33:07 - figuring out how much time has passed
33:10 - and kind of formatting that that
33:13 - a little that number a little bit so
33:14 - that we can have a decimal in our user
33:17 - interface
33:18 - and and that was that was kind of the
33:20 - extent of the early javascript projects
33:23 - that i could come across it was a lot of
33:25 - we want this functionality
33:27 - and we need to do it this way and so you
33:29 - you kind of threw it all into one file
33:31 - you tried to avoid global state if you
33:32 - could but you
33:33 - usually had something that couldn't be
33:36 - isolated and so it ended up in there and
33:39 - and it caused you know enough problems
33:41 - that javascript evolved past that and
33:44 - jquery came along
33:45 - and i don't have an example with jquery
33:48 - i'm going to move right to turning this
33:50 - code into es syntax so it's going to
33:52 - look very similar
33:54 - but
33:55 - it's uh worth highlighting that that's
33:57 - what drove you know the react and the
34:00 - angular's frameworks for today
34:03 - so if we
34:09 - check out the es6 app
34:14 - the built-in one
34:16 - for
34:18 - built-in one for vs code um
34:21 - oh i use the z shell
34:23 - and i forget with some theme
34:25 - whatever
34:26 - something i customized once years ago
34:28 - and forgot about
34:30 - so now you'll notice i have a similar
34:33 - structure
34:34 - to the es5 app but the index is gone
34:37 - i now have a package json that lets me
34:39 - take advantage of what npm brings in to
34:42 - the developer experience
34:44 - i have this git ignore just tells me
34:47 - tells my app when not to care about for
34:49 - version control
34:51 - and there's this babel rc which is an
34:53 - object that babel uses
34:56 - and this is where i tell babel here's
34:58 - what i want to do with this code and
35:01 - i'm telling them use this
35:03 - es 2015 presets
35:05 - and when you compile the code i'm
35:07 - writing for distribution
35:10 - include source maps in there
35:13 - so if i run babel without doing anything
35:15 - else it will look for this file and
35:17 - it'll use those
35:18 - pre-configured
35:20 - presets to generate output code
35:24 - you'll notice there's uh
35:30 - there's no assets uh oh
35:32 - oh
35:34 - interesting i hope i didn't mess it up
35:36 - um
35:38 - oh i forgot to show the es5 app running
35:40 - but don't remind me to show this one
35:42 - running i'll show it in a minute
35:46 - and now i'm not sure why that's there
35:48 - all right
35:50 - so in our source
35:52 - we have what you could consider the
35:54 - the structure of our application
35:56 - everything outside of it is some sort of
35:58 - dependency that we need to build
36:00 - the app and deliver it so we still have
36:02 - our index
36:03 - it still looks like the same html
36:06 - structure
36:07 - but we put our assets inside there we
36:09 - have some images and a style sheet and
36:12 - then we have an application that
36:15 - with uh
36:17 - with a saturday afternoon of time to do
36:19 - all these demos i turned into
36:22 - something that's es6 so basically the
36:24 - biggest difference here is that
36:26 - i removed the global state from
36:29 - the
36:30 - application and i wrapped it into a
36:32 - single class
36:33 - and i put as much functionality in that
36:35 - class as possible and using es6 i can do
36:39 - a lot of things in the constructor when
36:41 - someone initializes a new
36:43 - a new instance of this timer app
36:45 - we can do a bunch of things ahead of
36:47 - time and say oh you find this find this
36:49 - element and give me a reference to it
36:51 - find this other element give me a
36:52 - reference to it and that instance of the
36:55 - timer can now
36:57 - work isolated by itself in the browser
37:00 - and not worry about stepping on other
37:02 - bits of javascript's toes
37:04 - we still add an event listener
37:07 - and bind them to click handlers
37:09 - one thing to note is i had to pass in
37:12 - this which if anyone who's done a lot of
37:14 - javascript development they'll know
37:16 - scoping
37:17 - is a mysterious and dark art but
37:20 - basically passing that in lets my
37:21 - function run and understand what its
37:24 - state is
37:25 - you didn't want to use low dash
37:27 - i try to keep it as minimal as possible
37:29 - for for this demonstration
37:31 - just as pure vanilla javascript as
37:33 - possible
37:35 - and then notice that these
37:37 - these click handlers
37:39 - are inside encapsulated inside my class
37:42 - and they do basically the same thing
37:44 - they add a class
37:45 - if it's running
37:47 - they have a check
37:48 - and they set an interval to calculate
37:50 - the new time
37:52 - they have a a way to stop the timer
37:55 - remove the interval so that the timer
37:57 - stops and invite in etc we can reset the
38:01 - app we can mark the time and so then
38:05 - i now have a nice encapsulated bit of
38:07 - code that i can initialize in my global
38:10 - state with a new simple variable and a
38:12 - function call that says hey i want a new
38:14 - timer
38:15 - so
38:17 - to see what this looks like running i
38:18 - apologize for not showing the es5
38:21 - it looks the same though except for the
38:23 - background image
38:25 - so if we open up that
38:30 - index.html
38:32 - if we open it up we get a nice little
38:34 - app we have some buttons
38:36 - we can start our timer
38:39 - and i broke it
38:40 - oh no
38:42 - let's go back to the es51 i'll show you
38:44 - running there i'm sorry about that
38:49 - i do not like live coding if it
38:51 - if it's at all possible but
38:54 - let's see kit check out
38:57 - actually yeah
39:08 - all right
39:09 - so we have a timer i can start it
39:12 - i can tell the user is running
39:14 - i can mark some laps when i mark a lap i
39:17 - let them know hey it's running
39:19 - i can stop the timer
39:21 - one thing to note is
39:23 - i could still add times and that's
39:24 - probably a bug you wouldn't want
39:27 - multiple things of the exact same value
39:29 - in your collection so
39:31 - i could write a bunch of code to kind of
39:33 - look at that array and and figure out do
39:36 - i put it in or not put it in or just put
39:38 - everything in there and figure out we'll
39:39 - only show the unique things
39:41 - but you know modern javascript gives us
39:43 - things like sets
39:45 - which we know you know is a data
39:47 - structure that lets you just put in
39:49 - one unique thing and if you try to put
39:51 - another thing in it doesn't even error
39:53 - for you it just says thanks no
39:55 - and goes on about its way so
39:58 - i'll show i use that in the angular app
40:00 - basically to
40:01 - fix this bug so
40:03 - that's the app it resets
40:05 - and that kind of takes us up to these
40:08 - modern frameworks where there's a bunch
40:09 - of tooling and so what i'm about to show
40:11 - in the angular app is going to be a
40:13 - little more complicated i'll try to hit
40:14 - these
40:15 - high level you know what's the global
40:17 - state look like
40:19 - what's the dom manipulation for angular
40:22 - look like and then what's the event
40:24 - binding and how would you get this app
40:26 - to production
40:28 - so if we go back to code
40:31 - all right i have this thing called an
40:33 - angular timer
40:35 - and so if you haven't worked with
40:36 - angular before has anyone worked with
40:37 - angular here before
40:39 - all right so not a whole lot so
40:42 - i'll try to kind of
40:44 - help you understand how the project is
40:46 - organized
40:47 - again we have
40:49 - a json file and you'll notice
40:52 - that it it has a couple scripts i
40:54 - generated this app with angular cli so i
40:57 - didn't actually write any of this
40:59 - it gives me something that i can use to
41:01 - start my application which has a
41:03 - built-in local development server so
41:06 - that gives me the ability to do things
41:08 - like write code save and it
41:10 - automatically reloads my browser so that
41:11 - by the time i flip over from my editor
41:13 - to the web browser i already see my code
41:16 - running or not running in the web
41:18 - browser linting is basically a way of
41:21 - keeping your code clean to certain
41:24 - preset
41:25 - configurations of like oh you should
41:27 - always have a semicolon or you should
41:29 - always indent two spaces etc so they
41:32 - bake that into the app generation for
41:34 - the angular cli tool and then ede is is
41:37 - end-to-end testing um they have a
41:41 - another framework that is useful for
41:43 - testing angular applications there's a
41:44 - bunch of
41:46 - other projects out there that you can
41:48 - kind of dig into if your use case are
41:51 - different that are have their own
41:53 - sort of
41:54 - use cases and fans for following but you
41:57 - see here in our dependencies we have a
41:58 - bunch of angular stuff we have this core
42:00 - js we have this rxjs and we have the
42:03 - zone.js all the angular stuff is what
42:05 - makes angular work for me
42:07 - and the other stuff are things that
42:09 - angular depends on
42:11 - if you're not familiar with rxjs i'd say
42:13 - that's one of the coolest things i've
42:15 - really had to dive into in the last
42:17 - couple years uh it's worth
42:19 - it's worth learning if you ever went
42:21 - from
42:22 - jquery call back hell to oh my god
42:24 - promises are awesome
42:26 - you'll you'll be a fan of observables
42:28 - when you when you get into them that's
42:30 - worth noting there and then all these
42:32 - dev dependencies this is how we build
42:34 - and ship this app in an optimized way
42:37 - for production so everything that the
42:39 - angular cli needs to build my app is
42:41 - installed in my node modules and then
42:44 - when i run
42:45 - the the right command it packages it all
42:47 - up it optimizes it and it gets it ready
42:50 - for me to
42:51 - do something with
42:53 - so that's the package
42:55 - the code itself
42:56 - angular needs to know a couple things
42:59 - about my app and i can change them and
43:01 - configure them as i need to but
43:03 - basically it has a configuration object
43:05 - the main things to see here is this
43:07 - prefix
43:08 - and
43:10 - schematics prefix is something that
43:13 - we'll use so every component i build in
43:15 - an angular app
43:16 - will basically be very similar to a web
43:19 - component so it'll have its own um
43:23 - html like signature where i can bracket
43:28 - app dash timer
43:30 - close close bracket and then close close
43:33 - that like you would close any other div
43:35 - or section or
43:37 - whatever
43:38 - but this tells app when you create new
43:40 - components prepend this app so if i want
43:42 - to customize that for
43:44 - my uses i just change it there
43:46 - everything that gets generated gets that
43:49 - prefix and then schematics is something
43:51 - that i haven't seen anybody else doing
43:54 - this but it's this idea that
43:57 - i think angular wants to make it really
43:59 - easy to update and maintain
44:01 - client applications so the clarity
44:03 - project that i work on is a ui
44:06 - library it's a module it's not an app
44:08 - and our customers kind of depend on us
44:11 - to keep breaking changes to a minimum or
44:14 - not include them at all unless we're
44:16 - bumping a major version
44:19 - and the schematics is a tool that lets
44:22 - you work within the angular ecosystem
44:23 - and say
44:24 - ng add at clr angular
44:27 - and it'll install this tool
44:30 - the the clarity angular components
44:33 - it will also we also have the ability to
44:35 - say hey we know this is an angular
44:36 - application instead of you having to go
44:38 - and put our clarity module into the
44:41 - application we'll do that for you we
44:44 - know where it goes we'll import it we'll
44:45 - add that
44:46 - and
44:48 - when you use our components it's all
44:50 - ready for you to go you don't have to do
44:51 - that boilerplate configuration yourself
44:53 - the other really powerful thing that the
44:56 - schematics does
44:58 - for me as a library maintainer is that
45:01 - when i do have braking changes or
45:03 - deprecations
45:05 - and you install my project with the
45:07 - angular cli
45:08 - i can scan your code base and say hey
45:12 - this thing you're using is deprecated in
45:14 - this version
45:15 - and i can write a custom note for here
45:18 - look here and see how long it's going to
45:20 - be
45:21 - in you know in the clarity library let's
45:23 - see when we're going to remove it
45:25 - even more powerful if it's not too
45:27 - complicated of a change
45:28 - and we deprecate something and you don't
45:30 - update it
45:31 - when you install it with the schematics
45:33 - i can provide a template for hey you're
45:35 - using this old thing
45:37 - turn it into the new thing so that
45:38 - deprecations or removals magically get
45:41 - handled or notified hey you're
45:44 - installing a version that this thing no
45:46 - longer exists and and your app's going
45:48 - to horribly break and we want to let you
45:50 - know about it as soon as possible so
45:52 - that's a very powerful thing that
45:54 - schematics brings to the angular
45:55 - ecosystem
45:58 - so real quick
46:00 - what that looks like um
46:02 - [Music]
46:03 - is
46:05 - as i said angular is a tree of
46:07 - components and so you start with a root
46:09 - component
46:10 - and the way you
46:12 - you get that started is kind of glossing
46:15 - over the bootstrapping process as we
46:17 - still have
46:18 - an html file but it gets really simple
46:21 - you notice there's no styles there's no
46:23 - scripts so when we build the app
46:26 - angular cli and all the and webpack is
46:29 - actually the build tool underneath there
46:31 - um
46:32 - it's configured good enough for 90 of
46:35 - the use cases if you really need to you
46:37 - can eject out of the default
46:39 - configuration and customize it but
46:43 - i i don't see the need for my uses
46:46 - but what i want to say is
46:47 - our app gets started with this custom
46:49 - like element called app root
46:52 - and
46:53 - we have a component
46:56 - and you'll notice we have a selector
46:58 - called app root so when angular comes
47:00 - across this element it knows what it is
47:04 - it knows what template to apply to it
47:07 - and it knows what style to go with it
47:10 - and there's a couple different ways to
47:12 - do it but the default version of angular
47:14 - encapsulate all encapsulates all of that
47:17 - css
47:18 - in a way that makes
47:20 - style conflicts impossible
47:22 - so
47:23 - the names that i use for this component
47:25 - in this style sheet couldn't ever
47:28 - conflict with something else some
47:30 - somewhere in the the webpage of the
47:32 - application
47:33 - you'll notice there's not a whole lot
47:34 - going on here we just have this app root
47:36 - and this template so if we look into
47:38 - that template it'll kind of feel like
47:39 - we're starting to walk into
47:41 - a tree
47:43 - where we have another
47:46 - another custom like element called app
47:48 - timer and that's really the meat of
47:50 - what it took to turn that es6 code into
47:53 - an angular app
47:54 - and i basically had to have
47:56 - four components
47:57 - i had the timer component and we'll look
48:00 - at the code in a minute
48:01 - we have the the button bar we have the
48:03 - display and we have the mark list so if
48:05 - you remember those basic
48:07 - div elements we had they basically
48:09 - become
48:10 - first class citizens of my app they can
48:12 - have their own encapsulated style their
48:14 - own encapsulated functionality and the
48:16 - tools that angular
48:18 - provides gives me the ability to manage
48:20 - global state with basically in an
48:22 - angular app you don't really need global
48:24 - state you can encapsulate all that state
48:27 - inside the typescript files and kind of
48:29 - work confidently
48:31 - inside there um so for something like
48:35 - dom manipulation
48:37 - if we look at the timer display which is
48:39 - the big number of what the current time
48:41 - is
48:42 - you'll see
48:44 - we'll start with a template this time
48:46 - and this could have been in line into
48:47 - the typescript code but i apologize i
48:49 - was a little too lazy to to do that um
48:52 - but for smaller templates generally five
48:54 - to ten lines or less i'll inline them
48:57 - into the typescript file itself anything
49:00 - that gets bigger it's worth kind of
49:02 - separating it out it gets too
49:03 - complicated and there's two things going
49:05 - on here we'll come back to time format
49:07 - but basically
49:08 - in my
49:09 - in my timer display component class
49:12 - there's a variable called current time
49:14 - and whatever that current time is it
49:16 - will get interpolated in this template
49:20 - with that value
49:21 - the other thing angular will do for me
49:23 - is it will pass that value to this time
49:25 - format function which i'll show you real
49:27 - quick and kind of explain at a high
49:29 - level what it is and and what it does
49:31 - for me
49:33 - so then we have
49:34 - the component itself
49:37 - and
49:38 - you'll see it follows a similar pattern
49:39 - we have you know we import the stuff we
49:41 - need from angular we import our timer
49:43 - service which we'll talk about in a
49:45 - minute
49:46 - and then we we decorate our component
49:49 - with these
49:50 - this metadata for what selector is used
49:54 - what template is used with this class
49:57 - and what style goes along with it and
49:58 - angular does the work of packaging that
50:00 - all up encapsulating it and delivers it
50:03 - to your browser
50:05 - and our class looks pretty simple
50:07 - remember we have that current time
50:09 - property
50:10 - and we have two things going on here
50:13 - we'll come back to the timer service
50:15 - remember how i said you know dom
50:17 - manipulation and data binding
50:20 - and things that jquery kind of brought
50:22 - to the table well angular has this idea
50:24 - of decorators and so that component is a
50:27 - decorator
50:28 - at host binding as a decorator because
50:30 - angular views this class as the host
50:34 - anything that lives inside there in
50:35 - terms of an html template is is a child
50:39 - of the host it's a view it's part of the
50:41 - view for that host
50:43 - and so
50:44 - when i use the at host binding decorator
50:47 - angular knows hey
50:50 - when this cloud this thing is true
50:53 - add the class timer display to this host
50:56 - so in my browser i'll have this app
50:58 - timer display element and it'll have
50:59 - class equals
51:01 - timer display and now i can target css
51:04 - for that host and and write things that
51:07 - i wanted to do
51:09 - the other thing that's going on here is
51:10 - remember how
51:11 - i
51:13 - we we talked about not having global
51:14 - state but we still need to to maintain
51:17 - state for our app and pass it around
51:19 - so angular uses that rxjs project
51:23 - and it
51:24 - basically
51:25 - gives me the ability to create a stream
51:28 - of time events and
51:30 - if you're familiar with rxjs it's
51:32 - basically what i'm doing is subscribing
51:34 - to an observable that basically
51:38 - passes every new time to whoever
51:40 - subscribes to it so in this case i
51:42 - subscribe to new times
51:44 - and whenever they're generated i hear
51:47 - about them and whenever i hear about
51:49 - them i run this lambda function in line
51:51 - that sets the new time value to this dot
51:54 - current time and we show up in our
51:57 - browser is this similar to the idea of
51:59 - having connected components to like a
52:01 - redux state for example
52:04 - it's similar it's not redux though it's
52:07 - not one-way flow same same idea of
52:10 - having components to be listening to a
52:11 - global state
52:12 - uh it's it's it's components listening
52:15 - to a state but
52:16 - i could give a whole
52:18 - 20 30 minutes in
52:20 - how the angular providers are organized
52:22 - at a high level these providers are
52:27 - a tree so angular gives you
52:29 - this thing called an injector and you
52:31 - can put providers in there so if you put
52:34 - it high enough up the tree your provider
52:36 - is available to the entire app
52:38 - but if i i say hey i want to define my
52:40 - provider at a lower level at this
52:42 - component level
52:44 - then
52:45 - you'll notice
52:47 - where is that
52:49 - uh if we go back to highlight that
52:52 - if you look at my timer component
52:56 - you notice that i decorated my metadata
52:58 - with this timer service
53:00 - so i only i only inject it into this
53:03 - timer component
53:05 - but when i want to use it
53:08 - in my
53:10 - where is it timer display
53:13 - i don't have to provide it again because
53:15 - if i did that i'd end up with two
53:16 - instances angular would say oh you want
53:18 - one here and you want one here so it
53:20 - instantiate two different providers and
53:22 - they're two different states so by
53:24 - injecting it up top and then inject and
53:26 - then
53:27 - putting it into the constructor
53:29 - angular knows about it it knows what
53:30 - type it is it gives me access to it and
53:33 - then lets me subscribe to that single
53:35 - state so does that answer your question
53:37 - it's kind of multi-layered you can do
53:40 - global or you can target it
53:42 - that state where you want to target it
53:45 - and then observables work the way
53:46 - observables work so it's different than
53:49 - that
54:06 - right so i set an interval oh and so
54:09 - every 100 milliseconds it called that
54:10 - function call that function
54:12 - and then when i stop it i basically wipe
54:14 - the interval out and it stops
54:19 - we can look at that um
54:22 - so
54:27 - so my service is a little messy it needs
54:29 - some cleaning up but basically this
54:32 - starts getting into what is rxjs and how
54:34 - does it work
54:35 - but we have
54:36 - the subjects
54:38 - which is the single source of truth
54:40 - and then
54:42 - i give access to those subjects
54:44 - those
54:46 - subjects with this public get time
54:48 - method it returns something with a type
54:51 - observable and basically it returns that
54:53 - time stream dot observe as observable so
54:56 - whoever subscribes to that
54:58 - will hear about
55:00 - changes on the
55:02 - or the time stream behavior subject the
55:05 - difference between a behavior subject
55:06 - and a subject is that
55:08 - a subject
55:10 - initializes and that's it a behavior
55:12 - subject takes a value and initializes
55:14 - with that value
55:15 - so if someone subscribed to it when they
55:18 - subscribe to it they get that first
55:19 - value so basically i want to populate
55:21 - 0.00 as my first timer value
55:26 - the way i add changes to it is
55:30 - i
55:32 - where do i do that
55:34 - so when you start the timer
55:36 - uh if we're running the time calculation
55:40 - we tell some people that we're running
55:42 - so whoever subscribes to this running
55:44 - behavior
55:46 - subject will get the next event in that
55:50 - stream
55:51 - and then
55:52 - uh for the time calculation
55:55 - i set this interval same same principle
55:57 - as before and i run the calculate the
56:00 - next time and then i update this this
56:02 - this is the way that people hear about
56:04 - the message that i'm sending
56:06 - when i get the next time
56:09 - i add it to this timestream.next
56:11 - function
56:12 - and so no matter how many subscribers
56:14 - there are
56:15 - to this uh property they all get the
56:18 - same time
56:19 - from that observable
56:21 - does that help
56:27 - yeah that's so i it's not a perfect
56:29 - timer yeah yeah
56:33 - there yeah yeah there's delay but it's
56:36 - pretty reliable in terms of propagating
56:39 - out
56:40 - without
56:41 - yeah no it's very consistent
56:49 - right
56:50 - right
56:52 - all right so what are we looking at so a
56:54 - little more dom manipulation
56:56 - and if we get too late i can
56:59 - wrap it up but
57:00 - if you're good i can keep going
57:02 - okay
57:04 - um
57:05 - so
57:06 - we talked a little about the timer
57:07 - display let's talk about event binding
57:10 - so we have our buttons
57:12 - and it's just we kind of took out that
57:15 - little bit of functionality from the es6
57:18 - app
57:18 - and now we need to bind some
57:21 - functionality to our user interface and
57:22 - we don't want to use add event listener
57:25 - so angular gives you this
57:27 - convention of
57:29 - tying and
57:30 - tying into the native browser events
57:34 - so
57:35 - as you'll see here click is a native
57:37 - browser event and by putting parentheses
57:39 - around it this tells angular hey
57:42 - listen to the click event for this
57:43 - element
57:44 - and when it hears something
57:46 - run this function
57:48 - which is defined in my typescript class
57:50 - so it works for you know mouse over
57:53 - mouse move you know any any event that's
57:55 - a native one you can use
57:58 - and you can write your own custom events
58:00 - that kind of notify hey something
58:02 - happened
58:03 - so
58:04 - there's there's a lot of flexibility in
58:06 - using what's already there but kind of
58:08 - customizing it for your needs later
58:11 - if we look at the typescript class
58:14 - you'll see
58:15 - you know there's the metadata for the
58:17 - decorator we inject our service but we
58:19 - don't do anything in the constructor
58:21 - what we do is we
58:23 - we use those bound functions to
58:26 - tell the timer hey start the timer
58:30 - hey timer service stop the timer so
58:33 - we can very nicely kind of break out the
58:35 - pieces that need access to that timer
58:38 - service that global state
58:40 - and keep our
58:42 - our component class is
58:45 - focused on what its job is and the only
58:47 - job of the the timer bar is to start
58:50 - stop mark and reset
58:52 - and then
58:54 - that's event binding we'll talk about
59:01 - i think the last thing to really talk
59:03 - about is how would i get this to
59:05 - production but before we do that let's
59:08 - just show it running so you can kind of
59:10 - see
59:13 - that i do have a functional application
59:16 - so remember the package.json it gave me
59:18 - that
59:20 - and that list of commands
59:22 - they basically run
59:24 - the cli which tells it hey they want to
59:27 - serve this app so it goes and looks at
59:29 - everything i've configured it finds all
59:31 - my files it stuffs them all together
59:34 - and it starts a dev server for me
59:36 - and i can
59:44 - see
59:45 - running angular app that is a timer
59:47 - you'll notice it works pretty similar to
59:50 - the other ones we can mark times
59:53 - for our laps
59:54 - we can stop times you'll notice
59:57 - i can't add more than one number of the
59:59 - same time and basically i use the
60:01 - javascript set which does all the work
60:04 - of
60:04 - keeping values unique for my use case
60:07 - so i don't have to write extra the nice
60:09 - thing for me is that modern construct
60:11 - means i don't have to write extra error
60:12 - handling code i don't have to worry
60:13 - about that if i kind of pick the right
60:16 - tool for the job i'm trying to do
60:19 - and that's it so that's the developer's
60:21 - experience
60:23 - but the
60:25 - the uh
60:32 - well i think when it compiles down it's
60:34 - an array but it's got a lot of it does
60:36 - all the the de-duping and unique
60:39 - of the values so that my array only ends
60:41 - up with the right
60:42 - values
60:44 - so
60:45 - um
60:46 - you're familiar with the concept of a
60:48 - set
60:50 - you're just adding one more array right
60:52 - adding an item to the set and then it
60:54 - notifies hey there's a new item
60:56 - and the user interface
60:58 - populates i can go into um
61:01 - oh no
61:02 - what did i do
61:07 - okay sorry
61:10 - um
61:20 - all right
61:21 - all right
61:24 - all right so
61:25 - here's that that mark list component and
61:28 - it's the consumer of that set so i
61:30 - already know i'm getting unique values
61:33 - and basically
61:34 - i subscribe to that stream and i update
61:37 - my timer list whenever i hear a new
61:40 - thing on that stream
61:42 - the way i get it into the user interface
61:44 - is the template actually does change
61:45 - from the
61:49 - the
61:50 - es5 es6 one basically angular gives us
61:53 - this idea of
61:54 - iterators so any templating language
61:57 - you're familiar with has had something
61:58 - similar
62:00 - but
62:02 - there's this idea of a
62:04 - structural directive and what that means
62:06 - in angular world is that anything with
62:08 - an asterisk
62:10 - is a directive on an element and that
62:12 - tells angular it's going to actually
62:14 - modify it's going to create and destroy
62:17 - elements at some point in an angular
62:20 - application life cycle
62:22 - you can have directives that don't do
62:24 - that they just add behavior
62:27 - but because we're going to actually
62:29 - conditionally create a list depending on
62:31 - how many elements are in our time array
62:35 - i i know i need a structural directive
62:37 - and angular gives us this ng4 so for for
62:40 - every time in my timer list it will
62:42 - stamp out a list item for me
62:45 - and then
62:46 - um
62:47 - i'm good i don't have to do anything
62:49 - else
62:50 - the last thing i forgot to show too is
62:51 - this formatting remember how i was
62:53 - formatting all the time strings based on
62:55 - the function it was running well that's
62:57 - kind of
62:58 - not
62:59 - use reusable or sustainable if i want to
63:02 - change that format i've got to change it
63:03 - in a bunch of places
63:05 - angular gives this idea of pipes
63:08 - and so a pipe is something that i can
63:10 - put into my html
63:12 - and then it's a function that basically
63:14 - receives the
63:15 - the
63:16 - inf information so whatever's mapped to
63:18 - current time gets passed to this
63:20 - function
63:21 - i write my formatting here and i reuse
63:23 - it in my html wherever i need to and
63:25 - when i want to update my format i update
63:28 - here and in one place and everybody gets
63:30 - it
63:32 - so the last thing i have to show here is
63:36 - production
63:37 - so the webpack app the es5 app was easy
63:40 - to get into production the webpack app
63:42 - would need some or sorry the es6 app
63:44 - would need some webpack you'd have to
63:46 - configure it and get it ready to you
63:48 - know concat and minify and optimize
63:50 - assets
63:51 - angular
63:52 - cli gives me a tool
63:55 - build
63:56 - and if i give it this command prod
63:59 - while it's running
64:00 - what prod does is it it does all those
64:02 - optimizations but it also if you're
64:04 - familiar with how
64:06 - webpack is really revolutionizing
64:08 - something that we're calling tree
64:10 - shaking
64:11 - so angular
64:14 - at build time analyzes my app and looks
64:17 - at stuff to make sure it's used used
64:19 - if there's something in there that's not
64:21 - used it removes it from the bundle that
64:23 - gets shipped for production thus making
64:26 - my files smaller my app a little more
64:28 - performant my user a little happier
64:31 - developers are happy too because if
64:33 - you're using the cli they've configured
64:36 - webpack for all that and you just have
64:38 - to
64:38 - type the right flag and you're off and
64:40 - going
64:43 - so that's all i have for the demo
64:50 - let's see here
64:52 - um
64:55 - so that's that's it i i think we kind of
64:57 - went through these three
64:59 - stages we we looked at
65:01 - you know where ecmascript sort of pushed
65:04 - the evolution of javascript es3 es4 es5
65:08 - you know it was a wild wild west back
65:09 - then there was a lot of issues that
65:12 - tooling and jquery es6 came along and
65:17 - you know helped address
65:19 - and then finally the the idea of a
65:21 - framework or a library to
65:23 - work cohesively to use modern design
65:26 - patterns to bring that all together
65:28 - they
65:29 - you know have addressed a lot of those
65:31 - needs
65:32 - there's a variety of them out there i
65:34 - think they're all worth kind of knowing
65:36 - a little bit about because
65:38 - you never know what's going to be the
65:39 - next jquery
65:40 - angularjs angular or react which are all
65:44 - react as massively adopted
65:49 - i have one more thing
65:51 - um
65:52 - but i do yeah i do think it's worth kind
65:54 - of understanding those at a high level
65:56 - no matter what you're using in your day
65:57 - to day
65:58 - so if you're interested in the apps they
66:00 - are up on github
66:02 - in a repository feel free to
66:05 - take a look i hope this was useful i
66:08 - hope it took you maybe down to some fond
66:10 - memories or not so fond memories but
66:13 - this was sort of my journey through
66:15 - javascript as i understand it and
66:18 - that's all i have
66:26 - [Applause]
66:29 - [Music]
66:43 - you

Cleaned transcript:

tonight i'm going to talk about what i'm calling the modern web and i mean that from a user's experience as well as a developer's experience so i'll try to refer to that back and forth basically i want to talk about how this rich javascript ecosystem developed and kind of some of the big milestones along the way and then i'll show a couple samples of how that used to look and how it looks today a little bit about me i work at vmware i am a user interface engineer on the clarity design team and the clarity design system is a tool kit of ui guidelines and resources as well as a ui javascript html component library and then the really advanced components are actually written in angular so that you can add data and functionality and really make them work with an angular app internally they're heavily used throughout vmware's products so we kind of evolved the project with a focus on the enterprise and that kind of led us to take a different approach to our design system because we were starting on the desktop and degrading for mobile because most of our customers work on a desktop so that kind of influenced some of the design choices we made along the way so a little more about me i started writing javascript i don't know around 2004 or 2005 and this was back in the day when there wasn't any modern frameworks there wasn't any one way to do things and let's see as i moved through my career i started working with different people and when i started up a group out in westlake village that just wanted just likeminded people who wanted to meet up i often got questions about why is it so complicated um actually sorry i'm gonna back up i messed up so tonight we're gonna talk about the history and where javascript came from we're going to look at some of the dev tools that have evolved to help the developer experience and then i'm going to walk through what i call this timer app which is a simple application that has you know some specifications we could talk about and then show you how it could have been written 10 or 15 years ago in ecmascript 5 or earlier show you how you can turn it into a more modern syntax with es6 and then i'll try to walk through a high level of what that could look like as an angular application in today's ecosystem so back when i started really trying to meet likeminded folks and and hang out with them i'd have conversations with some of the people who showed up to the meetup out in westlake village and they'd say things like um you know why is the web so complicated or i'm here i'm an engineer but i'm a backend engineer and i hate javascript or you know has anyone ever heard someone say i just want to use jquery in in a way that says it's not a good thing to be using jquery for what they're trying to do um so that's kind of who this this is for people who are new to web development or people who are voluntold to work on the web client and they have a lot to chew off and a lot to understand why things are the way they are so this will hopefully walk us through how we got to here you know we had things that people may be familiar with there's backbone.js knockout angularjs angular react vue we have javascript es6 typescript babel webpack gulp grunt and many many more that i didn't put on the slide even more than that there's so much out there there's no way any one person can be an expert or even know kind of all the tools so we got here you know by a couple different um important evolutions in javascript and i think it's important to understand those so that as you are bombarded with new tools every day you can kind of say you know what kind of niche does this fill and where did it come from you know what drove the evolution of this tool i'm using and the way i see it you know javascript has had a 20 plus year evolution and it has really five four or five phases or errors we could call them in the beginning it was very simple html css javascript throw it on a web server you're good then things got a little more complicated users want a little more functionality in their app it'll got a little more difficult for a couple reasons we'll outline in a minute but jquery came along and kind of helped solve those problems it helped really address some developer pain points and made things a little better for the end users of those apps but jquery had some problems too the more it got used the more pain that developers had using it and you know the some really smart developers said we can do better than this so what i call frameworks part one came about and these projects really helped kind of organize code bases organize teams around concepts and design patterns and then make it you know a better developer experience make apps a little bit closer to native uh a native app which users are really coming to expect around this time in the evolution and then i put tooling in between frameworks and um the the two framework parts mainly because it needs a home but it evolves kind of along the same time as the the the frameworks one and two there's a lot going on during that time and so we'll look at some of those tools and kind of how they they look in practice and then we'll we'll end up the history lesson with frameworks part two i'll look at two of the big big heavyweights in the industry today and then we'll go to a a demonstration i have of looking at that timer app three different ways um so way back when where did where did it where did it begin in 1989 tim bernerslee created the world wide web he he started sharing documents with his friends around the world and making new friends kind of laying the foundation for what the web could become and he did it with html and css you know a little bit information a little bit of style um it wasn't real pretty by today's standards but it was you know leaps and bounds ahead of what anything else was at the time and that lasted for a couple years and folks started kind of expecting a little bit more out of the web pages or products needed to do a little more with their web pages collect information submit forms other things had to be you know people said what if we could do that and in a short twoweek burst i think around 1995 or so brendan ike coded up javascript and you know here we are today but it all really started in the evolution of javascript you know that twoweek period and it enabled a lot of things it created a lot of problems but those problems got solved and new new tools were built to address those problems so it was actually a really exciting time even though by today's standards you know a 1995 website probably looks pretty pretty arcane right now so some of the problems that they had were around the issues with standards and the need to do the same functionality for addressing multiple browsers and you know that was a big big pain point for developers because they spent all their time coding a feature five eight ten different ways depending on how many browsers were out there that they wanted to support and the browsers weren't crop cooperating because there's some nascent standards committees out there but the browsers didn't implement the standards the same way so you know it had a lot of problems for developers and they solved them they got through it but they needed another tool and around 2005 or so i think john john resig was his name he's the initial creator of jquery and there were a couple other tools out there at the time that are worth mentioning um my notes are gone um but the tools that i remember are yui framework the mootools i think prototype was another tool that tried to solve these problems in a way that developers didn't have to worry about browsers they could abstract the layer on top of the the code that would work and then the client delivered to the browser would figure out how to address each browser quirk as it as it is probably called um but jquery did five things really really well and it really enabled a massive adoption and the first thing that it did really really well is it exposed something called the jquery object and this was a thing that no matter what else jquery would do for you it let you extend it it let you build your own functionality so when you use jquery and it solves some of those other problems but you had a new problem you could write your own custom solution in jquery style and plug that into your app without having to worry about the browser quirks the other things that were going on the other thing it enabled with plugins is it was really the first time i saw a massive sharing of these tools people were saying well we solved this drop down menu issue and now if you want a drop down menu you can go to the there was a a sort of a pseudo repository of jquery plugins you could look for something see who was developing it and and use it in their your project and maybe even contribute back to it in the early days before github so that was one of the big things that i think helped jquery become the de facto tool that developers use when they really started looking for some structure and organization in their apps and then the second thing they did is they standardized dom access they made it very simple to find an element and do things to it and they did it in a way that abstracted above almost all of the browser quirks that were causing developers to not waste time but spend a lot of time making sure their app was performant and working in a wide variety of browsers i think that one was really important event handlers is a similar pattern to the dom access but basically they provided a standard way to find elements attach functionality to those elements and have it and not have to worry about it working in one browser and not another browser so those standard wars drove a lot of what the fundamentals of jquery saw problems that they solved the first thing it did is it baked in simple animations you know hide and show slide up slide down etc if you've ever seen an app that does that jquery provided an easy way to do that and it did two things it made it easier for developers to add some polish to their apps and it also kind of started to raise users expectations for what the web could become like it wasn't just a toy anymore when it looked and behaved a little more like a native app it was actually kind of cool to work on it it was kind of cooler to use it and a little more fun for everyone on both sides of that table and the last thing that jquery really saw the last problem that it solved was ajax and before you know you had a standard jquery library or api if you will you know you had to write ajax for multiple versions of browsers and identify quirks in one but not in the other and and tailor your application to deal with all that well just by using jquery you could abstract above that layer and move on to doing you know app development working on what your users wanted and i think this really drove a large part of the web forward way back in in period between like 2005 and 2010ish where we we got to what i call frameworks part one and this is where the use of jquery has proliferated and adopted you know adopted it been adopted at a massive scale but it started causing some of its own problems and if you notice a pattern here i think it's something that software development has always had and may never be able to get away from is you know you you build a tool that solves a problem you have and that tool is useful and it gets used a lot and the massive use of that tool causes more problems so you build another tool so these tools that came about kind of in this period were some of the early things that i consider is frameworks you could call them libraries collections of utilities the first one i heard about but never really got deep into using was something that called knockout js i believe it was used or came out of microsoft or a microsoft related project and it pioneered this idea of model view view model pattern a design pattern so anyone who's who's kind of educated themselves in computer science will know there's all kinds of design patterns that are useful but before before this time javascript really didn't have an easy way to apply those patterns some folks did it because you know they they figured out how to do it but it wasn't shared it wasn't adopted as a standard way of doing things so knockout kind of identified this pattern and then wrote some code that let you create an app with this pattern in mind and it helps you abstract your app up a level or two understand here's the pieces of my app this is the model this is the view and the view controller is what kind of glues them together fast forward a year or two and backbone said hey we like what you're doing maybe but we're going to do it a slightly different way i don't know if they said that but you know you know what i'm saying is a new tool that was developed in a similar pattern and it was the first one that i used in a real production context but basically the the library gave context and structure to help organize the code base and they did that by providing these three big building blocks models collections and views you know models obviously is where your data will live views is where your data will show up and be presented and then the collections wires them together and in between you know you get to write what happens and figure out how that behavior works so that one was was the first one i used and then the second one that i used starting i think around 2014 2014 or so was when i first came across angularjs just a quick note it is now angularjs and angular not there's two projects with the similar name but they're not the same we'll talk about that in a minute but angularjs did a similar similar thing in that they provided the model view view model controller pattern but they also said we're going to ship this framework with some opinions you know we're it came out of google by the way and they're very some very smart engineers there they had strong opinions on how things should be done how an app should be constructed so baked into their library is a very opinionated way of writing a router for a web a web app you know writing an http api that is used throughout the web app writing services that glue various controllers in your app together so they they put all that out there and angular took off in a very similar way to i think how jquery took off and that was good apps were getting more functional they were getting more nativelike but developers were still having problems while these apps were being developed and so we had a wide variety of tooling kind of spring up alongside these frameworks and kind of evolve with these frameworks at the same time and there's really four i want to highlight here because they all sort of signify significant advances that make the developer experience in the modern web a lot better than it used to be the first one was um circa 2011 ryan dahl was i his name i believe he he coded up this idea of hey i want to run javascript on my on a server and so he he released it to the world and it was this crossplatform javascript runtime that you could write javascript and run it from your command line on your computer and that was crazy because before that you had needed a web browser to do anything and this sort of gave a lot of fuel to javascript and after that people started scratching all different kinds of itches to make their lives as developers easier with javascript and they needed somewhere to kind of share and store those those utilities they were writing so right after or pretty close after node coming out npm launched and eventually was baked into node but it didn't start they started out as separate projects but basically it became this command line utility that you could use to search find install manage this exponentially growing group of tools and utilities all written in javascript and i'll show a sample package json in a second but fast forward a couple years and people were you know really solidifying how standards work in javascript and they were moving forward but browsers were still kind of causing a little problem they weren't adopting them they weren't shipping browsers that could consume modern javascript constructs so a really smart fella evan lee maybe what's his name i can't remember his name but the the creator of babel basically took that idea and said i want to write modern javascript languages i want to use it in a way that makes sense to me that makes my code easier to understand easier to architect and i want it to run in some of these older browsers that don't understand it and so he wrote this tool that takes that es6 es7 esnex now whatever version you want to write his tool will turn that into something that you know ie11 can run and it's a very powerful tool and what it does is it does this thing called transpiling which i think i i generally use the word compiling although it's not completely accurate but it transpiles your source code into something that the browser understands and you know away you go you get as a developer you get a better experience using the modern language but your your code still works in the the environment that the products live in and then finally all these things kind of highlighted the need for this idea of well how do we okay we can compile it and create it but how do we actually optimize it and split it up and get it ready for this modern web as as we realize you know not all the bits of our javascript are needed right away so how do we figure out how to do that and webpack came along after a couple other sort of orchestration tools were used for a few years and they basically help you package up and optimize your application for delivery to the web so real quick this is a just a sample npm package manifest and i want to highlight three things here that i i think are they're important to me for understanding what npm is and what it does for you it lets you organize your dependencies which is turns into a little javascript object and it basically tells you what the name of your dependency is and tells you what version you have it have in your project and dependencies are things that are going to get packaged up and used inside your app when it's delivered to the client's browser it also lets you manage these things called dev dependencies because as these frameworks were evolving and getting more complicated you know files were getting bigger where webpack and grunt and gulp were doing things like let's concatenate all of our javascript into one massive file but now we need to make that file smaller so there's a bunch of tools that people wrote to help them automate that and do that and the dev dependencies you install will will help along those lines they'll provide some little effort that helps automate your app building experience and typescript is one of those that i use in the angular projects i work on and then scripps was one of the coolest things i think it was one of the first things i gravitated to in npm and basically with this complications that were added to the build process for an app you needed a way to not have to remember babel build command with arguments one and two and at this file in that file so the scripts kind of gives you an area where you can customize the developer experience for your app it it gives you the ability to write a shell script if you want write a node script if you want and then execute it with a simple npm run my command and do a lot of complicated things without having to remember what's going on except for the first time when you write write that script so that was a i think the npm besides jquery the npm evolution and adoption was a big milestone in in the javascript evolution and finally we come to frameworks part two and there are a couple out there i'm not going to talk too much about vue or elm there's a couple others but they're projects that do you guys use album no i do okay cool there's a big fan of it on my team but um they're projects that kind of built on what the first generation of frameworks kind of learned the mistakes they made they figured out how not to make them and the good things they kind of carried them over so react was the the first one i would consider was like the more evolved of the frameworks and it was kind of came out of facebook in 2013. it's its claim to fame was really they wanted to well they had a massive scale for their applications so i don't know there were 700 800 million people back in 2013 maybe a billion and so they had a really large data set that needed to get into their apps and use the data and they had a couple key principles that i think helped them manage the large changes that were coming down with these massive data consumptions by client apps and so they oops they they pioneered this concept of oneway data binding if you're familiar with an immutable state they figured out hey it's better if if our app knows there's one source of truth and when that source of truth changes everybody gets the update at the same time and the way they did that is by working with something called the virtual dom because we all know that it's extremely expensive to query the dom dig into the dom make changes to the dom what they said is instead of doing that let's just take a picture of the dom let's see what it looks like and then when we know there's changes let's take another picture that's a very lightweight process and then we'll see what's different and then we can narrow in on those small set of changes zoom in to that part of the the application and update it when it needs it and it helped really kind of increase the performance of apps and helped um i think consumers kind of become really comfortable with some slick apps that started to approach a native feel and then angular 2016 so i mentioned before there's angularjs and there's angular so the first version of angular angularjs today kind of was there was a line drawn in the sand and i think they had some some lessons that they learned and they wanted to move forward but they couldn't move forward with the legacy code base so it ultimately ended up being an a complete rewrite and so you know for developers like me we i i resisted jumping into angular for a while and then now i'm not even sure why i hesitated or waited because a lot of the decisions they made were really good for my developer experience but the couple of things they did that i think are worth highlighting is they wrote it in typescript typescript is a typed language that is a superset of javascript and it compiles down to javascript even more interesting is that you can one you can use it in in any framework if you want but you can target specific versions of ecmascript so you can say i need my code to run an es3 because we've got this ancient thing running on a kiosk in this little mall well typescript will help you do that and give you the tools to write code in a modern way that can run on browsers that may have been around 1520 years ago the other thing they did was they can't they instead of using the immutable pattern they have this idea of dependency injection which is a i think a carryover the first time i saw it was in java world where you annotate your classes with other bits of information so that when you build your app it knows hey this class needs to know about this service and a service in angular world is really just something that's a singleton that can act as a single source of truth for an application and finally the one thing that i think angular is kind of doing better than even react but react has something similar that's making pretty quick strides is they have this idea of the angular cli so the angular cli is a tool that lets you create a new app with one command line process and it will let you add a component and what it's doing under the hood is it's writing all this boilerplate out to the file so that you don't have to create a new class you don't have to tell your app module about that class because things have gotten a lot more complicated this is a tool that helps kind of alleviate some of that complications so that's that's what i have for the history lesson i'm going to jump over to my computer and kind of walk through that timer app and we'll see how it goes good um miss it sorry thank you all right all right so is that big enough can everyone see if it's too small let me just shout out and i'll bump it up so we have here what i'm calling a native timer app and we're going to look at it in es5 ish syntax this is something that i would have written 2000 2005 maybe maybe earlier if you look at the structure of the project you have an index you have a source we're going to ignore this i wasn't sure if i'd have internet access so i didn't want to uninstall my node modules you have this idea of assets where i just put an image and a css file but you might have had another folder for images another file for folder for styles if you had a more complicated web page you might have multiple ones of those but i think you get the idea that it was it was pretty simple it was an easy structure to understand and in order to run this app all you had to do was deliver it to a web server and clients just needed to go to the web url and they're good to go so my timer has some requirements um let me talk about those real quick so basically we need to start the timer we need to stop the timer we need to mark times and list them out somewhere we need to tell the user when the the timer is running and we need to tell the user when they've added a time to their list and the way i i did this in es5 is you know we have a simple html document and we add in our style we add in our script which we'll get to in a minute and in between there we we have an element we call app and that app has three parts i if anyone knows how to get rid of those things in vs code let me know because the things that pop up i don't probably have to disable an extension okay i'll have to look because it's been bugging me for a couple days but there's three sections there's the timer display where we show the the current time then there's the the buttons that let the user start stop mark do do whatever they need to do and then we have a list for each each time that we want to record and make note of so the way i i kind of went back to the early days at least as far as i could remember them is i i wrote it all in one script you know i had to know if it was running so i gave it a global state i had to know where my app was so i used the the native web apis to get the element and get a reference to it then i created a function that i could pass an element to and if you look closely at the code you'll obviously see there's some some room for optimizing it and refactoring it a bit but when you call this function it passes an element that is used in a couple different places to add in the time that is the current one for our calculations and then we have a couple functions that we can use to attach to elements for starting the timer resetting the timer marking the timer resetting the the timer and so that's kind of all encapsulated in a function and this is probably even more advanced than 95 to 2000 javascript was written but it was worth encapsulating for the purposes of this but then in order to get that functionality onto my elements i had to bind those functions to them somehow and the the way we have today is the web api for add event listener so i can isolate the click events and then add a function that does some stuff it checks the global state which we all know is a bad thing but you know we use the tools we have it adds it adds a class list to this app variable that if you remember is defined up top where we we know kind of what that reference is to and finally it it does a it sets an interval that calls this start timer function every 100 milliseconds and if you remember that timer function all it's doing is you know looking at what the current time is figuring out how much time has passed and kind of formatting that that a little that number a little bit so that we can have a decimal in our user interface and and that was that was kind of the extent of the early javascript projects that i could come across it was a lot of we want this functionality and we need to do it this way and so you you kind of threw it all into one file you tried to avoid global state if you could but you usually had something that couldn't be isolated and so it ended up in there and and it caused you know enough problems that javascript evolved past that and jquery came along and i don't have an example with jquery i'm going to move right to turning this code into es syntax so it's going to look very similar but it's uh worth highlighting that that's what drove you know the react and the angular's frameworks for today so if we check out the es6 app the builtin one for builtin one for vs code um oh i use the z shell and i forget with some theme whatever something i customized once years ago and forgot about so now you'll notice i have a similar structure to the es5 app but the index is gone i now have a package json that lets me take advantage of what npm brings in to the developer experience i have this git ignore just tells me tells my app when not to care about for version control and there's this babel rc which is an object that babel uses and this is where i tell babel here's what i want to do with this code and i'm telling them use this es 2015 presets and when you compile the code i'm writing for distribution include source maps in there so if i run babel without doing anything else it will look for this file and it'll use those preconfigured presets to generate output code you'll notice there's uh there's no assets uh oh oh interesting i hope i didn't mess it up um oh i forgot to show the es5 app running but don't remind me to show this one running i'll show it in a minute and now i'm not sure why that's there all right so in our source we have what you could consider the the structure of our application everything outside of it is some sort of dependency that we need to build the app and deliver it so we still have our index it still looks like the same html structure but we put our assets inside there we have some images and a style sheet and then we have an application that with uh with a saturday afternoon of time to do all these demos i turned into something that's es6 so basically the biggest difference here is that i removed the global state from the application and i wrapped it into a single class and i put as much functionality in that class as possible and using es6 i can do a lot of things in the constructor when someone initializes a new a new instance of this timer app we can do a bunch of things ahead of time and say oh you find this find this element and give me a reference to it find this other element give me a reference to it and that instance of the timer can now work isolated by itself in the browser and not worry about stepping on other bits of javascript's toes we still add an event listener and bind them to click handlers one thing to note is i had to pass in this which if anyone who's done a lot of javascript development they'll know scoping is a mysterious and dark art but basically passing that in lets my function run and understand what its state is you didn't want to use low dash i try to keep it as minimal as possible for for this demonstration just as pure vanilla javascript as possible and then notice that these these click handlers are inside encapsulated inside my class and they do basically the same thing they add a class if it's running they have a check and they set an interval to calculate the new time they have a a way to stop the timer remove the interval so that the timer stops and invite in etc we can reset the app we can mark the time and so then i now have a nice encapsulated bit of code that i can initialize in my global state with a new simple variable and a function call that says hey i want a new timer so to see what this looks like running i apologize for not showing the es5 it looks the same though except for the background image so if we open up that index.html if we open it up we get a nice little app we have some buttons we can start our timer and i broke it oh no let's go back to the es51 i'll show you running there i'm sorry about that i do not like live coding if it if it's at all possible but let's see kit check out actually yeah all right so we have a timer i can start it i can tell the user is running i can mark some laps when i mark a lap i let them know hey it's running i can stop the timer one thing to note is i could still add times and that's probably a bug you wouldn't want multiple things of the exact same value in your collection so i could write a bunch of code to kind of look at that array and and figure out do i put it in or not put it in or just put everything in there and figure out we'll only show the unique things but you know modern javascript gives us things like sets which we know you know is a data structure that lets you just put in one unique thing and if you try to put another thing in it doesn't even error for you it just says thanks no and goes on about its way so i'll show i use that in the angular app basically to fix this bug so that's the app it resets and that kind of takes us up to these modern frameworks where there's a bunch of tooling and so what i'm about to show in the angular app is going to be a little more complicated i'll try to hit these high level you know what's the global state look like what's the dom manipulation for angular look like and then what's the event binding and how would you get this app to production so if we go back to code all right i have this thing called an angular timer and so if you haven't worked with angular before has anyone worked with angular here before all right so not a whole lot so i'll try to kind of help you understand how the project is organized again we have a json file and you'll notice that it it has a couple scripts i generated this app with angular cli so i didn't actually write any of this it gives me something that i can use to start my application which has a builtin local development server so that gives me the ability to do things like write code save and it automatically reloads my browser so that by the time i flip over from my editor to the web browser i already see my code running or not running in the web browser linting is basically a way of keeping your code clean to certain preset configurations of like oh you should always have a semicolon or you should always indent two spaces etc so they bake that into the app generation for the angular cli tool and then ede is is endtoend testing um they have a another framework that is useful for testing angular applications there's a bunch of other projects out there that you can kind of dig into if your use case are different that are have their own sort of use cases and fans for following but you see here in our dependencies we have a bunch of angular stuff we have this core js we have this rxjs and we have the zone.js all the angular stuff is what makes angular work for me and the other stuff are things that angular depends on if you're not familiar with rxjs i'd say that's one of the coolest things i've really had to dive into in the last couple years uh it's worth it's worth learning if you ever went from jquery call back hell to oh my god promises are awesome you'll you'll be a fan of observables when you when you get into them that's worth noting there and then all these dev dependencies this is how we build and ship this app in an optimized way for production so everything that the angular cli needs to build my app is installed in my node modules and then when i run the the right command it packages it all up it optimizes it and it gets it ready for me to do something with so that's the package the code itself angular needs to know a couple things about my app and i can change them and configure them as i need to but basically it has a configuration object the main things to see here is this prefix and schematics prefix is something that we'll use so every component i build in an angular app will basically be very similar to a web component so it'll have its own um html like signature where i can bracket app dash timer close close bracket and then close close that like you would close any other div or section or whatever but this tells app when you create new components prepend this app so if i want to customize that for my uses i just change it there everything that gets generated gets that prefix and then schematics is something that i haven't seen anybody else doing this but it's this idea that i think angular wants to make it really easy to update and maintain client applications so the clarity project that i work on is a ui library it's a module it's not an app and our customers kind of depend on us to keep breaking changes to a minimum or not include them at all unless we're bumping a major version and the schematics is a tool that lets you work within the angular ecosystem and say ng add at clr angular and it'll install this tool the the clarity angular components it will also we also have the ability to say hey we know this is an angular application instead of you having to go and put our clarity module into the application we'll do that for you we know where it goes we'll import it we'll add that and when you use our components it's all ready for you to go you don't have to do that boilerplate configuration yourself the other really powerful thing that the schematics does for me as a library maintainer is that when i do have braking changes or deprecations and you install my project with the angular cli i can scan your code base and say hey this thing you're using is deprecated in this version and i can write a custom note for here look here and see how long it's going to be in you know in the clarity library let's see when we're going to remove it even more powerful if it's not too complicated of a change and we deprecate something and you don't update it when you install it with the schematics i can provide a template for hey you're using this old thing turn it into the new thing so that deprecations or removals magically get handled or notified hey you're installing a version that this thing no longer exists and and your app's going to horribly break and we want to let you know about it as soon as possible so that's a very powerful thing that schematics brings to the angular ecosystem so real quick what that looks like um is as i said angular is a tree of components and so you start with a root component and the way you you get that started is kind of glossing over the bootstrapping process as we still have an html file but it gets really simple you notice there's no styles there's no scripts so when we build the app angular cli and all the and webpack is actually the build tool underneath there um it's configured good enough for 90 of the use cases if you really need to you can eject out of the default configuration and customize it but i i don't see the need for my uses but what i want to say is our app gets started with this custom like element called app root and we have a component and you'll notice we have a selector called app root so when angular comes across this element it knows what it is it knows what template to apply to it and it knows what style to go with it and there's a couple different ways to do it but the default version of angular encapsulate all encapsulates all of that css in a way that makes style conflicts impossible so the names that i use for this component in this style sheet couldn't ever conflict with something else some somewhere in the the webpage of the application you'll notice there's not a whole lot going on here we just have this app root and this template so if we look into that template it'll kind of feel like we're starting to walk into a tree where we have another another custom like element called app timer and that's really the meat of what it took to turn that es6 code into an angular app and i basically had to have four components i had the timer component and we'll look at the code in a minute we have the the button bar we have the display and we have the mark list so if you remember those basic div elements we had they basically become first class citizens of my app they can have their own encapsulated style their own encapsulated functionality and the tools that angular provides gives me the ability to manage global state with basically in an angular app you don't really need global state you can encapsulate all that state inside the typescript files and kind of work confidently inside there um so for something like dom manipulation if we look at the timer display which is the big number of what the current time is you'll see we'll start with a template this time and this could have been in line into the typescript code but i apologize i was a little too lazy to to do that um but for smaller templates generally five to ten lines or less i'll inline them into the typescript file itself anything that gets bigger it's worth kind of separating it out it gets too complicated and there's two things going on here we'll come back to time format but basically in my in my timer display component class there's a variable called current time and whatever that current time is it will get interpolated in this template with that value the other thing angular will do for me is it will pass that value to this time format function which i'll show you real quick and kind of explain at a high level what it is and and what it does for me so then we have the component itself and you'll see it follows a similar pattern we have you know we import the stuff we need from angular we import our timer service which we'll talk about in a minute and then we we decorate our component with these this metadata for what selector is used what template is used with this class and what style goes along with it and angular does the work of packaging that all up encapsulating it and delivers it to your browser and our class looks pretty simple remember we have that current time property and we have two things going on here we'll come back to the timer service remember how i said you know dom manipulation and data binding and things that jquery kind of brought to the table well angular has this idea of decorators and so that component is a decorator at host binding as a decorator because angular views this class as the host anything that lives inside there in terms of an html template is is a child of the host it's a view it's part of the view for that host and so when i use the at host binding decorator angular knows hey when this cloud this thing is true add the class timer display to this host so in my browser i'll have this app timer display element and it'll have class equals timer display and now i can target css for that host and and write things that i wanted to do the other thing that's going on here is remember how i we we talked about not having global state but we still need to to maintain state for our app and pass it around so angular uses that rxjs project and it basically gives me the ability to create a stream of time events and if you're familiar with rxjs it's basically what i'm doing is subscribing to an observable that basically passes every new time to whoever subscribes to it so in this case i subscribe to new times and whenever they're generated i hear about them and whenever i hear about them i run this lambda function in line that sets the new time value to this dot current time and we show up in our browser is this similar to the idea of having connected components to like a redux state for example it's similar it's not redux though it's not oneway flow same same idea of having components to be listening to a global state uh it's it's it's components listening to a state but i could give a whole 20 30 minutes in how the angular providers are organized at a high level these providers are a tree so angular gives you this thing called an injector and you can put providers in there so if you put it high enough up the tree your provider is available to the entire app but if i i say hey i want to define my provider at a lower level at this component level then you'll notice where is that uh if we go back to highlight that if you look at my timer component you notice that i decorated my metadata with this timer service so i only i only inject it into this timer component but when i want to use it in my where is it timer display i don't have to provide it again because if i did that i'd end up with two instances angular would say oh you want one here and you want one here so it instantiate two different providers and they're two different states so by injecting it up top and then inject and then putting it into the constructor angular knows about it it knows what type it is it gives me access to it and then lets me subscribe to that single state so does that answer your question it's kind of multilayered you can do global or you can target it that state where you want to target it and then observables work the way observables work so it's different than that right so i set an interval oh and so every 100 milliseconds it called that function call that function and then when i stop it i basically wipe the interval out and it stops we can look at that um so so my service is a little messy it needs some cleaning up but basically this starts getting into what is rxjs and how does it work but we have the subjects which is the single source of truth and then i give access to those subjects those subjects with this public get time method it returns something with a type observable and basically it returns that time stream dot observe as observable so whoever subscribes to that will hear about changes on the or the time stream behavior subject the difference between a behavior subject and a subject is that a subject initializes and that's it a behavior subject takes a value and initializes with that value so if someone subscribed to it when they subscribe to it they get that first value so basically i want to populate 0.00 as my first timer value the way i add changes to it is i where do i do that so when you start the timer uh if we're running the time calculation we tell some people that we're running so whoever subscribes to this running behavior subject will get the next event in that stream and then uh for the time calculation i set this interval same same principle as before and i run the calculate the next time and then i update this this this is the way that people hear about the message that i'm sending when i get the next time i add it to this timestream.next function and so no matter how many subscribers there are to this uh property they all get the same time from that observable does that help yeah that's so i it's not a perfect timer yeah yeah there yeah yeah there's delay but it's pretty reliable in terms of propagating out without yeah no it's very consistent right right all right so what are we looking at so a little more dom manipulation and if we get too late i can wrap it up but if you're good i can keep going okay um so we talked a little about the timer display let's talk about event binding so we have our buttons and it's just we kind of took out that little bit of functionality from the es6 app and now we need to bind some functionality to our user interface and we don't want to use add event listener so angular gives you this convention of tying and tying into the native browser events so as you'll see here click is a native browser event and by putting parentheses around it this tells angular hey listen to the click event for this element and when it hears something run this function which is defined in my typescript class so it works for you know mouse over mouse move you know any any event that's a native one you can use and you can write your own custom events that kind of notify hey something happened so there's there's a lot of flexibility in using what's already there but kind of customizing it for your needs later if we look at the typescript class you'll see you know there's the metadata for the decorator we inject our service but we don't do anything in the constructor what we do is we we use those bound functions to tell the timer hey start the timer hey timer service stop the timer so we can very nicely kind of break out the pieces that need access to that timer service that global state and keep our our component class is focused on what its job is and the only job of the the timer bar is to start stop mark and reset and then that's event binding we'll talk about i think the last thing to really talk about is how would i get this to production but before we do that let's just show it running so you can kind of see that i do have a functional application so remember the package.json it gave me that and that list of commands they basically run the cli which tells it hey they want to serve this app so it goes and looks at everything i've configured it finds all my files it stuffs them all together and it starts a dev server for me and i can see running angular app that is a timer you'll notice it works pretty similar to the other ones we can mark times for our laps we can stop times you'll notice i can't add more than one number of the same time and basically i use the javascript set which does all the work of keeping values unique for my use case so i don't have to write extra the nice thing for me is that modern construct means i don't have to write extra error handling code i don't have to worry about that if i kind of pick the right tool for the job i'm trying to do and that's it so that's the developer's experience but the the uh well i think when it compiles down it's an array but it's got a lot of it does all the the deduping and unique of the values so that my array only ends up with the right values so um you're familiar with the concept of a set you're just adding one more array right adding an item to the set and then it notifies hey there's a new item and the user interface populates i can go into um oh no what did i do okay sorry um all right all right all right so here's that that mark list component and it's the consumer of that set so i already know i'm getting unique values and basically i subscribe to that stream and i update my timer list whenever i hear a new thing on that stream the way i get it into the user interface is the template actually does change from the the es5 es6 one basically angular gives us this idea of iterators so any templating language you're familiar with has had something similar but there's this idea of a structural directive and what that means in angular world is that anything with an asterisk is a directive on an element and that tells angular it's going to actually modify it's going to create and destroy elements at some point in an angular application life cycle you can have directives that don't do that they just add behavior but because we're going to actually conditionally create a list depending on how many elements are in our time array i i know i need a structural directive and angular gives us this ng4 so for for every time in my timer list it will stamp out a list item for me and then um i'm good i don't have to do anything else the last thing i forgot to show too is this formatting remember how i was formatting all the time strings based on the function it was running well that's kind of not use reusable or sustainable if i want to change that format i've got to change it in a bunch of places angular gives this idea of pipes and so a pipe is something that i can put into my html and then it's a function that basically receives the the inf information so whatever's mapped to current time gets passed to this function i write my formatting here and i reuse it in my html wherever i need to and when i want to update my format i update here and in one place and everybody gets it so the last thing i have to show here is production so the webpack app the es5 app was easy to get into production the webpack app would need some or sorry the es6 app would need some webpack you'd have to configure it and get it ready to you know concat and minify and optimize assets angular cli gives me a tool build and if i give it this command prod while it's running what prod does is it it does all those optimizations but it also if you're familiar with how webpack is really revolutionizing something that we're calling tree shaking so angular at build time analyzes my app and looks at stuff to make sure it's used used if there's something in there that's not used it removes it from the bundle that gets shipped for production thus making my files smaller my app a little more performant my user a little happier developers are happy too because if you're using the cli they've configured webpack for all that and you just have to type the right flag and you're off and going so that's all i have for the demo let's see here um so that's that's it i i think we kind of went through these three stages we we looked at you know where ecmascript sort of pushed the evolution of javascript es3 es4 es5 you know it was a wild wild west back then there was a lot of issues that tooling and jquery es6 came along and you know helped address and then finally the the idea of a framework or a library to work cohesively to use modern design patterns to bring that all together they you know have addressed a lot of those needs there's a variety of them out there i think they're all worth kind of knowing a little bit about because you never know what's going to be the next jquery angularjs angular or react which are all react as massively adopted i have one more thing um but i do yeah i do think it's worth kind of understanding those at a high level no matter what you're using in your day to day so if you're interested in the apps they are up on github in a repository feel free to take a look i hope this was useful i hope it took you maybe down to some fond memories or not so fond memories but this was sort of my journey through javascript as i understand it and that's all i have you
