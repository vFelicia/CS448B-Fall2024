With timestamps:

00:01 - welcome to this tutorial we're going to
00:03 - build a tetris game with react and the
00:07 - first question you should ask yourself
00:09 - is is react a good choice for making a
00:11 - game like this and to be honest i don't
00:14 - know it is probably better to build it
00:16 - with vanilla javascript but i wanted to
00:19 - do this for myself to test how this game
00:21 - can work out with react and sometimes i
00:24 - do this kind of projects just to yeah
00:27 - kind of expand my knowledge and try
00:29 - things out and the idea for this started
00:31 - when i was looking at the tutorial at
00:34 - youtube where this guy creates a tetris
00:37 - game with vanilla javascript and it's in
00:40 - this channel that's called methmeth
00:42 - method and yeah you can think whatever
00:44 - you want of that name the tutorial is
00:48 - really good actually and
00:50 - i learned a lot because i have to say
00:52 - this i'm not a game maker i create web
00:55 - applications and stuff like that and web
00:57 - pages so i'm kind of a rookie in the
01:00 - game development so it was fun to create
01:02 - this game with react and see how it
01:05 - works
01:06 - and in this video he used canvas i'm not
01:09 - going to use canvas i'm using regular
01:10 - divs and a grid for this one because i
01:13 - wanted to try it out also and not use
01:15 - canvas and it's also good to see how
01:18 - good react performs because there's
01:20 - going to be a lot of divs that we
01:21 - rendered to the screen because each cell
01:24 - in the tetris game is a div
01:26 - and i'm also going to borrow some of the
01:28 - code here and especially the one where
01:31 - we're going to check for collision when
01:33 - we rotate our tetra minor that is the
01:36 - name of the blocks in tetris
01:38 - big credits to this channel mathmath
01:41 - method and the video where this guy
01:43 - shows how to create a tetris game in
01:45 - just i think it's 50 minutes or so yeah
01:48 - and it's a really good tutorial if you
01:50 - want to learn how to build a tetris in
01:52 - plain javascript all right let's get to
01:54 - the app then and here's the tetris game
01:57 - that we're going to build i choose to
01:58 - have kind of a retro style to it with
02:00 - this stars in the background this is
02:03 - just an image i found on unsplash
02:05 - and we're going to show the score at the
02:08 - rows and the level and then we have a
02:10 - start button so if we press start game
02:13 - we can play the game and we're using the
02:15 - arrow keys on the keyboard for this one
02:18 - you rotate the tetra minor with the up
02:20 - arrow and you
02:21 - kind of go left and right with other
02:23 - arrows and down will make it go faster
02:26 - down there and
02:28 - there will be some limitation in this
02:29 - game and because this is not a perfect
02:32 - tetris game for example the key input
02:35 - we're just using the regular repeat here
02:37 - when holding down
02:39 - the down arrow key
02:41 - there should probably be
02:43 - a better function for this where we can
02:45 - control the speed of this one
02:49 - and also i will be using an interval for
02:51 - this one we could also use uh request
02:54 - animation frame where we can create kind
02:57 - of a more controlled animation
03:02 - so it will not be a perfect tetris game
03:04 - but it will be a good practice in react
03:07 - and especially react hooks that so many
03:10 - people are talking about now on the
03:13 - internet so we will be creating custom
03:15 - hooks and we will use state we will use
03:18 - use effect
03:19 - and use callback and also we're going to
03:22 - use react memo
03:24 - for minimizing or rerun this of the
03:27 - cells so i think this will be a good
03:29 - practice in react and especially react
03:32 - hooks
03:34 - so let's get to it we will start
03:36 - creating the game in the next video
03:40 - we're going to start to build our tetris
03:42 - game now and we're going to use create
03:44 - react app and i actually use that one a
03:47 - lot because it's great for bootstrapping
03:48 - your project and you don't have to set
03:50 - up your webpack and babel config and
03:52 - everything like that from scratch so i
03:55 - highly recommend you use create react
03:57 - app it's great and we create a project
03:59 - by go into our console in my case i'm
04:02 - using hyper and we just type npx create
04:06 - dash react dash app and we can call our
04:10 - application react dash
04:13 - tetris this will create the folder
04:15 - that's called react-tetris
04:18 - and then press enter
04:20 - and then we just wait it will take a
04:22 - second here
04:25 - all right we're good to go here and it's
04:27 - important now that you navigate into the
04:29 - new project folder you created so type
04:32 - cd
04:33 - react
04:34 - tetris
04:36 - and if we list the files you can see it
04:38 - has created some folders and files for
04:40 - us here and now i'm using style
04:43 - components for this game so we have to
04:45 - install that one also and we do that by
04:47 - typing npmi style dash components
04:53 - all right some arrows here but i think
04:56 - we'll be fine it's just on my computer i
04:58 - can clear the console i have also
05:00 - included some files in the starter files
05:03 - that you have to copy to your project
05:05 - folder otherwise it won't work so make
05:08 - sure first of all that you download the
05:10 - starter files it's on github and the
05:12 - link should be provided to you
05:14 - and then in the starter files you have
05:17 - something that's called
05:19 - bd.png that's the background image that
05:22 - the stars you see here then we have the
05:24 - font that's called pixel if i found this
05:26 - one on the internet it should be free to
05:28 - use
05:29 - so i hope it is
05:31 - and we have something that's called use
05:33 - indival dot js and that's a custom hook
05:36 - that's created by dan abramov that i'm
05:38 - going to use when we create the game
05:40 - loop with the javascript interval so
05:43 - we just have to copy this one over and
05:45 - i'll explain it later in the tutorial
05:48 - first grab the bd.png file copy that one
05:52 - and go into your project folder
05:54 - and inside the src the source folder we
05:57 - create a new folder
05:59 - that's called imd
06:02 - and that's for image of course and you
06:04 - can just paste the background in there
06:08 - all right then we have the font so grab
06:11 - that one copy that one and create
06:13 - another folder inside of your src your
06:16 - source folder
06:18 - and we can call this folder font
06:21 - go inside over there and paste the font
06:24 - inside of it
06:26 - and then we have the use interval.js
06:28 - file so copy that one
06:30 - and still in the src folder create
06:33 - another folder that's called hooks
06:36 - this is the folder where we're going to
06:37 - create our custom hooks
06:40 - so go inside of that folder and paste
06:42 - the use interval.js file
06:46 - and this should be it this is everything
06:48 - we need to get us started so in the next
06:50 - video we'll start to scaffold out some
06:52 - components and we'll continue with our
06:54 - application
06:57 - the first thing i do when i create the
06:59 - react application is that i scaffold out
07:01 - all the components that i need and
07:03 - that's what we're going to be doing in
07:05 - this video so first of all you can see
07:07 - that we have a lot of files here that
07:09 - was created for us with create react app
07:12 - and we're not going to use some of this
07:14 - stuff here you can yeah you can delete
07:16 - it if you want the logo the service
07:18 - worker the app test and stuff like that
07:21 - or you can just let it be because we're
07:23 - not using it now we are going to use the
07:25 - app.js file here and the index.js file
07:28 - for now and the index.js file we don't
07:31 - actually have to touch that one we can
07:33 - just go inside the app.js file we can
07:37 - delete everything inside of there
07:40 - so as usual our application is going to
07:43 - start in the app.js file this is kind of
07:46 - the highest component in the hierarchy
07:48 - so we import react from react
07:53 - we import tetris from
07:55 - dot forward slash components forward
07:58 - slash tetris
08:01 - like so and of course this one we
08:02 - haven't created this one yet so we're
08:05 - going to create that in a minute
08:07 - and we create our app function
08:09 - i like to use arrow functions for this
08:11 - one you can use a regular function if
08:13 - you want to do that but we have const
08:15 - app equals parenthesis and we're going
08:18 - to create an explicit return for this
08:20 - one so we just need parentheses
08:23 - then we can create a div
08:25 - with a class name of
08:28 - app
08:29 - and we have our tetris components
08:33 - like so
08:34 - and then we export default app
08:39 - and that's our app component
08:41 - then we can create a new folder inside
08:43 - of src folder
08:45 - that's called components
08:49 - inside the components folder we are
08:51 - going to create five different
08:53 - components
08:54 - so we can just create the file names now
08:57 - so we create one that's called cell.js
09:00 - make sure you have a capital letter here
09:02 - to start with or
09:04 - yeah maybe you don't name your
09:06 - components like that but i like to name
09:08 - them with capital letter because it's a
09:10 - component
09:12 - so we create another file that's called
09:14 - display.js
09:17 - and we have a new file that called
09:19 - stage.js
09:22 - and we have a new file that's called
09:24 - start button.js
09:27 - and the last one is going to be the
09:30 - tetris dot js file all right these are
09:33 - our five components the tetris.js file
09:36 - is kind of the heart of this application
09:39 - we can go into our cell.js file and
09:41 - start scaffold out this component so we
09:43 - import react from
09:46 - react as usual
09:50 - and we create the component const cell
09:52 - equals to
09:54 - parenthesis and we are going to have
09:56 - props for this one so we can create
09:58 - these ones also either structure them
10:00 - out we're going to have a type for this
10:02 - one
10:02 - and we talk about this later on we make
10:05 - an implicit return for now
10:07 - and we can just have a div and
10:10 - write cell inside of it
10:14 - and we export default cell like so we
10:18 - save that one
10:19 - and then we have our display.js file
10:23 - we import react from react
10:27 - we have a const that's called display
10:30 - equals and for this one we're going to
10:33 - have two props so we destructure them
10:35 - out one is called game over and one is
10:38 - called text
10:42 - and we create a div inside of here
10:45 - where we're going to have the text we
10:47 - create curly braces and text to grab
10:49 - that prop and display it inside of the
10:52 - div
10:54 - export default display
10:57 - we will style these components later
10:59 - with style components so we will change
11:02 - some stuff inside of them we just
11:03 - scaffold them out now so we know what
11:06 - components we're going to have for this
11:08 - game
11:09 - save that one
11:12 - then we go into our stage.js file we
11:15 - import react from react
11:18 - of course you can copy and paste a lot
11:19 - here also if you want to do that
11:22 - for this one we're going to import the
11:24 - cell component so we import cell
11:27 - from
11:28 - dot forward slash
11:31 - cell
11:34 - and then we create the const stage
11:37 - equals to
11:38 - i mean the structure of the prop that
11:40 - we're going to have that's called stage
11:44 - and we make an implicit return for this
11:46 - one also and as you can see i'm not
11:48 - doing any prop type checking for this
11:51 - course you can add that in yourself if
11:53 - you want to do that to verify your props
11:55 - with prop types
11:57 - all right we create a div
12:00 - for now again
12:03 - and inside here we're going to map
12:05 - through our stage prop and create cells
12:08 - from this stage prop and we're going to
12:10 - do that later also so it can just have a
12:13 - cell for now
12:14 - inside of this
12:16 - and we export
12:18 - default stage
12:22 - like so and we save this one then we
12:24 - have our start button.js file
12:28 - so we import react from react
12:32 - and we have a const start button
12:37 - and we have a prop that's going to be a
12:39 - callback for this one
12:42 - and we make an implicit return with a
12:45 - div that says start game
12:49 - and we export default
12:51 - start button
12:53 - like so
12:55 - we save that one
12:56 - and then it's the last one it's our
12:58 - tetris component or heart of this
13:00 - application
13:02 - so we import react from
13:05 - react
13:06 - like so
13:08 - and then we're going to have some
13:10 - components here
13:12 - we import our stage
13:15 - from dot forward slash stage
13:20 - also going to need our display
13:22 - from
13:24 - dot forward slash display
13:27 - and we import
13:29 - our start button from
13:31 - dot forward slash start button
13:34 - and these ones we can check them out
13:36 - here this is obviously going to be the
13:38 - stage with the cells in it and these are
13:41 - the display components we have three of
13:43 - them and this is the start game button
13:45 - here so these are the ones we've created
13:48 - now
13:50 - then we create our const tetris
13:53 - and equals to
13:55 - an arrow function
13:57 - and we have curly braces for this one
13:59 - because we're going to have more logic
14:00 - inside of here
14:02 - and we can create the return statement
14:04 - here
14:05 - first we have a kind of a repetitive
14:07 - here
14:08 - and as i said we're going to rename
14:10 - these ones when we style the components
14:12 - then we have our stage
14:14 - and for now we're not sending in any
14:16 - prop because we don't have anything to
14:18 - send in to it right now then we can
14:21 - create a side element
14:24 - that's obviously the sidebar here that
14:27 - we're creating
14:30 - and then we're going to have three
14:31 - different displays
14:34 - and for these ones we have a text prop
14:36 - and for now they can just say score
14:39 - we can copy this one
14:43 - and paste two times and this one can say
14:47 - rows
14:49 - and level
14:51 - all right
14:53 - we can also wrap these ones inside of a
14:55 - div
15:00 - and end it like that
15:05 - and below we're going to have our start
15:07 - button
15:09 - and it's going to get a callback prop
15:11 - but we don't have that yet either so
15:13 - we're not giving it that now
15:16 - so this is it
15:18 - and we export default
15:20 - tetris like so
15:22 - okay
15:25 - then we can store this up to see what
15:27 - we've got so mpm start
15:31 - and we have all our components showing
15:33 - up here and that's great they are of
15:36 - course not styled yet but we're going to
15:38 - do that soon first we have to create the
15:40 - stage and or tetra minus and we're going
15:43 - to do that in the next video before we
15:46 - do the styling so we can see the ui here
15:49 - okay we're going to create the stage and
15:51 - the tetra minus in this video and to do
15:54 - that we have to create a couple of new
15:56 - files
15:57 - inside our source folder or src folder
16:00 - we can create a new file that's called
16:03 - gamehelpers.js
16:07 - and that's a lowercase g on that one
16:09 - because this is not a component and we
16:12 - can also create a new file that's called
16:14 - tetrominos.js
16:17 - make sure you're inside the
16:19 - gamehelpers.js file
16:21 - here we're going to create a stage and
16:23 - we are going to have two const where we
16:25 - can set the stage width and height and
16:27 - we have to import these ones into our
16:30 - components
16:31 - so we have to export them from this file
16:33 - so we export const and then with capital
16:36 - letters
16:37 - we can have stage width
16:40 - and we can set that 1 to 12
16:43 - and we export const
16:45 - stage
16:46 - height
16:50 - and we set that to 20.
16:54 - so that's our width and height but we
16:56 - actually need a function that creates
16:57 - the stage for us and the stage is going
16:59 - to be a nested array a multi-dimensional
17:02 - array that represents rows and columns
17:05 - and we have to export this function that
17:07 - creates the stage also because we're
17:08 - going to need it in our component so we
17:11 - export const create stage
17:15 - and it is an error function
17:18 - all right so how is this going to work
17:20 - well we're going to create a
17:22 - multi-dimensional array that represents
17:24 - the grid so we create an array
17:27 - from something
17:30 - and that something is
17:31 - another array that we're going to create
17:34 - from the stage height and this is going
17:36 - to be an empty array so it's not going
17:38 - to be useful for us so we have to do
17:41 - something we have to fill this up with
17:43 - something
17:44 - we can do that by supplying an inline
17:46 - function here
17:50 - and that means for each row we create a
17:52 - new array
17:55 - from the stage width
17:57 - and we're going to fill it
18:01 - with another array there's a lot of
18:03 - arrays here and for now we set it to
18:05 - zero
18:06 - and we have something that's called
18:08 - clear
18:10 - and these ones i'm going to explain that
18:11 - later on 0 equals nothing on the grid we
18:15 - have the different tetra minus each of
18:17 - them going to have a letter here so we
18:19 - know that the grid has that tetramino in
18:22 - that particular cell
18:23 - and we also have this clear property
18:26 - here that is going to be set to merged
18:28 - when we have a tetra minor merge into
18:31 - the stage that means when we have
18:33 - collided so the tetramino should stay in
18:35 - the stage and not be cleared in the next
18:37 - render and as i said i will explain this
18:40 - later on so i hope you understand this
18:42 - function what it's doing we're creating
18:44 - a new array from an array that we're
18:47 - creating here with a state height that's
18:49 - the 20 rows we're going to have in our
18:51 - grid
18:52 - and we're supplying an inline function
18:54 - that for each row create a new array
18:57 - with our cells and we're filling them up
19:00 - with this array here
19:02 - that has
19:03 - one value that is zero and that's
19:05 - represent a clean cell there's nothing
19:08 - in that cell on the stage and we also
19:10 - have this string here that says clear
19:13 - for now and that means that there's no
19:15 - tetraminer that has collided in this
19:17 - cell and we should wipe it out from the
19:19 - stage in the next render
19:22 - okay so that's how we create our stage
19:25 - and if you remember up here in the
19:27 - components we had our stage here and we
19:29 - had our prop that's called stage and
19:32 - this is the stage we're sending in from
19:34 - the tetris component
19:35 - so we can actually import this one here
19:37 - in the tetris.js file
19:40 - we can import our create stage function
19:42 - here
19:46 - and we grab it from
19:48 - dot dot forward slash game helpers
19:51 - like so and for now we can just send it
19:54 - in to this one
19:56 - we have the stage prop
19:57 - equals curly braces
20:00 - create stage
20:01 - and parenthesis because we we invoke
20:03 - this function here
20:05 - just check in so we're not breaking
20:07 - anything here no
20:11 - and we're going to change this later on
20:13 - because we're going to have the stage in
20:15 - a custom hook and a state for this one
20:18 - but for now we can just send it in so it
20:20 - renders something
20:22 - inside of stage component we can remove
20:24 - this one and inside the div here we
20:27 - create the curly braces because we're
20:29 - going to use javascript now and map over
20:31 - our stage
20:32 - prop so we have a row
20:36 - and we also map through that row
20:39 - and then we get a cell and our x value
20:42 - for that one
20:45 - so what are we doing here well we have
20:47 - the stage that's the one we created we
20:50 - map through that and when we map through
20:52 - that stage array we get the row and each
20:55 - row is also an array that holds the
20:57 - cells so we map through that row also
21:00 - and we get the cell so for each cell we
21:02 - are going to render out the cell
21:04 - component
21:09 - we can set the key to x
21:13 - and our type are going to be the first
21:16 - value in the salary
21:18 - and that's the one we created down here
21:22 - we're telling it when we initially do
21:24 - the render we're telling it that this
21:26 - stage is clean we don't have any tetra
21:28 - minor in the stage
21:30 - so we're grabbing this value here and
21:32 - that's a zero that we set it to
21:34 - initially
21:36 - go back into your state component
21:39 - we have to close this one also
21:41 - this one should hopefully render out the
21:43 - stage for us
21:46 - but as you can see we didn't style it
21:48 - yet so it's just a lot of cells here in
21:51 - one column
21:53 - but we're going to fix that when we do
21:54 - the styling later on
21:56 - all right let's get back to our code
21:59 - that's our stage now we have to create
22:01 - our tetra miners
22:03 - and we're going to keep them in a const
22:05 - that's called tetra minus and it's going
22:08 - to be an object so we export const
22:12 - capital letter tetra minus
22:16 - equals an object
22:18 - and we're going to have different
22:19 - properties for these ones first we can
22:21 - create a property that's called syrup
22:23 - because i'm going to use this initially
22:25 - when we start up the application we
22:27 - don't want to show a tetra miner on the
22:29 - stage but you could do it some other way
22:31 - of course but i think it's nice to have
22:33 - it inside of this tetra miners object
22:37 - alright so we create an object
22:39 - we're going to have a property that's
22:41 - called shape and the shape is also going
22:43 - to be an array with a race
22:46 - i noticed that there's a lot of arrays
22:48 - with arrays when you create games like
22:50 - this so we have an array then we have
22:52 - another array and we just set it to zero
22:55 - and then we have another property that's
22:56 - called color
22:59 - and this is just going to be a string
23:01 - zero comma zero comma zero
23:04 - like that
23:07 - so that's our clean cell that's what
23:08 - we're using when we're not showing any
23:10 - tetra minor and then we have seven
23:12 - different tetra miners we have the i j l
23:16 - o s t and said
23:18 - so we can start by creating the i
23:21 - so we create a new property that's
23:23 - called i and we create a new object for
23:25 - that one
23:27 - we have the shape property that's going
23:30 - to be an array
23:33 - and inside of that array we're going to
23:35 - have another array
23:37 - and as i mentioned before a zero equals
23:40 - nothing on the grid and we're going to
23:43 - use a letter where we want to show this
23:45 - tetra minus first we have a zero that's
23:48 - nothing
23:50 - then we have a string with a capital i
23:53 - then we have a zero and a zero
23:57 - then we create another array
24:00 - with another zero
24:02 - and another i
24:05 - and a zero and a zero
24:08 - and this one is just going to be a four
24:10 - by four
24:12 - so we can copy this once
24:14 - and paste them in like that
24:18 - and as you can see this is going to be
24:19 - the eye shape that is the long one
24:22 - the long tetra minor that's the only one
24:24 - that has four in width and we can make
24:27 - it a little cleaner here maybe
24:31 - i will not auto format this because it
24:33 - will destroy this
24:35 - formatting i've done here it's easier to
24:37 - see the tetra minor here otherwise it
24:40 - will format it in just one line for me
24:43 - and that's no good
24:46 - so we have another property here also so
24:49 - we have the color
24:53 - and this is yet again a string and this
24:55 - is just an rgb value i'm going to use in
24:58 - the css later on
25:00 - so i'm setting the call of this one to
25:03 - 80
25:04 - 227
25:06 - 230
25:09 - so this is the i we have here
25:12 - and i guess we can just copy and paste
25:14 - this one
25:15 - make sure you make a comma here
25:18 - and we create a j
25:21 - and the shape for the j is going to be
25:25 - we can remove these last ones because
25:27 - it's going to be three by three
25:30 - so we remove the last row there also
25:33 - change this once to j
25:36 - j
25:37 - j
25:38 - and we're going to have a j there also i
25:40 - hope you see this
25:43 - oops it's going to be a string
25:46 - i hope you see this pattern here that
25:48 - this is a j
25:49 - and the color for this one is going to
25:51 - be
25:53 - 36
25:55 - 95
25:57 - 223
26:00 - all right
26:01 - then we copy this one and paste we're
26:03 - going to create the l shape
26:07 - and it's exactly like the j but we
26:09 - change this one and put it there instead
26:13 - and of course we should have an l also
26:17 - as a value in these strings
26:21 - and the color is going to be
26:23 - 2 2 3
26:25 - 1 7 3
26:27 - and 36
26:29 - all right
26:31 - we copy this one
26:33 - make sure you don't forget the comma
26:35 - there
26:37 - and we're going to create the o shape
26:42 - and this is actually just going to be
26:44 - two values in
26:46 - so we have the o
26:49 - and
26:50 - o
26:52 - like so
26:57 - and oh
27:00 - so we have a two by two array there
27:04 - and the color for this one is going to
27:06 - be
27:07 - two two three
27:10 - two one seven
27:12 - yeah and also 36 for that one all right
27:15 - then we can grab the l up here
27:17 - copy it
27:19 - make another comma
27:21 - paste it
27:22 - we have the s shape
27:27 - and it's going to be a zero
27:29 - an s don't forget that this is a string
27:31 - here so don't forget the ticks here
27:35 - and then we have an s and an s and a
27:38 - zero and these ones are just going to be
27:40 - zeros
27:47 - like so
27:48 - and the color is
27:51 - 48
27:52 - 211
27:54 - and 56
27:57 - all right then we paste in yet another
28:00 - one and we have two to go we have the t
28:05 - and that shape is going to be
28:08 - zero zero zero
28:13 - then we have a t
28:16 - a t
28:19 - and a t
28:20 - and now we have a zero a t and a zero
28:24 - a nice little shaped t there
28:27 - and the color is 132
28:31 - 61 and 198
28:35 - and then we have the last one and that's
28:37 - the said
28:38 - whoa kind of boring this but we have to
28:41 - do it otherwise we don't have any tetra
28:44 - minus
28:45 - all right this said
28:49 - we have a said
28:51 - a set
28:52 - and a zero
28:54 - then we have a zero
28:56 - a set
28:58 - and a set
29:00 - and then zero
29:02 - zero
29:04 - and zero and then we just have the color
29:07 - for this one and that's two to seven
29:10 - seventy eight and 78
29:14 - all right
29:16 - so that's our tetra minus
29:22 - and we have one more thing to do because
29:24 - we want to have a function that
29:26 - generates a random tetra miner for us so
29:29 - we export const
29:32 - random petromino
29:36 - and we create the function for that one
29:38 - we have curly braces here
29:40 - so first we create the const called
29:42 - tetraminos lowercase letters
29:45 - and we create the string with capital
29:48 - letters i j
29:49 - l o s t said
29:54 - and this is of course the string with
29:56 - all our seven tetra minors
29:58 - then we create another const
30:00 - rand tetro minor
30:04 - like so
30:06 - we're going to grab a random letter from
30:08 - this tetra minor string and we do that
30:11 - by typing tetro minus
30:15 - that's the string const
30:17 - and inside of here we do a little math
30:20 - dot floor
30:23 - math dot random
30:29 - times tetra minus
30:32 - length
30:33 - like so and this is just a standard for
30:36 - generating random numbers of the length
30:38 - of this in this case the string so we
30:41 - have the string length and we're getting
30:42 - a random number for this one
30:44 - and i misspelled this one it should be
30:46 - tetra minus
30:49 - yeah so we have the tetra minor string
30:51 - and we're grabbing a random number for
30:53 - that one and that will return one of the
30:55 - letters for us and that's how we get the
30:57 - random tetra minor because now we can
31:00 - return
31:04 - from our tetro minus
31:06 - rand tetra minor
31:08 - so for example let's say that this will
31:09 - give us an l here
31:12 - so we have that one and we go to our
31:14 - tetra minus object and we have an l here
31:17 - and that will of course grab the l
31:19 - property for us and return
31:21 - this one here the l tetra minor with the
31:24 - shape and the color this is an object
31:26 - here so we get that object back
31:29 - and that's how we get a random tetra
31:31 - minor
31:32 - i type the zero here it should of course
31:34 - be an o
31:36 - there
31:39 - and save this one all right this was a
31:42 - lot i know i know
31:44 - and i think that's why i don't do games
31:48 - but i i recommend it to really go
31:50 - through this code and try to understand
31:52 - it as much as possible before moving
31:55 - forward in the next video we're going to
31:57 - create the styles with style component
31:59 - and after that we actually going to
32:01 - start to do some heavy coding on the
32:03 - game
32:05 - we're going to do some styling now to
32:07 - get this sad look
32:09 - out of this tetris game and if you're
32:11 - not a css person you don't like to style
32:14 - things you can just copy and paste the
32:16 - styles from the starter files into your
32:19 - project but you have to import them into
32:21 - your component as i'm going to show in
32:23 - this video and also change your divs to
32:25 - the components that we're using from the
32:27 - styles component i'm going to show you
32:29 - this soon so let's get on with it first
32:32 - of all we're going to create the global
32:34 - styling and actually i've been kind of
32:36 - lazy for this one because you can create
32:38 - global styles with style components but
32:41 - i'm actually just going to use this
32:42 - index dot css file that's yeah pre-made
32:45 - for us with create direct app and it's
32:48 - imported in the index file and that's
32:50 - because we're going to have a font and
32:52 - it's a little bit more troublesome to
32:54 - import it with style components
32:56 - so if we go inside the index.css
33:00 - file first we're going to set our body
33:03 - we're going to set our margin to zero
33:06 - and then
33:07 - we are going to import a font so we have
33:09 - a font face
33:13 - and the font family is going to be
33:15 - called pixel
33:18 - and we have a source src with our url
33:22 - and we grab our font from font
33:24 - forward slash pixel
33:27 - dash
33:28 - lcd-7 dot buff
33:32 - we can also set the format to vof
33:37 - like so and we save that one
33:40 - yeah and we will not see anything
33:42 - happening here right now
33:44 - but that's our global styling
33:47 - then we can move up to our components
33:49 - and we're going to style the tetris
33:51 - component first and what i like to do
33:54 - when i use style component is that i
33:56 - create this folder
33:57 - that where i place all of my styling and
34:00 - then i import them into the components
34:02 - so inside of the components folder
34:05 - create another folder that called styles
34:09 - and inside the styles folder create a
34:11 - new file
34:13 - and call it styled
34:14 - cell.js i also like to name them like
34:17 - this with styled and then the component
34:20 - name and dot js so styled cell dot js
34:23 - capital s capital c
34:26 - and first we have to import style from
34:28 - style components
34:31 - and then we need to export our style
34:33 - component because we're going to import
34:35 - it into the tetris component when we
34:38 - created this one
34:39 - so we export const
34:42 - style cell
34:44 - and equals style dot and this is going
34:47 - to be a div we have backticks because
34:50 - this is a tagged function
34:52 - and this is how style components works
34:54 - you have this tag function and you can
34:56 - write regular css inside of it
34:59 - and if you don't know style components i
35:01 - really recommend you to read more about
35:02 - it at their webpage i'm not going to go
35:06 - through everything with star components
35:08 - in this tutorial because as i said
35:10 - before this tutorial is about showing
35:12 - you how to build a tetris game with
35:14 - react and i assume that you know some
35:17 - stuff with react and yeah style
35:20 - components also otherwise
35:22 - it's not that difficult to use style
35:23 - components so i think you will pick up a
35:25 - lot just watching me create these
35:27 - components
35:29 - all right and i just realized i created
35:31 - a styled cell now okay
35:34 - i said tetris component but it's the
35:37 - styled cell i created now so well let's
35:40 - create the styles for the cell component
35:42 - first then
35:44 - okay we're going to have a width
35:47 - and set that to auto
35:50 - then we're going to set our background
35:52 - and that's going to be an rgba
35:56 - and we're going to grab this from the
35:57 - props that we send into the cell
35:59 - component
36:01 - so for now i just type this out and we
36:03 - go to the cell component and i'm going
36:05 - to show you how this prop work
36:07 - so we have a dollar sign curly braces
36:10 - and props and an arrow function
36:13 - and a props
36:15 - we have one that's called color
36:18 - so that's how we get our rgb value and
36:21 - we set the alpha value to 0.7 this is
36:24 - just regular css
36:26 - so we're going to come back to this in a
36:28 - second but first we save this one and we
36:30 - go into the cell component and i'm going
36:32 - to show you how this works with the
36:34 - props
36:35 - so first of all
36:37 - we import our styled cell that's the one
36:40 - we created
36:42 - and we grab it from styles
36:45 - forward slash style cell
36:48 - like so
36:50 - then we also going to need our tetra
36:52 - minus so we import our tetra minus
36:56 - if you remember that's the one we
36:58 - created down here it's an object with
37:01 - different tetra minus
37:06 - so we grab that from dot dot forward
37:08 - slash
37:10 - tetra minus
37:12 - all right so now we got everything we
37:14 - want in this component we can now first
37:17 - change this one to our styled cell
37:23 - that's the one we create here
37:25 - and we import it in this component here
37:28 - so we use it here you could write the
37:30 - style component inside of this component
37:32 - and many people do it like that but i
37:34 - like to have them separated because i
37:36 - think this is yeah i like this structure
37:39 - of things
37:40 - so you can do whatever you want and then
37:41 - you don't have to do all this export and
37:43 - import stuff that i do here
37:46 - okay so this style cell is going to have
37:49 - a type prop
37:52 - and we grab the type from type we are
37:54 - sending that in here and now we're
37:56 - passing that prop into our style
37:58 - component
38:00 - and then we're going to have a color
38:03 - and the color we can grab from the tetra
38:05 - minus
38:10 - and the type is going to be the tetra
38:12 - minor so we if we for example have the
38:14 - type of l it will grab the tetra minus l
38:18 - for the color
38:20 - and of course we're also going to grab
38:21 - the property color because when we
38:23 - created the tetra minus
38:26 - we have both the shape property and the
38:28 - color properties so this is the one
38:30 - we're grabbing here is the color
38:31 - property from the tetra minus
38:37 - all right so for now we can just we
38:39 - change this one to yeah we can say on l
38:44 - because we're not sending in anything to
38:46 - this component yet
38:47 - because as i said i intended to do the
38:49 - tetris first
38:51 - but now we do the cell here instead
38:56 - and as you can see now we're getting the
38:58 - color here but it will color everything
39:00 - here and that's because this cell row
39:05 - you see it's the com it take up the
39:07 - complete width here
39:09 - so the color is there but we haven't
39:11 - created the grid yet and that's because
39:13 - it's showing all yellow now because each
39:16 - cell is a hundred percent with right now
39:20 - all right let's go back to the styling
39:22 - we need some
39:23 - shadows on our tetra minus
39:26 - so this is also how it works with props
39:28 - that you send into your style components
39:30 - you can grab them with an inline
39:32 - function like this because this is a
39:34 - tagged function you can use a dollar
39:36 - sign and curly brackets and use
39:38 - expressions inside of these ones and by
39:40 - using this inline function we can grab
39:42 - the props that we send into our style
39:44 - components and we had one prop that is
39:47 - called color
39:48 - so we're grabbing that one inside of
39:50 - here
39:52 - all right
39:54 - so that's our background we also want to
39:57 - set our border
39:59 - yet again we have a dollar sign and
40:01 - curly braces we have our props
40:06 - and then we're going to do a ternary
40:08 - operator here we check if our props type
40:11 - if that one equals to zero that means we
40:14 - not have a tetramino in this specific
40:16 - cell
40:18 - so we don't want to have a border so we
40:20 - set that one to null pixels solid i
40:22 - don't actually yeah
40:25 - i don't think we need solid here but
40:27 - yeah
40:28 - let it be there for now
40:30 - otherwise we set it to 4 pixels solid
40:35 - all
40:36 - right then we have our border bottom
40:40 - color
40:41 - and that is going to be on rgba
40:46 - and yet again we have a dollar sign
40:48 - curly braces
40:50 - we have our props
40:52 - and we have our props dot color
40:54 - and we're going to set the alpha value
40:56 - here to 0
40:58 - to 0.1 we can actually just grab this
41:00 - one and copy
41:04 - and paste it in three times
41:07 - because now we have border right
41:10 - color
41:11 - and that one we're going to set to one
41:14 - and then we have
41:17 - border top color and we set that one to
41:20 - one also
41:24 - and bore the left color and we set that
41:26 - one to 0.3
41:28 - and this will give us kind of the shadow
41:31 - effect on the blocks yeah if you don't
41:33 - like them you can just play around with
41:35 - this and set your own shadow
41:37 - and this is also what i like about style
41:39 - components because you can send in props
41:41 - like this we can easily modify your css
41:44 - conditionally with props and that's
41:46 - really nice actually
41:48 - so what i'm doing here i'm just using
41:50 - the same color value as we set in the
41:52 - tetra minus object but i'm just changing
41:54 - the alpha value to get different opacity
41:57 - on the blocks
41:59 - all right let's go to our tetris.js file
42:02 - now and do it in the right order here
42:05 - we are going to create two different
42:07 - style components here we have one that
42:10 - style tetris wrapper and one that's
42:12 - called style tetris so we have a wrapper
42:14 - around here and we have the tetris
42:17 - also we can actually just type them out
42:20 - here so we can see the structure of it
42:21 - here is going to be a styled
42:24 - tetris wrapper
42:27 - like so
42:28 - and we close it down below there
42:31 - and it will complain of course we
42:33 - haven't created this one yet
42:36 - and then below we're going to have the
42:38 - styled tetris
42:41 - component
42:47 - and of course we have to move that down
42:49 - here
42:53 - like so
42:55 - and i will explain later why we have
42:57 - this wrapper here
42:59 - so these are the two style components so
43:01 - let's create a new file inside of the
43:02 - styles folder that's called
43:05 - styledtetris.js and inside that file
43:08 - inside
43:09 - styletetris.js
43:11 - import style from style components
43:15 - like so
43:16 - we also need to import our background
43:18 - image so we can call it
43:20 - bd
43:21 - image
43:22 - and we grab that from dot dot forward
43:24 - slash dot dot forward slash
43:27 - imd
43:29 - pj dot png
43:31 - like so
43:33 - then we export const or styled tetris
43:38 - wrapper and that one is going to be a
43:41 - style.div
43:43 - and we have our backticks because this
43:45 - is a tag function
43:47 - we set our width
43:49 - to 100 viewport width
43:52 - and our height 200
43:55 - viewport height
43:58 - yeah this is just regular css now and
44:00 - i'm not going to explain the css here
44:02 - either i hope you know your css
44:04 - otherwise you can pick up some things
44:06 - here but i won't explain them yeah in
44:09 - detail
44:12 - and here we can set our background with
44:14 - the url
44:16 - and now we can just use our
44:18 - bj image
44:20 - and we do that by creating a dollar sign
44:22 - and curly braces and inside we have our
44:24 - bj image
44:26 - and we can set a default color to
44:28 - zero zero zero
44:31 - we have a background size
44:36 - of cover
44:38 - and overflow is going to be hidden for
44:40 - this one and this is also great with
44:43 - style components because otherwise if
44:44 - you set a background image you may have
44:46 - done some inline styling to get the
44:48 - image to show up as a background image
44:50 - but here we can just import it and use
44:52 - it in the style component like this so
44:55 - we don't have to do any inline styling
44:57 - on the component itself
45:01 - all right then we have our export cons
45:03 - to style tetris
45:08 - and that's going to be a style div also
45:11 - type function
45:14 - this is going to be a flex
45:18 - align items
45:20 - to flex start
45:23 - we set our padding to 40 pixels
45:27 - and we have a margin
45:29 - of 0 and auto
45:32 - and a max width
45:34 - of 900 pixels
45:38 - the css here is not really optimized you
45:41 - can try to get a better look for
45:43 - yourself if you want to do that i
45:44 - haven't put that much time in the css
45:47 - styling i just wanted something to work
45:49 - fairly good so you could probably
45:52 - improve the css and get a better grid
45:54 - and stuff like that
45:57 - and inside here we have our aside and
45:59 - we're going to style that and this is
46:00 - also great with star components of
46:02 - course you can nest them inside of here
46:04 - just like you do in sas for example
46:07 - so we set our width to 100
46:11 - a max width
46:13 - of 200 pixels
46:16 - we set our display to block
46:19 - and padding to 0 and 20 pixels like so
46:23 - and that is going to be our style
46:25 - component for the style tetris
46:28 - now we just have to import it up in the
46:31 - component
46:32 - so we can import our
46:35 - styled tetris wrapper and or style
46:38 - tetris
46:40 - and we grab them from dot forward slash
46:42 - styles
46:44 - forward slash
46:46 - style tetris and no it shouldn't
46:48 - complain here no
46:52 - all right and as you can see we are
46:55 - gradually exchanging this
46:56 - one to something else so we see the
46:58 - space here now and we see that the cells
47:01 - are just yeah these tiny bits now
47:05 - all right then we can create another
47:06 - style inside of styles folder that's
47:09 - called
47:11 - style stage.js
47:14 - and we create the style first
47:17 - so we import styled
47:19 - from
47:23 - style components
47:25 - then we export const style stage
47:30 - and it's equal to styled div and we have
47:32 - backticks course it's a tagged function
47:36 - and we're going to display a grid for
47:38 - this one
47:41 - we have our grid template rows
47:46 - it's going to repeat
47:48 - and we're grabbing from props
47:53 - or props dot height
47:56 - or coma and then we're going to do some
47:58 - css calculation here
48:03 - we have 25 viewport width
48:06 - and we divide it with
48:09 - we have dollar sign and curly braces
48:11 - because now we're going to have another
48:12 - inline function another inline function
48:14 - to grab our props
48:17 - and we grab the props dot width and this
48:19 - is going to do some nice little
48:21 - calculation for us to make the grid look
48:24 - nice and we are doing this to keep the
48:26 - aspect ratio of the grid cells
48:30 - then we have our grid template columns
48:33 - that's also going to repeat
48:37 - and from our props yet again
48:40 - we grab our props dot width
48:43 - and it's going to be one fragment
48:45 - and of course that one should be there
48:50 - like so these calculations is because we
48:52 - want to keep the aspect ratio of
48:54 - ourselves we want them to be perfect
48:56 - squares
48:57 - all the time and this is actually kind
49:00 - of tricky to do so yeah i've got it to
49:02 - work yeah fairly responsive but not 100
49:05 - percent so if you come up with a better
49:08 - idea feel free to change it to whatever
49:10 - you want
49:12 - we want to have a grid gap of one pixel
49:15 - and the border going to be two pixels
49:19 - solid
49:20 - and we can set it to three three three
49:24 - we have a width of hundred percent
49:28 - and a max width
49:30 - of 25 viewport width
49:34 - and a background of
49:37 - say one one one all right
49:41 - so that's our style stage we just have
49:43 - to import it into the stage component so
49:45 - make sure you're inside the stage
49:46 - component
49:48 - and import
49:50 - style stage
49:52 - from
49:53 - dot forward slash styles forward slash
49:57 - style stage
49:59 - all right and then we rename this one
50:03 - to our style stage
50:07 - now we close it with the same
50:10 - and we're going to send some props
50:11 - inside of this of course we had a width
50:13 - and that one we're grabbing from
50:16 - we are sending in the stage as props to
50:19 - this one
50:20 - so if we grab the stage
50:23 - and the first row
50:25 - and the length we know the width of our
50:27 - grid
50:28 - and the height
50:29 - we just grab the stage
50:31 - length
50:33 - like so and that will give us the height
50:35 - from our multi-dimensional array
50:38 - all right we save this one and see what
50:40 - we've got
50:41 - and as you can see we have something
50:43 - here
50:44 - so we're slowly getting there we can
50:47 - actually now also go back into the cell
50:49 - component and we can remove the text
50:52 - here we don't need that one
50:55 - and that's why we can just self-close it
50:57 - like this
50:59 - and that will get us our grid and here
51:01 - you can also see the shadows that we
51:03 - created in the cell component
51:06 - and it works fairly responsive
51:13 - what have we got left to do we're going
51:15 - to style our display and our start
51:18 - button inside our styles folder create a
51:20 - new file styled display
51:26 - dot js
51:28 - and import
51:31 - style from styled components
51:34 - and we export const
51:36 - styled display
51:40 - and it equals a styled div
51:43 - and yet again backticks
51:46 - box sizing to
51:48 - border box
51:51 - we display
51:53 - flex
51:55 - we align items
51:58 - to center
52:00 - why i'm using flexbox is to align the
52:02 - text in the different displays we have a
52:05 - margin of 0 0 20 pixels and 0
52:09 - we have a padding of 20 pixels
52:12 - we have a border of 4 pixels solid
52:16 - and a triple three
52:19 - we have a min height
52:21 - of
52:22 - 30 pixels
52:24 - we have a width of 100 percent
52:28 - a border radius
52:30 - of 20 pixels
52:32 - and the color and that one we're
52:34 - grabbing from props yet again we have a
52:36 - dollar sign and curly braces
52:39 - we have our props
52:41 - and we do a turner operator because we
52:43 - are using the same display component
52:45 - when we did play game over as we display
52:47 - the score and rows and things like that
52:51 - so we have a prop that's called game
52:53 - over
52:57 - and if it's game over we set the text to
53:00 - red
53:01 - otherwise we set it to
53:04 - some grayish
53:09 - and we set the background
53:11 - to black
53:14 - we have a font family
53:16 - of pixel that's the one we imported in
53:19 - the global css file
53:23 - and we can set it to yeah some fallback
53:25 - fonts here
53:27 - and the font size
53:30 - of 0.8 rem
53:34 - like so and then we just have to import
53:36 - and use it in our display component
53:39 - so we import or styled display
53:43 - from
53:45 - dot forward slash styles forward slash
53:50 - style display
53:54 - and then we change this div to our style
53:56 - display component and we also had our
53:59 - prop
54:00 - that's called game over
54:03 - so we send that one in
54:05 - like so
54:07 - and let's see what we've got
54:09 - and there's some nice displays and we
54:11 - have this retro font inside of them and
54:13 - that's good
54:14 - we just have to style our start button
54:16 - and then i think we'll be good to go to
54:18 - do some heavy coding on this game
54:21 - so inside of styles create a new file
54:24 - and call it styled start button.js
54:28 - import style from style components
54:33 - getting boring boring boring but we have
54:36 - to do this so we export a const and
54:39 - style start
54:42 - button
54:44 - and we have a styled button
54:48 - double backticks and inside we write our
54:50 - css we have our box sizing and we set
54:54 - that one to border box
54:56 - we have a margin of 0 0 20 pixels and 0
55:00 - we have a padding of 20 pixels
55:03 - a min height of 30 pixels
55:06 - a width of 100
55:10 - and a border radius of 20 pixels
55:14 - a border
55:15 - we set that one to none we have a color
55:18 - of white
55:20 - a background
55:24 - of a triple three
55:26 - we have a font family of pixel
55:31 - and
55:33 - some fallback fonts
55:35 - we have a font size of
55:37 - one rem
55:39 - on outline
55:41 - of none because we don't want to display
55:43 - that ugly outline when we press the
55:45 - button
55:47 - we set the cursor to pointer also
55:51 - and we save that one and inside our
55:53 - start button
55:55 - we are going to import this one so we
55:57 - import
56:02 - styled start button
56:05 - from
56:06 - dot forward slash styles forward slash
56:10 - style start button
56:13 - and of course we change this one to
56:15 - style the start button
56:18 - we are also going to have an on click
56:20 - handler on this one so we can type it in
56:22 - now so we have the on click and it's
56:24 - going to be a callback
56:26 - all right
56:28 - so that's the start button
56:31 - and it's showing nicely
56:34 - but nothing is happening now because we
56:35 - don't have that callback created yet
56:38 - but we have something that looks like a
56:40 - tetris we're just going to remove this
56:43 - yellow one
56:46 - from our cell
56:49 - because the type is going to be the type
56:52 - and here we also change that one to type
56:55 - because that was only to show you what
56:58 - we were doing here
57:02 - and as you can see now we have our grid
57:04 - here instead
57:07 - and that's nice because that's our
57:09 - playing field and everything set up for
57:11 - us so we can start coding the real game
57:13 - here and we'll start with that in the
57:15 - next video so see you then
57:19 - okay we got our stage our displays and
57:22 - our start button and it's time to code
57:24 - some logic for this game and how is it
57:27 - going to work yeah well we're going to
57:29 - have this stage of course with the cells
57:31 - here and we're going to have a player
57:33 - and we're going to use react hooks to
57:35 - create this game and two big advantages
57:38 - with hooks is that you can abstract them
57:40 - and you can reduce them and compose
57:43 - things together and that's really great
57:45 - and for this game we're going to create
57:47 - three own custom hooks and that's the
57:50 - use stage use player use game status and
57:53 - the use in the well is the one that dana
57:55 - remote created for us and the reason
57:57 - that i created these custom hooks is
57:59 - that i want to
58:00 - kind of separate out the logic for
58:02 - different things so we have all the
58:04 - logic for the player in the use player
58:06 - hook and we have all the logic for the
58:08 - stage in the use stage hook and we also
58:11 - have the use game status that is going
58:13 - to have yeah mostly the display logic
58:16 - that we're going to show like the scores
58:18 - and things like that and how many rows
58:20 - we cleared so that is how we're going to
58:22 - divide up the code and we have the
58:24 - tetris component that's going to be our
58:26 - main component as i said before that's
58:28 - the heart of our application and as
58:30 - we're creating a game we're going to
58:32 - have some kind of game loop and as i
58:34 - also said before we're going to use an
58:36 - interval for this one and not using yeah
58:39 - maybe the more sophisticated way where
58:41 - you get animation frames and stuff like
58:43 - that so we have this grid here that is
58:45 - uh represented by the array and we can
58:48 - actually console log this one out so we
58:50 - can see what we have in our array
58:53 - so inside of here somewhere
58:57 - we can console.log
59:00 - create stage
59:03 - like so
59:06 - and i'm just going to show the console
59:08 - here
59:09 - and as you can see we have an array with
59:11 - 20 rows in it and each row has 12 cells
59:16 - and as you can see here we have a zero
59:18 - and that means that this cell is clear
59:20 - we don't have a tetramino in this cell
59:22 - and it's also set to clear as we can see
59:25 - now we just have a clean stage here so
59:27 - everyone here is clear and that means
59:29 - that we don't have any tetramine or
59:32 - merge into our stage because when we
59:34 - collide with something we're going to
59:36 - change this one to merge and in the next
59:39 - render we're going to keep every cell
59:41 - that has merged here and that's the way
59:43 - we keep the tetra minus that has
59:45 - collided i think it will get too much
59:48 - more clearer when we actually create the
59:49 - tetra minor and how our game loop works
59:52 - because the game loop are going to do
59:55 - a couple of things for us the first
59:56 - thing we have to do in our game loop is
59:58 - that we clear the stage and then we
60:00 - check for an emerged cells here and we
60:02 - don't clear the merged ones so they are
60:04 - going to stay in the stage they're going
60:06 - to stay in the array for a stage
60:09 - and then we're going to check the
60:11 - position of our tetramino and if it
60:13 - hasn't collided we are just going to set
60:15 - it to clear again and that means for the
60:18 - next render it's going to be wiped out
60:20 - and it's going to move and that's the
60:22 - way we get the illusion of movement here
60:25 - or maybe it's not an illusion it is a
60:27 - movement but the tetra minor that hasn't
60:30 - collided is getting cleared on every
60:32 - render but if we have set this to merge
60:35 - it's going to stay in the stage and then
60:37 - we do this over and over again with our
60:40 - innerval and that's the way we get the
60:42 - movement for our tetra minor
60:45 - so that's the short very compact version
60:48 - of how this game loop is going to work
60:51 - and we also kind of have to look into
60:53 - the future because we are going to check
60:55 - the collision before we actually move
60:57 - the player so when we make a move if it
61:00 - drops or if you move it with the arrows
61:02 - on your keyboard we first check the
61:04 - collision before we make the move and if
61:06 - it collides we don't make the move
61:09 - because then we know that it has
61:10 - collider we always check the game field
61:13 - the stage one step ahead before we make
61:16 - the move and that is also going to be
61:18 - much more clearer when we actually do
61:19 - this coding i just wanted to explain it
61:22 - shortly for you so you have a rough idea
61:24 - of how this is going to work
61:27 - all right so let's get back to our code
61:31 - we can start in our hooks directory in
61:33 - our hooks folder
61:35 - and inside of that folder we create two
61:38 - new files we create one that is called
61:40 - use player
61:42 - dot js
61:44 - and one that is called use stage
61:47 - dot js
61:48 - and as i said i always name my files as
61:51 - the component or in this case the hook
61:53 - itself and in react you always name your
61:57 - custom hooks with use before the actual
61:59 - name so in this case it's use stage and
62:02 - use player
62:04 - so we can start off in the use player.js
62:06 - file so make sure you're inside of that
62:09 - file
62:10 - and we import and we're not going to
62:12 - need react for this one we just need to
62:14 - use state
62:16 - state
62:19 - from react
62:20 - because this is not a react component so
62:23 - we're just importing the use state
62:27 - then we can import our random tetra
62:29 - minor function
62:33 - and we grab that from dot dot forward
62:35 - slash tetra minus
62:39 - then we export const and we have our use
62:42 - player as i said it's important to have
62:45 - used before otherwise react won't know
62:47 - that this is a custom hook
62:51 - and we have an error function curly
62:53 - braces and we're going to create a state
62:55 - for this one and that's the only thing
62:57 - we're going to do in this video then
62:58 - we're going to build more up on these
63:00 - files in the next videos we're going to
63:02 - create a state now with a hook that's
63:04 - called use state that we imported up
63:06 - here and use state will return an array
63:09 - with two items in it for us and that's
63:12 - where we can use es6 destructuring to
63:15 - grab these two values
63:17 - so we have a const and we have an array
63:19 - that we want to destructure and we can
63:21 - call it the player and we have the set
63:23 - player
63:26 - and we use state
63:28 - and this is the way that you state works
63:30 - as i said we get two values back we got
63:33 - the actual state here and then we have
63:35 - the setter for this state you can call
63:37 - them whatever you want they don't need
63:39 - to be player or set player and this is
63:41 - just two values that we destructure out
63:44 - here so this line here is actually short
63:47 - for all of this we have a const with
63:50 - player state maybe
63:53 - and we use state
63:56 - and then we have our player
63:58 - and we grab player state
64:01 - and the first value in the array then we
64:03 - have our set player
64:06 - and then we have our player state
64:08 - and the second value in that array but
64:11 - by using es6 the structuring we can make
64:14 - it in one row here and that's very very
64:16 - convenient and that's the way you should
64:18 - do it when you use state
64:22 - so get rid of this
64:25 - we are also going to set an initial
64:27 - state for a player
64:29 - and you can actually send in your
64:30 - initial state to the u state when you
64:32 - create the state with it we're going to
64:34 - have an object so we have curly braces
64:37 - and inside we're going to have a
64:38 - property that's called pos that's the
64:40 - position for our player we're going to
64:43 - have an x value and we set at the zero
64:45 - and then y value we set it to zero also
64:50 - and then we have our tetra minor
64:54 - and that's going to be one of them we
64:56 - created down here that we're always
64:58 - going to keep in this state for the
65:00 - player
65:01 - and for now we can actually just set the
65:03 - random tetramino
65:05 - so we call that function and we're going
65:07 - to grab the shape from the tetra minor
65:10 - and if you remember we had one shape
65:12 - property and one color property so this
65:15 - is the one we're grabbing here that's
65:16 - the shape of our tetra minor zero equals
65:19 - nothing and the letter inside of here
65:22 - equals the cells that are occupied in
65:24 - our tetra minor and i choose to have the
65:27 - letter of the actual tetramine here you
65:29 - could actually have the same letter for
65:31 - every one of them it doesn't matter
65:33 - because we're just going to check if
65:34 - it's not zero when we render the tetra
65:37 - minor to the stage
65:39 - all right so we grab a random tetramino
65:42 - and the shape of that one and put it in
65:44 - our state for the player and then we're
65:46 - going to have a property that's called
65:48 - collided and we set that to false
65:51 - so that's our initial state for the
65:53 - player
65:54 - and now we're actually just going to
65:56 - return the player
65:59 - because we're going to import this
66:01 - custom hook into our tetris component
66:04 - and then we're going to need the player
66:06 - inside of the tetris component
66:09 - i'm going to show you this in a second
66:11 - for now this is it for the use player
66:13 - we're going to return to this file and
66:15 - we can now move on to our new stage hook
66:18 - and do almost the same for that one
66:22 - so we import use state
66:26 - from react
66:28 - so we import create
66:30 - stage
66:32 - from
66:33 - dot dot forward slash game helpers
66:37 - all right
66:38 - and then we create their custom hook so
66:40 - we export const and we're going to call
66:43 - it use stage
66:46 - and it's an arrow function curly braces
66:49 - and we create the state for this one
66:51 - also
66:52 - so we call it stage and set stage
66:56 - and we call the use stage hook
66:59 - and inside of this we're actually going
67:01 - to give it the initial stage and we can
67:04 - just call the create stage inside of
67:06 - here and it will generate the initial
67:08 - stage for us the clean board for a game
67:11 - as we have here
67:13 - so that's our state for the stage
67:15 - and we're going to return
67:18 - we're going to need both the stage and
67:20 - the set stage for this one
67:22 - so we return them
67:24 - and i can see that i typed use stage
67:27 - here it should of course be use state
67:30 - like so
67:32 - so we save this one
67:34 - and then we're going to do a little bit
67:36 - of coding in our tetris component also
67:40 - so make sure you're inside your
67:42 - tetris.js file
67:45 - we can actually remove the create state
67:47 - for this one now we just had it before
67:49 - we're not going to need that one because
67:51 - we're creating the stage in our use
67:52 - stagehook now so remove this one
67:55 - and we can actually make a little
67:57 - comment here this is a style components
68:00 - and then we're going to have our custom
68:02 - hooks
68:04 - so we import
68:06 - use player
68:09 - from
68:10 - dot dot forward slash
68:13 - hooks
68:14 - and use player
68:17 - and then we also import our new stage
68:21 - from dot dot forward slash hooks
68:24 - use stage
68:27 - all right and we already have imported
68:29 - the components
68:31 - we are going to use some state in this
68:33 - component also
68:34 - so we have to import use state up here
68:40 - all right
68:41 - so we're both importing react and use
68:44 - state
68:46 - and now we can remove this console log
68:49 - but it would be nice to have a console
68:51 - log here that tells us if it re-renders
68:54 - so we can create that one console.log
68:57 - re-render
69:00 - it's always nice to have
69:02 - then we're going to create two states
69:04 - now actually because yeah we're not
69:06 - going to use them right now but we can
69:08 - create them as we're already in this
69:10 - component we're going to have one that's
69:12 - called drop time and one that's called
69:14 - game over and the drop time is the
69:16 - actual speed that we're going to modify
69:19 - depending on which level we're on and
69:21 - then the game over is yeah simply going
69:24 - to tell us if the game is over or not so
69:26 - we're keeping true or false in a state
69:28 - for that one so we create the new
69:30 - state that's called drop time
69:33 - and set drop time
69:36 - we have use state and for this one we
69:39 - can just initialize it with null
69:42 - and we have a game over and set game
69:45 - over
69:48 - and our use state
69:50 - and we set that one to false of course
69:52 - it's not game over when we start
69:56 - and then we're going to use our custom
69:58 - hooks
69:59 - and if you remember from a player we
70:01 - exported
70:03 - our player
70:04 - and that means
70:05 - that we can grab that one
70:08 - with destruction here
70:10 - const player
70:13 - and use player
70:15 - like so
70:17 - and we also have our stage and for that
70:19 - one we exported
70:21 - two different values in an array
70:24 - so we can destructure them out also
70:26 - so we have our stage and our set stage
70:32 - we run our custom hook
70:35 - called use stage
70:37 - and we send in the player to this one
70:40 - we're not using the player in this
70:42 - custom hook yet but we are going to need
70:44 - our play in this one so we're going to
70:45 - modify this to use the player later so
70:48 - that's why we can send it in already now
70:50 - because we have the player here so we
70:52 - send that one in
70:54 - okay
70:56 - and then we can remove this one because
70:58 - we're not needing that functional we
70:59 - already have our stage in our variable
71:02 - called stage that we get from you stage
71:06 - so we use that one instead here
71:09 - and we can actually also use this game
71:13 - over variable here
71:15 - because when the game is over we're
71:17 - going to show a display that says it's
71:19 - over
71:20 - so somewhere in the side here
71:24 - we create curly braces we check our game
71:27 - over variable if that's one is true
71:30 - we're going to show a display component
71:33 - with a prop of game over we're sending
71:35 - that one into the display component
71:37 - because if you remember we're changing
71:39 - the color of the text to red if it's
71:41 - game over
71:44 - so we're just simply sending the game
71:46 - over variable and we have the text that
71:49 - equals the game over
71:51 - and we self-close the component there
71:55 - this is a ternary operator so if the
71:58 - game is not over
72:00 - we're simply going to display
72:04 - everything of this
72:09 - like so
72:12 - so if we have a game over we just
72:14 - display this one that says game over we
72:16 - don't display the score the rows and the
72:18 - level and if the game is not over we are
72:21 - displaying all of these
72:24 - so we save the file
72:26 - and it seems to be working we didn't
72:28 - break anything in the game and it's just
72:30 - complaining here because we're not using
72:32 - these values yet but that's fine
72:37 - in the next video we are going to create
72:39 - the player movement with the keys on the
72:40 - keyboard and we're going to do the stage
72:43 - update we're actually not seeing any
72:45 - tetra miner now but we will see it in
72:48 - the next video hopefully
72:51 - okay let's create the movement for the
72:53 - player and also the stage update so we
72:55 - can see the changes take place on our
72:58 - stage here
73:00 - first we're going to be working in the
73:01 - tetris.js file the tetris component and
73:05 - i'm actually going to take back some
73:07 - code we deleted in the last video we are
73:09 - going to use the create stage function
73:12 - in this one also
73:13 - so import it again
73:16 - sorry for that we import create stage
73:20 - from dot dot forward slash game help us
73:23 - we're going to need this one when we
73:25 - restart the game we need to create a
73:26 - clean stage for that one so we're going
73:29 - to need a few functions now because
73:31 - we're going to create the movement for
73:32 - the player
73:34 - so down below here somewhere below the
73:36 - console.log re-render
73:38 - we are going to need a function that's
73:40 - called move player
73:44 - and it's going to take in a direction as
73:46 - a parameter
73:50 - for now we just leave it empty then
73:52 - we're going to need a function that's
73:54 - called start gain
73:59 - we leave it empty for now
74:03 - we have another one that we call drop
74:07 - and we leave that one empty
74:10 - and we have another one that's called
74:11 - drop player
74:17 - yeah and that may seem odd now that we
74:19 - have two similar functions here but it
74:21 - will get clear to you when we have more
74:23 - code in this component and i'll explain
74:26 - why them
74:30 - and the last one for now is a function
74:33 - that's called move and we're going to
74:35 - destructure out the key code for this
74:37 - one
74:38 - this is going to be the callback
74:39 - function when we press the keys on the
74:41 - keyboard
74:43 - all right we're going to fill them with
74:45 - code in a second but first i'm going to
74:47 - explain this style tetris wrapper for
74:50 - you
74:51 - so we created this one with the width
74:53 - and height of the complete window here
74:55 - and that's because we need some way to
74:57 - take our key inputs and this one the
74:59 - rapid over here is going to be
75:01 - responsible for that
75:02 - so it's going to have a few props
75:05 - we need to set the role to button
75:08 - otherwise it won't respond to the key
75:10 - press
75:11 - and we need to have a tab index that
75:13 - equals to zero
75:15 - and we have an on key down
75:18 - and we're going to call our function
75:20 - that's called move for that one and send
75:23 - in the event
75:26 - so that's why we have this style tetris
75:28 - wrapper
75:29 - it's on kind of her you don't see the
75:31 - div here but it will cover the complete
75:33 - screen here and that's why when we for
75:35 - example click here it will register the
75:37 - key presses for us if we didn't have
75:40 - that one or for example just put the key
75:42 - press on this one you have to click on
75:44 - this to get the key presses to register
75:48 - let's go to our callback function that's
75:50 - called move
75:51 - that's the one we call here
75:54 - first of all we're going to check that
75:55 - the game isn't game over
75:58 - because then we don't want to register
75:59 - any key press
76:01 - so if parenthesis and not game over then
76:05 - we can do something here
76:07 - and then we check again if
76:09 - our keycode we destructure that one out
76:11 - from our event because on our event
76:15 - we have a property that's called keycode
76:17 - and if we destructure it here we don't
76:19 - have to type e dot key chord a little
76:22 - win here because that's not too long to
76:24 - write an e but yeah
76:26 - and we're checking if the key chord
76:28 - equals to 37 and that's the key chord
76:30 - for the left error on the keyboard then
76:34 - we're going to move the player we call
76:36 - our move player with the -1 because
76:39 - we're moving to the left that's why it's
76:41 - -1
76:44 - if our key code
76:46 - equals 39
76:49 - that's the right arrow on the keyboard
76:52 - we're going to move the player to the
76:53 - right and that's why we have a one here
76:56 - so left equals minus one because we're
76:59 - moving minus one on the x
77:01 - and 1 equals right because we're moving
77:04 - one step on the x-axis
77:06 - and then we have another else if
77:10 - if the key code equals to 40
77:13 - that's the down error on the keyboard
77:17 - we drop the player
77:18 - because we're pressing down so we want
77:20 - it to go down
77:22 - so that's our move function
77:26 - an in or drop player function for now
77:28 - we're just going to call the drop
77:31 - so we're just calling this one we're
77:32 - going to have another little special
77:34 - case inside of this later on so i'll
77:36 - explain that then
77:39 - then we have our drop function
77:41 - and we're going to create the function
77:42 - in or use player hook that's called
77:45 - update player pos and
77:47 - yeah it will do what it says it will
77:49 - update the player position
77:52 - update player pos
77:54 - and we're going to give it an object
77:56 - with the x value of 0
77:59 - and the y value of 1 because we're
78:01 - dropping now
78:03 - and i can see that i'm in the wrong
78:05 - function here
78:06 - so just copy and paste that one inside
78:09 - it should be in the drop function
78:11 - so as we're dropping here we're going to
78:13 - increase the y value of one and make the
78:16 - player tetra minor go down
78:20 - and we set the collider to false
78:23 - all right it will complain because we
78:24 - haven't created this function yet
78:26 - and in the start game function we can
78:29 - just make a little comment here reset
78:31 - everything
78:35 - and we set the stage
78:37 - to create stage
78:39 - we call our function to create a new
78:41 - stage and we reset the player and that's
78:44 - also a function that's going to be in
78:46 - the use player hook and the start game
78:49 - is a callback function also that we're
78:51 - going to have on our start button so we
78:54 - can set an on click handler
78:58 - and call the start game function
79:01 - so what we'll do when we press the start
79:03 - game button we will reset the stage and
79:05 - we will also reset the player
79:08 - and then we have our move player
79:10 - function
79:11 - and that one is going to take care of
79:13 - the left and right movement so we call
79:15 - the update player pros
79:18 - and we give it the x value of direction
79:22 - and the y value of zero
79:26 - because now we're just moving left and
79:28 - right and we're giving it a value here
79:30 - minus one
79:32 - or one
79:34 - all right we save that file and it will
79:36 - break now of course because we haven't
79:38 - created these ones yet
79:44 - so we have to create the update player
79:46 - pos function and the reset player
79:48 - function and we're going to place them
79:50 - in our use player custom hook
79:53 - and that means that when we call or use
79:55 - player function here we also want to get
79:59 - the update player pus and the reset
80:02 - player from that custom hook
80:05 - all right so let's move into our use
80:07 - player hook
80:09 - so make sure you're in the use player.js
80:12 - file
80:13 - and we're going to continue write some
80:15 - code here we're going to create these
80:16 - two functions here so we have our update
80:20 - player pos and it's going to be a
80:22 - function that takes in an object
80:24 - and we can destructure out x y and
80:27 - collided from that one
80:32 - we create an arrow function curly braces
80:34 - and inside of here we're going to set
80:36 - the state because now we're moving the
80:38 - player so we can set the player state
80:40 - here so we call set player that's the
80:43 - one up here and we do that with an
80:45 - update function if we do that we get the
80:48 - previous state here
80:51 - and we have to have a parenthesis here
80:54 - because we just can't give it the object
80:56 - because it will think that these curly
80:57 - braces are for the block and that's why
81:00 - we have the parentheses here we spread
81:02 - our previous state
81:04 - we set our pos
81:07 - to the new one
81:08 - we have an x property
81:12 - so we set that one to our prev.pos
81:16 - dot x
81:17 - plus equals x
81:19 - then we set a y value
81:22 - prev pos dot y
81:25 - and plus equals y
81:27 - so we're adding the values to our state
81:29 - here
81:30 - and then we set our collided property
81:34 - like so so that's the update player
81:36 - position we're just setting the state
81:38 - with the new x and y values here and our
81:41 - collided value
81:42 - all right then we need one for reset
81:44 - player so we create the const reset
81:47 - player and for this one we're actually
81:49 - going to need a hook that's called use
81:51 - callback and that's because otherwise
81:53 - our game loop will go into an infinity
81:56 - loop we won't see it now because we
81:59 - haven't created one yet in our new stage
82:01 - hook where we're going to use this
82:03 - function
82:04 - but trust me we need to have the use
82:06 - callback here otherwise we will be in a
82:09 - mess with an infinity loop
82:11 - so we use callback and give it an inline
82:14 - function here
82:15 - it is going to be dependent
82:18 - on nothing because we just create this
82:21 - once
82:22 - so we set the player
82:24 - and in this case we're resetting
82:26 - everything so we won't need to have this
82:28 - update the function here
82:30 - and give it the previous state we can
82:31 - just set the state from scratch so we
82:33 - have our position
82:35 - or pus
82:37 - our x property we set that to our
82:42 - stage width
82:44 - and we divide it by two i subtract two
82:47 - also to get it kind of in the middle
82:50 - because this one will position the tetra
82:52 - minor in the stage so this one will give
82:54 - it yeah kind of
82:56 - in the middle
82:58 - and we have our y property we set that
83:00 - one to zero because we want our tetra
83:02 - minor to be at the top when we reset the
83:05 - player
83:06 - and we have our tetra minor and we will
83:08 - give it a random tetra minor
83:11 - and grab the shape
83:13 - so each time we call this we will get
83:14 - the random tetra minor and this is the
83:16 - way that the tetra minors change
83:18 - randomly
83:20 - and we set collided to false
83:24 - like so we also have to import the use
83:27 - callback up here
83:30 - and use callback is a standard react
83:32 - hook and the last thing we have to do
83:35 - for now is also return or update player
83:38 - position
83:40 - or update player pause and or reset
83:42 - player
83:44 - and this should be it now
83:47 - so it's still working but nothing
83:49 - happens here because we're not drawing
83:51 - anything to the stage now
83:54 - and that's what we're going to be doing
83:56 - now so let's go into our use stage.js
83:59 - file or use stage custom hook
84:02 - and this one is going to be a little
84:05 - maybe complicated but i hope we will get
84:08 - through it
84:09 - and that's the thing with game making
84:11 - because as i said i'm not the game maker
84:13 - so yeah some stuff can be hard to
84:16 - understand when you're not a game maker
84:18 - but even if you don't understand
84:20 - everything that's game specific i hope
84:22 - you will learn some stuff in react
84:25 - okay so let's continue in this one we're
84:27 - going to take in our player and
84:30 - reset player as our parameters
84:33 - for this one so add these ones up here
84:36 - then we're going to use the hook that's
84:37 - called use effect
84:39 - and that's one is for creating side
84:42 - effects with react and it's yeah kind of
84:44 - a replacement for the life cycle methods
84:47 - in the class components i won't go into
84:49 - detail with every hook here so you have
84:51 - to look up that yourself if you don't
84:52 - know how use effect works and what it's
84:55 - for
84:56 - they have an excellent text on the react
84:59 - homepage where you can read about all
85:00 - the hooks
85:01 - all right
85:03 - so we create our use effect
85:08 - and that one is going to have an inline
85:10 - arrow function
85:12 - where we're going to create everything
85:14 - for our effect
85:16 - and this is the dependency array for now
85:18 - we can just leave it empty
85:21 - we create another function inside of
85:23 - here that's called update stage
85:26 - we're going to give it the prep stage
85:28 - the previous stage
85:31 - and below here we're going to set the
85:32 - state of the stage with this function so
85:35 - we have the stage state here and we set
85:38 - it with the set stage
85:41 - so set stage
85:44 - and then we have our update function so
85:46 - we grab the previous stage state
85:49 - it's easy to be confused here with stage
85:51 - and state it's almost the same saying
85:53 - that
85:55 - so we call our update stage
85:58 - in our previous state
86:00 - and you can also see that we're placing
86:02 - this function inside of the use effect
86:04 - and by doing this we don't have to
86:06 - specify it as a dependency here so we
86:08 - can have it inside of this effect
86:10 - all right and now we have to do some
86:12 - things here because when we update the
86:14 - stage we first
86:17 - have to flush the stage we have to kind
86:20 - of clear it from the previous render
86:23 - so we create the const with a new stage
86:27 - we take our previous stage of prep stage
86:30 - and we map through it
86:32 - so we get our row
86:34 - and we have an inline function here
86:37 - and we make another map on our row
86:39 - because this is a multi-dimensional
86:41 - array so we have to do two maps here it
86:44 - will probably be a little bit faster if
86:47 - we do this with just four loops but i
86:49 - think we will be fine here using map
86:52 - but if you care a lot about performance
86:54 - you shouldn't use map i think in a game
86:57 - like this you should use the for loop
86:58 - because that will be faster than the map
87:01 - all right so we have a row with map over
87:03 - a row and then we get our cell
87:08 - and we're going to return a new cell
87:10 - value and here we're going to make use
87:12 - of
87:13 - the one i talked about here where we
87:15 - create the stage
87:17 - where we set it to clear or merged
87:20 - so i'll show you that now
87:23 - we create the turner operator here we
87:25 - have a cell value we checked the value
87:28 - in our cell array
87:30 - and i will go back to this again to make
87:33 - it as clear as i can
87:35 - it's this value here we're grabbing
87:41 - so we simply check if that one is set to
87:43 - clear
87:47 - clear
87:50 - then we are going to return an empty
87:53 - cell
87:54 - so we return an array with a zero
87:58 - and clear
88:00 - otherwise we are just going to return
88:03 - the cell
88:04 - and this is what i've been talking about
88:06 - before
88:09 - because if we haven't marked a cell to
88:11 - merged then we just swipe it out we just
88:14 - clear it and we return a fresh clear
88:16 - cell here otherwise we return the cell
88:19 - as it is and it will stay in the stage
88:22 - so that's the way we know what cells
88:24 - have collided tetraminos in them or not
88:27 - so we have flush the stage here then
88:31 - draw the tetra minor
88:35 - so we flush the stage remove everything
88:37 - that shouldn't be there and then we draw
88:39 - the new stage for this render and we can
88:42 - do that by loop through our tetra minor
88:45 - and we have our tetra minor in our
88:47 - player
88:48 - if we check or use player we created the
88:50 - state here so we have
88:53 - the tetra minor here
88:54 - it's in the object for the player
88:57 - and in our tetris
89:00 - we are sending in the player to the use
89:02 - stage
89:03 - and we're getting it here so that's why
89:05 - we can access the player in our use
89:07 - stage custom hook so we have our player
89:11 - and the tetra minor property
89:14 - for each we're not going to return a new
89:16 - one here we're just going to simply loop
89:17 - through it we have a row and we have a y
89:21 - value
89:26 - curly braces
89:29 - then we're going to map through our row
89:32 - because this one is also
89:34 - multi-dimensional array so
89:36 - it's unfortunately a lot of loops here
89:39 - when doing this
89:41 - we have our value and our x value for
89:43 - that one
89:45 - and we have another inline function
89:48 - it may be a lot to grasp now when you're
89:50 - just typing it in like this so i suggest
89:52 - again you stop and just try to really
89:54 - understand what we're doing here because
89:56 - now we're looping through our tetra
89:58 - minor and now we're going to check which
90:00 - cells in the tetra minor that are
90:02 - occupied and that way we know the shape
90:04 - of the tetra minor
90:06 - we have our value here for a tetramino
90:09 - for a cell in the tetramino
90:12 - so we can check if the value
90:16 - isn't zero then we know that we're on a
90:18 - cell that makes up the shape of this
90:20 - tetra minor and then we also know how we
90:22 - can position the tetra minor on the
90:25 - stage
90:27 - we have our new stage up here that we
90:29 - flushed it's a fresh stage that we can
90:31 - use to draw our tetra minor so we have a
90:34 - new stage
90:38 - and yet again this is a
90:39 - multi-dimensional array so we have to
90:42 - set the y and x value for this one first
90:44 - we have our rows that's our y value
90:49 - so we have the y value
90:51 - plus player
90:52 - pos
90:54 - dot y
90:56 - then
90:57 - we have our x value plus
91:00 - player pos
91:02 - dot x
91:04 - this will give us the coordinates on the
91:06 - stage
91:09 - so we are going to set these ones to the
91:12 - value
91:15 - and the value here remember that it's
91:17 - the tetra minor that we're looping
91:19 - through so we get the value of the tetra
91:21 - minor
91:22 - and in this case it's going to be yeah
91:25 - one of these values here
91:27 - let's go back to our u stage so that's
91:30 - our value
91:33 - and then we're going to do backticks
91:35 - here
91:36 - two of them and inside we have a dollar
91:39 - sign curly braces
91:41 - because we're going to check with the
91:43 - turner operator if our player is
91:45 - collided
91:47 - then we set this one to merged
91:50 - otherwise we set it to clear
91:52 - and this is yet again how we know that
91:54 - we should clear this tetra minor in the
91:57 - next render if we set it to merge we
91:59 - know it has collided and this one when
92:01 - we flush the stage before we do this it
92:04 - will be set to merged and that way we
92:06 - know that we should keep it in the stage
92:08 - because it has collided otherwise it's
92:11 - set to clear and then we can just delete
92:13 - it in the next render before we do
92:15 - anything else
92:17 - all right this is beginning to be a long
92:20 - video sorry for that but we have to do
92:22 - this
92:23 - and inside our function here make sure
92:25 - you're in the right
92:27 - scope here
92:28 - inside of the update stage function
92:31 - we are returning the new stage for now
92:35 - because we're not checking any
92:36 - collisions yet we're going to return to
92:38 - this one
92:39 - and as you can see here when i order
92:41 - formatted this one it has filled in this
92:44 - itself
92:45 - these are the dependencies that we need
92:47 - for this use effect
92:49 - so we have the player.collided the
92:51 - player.post.x
92:52 - the player dot post dot y and player dot
92:55 - tetra minor we're using them inside of
92:58 - this use effect and that's why we have
93:00 - to specify them as dependencies here
93:02 - and we are going to use the reset player
93:05 - that we wrapped in our use callback
93:08 - later so that's why we have wrapped it
93:10 - because we're going to add it as a
93:12 - dependency to this one
93:14 - and it's this use effect that will go
93:16 - into an infinity loop if we don't wrap
93:18 - it in a used callback
93:20 - all right save this one
93:22 - and as you can see we have a tetra miner
93:24 - here now and that's great and if we
93:27 - reload this one we get a different tetra
93:29 - minor because we have randomized them
93:31 - and that's working great and is this
93:33 - working
93:34 - no okay let's check that out
93:42 - in our tetris
93:44 - all right i see here it shouldn't be on
93:46 - click
93:47 - it should be called back
93:49 - because if we look in our start button
93:52 - we have the prop here that's called
93:53 - callback so make sure
93:56 - you're in the tetris component and
93:57 - change this one to callback and i bet it
94:00 - will work now
94:04 - and it does
94:06 - and
94:08 - i think i saw a little bug there
94:11 - yeah
94:15 - it disappears and i think it is
94:20 - it's probably when we get the same tetra
94:23 - minor as before and i think that is if
94:25 - we go into the use stage custom hook
94:30 - we have these dependencies here so when
94:33 - we get the exact same tetramino it won't
94:35 - re-render because this one is dependent
94:38 - of the collider the position x the
94:40 - position y and the tetra minor so they
94:43 - are going to be the exact same in the
94:45 - next render if we get the same tetra
94:47 - minor and that's no good
94:49 - i think we can just change the
94:50 - dependency to player
94:53 - and save this one
94:58 - make sure you reload it
95:08 - it's working great now um
95:10 - i don't think this will give us any
95:12 - trouble in the future so i haven't seen
95:15 - this bug actually before i think i had
95:18 - gone through everything but yeah that's
95:20 - the thing with code you always get
95:22 - surprised i think it will be fine to
95:24 - have the player there otherwise we'll
95:26 - change it later and i also saw some
95:29 - little other stuff here we have to
95:31 - adjust because when you start the game
95:33 - you don't want this one to show up here
95:35 - before we have pushed the start button
95:38 - and that's why i created in this file
95:40 - tetra minus i created this zero here
95:43 - with just a blank little cell here and
95:46 - that's the one we're going to use for
95:47 - this now so if we go back into our
95:50 - use stage now into our use player
95:54 - you can see that we are just
95:56 - rendering a random tetra minor here and
95:59 - that's not good if we import our tetra
96:02 - minus also here
96:05 - then we can just grab the tetra minor
96:09 - and we grab the first one in the array
96:12 - tetro minor
96:15 - tetro minus
96:17 - and we save it and as you can see now
96:20 - the stage is blank here and that's good
96:22 - and if we push to start
96:24 - it will generate a random tetra miner
96:26 - for us to start with and of course also
96:29 - we have created the movement for this
96:31 - one so if you press left and right
96:34 - and the down button we can actually move
96:36 - the tetra miner now and as you can see
96:38 - we have not done any collision detection
96:40 - yet so it will screw up here but that's
96:43 - fine for now we will fix that later
96:50 - but at least the controls are working
96:52 - and that's also great so we have
96:54 - something here now
96:56 - we are getting somewhere and we will
96:58 - continue this one in the next video
97:03 - it's time to create some collision
97:05 - detection now for our game
97:07 - because now it isn't working here
97:09 - we can move outside the play field and
97:12 - it looks kind of screwed up here and
97:15 - that's not what we want
97:16 - so let's go back into our code
97:19 - and we're going to be working in the
97:22 - gamehelpers.js file for now that's where
97:24 - we're going to place the collision
97:26 - detection function it made sense for me
97:28 - to place it in that file but if you feel
97:31 - that you want to place it somewhere else
97:32 - you can do that of course
97:35 - but for this tutorial i'm going to
97:37 - create it here so make sure you're in
97:39 - the gamehelpers.js
97:40 - file
97:41 - and we have to think about a few things
97:43 - before we create this function one of
97:45 - them is that it's probably better to use
97:48 - for loops because it will be at least a
97:50 - little bit faster than to use for
97:52 - example map or for each because we are
97:55 - going to loop through our tetra minor
97:57 - here again and we're going to have two
97:58 - loops for this one also so if we use for
98:02 - example for each
98:03 - we can't break out of that one and
98:05 - that's the downside for us because we
98:07 - want to break out of the loop as soon as
98:10 - we collide with anything so feel free if
98:13 - you want to experiment with this and try
98:15 - different ways of doing it i'm going to
98:17 - use for loops so we can start by
98:19 - creating our function now we need to
98:21 - export this one because we're using it
98:23 - in the components
98:24 - so we need to have an export
98:26 - const and we call it check collision
98:31 - we give it a player
98:33 - the stage
98:35 - and we give it an object
98:38 - where we can destructure out the move x
98:40 - and
98:42 - the move
98:43 - y
98:44 - so what i'm doing here is that i rename
98:46 - the x and y to move x and to move y and
98:49 - that's because i'm going to use y and x
98:52 - in my loops so i want to have a
98:54 - different name for these parameters here
98:56 - and it's an arrow function and we have
98:58 - curly braces
99:00 - so we're going to loop through our tetra
99:02 - minor in this one
99:03 - so we have a for loop
99:05 - let y
99:07 - equal zero and y should be less than
99:10 - player dot tetra minor
99:12 - dot length
99:14 - and then we just have the y plus equals
99:17 - one for each iteration
99:20 - and then inside of here we have another
99:22 - loop
99:24 - let x
99:25 - equals zero and x should be less than
99:28 - player dot tetra minor and we can grab
99:31 - the y value
99:33 - dot length
99:35 - and then we have the x plus equals one
99:39 - so we add one to this one for each
99:42 - iteration also and we could of course
99:46 - just say zero here because it doesn't
99:48 - matter which row we are checking the
99:50 - length so of course the rows are the
99:52 - same length all right
99:54 - so what do we have to do here now first
99:56 - of all
99:57 - this is the tetra minor we're looping
99:59 - through and we first have to check that
100:01 - we're actually on a tetra minor cell and
100:03 - the zero don't make up the shape of the
100:06 - actual tetra so we have to check that
100:09 - the cell isn't zero
100:11 - so we can make some comments here
100:13 - one
100:14 - check that we're on an actual
100:17 - tetra minor cell like so and then we
100:21 - create an if statement and we check if
100:23 - player.tetromino
100:25 - and now we're grabbing a y value
100:28 - and our x value from our loops
100:31 - and it shouldn't equal zero
100:35 - all right so that way we know that we're
100:37 - actually on a cell that make up the
100:39 - shape for the tetra minor and we should
100:41 - check that cell if it collide with
100:43 - anything
100:44 - so what collisions do we have to check
100:46 - we make a little comment here again we
100:48 - need to check that our movement is
100:50 - inside of the game area's
100:52 - height that we're not moving the
100:54 - tetramino outside of the bottom of the
100:56 - stage so we can just make a comment
100:59 - check that our
101:01 - move
101:02 - is inside the game
101:05 - area's height
101:07 - and we can just set y in parenthesis
101:11 - and maybe also
101:14 - we
101:14 - shouldn't go through
101:18 - the bottom of the play area
101:21 - all right
101:23 - and we can actually specify the other
101:25 - things we're going to check before we
101:26 - create them
101:27 - so down below here create number three
101:30 - then we need to check that our tetra
101:32 - minor isn't moving outside of the game
101:34 - areas with
101:38 - check that or move
101:42 - is inside the game areas with
101:47 - and that's an x and then below here we
101:49 - have the fourth thing we're going to
101:51 - check and that is we're going to check
101:53 - that the cell isn't set to clear because
101:55 - this function will return true or false
101:58 - if it returned true we have obviously
102:00 - collided with something otherwise it's
102:02 - false and we haven't collided with
102:04 - something
102:05 - so if the cell is set to clear then we
102:08 - know that we're not colliding with
102:10 - anything and it will return
102:12 - false check that the cell
102:16 - we're moving to isn't
102:19 - set to clear
102:20 - because if it is clear we're not
102:22 - colliding
102:23 - all right so that's our things we have
102:25 - to check here we're going to do this
102:26 - with a chained short circuit whoa that
102:29 - was hard for me to say as i'm not
102:32 - natively speaking english and you
102:34 - probably can hear that also but you have
102:36 - to live with it
102:38 - so if not stage
102:40 - and we grab the y value plus player dot
102:44 - pos dot y
102:46 - plus or move y
102:48 - we're looking into the future here you
102:50 - can almost say like that because we're
102:52 - checking here if the position that we
102:53 - intend to move to is colliding so here
102:56 - we're simply checking that our status y
102:58 - value actually has a value in it if it
103:01 - doesn't have that we know that we're
103:03 - outside the bottom of the stage and this
103:05 - will also return true because we're
103:07 - setting this to not with this
103:09 - exclamation mark
103:10 - so if it not find anything here in this
103:13 - stage row it will return true and we
103:15 - know that we are colliding with
103:17 - something
103:18 - and as i said we do a short circuit here
103:20 - so we do an or
103:23 - i actually don't know what these signs
103:25 - are called in english it's the sign for
103:28 - or in a short circuit
103:30 - okay then we need to check that our move
103:32 - is inside the game errors width so we
103:34 - have the exclamation mark we're checking
103:36 - that not stage
103:39 - y plus player dot pos dot y plus move y
103:45 - and then we need to check the actual
103:47 - cell here so we check the x
103:50 - plus player dot pos dot x plus move x
103:55 - and yeah it is complaining here because
103:57 - we
103:58 - of course need an if statement here also
104:00 - so wrap this in an if statement
104:05 - and return true
104:07 - and we go back to this one
104:10 - we create another or
104:13 - and we're going to do our fourth check
104:14 - here okay the fourth one we're going to
104:17 - check i misspelled this check
104:21 - we are going to check if this cell is
104:23 - not set to clear and we can do that
104:26 - by typing stage and then we do the same
104:29 - thing here y plus player dot pos
104:33 - y plus move y
104:35 - and then we have the cell
104:37 - so we have x plus player
104:41 - pos
104:41 - dot x
104:43 - plus move x
104:45 - and then it's the second one in this
104:47 - array that we have to check so we type
104:49 - in a one here and we check that it isn't
104:52 - clear
104:57 - like so and this one should of course be
105:00 - a capital y
105:04 - so there you have it
105:06 - that's everything we need for our kind
105:08 - of simple collision detection i actually
105:10 - almost copy and paste this code from the
105:12 - mathmath method tutorial because i think
105:15 - this is a very simple and clever way to
105:18 - check the collision because with this
105:20 - collision detection we can detect if
105:22 - we're outside the stage and also if we
105:24 - collide with any of the tetra miners
105:26 - because we're looping through the tetra
105:28 - minor that we have in play and check if
105:31 - any of the cells inside of that tetra
105:32 - minor collide with any of the cells in
105:35 - the play field and that's how this
105:37 - function can check for everything that
105:38 - we want if we go outside the stage and
105:41 - also if we collide with another tetra
105:43 - miner that's merged to the stage
105:47 - so we save it and we see that we didn't
105:49 - break anything and we didn't do that and
105:52 - that's good
105:53 - we have to go inside or use stage hook
105:56 - and add a little collision detection
105:57 - here
105:58 - because when we have the new stage here
106:01 - with the new updated position
106:04 - we then
106:05 - check
106:07 - check if we collided
106:10 - like so so we can do a little if
106:12 - statement here if player got collided
106:16 - then we just reset the player
106:19 - like so
106:21 - and it will need a new dependency here
106:23 - so we can add reset player
106:26 - because if we collide we just reset the
106:28 - player we move the player up
106:31 - to the zero y position and the other one
106:33 - will stay in place where we collided
106:36 - because we merged it into the stage here
106:39 - the last thing we have to do here now is
106:41 - to go into our tetris component
106:43 - and actually use our
106:45 - check collision function
106:47 - first we have to import it from the game
106:49 - helpers
106:50 - so we have our check collision imported
106:53 - there
106:55 - and we have to check the collision when
106:57 - we move the player and when the player
106:59 - drops so inside our move player
107:02 - we create an if statement
107:04 - and if we don't collide
107:07 - we send in the player the stage
107:11 - and the intended position we want to
107:13 - move to
107:15 - so we have an x value of direction
107:18 - and we have the y set to zero because
107:20 - this move player function is responsible
107:22 - for moving the player left and right so
107:26 - yeah i probably should have named it
107:29 - something else yeah i realized that so
107:32 - you can change it to a more descriptive
107:34 - name if you want to do that then we can
107:37 - move this one inside of the if statement
107:39 - and this means that if we're not
107:41 - colliding with with anything we actually
107:44 - do the move otherwise we don't do
107:46 - anything here
107:48 - so we save it
107:50 - and we can see if it works we shouldn't
107:53 - be able to go outside the play field to
107:55 - the left and to the right
107:57 - and we can't and that's great
107:59 - so it will stop the tetra minor there
108:02 - because we are colliding with the sides
108:04 - of the stage
108:06 - then we have to check for collision when
108:08 - we drop the player
108:11 - so inside of the drop function we do
108:14 - almost the same here we check if not
108:16 - check collision
108:19 - we give it the player
108:20 - the stage and the intended move
108:24 - so we have the x value in this case it's
108:26 - zero and it's the y value that we're
108:28 - going to give a one because we're moving
108:30 - one step down each at a time
108:36 - and we can move this one up here
108:38 - inside of the if statement
108:40 - in this case we're going to have an else
108:42 - also
108:44 - in this case as we're dropping we know
108:46 - that if we collide on something when we
108:49 - drop we also need to set the collided
108:51 - property to true in the player and
108:53 - that's because if we collide with
108:55 - something when we drop we know that this
108:57 - tetra miner should be merged to the
108:59 - stage because it can't drop anymore so
109:01 - we we need to yeah merge it into the
109:04 - stage
109:05 - so we update player pos
109:08 - we give it an x value of zero and a y
109:11 - value of zero we're not moving anymore
109:13 - we're just setting the collided to true
109:17 - we can also inside of this else block
109:20 - create
109:21 - something when the game is over because
109:25 - if we're colliding and the player dot
109:27 - pos dot y
109:29 - is less than one we know that we're
109:32 - colliding up here somewhere and the game
109:34 - should be set to game over
109:38 - so we can console
109:40 - log game over
109:44 - and then we're going to set game over
109:47 - to true
109:49 - and set drop time
109:52 - to null because we're not dropping
109:54 - anymore so we set at a null
109:56 - and also up here in the start game
109:58 - function we can set
110:01 - game over
110:02 - to false because we're starting a new
110:04 - game here so it shouldn't be set to true
110:07 - all right we save it and see what we've
110:09 - got we're checking here and it's still
110:12 - working with the collision on the sides
110:13 - and if we go down here it should merge
110:16 - into that position in the stage and it
110:18 - does so that's great
110:22 - and we can see if it will go into game
110:24 - over mode here when we're colliding at
110:27 - the top
110:28 - and it does also and that's really
110:31 - really sweet but now we have a kind of a
110:35 - half working game it's not dropping
110:37 - because we haven't created the interval
110:39 - and we can't rotate the player so that's
110:42 - what we're going to do in the next
110:44 - videos
110:46 - in this video we're going to create a
110:48 - rotation for the player and we're mostly
110:51 - going to be in the use player custom
110:53 - hooked so make sure you're in the use
110:55 - player custom hook
110:57 - we're going to create two new functions
110:59 - in this one
111:00 - so just below our state here we can
111:02 - create one that's called rotate
111:05 - this one is going to receive a matrix
111:09 - and a direction
111:12 - so the matrix is actually going to be
111:14 - our tetra minor so you can name it that
111:15 - also if you want
111:18 - and of course we're going to have an
111:19 - equal sign and
111:21 - an arrow here
111:23 - then we're going to have another
111:24 - function that's called player rotate
111:27 - and we could actually do them in one
111:29 - function but i wanted to separate them
111:31 - out because the rotate here actually do
111:33 - the rotation and the player rotate are
111:35 - going to do some other things also
111:37 - because we need to check the collision
111:38 - here when we rotate the tetra minor
111:41 - that's why i separate them into two
111:43 - functions
111:44 - so we have the const play rotate equals
111:47 - it is going to take in the stage and
111:49 - direction
111:51 - and we create an arrow function and as i
111:53 - said before you can of course create
111:55 - regular functions if you want it's just
111:57 - me that yeah i like to create arrow
111:59 - functions instead but if it makes more
112:01 - sense for you to create a regular
112:03 - function you can do that also it doesn't
112:05 - matter here okay so first we create a
112:07 - rotate function and that's the one
112:09 - that's going to take in the tetra minor
112:11 - and the direction and we want to rotate
112:14 - the tetra minor and how can we rotate
112:16 - the tetra minor yeah first of all we can
112:19 - make all the rows to become columns
112:21 - instead so we kind of shift them in the
112:24 - array
112:25 - and that way all the rows are going to
112:27 - be columns instead and then if we
112:29 - reverse all of the values in the rows we
112:32 - get the rotation so that is how this is
112:34 - going to work so first
112:37 - make the rows
112:38 - to become
112:41 - calls
112:42 - now we can call it this transpose
112:46 - okay we create the new const we can call
112:49 - it
112:50 - rotate the
112:52 - tetra
112:53 - all right so we take our matrix
112:57 - we map through that one
113:01 - we're not going to use the actual value
113:03 - in this loop but we need the index
113:06 - then we map through the matrix again
113:11 - and we have the column
113:14 - and we return the call and the index
113:19 - and this one will make all the rows in
113:22 - the array to become columns
113:24 - so that's the first step in rotating
113:28 - then we need to reverse
113:33 - each row to get a rotated matrix
113:39 - or a tetra minor in this case
113:42 - and this one we have to separate into
113:44 - two things because it depends on which
113:46 - direction we are moving how we do this
113:49 - if we move with the direction of a value
113:51 - that's bigger than zero we know that
113:53 - we're moving kind of clockwise then we
113:56 - need to reverse all of the rows to get
113:59 - the rotation right otherwise if we move
114:01 - in the other direction if it's for
114:03 - example minus one it's less than zero
114:06 - then we just reverse the complete matrix
114:09 - or in this case the rotated tetra as we
114:11 - call it
114:12 - i know that this can seem a little bit
114:14 - too much and i think
114:16 - this is one of the thing again with game
114:18 - making you do this stuff all the time
114:20 - when you rotate things i actually had to
114:22 - think about this twice or three or four
114:24 - times before i got it myself and he
114:27 - explained it quite good in the math math
114:29 - methods video on how he rotate things i
114:32 - don't do it exactly the same here in
114:34 - this function but the principle is the
114:36 - same
114:37 - we have transposed our array or matrix
114:40 - or tetra minor and
114:43 - we have converted all our rows into
114:45 - columns and we save them in the rotated
114:48 - tetra then we can check if the direction
114:52 - is bigger than zero we return
114:55 - or rotate the tetro that we're going to
114:58 - map
114:59 - and we have the row
115:02 - and all of the rows are going to be
115:04 - reversed for this one
115:06 - so we use the reverse function on this
115:08 - row and that's a built-in function in
115:10 - javascript
115:12 - otherwise we're moving in the other
115:14 - direction so we can just return
115:17 - the rotated tetro
115:20 - dot reverse
115:24 - okay now we can create our player rotate
115:27 - where we're also going to do some
115:28 - collision detection when we rotate the
115:31 - player and i'm going to show you why in
115:34 - a second but first as always we don't
115:37 - want to mutate or state or anything so
115:40 - we create a copy of our player we can
115:43 - call it clone
115:44 - player we cannot do a shallow copy here
115:47 - so we need to make kind of a deep clone
115:50 - and you can do that with json
115:52 - dot parse
115:55 - and json
115:56 - dot stringify
115:59 - player so now we get a complete copy a
116:02 - complete clone of our player and that's
116:04 - good we don't have to work with the
116:06 - player that's in the state because we
116:08 - shouldn't mutate the state then we take
116:10 - our clone player
116:14 - and grab the tetromino from that one
116:19 - and we use our rotate function
116:24 - and we rotate the clone player dot
116:26 - tetramino
116:30 - and we give it the direction also
116:34 - and this will rotate the player and we
116:37 - can set the player
116:39 - to the cloned player
116:45 - we also need to export our functions
116:48 - here
116:49 - or actually it's just a player rotate we
116:51 - need to export
116:55 - we will get back to this in a second but
116:57 - first we have to actually create the
116:59 - rotation in the tetris component
117:02 - first of all we need to add the player
117:04 - rotate here so we get it inside our
117:08 - tetris component
117:10 - from the use player we're also returning
117:12 - this one
117:14 - then below here in our move function
117:17 - where we check the key code on what key
117:20 - is pressed and call a function we also
117:22 - need to add another else if here
117:26 - so if the key code equals to 38 that's
117:29 - the up error on the keyboard
117:33 - we call player rotate
117:37 - give it the stage
117:39 - and the one because we are going to need
117:41 - a stage when we do the collision
117:42 - detection in a minute
117:44 - and this is the direction we're sending
117:46 - in so we're rotating it clockwise and
117:49 - this means that we have a function now
117:51 - that we can rotate counterclockwise also
117:53 - so if you want you can add another key
117:55 - here that will rotate the tetraminer in
117:58 - the opposite direction that's very easy
117:59 - to implement if you want to do that i
118:02 - kind of play tetris with just rotating
118:04 - it with one key so i choose to not
118:07 - implement two keys for rotating in
118:09 - different directions here
118:11 - all right let's see if this works
118:15 - and it does that's nice
118:17 - but if we go to the side here you can
118:19 - see if we rotate it it will rotate
118:22 - outside of the stage and that's no good
118:26 - and it will break it as you see here
118:33 - but it's rotating nicely
118:38 - we're going to fix this thing now so it
118:41 - can't rotate outside of the stage
118:43 - so go back into our code and inside or
118:46 - use player custom hook
118:49 - and inside the
118:51 - player rotate function we're going to
118:53 - continue write some code here
118:55 - that will solve this problem for us
118:59 - and this one i actually grabbed it
119:01 - directly from the mathmath method
119:03 - tutorial because i think it's very
119:04 - clever how he does this so this code is
119:07 - straight from that one first we want to
119:09 - save our position in a const so we have
119:12 - const pos equals cloned player
119:15 - dot pos dot x
119:18 - so that's the x position we save here
119:20 - then we're going to create a new let
119:22 - that we call offset and that equals one
119:27 - then we're going to have a while loop so
119:30 - we have while and inside a while we
119:32 - check collision
119:35 - we send in the clone player the stage
119:39 - and we're not moving it anywhere so we
119:41 - just give it zero values in this object
119:43 - here with the x and y
119:47 - we already imported this check collision
119:49 - up here so we don't have to do that
119:50 - again
119:52 - and now we're going to write some tricky
119:54 - code here actually um and i'll try to
119:56 - explain it for you if we go back into
119:58 - our game i'll try to show you here so
120:01 - let's just place a few of the tetra
120:03 - minus here and i try to explain it
120:06 - if we rotate this one here
120:12 - as you can see it will move inside of
120:14 - these tetra minus
120:16 - and that's no good
120:17 - and this little function we're going to
120:19 - right now is going to take
120:22 - wait i'm going to create another one
120:24 - here
120:24 - it's going to take the tetra minor when
120:26 - we rotate it and move it
120:28 - right and left and right and left and
120:31 - check if we collide with something and
120:34 - that's the clever little function that
120:36 - he came up with in that tutorial let's
120:38 - say we go right it will check are we
120:40 - colliding
120:42 - no then we go left are we colliding
120:44 - there no and then it will continue until
120:47 - we collide or if we don't collide we can
120:49 - actually rotate the player
120:52 - so that is how this is going to work in
120:54 - this while loop
120:56 - so we have our clone player we set the
120:58 - position dot x plus equals the offset
121:02 - and this is how we keep track on how
121:04 - many steps we're moving to the side back
121:07 - and forth
121:08 - so we set the offset
121:10 - it equals to minus
121:12 - parenthesis offset
121:15 - plus
121:16 - the offset
121:18 - if it's greater than 0
121:20 - we set it to one otherwise we set it to
121:23 - minus one
121:24 - and it's this little row here that will
121:26 - create the kind of back and forth
121:29 - movement for us with the tetra minor
121:31 - then we can create an if statement and
121:33 - we check if the offset
121:35 - is greater than clone player dot tetra
121:38 - minor
121:40 - and we grab the first value in the array
121:43 - and length here we're just grabbing the
121:45 - first row and check the length of that
121:47 - one we don't need to do any more shakier
121:50 - because we have looped through the
121:51 - complete length of the tetra minor
121:55 - then we just rotate the tetra minor back
121:57 - because this move isn't a load we can't
121:59 - rotate it if we have try this back and
122:02 - forth more than the width of the tetra
122:04 - minor then we know that we can't rotate
122:06 - so we just rotate it back because we
122:09 - already rotated it up here so we just
122:11 - rotate it back
122:13 - rotate
122:14 - lone player
122:16 - dot tetramino
122:18 - and minus direction we reverse the
122:20 - direction so we rotate it back
122:24 - and we set the clone player
122:27 - dot pos dot x
122:28 - to equals position and that's the one we
122:31 - saved up here because we wanted to have
122:33 - the same position as we had from the
122:35 - beginning and then we just return
122:38 - so
122:39 - this is yeah quite a handful of a
122:42 - function i don't blame you if you don't
122:44 - get it especially this one it can seem a
122:47 - little bit tricky it took some thinking
122:49 - for me to understand this
122:51 - just think of it
122:52 - as this one we'll go back and forth and
122:54 - see if it collide with something when we
122:56 - rotate
122:58 - and if we do we can't rotate it that way
123:01 - and it will constantly move it away from
123:04 - that one when we rotate
123:06 - so we can save it and see if it works
123:15 - we can try this out
123:17 - if we rotate it now
123:19 - you can see that it kind of pops out
123:21 - from the wall
123:25 - it won't go through it and also if we
123:33 - do some rotating here
123:36 - you can't rotate through them and that's
123:39 - good
123:47 - so i actually think that this is the
123:49 - most advanced function in this tutorial
123:51 - because this is quite advanced don't
123:54 - blame yourself if you don't get it the
123:55 - first time just try out yourself try to
123:58 - change the code try to look at it read
124:00 - it try and change it again and you will
124:03 - soon get it how it works if you don't
124:05 - get it right away and if you get it
124:07 - right away well good for you and see you
124:10 - in the next video
124:13 - okay we have a kind of a functioning
124:16 - tetris game here just a few things left
124:18 - to do if we take a look here we see that
124:21 - we have some full rows here and they
124:23 - should be swept off the stage and it
124:25 - should give us some score at the end
124:28 - but it won't do that now because yeah
124:31 - we can just fill this up and nothing
124:33 - will happen in this video we will create
124:35 - the function that will kind of sweep the
124:38 - stage and see if there's any rows that
124:40 - needs to be cleared and also push down
124:42 - the other ones that shouldn't be cleared
124:44 - so that said go into our code again and
124:47 - into our use stage custom hook
124:50 - inside of this custom hook we're first
124:52 - going to create another state
124:55 - so we create a state here that's called
124:58 - rows cleared
125:01 - and set rows cleared
125:06 - and this is how we're going to keep
125:07 - track of all the rows that we have
125:09 - cleared so we use state
125:13 - and give it an initial value of zero
125:17 - okay
125:18 - and the first thing we want to do in
125:20 - this use effect is to set rows cleared
125:24 - to zero
125:26 - and then we're going to create another
125:28 - function here
125:29 - that's called sweep rows
125:33 - we're going to give it a new stage
125:36 - to sweep
125:39 - and it's going to be an implicit return
125:41 - for this one so we don't have to have
125:43 - curly braces
125:44 - we grab our new stage and we're going to
125:46 - do some reducing here so reduce
125:50 - this is the built-in reduce es6 function
125:54 - we have the accumulator
125:56 - and the row
125:59 - arrow function
126:00 - called braces
126:02 - so we give this function a stage and
126:04 - we're going to map through it with
126:06 - reduce so we we do that with new stage
126:09 - dot reduce
126:10 - and we get the row and the accumulator
126:13 - if you don't know how reduce works i
126:15 - suggest you look it up
126:17 - and the first thing we have to do now is
126:19 - to check if our row just contains cells
126:23 - that are merged and that means that we
126:25 - can check if a row don't contain zeros
126:29 - and we can do that with find index so if
126:33 - row
126:34 - find index
126:37 - we have our cell
126:39 - and an inline function we check if the
126:41 - first value in our cell array equals to
126:44 - zero
126:45 - and if this one equals to minus one
126:49 - we know that we haven't found a value of
126:51 - zero and then we know that this is a
126:53 - full row and should be cleared because
126:55 - find index will return -1 if it don't
126:59 - find a match with the provided function
127:01 - inside of it
127:02 - if we're looking for the value 0 and it
127:05 - won't find that one then it will return
127:07 - -1 and then we know that this row should
127:10 - be swept away from the stage
127:13 - so we first set rows cleared
127:15 - and we do that with an update the
127:17 - function because we're going to need the
127:18 - previous value
127:20 - and we just add one to that one
127:23 - then we're going to grab the accumulator
127:26 - that's the new array we're building up
127:28 - inside of this reduce function
127:31 - we're going to unshift
127:34 - and unshift let us add a new value to
127:36 - the array at the beginning of the array
127:39 - because if we look here if we for
127:41 - example remove these three rows here
127:44 - we need to add three rows at the top and
127:46 - we can do that with the unshift method
127:49 - so we remove these three ones here and
127:51 - if we add three empty ones up here it
127:54 - will push down the other ones and it
127:56 - will kind of create the illusion that
127:57 - these ones just
127:59 - pop out of the stage
128:01 - and disappear
128:03 - so with the unshift we can add
128:05 - a complete empty row at the beginning of
128:08 - the array so we create a new array
128:12 - from our new stage
128:14 - 0
128:15 - dot length that will give us the width
128:18 - of the actual play field
128:20 - and we fill it up with
128:23 - an array of zeros and clear because
128:25 - these ones are completely fresh
128:28 - so they should be zero and clear
128:31 - then for each iteration inside of the
128:34 - reduce we have to return the accumulator
128:36 - also
128:37 - and this is if we find a matching row
128:40 - that should be cleared if we don't do
128:42 - that we just push the row
128:45 - into the accumulated array
128:48 - and we return the accumulator again like
128:51 - this and
128:52 - we could also give it an empty array to
128:54 - start with
128:56 - so this is the complete function here i
128:59 - will go through it again and tell you
129:00 - what it will do
129:02 - we give this function our stage
129:04 - and we take the complete stage and use
129:07 - the reduce method on this one by using
129:10 - reduce we can create a new array so we
129:13 - check if the row contains any zero if it
129:16 - does we know that this row shouldn't be
129:18 - clear because we haven't filled up a
129:21 - complete row but if we have filled up a
129:24 - complete row we first add a row to our
129:26 - rows cleared state
129:28 - then we add an empty a complete empty
129:31 - new row at the top of the array and we
129:33 - return the accumulated array this works
129:36 - because we completely ignored to return
129:38 - the full row that we should remove from
129:41 - the stage and instead we return a new
129:43 - empty row at the top of the array so
129:46 - this will create the illusion that we
129:48 - remove the row on the stage and move the
129:50 - other ones down that was above that row
129:54 - and if we don't have a full row we just
129:56 - return the row as it is in the array and
129:59 - that's the way it works
130:01 - we have to use this function somewhere
130:03 - and we can do it if we know that we
130:05 - collide with something we should do this
130:07 - sweep and see if we also have a full row
130:11 - so below the reset player and because
130:13 - this one returns a complete new stage
130:16 - we also need to return
130:19 - the function and give it the new stage
130:23 - so this one will take or stage we create
130:25 - here
130:26 - when we have done all the mapping with
130:28 - the tetra miner and everything and if it
130:30 - collides then we call the sweep rows
130:33 - with this stage and this one in turn
130:36 - will return another stage for us when it
130:38 - has swept all the rows and check that
130:40 - there's no full row that needs to be
130:42 - removed from the stage
130:44 - okay
130:46 - so we'll see if it works
130:48 - i have to do some gaming here to get a
130:51 - full row
130:54 - and that's nice to be able to play some
130:56 - game here
130:58 - let's see if it works
131:01 - and it does nice
131:03 - it's kind of easy now when it's not
131:05 - dropping
131:08 - yeah and we know that it works now so i
131:10 - don't have to create another row here
131:12 - and we actually forgot to do something
131:14 - here and go back into our code and into
131:16 - our use stage custom hook
131:18 - we also need to return our rows clear
131:21 - because we're going to use this one in
131:24 - the tetris component later on
131:27 - so make sure you add that one to the
131:28 - return statement here all right so
131:30 - that's it we'll continue by creating the
131:32 - interval for the tetra miners to drop by
131:35 - themselves in the next
131:36 - video
131:38 - we are going to set this game in motion
131:41 - and i think it's better we take a look
131:43 - at dan abramov's site first overreacted
131:46 - dot io and then
131:48 - he has a blog post that's called making
131:51 - selling develop declarative with react
131:53 - hooks and it's 16 minutes read so i
131:55 - won't go through it here but i suggest
131:57 - you read this one because here he
131:59 - explained why it isn't a good idea to
132:01 - just use set in the val with react hooks
132:04 - so he has created this custom hook
132:06 - that's called use inval that we are
132:08 - going to use and hopefully you copied
132:10 - this file over to your project folder as
132:12 - i showed you in the beginning of this
132:14 - tutorial
132:15 - here's all the answers to why setting
132:17 - the well is not good to use as it is
132:19 - with ragged hooks it's better to create
132:21 - a custom hook and use that one instead
132:25 - and one thing why it's not so great is
132:27 - because react hooks are heavily using
132:29 - closures and closures can be
132:32 - quite difficult to grasp if you're not
132:35 - that used to them he has created this
132:37 - use in the world for us that we can just
132:40 - use in our game and that's what we're
132:42 - going to do now
132:44 - so back to our app and our code
132:47 - inside of our tetris component we're
132:49 - going to be in that component in this
132:51 - video at the beginning here where we
132:53 - import our custom hooks we can import
132:56 - our use in a val
132:59 - from
133:00 - dot dot forward slash hooks
133:05 - and use innerval
133:07 - and that makes sure that we can use this
133:09 - one inside of our component
133:12 - okay and now we're going to make this
133:14 - one move by itself because now we can
133:16 - just drop it by pressing the down key on
133:18 - our keyboard and that's no good we want
133:20 - it to move by itself
133:22 - so we can set up this interval
133:25 - and below i think yeah
133:28 - here
133:28 - somewhere we can use our interval so use
133:32 - interval
133:34 - and this one will take an inline
133:36 - function
133:38 - so we create an arrow function
133:41 - and we are going to call the drop
133:42 - function as we created up here because
133:45 - that's the one that makes the tetra
133:47 - minus drop
133:51 - so we call that one
133:53 - and we can specify
133:55 - the interval timing here and we already
133:58 - have a state that's called drop time
134:01 - so we just send this one in to the use
134:03 - in a well because if we look at the use
134:06 - interval
134:07 - it will take a callback and a delay and
134:09 - the callback is the inline function we
134:11 - created and the delay is our drop time
134:14 - so that's how this works and also if we
134:17 - send null into the drop time it will
134:19 - stop and clear the interval so that's
134:21 - good for us because that way we can
134:23 - control the interval
134:25 - all right back to the tetris component
134:28 - we have to do a few more things here to
134:29 - get it up and running because now our
134:32 - drop time is set to null
134:35 - we set it up here
134:38 - so now the interval is not active
134:40 - but we have a start button
134:43 - so when we start our game
134:45 - we can set our drop time
134:49 - and we send in thousand that means one
134:51 - second
134:54 - and we save it
134:55 - and then if we press start game
134:58 - as you can see it's moving
135:01 - really good here now and that's nice
135:03 - because now we have a working tetris
135:05 - game
135:14 - great
135:18 - i want to do a few optimizations here
135:20 - also we created one extra function here
135:25 - that's called
135:27 - drop player
135:29 - and inside now we're just calling drop
135:31 - and that's when we press the down key on
135:33 - our keyboard
135:35 - i want to stop the interval when the
135:37 - player moves the tetra minor down with
135:39 - the keyboard
135:41 - and that's easy we can just set the drop
135:43 - time to null
135:45 - and that will make sure that we stop the
135:48 - interval but we also have to activate it
135:50 - again when the player releases the down
135:52 - key
135:54 - so we're going to create a new function
135:56 - here
135:57 - that's called key up
136:00 - and inside of this we're going to take
136:02 - in the key code again so we destructure
136:05 - that out from our event
136:09 - and yet again we're going to check if
136:11 - the game
136:12 - is not game over
136:15 - and we can activate the interval again
136:17 - when the player release the down key
136:20 - so inside of here we check if the key
136:23 - code equals to 40 that is the down key
136:27 - we will only run this if the player is
136:29 - releasing the donkey then we set the
136:31 - drop time
136:34 - for now we just set it to thousand again
136:36 - we are going to create different speeds
136:38 - here later in the next video
136:41 - so that's our callback function for our
136:43 - key up event
136:44 - and we also have to make sure that we
136:47 - have this event here
136:50 - and we can create it on our style tetris
136:53 - wrapper
136:54 - so we just add
136:56 - on key up
136:59 - and it equals key
137:02 - up
137:05 - and a little nice formatting here
137:08 - and we save this one
137:12 - and we can actually do a little console
137:15 - login here
137:17 - because here we can console log
137:21 - interval off
137:23 - and we copy this one
137:25 - and go to our key up
137:29 - console
137:31 - interval on
137:35 - make sure you're showing your console
137:37 - here
137:40 - whoops i misspell this one
137:43 - yeah my formatting here has added this
137:45 - one for us yeah that's nice so i can
137:48 - remove this one it should only be use in
137:50 - the valve here
137:54 - okay so we start the game
137:58 - and i press the down button you can see
138:00 - that interval off
138:03 - and then interval on when we release the
138:05 - button and that's great because then it
138:08 - will not interfere with the keyboard
138:11 - when we hold the key down it will
138:14 - repeat itself and
138:16 - make the tetra minor go down faster
138:20 - and that could mess things up for us if
138:22 - the interval also is activated then
138:26 - so that's actually all there is to it to
138:28 - create this movement this kind of game
138:31 - loop that makes the tetra minor drop by
138:33 - itself in the next video i'm going to
138:35 - conclude this tutorial and we create
138:37 - some nice little displays here with
138:40 - score and rows and level and we're going
138:42 - to do that by create our last custom
138:44 - hook
138:47 - we're almost finished now we're just
138:49 - going to create a custom hook for
138:51 - displaying scores rows and levels and we
138:54 - are eventually going to import it here
138:56 - in the tetris component with the other
138:58 - hooks here
138:59 - but we will create it first so we have
139:02 - something to import here so inside our
139:04 - hooks folder create a new file that's
139:07 - called use game status
139:10 - dot js and we're going to need a few
139:12 - things here so we import use state
139:16 - use effect
139:18 - and use callback
139:21 - from react
139:25 - then we export const
139:27 - use game status
139:30 - and we're going to need one parameter
139:32 - here that's called rows cleared
139:35 - that's the one we created in our use
139:38 - stage we're going to send this one in to
139:40 - use game status because we need it when
139:42 - we calculate our score and set the total
139:45 - rows that we cleared because this one
139:47 - here is just the rows that we cleared in
139:49 - the current render that's why we set it
139:52 - to zero here so we clear it on each
139:54 - render and then we're going to send this
139:56 - one in to the use game status where we
139:58 - can add it up to the rows we already
140:00 - have cleared before
140:02 - all right we have an arrow function and
140:04 - curly braces and then we're going to
140:06 - create three states here so we have a
140:09 - const with the structure outscore set
140:12 - score
140:13 - equals u state
140:16 - and we have a zero
140:18 - we can just copy this one
140:21 - paste it two times and we're going to
140:23 - call this one
140:25 - rows and set rows
140:28 - and we're going to initialize all of
140:30 - these with a zero
140:33 - then we have our level
140:37 - and our set level
140:41 - so there you have it three states then
140:44 - we're going to need a const
140:46 - that's called line points
140:49 - and this is going to be an array
140:52 - with forty hundred
140:55 - three hundred
140:56 - and
140:57 - hundred and these are the actual scores
140:59 - i
141:00 - did some googling and found this course
141:03 - from the original tetris game so we're
141:05 - going to use these to calculate our
141:07 - total score
141:08 - i don't know there's probably a lot of
141:10 - different versions so i don't know if
141:12 - this is legit that it's truly the
141:14 - original scores that were used and also
141:17 - the formula for calculating the score
141:20 - but i found this one i think it was on
141:22 - wikipedia actually
141:24 - so you can have what scoring you want
141:26 - here
141:27 - if you want to change it so we have a
141:29 - const that's called calc score
141:32 - and this is a function we're creating
141:34 - here because we're going to call this
141:36 - function in a use effect and we're also
141:38 - going to need to use callback because
141:39 - otherwise this will go into an infinity
141:42 - loop and that's no good
141:45 - and i think that's also
141:46 - not a problem but i think it can be
141:48 - annoying because it's easy with react
141:50 - hooks to make them go into an infinity
141:53 - loop if you don't think about that very
141:55 - very thoroughly okay so first we're
141:58 - going to check if we have score
142:01 - if
142:03 - rows cleared
142:05 - is greater than
142:07 - zero that means if we cleared any rows
142:09 - in the render that's the one we send in
142:11 - here because if it's zero we didn't
142:13 - clear any row so we don't have any score
142:16 - calculations to do
142:18 - and that means that if this one is
142:20 - greater than zero we know that we
142:22 - cleared some rows and we're going to
142:24 - calculate the score and if it's uh zero
142:27 - yeah we know that we didn't clear any
142:28 - rows in this render and we don't need to
142:30 - calculate any score
142:32 - we are going to calculate a score and
142:34 - set our total rows so i create a comment
142:37 - here this is how original
142:41 - tetris score
142:43 - is calculated
142:45 - so this is the formula i use i found
142:47 - that one on the internet and i'm using
142:49 - that here to calculate the score
142:52 - so we just set our score state
142:54 - set score
142:56 - we have a previous state
142:58 - and we use that previous state to add
143:00 - something to it and here's the formula
143:03 - we have the line points
143:05 - that's the array up here and these line
143:07 - points array have four different values
143:10 - here and they each represent one row
143:12 - cleared two rows cleared three rows
143:15 - cleared and four rows cleared
143:17 - and this is an array so the index starts
143:19 - at zero so we have to take our rows
143:22 - clear
143:24 - minus one because say for example that
143:26 - we cleared two rows we need to grab the
143:29 - value with index one in our array
143:32 - and we're going to multiply that with
143:34 - our level
143:36 - plus one and that's also because our
143:38 - level starts at zero so that's why we're
143:41 - adding one here
143:43 - so this is the formula to calculate our
143:45 - score
143:46 - and then we also need to set our rows we
143:49 - have our previous state here and we take
143:51 - the previous state and add the new rows
143:53 - cleared to that one
143:56 - and that will always keep track of our
143:59 - total rows that we cleared
144:01 - all right
144:03 - and as this is a used callback we have
144:05 - to make it depend on something
144:08 - so we have the dependency array here
144:11 - we have the level the line points
144:14 - and the rows cleared
144:17 - so this one is always going to change
144:20 - when the level line points or rows
144:21 - cleared are changing otherwise it will
144:23 - stay the same and that's why it won't go
144:26 - into an infinity loop because if we
144:28 - didn't have this use callback it will
144:30 - change every render and that will create
144:32 - the infinity loop
144:36 - okay
144:37 - and then we create the use effect we
144:39 - want this to fire off automatically
144:47 - and this dependency array is going to
144:50 - depend on the calculate score
144:52 - the rows cleared
144:56 - and the score
144:58 - we're just calling the score here
145:02 - and as we're using these ones in this
145:04 - function we have to specify them as
145:06 - dependencies here but then we have to
145:08 - return something from this custom hook
145:11 - so there's a lot of things we're going
145:12 - to return here we want the score we want
145:14 - a set score because we want to reset the
145:17 - score when we start a new game we need a
145:20 - rows and we also need a set rows we want
145:22 - to set the rows to zero when we start a
145:24 - new game and also the same with the
145:27 - level so we want the level and the set
145:29 - level
145:31 - like so
145:33 - so we save this one
145:36 - and go back into our tetris component
145:40 - we import it
145:41 - where we import our other custom hooks
145:44 - use
145:45 - game status
145:47 - from dot dot forward slash hooks use
145:51 - game status
145:54 - all right
145:55 - then we have to use these values inside
145:57 - of our tetris component
145:59 - but first we have to call or use game
146:01 - status hook
146:02 - we can do that below here
146:05 - so we have a const
146:08 - and we are going to receive everything
146:11 - that we returned from this one
146:14 - all of these here
146:16 - we're going to receive here so we have
146:18 - to specify them we have the score
146:21 - set score
146:22 - rows
146:24 - set rows
146:26 - level and set level
146:29 - and we're going to call our use game
146:32 - status
146:35 - and we're sending in the rows cleared
146:38 - as we talked about before
146:41 - and of course we also have to grab the
146:43 - rows cleared here
146:47 - from our new stage hook
146:49 - see if i can
146:51 - make it a little bigger here
146:54 - i think we actually can move this one
146:56 - down here to make it a little nicer
146:58 - looking
147:00 - like so okay and now we have to use
147:03 - these values inside of our tetris
147:05 - component
147:06 - first in our drop function we want to
147:08 - change the level depending on how many
147:11 - rows we have cleared and that means we
147:13 - have to have something here that
147:14 - calculates that on every drop
147:17 - so i make a little comment here
147:20 - increase level when player
147:23 - has cleared
147:24 - 10 rows
147:27 - i think that that also is the original
147:29 - tetris but i'm not sure when you clear
147:31 - 10 rows then we go up a level and the
147:34 - speed will increase
147:35 - we create a little if statement here we
147:38 - check if the rows are greater than
147:42 - level plus one that's because the level
147:45 - starts at zero just as before
147:48 - times ten
147:52 - we set the level with our previous state
147:56 - and we just have the previous plus one
147:59 - we're just increasing the level by one
148:03 - and we also
148:05 - want to increase the speed
148:08 - and this little formula i created here i
148:10 - don't know if it's optimal actually i'm
148:13 - going to set the drop time
148:16 - like so and then i have thousand that's
148:18 - one second i divide it
148:21 - with the level plus one
148:23 - and then i just added 200 here so it
148:26 - will not get too fast
148:28 - and you can actually play with this and
148:30 - try another formula and see if it works
148:32 - better for you so i don't know if it's
148:34 - good i think yeah it's working fairly
148:36 - nice but yeah
148:38 - probably there will be a better formula
148:40 - for this to use
148:42 - so that's how we calculate our level
148:46 - we can actually also set a few things
148:48 - here when we start the game
148:50 - because we also want to reset our score
148:52 - level and rows so we can set our score
148:55 - to zero
148:58 - set rows to zero
149:00 - and we set our level to zero and then
149:02 - there's one more thing we have to do
149:04 - here
149:06 - we are going to take this formula here
149:08 - and copy that in the drop function where
149:12 - we set the drop time we have to also
149:14 - paste that in our key up function
149:17 - because now we're just setting it to a
149:18 - thousand here so just paste it in there
149:26 - and we want to display our score rows
149:28 - and levels also so we can change these
149:30 - ones inside of the props we're sending
149:32 - in to the display components so we
149:35 - create curly braces double ticks
149:38 - and we have our score
149:40 - and a dollar sign and curly braces
149:43 - and we grab our score
149:45 - then we do the same with the rows and
149:47 - the levels we can copy this one
149:53 - paste it in and then we change this once
149:56 - we have our rows
150:02 - and we have our level
150:07 - so this will make sure that we display
150:09 - the score rows and level
150:11 - and i think it's time to save this one
150:13 - and see if it works
150:16 - so it's already displaying the series
150:18 - here so we can start the game
150:44 - and it seems to be working nice
150:47 - so that's it we have a working tetris
150:50 - game i just want to make a little
150:52 - optimization here and i'm going to show
150:55 - you why
150:56 - because if we go inside our cell
150:59 - component
151:00 - and for now i have to do like this
151:02 - because i want to console something out
151:10 - re-render
151:14 - so what i'm doing here i'm just going to
151:15 - console.log out re-render on each cell
151:18 - here so i save this one
151:21 - and as you can see we have 240 rewinders
151:23 - here and that's fine when we build this
151:26 - table for the first time but as you can
151:28 - see on each little drop here now on each
151:32 - rotation and everything we get 240
151:34 - renders it probably won't be an issue
151:37 - here because react is fast
151:39 - but i want to show you here how you can
151:41 - create a little optimization for this
151:43 - one so we go back inside our cell
151:46 - component and where we export this one
151:48 - we're going to export it with react dot
151:51 - memo
151:53 - and this will make sure that it
151:55 - memorizes this cell component and only
151:58 - re-renders when the cells actually are
152:00 - changing so we save this one
152:05 - and as you can see we're just
152:07 - re-rendering the cells that actually
152:08 - change with the tetra miner now
152:12 - and i actually think that this is a
152:14 - really good example to show you what
152:16 - react memo does in react because now it
152:19 - won't affect the cells that won't change
152:22 - on that render it will only re-render
152:24 - the cells that change with the tetromino
152:28 - and that's good so we made quite an
152:30 - optimization here and reduced the
152:32 - rewrites here and that's good
152:35 - there you have it this is my this is my
152:37 - version of tetris with react hooks and
152:40 - as i said a couple of times now i'm not
152:42 - a game developer but it was sure fun to
152:45 - create this game
152:47 - and i think it's a good practice in
152:49 - react and especially react hooks to see
152:51 - how they work
152:53 - and i hope you enjoyed this one as much
152:55 - as i did and i'm very grateful that you
152:58 - have followed me on this tutorial and i
153:00 - hope you learn a lot
153:02 - i initially created this one exclusively
153:04 - for free code cam and i actually record
153:07 - a lot of free stuff especially in react
153:09 - and front-end and stuff like that in my
153:11 - own youtube channel so if you go to
153:14 - youtube
153:15 - and just search for webinfo w-e-i-b
153:22 - you will see my pretty face here and you
153:25 - can just go to my channel and make sure
153:27 - you subscribe if you want free coding
153:30 - tips in react and other front-end stuff
153:33 - and i also create paid premium courses
153:36 - i'm going to move them to my own
153:37 - platform soon but for now they're up on
153:39 - udemy and it's a beginner react course
153:42 - and also a course in gatsby and how to
153:44 - create get beside with wordpress as a
153:46 - headless cms there's also a free course
153:49 - on
153:50 - react redux and there's of course the
153:52 - hooks introduction course that were
153:54 - published on free code camp a little
153:56 - while ago
153:58 - and i'm also on twitter just hook me up
154:00 - there if you have any questions or just
154:02 - want to follow me there and i sure
154:05 - appreciate the support i can get from
154:07 - you i want to continue to create free
154:09 - stuff and do things like this so
154:11 - hopefully you'll see me again in another
154:13 - video but for now thank you and goodbye

Cleaned transcript:

welcome to this tutorial we're going to build a tetris game with react and the first question you should ask yourself is is react a good choice for making a game like this and to be honest i don't know it is probably better to build it with vanilla javascript but i wanted to do this for myself to test how this game can work out with react and sometimes i do this kind of projects just to yeah kind of expand my knowledge and try things out and the idea for this started when i was looking at the tutorial at youtube where this guy creates a tetris game with vanilla javascript and it's in this channel that's called methmeth method and yeah you can think whatever you want of that name the tutorial is really good actually and i learned a lot because i have to say this i'm not a game maker i create web applications and stuff like that and web pages so i'm kind of a rookie in the game development so it was fun to create this game with react and see how it works and in this video he used canvas i'm not going to use canvas i'm using regular divs and a grid for this one because i wanted to try it out also and not use canvas and it's also good to see how good react performs because there's going to be a lot of divs that we rendered to the screen because each cell in the tetris game is a div and i'm also going to borrow some of the code here and especially the one where we're going to check for collision when we rotate our tetra minor that is the name of the blocks in tetris big credits to this channel mathmath method and the video where this guy shows how to create a tetris game in just i think it's 50 minutes or so yeah and it's a really good tutorial if you want to learn how to build a tetris in plain javascript all right let's get to the app then and here's the tetris game that we're going to build i choose to have kind of a retro style to it with this stars in the background this is just an image i found on unsplash and we're going to show the score at the rows and the level and then we have a start button so if we press start game we can play the game and we're using the arrow keys on the keyboard for this one you rotate the tetra minor with the up arrow and you kind of go left and right with other arrows and down will make it go faster down there and there will be some limitation in this game and because this is not a perfect tetris game for example the key input we're just using the regular repeat here when holding down the down arrow key there should probably be a better function for this where we can control the speed of this one and also i will be using an interval for this one we could also use uh request animation frame where we can create kind of a more controlled animation so it will not be a perfect tetris game but it will be a good practice in react and especially react hooks that so many people are talking about now on the internet so we will be creating custom hooks and we will use state we will use use effect and use callback and also we're going to use react memo for minimizing or rerun this of the cells so i think this will be a good practice in react and especially react hooks so let's get to it we will start creating the game in the next video we're going to start to build our tetris game now and we're going to use create react app and i actually use that one a lot because it's great for bootstrapping your project and you don't have to set up your webpack and babel config and everything like that from scratch so i highly recommend you use create react app it's great and we create a project by go into our console in my case i'm using hyper and we just type npx create dash react dash app and we can call our application react dash tetris this will create the folder that's called reacttetris and then press enter and then we just wait it will take a second here all right we're good to go here and it's important now that you navigate into the new project folder you created so type cd react tetris and if we list the files you can see it has created some folders and files for us here and now i'm using style components for this game so we have to install that one also and we do that by typing npmi style dash components all right some arrows here but i think we'll be fine it's just on my computer i can clear the console i have also included some files in the starter files that you have to copy to your project folder otherwise it won't work so make sure first of all that you download the starter files it's on github and the link should be provided to you and then in the starter files you have something that's called bd.png that's the background image that the stars you see here then we have the font that's called pixel if i found this one on the internet it should be free to use so i hope it is and we have something that's called use indival dot js and that's a custom hook that's created by dan abramov that i'm going to use when we create the game loop with the javascript interval so we just have to copy this one over and i'll explain it later in the tutorial first grab the bd.png file copy that one and go into your project folder and inside the src the source folder we create a new folder that's called imd and that's for image of course and you can just paste the background in there all right then we have the font so grab that one copy that one and create another folder inside of your src your source folder and we can call this folder font go inside over there and paste the font inside of it and then we have the use interval.js file so copy that one and still in the src folder create another folder that's called hooks this is the folder where we're going to create our custom hooks so go inside of that folder and paste the use interval.js file and this should be it this is everything we need to get us started so in the next video we'll start to scaffold out some components and we'll continue with our application the first thing i do when i create the react application is that i scaffold out all the components that i need and that's what we're going to be doing in this video so first of all you can see that we have a lot of files here that was created for us with create react app and we're not going to use some of this stuff here you can yeah you can delete it if you want the logo the service worker the app test and stuff like that or you can just let it be because we're not using it now we are going to use the app.js file here and the index.js file for now and the index.js file we don't actually have to touch that one we can just go inside the app.js file we can delete everything inside of there so as usual our application is going to start in the app.js file this is kind of the highest component in the hierarchy so we import react from react we import tetris from dot forward slash components forward slash tetris like so and of course this one we haven't created this one yet so we're going to create that in a minute and we create our app function i like to use arrow functions for this one you can use a regular function if you want to do that but we have const app equals parenthesis and we're going to create an explicit return for this one so we just need parentheses then we can create a div with a class name of app and we have our tetris components like so and then we export default app and that's our app component then we can create a new folder inside of src folder that's called components inside the components folder we are going to create five different components so we can just create the file names now so we create one that's called cell.js make sure you have a capital letter here to start with or yeah maybe you don't name your components like that but i like to name them with capital letter because it's a component so we create another file that's called display.js and we have a new file that called stage.js and we have a new file that's called start button.js and the last one is going to be the tetris dot js file all right these are our five components the tetris.js file is kind of the heart of this application we can go into our cell.js file and start scaffold out this component so we import react from react as usual and we create the component const cell equals to parenthesis and we are going to have props for this one so we can create these ones also either structure them out we're going to have a type for this one and we talk about this later on we make an implicit return for now and we can just have a div and write cell inside of it and we export default cell like so we save that one and then we have our display.js file we import react from react we have a const that's called display equals and for this one we're going to have two props so we destructure them out one is called game over and one is called text and we create a div inside of here where we're going to have the text we create curly braces and text to grab that prop and display it inside of the div export default display we will style these components later with style components so we will change some stuff inside of them we just scaffold them out now so we know what components we're going to have for this game save that one then we go into our stage.js file we import react from react of course you can copy and paste a lot here also if you want to do that for this one we're going to import the cell component so we import cell from dot forward slash cell and then we create the const stage equals to i mean the structure of the prop that we're going to have that's called stage and we make an implicit return for this one also and as you can see i'm not doing any prop type checking for this course you can add that in yourself if you want to do that to verify your props with prop types all right we create a div for now again and inside here we're going to map through our stage prop and create cells from this stage prop and we're going to do that later also so it can just have a cell for now inside of this and we export default stage like so and we save this one then we have our start button.js file so we import react from react and we have a const start button and we have a prop that's going to be a callback for this one and we make an implicit return with a div that says start game and we export default start button like so we save that one and then it's the last one it's our tetris component or heart of this application so we import react from react like so and then we're going to have some components here we import our stage from dot forward slash stage also going to need our display from dot forward slash display and we import our start button from dot forward slash start button and these ones we can check them out here this is obviously going to be the stage with the cells in it and these are the display components we have three of them and this is the start game button here so these are the ones we've created now then we create our const tetris and equals to an arrow function and we have curly braces for this one because we're going to have more logic inside of here and we can create the return statement here first we have a kind of a repetitive here and as i said we're going to rename these ones when we style the components then we have our stage and for now we're not sending in any prop because we don't have anything to send in to it right now then we can create a side element that's obviously the sidebar here that we're creating and then we're going to have three different displays and for these ones we have a text prop and for now they can just say score we can copy this one and paste two times and this one can say rows and level all right we can also wrap these ones inside of a div and end it like that and below we're going to have our start button and it's going to get a callback prop but we don't have that yet either so we're not giving it that now so this is it and we export default tetris like so okay then we can store this up to see what we've got so mpm start and we have all our components showing up here and that's great they are of course not styled yet but we're going to do that soon first we have to create the stage and or tetra minus and we're going to do that in the next video before we do the styling so we can see the ui here okay we're going to create the stage and the tetra minus in this video and to do that we have to create a couple of new files inside our source folder or src folder we can create a new file that's called gamehelpers.js and that's a lowercase g on that one because this is not a component and we can also create a new file that's called tetrominos.js make sure you're inside the gamehelpers.js file here we're going to create a stage and we are going to have two const where we can set the stage width and height and we have to import these ones into our components so we have to export them from this file so we export const and then with capital letters we can have stage width and we can set that 1 to 12 and we export const stage height and we set that to 20. so that's our width and height but we actually need a function that creates the stage for us and the stage is going to be a nested array a multidimensional array that represents rows and columns and we have to export this function that creates the stage also because we're going to need it in our component so we export const create stage and it is an error function all right so how is this going to work well we're going to create a multidimensional array that represents the grid so we create an array from something and that something is another array that we're going to create from the stage height and this is going to be an empty array so it's not going to be useful for us so we have to do something we have to fill this up with something we can do that by supplying an inline function here and that means for each row we create a new array from the stage width and we're going to fill it with another array there's a lot of arrays here and for now we set it to zero and we have something that's called clear and these ones i'm going to explain that later on 0 equals nothing on the grid we have the different tetra minus each of them going to have a letter here so we know that the grid has that tetramino in that particular cell and we also have this clear property here that is going to be set to merged when we have a tetra minor merge into the stage that means when we have collided so the tetramino should stay in the stage and not be cleared in the next render and as i said i will explain this later on so i hope you understand this function what it's doing we're creating a new array from an array that we're creating here with a state height that's the 20 rows we're going to have in our grid and we're supplying an inline function that for each row create a new array with our cells and we're filling them up with this array here that has one value that is zero and that's represent a clean cell there's nothing in that cell on the stage and we also have this string here that says clear for now and that means that there's no tetraminer that has collided in this cell and we should wipe it out from the stage in the next render okay so that's how we create our stage and if you remember up here in the components we had our stage here and we had our prop that's called stage and this is the stage we're sending in from the tetris component so we can actually import this one here in the tetris.js file we can import our create stage function here and we grab it from dot dot forward slash game helpers like so and for now we can just send it in to this one we have the stage prop equals curly braces create stage and parenthesis because we we invoke this function here just check in so we're not breaking anything here no and we're going to change this later on because we're going to have the stage in a custom hook and a state for this one but for now we can just send it in so it renders something inside of stage component we can remove this one and inside the div here we create the curly braces because we're going to use javascript now and map over our stage prop so we have a row and we also map through that row and then we get a cell and our x value for that one so what are we doing here well we have the stage that's the one we created we map through that and when we map through that stage array we get the row and each row is also an array that holds the cells so we map through that row also and we get the cell so for each cell we are going to render out the cell component we can set the key to x and our type are going to be the first value in the salary and that's the one we created down here we're telling it when we initially do the render we're telling it that this stage is clean we don't have any tetra minor in the stage so we're grabbing this value here and that's a zero that we set it to initially go back into your state component we have to close this one also this one should hopefully render out the stage for us but as you can see we didn't style it yet so it's just a lot of cells here in one column but we're going to fix that when we do the styling later on all right let's get back to our code that's our stage now we have to create our tetra miners and we're going to keep them in a const that's called tetra minus and it's going to be an object so we export const capital letter tetra minus equals an object and we're going to have different properties for these ones first we can create a property that's called syrup because i'm going to use this initially when we start up the application we don't want to show a tetra miner on the stage but you could do it some other way of course but i think it's nice to have it inside of this tetra miners object alright so we create an object we're going to have a property that's called shape and the shape is also going to be an array with a race i noticed that there's a lot of arrays with arrays when you create games like this so we have an array then we have another array and we just set it to zero and then we have another property that's called color and this is just going to be a string zero comma zero comma zero like that so that's our clean cell that's what we're using when we're not showing any tetra minor and then we have seven different tetra miners we have the i j l o s t and said so we can start by creating the i so we create a new property that's called i and we create a new object for that one we have the shape property that's going to be an array and inside of that array we're going to have another array and as i mentioned before a zero equals nothing on the grid and we're going to use a letter where we want to show this tetra minus first we have a zero that's nothing then we have a string with a capital i then we have a zero and a zero then we create another array with another zero and another i and a zero and a zero and this one is just going to be a four by four so we can copy this once and paste them in like that and as you can see this is going to be the eye shape that is the long one the long tetra minor that's the only one that has four in width and we can make it a little cleaner here maybe i will not auto format this because it will destroy this formatting i've done here it's easier to see the tetra minor here otherwise it will format it in just one line for me and that's no good so we have another property here also so we have the color and this is yet again a string and this is just an rgb value i'm going to use in the css later on so i'm setting the call of this one to 80 227 230 so this is the i we have here and i guess we can just copy and paste this one make sure you make a comma here and we create a j and the shape for the j is going to be we can remove these last ones because it's going to be three by three so we remove the last row there also change this once to j j j and we're going to have a j there also i hope you see this oops it's going to be a string i hope you see this pattern here that this is a j and the color for this one is going to be 36 95 223 all right then we copy this one and paste we're going to create the l shape and it's exactly like the j but we change this one and put it there instead and of course we should have an l also as a value in these strings and the color is going to be 2 2 3 1 7 3 and 36 all right we copy this one make sure you don't forget the comma there and we're going to create the o shape and this is actually just going to be two values in so we have the o and o like so and oh so we have a two by two array there and the color for this one is going to be two two three two one seven yeah and also 36 for that one all right then we can grab the l up here copy it make another comma paste it we have the s shape and it's going to be a zero an s don't forget that this is a string here so don't forget the ticks here and then we have an s and an s and a zero and these ones are just going to be zeros like so and the color is 48 211 and 56 all right then we paste in yet another one and we have two to go we have the t and that shape is going to be zero zero zero then we have a t a t and a t and now we have a zero a t and a zero a nice little shaped t there and the color is 132 61 and 198 and then we have the last one and that's the said whoa kind of boring this but we have to do it otherwise we don't have any tetra minus all right this said we have a said a set and a zero then we have a zero a set and a set and then zero zero and zero and then we just have the color for this one and that's two to seven seventy eight and 78 all right so that's our tetra minus and we have one more thing to do because we want to have a function that generates a random tetra miner for us so we export const random petromino and we create the function for that one we have curly braces here so first we create the const called tetraminos lowercase letters and we create the string with capital letters i j l o s t said and this is of course the string with all our seven tetra minors then we create another const rand tetro minor like so we're going to grab a random letter from this tetra minor string and we do that by typing tetro minus that's the string const and inside of here we do a little math dot floor math dot random times tetra minus length like so and this is just a standard for generating random numbers of the length of this in this case the string so we have the string length and we're getting a random number for this one and i misspelled this one it should be tetra minus yeah so we have the tetra minor string and we're grabbing a random number for that one and that will return one of the letters for us and that's how we get the random tetra minor because now we can return from our tetro minus rand tetra minor so for example let's say that this will give us an l here so we have that one and we go to our tetra minus object and we have an l here and that will of course grab the l property for us and return this one here the l tetra minor with the shape and the color this is an object here so we get that object back and that's how we get a random tetra minor i type the zero here it should of course be an o there and save this one all right this was a lot i know i know and i think that's why i don't do games but i i recommend it to really go through this code and try to understand it as much as possible before moving forward in the next video we're going to create the styles with style component and after that we actually going to start to do some heavy coding on the game we're going to do some styling now to get this sad look out of this tetris game and if you're not a css person you don't like to style things you can just copy and paste the styles from the starter files into your project but you have to import them into your component as i'm going to show in this video and also change your divs to the components that we're using from the styles component i'm going to show you this soon so let's get on with it first of all we're going to create the global styling and actually i've been kind of lazy for this one because you can create global styles with style components but i'm actually just going to use this index dot css file that's yeah premade for us with create direct app and it's imported in the index file and that's because we're going to have a font and it's a little bit more troublesome to import it with style components so if we go inside the index.css file first we're going to set our body we're going to set our margin to zero and then we are going to import a font so we have a font face and the font family is going to be called pixel and we have a source src with our url and we grab our font from font forward slash pixel dash lcd7 dot buff we can also set the format to vof like so and we save that one yeah and we will not see anything happening here right now but that's our global styling then we can move up to our components and we're going to style the tetris component first and what i like to do when i use style component is that i create this folder that where i place all of my styling and then i import them into the components so inside of the components folder create another folder that called styles and inside the styles folder create a new file and call it styled cell.js i also like to name them like this with styled and then the component name and dot js so styled cell dot js capital s capital c and first we have to import style from style components and then we need to export our style component because we're going to import it into the tetris component when we created this one so we export const style cell and equals style dot and this is going to be a div we have backticks because this is a tagged function and this is how style components works you have this tag function and you can write regular css inside of it and if you don't know style components i really recommend you to read more about it at their webpage i'm not going to go through everything with star components in this tutorial because as i said before this tutorial is about showing you how to build a tetris game with react and i assume that you know some stuff with react and yeah style components also otherwise it's not that difficult to use style components so i think you will pick up a lot just watching me create these components all right and i just realized i created a styled cell now okay i said tetris component but it's the styled cell i created now so well let's create the styles for the cell component first then okay we're going to have a width and set that to auto then we're going to set our background and that's going to be an rgba and we're going to grab this from the props that we send into the cell component so for now i just type this out and we go to the cell component and i'm going to show you how this prop work so we have a dollar sign curly braces and props and an arrow function and a props we have one that's called color so that's how we get our rgb value and we set the alpha value to 0.7 this is just regular css so we're going to come back to this in a second but first we save this one and we go into the cell component and i'm going to show you how this works with the props so first of all we import our styled cell that's the one we created and we grab it from styles forward slash style cell like so then we also going to need our tetra minus so we import our tetra minus if you remember that's the one we created down here it's an object with different tetra minus so we grab that from dot dot forward slash tetra minus all right so now we got everything we want in this component we can now first change this one to our styled cell that's the one we create here and we import it in this component here so we use it here you could write the style component inside of this component and many people do it like that but i like to have them separated because i think this is yeah i like this structure of things so you can do whatever you want and then you don't have to do all this export and import stuff that i do here okay so this style cell is going to have a type prop and we grab the type from type we are sending that in here and now we're passing that prop into our style component and then we're going to have a color and the color we can grab from the tetra minus and the type is going to be the tetra minor so we if we for example have the type of l it will grab the tetra minus l for the color and of course we're also going to grab the property color because when we created the tetra minus we have both the shape property and the color properties so this is the one we're grabbing here is the color property from the tetra minus all right so for now we can just we change this one to yeah we can say on l because we're not sending in anything to this component yet because as i said i intended to do the tetris first but now we do the cell here instead and as you can see now we're getting the color here but it will color everything here and that's because this cell row you see it's the com it take up the complete width here so the color is there but we haven't created the grid yet and that's because it's showing all yellow now because each cell is a hundred percent with right now all right let's go back to the styling we need some shadows on our tetra minus so this is also how it works with props that you send into your style components you can grab them with an inline function like this because this is a tagged function you can use a dollar sign and curly brackets and use expressions inside of these ones and by using this inline function we can grab the props that we send into our style components and we had one prop that is called color so we're grabbing that one inside of here all right so that's our background we also want to set our border yet again we have a dollar sign and curly braces we have our props and then we're going to do a ternary operator here we check if our props type if that one equals to zero that means we not have a tetramino in this specific cell so we don't want to have a border so we set that one to null pixels solid i don't actually yeah i don't think we need solid here but yeah let it be there for now otherwise we set it to 4 pixels solid all right then we have our border bottom color and that is going to be on rgba and yet again we have a dollar sign curly braces we have our props and we have our props dot color and we're going to set the alpha value here to 0 to 0.1 we can actually just grab this one and copy and paste it in three times because now we have border right color and that one we're going to set to one and then we have border top color and we set that one to one also and bore the left color and we set that one to 0.3 and this will give us kind of the shadow effect on the blocks yeah if you don't like them you can just play around with this and set your own shadow and this is also what i like about style components because you can send in props like this we can easily modify your css conditionally with props and that's really nice actually so what i'm doing here i'm just using the same color value as we set in the tetra minus object but i'm just changing the alpha value to get different opacity on the blocks all right let's go to our tetris.js file now and do it in the right order here we are going to create two different style components here we have one that style tetris wrapper and one that's called style tetris so we have a wrapper around here and we have the tetris also we can actually just type them out here so we can see the structure of it here is going to be a styled tetris wrapper like so and we close it down below there and it will complain of course we haven't created this one yet and then below we're going to have the styled tetris component and of course we have to move that down here like so and i will explain later why we have this wrapper here so these are the two style components so let's create a new file inside of the styles folder that's called styledtetris.js and inside that file inside styletetris.js import style from style components like so we also need to import our background image so we can call it bd image and we grab that from dot dot forward slash dot dot forward slash imd pj dot png like so then we export const or styled tetris wrapper and that one is going to be a style.div and we have our backticks because this is a tag function we set our width to 100 viewport width and our height 200 viewport height yeah this is just regular css now and i'm not going to explain the css here either i hope you know your css otherwise you can pick up some things here but i won't explain them yeah in detail and here we can set our background with the url and now we can just use our bj image and we do that by creating a dollar sign and curly braces and inside we have our bj image and we can set a default color to zero zero zero we have a background size of cover and overflow is going to be hidden for this one and this is also great with style components because otherwise if you set a background image you may have done some inline styling to get the image to show up as a background image but here we can just import it and use it in the style component like this so we don't have to do any inline styling on the component itself all right then we have our export cons to style tetris and that's going to be a style div also type function this is going to be a flex align items to flex start we set our padding to 40 pixels and we have a margin of 0 and auto and a max width of 900 pixels the css here is not really optimized you can try to get a better look for yourself if you want to do that i haven't put that much time in the css styling i just wanted something to work fairly good so you could probably improve the css and get a better grid and stuff like that and inside here we have our aside and we're going to style that and this is also great with star components of course you can nest them inside of here just like you do in sas for example so we set our width to 100 a max width of 200 pixels we set our display to block and padding to 0 and 20 pixels like so and that is going to be our style component for the style tetris now we just have to import it up in the component so we can import our styled tetris wrapper and or style tetris and we grab them from dot forward slash styles forward slash style tetris and no it shouldn't complain here no all right and as you can see we are gradually exchanging this one to something else so we see the space here now and we see that the cells are just yeah these tiny bits now all right then we can create another style inside of styles folder that's called style stage.js and we create the style first so we import styled from style components then we export const style stage and it's equal to styled div and we have backticks course it's a tagged function and we're going to display a grid for this one we have our grid template rows it's going to repeat and we're grabbing from props or props dot height or coma and then we're going to do some css calculation here we have 25 viewport width and we divide it with we have dollar sign and curly braces because now we're going to have another inline function another inline function to grab our props and we grab the props dot width and this is going to do some nice little calculation for us to make the grid look nice and we are doing this to keep the aspect ratio of the grid cells then we have our grid template columns that's also going to repeat and from our props yet again we grab our props dot width and it's going to be one fragment and of course that one should be there like so these calculations is because we want to keep the aspect ratio of ourselves we want them to be perfect squares all the time and this is actually kind of tricky to do so yeah i've got it to work yeah fairly responsive but not 100 percent so if you come up with a better idea feel free to change it to whatever you want we want to have a grid gap of one pixel and the border going to be two pixels solid and we can set it to three three three we have a width of hundred percent and a max width of 25 viewport width and a background of say one one one all right so that's our style stage we just have to import it into the stage component so make sure you're inside the stage component and import style stage from dot forward slash styles forward slash style stage all right and then we rename this one to our style stage now we close it with the same and we're going to send some props inside of this of course we had a width and that one we're grabbing from we are sending in the stage as props to this one so if we grab the stage and the first row and the length we know the width of our grid and the height we just grab the stage length like so and that will give us the height from our multidimensional array all right we save this one and see what we've got and as you can see we have something here so we're slowly getting there we can actually now also go back into the cell component and we can remove the text here we don't need that one and that's why we can just selfclose it like this and that will get us our grid and here you can also see the shadows that we created in the cell component and it works fairly responsive what have we got left to do we're going to style our display and our start button inside our styles folder create a new file styled display dot js and import style from styled components and we export const styled display and it equals a styled div and yet again backticks box sizing to border box we display flex we align items to center why i'm using flexbox is to align the text in the different displays we have a margin of 0 0 20 pixels and 0 we have a padding of 20 pixels we have a border of 4 pixels solid and a triple three we have a min height of 30 pixels we have a width of 100 percent a border radius of 20 pixels and the color and that one we're grabbing from props yet again we have a dollar sign and curly braces we have our props and we do a turner operator because we are using the same display component when we did play game over as we display the score and rows and things like that so we have a prop that's called game over and if it's game over we set the text to red otherwise we set it to some grayish and we set the background to black we have a font family of pixel that's the one we imported in the global css file and we can set it to yeah some fallback fonts here and the font size of 0.8 rem like so and then we just have to import and use it in our display component so we import or styled display from dot forward slash styles forward slash style display and then we change this div to our style display component and we also had our prop that's called game over so we send that one in like so and let's see what we've got and there's some nice displays and we have this retro font inside of them and that's good we just have to style our start button and then i think we'll be good to go to do some heavy coding on this game so inside of styles create a new file and call it styled start button.js import style from style components getting boring boring boring but we have to do this so we export a const and style start button and we have a styled button double backticks and inside we write our css we have our box sizing and we set that one to border box we have a margin of 0 0 20 pixels and 0 we have a padding of 20 pixels a min height of 30 pixels a width of 100 and a border radius of 20 pixels a border we set that one to none we have a color of white a background of a triple three we have a font family of pixel and some fallback fonts we have a font size of one rem on outline of none because we don't want to display that ugly outline when we press the button we set the cursor to pointer also and we save that one and inside our start button we are going to import this one so we import styled start button from dot forward slash styles forward slash style start button and of course we change this one to style the start button we are also going to have an on click handler on this one so we can type it in now so we have the on click and it's going to be a callback all right so that's the start button and it's showing nicely but nothing is happening now because we don't have that callback created yet but we have something that looks like a tetris we're just going to remove this yellow one from our cell because the type is going to be the type and here we also change that one to type because that was only to show you what we were doing here and as you can see now we have our grid here instead and that's nice because that's our playing field and everything set up for us so we can start coding the real game here and we'll start with that in the next video so see you then okay we got our stage our displays and our start button and it's time to code some logic for this game and how is it going to work yeah well we're going to have this stage of course with the cells here and we're going to have a player and we're going to use react hooks to create this game and two big advantages with hooks is that you can abstract them and you can reduce them and compose things together and that's really great and for this game we're going to create three own custom hooks and that's the use stage use player use game status and the use in the well is the one that dana remote created for us and the reason that i created these custom hooks is that i want to kind of separate out the logic for different things so we have all the logic for the player in the use player hook and we have all the logic for the stage in the use stage hook and we also have the use game status that is going to have yeah mostly the display logic that we're going to show like the scores and things like that and how many rows we cleared so that is how we're going to divide up the code and we have the tetris component that's going to be our main component as i said before that's the heart of our application and as we're creating a game we're going to have some kind of game loop and as i also said before we're going to use an interval for this one and not using yeah maybe the more sophisticated way where you get animation frames and stuff like that so we have this grid here that is uh represented by the array and we can actually console log this one out so we can see what we have in our array so inside of here somewhere we can console.log create stage like so and i'm just going to show the console here and as you can see we have an array with 20 rows in it and each row has 12 cells and as you can see here we have a zero and that means that this cell is clear we don't have a tetramino in this cell and it's also set to clear as we can see now we just have a clean stage here so everyone here is clear and that means that we don't have any tetramine or merge into our stage because when we collide with something we're going to change this one to merge and in the next render we're going to keep every cell that has merged here and that's the way we keep the tetra minus that has collided i think it will get too much more clearer when we actually create the tetra minor and how our game loop works because the game loop are going to do a couple of things for us the first thing we have to do in our game loop is that we clear the stage and then we check for an emerged cells here and we don't clear the merged ones so they are going to stay in the stage they're going to stay in the array for a stage and then we're going to check the position of our tetramino and if it hasn't collided we are just going to set it to clear again and that means for the next render it's going to be wiped out and it's going to move and that's the way we get the illusion of movement here or maybe it's not an illusion it is a movement but the tetra minor that hasn't collided is getting cleared on every render but if we have set this to merge it's going to stay in the stage and then we do this over and over again with our innerval and that's the way we get the movement for our tetra minor so that's the short very compact version of how this game loop is going to work and we also kind of have to look into the future because we are going to check the collision before we actually move the player so when we make a move if it drops or if you move it with the arrows on your keyboard we first check the collision before we make the move and if it collides we don't make the move because then we know that it has collider we always check the game field the stage one step ahead before we make the move and that is also going to be much more clearer when we actually do this coding i just wanted to explain it shortly for you so you have a rough idea of how this is going to work all right so let's get back to our code we can start in our hooks directory in our hooks folder and inside of that folder we create two new files we create one that is called use player dot js and one that is called use stage dot js and as i said i always name my files as the component or in this case the hook itself and in react you always name your custom hooks with use before the actual name so in this case it's use stage and use player so we can start off in the use player.js file so make sure you're inside of that file and we import and we're not going to need react for this one we just need to use state state from react because this is not a react component so we're just importing the use state then we can import our random tetra minor function and we grab that from dot dot forward slash tetra minus then we export const and we have our use player as i said it's important to have used before otherwise react won't know that this is a custom hook and we have an error function curly braces and we're going to create a state for this one and that's the only thing we're going to do in this video then we're going to build more up on these files in the next videos we're going to create a state now with a hook that's called use state that we imported up here and use state will return an array with two items in it for us and that's where we can use es6 destructuring to grab these two values so we have a const and we have an array that we want to destructure and we can call it the player and we have the set player and we use state and this is the way that you state works as i said we get two values back we got the actual state here and then we have the setter for this state you can call them whatever you want they don't need to be player or set player and this is just two values that we destructure out here so this line here is actually short for all of this we have a const with player state maybe and we use state and then we have our player and we grab player state and the first value in the array then we have our set player and then we have our player state and the second value in that array but by using es6 the structuring we can make it in one row here and that's very very convenient and that's the way you should do it when you use state so get rid of this we are also going to set an initial state for a player and you can actually send in your initial state to the u state when you create the state with it we're going to have an object so we have curly braces and inside we're going to have a property that's called pos that's the position for our player we're going to have an x value and we set at the zero and then y value we set it to zero also and then we have our tetra minor and that's going to be one of them we created down here that we're always going to keep in this state for the player and for now we can actually just set the random tetramino so we call that function and we're going to grab the shape from the tetra minor and if you remember we had one shape property and one color property so this is the one we're grabbing here that's the shape of our tetra minor zero equals nothing and the letter inside of here equals the cells that are occupied in our tetra minor and i choose to have the letter of the actual tetramine here you could actually have the same letter for every one of them it doesn't matter because we're just going to check if it's not zero when we render the tetra minor to the stage all right so we grab a random tetramino and the shape of that one and put it in our state for the player and then we're going to have a property that's called collided and we set that to false so that's our initial state for the player and now we're actually just going to return the player because we're going to import this custom hook into our tetris component and then we're going to need the player inside of the tetris component i'm going to show you this in a second for now this is it for the use player we're going to return to this file and we can now move on to our new stage hook and do almost the same for that one so we import use state from react so we import create stage from dot dot forward slash game helpers all right and then we create their custom hook so we export const and we're going to call it use stage and it's an arrow function curly braces and we create the state for this one also so we call it stage and set stage and we call the use stage hook and inside of this we're actually going to give it the initial stage and we can just call the create stage inside of here and it will generate the initial stage for us the clean board for a game as we have here so that's our state for the stage and we're going to return we're going to need both the stage and the set stage for this one so we return them and i can see that i typed use stage here it should of course be use state like so so we save this one and then we're going to do a little bit of coding in our tetris component also so make sure you're inside your tetris.js file we can actually remove the create state for this one now we just had it before we're not going to need that one because we're creating the stage in our use stagehook now so remove this one and we can actually make a little comment here this is a style components and then we're going to have our custom hooks so we import use player from dot dot forward slash hooks and use player and then we also import our new stage from dot dot forward slash hooks use stage all right and we already have imported the components we are going to use some state in this component also so we have to import use state up here all right so we're both importing react and use state and now we can remove this console log but it would be nice to have a console log here that tells us if it rerenders so we can create that one console.log rerender it's always nice to have then we're going to create two states now actually because yeah we're not going to use them right now but we can create them as we're already in this component we're going to have one that's called drop time and one that's called game over and the drop time is the actual speed that we're going to modify depending on which level we're on and then the game over is yeah simply going to tell us if the game is over or not so we're keeping true or false in a state for that one so we create the new state that's called drop time and set drop time we have use state and for this one we can just initialize it with null and we have a game over and set game over and our use state and we set that one to false of course it's not game over when we start and then we're going to use our custom hooks and if you remember from a player we exported our player and that means that we can grab that one with destruction here const player and use player like so and we also have our stage and for that one we exported two different values in an array so we can destructure them out also so we have our stage and our set stage we run our custom hook called use stage and we send in the player to this one we're not using the player in this custom hook yet but we are going to need our play in this one so we're going to modify this to use the player later so that's why we can send it in already now because we have the player here so we send that one in okay and then we can remove this one because we're not needing that functional we already have our stage in our variable called stage that we get from you stage so we use that one instead here and we can actually also use this game over variable here because when the game is over we're going to show a display that says it's over so somewhere in the side here we create curly braces we check our game over variable if that's one is true we're going to show a display component with a prop of game over we're sending that one into the display component because if you remember we're changing the color of the text to red if it's game over so we're just simply sending the game over variable and we have the text that equals the game over and we selfclose the component there this is a ternary operator so if the game is not over we're simply going to display everything of this like so so if we have a game over we just display this one that says game over we don't display the score the rows and the level and if the game is not over we are displaying all of these so we save the file and it seems to be working we didn't break anything in the game and it's just complaining here because we're not using these values yet but that's fine in the next video we are going to create the player movement with the keys on the keyboard and we're going to do the stage update we're actually not seeing any tetra miner now but we will see it in the next video hopefully okay let's create the movement for the player and also the stage update so we can see the changes take place on our stage here first we're going to be working in the tetris.js file the tetris component and i'm actually going to take back some code we deleted in the last video we are going to use the create stage function in this one also so import it again sorry for that we import create stage from dot dot forward slash game help us we're going to need this one when we restart the game we need to create a clean stage for that one so we're going to need a few functions now because we're going to create the movement for the player so down below here somewhere below the console.log rerender we are going to need a function that's called move player and it's going to take in a direction as a parameter for now we just leave it empty then we're going to need a function that's called start gain we leave it empty for now we have another one that we call drop and we leave that one empty and we have another one that's called drop player yeah and that may seem odd now that we have two similar functions here but it will get clear to you when we have more code in this component and i'll explain why them and the last one for now is a function that's called move and we're going to destructure out the key code for this one this is going to be the callback function when we press the keys on the keyboard all right we're going to fill them with code in a second but first i'm going to explain this style tetris wrapper for you so we created this one with the width and height of the complete window here and that's because we need some way to take our key inputs and this one the rapid over here is going to be responsible for that so it's going to have a few props we need to set the role to button otherwise it won't respond to the key press and we need to have a tab index that equals to zero and we have an on key down and we're going to call our function that's called move for that one and send in the event so that's why we have this style tetris wrapper it's on kind of her you don't see the div here but it will cover the complete screen here and that's why when we for example click here it will register the key presses for us if we didn't have that one or for example just put the key press on this one you have to click on this to get the key presses to register let's go to our callback function that's called move that's the one we call here first of all we're going to check that the game isn't game over because then we don't want to register any key press so if parenthesis and not game over then we can do something here and then we check again if our keycode we destructure that one out from our event because on our event we have a property that's called keycode and if we destructure it here we don't have to type e dot key chord a little win here because that's not too long to write an e but yeah and we're checking if the key chord equals to 37 and that's the key chord for the left error on the keyboard then we're going to move the player we call our move player with the 1 because we're moving to the left that's why it's 1 if our key code equals 39 that's the right arrow on the keyboard we're going to move the player to the right and that's why we have a one here so left equals minus one because we're moving minus one on the x and 1 equals right because we're moving one step on the xaxis and then we have another else if if the key code equals to 40 that's the down error on the keyboard we drop the player because we're pressing down so we want it to go down so that's our move function an in or drop player function for now we're just going to call the drop so we're just calling this one we're going to have another little special case inside of this later on so i'll explain that then then we have our drop function and we're going to create the function in or use player hook that's called update player pos and yeah it will do what it says it will update the player position update player pos and we're going to give it an object with the x value of 0 and the y value of 1 because we're dropping now and i can see that i'm in the wrong function here so just copy and paste that one inside it should be in the drop function so as we're dropping here we're going to increase the y value of one and make the player tetra minor go down and we set the collider to false all right it will complain because we haven't created this function yet and in the start game function we can just make a little comment here reset everything and we set the stage to create stage we call our function to create a new stage and we reset the player and that's also a function that's going to be in the use player hook and the start game is a callback function also that we're going to have on our start button so we can set an on click handler and call the start game function so what we'll do when we press the start game button we will reset the stage and we will also reset the player and then we have our move player function and that one is going to take care of the left and right movement so we call the update player pros and we give it the x value of direction and the y value of zero because now we're just moving left and right and we're giving it a value here minus one or one all right we save that file and it will break now of course because we haven't created these ones yet so we have to create the update player pos function and the reset player function and we're going to place them in our use player custom hook and that means that when we call or use player function here we also want to get the update player pus and the reset player from that custom hook all right so let's move into our use player hook so make sure you're in the use player.js file and we're going to continue write some code here we're going to create these two functions here so we have our update player pos and it's going to be a function that takes in an object and we can destructure out x y and collided from that one we create an arrow function curly braces and inside of here we're going to set the state because now we're moving the player so we can set the player state here so we call set player that's the one up here and we do that with an update function if we do that we get the previous state here and we have to have a parenthesis here because we just can't give it the object because it will think that these curly braces are for the block and that's why we have the parentheses here we spread our previous state we set our pos to the new one we have an x property so we set that one to our prev.pos dot x plus equals x then we set a y value prev pos dot y and plus equals y so we're adding the values to our state here and then we set our collided property like so so that's the update player position we're just setting the state with the new x and y values here and our collided value all right then we need one for reset player so we create the const reset player and for this one we're actually going to need a hook that's called use callback and that's because otherwise our game loop will go into an infinity loop we won't see it now because we haven't created one yet in our new stage hook where we're going to use this function but trust me we need to have the use callback here otherwise we will be in a mess with an infinity loop so we use callback and give it an inline function here it is going to be dependent on nothing because we just create this once so we set the player and in this case we're resetting everything so we won't need to have this update the function here and give it the previous state we can just set the state from scratch so we have our position or pus our x property we set that to our stage width and we divide it by two i subtract two also to get it kind of in the middle because this one will position the tetra minor in the stage so this one will give it yeah kind of in the middle and we have our y property we set that one to zero because we want our tetra minor to be at the top when we reset the player and we have our tetra minor and we will give it a random tetra minor and grab the shape so each time we call this we will get the random tetra minor and this is the way that the tetra minors change randomly and we set collided to false like so we also have to import the use callback up here and use callback is a standard react hook and the last thing we have to do for now is also return or update player position or update player pause and or reset player and this should be it now so it's still working but nothing happens here because we're not drawing anything to the stage now and that's what we're going to be doing now so let's go into our use stage.js file or use stage custom hook and this one is going to be a little maybe complicated but i hope we will get through it and that's the thing with game making because as i said i'm not the game maker so yeah some stuff can be hard to understand when you're not a game maker but even if you don't understand everything that's game specific i hope you will learn some stuff in react okay so let's continue in this one we're going to take in our player and reset player as our parameters for this one so add these ones up here then we're going to use the hook that's called use effect and that's one is for creating side effects with react and it's yeah kind of a replacement for the life cycle methods in the class components i won't go into detail with every hook here so you have to look up that yourself if you don't know how use effect works and what it's for they have an excellent text on the react homepage where you can read about all the hooks all right so we create our use effect and that one is going to have an inline arrow function where we're going to create everything for our effect and this is the dependency array for now we can just leave it empty we create another function inside of here that's called update stage we're going to give it the prep stage the previous stage and below here we're going to set the state of the stage with this function so we have the stage state here and we set it with the set stage so set stage and then we have our update function so we grab the previous stage state it's easy to be confused here with stage and state it's almost the same saying that so we call our update stage in our previous state and you can also see that we're placing this function inside of the use effect and by doing this we don't have to specify it as a dependency here so we can have it inside of this effect all right and now we have to do some things here because when we update the stage we first have to flush the stage we have to kind of clear it from the previous render so we create the const with a new stage we take our previous stage of prep stage and we map through it so we get our row and we have an inline function here and we make another map on our row because this is a multidimensional array so we have to do two maps here it will probably be a little bit faster if we do this with just four loops but i think we will be fine here using map but if you care a lot about performance you shouldn't use map i think in a game like this you should use the for loop because that will be faster than the map all right so we have a row with map over a row and then we get our cell and we're going to return a new cell value and here we're going to make use of the one i talked about here where we create the stage where we set it to clear or merged so i'll show you that now we create the turner operator here we have a cell value we checked the value in our cell array and i will go back to this again to make it as clear as i can it's this value here we're grabbing so we simply check if that one is set to clear clear then we are going to return an empty cell so we return an array with a zero and clear otherwise we are just going to return the cell and this is what i've been talking about before because if we haven't marked a cell to merged then we just swipe it out we just clear it and we return a fresh clear cell here otherwise we return the cell as it is and it will stay in the stage so that's the way we know what cells have collided tetraminos in them or not so we have flush the stage here then draw the tetra minor so we flush the stage remove everything that shouldn't be there and then we draw the new stage for this render and we can do that by loop through our tetra minor and we have our tetra minor in our player if we check or use player we created the state here so we have the tetra minor here it's in the object for the player and in our tetris we are sending in the player to the use stage and we're getting it here so that's why we can access the player in our use stage custom hook so we have our player and the tetra minor property for each we're not going to return a new one here we're just going to simply loop through it we have a row and we have a y value curly braces then we're going to map through our row because this one is also multidimensional array so it's unfortunately a lot of loops here when doing this we have our value and our x value for that one and we have another inline function it may be a lot to grasp now when you're just typing it in like this so i suggest again you stop and just try to really understand what we're doing here because now we're looping through our tetra minor and now we're going to check which cells in the tetra minor that are occupied and that way we know the shape of the tetra minor we have our value here for a tetramino for a cell in the tetramino so we can check if the value isn't zero then we know that we're on a cell that makes up the shape of this tetra minor and then we also know how we can position the tetra minor on the stage we have our new stage up here that we flushed it's a fresh stage that we can use to draw our tetra minor so we have a new stage and yet again this is a multidimensional array so we have to set the y and x value for this one first we have our rows that's our y value so we have the y value plus player pos dot y then we have our x value plus player pos dot x this will give us the coordinates on the stage so we are going to set these ones to the value and the value here remember that it's the tetra minor that we're looping through so we get the value of the tetra minor and in this case it's going to be yeah one of these values here let's go back to our u stage so that's our value and then we're going to do backticks here two of them and inside we have a dollar sign curly braces because we're going to check with the turner operator if our player is collided then we set this one to merged otherwise we set it to clear and this is yet again how we know that we should clear this tetra minor in the next render if we set it to merge we know it has collided and this one when we flush the stage before we do this it will be set to merged and that way we know that we should keep it in the stage because it has collided otherwise it's set to clear and then we can just delete it in the next render before we do anything else all right this is beginning to be a long video sorry for that but we have to do this and inside our function here make sure you're in the right scope here inside of the update stage function we are returning the new stage for now because we're not checking any collisions yet we're going to return to this one and as you can see here when i order formatted this one it has filled in this itself these are the dependencies that we need for this use effect so we have the player.collided the player.post.x the player dot post dot y and player dot tetra minor we're using them inside of this use effect and that's why we have to specify them as dependencies here and we are going to use the reset player that we wrapped in our use callback later so that's why we have wrapped it because we're going to add it as a dependency to this one and it's this use effect that will go into an infinity loop if we don't wrap it in a used callback all right save this one and as you can see we have a tetra miner here now and that's great and if we reload this one we get a different tetra minor because we have randomized them and that's working great and is this working no okay let's check that out in our tetris all right i see here it shouldn't be on click it should be called back because if we look in our start button we have the prop here that's called callback so make sure you're in the tetris component and change this one to callback and i bet it will work now and it does and i think i saw a little bug there yeah it disappears and i think it is it's probably when we get the same tetra minor as before and i think that is if we go into the use stage custom hook we have these dependencies here so when we get the exact same tetramino it won't rerender because this one is dependent of the collider the position x the position y and the tetra minor so they are going to be the exact same in the next render if we get the same tetra minor and that's no good i think we can just change the dependency to player and save this one make sure you reload it it's working great now um i don't think this will give us any trouble in the future so i haven't seen this bug actually before i think i had gone through everything but yeah that's the thing with code you always get surprised i think it will be fine to have the player there otherwise we'll change it later and i also saw some little other stuff here we have to adjust because when you start the game you don't want this one to show up here before we have pushed the start button and that's why i created in this file tetra minus i created this zero here with just a blank little cell here and that's the one we're going to use for this now so if we go back into our use stage now into our use player you can see that we are just rendering a random tetra minor here and that's not good if we import our tetra minus also here then we can just grab the tetra minor and we grab the first one in the array tetro minor tetro minus and we save it and as you can see now the stage is blank here and that's good and if we push to start it will generate a random tetra miner for us to start with and of course also we have created the movement for this one so if you press left and right and the down button we can actually move the tetra miner now and as you can see we have not done any collision detection yet so it will screw up here but that's fine for now we will fix that later but at least the controls are working and that's also great so we have something here now we are getting somewhere and we will continue this one in the next video it's time to create some collision detection now for our game because now it isn't working here we can move outside the play field and it looks kind of screwed up here and that's not what we want so let's go back into our code and we're going to be working in the gamehelpers.js file for now that's where we're going to place the collision detection function it made sense for me to place it in that file but if you feel that you want to place it somewhere else you can do that of course but for this tutorial i'm going to create it here so make sure you're in the gamehelpers.js file and we have to think about a few things before we create this function one of them is that it's probably better to use for loops because it will be at least a little bit faster than to use for example map or for each because we are going to loop through our tetra minor here again and we're going to have two loops for this one also so if we use for example for each we can't break out of that one and that's the downside for us because we want to break out of the loop as soon as we collide with anything so feel free if you want to experiment with this and try different ways of doing it i'm going to use for loops so we can start by creating our function now we need to export this one because we're using it in the components so we need to have an export const and we call it check collision we give it a player the stage and we give it an object where we can destructure out the move x and the move y so what i'm doing here is that i rename the x and y to move x and to move y and that's because i'm going to use y and x in my loops so i want to have a different name for these parameters here and it's an arrow function and we have curly braces so we're going to loop through our tetra minor in this one so we have a for loop let y equal zero and y should be less than player dot tetra minor dot length and then we just have the y plus equals one for each iteration and then inside of here we have another loop let x equals zero and x should be less than player dot tetra minor and we can grab the y value dot length and then we have the x plus equals one so we add one to this one for each iteration also and we could of course just say zero here because it doesn't matter which row we are checking the length so of course the rows are the same length all right so what do we have to do here now first of all this is the tetra minor we're looping through and we first have to check that we're actually on a tetra minor cell and the zero don't make up the shape of the actual tetra so we have to check that the cell isn't zero so we can make some comments here one check that we're on an actual tetra minor cell like so and then we create an if statement and we check if player.tetromino and now we're grabbing a y value and our x value from our loops and it shouldn't equal zero all right so that way we know that we're actually on a cell that make up the shape for the tetra minor and we should check that cell if it collide with anything so what collisions do we have to check we make a little comment here again we need to check that our movement is inside of the game area's height that we're not moving the tetramino outside of the bottom of the stage so we can just make a comment check that our move is inside the game area's height and we can just set y in parenthesis and maybe also we shouldn't go through the bottom of the play area all right and we can actually specify the other things we're going to check before we create them so down below here create number three then we need to check that our tetra minor isn't moving outside of the game areas with check that or move is inside the game areas with and that's an x and then below here we have the fourth thing we're going to check and that is we're going to check that the cell isn't set to clear because this function will return true or false if it returned true we have obviously collided with something otherwise it's false and we haven't collided with something so if the cell is set to clear then we know that we're not colliding with anything and it will return false check that the cell we're moving to isn't set to clear because if it is clear we're not colliding all right so that's our things we have to check here we're going to do this with a chained short circuit whoa that was hard for me to say as i'm not natively speaking english and you probably can hear that also but you have to live with it so if not stage and we grab the y value plus player dot pos dot y plus or move y we're looking into the future here you can almost say like that because we're checking here if the position that we intend to move to is colliding so here we're simply checking that our status y value actually has a value in it if it doesn't have that we know that we're outside the bottom of the stage and this will also return true because we're setting this to not with this exclamation mark so if it not find anything here in this stage row it will return true and we know that we are colliding with something and as i said we do a short circuit here so we do an or i actually don't know what these signs are called in english it's the sign for or in a short circuit okay then we need to check that our move is inside the game errors width so we have the exclamation mark we're checking that not stage y plus player dot pos dot y plus move y and then we need to check the actual cell here so we check the x plus player dot pos dot x plus move x and yeah it is complaining here because we of course need an if statement here also so wrap this in an if statement and return true and we go back to this one we create another or and we're going to do our fourth check here okay the fourth one we're going to check i misspelled this check we are going to check if this cell is not set to clear and we can do that by typing stage and then we do the same thing here y plus player dot pos y plus move y and then we have the cell so we have x plus player pos dot x plus move x and then it's the second one in this array that we have to check so we type in a one here and we check that it isn't clear like so and this one should of course be a capital y so there you have it that's everything we need for our kind of simple collision detection i actually almost copy and paste this code from the mathmath method tutorial because i think this is a very simple and clever way to check the collision because with this collision detection we can detect if we're outside the stage and also if we collide with any of the tetra miners because we're looping through the tetra minor that we have in play and check if any of the cells inside of that tetra minor collide with any of the cells in the play field and that's how this function can check for everything that we want if we go outside the stage and also if we collide with another tetra miner that's merged to the stage so we save it and we see that we didn't break anything and we didn't do that and that's good we have to go inside or use stage hook and add a little collision detection here because when we have the new stage here with the new updated position we then check check if we collided like so so we can do a little if statement here if player got collided then we just reset the player like so and it will need a new dependency here so we can add reset player because if we collide we just reset the player we move the player up to the zero y position and the other one will stay in place where we collided because we merged it into the stage here the last thing we have to do here now is to go into our tetris component and actually use our check collision function first we have to import it from the game helpers so we have our check collision imported there and we have to check the collision when we move the player and when the player drops so inside our move player we create an if statement and if we don't collide we send in the player the stage and the intended position we want to move to so we have an x value of direction and we have the y set to zero because this move player function is responsible for moving the player left and right so yeah i probably should have named it something else yeah i realized that so you can change it to a more descriptive name if you want to do that then we can move this one inside of the if statement and this means that if we're not colliding with with anything we actually do the move otherwise we don't do anything here so we save it and we can see if it works we shouldn't be able to go outside the play field to the left and to the right and we can't and that's great so it will stop the tetra minor there because we are colliding with the sides of the stage then we have to check for collision when we drop the player so inside of the drop function we do almost the same here we check if not check collision we give it the player the stage and the intended move so we have the x value in this case it's zero and it's the y value that we're going to give a one because we're moving one step down each at a time and we can move this one up here inside of the if statement in this case we're going to have an else also in this case as we're dropping we know that if we collide on something when we drop we also need to set the collided property to true in the player and that's because if we collide with something when we drop we know that this tetra miner should be merged to the stage because it can't drop anymore so we we need to yeah merge it into the stage so we update player pos we give it an x value of zero and a y value of zero we're not moving anymore we're just setting the collided to true we can also inside of this else block create something when the game is over because if we're colliding and the player dot pos dot y is less than one we know that we're colliding up here somewhere and the game should be set to game over so we can console log game over and then we're going to set game over to true and set drop time to null because we're not dropping anymore so we set at a null and also up here in the start game function we can set game over to false because we're starting a new game here so it shouldn't be set to true all right we save it and see what we've got we're checking here and it's still working with the collision on the sides and if we go down here it should merge into that position in the stage and it does so that's great and we can see if it will go into game over mode here when we're colliding at the top and it does also and that's really really sweet but now we have a kind of a half working game it's not dropping because we haven't created the interval and we can't rotate the player so that's what we're going to do in the next videos in this video we're going to create a rotation for the player and we're mostly going to be in the use player custom hooked so make sure you're in the use player custom hook we're going to create two new functions in this one so just below our state here we can create one that's called rotate this one is going to receive a matrix and a direction so the matrix is actually going to be our tetra minor so you can name it that also if you want and of course we're going to have an equal sign and an arrow here then we're going to have another function that's called player rotate and we could actually do them in one function but i wanted to separate them out because the rotate here actually do the rotation and the player rotate are going to do some other things also because we need to check the collision here when we rotate the tetra minor that's why i separate them into two functions so we have the const play rotate equals it is going to take in the stage and direction and we create an arrow function and as i said before you can of course create regular functions if you want it's just me that yeah i like to create arrow functions instead but if it makes more sense for you to create a regular function you can do that also it doesn't matter here okay so first we create a rotate function and that's the one that's going to take in the tetra minor and the direction and we want to rotate the tetra minor and how can we rotate the tetra minor yeah first of all we can make all the rows to become columns instead so we kind of shift them in the array and that way all the rows are going to be columns instead and then if we reverse all of the values in the rows we get the rotation so that is how this is going to work so first make the rows to become calls now we can call it this transpose okay we create the new const we can call it rotate the tetra all right so we take our matrix we map through that one we're not going to use the actual value in this loop but we need the index then we map through the matrix again and we have the column and we return the call and the index and this one will make all the rows in the array to become columns so that's the first step in rotating then we need to reverse each row to get a rotated matrix or a tetra minor in this case and this one we have to separate into two things because it depends on which direction we are moving how we do this if we move with the direction of a value that's bigger than zero we know that we're moving kind of clockwise then we need to reverse all of the rows to get the rotation right otherwise if we move in the other direction if it's for example minus one it's less than zero then we just reverse the complete matrix or in this case the rotated tetra as we call it i know that this can seem a little bit too much and i think this is one of the thing again with game making you do this stuff all the time when you rotate things i actually had to think about this twice or three or four times before i got it myself and he explained it quite good in the math math methods video on how he rotate things i don't do it exactly the same here in this function but the principle is the same we have transposed our array or matrix or tetra minor and we have converted all our rows into columns and we save them in the rotated tetra then we can check if the direction is bigger than zero we return or rotate the tetro that we're going to map and we have the row and all of the rows are going to be reversed for this one so we use the reverse function on this row and that's a builtin function in javascript otherwise we're moving in the other direction so we can just return the rotated tetro dot reverse okay now we can create our player rotate where we're also going to do some collision detection when we rotate the player and i'm going to show you why in a second but first as always we don't want to mutate or state or anything so we create a copy of our player we can call it clone player we cannot do a shallow copy here so we need to make kind of a deep clone and you can do that with json dot parse and json dot stringify player so now we get a complete copy a complete clone of our player and that's good we don't have to work with the player that's in the state because we shouldn't mutate the state then we take our clone player and grab the tetromino from that one and we use our rotate function and we rotate the clone player dot tetramino and we give it the direction also and this will rotate the player and we can set the player to the cloned player we also need to export our functions here or actually it's just a player rotate we need to export we will get back to this in a second but first we have to actually create the rotation in the tetris component first of all we need to add the player rotate here so we get it inside our tetris component from the use player we're also returning this one then below here in our move function where we check the key code on what key is pressed and call a function we also need to add another else if here so if the key code equals to 38 that's the up error on the keyboard we call player rotate give it the stage and the one because we are going to need a stage when we do the collision detection in a minute and this is the direction we're sending in so we're rotating it clockwise and this means that we have a function now that we can rotate counterclockwise also so if you want you can add another key here that will rotate the tetraminer in the opposite direction that's very easy to implement if you want to do that i kind of play tetris with just rotating it with one key so i choose to not implement two keys for rotating in different directions here all right let's see if this works and it does that's nice but if we go to the side here you can see if we rotate it it will rotate outside of the stage and that's no good and it will break it as you see here but it's rotating nicely we're going to fix this thing now so it can't rotate outside of the stage so go back into our code and inside or use player custom hook and inside the player rotate function we're going to continue write some code here that will solve this problem for us and this one i actually grabbed it directly from the mathmath method tutorial because i think it's very clever how he does this so this code is straight from that one first we want to save our position in a const so we have const pos equals cloned player dot pos dot x so that's the x position we save here then we're going to create a new let that we call offset and that equals one then we're going to have a while loop so we have while and inside a while we check collision we send in the clone player the stage and we're not moving it anywhere so we just give it zero values in this object here with the x and y we already imported this check collision up here so we don't have to do that again and now we're going to write some tricky code here actually um and i'll try to explain it for you if we go back into our game i'll try to show you here so let's just place a few of the tetra minus here and i try to explain it if we rotate this one here as you can see it will move inside of these tetra minus and that's no good and this little function we're going to right now is going to take wait i'm going to create another one here it's going to take the tetra minor when we rotate it and move it right and left and right and left and check if we collide with something and that's the clever little function that he came up with in that tutorial let's say we go right it will check are we colliding no then we go left are we colliding there no and then it will continue until we collide or if we don't collide we can actually rotate the player so that is how this is going to work in this while loop so we have our clone player we set the position dot x plus equals the offset and this is how we keep track on how many steps we're moving to the side back and forth so we set the offset it equals to minus parenthesis offset plus the offset if it's greater than 0 we set it to one otherwise we set it to minus one and it's this little row here that will create the kind of back and forth movement for us with the tetra minor then we can create an if statement and we check if the offset is greater than clone player dot tetra minor and we grab the first value in the array and length here we're just grabbing the first row and check the length of that one we don't need to do any more shakier because we have looped through the complete length of the tetra minor then we just rotate the tetra minor back because this move isn't a load we can't rotate it if we have try this back and forth more than the width of the tetra minor then we know that we can't rotate so we just rotate it back because we already rotated it up here so we just rotate it back rotate lone player dot tetramino and minus direction we reverse the direction so we rotate it back and we set the clone player dot pos dot x to equals position and that's the one we saved up here because we wanted to have the same position as we had from the beginning and then we just return so this is yeah quite a handful of a function i don't blame you if you don't get it especially this one it can seem a little bit tricky it took some thinking for me to understand this just think of it as this one we'll go back and forth and see if it collide with something when we rotate and if we do we can't rotate it that way and it will constantly move it away from that one when we rotate so we can save it and see if it works we can try this out if we rotate it now you can see that it kind of pops out from the wall it won't go through it and also if we do some rotating here you can't rotate through them and that's good so i actually think that this is the most advanced function in this tutorial because this is quite advanced don't blame yourself if you don't get it the first time just try out yourself try to change the code try to look at it read it try and change it again and you will soon get it how it works if you don't get it right away and if you get it right away well good for you and see you in the next video okay we have a kind of a functioning tetris game here just a few things left to do if we take a look here we see that we have some full rows here and they should be swept off the stage and it should give us some score at the end but it won't do that now because yeah we can just fill this up and nothing will happen in this video we will create the function that will kind of sweep the stage and see if there's any rows that needs to be cleared and also push down the other ones that shouldn't be cleared so that said go into our code again and into our use stage custom hook inside of this custom hook we're first going to create another state so we create a state here that's called rows cleared and set rows cleared and this is how we're going to keep track of all the rows that we have cleared so we use state and give it an initial value of zero okay and the first thing we want to do in this use effect is to set rows cleared to zero and then we're going to create another function here that's called sweep rows we're going to give it a new stage to sweep and it's going to be an implicit return for this one so we don't have to have curly braces we grab our new stage and we're going to do some reducing here so reduce this is the builtin reduce es6 function we have the accumulator and the row arrow function called braces so we give this function a stage and we're going to map through it with reduce so we we do that with new stage dot reduce and we get the row and the accumulator if you don't know how reduce works i suggest you look it up and the first thing we have to do now is to check if our row just contains cells that are merged and that means that we can check if a row don't contain zeros and we can do that with find index so if row find index we have our cell and an inline function we check if the first value in our cell array equals to zero and if this one equals to minus one we know that we haven't found a value of zero and then we know that this is a full row and should be cleared because find index will return 1 if it don't find a match with the provided function inside of it if we're looking for the value 0 and it won't find that one then it will return 1 and then we know that this row should be swept away from the stage so we first set rows cleared and we do that with an update the function because we're going to need the previous value and we just add one to that one then we're going to grab the accumulator that's the new array we're building up inside of this reduce function we're going to unshift and unshift let us add a new value to the array at the beginning of the array because if we look here if we for example remove these three rows here we need to add three rows at the top and we can do that with the unshift method so we remove these three ones here and if we add three empty ones up here it will push down the other ones and it will kind of create the illusion that these ones just pop out of the stage and disappear so with the unshift we can add a complete empty row at the beginning of the array so we create a new array from our new stage 0 dot length that will give us the width of the actual play field and we fill it up with an array of zeros and clear because these ones are completely fresh so they should be zero and clear then for each iteration inside of the reduce we have to return the accumulator also and this is if we find a matching row that should be cleared if we don't do that we just push the row into the accumulated array and we return the accumulator again like this and we could also give it an empty array to start with so this is the complete function here i will go through it again and tell you what it will do we give this function our stage and we take the complete stage and use the reduce method on this one by using reduce we can create a new array so we check if the row contains any zero if it does we know that this row shouldn't be clear because we haven't filled up a complete row but if we have filled up a complete row we first add a row to our rows cleared state then we add an empty a complete empty new row at the top of the array and we return the accumulated array this works because we completely ignored to return the full row that we should remove from the stage and instead we return a new empty row at the top of the array so this will create the illusion that we remove the row on the stage and move the other ones down that was above that row and if we don't have a full row we just return the row as it is in the array and that's the way it works we have to use this function somewhere and we can do it if we know that we collide with something we should do this sweep and see if we also have a full row so below the reset player and because this one returns a complete new stage we also need to return the function and give it the new stage so this one will take or stage we create here when we have done all the mapping with the tetra miner and everything and if it collides then we call the sweep rows with this stage and this one in turn will return another stage for us when it has swept all the rows and check that there's no full row that needs to be removed from the stage okay so we'll see if it works i have to do some gaming here to get a full row and that's nice to be able to play some game here let's see if it works and it does nice it's kind of easy now when it's not dropping yeah and we know that it works now so i don't have to create another row here and we actually forgot to do something here and go back into our code and into our use stage custom hook we also need to return our rows clear because we're going to use this one in the tetris component later on so make sure you add that one to the return statement here all right so that's it we'll continue by creating the interval for the tetra miners to drop by themselves in the next video we are going to set this game in motion and i think it's better we take a look at dan abramov's site first overreacted dot io and then he has a blog post that's called making selling develop declarative with react hooks and it's 16 minutes read so i won't go through it here but i suggest you read this one because here he explained why it isn't a good idea to just use set in the val with react hooks so he has created this custom hook that's called use inval that we are going to use and hopefully you copied this file over to your project folder as i showed you in the beginning of this tutorial here's all the answers to why setting the well is not good to use as it is with ragged hooks it's better to create a custom hook and use that one instead and one thing why it's not so great is because react hooks are heavily using closures and closures can be quite difficult to grasp if you're not that used to them he has created this use in the world for us that we can just use in our game and that's what we're going to do now so back to our app and our code inside of our tetris component we're going to be in that component in this video at the beginning here where we import our custom hooks we can import our use in a val from dot dot forward slash hooks and use innerval and that makes sure that we can use this one inside of our component okay and now we're going to make this one move by itself because now we can just drop it by pressing the down key on our keyboard and that's no good we want it to move by itself so we can set up this interval and below i think yeah here somewhere we can use our interval so use interval and this one will take an inline function so we create an arrow function and we are going to call the drop function as we created up here because that's the one that makes the tetra minus drop so we call that one and we can specify the interval timing here and we already have a state that's called drop time so we just send this one in to the use in a well because if we look at the use interval it will take a callback and a delay and the callback is the inline function we created and the delay is our drop time so that's how this works and also if we send null into the drop time it will stop and clear the interval so that's good for us because that way we can control the interval all right back to the tetris component we have to do a few more things here to get it up and running because now our drop time is set to null we set it up here so now the interval is not active but we have a start button so when we start our game we can set our drop time and we send in thousand that means one second and we save it and then if we press start game as you can see it's moving really good here now and that's nice because now we have a working tetris game great i want to do a few optimizations here also we created one extra function here that's called drop player and inside now we're just calling drop and that's when we press the down key on our keyboard i want to stop the interval when the player moves the tetra minor down with the keyboard and that's easy we can just set the drop time to null and that will make sure that we stop the interval but we also have to activate it again when the player releases the down key so we're going to create a new function here that's called key up and inside of this we're going to take in the key code again so we destructure that out from our event and yet again we're going to check if the game is not game over and we can activate the interval again when the player release the down key so inside of here we check if the key code equals to 40 that is the down key we will only run this if the player is releasing the donkey then we set the drop time for now we just set it to thousand again we are going to create different speeds here later in the next video so that's our callback function for our key up event and we also have to make sure that we have this event here and we can create it on our style tetris wrapper so we just add on key up and it equals key up and a little nice formatting here and we save this one and we can actually do a little console login here because here we can console log interval off and we copy this one and go to our key up console interval on make sure you're showing your console here whoops i misspell this one yeah my formatting here has added this one for us yeah that's nice so i can remove this one it should only be use in the valve here okay so we start the game and i press the down button you can see that interval off and then interval on when we release the button and that's great because then it will not interfere with the keyboard when we hold the key down it will repeat itself and make the tetra minor go down faster and that could mess things up for us if the interval also is activated then so that's actually all there is to it to create this movement this kind of game loop that makes the tetra minor drop by itself in the next video i'm going to conclude this tutorial and we create some nice little displays here with score and rows and level and we're going to do that by create our last custom hook we're almost finished now we're just going to create a custom hook for displaying scores rows and levels and we are eventually going to import it here in the tetris component with the other hooks here but we will create it first so we have something to import here so inside our hooks folder create a new file that's called use game status dot js and we're going to need a few things here so we import use state use effect and use callback from react then we export const use game status and we're going to need one parameter here that's called rows cleared that's the one we created in our use stage we're going to send this one in to use game status because we need it when we calculate our score and set the total rows that we cleared because this one here is just the rows that we cleared in the current render that's why we set it to zero here so we clear it on each render and then we're going to send this one in to the use game status where we can add it up to the rows we already have cleared before all right we have an arrow function and curly braces and then we're going to create three states here so we have a const with the structure outscore set score equals u state and we have a zero we can just copy this one paste it two times and we're going to call this one rows and set rows and we're going to initialize all of these with a zero then we have our level and our set level so there you have it three states then we're going to need a const that's called line points and this is going to be an array with forty hundred three hundred and hundred and these are the actual scores i did some googling and found this course from the original tetris game so we're going to use these to calculate our total score i don't know there's probably a lot of different versions so i don't know if this is legit that it's truly the original scores that were used and also the formula for calculating the score but i found this one i think it was on wikipedia actually so you can have what scoring you want here if you want to change it so we have a const that's called calc score and this is a function we're creating here because we're going to call this function in a use effect and we're also going to need to use callback because otherwise this will go into an infinity loop and that's no good and i think that's also not a problem but i think it can be annoying because it's easy with react hooks to make them go into an infinity loop if you don't think about that very very thoroughly okay so first we're going to check if we have score if rows cleared is greater than zero that means if we cleared any rows in the render that's the one we send in here because if it's zero we didn't clear any row so we don't have any score calculations to do and that means that if this one is greater than zero we know that we cleared some rows and we're going to calculate the score and if it's uh zero yeah we know that we didn't clear any rows in this render and we don't need to calculate any score we are going to calculate a score and set our total rows so i create a comment here this is how original tetris score is calculated so this is the formula i use i found that one on the internet and i'm using that here to calculate the score so we just set our score state set score we have a previous state and we use that previous state to add something to it and here's the formula we have the line points that's the array up here and these line points array have four different values here and they each represent one row cleared two rows cleared three rows cleared and four rows cleared and this is an array so the index starts at zero so we have to take our rows clear minus one because say for example that we cleared two rows we need to grab the value with index one in our array and we're going to multiply that with our level plus one and that's also because our level starts at zero so that's why we're adding one here so this is the formula to calculate our score and then we also need to set our rows we have our previous state here and we take the previous state and add the new rows cleared to that one and that will always keep track of our total rows that we cleared all right and as this is a used callback we have to make it depend on something so we have the dependency array here we have the level the line points and the rows cleared so this one is always going to change when the level line points or rows cleared are changing otherwise it will stay the same and that's why it won't go into an infinity loop because if we didn't have this use callback it will change every render and that will create the infinity loop okay and then we create the use effect we want this to fire off automatically and this dependency array is going to depend on the calculate score the rows cleared and the score we're just calling the score here and as we're using these ones in this function we have to specify them as dependencies here but then we have to return something from this custom hook so there's a lot of things we're going to return here we want the score we want a set score because we want to reset the score when we start a new game we need a rows and we also need a set rows we want to set the rows to zero when we start a new game and also the same with the level so we want the level and the set level like so so we save this one and go back into our tetris component we import it where we import our other custom hooks use game status from dot dot forward slash hooks use game status all right then we have to use these values inside of our tetris component but first we have to call or use game status hook we can do that below here so we have a const and we are going to receive everything that we returned from this one all of these here we're going to receive here so we have to specify them we have the score set score rows set rows level and set level and we're going to call our use game status and we're sending in the rows cleared as we talked about before and of course we also have to grab the rows cleared here from our new stage hook see if i can make it a little bigger here i think we actually can move this one down here to make it a little nicer looking like so okay and now we have to use these values inside of our tetris component first in our drop function we want to change the level depending on how many rows we have cleared and that means we have to have something here that calculates that on every drop so i make a little comment here increase level when player has cleared 10 rows i think that that also is the original tetris but i'm not sure when you clear 10 rows then we go up a level and the speed will increase we create a little if statement here we check if the rows are greater than level plus one that's because the level starts at zero just as before times ten we set the level with our previous state and we just have the previous plus one we're just increasing the level by one and we also want to increase the speed and this little formula i created here i don't know if it's optimal actually i'm going to set the drop time like so and then i have thousand that's one second i divide it with the level plus one and then i just added 200 here so it will not get too fast and you can actually play with this and try another formula and see if it works better for you so i don't know if it's good i think yeah it's working fairly nice but yeah probably there will be a better formula for this to use so that's how we calculate our level we can actually also set a few things here when we start the game because we also want to reset our score level and rows so we can set our score to zero set rows to zero and we set our level to zero and then there's one more thing we have to do here we are going to take this formula here and copy that in the drop function where we set the drop time we have to also paste that in our key up function because now we're just setting it to a thousand here so just paste it in there and we want to display our score rows and levels also so we can change these ones inside of the props we're sending in to the display components so we create curly braces double ticks and we have our score and a dollar sign and curly braces and we grab our score then we do the same with the rows and the levels we can copy this one paste it in and then we change this once we have our rows and we have our level so this will make sure that we display the score rows and level and i think it's time to save this one and see if it works so it's already displaying the series here so we can start the game and it seems to be working nice so that's it we have a working tetris game i just want to make a little optimization here and i'm going to show you why because if we go inside our cell component and for now i have to do like this because i want to console something out rerender so what i'm doing here i'm just going to console.log out rerender on each cell here so i save this one and as you can see we have 240 rewinders here and that's fine when we build this table for the first time but as you can see on each little drop here now on each rotation and everything we get 240 renders it probably won't be an issue here because react is fast but i want to show you here how you can create a little optimization for this one so we go back inside our cell component and where we export this one we're going to export it with react dot memo and this will make sure that it memorizes this cell component and only rerenders when the cells actually are changing so we save this one and as you can see we're just rerendering the cells that actually change with the tetra miner now and i actually think that this is a really good example to show you what react memo does in react because now it won't affect the cells that won't change on that render it will only rerender the cells that change with the tetromino and that's good so we made quite an optimization here and reduced the rewrites here and that's good there you have it this is my this is my version of tetris with react hooks and as i said a couple of times now i'm not a game developer but it was sure fun to create this game and i think it's a good practice in react and especially react hooks to see how they work and i hope you enjoyed this one as much as i did and i'm very grateful that you have followed me on this tutorial and i hope you learn a lot i initially created this one exclusively for free code cam and i actually record a lot of free stuff especially in react and frontend and stuff like that in my own youtube channel so if you go to youtube and just search for webinfo weib you will see my pretty face here and you can just go to my channel and make sure you subscribe if you want free coding tips in react and other frontend stuff and i also create paid premium courses i'm going to move them to my own platform soon but for now they're up on udemy and it's a beginner react course and also a course in gatsby and how to create get beside with wordpress as a headless cms there's also a free course on react redux and there's of course the hooks introduction course that were published on free code camp a little while ago and i'm also on twitter just hook me up there if you have any questions or just want to follow me there and i sure appreciate the support i can get from you i want to continue to create free stuff and do things like this so hopefully you'll see me again in another video but for now thank you and goodbye
