With timestamps:

00:00 - hi everybody and welcome to the second
00:02 - video on a series that shows you how to
00:04 - build an 8-ball pool game with
00:06 - javascript and html5
00:08 - in the last video we implemented the
00:09 - shoot method on both the stick class and
00:12 - the ball class so that when we'll
00:14 - release the left button on our mouse it
00:16 - will shoot the ball towards the position
00:18 - of the pointer
00:19 - and we also display this shooting
00:21 - animation as you can see right here on
00:23 - the canvas
00:26 - okay so now i'll open the vector2.js
00:28 - file and there i want to add a method so
00:32 - i could get the length of a given vector
00:35 - so
00:37 - vector2.prototype.length and that will
00:38 - be equal a function
00:40 - and
00:41 - here i'm going to return the result of
00:44 - the length formula
00:46 - on the given vector and i'm going to
00:49 - calculate that
00:50 - using the math
00:52 - object of javascript
00:55 - [Music]
01:06 - okay great
01:08 - inside ball.js i want to add another
01:11 - property to the ball class
01:14 - that will indicate whether the ball is
01:16 - moving or not so this dot moving will be
01:19 - initially false and inside the update
01:22 - method
01:23 - i want to
01:25 - set it to be false if dot this dot
01:27 - velocity dot length
01:30 - is
01:31 - less than let's say five
01:36 - so if that happens i want to set this
01:39 - dot moving
01:41 - to be
01:42 - false and before that i want to set uh
01:46 - this dot velocity
01:48 - to be a new vector 2
01:51 - so its x and y values will be zeros
01:57 - and inside the shoot method after i
02:00 - um
02:01 - change the velocity i want to set this
02:04 - dot moving to be true
02:08 - and i'm going to add another uh property
02:11 - to the stick class and i'm going to call
02:13 - this property this dot shot and
02:15 - initially it will be false maybe i can
02:17 - find a better name but for now that will
02:18 - do
02:20 - and inside the shoot method i want to um
02:23 - set this dot shot to be true
02:28 - and inside the game world
02:30 - uh we'll implement another
02:32 - method that i will call
02:34 - gameworld. dot
02:38 - balls moving
02:43 - and that will be equal a function
02:45 - and for now we only have
02:47 - one bow
02:49 - that this object contains so we'll
02:52 - return this dot white ball dot moving
02:59 - inside the update method
03:02 - so if all the balls uh stop moving
03:06 - so if
03:07 - um
03:09 - this
03:10 - dot
03:10 - balls moving
03:12 - and
03:15 - if
03:16 - um
03:18 - this dot
03:20 - stick dot shot is true
03:23 - um
03:25 - so
03:26 - sorry if not this
03:29 - dot balls moving
03:32 - i'll call a method inside the stick
03:36 - object
03:37 - that i will name reposition
03:40 - and i will send
03:43 - this dot white ball dot
03:47 - position
03:49 - so i want to reposition the stick
03:52 - to
03:53 - the new position of the white ball
03:57 - so let's open
04:00 - stick.js again and here i'm going to
04:03 - implement this method
04:05 - stick dot prototype dot reposition
04:08 - and that will be equal a function
04:11 - that will get a position as an argument
04:14 - and
04:16 - it will set
04:17 - this dot position to be
04:20 - a copy of this position the the position
04:23 - argument
04:24 - and i'm going to set uh this dot origin
04:29 - to be equal
04:32 - the stick origin
04:34 - constant
04:35 - a copy of it
04:40 - now back in the browser let me refresh
04:43 - and
04:44 - once the ball stops moving
04:46 - the stick changes its position to be the
04:49 - same as the new position of the white
04:50 - ball
04:57 - just one final thing before we move on
04:59 - on the reposition method that we just
05:01 - wrote let's set this dot shot to be
05:04 - false
05:05 - and let's see that everything still
05:06 - works as it should
05:13 - okay great
05:17 - in assets.js let's load some more
05:20 - sprites
05:21 - um so the first one will be the sprite
05:24 - of the red ball
05:26 - and the second one will be the sprite of
05:28 - the yellow bowl
05:33 - and the last one will be the sprite of
05:35 - the black ball
05:40 - now i will create a new file that will
05:42 - go by the name of color.js and there i'm
05:45 - going to define something that we call
05:47 - in other languages and enum
05:50 - and
05:51 - it will contain all the different colors
05:53 - that we use on our game so uh
05:56 - red yellow
05:57 - black
05:59 - and
06:00 - white
06:01 - and each
06:03 - color is going to have a different value
06:11 - back in assets.js i will implement a
06:13 - helper function
06:15 - that will provide me the sprite that i
06:17 - want
06:18 - based on the color that i will send it
06:21 - so i will call this function
06:23 - get
06:24 - ball sprite by color
06:27 - and it will get as an argument a color
06:30 - and here i'm going to um
06:33 - create a switch case
06:35 - statement
06:37 - so switch color and in case
06:40 - the color is
06:43 - color dot red
06:48 - i will return the
06:50 - red
06:52 - sprite
07:00 - okay so i filled it up with the rest of
07:02 - the colors and now we can uh
07:05 - go to the bowl class
07:07 - and change the function constructor so
07:10 - it will get a color as an argument
07:13 - and here i'm going to set the sprite
07:16 - this dot sprite to be
07:18 - get
07:20 - ball sprite by color and send the color
07:23 - that we got as an argument and here in
07:26 - the draw method we can just delete
07:28 - sprites dot white ball and
07:30 - send this dot sprite instead
07:35 - so now we have to go back to the game
07:37 - world and to send
07:40 - the color that we want for the white
07:41 - ball which is of course white and let's
07:44 - go to the index.html file and add a
07:46 - reference to the
07:48 - color.js file that we just wrote so
07:51 - script src and that will be equal
07:54 - color.js
07:56 - back in our browser everything still
07:58 - works fine
08:00 - in purpose of testing let's uh change
08:03 - the color to be red and let's refresh
08:06 - the browser and that also works great so
08:09 - let's change it back to be white as we
08:13 - want it to be
08:16 - okay so let me paste a bit of code here
08:18 - because i don't see the point of writing
08:20 - it all again what you see here in front
08:22 - of you is an array that contains all the
08:24 - different arguments that we need in
08:26 - order to create our ball objects so you
08:29 - can see that each element in this array
08:32 - is actually a pair
08:33 - that contains a position and a color
08:37 - and eventually we use the map function
08:39 - in order to take every parameter and to
08:43 - pass it into the bowl
08:45 - function constructor to create a new
08:47 - bowl
08:48 - so
08:48 - at the end of the day what you get is
08:51 - that this dot balls contains all the
08:53 - balls
08:55 - other ball objects that we need
08:57 - in our game
09:00 - so down here instead of creating a new
09:03 - object
09:04 - for the
09:05 - white ball member we can just refer it
09:08 - to the
09:09 - last
09:11 - object
09:12 - in the array that we just created
09:15 - and maybe we'll change it in future but
09:17 - for now that will do
09:20 - and
09:22 - down here in the update method we can
09:24 - just loop over this array
09:26 - and
09:28 - right for let i
09:30 - equals zero i is less than
09:32 - this dot balls dot length
09:35 - i plus plus
09:37 - and
09:39 - to call this
09:41 - dot balls
09:43 - at i
09:45 - dot update
09:46 - and to send the delta of course
09:51 - and let's
09:52 - copy that and paste that on the
09:55 - draw method
09:56 - so
09:58 - we can loop
09:59 - over the array and instead of calling
10:01 - the update method we can call the drill
10:04 - method
10:06 - so back in our browser finally you can
10:09 - see that our
10:11 - setup at least visually is pretty much
10:14 - complete
10:15 - and if i'll shoot the ball towards any
10:18 - direction really
10:19 - as soon as the white ball stops moving
10:23 - the stick repositions
10:25 - itself to the new position of the white
10:28 - ball
10:31 - okay so there's something that i need to
10:32 - fix before we move on now that we have
10:34 - more ball objects it's not enough to uh
10:37 - check only if the white ball is moving
10:40 - on the ball's moving method we want to
10:43 - uh loop over the array and to see if any
10:46 - of the ball object
10:47 - is moving so i will set a new boolean
10:51 - ball's moving to be false and let's loop
10:53 - over
10:54 - the array
10:57 - this dot balls dot
10:59 - length
11:01 - i plus plus
11:05 - and if
11:07 - this dot balls
11:08 - at i
11:10 - is moving
11:14 - we can set
11:16 - both moving
11:20 - to be true
11:22 - and we can break out of the loop
11:28 - now we will return
11:30 - [Music]
11:32 - both moving
11:38 - back in our browser let's see that
11:39 - everything still works
11:42 - yep that looks fine
11:44 - now in vector2.js we'll need to add some
11:47 - more operations
11:48 - to support the collision system that
11:50 - we're going to implement later on
11:53 - so um
11:55 - we'll add here
11:57 - a new um
11:59 - method
12:00 - so
12:01 - vector2.prototype.add and that will be
12:03 - equal a function that will get another
12:05 - vector
12:06 - and we're just going to return
12:10 - a new vector
12:12 - that
12:13 - will be the sum
12:15 - of both vectors so this dot x plus
12:19 - vector dot x
12:22 - and this dot y
12:25 - plus vector dot y
12:30 - [Music]
12:36 - let's add another one and let's call
12:38 - this one subtract
12:41 - [Music]
12:44 - and here i will return the
12:46 - subtraction result of this of the vector
12:50 - argument from this vector
12:53 - and the last one for now
12:54 - will be
12:56 - the dot product
12:58 - so vector 2 dot prototype dot dot
13:01 - that will be equal function that will
13:03 - get another vector
13:05 - and this function will return the result
13:09 - of a dot
13:11 - product operation between both vectors
13:14 - so that will be this dot x multiplied by
13:17 - vector dot x
13:19 - plus this dot y multiplied by
13:22 - vector dot y
13:26 - now let's go to our game world
13:29 - and there on the update method before we
13:31 - do anything
13:32 - we want to check if
13:34 - collisions occur
13:36 - so let's write a new uh method for that
13:39 - and let's call it on the update method
13:42 - let's call this method this dot handle
13:44 - collisions
13:45 - so um
13:48 - gameworld.prototype.handle collisions
13:51 - and that will be equal function
13:53 - [Music]
13:57 - and inside this function i want to loop
13:59 - over the array in a certain manner that
14:01 - will provide me all the possible pairs
14:03 - of objects
14:05 - so uh
14:06 - for let i equal zero is less than
14:08 - this.length i plus plus
14:11 - and inside the nested loop i'm going to
14:13 - declare let j be
14:16 - i plus one
14:18 - [Music]
14:20 - j is less than
14:22 - this dot both dot length
14:25 - i
14:26 - and i plus plus
14:29 - [Music]
14:31 - okay so inside this loop let's get the
14:34 - first ball
14:35 - out of the array so first ball that will
14:37 - be equal
14:39 - this dot balls at i
14:42 - and
14:44 - const second wall
14:47 - and that will be equal this dot both
14:51 - at j
14:54 - and i want to write something like first
14:57 - ball dot collide with
15:00 - um second ball and of course we need to
15:02 - implement
15:04 - uh this method in order for that to work
15:07 - let's see that everything is fine
15:10 - here um
15:13 - oh actually i have
15:15 - a mistake inside the nested loop and we
15:18 - need to
15:19 - increase j so j plus plus
15:24 - okay so now let's implement the collide
15:26 - with method inside the bowl class so
15:28 - bowl.prototype
15:30 - dot
15:31 - collide with
15:33 - and that will be equal a function
15:38 - that will get a ball as an argument
15:42 - okay so this is the moment we all have
15:44 - been waiting for elastic collision in
15:47 - two dimensions and before i begin i must
15:50 - give a huge credit to chad burchek who
15:52 - wrote an article about this subject in
15:54 - 2009
15:56 - and this article explains everything in
15:58 - a very simple manner
16:00 - and
16:01 - even if you don't have a mathematical
16:04 - background i really encourage you
16:06 - to go and read this article i will leave
16:08 - a link in the description down below and
16:11 - really it's
16:12 - very easy to read and it's it explains
16:15 - everything um just beautifully so go and
16:19 - read this article
16:20 - one more thing that i want to say before
16:22 - we begin is that i'm going to provide
16:24 - you with steps on how to implement
16:26 - elastic collision in your code
16:28 - but i'm not going to get too deep inside
16:31 - the mathematical proofs and concepts
16:34 - okay so now that we're all set let's
16:36 - begin
16:39 - step one
16:40 - finding a unit normal vector
16:43 - a unit normal vector is a vector that
16:45 - has length of one
16:47 - which is perpendicular to the surfaces
16:50 - of the balls at the point of the
16:51 - collision
16:53 - in order to find the unit normal vector
16:55 - we need to find a normal vector first
16:57 - and we can do that by subtracting one of
17:00 - the ball's position from the other
17:02 - ball's position
17:06 - so back in our code in the collide with
17:08 - method let's find a normal vector
17:12 - and let's scroll down a little bit so it
17:15 - will be easier to see okay that's better
17:19 - so const
17:20 - n
17:22 - and that will be equal this dot position
17:25 - sub subtract
17:28 - and we'll send
17:30 - ball dot position
17:32 - [Music]
17:36 - from this normal vector we can also get
17:38 - the distance between the centers of both
17:41 - balls
17:42 - and this will indicate us whether a
17:44 - collision occurred or not
17:47 - so
17:48 - let's um
17:50 - find
17:51 - the distance
17:54 - and let's set const dist
17:57 - to be
18:00 - n dot length
18:06 - and if
18:08 - the distance is greater than
18:10 - the ball's diameter
18:14 - then we want to return
18:17 - from this
18:18 - function because there is no collision
18:20 - between both balls
18:23 - let's not forget to set another constant
18:26 - that will call ball diameter
18:30 - and in our case that will be 38.
18:38 - okay so now let's find a unit vector of
18:41 - n
18:42 - and we can do that by taking n and
18:45 - multiplying it by one divided by its
18:48 - length
18:50 - okay so now back in our code let's write
18:52 - a new comment
18:54 - and we'll declare here that um here
18:57 - we're going to find unit normal vector
18:59 - [Music]
19:02 - let's set uh const
19:04 - u n
19:07 - uh to be n
19:09 - multiplied
19:10 - by 1 divided
19:13 - by n dot length
19:16 - [Music]
19:21 - step 2 finding the unit tangent vector
19:24 - back to the drawing you can see that the
19:26 - unit tangent vector is a vector that has
19:29 - a length of one
19:31 - and is tangent to the surfaces of the
19:34 - balls at the point of the
19:36 - collision we can find it by
19:39 - using our unit normal vector that we
19:42 - already found we just
19:45 - take
19:46 - the x value to be minus u n
19:49 - dot y
19:50 - and the y value of the unit tangent
19:52 - vector to be
19:54 - u n dot x
19:57 - back in our code
19:59 - let's
19:59 - write a new comment finding
20:02 - unit tangent
20:04 - vector
20:07 - and we'll set const u t
20:10 - to be a new vector to object
20:13 - [Music]
20:16 - that
20:17 - its x value will be
20:19 - minus u n dot y
20:21 - and is its y value will be u n dot x
20:25 - [Music]
20:28 - step 3
20:29 - resolving the velocities into normal and
20:31 - tangential components
20:33 - so we're doing that by performing a dot
20:36 - product operation
20:38 - between the velocities of the bows
20:41 - and the u n and u t
20:44 - vectors that we already found
20:48 - back in our code let's write
20:50 - a comment
20:51 - uh project
20:54 - velocities
20:55 - onto
20:58 - the
20:59 - unit normal
21:01 - and unit
21:03 - tangent
21:04 - vectors
21:07 - okay let's go one by one so const v one
21:12 - n and that will be equal
21:14 - u n dot this dot velocity
21:19 - const v one t
21:21 - and that will be
21:23 - uh u t dot this dot velocity
21:27 - [Music]
21:29 - const
21:30 - v to n
21:32 - and that will be u n dot
21:36 - bo dot velocity
21:38 - [Music]
21:40 - and finally
21:42 - const v2 t and that will be equal
21:46 - ut
21:47 - dot
21:48 - ball dot velocity
21:50 - [Music]
21:54 - step 4 find new normal velocities
21:57 - we want to find the normal velocities
21:59 - after the collision and for that we can
22:01 - use the formula for collisions
22:04 - for elastic collisions in one dimension
22:06 - and because both of our objects
22:10 - have the same mass what we get here is
22:13 - rather simple
22:15 - if we just put our values inside we get
22:18 - that
22:19 - v tag
22:20 - v1 and tag tag means after the collision
22:25 - will be equals to uh will be equal to v2
22:28 - n
22:29 - and v2 and tag
22:31 - tag stands for after the collision will
22:34 - be equal to v1 and
22:37 - that we already calculated in the
22:39 - previous step
22:44 - so back in our code that will be
22:46 - pretty easy to implement
22:48 - so
22:49 - let's just write a new comment first
22:53 - find new normal velocities
22:57 - and
22:58 - we'll set um
23:00 - let
23:02 - v1 and tag
23:04 - be equals
23:05 - v to n and let
23:09 - v to n tag b equals v one n
23:17 - step five now we want to convert the
23:19 - scalar normal and the tangential
23:21 - velocities into vectors and for that we
23:24 - need to make some
23:26 - few multiplications between the vectors
23:28 - and the unit normals and the unit
23:30 - tangent
23:31 - that we calculated before
23:34 - so let's go back to the code and
23:35 - implement that
23:38 - so back in our code let's write a new
23:40 - comment
23:41 - convert
23:43 - the
23:44 - scalar normal
23:47 - and the
23:49 - tangential
23:52 - velocities
23:53 - [Music]
23:55 - into
23:57 - vectors
24:00 - so v1
24:01 - and
24:02 - tag
24:03 - will be
24:04 - um
24:05 - the unit normal
24:07 - multiplied by
24:09 - v1 and tag
24:11 - [Music]
24:14 - and let's set
24:16 - const v1t
24:20 - tag
24:21 - to be
24:22 - ut
24:24 - multiplied by
24:27 - v1t
24:30 - and let's set
24:32 - v2 and tag
24:34 - to be equal
24:37 - um
24:38 - un
24:39 - multiplied by
24:41 - v2 and tag
24:46 - and let's set
24:48 - const v2 t tag
24:51 - to be equals
24:52 - um
24:53 - the ut
24:54 - multiplied
24:56 - by v2 t
24:59 - [Music]
25:02 - step 6 the final step for now
25:05 - update velocities now we need to update
25:07 - the velocities of our ball objects
25:10 - according to the equations that you see
25:12 - right here in front of you
25:16 - so back in our code
25:17 - let's write a new comment
25:19 - and let's write update velocities
25:23 - yeah finally
25:25 - so
25:26 - let's set
25:27 - this.velocity
25:29 - to be
25:31 - v1n
25:33 - tag
25:36 - add
25:37 - [Music]
25:39 - v1t tag
25:43 - and
25:45 - ball dot velocity
25:46 - to be
25:48 - v to n tag
25:51 - dot add
25:53 - v to t tag
25:55 - [Music]
25:58 - and now let's set this dot moving to be
26:01 - true
26:02 - and let's also set ball dot moving
26:06 - to be true
26:08 - [Music]
26:11 - okay so now back in our browser let's
26:14 - test the results i'm really excited
26:16 - let's see what happens
26:18 - okay
26:20 - um
26:21 - so we do have collisions but we also
26:24 - have
26:25 - an issue here because you see that the
26:27 - balls
26:28 - kind of merge together
26:31 - and that's not good for us
26:34 - there is a way to fix that
26:36 - and
26:37 - let's do that let's fix that
26:41 - okay so back in our code we will need to
26:42 - find the minimum translation distance
26:45 - which is the minimum distance that an
26:47 - object a colliding object can be moved
26:50 - in order to
26:52 - not collide anymore with the other
26:54 - object
26:57 - so const
26:58 - minimum translation distance mtd will be
27:01 - equal
27:02 - the normal that we calculated before
27:04 - multiplied by the ball diameter
27:07 - minus
27:09 - the distance
27:11 - divided by the distance and i should put
27:15 - this part in parenthesis
27:21 - okay so now let's push and pull the
27:23 - balls apart
27:25 - um
27:27 - okay so let's do that by setting
27:31 - this dot position to be
27:34 - this dot position dot add
27:38 - and i will add
27:40 - the empty d
27:41 - multiplied by half
27:45 - and
27:47 - i will set ball.position to be
27:50 - the
27:51 - ball.position
27:53 - dot subtract
27:56 - mtd
27:58 - multiplied
28:00 - by half
28:02 - [Music]
28:06 - okay so back in the browser let's test
28:08 - the results and hey
28:11 - whoa this is actually working
28:14 - so let's try another one here
28:17 - yay great
28:20 - okay so even though the physics that we
28:22 - implemented in this game are 100
28:25 - correct we still got an issue here let
28:29 - me demonstrate and let's see if you can
28:30 - spot it
28:37 - ok did you get it
28:38 - let's watch that again in slow motion
28:41 - here you'll see that at the time of the
28:43 - collision some of the balls overlap each
28:46 - other and that happens because it
28:49 - detects the collision too late when the
28:52 - balls are already on the same area
28:55 - back in our code in order to minimize
28:57 - that unwanted effect i will try to tune
29:00 - some of the constants so let me start
29:02 - with the delta and let's set it to be 1
29:05 - divided by 177 and that's just the
29:08 - number that i came up with and let me
29:10 - just remind you that the delta defines
29:13 - how much of the ball's velocities we
29:15 - will add to the ball's positions on each
29:19 - iteration of the main loop
29:20 - [Music]
29:22 - now in the bose update method we will
29:24 - multiply the velocity
29:26 - by 0.984
29:29 - in the part of the code where we apply
29:32 - friction and let me just write it in in
29:34 - a comment
29:35 - so here we apply friction and again you
29:37 - can choose any number that suits your
29:38 - needs
29:40 - back in our browser now it looks much
29:42 - better
29:43 - but since we decreased the value of
29:45 - delta it seems like the stick doesn't
29:48 - hit the white ball with enough power so
29:51 - back in our code inside the increased
29:52 - power method of the stick class we will
29:56 - increase every time by
29:58 - 120
30:00 - and
30:02 - let's set a max power
30:05 - maximum power
30:07 - so if this dot power is greater than max
30:10 - power
30:12 - i want to return from this function
30:19 - and let me just set
30:22 - const
30:24 - max power
30:26 - to be for now 8 000
30:30 - now let's check the result and
30:34 - i don't know maybe we'll change it to
30:36 - 7500
30:41 - okay
30:43 - so
30:43 - i think that's better
30:46 - please take your time and tune those
30:48 - numbers until you will get a result that
30:50 - will satisfy you
30:52 - of course that's not a perfect solution
30:54 - to the problem but that will do for now
30:57 - if you want you can read more about
30:59 - something called quad trees and how to
31:02 - use it for collision detection but
31:04 - that's beyond the scope of this tutorial
31:09 - inside the game world i'm going to
31:10 - create a new member that i will call
31:13 - table
31:14 - and
31:15 - this dot table will be a new object
31:17 - literal
31:18 - that will contain the x and y values of
31:21 - the borders of the table
31:23 - [Music]
31:25 - so top y
31:26 - is 57
31:30 - and the right x value the right borders
31:33 - x value
31:35 - is
31:37 - 1443
31:39 - and the bottom
31:40 - y
31:42 - value
31:43 - is
31:44 - 706
31:49 - and
31:50 - the left
31:51 - borders x value
31:54 - is 57
31:57 - [Music]
32:01 - now inside the handle collisions method
32:03 - inside the first loop i want to write
32:05 - something like this dot balls at i
32:09 - dot collide with and it's instead of
32:12 - sending a ball i want to send a table
32:14 - the table that we created
32:17 - so in order for that to work i will
32:19 - create two more methods inside the ball
32:21 - class
32:23 - and the first one
32:25 - i will call
32:26 - ball dot prototype dot collide with
32:29 - ball
32:30 - and that will be equal a function that
32:32 - will get a ball
32:34 - as an argument
32:36 - and the second one will be
32:38 - ball dot prototype
32:41 - dot collide with table
32:45 - and that will be equal a function
32:48 - that will get a table
32:51 - as an argument
32:52 - so now let me just copy all the content
32:56 - of the collide with method that we wrote
32:58 - for ball to ball collision
33:01 - and let me paste that
33:03 - inside the collide with ball
33:06 - method that we just wrote
33:09 - [Music]
33:11 - and
33:14 - here i'm going to change
33:16 - uh the argument
33:18 - to be
33:19 - called object instead of bo
33:22 - inside the collide with method and i'm
33:24 - going to check if object is instance of
33:27 - ball and if it is i'm going to call the
33:30 - collide with ball method
33:32 - and i'm going to send this object
33:35 - and else
33:37 - i want to call
33:39 - this dot collide with
33:41 - table and
33:43 - to send the object
33:47 - [Music]
33:49 - okay so back in the browser we see that
33:51 - table is not defined
33:53 - so
33:54 - let's go back to the game world and
33:56 - instead of sending table we need to send
33:59 - this dot table
34:01 - and let's
34:02 - check again
34:04 - so again table is not defined and this
34:07 - time it's on the collide with method
34:10 - so here i sent
34:12 - um accidentally
34:14 - table instead of object
34:17 - so let's go back to the browser and
34:19 - let's refresh
34:20 - and see that everything still works
34:24 - yeah it does
34:26 - so back in our code in the collide with
34:28 - table method the first thing i want to
34:29 - do is to check if the ball is moving and
34:32 - if it's not i want to return from this
34:35 - function
34:36 - [Music]
34:37 - next i will set a new variable that i
34:39 - will call collided to be false
34:41 - [Music]
34:43 - and before i move on i need to
34:46 - create a new constant that i will call
34:48 - the ball radius
34:50 - and it will be half of the ball's
34:52 - diameter
34:57 - [Music]
35:02 - now i want to check if this
35:06 - dot position dot y
35:09 - is less
35:11 - or equal to
35:13 - the table dot top y
35:16 - plus
35:18 - the ball radius
35:24 - and if that happens i want to set the
35:27 - velocity
35:28 - to be a new velocity
35:31 - that its x value
35:34 - will be
35:35 - the same x
35:36 - value of the
35:38 - previous velocity
35:40 - and its y value will be
35:42 - minus this dot velocity dot y
35:49 - and i want to set
35:50 - collided to be true
35:53 - now let's test the results on the
35:54 - browser and that looks like it's working
36:00 - so now let's do the same thing for the
36:02 - right border
36:03 - so
36:04 - this should be
36:06 - x instead of y and this should be
36:09 - right
36:10 - x instead of top y
36:13 - and
36:15 - this should be
36:17 - greater or equal and this should be
36:19 - minus
36:20 - i hope you guys are following
36:23 - and here instead of
36:26 - minus this dot velocity dot y i need to
36:30 - make the x value to be
36:32 - minus the x value of the previous
36:35 - velocity
36:35 - [Music]
36:39 - so now let's refresh the browser and
36:41 - test the right border
36:44 - and
36:45 - that seems like it works
36:47 - so back in our code we need to do the
36:49 - same for the bottom one and the left one
36:52 - so let's start with the bottom
36:54 - and
36:56 - that should be greater or equal
37:00 - and that
37:01 - this should be bottom y
37:04 - and
37:05 - that should be minus the ball radius
37:09 - and the code inside should stay the same
37:13 - so let's refresh and let's test
37:17 - and that looks fine
37:23 - so now the last border
37:25 - let me copy that and paste that here
37:28 - and instead of
37:31 - um
37:32 - greater it should be less than or equal
37:35 - to left x
37:38 - plus
37:39 - ball radius
37:41 - and same here we don't need to change
37:43 - the code inside the if statement let me
37:45 - just refresh the browser and let's see
37:48 - and yet all the borders collisions are
37:52 - working
37:53 - so one final thing that i want to do
37:55 - inside this method is to decrease the
37:58 - velocity in case of collision
38:00 - so if collided
38:02 - so
38:03 - this dot velocity will be this dot
38:06 - velocity
38:07 - multiplied by
38:10 - 0.98 to simulate energy loss
38:14 - okay so let's test the results let me
38:17 - refresh and let's shoot the white ball
38:18 - towards the other balls
38:20 - and hooray
38:22 - so you can see that we pretty much
38:24 - finished implementing the physics for
38:26 - this game
38:27 - i'm sure there are still some bugs here
38:30 - and there
38:31 - but we'll find them on the go and we'll
38:33 - fix them all
38:34 - and
38:36 - this was it for this video thank you
38:38 - very much for watching it and stay tuned
38:40 - for more goodbye

Cleaned transcript:

hi everybody and welcome to the second video on a series that shows you how to build an 8ball pool game with javascript and html5 in the last video we implemented the shoot method on both the stick class and the ball class so that when we'll release the left button on our mouse it will shoot the ball towards the position of the pointer and we also display this shooting animation as you can see right here on the canvas okay so now i'll open the vector2.js file and there i want to add a method so i could get the length of a given vector so vector2.prototype.length and that will be equal a function and here i'm going to return the result of the length formula on the given vector and i'm going to calculate that using the math object of javascript okay great inside ball.js i want to add another property to the ball class that will indicate whether the ball is moving or not so this dot moving will be initially false and inside the update method i want to set it to be false if dot this dot velocity dot length is less than let's say five so if that happens i want to set this dot moving to be false and before that i want to set uh this dot velocity to be a new vector 2 so its x and y values will be zeros and inside the shoot method after i um change the velocity i want to set this dot moving to be true and i'm going to add another uh property to the stick class and i'm going to call this property this dot shot and initially it will be false maybe i can find a better name but for now that will do and inside the shoot method i want to um set this dot shot to be true and inside the game world uh we'll implement another method that i will call gameworld. dot balls moving and that will be equal a function and for now we only have one bow that this object contains so we'll return this dot white ball dot moving inside the update method so if all the balls uh stop moving so if um this dot balls moving and if um this dot stick dot shot is true um so sorry if not this dot balls moving i'll call a method inside the stick object that i will name reposition and i will send this dot white ball dot position so i want to reposition the stick to the new position of the white ball so let's open stick.js again and here i'm going to implement this method stick dot prototype dot reposition and that will be equal a function that will get a position as an argument and it will set this dot position to be a copy of this position the the position argument and i'm going to set uh this dot origin to be equal the stick origin constant a copy of it now back in the browser let me refresh and once the ball stops moving the stick changes its position to be the same as the new position of the white ball just one final thing before we move on on the reposition method that we just wrote let's set this dot shot to be false and let's see that everything still works as it should okay great in assets.js let's load some more sprites um so the first one will be the sprite of the red ball and the second one will be the sprite of the yellow bowl and the last one will be the sprite of the black ball now i will create a new file that will go by the name of color.js and there i'm going to define something that we call in other languages and enum and it will contain all the different colors that we use on our game so uh red yellow black and white and each color is going to have a different value back in assets.js i will implement a helper function that will provide me the sprite that i want based on the color that i will send it so i will call this function get ball sprite by color and it will get as an argument a color and here i'm going to um create a switch case statement so switch color and in case the color is color dot red i will return the red sprite okay so i filled it up with the rest of the colors and now we can uh go to the bowl class and change the function constructor so it will get a color as an argument and here i'm going to set the sprite this dot sprite to be get ball sprite by color and send the color that we got as an argument and here in the draw method we can just delete sprites dot white ball and send this dot sprite instead so now we have to go back to the game world and to send the color that we want for the white ball which is of course white and let's go to the index.html file and add a reference to the color.js file that we just wrote so script src and that will be equal color.js back in our browser everything still works fine in purpose of testing let's uh change the color to be red and let's refresh the browser and that also works great so let's change it back to be white as we want it to be okay so let me paste a bit of code here because i don't see the point of writing it all again what you see here in front of you is an array that contains all the different arguments that we need in order to create our ball objects so you can see that each element in this array is actually a pair that contains a position and a color and eventually we use the map function in order to take every parameter and to pass it into the bowl function constructor to create a new bowl so at the end of the day what you get is that this dot balls contains all the balls other ball objects that we need in our game so down here instead of creating a new object for the white ball member we can just refer it to the last object in the array that we just created and maybe we'll change it in future but for now that will do and down here in the update method we can just loop over this array and right for let i equals zero i is less than this dot balls dot length i plus plus and to call this dot balls at i dot update and to send the delta of course and let's copy that and paste that on the draw method so we can loop over the array and instead of calling the update method we can call the drill method so back in our browser finally you can see that our setup at least visually is pretty much complete and if i'll shoot the ball towards any direction really as soon as the white ball stops moving the stick repositions itself to the new position of the white ball okay so there's something that i need to fix before we move on now that we have more ball objects it's not enough to uh check only if the white ball is moving on the ball's moving method we want to uh loop over the array and to see if any of the ball object is moving so i will set a new boolean ball's moving to be false and let's loop over the array this dot balls dot length i plus plus and if this dot balls at i is moving we can set both moving to be true and we can break out of the loop now we will return both moving back in our browser let's see that everything still works yep that looks fine now in vector2.js we'll need to add some more operations to support the collision system that we're going to implement later on so um we'll add here a new um method so vector2.prototype.add and that will be equal a function that will get another vector and we're just going to return a new vector that will be the sum of both vectors so this dot x plus vector dot x and this dot y plus vector dot y let's add another one and let's call this one subtract and here i will return the subtraction result of this of the vector argument from this vector and the last one for now will be the dot product so vector 2 dot prototype dot dot that will be equal function that will get another vector and this function will return the result of a dot product operation between both vectors so that will be this dot x multiplied by vector dot x plus this dot y multiplied by vector dot y now let's go to our game world and there on the update method before we do anything we want to check if collisions occur so let's write a new uh method for that and let's call it on the update method let's call this method this dot handle collisions so um gameworld.prototype.handle collisions and that will be equal function and inside this function i want to loop over the array in a certain manner that will provide me all the possible pairs of objects so uh for let i equal zero is less than this.length i plus plus and inside the nested loop i'm going to declare let j be i plus one j is less than this dot both dot length i and i plus plus okay so inside this loop let's get the first ball out of the array so first ball that will be equal this dot balls at i and const second wall and that will be equal this dot both at j and i want to write something like first ball dot collide with um second ball and of course we need to implement uh this method in order for that to work let's see that everything is fine here um oh actually i have a mistake inside the nested loop and we need to increase j so j plus plus okay so now let's implement the collide with method inside the bowl class so bowl.prototype dot collide with and that will be equal a function that will get a ball as an argument okay so this is the moment we all have been waiting for elastic collision in two dimensions and before i begin i must give a huge credit to chad burchek who wrote an article about this subject in 2009 and this article explains everything in a very simple manner and even if you don't have a mathematical background i really encourage you to go and read this article i will leave a link in the description down below and really it's very easy to read and it's it explains everything um just beautifully so go and read this article one more thing that i want to say before we begin is that i'm going to provide you with steps on how to implement elastic collision in your code but i'm not going to get too deep inside the mathematical proofs and concepts okay so now that we're all set let's begin step one finding a unit normal vector a unit normal vector is a vector that has length of one which is perpendicular to the surfaces of the balls at the point of the collision in order to find the unit normal vector we need to find a normal vector first and we can do that by subtracting one of the ball's position from the other ball's position so back in our code in the collide with method let's find a normal vector and let's scroll down a little bit so it will be easier to see okay that's better so const n and that will be equal this dot position sub subtract and we'll send ball dot position from this normal vector we can also get the distance between the centers of both balls and this will indicate us whether a collision occurred or not so let's um find the distance and let's set const dist to be n dot length and if the distance is greater than the ball's diameter then we want to return from this function because there is no collision between both balls let's not forget to set another constant that will call ball diameter and in our case that will be 38. okay so now let's find a unit vector of n and we can do that by taking n and multiplying it by one divided by its length okay so now back in our code let's write a new comment and we'll declare here that um here we're going to find unit normal vector let's set uh const u n uh to be n multiplied by 1 divided by n dot length step 2 finding the unit tangent vector back to the drawing you can see that the unit tangent vector is a vector that has a length of one and is tangent to the surfaces of the balls at the point of the collision we can find it by using our unit normal vector that we already found we just take the x value to be minus u n dot y and the y value of the unit tangent vector to be u n dot x back in our code let's write a new comment finding unit tangent vector and we'll set const u t to be a new vector to object that its x value will be minus u n dot y and is its y value will be u n dot x step 3 resolving the velocities into normal and tangential components so we're doing that by performing a dot product operation between the velocities of the bows and the u n and u t vectors that we already found back in our code let's write a comment uh project velocities onto the unit normal and unit tangent vectors okay let's go one by one so const v one n and that will be equal u n dot this dot velocity const v one t and that will be uh u t dot this dot velocity const v to n and that will be u n dot bo dot velocity and finally const v2 t and that will be equal ut dot ball dot velocity step 4 find new normal velocities we want to find the normal velocities after the collision and for that we can use the formula for collisions for elastic collisions in one dimension and because both of our objects have the same mass what we get here is rather simple if we just put our values inside we get that v tag v1 and tag tag means after the collision will be equals to uh will be equal to v2 n and v2 and tag tag stands for after the collision will be equal to v1 and that we already calculated in the previous step so back in our code that will be pretty easy to implement so let's just write a new comment first find new normal velocities and we'll set um let v1 and tag be equals v to n and let v to n tag b equals v one n step five now we want to convert the scalar normal and the tangential velocities into vectors and for that we need to make some few multiplications between the vectors and the unit normals and the unit tangent that we calculated before so let's go back to the code and implement that so back in our code let's write a new comment convert the scalar normal and the tangential velocities into vectors so v1 and tag will be um the unit normal multiplied by v1 and tag and let's set const v1t tag to be ut multiplied by v1t and let's set v2 and tag to be equal um un multiplied by v2 and tag and let's set const v2 t tag to be equals um the ut multiplied by v2 t step 6 the final step for now update velocities now we need to update the velocities of our ball objects according to the equations that you see right here in front of you so back in our code let's write a new comment and let's write update velocities yeah finally so let's set this.velocity to be v1n tag add v1t tag and ball dot velocity to be v to n tag dot add v to t tag and now let's set this dot moving to be true and let's also set ball dot moving to be true okay so now back in our browser let's test the results i'm really excited let's see what happens okay um so we do have collisions but we also have an issue here because you see that the balls kind of merge together and that's not good for us there is a way to fix that and let's do that let's fix that okay so back in our code we will need to find the minimum translation distance which is the minimum distance that an object a colliding object can be moved in order to not collide anymore with the other object so const minimum translation distance mtd will be equal the normal that we calculated before multiplied by the ball diameter minus the distance divided by the distance and i should put this part in parenthesis okay so now let's push and pull the balls apart um okay so let's do that by setting this dot position to be this dot position dot add and i will add the empty d multiplied by half and i will set ball.position to be the ball.position dot subtract mtd multiplied by half okay so back in the browser let's test the results and hey whoa this is actually working so let's try another one here yay great okay so even though the physics that we implemented in this game are 100 correct we still got an issue here let me demonstrate and let's see if you can spot it ok did you get it let's watch that again in slow motion here you'll see that at the time of the collision some of the balls overlap each other and that happens because it detects the collision too late when the balls are already on the same area back in our code in order to minimize that unwanted effect i will try to tune some of the constants so let me start with the delta and let's set it to be 1 divided by 177 and that's just the number that i came up with and let me just remind you that the delta defines how much of the ball's velocities we will add to the ball's positions on each iteration of the main loop now in the bose update method we will multiply the velocity by 0.984 in the part of the code where we apply friction and let me just write it in in a comment so here we apply friction and again you can choose any number that suits your needs back in our browser now it looks much better but since we decreased the value of delta it seems like the stick doesn't hit the white ball with enough power so back in our code inside the increased power method of the stick class we will increase every time by 120 and let's set a max power maximum power so if this dot power is greater than max power i want to return from this function and let me just set const max power to be for now 8 000 now let's check the result and i don't know maybe we'll change it to 7500 okay so i think that's better please take your time and tune those numbers until you will get a result that will satisfy you of course that's not a perfect solution to the problem but that will do for now if you want you can read more about something called quad trees and how to use it for collision detection but that's beyond the scope of this tutorial inside the game world i'm going to create a new member that i will call table and this dot table will be a new object literal that will contain the x and y values of the borders of the table so top y is 57 and the right x value the right borders x value is 1443 and the bottom y value is 706 and the left borders x value is 57 now inside the handle collisions method inside the first loop i want to write something like this dot balls at i dot collide with and it's instead of sending a ball i want to send a table the table that we created so in order for that to work i will create two more methods inside the ball class and the first one i will call ball dot prototype dot collide with ball and that will be equal a function that will get a ball as an argument and the second one will be ball dot prototype dot collide with table and that will be equal a function that will get a table as an argument so now let me just copy all the content of the collide with method that we wrote for ball to ball collision and let me paste that inside the collide with ball method that we just wrote and here i'm going to change uh the argument to be called object instead of bo inside the collide with method and i'm going to check if object is instance of ball and if it is i'm going to call the collide with ball method and i'm going to send this object and else i want to call this dot collide with table and to send the object okay so back in the browser we see that table is not defined so let's go back to the game world and instead of sending table we need to send this dot table and let's check again so again table is not defined and this time it's on the collide with method so here i sent um accidentally table instead of object so let's go back to the browser and let's refresh and see that everything still works yeah it does so back in our code in the collide with table method the first thing i want to do is to check if the ball is moving and if it's not i want to return from this function next i will set a new variable that i will call collided to be false and before i move on i need to create a new constant that i will call the ball radius and it will be half of the ball's diameter now i want to check if this dot position dot y is less or equal to the table dot top y plus the ball radius and if that happens i want to set the velocity to be a new velocity that its x value will be the same x value of the previous velocity and its y value will be minus this dot velocity dot y and i want to set collided to be true now let's test the results on the browser and that looks like it's working so now let's do the same thing for the right border so this should be x instead of y and this should be right x instead of top y and this should be greater or equal and this should be minus i hope you guys are following and here instead of minus this dot velocity dot y i need to make the x value to be minus the x value of the previous velocity so now let's refresh the browser and test the right border and that seems like it works so back in our code we need to do the same for the bottom one and the left one so let's start with the bottom and that should be greater or equal and that this should be bottom y and that should be minus the ball radius and the code inside should stay the same so let's refresh and let's test and that looks fine so now the last border let me copy that and paste that here and instead of um greater it should be less than or equal to left x plus ball radius and same here we don't need to change the code inside the if statement let me just refresh the browser and let's see and yet all the borders collisions are working so one final thing that i want to do inside this method is to decrease the velocity in case of collision so if collided so this dot velocity will be this dot velocity multiplied by 0.98 to simulate energy loss okay so let's test the results let me refresh and let's shoot the white ball towards the other balls and hooray so you can see that we pretty much finished implementing the physics for this game i'm sure there are still some bugs here and there but we'll find them on the go and we'll fix them all and this was it for this video thank you very much for watching it and stay tuned for more goodbye
