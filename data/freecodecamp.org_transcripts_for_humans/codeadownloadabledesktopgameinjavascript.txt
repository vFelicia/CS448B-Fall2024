With timestamps:

00:00 - in this course JS Legend will teach you
00:02 - how to make a game in JavaScript with
00:04 - the capl library and how to use Tori to
00:07 - make it installable on a Windows PC JS
00:10 - Legend dev has created many popular
00:13 - courses hi everyone welcome to this new
00:15 - tutorial today I'll teach you how to
00:16 - make a desktop game in JavaScript so
00:20 - JavaScript is usually used for the web
00:22 - but with a technology called T you we're
00:25 - going to be able to make a game that is
00:27 - installable on your PC so we're going to
00:30 - use Tori and the capl library if you
00:33 - don't have any experience with both of
00:35 - them I'm going to explain everything so
00:37 - this tutorial is really for you in the
00:40 - sense the only prerequisites you need is
00:43 - a good fundamental understanding of
00:45 - JavaScript now let's get started so the
00:48 - game we going to build here is a Flappy
00:50 - Bird Style game so you jump here and
00:53 - then when you hit the obstacle you have
00:55 - your previous best score that is always
00:57 - written to dis so you have the concept
00:59 - of this save file and this is something
01:01 - I wanted to teach you because this is
01:02 - one of the main draw of having a desktop
01:05 - game in JavaScript is so that you can
01:08 - save your games so usually JavaScript is
01:10 - used for the web and in the web you know
01:12 - you have local storage but it isn't a
01:14 - very safe way to store data because as
01:18 - soon as the player clears their browser
01:21 - cache it's going to wipe out the save so
01:23 - this is one of the main aspect main draw
01:25 - of having your game as a desktop game if
01:28 - it grows above of a certain size and you
01:31 - need to keep track of save data so let's
01:35 - jump right into it so in this game one
01:38 - thing I forgot to mention is that we're
01:39 - going to have multiple inputs it's going
01:41 - to be a very simple game because I want
01:43 - to focus on the actual Tor Concepts and
01:48 - the capl concept so capl is the library
01:50 - for making games that is very easy it
01:52 - was called Kaboom Jaz previously if you
01:54 - want to know why the Rebrand you can
01:56 - watch the previous video by the way I I
01:59 - made a a lot of tutorials on Kaboom JS
02:01 - and how like C playay basically now how
02:03 - to make games with it so if you're
02:04 - interested feel free to watch those as
02:07 - well they are still relevant because the
02:09 - difference between capl and Kaboom is
02:11 - just the name for now all right
02:15 - so here we're going to implement
02:19 - keyboard controls so just by pressing
02:22 - the space button you can jump we're
02:24 - going to also Implement Mouse control so
02:26 - by clicking you can jump but also
02:28 - Gamepad control by pressing the South
02:30 - button you're going to be able to jump
02:32 - so uh this might sound strange what is
02:34 - the South button so look at this little
02:37 - schematic imagine this is a controller
02:39 - the South button is the button the
02:42 - action button that is always at the
02:43 - South here so it's a way that capl uses
02:47 - those terms so that it can be
02:49 - independent from the actual type of
02:50 - controller so an Xbox controller versus
02:53 - a PlayStation controller have different
02:55 - symbols on them but at the end of the
02:57 - day the x button is here for the
03:00 - PlayStation and the for the Xbox I don't
03:03 - remember actually here is it A or B that
03:06 - is down there but by just using the
03:08 - South name we can just have our uh game
03:13 - be agnostic regarding this so let's
03:16 - start the project so there are some
03:18 - prerequisites uh that you need to have
03:21 - so in terms of following this tutorial
03:23 - you only need to know JavaScript the
03:26 - basics but as for the installation
03:28 - process and also by the way I'm going to
03:30 - do this mostly on windows so the reason
03:34 - I'm doing this on Windows because this
03:36 - is the machine I have and also the
03:38 - expectation for games is usually that
03:40 - they run on windows so if you're going
03:42 - to publish a game on Steam it's really
03:44 - not worth your time to support Linux and
03:48 - Mac OS usually now maybe with protown uh
03:52 - with the steam deck it's it's changing a
03:55 - bit but
03:56 - yeah so you need to follow this um this
04:00 - page so it's going to be linked in the
04:01 - description it's the prerequisites so
04:04 - you need to set up this on windows by
04:07 - the way you can still follow this
04:09 - tutorial on Mac OS or Linux there are
04:12 - some instructions but at the end of the
04:13 - day the execut the executable you're
04:15 - going to get is not going to be the one
04:17 - for Windows so here we're going to set
04:19 - up Windows uh now here I have the link
04:24 - in the description follow the
04:25 - instruction here you have a few things
04:27 - to install so one thing I want to
04:29 - mention is the web view2 thing so Tori
04:33 - compared to electron which is another
04:35 - solution technology for basically making
04:37 - desktop apps using JavaScript HTML and
04:40 - CSS is that with electron it packages a
04:43 - whole Chrome browser for each version of
04:46 - your app so if if it's on Linux or Mac
04:49 - OS Etc it's always going to package a
04:52 - fixed version of Chrome and the
04:54 - advantage of that is that your app is
04:56 - going to be rendered the exact same way
04:59 - regard regardless of the platform
05:01 - however the drawback of this is that
05:03 - it's going to make your app bloated so
05:06 - because electron has to package a whole
05:09 - Chrome browser that means an executable
05:11 - that does basically nothing so a project
05:14 - empty project is going to be I think 100
05:16 - megabytes now with Tori the actual end
05:19 - game like the full game uh that I've
05:22 - shown you earlier is only 6 megabytes so
05:24 - you can see that it's really not bloated
05:26 - and the way Tori achieves this is by
05:29 - have using the systems web view so for
05:31 - each operating system they have a web
05:33 - view that Tori uses but the issue is
05:37 - that is that you cannot really make sure
05:39 - that the app is going to be rendered the
05:41 - same way on all platforms because uh you
05:45 - know different browser engines have
05:47 - different particularities it's mostly
05:49 - the same but not it's not exactly the
05:51 - same the reason I'm going to use Tory
05:54 - for this tutorial is because it was very
05:56 - easier to set up than electron less
05:59 - bloed since uh on Windows and also on
06:03 - other platforms but the most important
06:05 - aspect that uh basically determined that
06:09 - I wanted to use Tori instead of electron
06:11 - is the fact that I really am targeting
06:13 - Windows only for this project so I don't
06:17 - really care or feel any of the drawback
06:21 - of the fact that it's not exactly the
06:22 - same browser engine on the various other
06:25 - platforms because I'm not publishing to
06:27 - other platforms all right so once you
06:28 - follow this so you install and by the
06:30 - way another drawback perceived drawback
06:33 - is that it needs to have this web V2
06:36 - runtime install on the users ma machine
06:39 - that is going to use the app but now it
06:43 - should be available on all windows 11 uh
06:47 - PL uh operating systems distributions
06:50 - but not on Windows 10 uh or certain or
06:53 - Windows 7 I think and then the reason
06:56 - for that is well it's it's not available
06:58 - by default and if you were to just
07:00 - distribute aexe made with Tori then this
07:04 - would be an issue because you would have
07:05 - to make sure that the user has the web
07:08 - view to install on their machine now
07:10 - this is not an issue in the end because
07:12 - we're going to distribute the installer
07:14 - the MSI and this installer that we get
07:17 - after building the project is going to
07:19 - install this web view2 runtime on the
07:21 - user's machine if it's not already
07:23 - available so you don't have to worry
07:25 - about
07:26 - anything and yeah you need to install
07:28 - rust even though in this tutorial we're
07:30 - not going to use it really we're just
07:32 - going to well we're going to R write
07:34 - some commands but we're not going to
07:36 - write rust basically it's just the
07:39 - project itself is built with rust
07:42 - because there's a JavaScript API that
07:44 - you can use to read and write to a file
07:46 - which makes it very beginner friendly I
07:50 - guess all right so follow this and once
07:53 - you have uh followed the prerequisites
07:56 - for your platform let's jump right into
07:58 - the project
08:01 - all right so what are how do we start a
08:03 - project so also you have to have nodejs
08:06 - installed this should have been
08:07 - mentioned in the prerequisites link that
08:10 - I've shown you earlier on so you need to
08:13 - run npm create t-a at latest dot here if
08:17 - we're in a folder so I'm using vs code
08:20 - as my editor I have created this kbby
08:22 - folder because creb is the name I've
08:24 - chosen for this project and then once
08:27 - I'm in this project I can use the dot
08:29 - notation here so that it's it's going to
08:32 - create the project files within the the
08:35 - current folder I'm in if you were to
08:37 - emit this it would create a different
08:39 - folder for you so run this
08:43 - command and then maybe I should increase
08:45 - the font size already just to make sure
08:49 - that everything is visible and then the
08:52 - package name you have to specify your
08:53 - package name I'm going to call it kbe uh
08:58 - tutorial actually just creepy I'm going
09:01 - to use typescript and JavaScript this
09:03 - project uses JavaScript but you need to
09:05 - use like which one for your front end
09:06 - you want and then npm and then here do
09:09 - not select the vanilla UI template
09:12 - because the vanilla UI template is just
09:14 - going to be a build lless HTML CSS in
09:18 - JavaScript so we still need to use a
09:20 - build system because it's very it's more
09:23 - convenient to install and use the um Tor
09:27 - API that way so I'm going to take the
09:29 - react template but I'm going to remove
09:31 - everything that is related to react for
09:33 - this project and then choose JavaScript
09:38 - here all right so we have everything we
09:40 - need now I'm going to open up the
09:43 - package.json and you can see that we
09:45 - have a couple of dependencies we going
09:47 - to need to
09:48 - remove so we're going to need to remove
09:50 - react and react D because we're not
09:52 - going to use them so I'm going to type
09:53 - in npm uninstall react and then react D
09:59 - all right right the package have have
10:00 - been uninstalled and then I'm going to
10:03 - also uninstall this vgs plug-in react we
10:06 - don't need that as well so I forgot to
10:09 - do that so let's do it here we go
10:13 - npm
10:15 - uninstall
10:17 - uninstall here we go and then that's it
10:20 - and now we can install the cap playay
10:22 - Library so cap playay can be installed
10:25 - in many different ways it can be
10:27 - installed using a script tag uh much
10:29 - like I did with Kaboom Jazz but for this
10:31 - project since we're using vit inside of
10:33 - it we're just going to use npm npm
10:36 - install C play and I'm going to install
10:39 - a specific version this is uh I'm making
10:42 - sure to pin the version here so that if
10:44 - you're watching this in the future it's
10:47 - going to always work this tutorial at
10:49 - least so it's a selfcontained so 3,000
10:52 - that's the version
10:54 - 0.1.7 U if you're not familiar with KL
10:57 - and Kaboom it works in thousand so
11:00 - version 1.0 is actually one version
11:02 - 1,000 version 2.0 is 2,000 version 3.0
11:06 - is 3,000 this is the the the naming
11:09 - convention that I used it say it's
11:12 - strange but I don't know the reason why
11:14 - but yeah that's it it is what it is so
11:17 - I'm going to hit npm install cap play
11:20 - with this
11:23 - version now we have capl installed let
11:27 - me check in the package.json
11:29 - and here we go okay so before we do
11:33 - anything I'm just going to collapse this
11:34 - I'm going to collapse this as well and
11:37 - I'm going to go
11:39 - to here so here to run Tor you need you
11:44 - have this Tory command just to make
11:46 - things convenient for us we're going to
11:49 - have rename those commands so we're
11:52 - going to have Dev do do browser and Dot
11:57 - browser here to differentiate from the
11:59 - two other commands I'm going to write
12:02 - here so I'm just going to do
12:07 - preview this is just a name I have
12:09 - decided for myself but here instead of
12:11 - having Tori here we just going to have
12:15 - when I run npm run Dev I want to run Tor
12:19 - Dev which is going to actually start the
12:21 - application and the reason we're doing
12:23 - this is because we have two systems
12:24 - going on we have vit which is a bundler
12:26 - that bundles your web code and then puts
12:29 - it on a local host that you can use and
12:32 - then there's Tory which takes this
12:34 - output at the same time and puts it in a
12:38 - desktop app desktop window so that's why
12:41 - we have those two commands even though
12:43 - for this project we're not going to use
12:44 - vit directly like that we're going to
12:46 - use Tori
12:47 - Dev so the other command is build and
12:52 - Tori
12:53 - build so just to check that everything
12:56 - works uh but because we are using the
12:59 - react template I'm going to remove
13:02 - everything that is within
13:05 - here so let's remove all of those files
13:09 - I'm going to also remove everything
13:10 - within the oh oops within the public
13:14 - folder
13:17 - oops all right delete this all right now
13:22 - we have the the
13:23 - index.html we don't really need much
13:26 - here I'm going to remove this I'm going
13:28 - to remove the head tag I'm going to
13:30 - remove it the HTML I'm going to remove
13:33 - even this it's it doesn't
13:35 - matter and then here instead of jsx it's
13:38 - going to be JS and then in the source
13:40 - file I'm going to create a main.js file
13:43 - now in main.js I'm going to call what we
13:47 - need for cap play so I'm going to import
13:50 - cap
13:52 - play from cap
13:56 - play and then oops and then here I'm
14:00 - going
14:01 - to initialize the capl context which is
14:04 - basically creates the canvas for us you
14:06 - call the cap playay function like that
14:09 - and then pass in a a bunch of options
14:11 - the width of the canvas is going to be
14:15 - uh
14:16 - 1,280 by the height which is
14:19 - [Music]
14:21 - 720 and then here I'm going to use the
14:24 - letter box options those are all options
14:26 - that comes from Capa so here letter box
14:29 - true makes our game our game will scale
14:32 - regardless of the Windows size while
14:36 - maintaining the aspect
14:39 - ratio and then here I'm going to put
14:42 - whenever or not we want this to be
14:44 - Global to be false so we don't want capl
14:48 - functions to be available globally we
14:51 - want to all capl functions to be
14:53 - callable from the K the context this
14:56 - will make our code
14:57 - cleaner and then we you want to scale
15:00 - the canvas two times this is what looked
15:02 - good uh and then this is for everything
15:05 - within the canvas it's going to become
15:07 - relevant later on so let's do that now
15:10 - let's go back to the terminal and run
15:14 - npm run Dev and then here it's going to
15:18 - compile your project and then you're
15:21 - going to have to wait a bit before it
15:23 - compiles and usually you're if you
15:26 - modify things related to Tor config I'm
15:29 - going to go over the file here then the
15:31 - application will have to close and
15:33 - reopen otherwise if you just modify
15:35 - JavaScript content here a code here it's
15:39 - it's usually it should usually hot hot
15:41 - reload I have something messed up I need
15:43 - to modify something in the Tor file
15:48 - here yeah here you should
15:52 - run the dev browser and then build
15:57 - browser and so really the preview
15:59 - command it doesn't
16:01 - matter so I'm just going to cancel this
16:03 - out and then everything should work all
16:05 - right so if I do
16:11 - this and
16:14 - then okay what's the
16:17 - issue cannot find the package VJs
16:20 - plug-in react so here let's remove
16:22 - everything related to react in the v
16:25 - config because we have removed it so
16:28 - everything should be like that and
16:30 - now just so you can see uh I removed
16:33 - this and another option called plugin
16:37 - react so now let's run
16:43 - it hopefully it works this time around
16:46 - yep when you see Local Host and then
16:49 - it's
16:52 - compiling and then downloading the
16:54 - various crates we need this this is only
16:56 - done the first time I think
16:59 - and then it's building yeah so it might
17:01 - take some time it's a bit slow at but
17:04 - this is only like the first time all
17:06 - right so it was a bit slow but it's the
17:08 - only once you do this and then now it
17:12 - should hopefully open up and here we go
17:15 - we have our window with our canvas and
17:19 - then if you press F12 so let me just
17:22 - increase that a bit if I press F12
17:26 - you'll have your console this ignore
17:29 - this we just remove the favicon it
17:31 - doesn't matter since it's a desktop
17:34 - application and yep so we're ready to
17:36 - start working on the game so let's try
17:39 - let's import our assets so I'm going to
17:41 - close this by the way you can just leave
17:43 - it open like
17:45 - that so here we go I'm going to go
17:50 - here and for the assets let's we're
17:53 - going to put them all in the public
17:55 - folder all right so I have imported all
17:58 - the assets sets you're going to find a
17:59 - link in the description or multiple
18:01 - links in the description to get
18:03 - everything here so I'm going to go over
18:05 - everyone so this is the background.png
18:07 - for our game clouds we're going to have
18:10 - a colliders data. Json which basically
18:13 - defines the hitbox for every platform uh
18:17 - obstacle so the the height and width of
18:19 - that hitbox and where to put it so the X
18:22 - and Y cordinates uh this is better I
18:25 - thought it would be better than having
18:26 - to pull an external editor like if you
18:29 - want interested in how to make like more
18:31 - serious games using an external editor
18:34 - called tiled watch the previous tutorial
18:36 - I made on the channel here are a few
18:39 - sounds we have the confirm sound so when
18:42 - you click on the button the HT sound and
18:44 - the jump sound those are made using a
18:46 - website called GS fxr.com
18:58 - obstacle layer here so the obstacles and
19:02 - then one thing also is the icon so here
19:04 - you can provide a bunch of different
19:06 - icons and there's a an icon command in
19:09 - Tori but for this project since it's I
19:12 - only care about Windows I just imported
19:16 - this icon for my project so just you'll
19:20 - find this in the description just put it
19:22 - in the under the source dtory and then
19:25 - icons folder here all right so if I look
19:28 - at the project you can see the icon
19:30 - appears here now all right I'm going to
19:33 - minimize this and we're ready to start
19:35 - working on our
19:37 - project so let's go back to the source
19:40 - folder and then in main.js so the first
19:43 - thing I'm going to do is to actually
19:45 - load bunch of our assets the way you do
19:47 - that in capl is to call either the load
19:51 - Sprite function or the load sound
19:54 - function there's also the load found
19:56 - function uh not F font
19:59 - sorry so load Sprite works this way so
20:02 - you pass in the name of the Sprite you
20:04 - want to use so kby this is going to be
20:07 - the the key that we're going to refer to
20:09 - in our code base and then the second
20:13 - param is the actual Pam so the Pam here
20:17 - is going to be the path to the assets
20:21 - which is going to be kb. PNG Dash cre so
20:24 - the reason it's just a dash is because
20:27 - when working with vit the public folder
20:29 - can be will automatically be linked to
20:32 - the root of the project so you don't
20:33 - have to write public SL
20:38 - k.png so that's the first one and that's
20:42 - basically it for the Sprite so I'm going
20:44 - to copy and paste the rest that you need
20:46 - here so load Sprite obstacles
20:48 - backgrounds and clouds much the same way
20:51 - for the sounds it's similar but the only
20:53 - thing that CH changes is that you use
20:56 - the load sound method instead
20:59 - all right one thing I want to implement
21:01 - right off the bat is to allow the player
21:04 - to go into full screen so for now if you
21:07 - press f11 which is us usually the
21:10 - keyboard shortcut for going full screen
21:12 - well it doesn't work so to implement
21:14 - this we're going to have to use the Tori
21:18 - API so Tori allows you to use a
21:21 - JavaScript API instead of rust if you
21:24 - want to do things that touches the
21:26 - native like Windows system like the the
21:29 - native app system so writing to a file
21:32 - changing the full screen etc those are
21:34 - things handled by the game window itself
21:38 - so you have this file called T.C com.
21:41 - Json which handles all the permissions
21:44 - to what you're allowed to do all right
21:46 - so you have a bunch of permissions and
21:48 - the permissions we're going to use here
21:50 - we going to need to edit is two things
21:53 - so here in our tor.com Json go to the
21:56 - Tor and then allow list uh um property
22:00 - and then here we're going to have two
22:03 - things so we're going to use the fs key
22:06 - for file system and allow us to read a
22:09 - file so said this true to write a file
22:13 - to write to a file set also this to
22:17 - true and the scope so the scope is here
22:22 - is let me just put it
22:26 - scope and then I'll explain
22:29 - so and then add a com so what is this um
22:33 - later on in the project we're going to
22:35 - need to write the save data as the save
22:37 - files basically uh this is a score
22:40 - actually I'm going to need to write this
22:42 - to disk so that when the player plays
22:44 - again some other time we know what their
22:46 - best score is always and for that we
22:50 - need to be able to write to a file and
22:52 - read to a file and here the way Tori
22:54 - works is that you need to enable each
22:57 - permissions each either you enable
22:59 - everything by using the All property or
23:02 - for each of those apis you enable what
23:05 - you need and usually the the best
23:07 - practice is to always enable what you
23:09 - only need and the scope here is the
23:12 - files the folder you're going to have
23:14 - access to only and here we're going to
23:17 - need to set pass in the app local data
23:22 - folder and by having this notation so
23:26 - everything in the app data local now the
23:28 - app local data folder is going to be
23:32 - accessible to our Tori
23:35 - application so we're going to be able to
23:38 - write to any file or or yeah write to
23:42 - any file within that folder or read any
23:45 - file within that F folder and the dot
23:48 - star here is for that as well so here
23:51 - this constant or this um name comes from
23:55 - the Tory documentation there there are
23:57 - various uh constant like that and it
24:00 - refers to if you go on Windows and you
24:03 - type in run in the command start the you
24:07 - know the windows the search bar on
24:08 - Windows to the left you and you type in
24:11 - run and then here you type in app data
24:15 - and you have a local local low and
24:17 - roaming and if you go to the local
24:19 - folder this is where maybe you're not
24:21 - seeing it maybe I can
24:23 - zoom y I can see so in this local folder
24:26 - you're going to have a folder that is
24:28 - the name of your application and in that
24:31 - folder everything you can read and write
24:34 - within that folder let's replace this
24:36 - with kby kb. game and then if you do
24:42 - this if you
24:44 - refresh uh it's going to rebuild it here
24:46 - you can see that we have this if you
24:49 - look at the path appdata local and then
24:50 - kb. game was created automatically by
24:53 - the application when it runs for the
24:55 - first time or when when it is installed
24:58 - so here is everything we're going to
25:00 - write the save file here we're going to
25:01 - read it from here Etc hope that was
25:05 - clear so now yeah replace the identifier
25:08 - make sure everything is saved and uh the
25:11 - other permission we need though is for
25:13 - with the windows permission so window
25:15 - permission and the exact permission we
25:18 - need to be able to set this to full
25:20 - screen is the set full screen permission
25:25 - and I'm going to set this to true so now
25:27 - if I go go back to
25:29 - main.js and I go here down below we can
25:34 - write the logic we
25:35 - need to make the window Go full screen
25:40 - when the f11 key is pressed so I'm going
25:43 - to add an event
25:45 - listener so you can do this in two
25:48 - ways either you do document or add event
25:52 - listener or you can
25:54 - just call add event listener directly
25:57 - like that
26:00 - and then here a key down event we want
26:02 - to listen to and we need an async here
26:05 - because the API the Tori API is
26:10 - asynchronous so here we going to have an
26:13 - EV for the event or we could call it
26:16 - event if you
26:17 - want and then here if the event code
26:22 - equal equal
26:23 - f11 that means the key was pressed so
26:27 - actually here a better name would be the
26:29 - key and then key. code is f11 key if
26:35 - this is pressed we're going to have
26:38 - first an if statement that is going to
26:40 - call this API so app window and you can
26:44 - see here app window it's going to import
26:47 - it from the Tor API so click on that it
26:49 - should import it at the top of your file
26:52 - and then here what will
26:55 - happen is that first you check if if
26:58 - it's full screen so is full screen you
27:01 - use this this is from the API if it's if
27:04 - it turn out turns out to be the case
27:07 - then we're going to set it back to not
27:12 - being full screen so the F1 key uh acts
27:15 - usually as a toggle so we can use the
27:18 - set full screen F function that we
27:20 - allowed the permission for in t.c. Json
27:23 - to turn it off so with false and then we
27:27 - have an
27:28 - another if statement here actually we
27:32 - should return early so if I have this
27:35 - like that I put it within
27:38 - brackets and we return
27:41 - early and then here down below if that
27:44 - was not the case that means that the app
27:47 - window is not full screen so I can just
27:49 - do app
27:50 - window and of course don't forget to
27:53 - await well actually it's not necessary
27:54 - to await here because there we don't do
27:57 - anything afterwards so set full screen
28:01 - and then set test to
28:03 - true so here we needed to await so that
28:07 - we don't move on we don't return before
28:10 - we are sure that actually yeah we don't
28:13 - return before we are we are sure that
28:15 - the the app was set to full screen in
28:18 - this case it doesn't I don't think it
28:20 - really matters but here it would matter
28:23 - because otherwise we would return a
28:24 - promise and not the actual value so yep
28:29 - okay so let's test it out so I'm going
28:31 - to open the application it is here now
28:33 - I'm going to press f11 and we can see
28:35 - that it is full screen now if I put it
28:38 - back here it's not
28:40 - anymore all right so now let's actually
28:42 - start working on the game and we're
28:45 - going to create two scenes so in cap
28:47 - playay the way you create a scene is by
28:49 - calling the scene method or function and
28:51 - then giving it a name and then passing
28:55 - as the second param a function that is
28:58 - going to contain the logic for that
28:59 - scene so we going to need two scenes we
29:02 - going to need the first scene called
29:04 - start which is the menu and then the
29:06 - first the second scene I'm going to call
29:08 - it main it's going to be the actual
29:10 - content of the game and then I'm going
29:13 - to call the go function which will go to
29:16 - the start scene when the game
29:19 - starts so start function main function
29:22 - and and uh start scene main scene Etc so
29:24 - I'm going to
29:25 - write a new file here I'm going to call
29:28 - it ut. JS it's just going to contain a
29:31 - few utilities that are going to be used
29:34 - uh for now we're just going to create a
29:36 - function that makes the background a
29:39 - certain color so I'm going to call make
29:41 - I'm going to call it make background I'm
29:42 - going to pass in the K context so I
29:44 - don't have to import K everywhere which
29:47 - is the c cap playay context and then I'm
29:49 - going to call the add function so the
29:52 - way cap playay works is that you create
29:55 - game objects using the add function and
29:57 - passing it an array of components so the
29:59 - array of components you pass in which
30:01 - usually are components that are offered
30:03 - by kipl they will then come together to
30:07 - create a game object with specific
30:09 - behaviors and properties so here I'm
30:11 - going to use the rectangular component
30:14 - from capl I'm going to call the width
30:17 - method and height method so that this
30:18 - rectangle takes the full height and
30:21 - width of the
30:22 - canvas I'm going to set the color by
30:25 - using the color component of that
30:27 - rectangle so I'm going to set the color
30:30 - using the color
30:32 - component H for the rectangle so it's
30:34 - not a color component of the rectangle
30:37 - it's just a color component offered by
30:39 - kaboon that allows you to modify the
30:41 - color of a game object so here I'm going
30:44 - to call the from heex method which can
30:48 - be accessed like this and allows us to
30:51 - specify a heximal value so by default
30:54 - the color components takes RGB values
30:56 - which mean three params uh that can vary
31:00 - from 0 to
31:01 - 255 but we want a specific color and the
31:04 - hexa usually in pixel art or in art you
31:07 - use hexadecimal instead of like RGB to
31:10 - specify colors so that's why what I
31:12 - prefer to use and then finally we're
31:16 - going to have a last component from KL
31:19 - again called the fixed component which
31:20 - will make the actually yeah yeah which
31:24 - going to make the the background
31:26 - independent from the camera because the
31:27 - camera is going to follow the player but
31:29 - by the way I think this is useless
31:31 - because in a Flappy Bird Style game the
31:36 - main the player never moves actually
31:38 - they just jump and it's the platforms
31:40 - that moves or the obstacles that moves
31:43 - towards them so this component is not
31:45 - necessary so let's use that in our main
31:50 - in our first scene the start scene I'm
31:51 - going to just going to call it make
31:53 - background and pass in the K here
31:56 - context that comes from here
31:58 - now if I look at the result you can see
32:01 - that here we have bars here that does
32:03 - are the just the the black bars and then
32:06 - you have the appropriate color I prefer
32:08 - my black bars here to be black and not
32:10 - white so here in the body I'm just going
32:13 - to have a style
32:14 - tag we're not going to spend too much
32:17 - time in CSS just one thing body a
32:19 - selector and then set that to being
32:22 - background color and then black so now
32:26 - it will look much nicer y I think this
32:29 - is better so now what comes next is to
32:31 - actually draw the background so I'm
32:34 - going to create something called a map
32:36 - game object it's going to act as the
32:38 - parent of all the game objects that are
32:43 - props or obstacles clouds Etc they're
32:45 - going to be all CH children of that
32:49 - singular map game object so this is a
32:51 - feature that allows you to do is to
32:53 - create game objects but also to have
32:56 - child game objects and parent game
32:58 - object so here we create a parent game
33:00 - object like a usual game object with the
33:02 - add function and we pass in the
33:04 - following array of components we can use
33:07 - the Sprite component offered by Klay and
33:09 - then you specify the key for the Sprite
33:11 - Which was defined earlier on in the load
33:14 - Sprite function so here I'm going to
33:16 - have the
33:17 - background as the Sprite I want to use
33:20 - for this game object I also have access
33:22 - to the positional component which allows
33:24 - us to set the position of our game
33:28 - object here z z because it's the
33:31 - background want it to be at the origin
33:33 - and by the way in game development
33:35 - things are drawn from the top left
33:37 - corner uh unless you
33:39 - specify the center to be the origin of
33:42 - the Sprite or the game
33:44 - object and then finally I'm going to
33:46 - actually scale our game here so here I'm
33:50 - going to use a I'm going to create a
33:52 - constants DJs file
33:56 - constants count uh constants DJs I'm
34:01 - going to export const and I'm going to
34:04 - call it scale factor because the the
34:07 - pixel art is going to be too small so
34:09 - for things to be visible I'm going to
34:12 - have to scale things a
34:15 - bit now you have two options actually
34:18 - either let's scale it four times either
34:21 - you make the camera zoom in or you make
34:24 - the Sprites scale so either one should
34:28 - work so scale
34:30 - factor is going to be the thing I'm
34:32 - going to use here don't forget to import
34:34 - it otherwise you're going to have an
34:35 - error so I'm going to import
34:39 - import
34:41 - import
34:43 - scale
34:45 - factor
34:48 - from whoops
34:50 - from
34:52 - constants now did I get this right
34:58 - export yep should
35:00 - work okay now let's go back to
35:04 - main so we should have our game object
35:07 - it should appear on the screen and you
35:09 - can see that we have our background
35:10 - looks pretty
35:12 - nice now we're going to have to add the
35:14 - clouds and the way I'm going to go about
35:16 - this is I'm going to create the clouds
35:20 - as a child game object of the map so the
35:24 - way I do this is by having a call to
35:28 - map. add so every game object has also
35:32 - the add function as a method that allows
35:35 - you to create game objects but this time
35:37 - they are a children of that game object
35:40 - instead of a global game object and here
35:43 - I'm going to again have a Sprite
35:47 - component where the
35:49 - clouds and when you create a child game
35:52 - object what happens is that their
35:55 - position is relative to the parent game
35:57 - object which is pretty
35:59 - handy here however we are going to need
36:02 - to call the positional components so
36:04 - that we can have access to the position
36:06 - and be able to set it if you don't do
36:08 - that you cannot modify the position so
36:10 - even though I don't need to specify a
36:12 - value here because I just want to later
36:13 - on modify the cloud so they move in a
36:16 - certain direction uh I still need to
36:18 - call the Sprite uh the positional
36:23 - component and now the last one I think
36:27 - we
36:28 - here in Kaboom JS what's handy and
36:30 - allows you to get away with not using
36:32 - classes Etc is that each game object can
36:34 - have as part of their ARA of components
36:37 - an object which you can specify in their
36:40 - its properties so here I'm going to
36:43 - specify the speed property as being a
36:44 - five so it's going to be the the rate at
36:47 - which the clouds are going to move so
36:49 - here I'm going to store the reference to
36:51 - those clouds here because by default
36:54 - when you all create a game object using
36:56 - the ad it always returns that game
36:58 - object even as a child of another game
37:01 - object it will return the child game
37:04 - object object and here we have multiple
37:06 - clouds and not just one under the same
37:08 - image so that's why it's the Cloud's
37:10 - game object and not every individual
37:12 - Cloud as game object which is better for
37:14 - performance reasons so here what I'm
37:16 - going to do is I'm going to use one of
37:20 - the other methods that are available is
37:23 - the onupdate methods on every game
37:25 - object which runs this function every
37:29 - frame so usually 60 frames 60 times per
37:33 - second so here I'm going to
37:38 - use the clouds move method which is also
37:42 - offered by Klay on game object which
37:44 - allows you to just move a game object
37:48 - along the X and Y coordinates at a
37:50 - certain rate so here I can use the speed
37:52 - I've defined earlier on and access it
37:54 - like this so the game object name do the
37:57 - property T and then here it's going to
37:59 - be as the first bam that means it's
38:01 - going to move to along the x axis uh
38:05 - yeah positively so to the right and then
38:08 - for the y- axis I don't want to change
38:11 - this the speed so it's going to be
38:14 - zero and now here right below what we're
38:18 - going to do is a clever trick so for now
38:20 - if I run
38:22 - this the clouds are moving to the right
38:25 - and then once they are fully gone to the
38:27 - right they'll never come back so what
38:29 - I'm going to do is I'm going to use a
38:30 - clever trick is I'm going to make sure
38:32 - that once the Cloud's uh position cloud.
38:36 - pause you can access the position this
38:38 - way and that's why I needed to to use
38:40 - the pause component if you didn't use
38:42 - that you wouldn't be able to access the
38:44 - current position so if the cloud clouds.
38:47 - position is uh X because it offers you
38:50 - both the X and Y value but we only need
38:53 - the x value is superior to 700 which is
38:57 - when when they leave the frame the the
38:59 - visible area of the canvas then we're
39:02 - just going to set back the position of
39:05 - along the xaxis to be of minus 500 the
39:08 - reason we do this is is they go all the
39:11 - way back to the left immediately they
39:12 - teleport back to the left and then they
39:15 - will continue their movement so
39:16 - basically we have infinite clouds that
39:18 - uh go from left to right so if I go here
39:22 - now here I'm not going to wait uh for
39:24 - this to be done but you you'll see
39:26 - you'll notice while playing game the
39:28 - final game that as the CL clouds move to
39:31 - the the right and they moved fully to
39:34 - the right so that they are no longer
39:36 - visible they're going to appear back
39:38 - from the left because they are
39:39 - teleported back so now the last thing we
39:42 - need for that scene is
39:44 - to add the obstacle as another game
39:47 - object to the map and here we're going
39:49 - to need the
39:50 - Sprite obstacles so the obstacle
39:54 - Sprite and
39:57 - I think that's it and by the way because
39:59 - initially we scaled the map game object
40:02 - the parent game object everything else
40:04 - the the children are also going to get
40:06 - Scaled by the way forgot to mention that
40:09 - for the last game object the obstacle
40:10 - game object we're going to have to
40:11 - specify the position as well by using
40:14 - the position component but not ex not
40:16 - necessarily passing in a value because
40:18 - we're going to modify this value later
40:20 - on and read
40:21 - it and here we're going to use the area
40:24 - component which is also offered by KL
40:27 - and allows you to specify a hitbox for
40:29 - your game object actually you know what
40:32 - I think it's not necessary here because
40:34 - the hit boox is going to be dependent on
40:37 - something else but for this yeah here in
40:40 - this case we don't need it we don't need
40:42 - it going to see when we're going to need
40:44 - it later
40:46 - on and uh that's it or maybe yep that's
40:51 - it I think that's
40:52 - it yeah so yeah we we don't need
40:56 - anything El so if I look at the app you
40:59 - can see so basically what we're building
41:02 - here in the start is the start menu
41:04 - basically that's it so we're going to
41:07 - put the the creb character here and the
41:10 - play button and then actually in the
41:12 - main is actually where we're going to
41:14 - write the actual Logic for jumping Etc
41:17 - what we're going to do now is create a
41:20 - player. JS file which is where we're
41:22 - going to write the logic for crey the
41:25 - main character so that
41:28 - uh we can reuse that in both the start
41:30 - scene in the menu and in the actual game
41:34 - so in the main C so I'm going to create
41:37 - a function which is going to act as the
41:39 - Constructor it's going to be called make
41:42 - player and it's going to take in the
41:44 - context and then here we can use the
41:48 - make method from capl which what it does
41:52 - is like the add function but the only
41:54 - difference between make and add is that
41:56 - make create the game object but does not
41:58 - display it on screen later on we're
42:00 - going to add if you create if you make
42:03 - an add call to a make to the result of
42:06 - that is going to actually create it so
42:09 - for now we just we're just are worrying
42:11 - we're just are focusing sorry with
42:14 - creating the game object itself so here
42:16 - I'm going to use the Sprite component
42:18 - with kby so that this is what is
42:21 - displayed here we're going to have an
42:23 - area component which defines a hitbox
42:26 - and can pass in an object with the shape
42:29 - property to specify a specific uh hitbox
42:32 - shape we're going to have a rectangle
42:34 - you can create a rectangle rectangle by
42:37 - using the k. rect with a capital letter
42:41 - in
42:43 - capl and the first Pam is the Y and X
42:49 - position relative to the the game object
42:54 - itself and you can have this as a vector
42:58 - 2 Vector 2 is just going to be in X and
43:00 - Y coordinates as a single data structure
43:03 - so here we're going to have zero for the
43:06 - first Pam and then 1.5 so that means the
43:10 - hbox is going to be placed at the
43:12 - position Z and 1.5 relative to the game
43:17 - object and then the third uh second and
43:20 - third param of the rect method or
43:24 - function is just going to be the width
43:25 - and the height of that rectangle
43:28 - so here the width and height is going to
43:30 - be 8 by5 so creb the character itself is
43:33 - 16 by 16 but by having this hitbox being
43:37 - 8 by five it's going to be more generous
43:39 - since it's a hard game and it will
43:44 - reduce the amount of Rage that the
43:46 - player will
43:47 - experience and then be by default I said
43:50 - earlier on that in C play or in Game Dev
43:54 - in general things are drawn from the top
43:56 - left corner but in this case it would be
43:58 - better for things to be so the the
44:00 - player game object to be drawn from the
44:02 - center and you can specify this by using
44:05 - the anchor component offered by Kay and
44:08 - passing in Center here as the string to
44:11 - use this you need to have the area
44:13 - component defined otherwise you're going
44:15 - to get an
44:16 - error and then finally going to scale
44:19 - the character as well the this game
44:21 - object like we did with the other one
44:23 - and this is where we can use our
44:24 - constant again here
44:27 - and then finally going to have an object
44:29 - here which is going to contain
44:30 - properties and methods that are useful
44:33 - for the player so here I'm going to have
44:36 - first an is dead is
44:40 - dead Boolean initially false which going
44:43 - we're going to use here to know when to
44:45 - display the scoreboard and when to
44:47 - restart the game and then the speed is
44:49 - going to be 600 which is the value that
44:53 - felt nice I'm going to have a key
44:56 - controllers
44:57 - array here which is going to hold event
44:59 - listeners to the various input controls
45:02 - we're going to Define and the reason
45:04 - we're doing this is because when the
45:06 - player dies we want to cancel all those
45:08 - controllers and by having them in an
45:10 - array and then iterating through them
45:11 - can disable the player control so that
45:13 - the player can no longer move once they
45:16 - die all right so now let's create our
45:18 - first method which is going to be the
45:20 - set controls method here U this is
45:23 - arbitrary and by the way if you're not
45:25 - familiar with this notation is
45:27 - equivalent to having this like that
45:29 - which you might be more familiar with so
45:31 - this method I'm going to call it set
45:33 - controls its goal as its name suggests
45:35 - is to set the controls this is not from
45:37 - Kay this is just a name I've decided to
45:39 - call this function I'm going to call it
45:42 - later on so here I'm going to
45:45 - store the jump logic I'm going to write
45:48 - into a simple small
45:50 - function so because it's a really a
45:52 - small function by convention I'm going
45:53 - to use the convention that if it's a
45:55 - reusable piece of log that you're not
45:58 - going to use elsewhere I'm just going to
45:59 - use this notation for the function and
46:01 - otherwise I use the function keyword
46:03 - this is a personal preference and you
46:07 - you can feel free to do what you want
46:09 - and here we're going to play the sound
46:12 - so here in main.js we imported the
46:14 - sounds for the various situations so
46:16 - when the player jump or gets hurt and
46:18 - here when we set the control when the
46:19 - player jumps we want to play the jump
46:22 - sound which we can use the key here of
46:25 - if you remember main. J the jump sound
46:27 - is here and uh yeah to play a sound you
46:31 - call the play Method from the C playay
46:35 - uh
46:37 - context and then here I'm going to use
46:40 - this. jump and this might be confusing
46:43 - where does this and jump comes from and
46:46 - why comma here so that's a mistake on my
46:48 - part so this can be used to refer to the
46:51 - whole game object so when you create
46:54 - methods within this object here you have
46:56 - access to the ual all all of the game
46:58 - object which is pretty handy that means
47:00 - that this refers to the game object
47:03 - itself now jump here is offered by capl
47:08 - it allows you to automatically Implement
47:11 - jumping and I realized I forgot to add
47:14 - the body components so this jump method
47:17 - comes from the fact that we used the
47:20 - jump the body component which we didn't
47:23 - so now it's time to add it so the body
47:25 - component allows us to make our game
47:28 - object um susceptible to gravity and
47:31 - also allows us to uh have the jump
47:35 - method so which implements jumping
47:37 - automatically for us you can modify
47:40 - various properties either within here
47:43 - the jump or within the body component
47:45 - itself here I'm going to set the jump
47:46 - Force to being 600 and there's the mass
47:49 - that you can modify Etc by the way go to
47:51 - the kj.com go to kls.com which is the
47:55 - where you're going to find the document
47:57 - ation for
47:58 - K so we have jump Force everything is
48:01 - fine and then let's actually Implement
48:04 - our jumping so here I'm going to use
48:07 - this. key controllers and I'm going to
48:09 - push to it the
48:11 - various uh event listeners we're going
48:13 - to create so here we have access
48:17 - to the following so this on key press
48:22 - well actually you can use a global K on
48:26 - key press and I don't remember why I did
48:30 - this this way but I think it's more
48:32 - performant to actually I don't see any
48:34 - reason
48:36 - to to use this here so use K here and
48:39 - then on key press which is offered by K
48:42 - play you can have an example here you
48:45 - pass as the first Pam the key you want
48:48 - to use and the second param is the
48:51 - function that is going to run when this
48:53 - is pressed there is another
48:57 - way of doing it where you only have one
48:59 - Pam and you have the key param here is
49:02 - going to give you every key which is a
49:04 - more handy way and better way to do it
49:06 - but in because in this project we only
49:08 - have one input really then this way is
49:13 - fine watch my previous Adventure
49:17 - platformer tutorial to know how to use
49:20 - more advanced feature of Klay it was
49:22 - called Kaboom then but everything is
49:25 - applicable the same yeah the same
49:27 - knowledge basically so here space and
49:30 - then we're going to call the jump logic
49:31 - so we're going to pass the function here
49:34 - so this this is going to result in an
49:36 - event listener
49:37 - controller and this controller is when
49:40 - space key runs it uses it runs it fires
49:44 - off the Jump logic
49:47 - function now as I said in the beginning
49:50 - of the the tutorial we will have more
49:52 - than one input method the other one is
49:55 - the click so this this um key
49:59 - controllers push maybe key controllers
50:02 - is not the the the right word here maybe
50:05 - I should call it input control input
50:08 - controllers would be a better
50:10 - name because it's not only for keys in
50:14 - the keyboard so here we can use the
50:17 - onclick method from C play and you can
50:22 - just pass in the jump logic here it's
50:24 - going to fire the function you pass in
50:27 - when the player
50:29 - klicks and then
50:32 - finally I'm going to
50:35 - push
50:37 - the the one for the game pad so for
50:40 - Gamepad you have K playay offers you the
50:43 - on
50:45 - game what's the name on Gamepad button
50:48 - press on Gamepad button
50:52 - press and then you specify the South as
50:55 - I've explained earlier you're on South
50:58 - come from the fact that if you look at
51:00 - the controller this button is to the
51:02 - South
51:04 - basically and now
51:07 - here the second param is the actual
51:10 - logic so jump logic that is going to
51:13 - fire off all right now we're almost done
51:18 - I'm going to call up the set controls
51:19 - here I'm going to call the disable
51:21 - controls which is going to be called not
51:23 - not dispat Advance disable controls
51:27 - which is a method I created I decided to
51:29 - create those function it it's not from K
51:32 - just making making sure that you
51:34 - understand that here
51:37 - disable here disable controls what it's
51:39 - going to do is just going to iterate
51:41 - through the key controllers actually now
51:43 - it's called input input controllers and
51:46 - then for each uh you could use a more
51:48 - performant for Loop but it it's only
51:52 - three elements so it's not that useful
51:54 - so key controllers
51:56 - and then arrow and then key actually key
51:59 - controller for each key
52:03 - controller it's going to we're going to
52:06 - call the cancel method which is
52:09 - available on each of those controls so
52:10 - if you look at the
52:12 - documentation I click on e h oops ah
52:16 - there's no intellisense it
52:18 - seems anyway these return these calls
52:22 - return in event controller all right so
52:24 - now in main.js I'm going going to right
52:27 - below here let's add the player so const
52:30 - player and then we're going to call the
52:32 - add function and within we're going to
52:34 - call the make player function that we
52:38 - defined earlier on that now should be
52:40 - imported from the play.js file here so
52:45 - now what I'm going to do here
52:47 - is remove uh first pass in the K here
52:51 - the context so that we can have access
52:52 - to the various Kaboom methods and then
52:55 - in here you can modify the position like
52:57 - this and as a vector 2 like that so you
53:00 - can use the vector 2 method to create a
53:01 - vector two on the
53:03 - Fly and then here we're going to put it
53:07 - at the following coordinates so I'm
53:10 - going to copy and paste this because
53:11 - it's not really that relevant I'm just
53:13 - going to explain one thing here so here
53:16 - k. Center gives you the center position
53:18 - and you have access to the X and Y
53:20 - coordinates of it and here we just make
53:23 - our creb character
53:26 - relative to the center position by a few
53:30 - given offsets here this is what looked
53:32 - good so if I look at the
53:35 - result it's here wait a minute so
53:39 - something went wrong I'm just GNA do
53:43 - F12 and here I have
53:46 - the let's go to the console and then the
53:50 - body require okay we didn't use the
53:52 - positional component so I forgot to add
53:54 - this to our def definition of the
53:59 - player so now if I run this again you
54:02 - can see that the crey character is here
54:04 - which is what we want actually by the
54:05 - way and now the last thing we have for
54:07 - this start menu scene is the start
54:10 - button and when it is clicked or when
54:12 - the player presses enter or when the
54:15 - player presses the South button on the
54:17 - game pad we should start the game so
54:20 - here in main.js we're going to have
54:23 - to create a play button so
54:26 - here we're going to do it the same way
54:29 - so I'm going to create a constant called
54:32 - play button I'm going to create a game
54:34 - object out of it and here there's no new
54:37 - Concepts so I'm going to copy and paste
54:40 - the code feel free to pause there's
54:42 - actually there's one New Concept is the
54:45 - radius so when using creating a
54:47 - rectangle by the way don't this is the
54:49 - rectangle component creates a visible
54:51 - rectangle do not um confuse this with
54:55 - the hit but
54:56 - k. rect this is not a component this is
54:59 - just creating a rectangle
55:02 - hitbox so there's a difference between
55:04 - the two so once when you want to create
55:08 - a rectangle that is visible you use the
55:10 - rect component from kipa when you want
55:12 - to create a rectangular hit boox in the
55:15 - shape use the k. rect
55:18 - here all right so radius of three so
55:21 - it's well rounded and then here we're
55:24 - going to add a child to the play button
55:27 - so right below here and it's going to
55:30 - use a new component that you not
55:32 - familiar with if you haven't used K
55:35 - playay before it's the text component it
55:37 - takes as the first Pam the text you
55:39 - actually want to display and the second
55:41 - param can take the size the font Etc
55:44 - here we just want the size so the size
55:47 - is going to be 24 with a this given
55:50 - color so it's a darkish color which
55:53 - follows the palette I used for the
55:55 - assets
55:57 - all right so now everything should be
56:00 - here should be fine let's look at the
56:02 - result we have the play button but if we
56:04 - click nothing happens if we press space
56:06 - nothing happens so here I'm going to use
56:09 - the same pattern we used in
56:12 - the for the um set controls for the
56:17 - player so I'm going to copy and paste
56:18 - create a disposable I guess small
56:21 - reusable piece of logic function here
56:23 - using this convention it will play the
56:26 - confirm sound and then go to main main
56:29 - is the other scene which is actual game
56:31 - and then we hook this up to the various
56:34 - input methods so on click on key press
56:37 - on game button press all right so now
56:40 - it's time to write the logic for the
56:43 - actual game here I'm going to create a
56:46 - constant I'm going to call it score it's
56:48 - going to be initially have zero so Y and
56:51 - by the way one thing is we're going to
56:54 - implement the save system right now
56:56 - actually instead of writing logic here
57:01 - in our start scene so let me just
57:04 - collapse it just to have a clearer
57:06 - picture so yeah I'm writing in a very
57:09 - big font so that you can be like really
57:11 - see the code but it's kind of
57:14 - inconvenient so we're going to have to
57:16 - Define our save system so I'm going to
57:19 - create a file called save dogs which I'm
57:22 - going to write the logic for that how
57:24 - we're going to go about save saving our
57:27 - score so the pattern I used for this is
57:31 - something very simple what I do is I
57:34 - create a function called make
57:39 - save
57:41 - system it takes a save file name you
57:44 - want to use for the game and then within
57:47 - it
57:49 - returns a an object this object has a
57:52 - first a data property which contains the
57:55 - data we're going to SA save it's going
57:57 - to contain an async method called
58:02 - save it's going to contain another async
58:05 - method that is going to be load the
58:07 - reason those are in async is because
58:09 - we're going to call the Tory API within
58:11 - and the Tory API is a
58:14 - synchronous so here in our save function
58:18 - what we're going to do is we're going to
58:20 - call the right text
58:24 - file method
58:26 - from or function from the Tori
58:29 - API this is something from Tori it takes
58:33 - three params it takes the save file name
58:38 - so actual name the the path or actually
58:41 - the yeah the save file name not the path
58:44 - and then here actually it's
58:46 - two yeah three the content and then the
58:49 - sorry so it takes the the name of the
58:52 - file the content which is just going to
58:54 - be a Json stringify so we're going to
58:58 - convert our data here so we can use
59:01 - this. data into text and then it the
59:06 - final one is going to be the base
59:09 - directory so the D deer it's an object
59:12 - that you need to specify the base
59:14 - directory and then app local data this
59:18 - is how going to be able to write the
59:22 - data here to the save file name which is
59:25 - going to be save.
59:26 - Jon and along the base directory app
59:31 - local data if you weren to not use this
59:33 - it wouldn't allow
59:35 - it and here base directory is imported
59:38 - from here it's a an
59:40 - enom and app local data is basically
59:43 - like the the thing the folder I've shown
59:46 - you earlier on all right that's it
59:50 - that's how you write to a file and if
59:53 - the file didn't exist before it's just
59:55 - going to create it and if it already
59:58 - existed it's going to override it so you
60:00 - might need to append in certain
60:02 - situation but for our project we can
60:06 - just overwrite when the score that the
60:09 - player has acquired in the current game
60:12 - is higher than what was written on
60:15 - disk and then the load function here is
60:18 - we're going to have a try catch because
60:20 - we might attempt to try to read a file
60:23 - that doesn't exist especially when the
60:24 - player first opened the game the goal of
60:27 - this is that we will store into the data
60:30 - property that we created here the the
60:33 - actual data so J from the the file so we
60:36 - going to use Json parse which is going
60:38 - to parse the text uh the string that we
60:43 - stored inside of our save. Json file so
60:47 - here we're going to call the await read
60:51 - text file API from Tori pass in the say
60:56 - file name and then the second param is
61:01 - just a deer so deer directory base
61:04 - directory and then app local
61:09 - data and then if for some reason it's
61:12 - not possible and this occurs when the
61:15 - file doesn't exist and it happens when
61:18 - the player first install install the
61:20 - game for the first time or they
61:23 - installed the game in the past uninstall
61:26 - it and then removed the save file from
61:28 - the local
61:30 - folder then what we're going to do in
61:32 - this case we're just going to set the
61:35 - data property from within the game to an
61:38 - empty object and then when we're going
61:41 - to save we just going to write to a new
61:43 - file to the to the file basically to a
61:46 - new file because it didn't exist all
61:49 - right we have everything we go here uh
61:51 - we want here so now we're just going to
61:55 - EXP
61:56 - Port our safe system so I'm going to
61:59 - have a constant call it safe system
62:01 - which is going to be we're going to call
62:03 - the make safe system and we're going to
62:05 - pass in that we want to store this in
62:08 - save. Json so when the player opens up
62:11 - the game they go to the start scene and
62:14 - at the end of the start scene we're
62:16 - going to call our save system this
62:19 - should be imported from our our file
62:22 - just to make sure save system has been
62:24 - imported
62:26 - and then here what we're going to do is
62:29 - we have save system and then we're going
62:31 - to load so initially if the file didn't
62:34 - exist then we're going to have an if
62:37 - statement which is going to make sure
62:39 - that if the save
62:42 - [Music]
62:43 - system
62:45 - dot um
62:50 - data Max score which is a property that
62:54 - doesn't exist yet
62:56 - um by the
62:57 - way the it doesn't exist
63:00 - yet so I'm I'm assuming like we have the
63:04 - the the player they open up the game for
63:06 - the first time that means there's no
63:08 - data so we load the data from our safe
63:10 - system and this is called going to go
63:13 - into the try catch is going to be
63:16 - catched because it doesn't exist you
63:18 - cannot read a file that does not exist
63:21 - that means that this the data is going
63:22 - to be set to basically the the default
63:25 - so when we arrive here for the first
63:27 - time after having loaded the the the
63:31 - data then the max score property doesn't
63:34 - exist and this is where we're going to
63:37 - actually set it so save
63:39 - system. data. Max score we're going to
63:43 - initially set it to
63:44 - zero then we're going to save that data
63:49 - that we just wrote Into the data object
63:53 - to disk by calling the save method and
63:56 - then reloading it to actually this is
64:00 - not necessary to reload it
64:04 - here but because we just write the same
64:06 - thing and then we we don't need to
64:08 - reload it so I'm going to not need that
64:12 - so here we go and uh the reason I'm
64:15 - doing this is just to make sure that if
64:16 - the player opens up the game for the
64:18 - first
64:19 - time we have actually a Max score
64:22 - property that is created in that save.
64:24 - Json file
64:26 - all right so now let's write the meat of
64:30 - the game which is the main scene here
64:34 - I'm going to have a variable I'm going
64:37 - to call it score which is going to
64:39 - increment as the player is surviving and
64:43 - avoiding the
64:45 - obstacles now the next thing I want to
64:48 - do is I'm going to import the colliders
64:51 - data so I'm going to use an await and
64:53 - then an await and then fetch and then
64:56 - the reason I'm doing this is to fetch
64:58 - this colliders data so here I'm just
65:01 - going to do.
65:03 - colliders data. Json and then once you
65:08 - receive once you receive a response here
65:10 - you need to await the response and then
65:12 - you need to await again while it is
65:15 - converted to
65:16 - Json usually people do this in two calls
65:19 - they first store this into a response
65:21 - constant and then call Json on it but I
65:24 - prefer to have it on one line here for
65:27 - con for conciseness and then here I'm
65:30 - going to create colliders data and it's
65:33 - going to be the colliders object. data
65:36 - and the reason it's do data is that if
65:38 - you look at the colliders data Json it's
65:42 - a data property with an array and we
65:44 - were only interested in the array so
65:47 - that's why I'm storing it as its own uh
65:51 - constant and then I'm going to call make
65:53 - Background by the way this should
65:55 - probably be called call at the top the
65:57 - first thing we want to do because the
65:59 - background we set here
66:01 - is is dependent on each scene so you
66:06 - cannot have a global background that you
66:09 - can set but actually you could you can
66:11 - use the set background but the issue
66:14 - with the set background is doesn't
66:15 - respect the aspect ratio the letter box
66:17 - that means that if you call this method
66:19 - from KL it's going to color even in the
66:23 - the place where it shouldn't be like the
66:24 - black bars so it doesn't in respect the
66:26 - aspect
66:28 - ratio all right so we have the make
66:30 - background here
66:33 - and
66:35 - yep so now what comes next is we're
66:38 - going to use set gravity so that the
66:41 - player is going to be affected by
66:43 - gravity the value the G value that was
66:48 - uh that felt nice was 20
66:52 - 2,500 uh set gravity is a method from
66:56 - Kay so yeah by the way if you see still
66:59 - Kaboom context here it's because it was
67:01 - previously called
67:03 - Kaboom all right and then here the logic
67:06 - is going to be very similar to what we
67:08 - had initially I could have abstracted
67:10 - this into a function by the way I
67:15 - noticed something is I called this map
67:18 - you could have called it level and then
67:20 - later on in my or source code on GitHub
67:24 - I used level here which is
67:26 - inconsistent and I should probably do
67:28 - better so I'm going to just copy and
67:33 - paste here so this first part and just
67:37 - for the sake of consistency let's use
67:40 - map everywhere because it's the same
67:42 - logic copy and paste it
67:45 - basically so here you could create a
67:47 - function that takes care of all of
67:50 - this uh I'm not going to do this just to
67:53 - go faster because the the the main draw
67:56 - of this tutorial is really to teach you
67:57 - how to have this all as a desktop app
67:59 - not necessarily the game itself if
68:02 - you're interested in more like code
68:03 - organization and tutorials where I take
68:06 - care more of that you can see my other
68:08 - tuto watch my other
68:11 - tutorials so here we have okay so I
68:14 - replaced it with map and then
68:17 - here for we going to have the platforms
68:20 - like we did initially here and instead
68:22 - of level it's going to be map
68:26 - and
68:27 - then here it's the different logic so
68:31 - actually never
68:32 - mind uh yeah yeah this is a different
68:35 - logic so here we also had the platforms
68:37 - if you go
68:38 - to the logic we had for the start menu
68:42 - we had clouds we
68:45 - had actually yeah we had the platforms
68:48 - here but now we need to actually do
68:50 - something with the platforms that's why
68:51 - I store them inside their own constant
68:54 - and then here below we're going to use
68:56 - the on update on update methods that is
69:00 - called every
69:01 - frame and here I'm going to make all the
69:04 - platforms move by the way the platforms
69:06 - are just a single Big Image so it can be
69:09 - treated as a single entity it's not
69:11 - multiple Sprites so here the move
69:14 - function we're going to move to the
69:17 - speed
69:18 - platforms. speed
69:20 - here and
69:22 - then zero and and then here is going to
69:27 - be something else so we're going to use
69:30 - the same logic that we used for the
69:32 - clouds so we're going to have as long as
69:34 - the position is inferior to certain
69:37 - value well as soon as the the platform's
69:40 - position is inferior to a certain value
69:43 - we're going to replace the platforms to
69:44 - being to the right and then we
69:47 - progressively increas the speed so that
69:49 - it is a challenge for the player so
69:52 - here's the comment I left here by the
69:54 - way the source code is available on
69:56 - GitHub might be a slightly different
69:58 - from what I'm writing here but you can
70:01 - use it as a
70:02 - reference and then here we have this
70:06 - now and we can have the loop method
70:10 - something from K so every second it's
70:13 - going to fire run the function past as a
70:17 - second peram and here we're just going
70:19 - to increment the
70:21 - score by one simple way to
70:25 - uh calculate the score and then here is
70:27 - where we're going to have add the hitbox
70:29 - to all the platforms or the obstacles
70:32 - maybe obstacles would have been a better
70:34 - name since it's the the name of the
70:37 - Sprites here but initially I wanted to
70:39 - make a Kirby like and then teach you how
70:42 - to use Tory but I thought would be like
70:44 - too complicated and it's better to
70:45 - isolate and do something simple that so
70:48 - that you can be familiar with how to
70:50 - make like desktop
70:52 - games all right so here we as I said
70:55 - our obstacles are a single image and by
70:58 - using the collider's data we're going to
71:00 - know where to draw the hitbox for each
71:02 - of those obstacles within that image so
71:05 - we're going to create child game objects
71:08 - of the platform's game object so here
71:14 - for going to use a for Loop or const
71:18 - collider of
71:21 - colliders data
71:25 - we're GNA add for each of them to the
71:27 - platforms game object we're gonna add so
71:30 - the platforms is a child of the map and
71:33 - every collider here is going to be a
71:35 - child of the platform so that their
71:37 - position is relative to the platform the
71:40 - obstacle image that means when this
71:42 - image moves the all the colliders are
71:44 - going to move at the same time without
71:45 - any extra logic from our
71:47 - part and then here uh it's the same
71:51 - thing so I'm just going to copy and
71:53 - paste actually there's one thing
71:56 - different is static so here we create a
72:00 - hitbox with a rectangle with a collider
72:02 - width and collider height this comes
72:04 - from the Json file which has these these
72:07 - values we place the X the position X and
72:12 - Y this is going to be relative to the
72:14 - platform the obstacle image which is
72:16 - what we want and then here the body by
72:20 - calling the is stat by setting the is
72:23 - static property to being true what will
72:25 - happen happen is it's going to be solid
72:27 - so that our player cannot pass through
72:30 - and it's going to act as
72:32 - obstacles all right now we're going to
72:35 - need to create two other game objects
72:37 - that are going to sit at the top and
72:40 - bottom of the
72:42 - screen and those two game objects
72:45 - outside of the for Loop but still in the
72:47 - main scene are going to act as walls up
72:50 - and above so here it's the width the
72:53 - rectangle is going to be the width of
72:55 - the whole screen one is going to be
72:57 - placed at the top of the screen but not
72:59 - visible and the other as well and we
73:02 - don't need them to be fixed since we're
73:05 - not going to modify their position the
73:08 - player positions play the player
73:10 - position isn't moving at all
73:13 - anyway oh by the way never mind I think
73:16 - it uh actually might might need this
73:20 - anyway let's keep it for now and then
73:23 - going to remove it if it's not necessary
73:24 - I'm think thinking of an edge case but
73:26 - it might not be actually a case all
73:30 - right so now if I look at the
73:32 - result you can see that we have nothing
73:35 - for now and but the the platforms are
73:38 - slightly increasing in
73:41 - speed so now let's call our player so
73:45 - const player make player pass in the K
73:49 - and then right below player position the
73:53 - position that sounded nice looked nice
73:55 - was 600 by
73:58 - 250 we're going to set the player
74:01 - control so that the player can start
74:03 - start moving and then we're going to
74:05 - have going to use Cap's On Collide logic
74:08 - so when this on Collide method available
74:11 - on game object is that when the player
74:14 - on collides with this so by the way I
74:17 - forgot to explain what is this this is a
74:20 - tag you can set it so that you can use
74:24 - them later on in on Collide calls to
74:26 - know to check for collisions so here on
74:30 - Collide when the player on collides with
74:33 - the tag here the tag here is going to be
74:34 - the obstacle
74:36 - obstacle so every game object that has
74:39 - this tag is concerned by this
74:42 - uh this um
74:46 - method that is going to is going to fire
74:49 - so basically when the player collides
74:52 - with the obstacle this runs what will
74:54 - run here is first we check if the player
74:56 - is not already dead so player is dead
74:59 - make sure that this is if it's true that
75:01 - means we don't run the logic that comes
75:03 - afterwards and then we play the her
75:08 - sound then we set the platform's speed
75:12 - to being
75:14 - zero and because of that because we set
75:16 - the platform I don't think fixed is
75:18 - necessary because the player is not
75:19 - moving so the camera is not moving at
75:21 - all so let's set it to like that so
75:25 - platform speed is going to be set to
75:27 - zero then we're going to disable the
75:30 - player controls so disable
75:33 - controls of the
75:35 - player and then here I'm going to have
75:39 - to
75:40 - do and
75:42 - create score
75:47 - box and then
75:50 - set player is dead true
75:55 - so let's play our
75:58 - game okay where's the player by the way
76:02 - you can use the F1 key to open the debug
76:05 - mode oh I think I know because we called
76:08 - the make player we didn't add it to the
76:09 - screen so you need to call it within a
76:13 - add because make player uses the make
76:16 - function which creates the game object
76:18 - but doesn't actually added to the scene
76:20 - so now it should work so if I go
76:23 - here here we go go we have our
76:26 - game so let's uh on purpose hit and then
76:31 - nothing happens okay now if I refresh
76:34 - again using F5 and I go to the
76:38 - top yeah so those walls that are not
76:41 - visible are here to prevent the player
76:43 - from going out of
76:44 - bounds so yep and
76:48 - here where are there yep so those are
76:51 - the the walls those two game objects
76:53 - here
76:55 - okay so the last part is really to
76:57 - create the
76:58 - scoreboard so I'm going to the scorebox
77:01 - not board well it could be a board
77:04 - scored box. JS so here we're going to
77:07 - have an export
77:09 - function and then make score box takes
77:14 - the context K but it's going to also
77:16 - take a position I think yep it's going
77:19 - to take a position which is going to be
77:20 - a vector 2 which going to have X and Y
77:22 - coordinates and that's it and oh of
77:25 - course one last thing is the actual
77:27 - current
77:29 - score and now here we're going to use
77:33 - the save system and we want it want to
77:38 - load from the
77:41 - file the save system because we're going
77:43 - to have to compare to the
77:46 - actual uh Max score so making sure to
77:49 - read the file that we have saved so that
77:53 - we can do the comparison here here so if
77:55 - the score is superior the current score
77:58 - is superior to the save system.
78:02 - data do Max score Max score if that's
78:09 - the case then we're going to put it in
78:12 - the save system Max score the new score
78:15 - the new maximum score and then we're
78:17 - going to call await and then save system
78:21 - and here is actually where we do the
78:22 - saving so we can call it save by the way
78:25 - this should be a sync so we can use a
78:28 - away and this is the actual thing that
78:31 - writes to dis so maybe I should have
78:33 - call it save system. write and read but
78:36 - I think load and save are
78:39 - pretty understandable terms so now let's
78:42 - create our box and here I'm going to use
78:46 - the make function as well so
78:49 - here the make function and the reason I
78:52 - want this fixed though is
78:56 - yeah because here it's important to have
78:58 - it fixed independent from the camera
79:00 - camera because depending on where the
79:02 - player is on but actually never mind the
79:05 - camera shouldn't even be moved in the
79:07 - first place so there's no need for that
79:11 - so here nothing new uh except for the
79:14 - outline component which creates an
79:16 - outline and we can give it a particular
79:18 - color as the second param this is going
79:20 - to be the outermost container and then
79:23 - I'm going to add as child game object
79:26 - the various text we need so this is
79:29 - something I'm going to just copy and
79:31 - paste because it's tedious to
79:33 - write here we go uh let me just go up so
79:37 - you can copy so this is the previous
79:39 - best score text which we take from the
79:43 - Save
79:44 - system and a given position Etc here
79:48 - same thing for the current
79:50 - score and then current rank which
79:53 - actually we didn't write the compute
79:55 - rank method function so yeah let's just
79:59 - copy this for now those two hit pause
80:04 - and maybe like that can see
80:07 - everything now I'm going to go in utils
80:10 - and the rank compute rank is just going
80:12 - to give a rank depending on the score
80:15 - value so here export function compute
80:17 - rank in utils and then you pass in the
80:21 - score and then depending on the score
80:23 - we're just going to
80:25 - give it a letter based grade so the rank
80:29 - and here I'm just going to copy and
80:31 - paste the logic just a bunch of if
80:33 - statements maybe you should have used
80:35 - them maybe I should have used a switch
80:38 - case here but yeah so if the score is
80:40 - superior to 30 S rank Superior to 20 a
80:43 - rank Superior to 10 B rank Superior to
80:47 - two c Rank and D if you have zero one or
80:53 - zero and and that's it so now if I go
80:56 - back to the scoreboard uh
80:58 - scorebox let's import the compute rank
81:02 - import compute
81:06 - Rank and uh yep so now it should compute
81:10 - it so if I play the
81:14 - game uh by the way I did not call this
81:17 - score boards but but we haven't finish
81:19 - who haven't finished we need to do the
81:22 - following we need to create the restart
81:25 - button and the same logic for the
81:27 - restart button and then return the
81:29 - container which is the whole parent of
81:32 - the box so
81:34 - here we have this restart button that as
81:38 - a child of the container as well which
81:40 - is going to be a rectangle with this
81:42 - color and then it's going to be uh drawn
81:45 - from the center nothing new here no new
81:47 - Concepts and then here as a child of the
81:50 - restart button going to have the text
81:52 - play again again with the following size
81:56 - Etc and then here I should have followed
81:59 - this is just a real reusable piece of
82:02 - logic that isn't used elsewhere actually
82:05 - it is used elsewhere it's not the first
82:07 - time that we have something like that uh
82:09 - but I think it was a different every
82:10 - case right here it's jump
82:13 - logic and I think it was
82:18 - used where it was
82:20 - used it was used here right
82:24 - go to game so maybe this should go so we
82:29 - have this here let's take this let's go
82:33 - to utils Let's create another utils
82:36 - let's write it as a proper
82:40 - function well well they're both proper
82:43 - function I mean like with a function
82:45 - syntax let's go back to
82:48 - main let's
82:52 - just ah the issue now is that we need
82:54 - need to use an arrow
82:56 - here and then call and passing the
82:59 - K and then an arrow
83:03 - here and then pass in K and then an
83:08 - arrow here and then pass in K because we
83:12 - don't want the function to be called
83:14 - immediately if you were to pass it and
83:16 - it would be called with the parenthesis
83:18 - it would call it immediately but we
83:19 - still need to pass the context so that
83:21 - we need to wrap it inside of an aror
83:23 - function definition
83:25 - so that's that and then the above let's
83:29 - go to U Tails here and add it go to
83:33 - game that means in our score box I can
83:37 - just remove
83:38 - that I can go
83:40 - above I can import it go to G here we
83:47 - go and uh here we go so we have the on
83:50 - click Etc so on key press the various
83:53 - inputs this again again could be
83:55 - abstracted away but I want to keep
83:57 - things simple for this project and then
83:59 - finally we return the container which
84:01 - contains everything so the whole score
84:04 - box and then in
84:06 - main.js if I scroll
84:09 - down in the to-do we're going to call k.
84:15 - add
84:16 - score make scorebox pass in the
84:22 - context pass in the following position I
84:26 - don't remember the actual position I
84:27 - used at the end of the day we just pass
84:29 - in the center k. Center
84:32 - here position which is well I should
84:36 - have probably hardcoded it here in
84:38 - scorebox if it's the center but imagine
84:41 - in a future use case where we want to
84:43 - display more components like that score
84:45 - box at in various different places so it
84:49 - doesn't hurt I guess and then finally
84:51 - has this third peram the score that we
84:53 - had in Main and here we had to find it
84:56 - above here in our main
84:59 - scene all right so that's basically it
85:03 - and uh now I think our game is
85:07 - done yeah I think our game is done uh so
85:10 - let me check okay we have a
85:14 - mistake uh does not provide a goto games
85:17 - core box just utils does not pro if I go
85:22 - to
85:22 - utils go to game and then if I go to the
85:26 - score
85:28 - box ah okay because we need to wrap it
85:33 - under a arrow
85:35 - function I'm just going to copy and
85:37 - paste
85:41 - this save all right now things should
85:47 - work um yeah so I didn't read the the
85:51 - proper error message so what's the issue
85:53 - syntax error the requested module source
85:56 - u.j does not provide an export name go
85:59 - to game is that
86:02 - true yes export sorry I missed I missed
86:07 - that now if I go here we have our
86:11 - game and then let's die and okay what
86:16 - what's what is
86:17 - that W trigger is not a
86:21 - function what do you mean
86:25 - uh okay I made a mistake
86:28 - somewhere oh I know
86:30 - why if I go back to
86:33 - main here remember this was an await
86:37 - here we return a promise so it's trying
86:39 - to add a promise as a game object
86:41 - doesn't work like that so we need to use
86:43 - a wait
86:45 - here uh okay wait a minute only allowed
86:49 - within a sync function but this needs to
86:50 - be a sync so the scene itself needs to
86:52 - be a sync
86:54 - uh not not the same the
86:58 - um the UN Collide call back so that
87:02 - means we don't need to have here as a oh
87:05 - we need because we need we needed to
87:07 - make a fetch call to the Json file which
87:11 - contains the collider
87:12 - data all right
87:15 - so I think that's
87:17 - it previous best score three current
87:20 - score one previous best rank C so let's
87:22 - try beating our score
87:29 - here we
87:31 - go we have CC as the rank okay let's try
87:36 - let's try for
87:38 - 20 at the same time we're we're going to
87:41 - test a few things
87:45 - so all
87:48 - right 15 current rank B so next time if
87:52 - I die here previous best score 10 ah
87:56 - okay it's not doing it right that's
87:59 - probably due to the fact that I here I
88:02 - did not load it in the
88:05 - main in the start sorry scene if I go to
88:10 - where I set up the safe system I did not
88:15 - load the safe system here I need to load
88:19 - here as well now the last part of the
88:22 - tutorial H it's basically getting the
88:24 - executables getting ready to distribute
88:27 - the project so I'm going to close the
88:30 - project and then you're going to write
88:32 - npm run
88:35 - build so now it's going to build the
88:39 - project it's going
88:41 - to compile and this is going to take a
88:46 - maybe a lot of time at first when you do
88:49 - it for the first time it's the first
88:50 - time building the
88:52 - project so let's wait all right it's
88:54 - almost done compiling and as I said this
88:58 - compilation step takes a lot of time the
89:00 - first time you do
89:01 - it but then uh it's relatively quick
89:06 - afterwards so now there's only one thing
89:11 - left and here we go running and then
89:16 - producing the MSI which is what is
89:18 - useful to distribute all right the
89:21 - project has been built after a long time
89:25 - now to get the executable you can go
89:28 - here to source. tari
89:31 - Target and release and then in bundle
89:35 - this is what you want to distribute
89:37 - either the MSI or
89:39 - the the NIS so either one of those two
89:43 - should be fine the reason I want you to
89:45 - distribute these instead of the C
89:47 - kirby.exe file is that this these are
89:51 - installers and if you uh if the player
89:56 - is is either playing on an older machine
89:59 - and doesn't have the web view2 system
90:00 - installed on their machine then the
90:02 - installer is going to take care of
90:04 - installing it for them all right uh so
90:07 - yeah just distribute that on h. or steam
90:11 - either one of them and that's it this is
90:13 - how you make a desktop game in
90:15 - JavaScript all right thanks for watching
90:18 - I hope this tutorial was useful for you
90:20 - and yep that's it uh feel free to
90:22 - subscribe for more JavaScript Game Dev
90:24 - related content bye I forgot to mention
90:27 - something very important in the project
90:30 - is that if you want your um executable
90:34 - so once uh the Tor app is installed so
90:37 - when the your game is installed on the
90:39 - user machine if they hover over it and
90:42 - this short description property is not
90:45 - defined is is going to display a Tory
90:47 - app and I would assume you want a
90:50 - description of your project to appear
90:53 - and not a Tori app so to have this
90:57 - description you need to go to tori.
90:59 - conf. Json and then under the bundle add
91:03 - the short description and your
91:05 - description here so that's all

Cleaned transcript:

in this course JS Legend will teach you how to make a game in JavaScript with the capl library and how to use Tori to make it installable on a Windows PC JS Legend dev has created many popular courses hi everyone welcome to this new tutorial today I'll teach you how to make a desktop game in JavaScript so JavaScript is usually used for the web but with a technology called T you we're going to be able to make a game that is installable on your PC so we're going to use Tori and the capl library if you don't have any experience with both of them I'm going to explain everything so this tutorial is really for you in the sense the only prerequisites you need is a good fundamental understanding of JavaScript now let's get started so the game we going to build here is a Flappy Bird Style game so you jump here and then when you hit the obstacle you have your previous best score that is always written to dis so you have the concept of this save file and this is something I wanted to teach you because this is one of the main draw of having a desktop game in JavaScript is so that you can save your games so usually JavaScript is used for the web and in the web you know you have local storage but it isn't a very safe way to store data because as soon as the player clears their browser cache it's going to wipe out the save so this is one of the main aspect main draw of having your game as a desktop game if it grows above of a certain size and you need to keep track of save data so let's jump right into it so in this game one thing I forgot to mention is that we're going to have multiple inputs it's going to be a very simple game because I want to focus on the actual Tor Concepts and the capl concept so capl is the library for making games that is very easy it was called Kaboom Jaz previously if you want to know why the Rebrand you can watch the previous video by the way I I made a a lot of tutorials on Kaboom JS and how like C playay basically now how to make games with it so if you're interested feel free to watch those as well they are still relevant because the difference between capl and Kaboom is just the name for now all right so here we're going to implement keyboard controls so just by pressing the space button you can jump we're going to also Implement Mouse control so by clicking you can jump but also Gamepad control by pressing the South button you're going to be able to jump so uh this might sound strange what is the South button so look at this little schematic imagine this is a controller the South button is the button the action button that is always at the South here so it's a way that capl uses those terms so that it can be independent from the actual type of controller so an Xbox controller versus a PlayStation controller have different symbols on them but at the end of the day the x button is here for the PlayStation and the for the Xbox I don't remember actually here is it A or B that is down there but by just using the South name we can just have our uh game be agnostic regarding this so let's start the project so there are some prerequisites uh that you need to have so in terms of following this tutorial you only need to know JavaScript the basics but as for the installation process and also by the way I'm going to do this mostly on windows so the reason I'm doing this on Windows because this is the machine I have and also the expectation for games is usually that they run on windows so if you're going to publish a game on Steam it's really not worth your time to support Linux and Mac OS usually now maybe with protown uh with the steam deck it's it's changing a bit but yeah so you need to follow this um this page so it's going to be linked in the description it's the prerequisites so you need to set up this on windows by the way you can still follow this tutorial on Mac OS or Linux there are some instructions but at the end of the day the execut the executable you're going to get is not going to be the one for Windows so here we're going to set up Windows uh now here I have the link in the description follow the instruction here you have a few things to install so one thing I want to mention is the web view2 thing so Tori compared to electron which is another solution technology for basically making desktop apps using JavaScript HTML and CSS is that with electron it packages a whole Chrome browser for each version of your app so if if it's on Linux or Mac OS Etc it's always going to package a fixed version of Chrome and the advantage of that is that your app is going to be rendered the exact same way regard regardless of the platform however the drawback of this is that it's going to make your app bloated so because electron has to package a whole Chrome browser that means an executable that does basically nothing so a project empty project is going to be I think 100 megabytes now with Tori the actual end game like the full game uh that I've shown you earlier is only 6 megabytes so you can see that it's really not bloated and the way Tori achieves this is by have using the systems web view so for each operating system they have a web view that Tori uses but the issue is that is that you cannot really make sure that the app is going to be rendered the same way on all platforms because uh you know different browser engines have different particularities it's mostly the same but not it's not exactly the same the reason I'm going to use Tory for this tutorial is because it was very easier to set up than electron less bloed since uh on Windows and also on other platforms but the most important aspect that uh basically determined that I wanted to use Tori instead of electron is the fact that I really am targeting Windows only for this project so I don't really care or feel any of the drawback of the fact that it's not exactly the same browser engine on the various other platforms because I'm not publishing to other platforms all right so once you follow this so you install and by the way another drawback perceived drawback is that it needs to have this web V2 runtime install on the users ma machine that is going to use the app but now it should be available on all windows 11 uh PL uh operating systems distributions but not on Windows 10 uh or certain or Windows 7 I think and then the reason for that is well it's it's not available by default and if you were to just distribute aexe made with Tori then this would be an issue because you would have to make sure that the user has the web view to install on their machine now this is not an issue in the end because we're going to distribute the installer the MSI and this installer that we get after building the project is going to install this web view2 runtime on the user's machine if it's not already available so you don't have to worry about anything and yeah you need to install rust even though in this tutorial we're not going to use it really we're just going to well we're going to R write some commands but we're not going to write rust basically it's just the project itself is built with rust because there's a JavaScript API that you can use to read and write to a file which makes it very beginner friendly I guess all right so follow this and once you have uh followed the prerequisites for your platform let's jump right into the project all right so what are how do we start a project so also you have to have nodejs installed this should have been mentioned in the prerequisites link that I've shown you earlier on so you need to run npm create ta at latest dot here if we're in a folder so I'm using vs code as my editor I have created this kbby folder because creb is the name I've chosen for this project and then once I'm in this project I can use the dot notation here so that it's it's going to create the project files within the the current folder I'm in if you were to emit this it would create a different folder for you so run this command and then maybe I should increase the font size already just to make sure that everything is visible and then the package name you have to specify your package name I'm going to call it kbe uh tutorial actually just creepy I'm going to use typescript and JavaScript this project uses JavaScript but you need to use like which one for your front end you want and then npm and then here do not select the vanilla UI template because the vanilla UI template is just going to be a build lless HTML CSS in JavaScript so we still need to use a build system because it's very it's more convenient to install and use the um Tor API that way so I'm going to take the react template but I'm going to remove everything that is related to react for this project and then choose JavaScript here all right so we have everything we need now I'm going to open up the package.json and you can see that we have a couple of dependencies we going to need to remove so we're going to need to remove react and react D because we're not going to use them so I'm going to type in npm uninstall react and then react D all right right the package have have been uninstalled and then I'm going to also uninstall this vgs plugin react we don't need that as well so I forgot to do that so let's do it here we go npm uninstall uninstall here we go and then that's it and now we can install the cap playay Library so cap playay can be installed in many different ways it can be installed using a script tag uh much like I did with Kaboom Jazz but for this project since we're using vit inside of it we're just going to use npm npm install C play and I'm going to install a specific version this is uh I'm making sure to pin the version here so that if you're watching this in the future it's going to always work this tutorial at least so it's a selfcontained so 3,000 that's the version 0.1.7 U if you're not familiar with KL and Kaboom it works in thousand so version 1.0 is actually one version 1,000 version 2.0 is 2,000 version 3.0 is 3,000 this is the the the naming convention that I used it say it's strange but I don't know the reason why but yeah that's it it is what it is so I'm going to hit npm install cap play with this version now we have capl installed let me check in the package.json and here we go okay so before we do anything I'm just going to collapse this I'm going to collapse this as well and I'm going to go to here so here to run Tor you need you have this Tory command just to make things convenient for us we're going to have rename those commands so we're going to have Dev do do browser and Dot browser here to differentiate from the two other commands I'm going to write here so I'm just going to do preview this is just a name I have decided for myself but here instead of having Tori here we just going to have when I run npm run Dev I want to run Tor Dev which is going to actually start the application and the reason we're doing this is because we have two systems going on we have vit which is a bundler that bundles your web code and then puts it on a local host that you can use and then there's Tory which takes this output at the same time and puts it in a desktop app desktop window so that's why we have those two commands even though for this project we're not going to use vit directly like that we're going to use Tori Dev so the other command is build and Tori build so just to check that everything works uh but because we are using the react template I'm going to remove everything that is within here so let's remove all of those files I'm going to also remove everything within the oh oops within the public folder oops all right delete this all right now we have the the index.html we don't really need much here I'm going to remove this I'm going to remove the head tag I'm going to remove it the HTML I'm going to remove even this it's it doesn't matter and then here instead of jsx it's going to be JS and then in the source file I'm going to create a main.js file now in main.js I'm going to call what we need for cap play so I'm going to import cap play from cap play and then oops and then here I'm going to initialize the capl context which is basically creates the canvas for us you call the cap playay function like that and then pass in a a bunch of options the width of the canvas is going to be uh 1,280 by the height which is 720 and then here I'm going to use the letter box options those are all options that comes from Capa so here letter box true makes our game our game will scale regardless of the Windows size while maintaining the aspect ratio and then here I'm going to put whenever or not we want this to be Global to be false so we don't want capl functions to be available globally we want to all capl functions to be callable from the K the context this will make our code cleaner and then we you want to scale the canvas two times this is what looked good uh and then this is for everything within the canvas it's going to become relevant later on so let's do that now let's go back to the terminal and run npm run Dev and then here it's going to compile your project and then you're going to have to wait a bit before it compiles and usually you're if you modify things related to Tor config I'm going to go over the file here then the application will have to close and reopen otherwise if you just modify JavaScript content here a code here it's it's usually it should usually hot hot reload I have something messed up I need to modify something in the Tor file here yeah here you should run the dev browser and then build browser and so really the preview command it doesn't matter so I'm just going to cancel this out and then everything should work all right so if I do this and then okay what's the issue cannot find the package VJs plugin react so here let's remove everything related to react in the v config because we have removed it so everything should be like that and now just so you can see uh I removed this and another option called plugin react so now let's run it hopefully it works this time around yep when you see Local Host and then it's compiling and then downloading the various crates we need this this is only done the first time I think and then it's building yeah so it might take some time it's a bit slow at but this is only like the first time all right so it was a bit slow but it's the only once you do this and then now it should hopefully open up and here we go we have our window with our canvas and then if you press F12 so let me just increase that a bit if I press F12 you'll have your console this ignore this we just remove the favicon it doesn't matter since it's a desktop application and yep so we're ready to start working on the game so let's try let's import our assets so I'm going to close this by the way you can just leave it open like that so here we go I'm going to go here and for the assets let's we're going to put them all in the public folder all right so I have imported all the assets sets you're going to find a link in the description or multiple links in the description to get everything here so I'm going to go over everyone so this is the background.png for our game clouds we're going to have a colliders data. Json which basically defines the hitbox for every platform uh obstacle so the the height and width of that hitbox and where to put it so the X and Y cordinates uh this is better I thought it would be better than having to pull an external editor like if you want interested in how to make like more serious games using an external editor called tiled watch the previous tutorial I made on the channel here are a few sounds we have the confirm sound so when you click on the button the HT sound and the jump sound those are made using a website called GS fxr.com obstacle layer here so the obstacles and then one thing also is the icon so here you can provide a bunch of different icons and there's a an icon command in Tori but for this project since it's I only care about Windows I just imported this icon for my project so just you'll find this in the description just put it in the under the source dtory and then icons folder here all right so if I look at the project you can see the icon appears here now all right I'm going to minimize this and we're ready to start working on our project so let's go back to the source folder and then in main.js so the first thing I'm going to do is to actually load bunch of our assets the way you do that in capl is to call either the load Sprite function or the load sound function there's also the load found function uh not F font sorry so load Sprite works this way so you pass in the name of the Sprite you want to use so kby this is going to be the the key that we're going to refer to in our code base and then the second param is the actual Pam so the Pam here is going to be the path to the assets which is going to be kb. PNG Dash cre so the reason it's just a dash is because when working with vit the public folder can be will automatically be linked to the root of the project so you don't have to write public SL k.png so that's the first one and that's basically it for the Sprite so I'm going to copy and paste the rest that you need here so load Sprite obstacles backgrounds and clouds much the same way for the sounds it's similar but the only thing that CH changes is that you use the load sound method instead all right one thing I want to implement right off the bat is to allow the player to go into full screen so for now if you press f11 which is us usually the keyboard shortcut for going full screen well it doesn't work so to implement this we're going to have to use the Tori API so Tori allows you to use a JavaScript API instead of rust if you want to do things that touches the native like Windows system like the the native app system so writing to a file changing the full screen etc those are things handled by the game window itself so you have this file called T.C com. Json which handles all the permissions to what you're allowed to do all right so you have a bunch of permissions and the permissions we're going to use here we going to need to edit is two things so here in our tor.com Json go to the Tor and then allow list uh um property and then here we're going to have two things so we're going to use the fs key for file system and allow us to read a file so said this true to write a file to write to a file set also this to true and the scope so the scope is here is let me just put it scope and then I'll explain so and then add a com so what is this um later on in the project we're going to need to write the save data as the save files basically uh this is a score actually I'm going to need to write this to disk so that when the player plays again some other time we know what their best score is always and for that we need to be able to write to a file and read to a file and here the way Tori works is that you need to enable each permissions each either you enable everything by using the All property or for each of those apis you enable what you need and usually the the best practice is to always enable what you only need and the scope here is the files the folder you're going to have access to only and here we're going to need to set pass in the app local data folder and by having this notation so everything in the app data local now the app local data folder is going to be accessible to our Tori application so we're going to be able to write to any file or or yeah write to any file within that folder or read any file within that F folder and the dot star here is for that as well so here this constant or this um name comes from the Tory documentation there there are various uh constant like that and it refers to if you go on Windows and you type in run in the command start the you know the windows the search bar on Windows to the left you and you type in run and then here you type in app data and you have a local local low and roaming and if you go to the local folder this is where maybe you're not seeing it maybe I can zoom y I can see so in this local folder you're going to have a folder that is the name of your application and in that folder everything you can read and write within that folder let's replace this with kby kb. game and then if you do this if you refresh uh it's going to rebuild it here you can see that we have this if you look at the path appdata local and then kb. game was created automatically by the application when it runs for the first time or when when it is installed so here is everything we're going to write the save file here we're going to read it from here Etc hope that was clear so now yeah replace the identifier make sure everything is saved and uh the other permission we need though is for with the windows permission so window permission and the exact permission we need to be able to set this to full screen is the set full screen permission and I'm going to set this to true so now if I go go back to main.js and I go here down below we can write the logic we need to make the window Go full screen when the f11 key is pressed so I'm going to add an event listener so you can do this in two ways either you do document or add event listener or you can just call add event listener directly like that and then here a key down event we want to listen to and we need an async here because the API the Tori API is asynchronous so here we going to have an EV for the event or we could call it event if you want and then here if the event code equal equal f11 that means the key was pressed so actually here a better name would be the key and then key. code is f11 key if this is pressed we're going to have first an if statement that is going to call this API so app window and you can see here app window it's going to import it from the Tor API so click on that it should import it at the top of your file and then here what will happen is that first you check if if it's full screen so is full screen you use this this is from the API if it's if it turn out turns out to be the case then we're going to set it back to not being full screen so the F1 key uh acts usually as a toggle so we can use the set full screen F function that we allowed the permission for in t.c. Json to turn it off so with false and then we have an another if statement here actually we should return early so if I have this like that I put it within brackets and we return early and then here down below if that was not the case that means that the app window is not full screen so I can just do app window and of course don't forget to await well actually it's not necessary to await here because there we don't do anything afterwards so set full screen and then set test to true so here we needed to await so that we don't move on we don't return before we are sure that actually yeah we don't return before we are we are sure that the the app was set to full screen in this case it doesn't I don't think it really matters but here it would matter because otherwise we would return a promise and not the actual value so yep okay so let's test it out so I'm going to open the application it is here now I'm going to press f11 and we can see that it is full screen now if I put it back here it's not anymore all right so now let's actually start working on the game and we're going to create two scenes so in cap playay the way you create a scene is by calling the scene method or function and then giving it a name and then passing as the second param a function that is going to contain the logic for that scene so we going to need two scenes we going to need the first scene called start which is the menu and then the first the second scene I'm going to call it main it's going to be the actual content of the game and then I'm going to call the go function which will go to the start scene when the game starts so start function main function and and uh start scene main scene Etc so I'm going to write a new file here I'm going to call it ut. JS it's just going to contain a few utilities that are going to be used uh for now we're just going to create a function that makes the background a certain color so I'm going to call make I'm going to call it make background I'm going to pass in the K context so I don't have to import K everywhere which is the c cap playay context and then I'm going to call the add function so the way cap playay works is that you create game objects using the add function and passing it an array of components so the array of components you pass in which usually are components that are offered by kipl they will then come together to create a game object with specific behaviors and properties so here I'm going to use the rectangular component from capl I'm going to call the width method and height method so that this rectangle takes the full height and width of the canvas I'm going to set the color by using the color component of that rectangle so I'm going to set the color using the color component H for the rectangle so it's not a color component of the rectangle it's just a color component offered by kaboon that allows you to modify the color of a game object so here I'm going to call the from heex method which can be accessed like this and allows us to specify a heximal value so by default the color components takes RGB values which mean three params uh that can vary from 0 to 255 but we want a specific color and the hexa usually in pixel art or in art you use hexadecimal instead of like RGB to specify colors so that's why what I prefer to use and then finally we're going to have a last component from KL again called the fixed component which will make the actually yeah yeah which going to make the the background independent from the camera because the camera is going to follow the player but by the way I think this is useless because in a Flappy Bird Style game the main the player never moves actually they just jump and it's the platforms that moves or the obstacles that moves towards them so this component is not necessary so let's use that in our main in our first scene the start scene I'm going to just going to call it make background and pass in the K here context that comes from here now if I look at the result you can see that here we have bars here that does are the just the the black bars and then you have the appropriate color I prefer my black bars here to be black and not white so here in the body I'm just going to have a style tag we're not going to spend too much time in CSS just one thing body a selector and then set that to being background color and then black so now it will look much nicer y I think this is better so now what comes next is to actually draw the background so I'm going to create something called a map game object it's going to act as the parent of all the game objects that are props or obstacles clouds Etc they're going to be all CH children of that singular map game object so this is a feature that allows you to do is to create game objects but also to have child game objects and parent game object so here we create a parent game object like a usual game object with the add function and we pass in the following array of components we can use the Sprite component offered by Klay and then you specify the key for the Sprite Which was defined earlier on in the load Sprite function so here I'm going to have the background as the Sprite I want to use for this game object I also have access to the positional component which allows us to set the position of our game object here z z because it's the background want it to be at the origin and by the way in game development things are drawn from the top left corner uh unless you specify the center to be the origin of the Sprite or the game object and then finally I'm going to actually scale our game here so here I'm going to use a I'm going to create a constants DJs file constants count uh constants DJs I'm going to export const and I'm going to call it scale factor because the the pixel art is going to be too small so for things to be visible I'm going to have to scale things a bit now you have two options actually either let's scale it four times either you make the camera zoom in or you make the Sprites scale so either one should work so scale factor is going to be the thing I'm going to use here don't forget to import it otherwise you're going to have an error so I'm going to import import import scale factor from whoops from constants now did I get this right export yep should work okay now let's go back to main so we should have our game object it should appear on the screen and you can see that we have our background looks pretty nice now we're going to have to add the clouds and the way I'm going to go about this is I'm going to create the clouds as a child game object of the map so the way I do this is by having a call to map. add so every game object has also the add function as a method that allows you to create game objects but this time they are a children of that game object instead of a global game object and here I'm going to again have a Sprite component where the clouds and when you create a child game object what happens is that their position is relative to the parent game object which is pretty handy here however we are going to need to call the positional components so that we can have access to the position and be able to set it if you don't do that you cannot modify the position so even though I don't need to specify a value here because I just want to later on modify the cloud so they move in a certain direction uh I still need to call the Sprite uh the positional component and now the last one I think we here in Kaboom JS what's handy and allows you to get away with not using classes Etc is that each game object can have as part of their ARA of components an object which you can specify in their its properties so here I'm going to specify the speed property as being a five so it's going to be the the rate at which the clouds are going to move so here I'm going to store the reference to those clouds here because by default when you all create a game object using the ad it always returns that game object even as a child of another game object it will return the child game object object and here we have multiple clouds and not just one under the same image so that's why it's the Cloud's game object and not every individual Cloud as game object which is better for performance reasons so here what I'm going to do is I'm going to use one of the other methods that are available is the onupdate methods on every game object which runs this function every frame so usually 60 frames 60 times per second so here I'm going to use the clouds move method which is also offered by Klay on game object which allows you to just move a game object along the X and Y coordinates at a certain rate so here I can use the speed I've defined earlier on and access it like this so the game object name do the property T and then here it's going to be as the first bam that means it's going to move to along the x axis uh yeah positively so to the right and then for the y axis I don't want to change this the speed so it's going to be zero and now here right below what we're going to do is a clever trick so for now if I run this the clouds are moving to the right and then once they are fully gone to the right they'll never come back so what I'm going to do is I'm going to use a clever trick is I'm going to make sure that once the Cloud's uh position cloud. pause you can access the position this way and that's why I needed to to use the pause component if you didn't use that you wouldn't be able to access the current position so if the cloud clouds. position is uh X because it offers you both the X and Y value but we only need the x value is superior to 700 which is when when they leave the frame the the visible area of the canvas then we're just going to set back the position of along the xaxis to be of minus 500 the reason we do this is is they go all the way back to the left immediately they teleport back to the left and then they will continue their movement so basically we have infinite clouds that uh go from left to right so if I go here now here I'm not going to wait uh for this to be done but you you'll see you'll notice while playing game the final game that as the CL clouds move to the the right and they moved fully to the right so that they are no longer visible they're going to appear back from the left because they are teleported back so now the last thing we need for that scene is to add the obstacle as another game object to the map and here we're going to need the Sprite obstacles so the obstacle Sprite and I think that's it and by the way because initially we scaled the map game object the parent game object everything else the the children are also going to get Scaled by the way forgot to mention that for the last game object the obstacle game object we're going to have to specify the position as well by using the position component but not ex not necessarily passing in a value because we're going to modify this value later on and read it and here we're going to use the area component which is also offered by KL and allows you to specify a hitbox for your game object actually you know what I think it's not necessary here because the hit boox is going to be dependent on something else but for this yeah here in this case we don't need it we don't need it going to see when we're going to need it later on and uh that's it or maybe yep that's it I think that's it yeah so yeah we we don't need anything El so if I look at the app you can see so basically what we're building here in the start is the start menu basically that's it so we're going to put the the creb character here and the play button and then actually in the main is actually where we're going to write the actual Logic for jumping Etc what we're going to do now is create a player. JS file which is where we're going to write the logic for crey the main character so that uh we can reuse that in both the start scene in the menu and in the actual game so in the main C so I'm going to create a function which is going to act as the Constructor it's going to be called make player and it's going to take in the context and then here we can use the make method from capl which what it does is like the add function but the only difference between make and add is that make create the game object but does not display it on screen later on we're going to add if you create if you make an add call to a make to the result of that is going to actually create it so for now we just we're just are worrying we're just are focusing sorry with creating the game object itself so here I'm going to use the Sprite component with kby so that this is what is displayed here we're going to have an area component which defines a hitbox and can pass in an object with the shape property to specify a specific uh hitbox shape we're going to have a rectangle you can create a rectangle rectangle by using the k. rect with a capital letter in capl and the first Pam is the Y and X position relative to the the game object itself and you can have this as a vector 2 Vector 2 is just going to be in X and Y coordinates as a single data structure so here we're going to have zero for the first Pam and then 1.5 so that means the hbox is going to be placed at the position Z and 1.5 relative to the game object and then the third uh second and third param of the rect method or function is just going to be the width and the height of that rectangle so here the width and height is going to be 8 by5 so creb the character itself is 16 by 16 but by having this hitbox being 8 by five it's going to be more generous since it's a hard game and it will reduce the amount of Rage that the player will experience and then be by default I said earlier on that in C play or in Game Dev in general things are drawn from the top left corner but in this case it would be better for things to be so the the player game object to be drawn from the center and you can specify this by using the anchor component offered by Kay and passing in Center here as the string to use this you need to have the area component defined otherwise you're going to get an error and then finally going to scale the character as well the this game object like we did with the other one and this is where we can use our constant again here and then finally going to have an object here which is going to contain properties and methods that are useful for the player so here I'm going to have first an is dead is dead Boolean initially false which going we're going to use here to know when to display the scoreboard and when to restart the game and then the speed is going to be 600 which is the value that felt nice I'm going to have a key controllers array here which is going to hold event listeners to the various input controls we're going to Define and the reason we're doing this is because when the player dies we want to cancel all those controllers and by having them in an array and then iterating through them can disable the player control so that the player can no longer move once they die all right so now let's create our first method which is going to be the set controls method here U this is arbitrary and by the way if you're not familiar with this notation is equivalent to having this like that which you might be more familiar with so this method I'm going to call it set controls its goal as its name suggests is to set the controls this is not from Kay this is just a name I've decided to call this function I'm going to call it later on so here I'm going to store the jump logic I'm going to write into a simple small function so because it's a really a small function by convention I'm going to use the convention that if it's a reusable piece of log that you're not going to use elsewhere I'm just going to use this notation for the function and otherwise I use the function keyword this is a personal preference and you you can feel free to do what you want and here we're going to play the sound so here in main.js we imported the sounds for the various situations so when the player jump or gets hurt and here when we set the control when the player jumps we want to play the jump sound which we can use the key here of if you remember main. J the jump sound is here and uh yeah to play a sound you call the play Method from the C playay uh context and then here I'm going to use this. jump and this might be confusing where does this and jump comes from and why comma here so that's a mistake on my part so this can be used to refer to the whole game object so when you create methods within this object here you have access to the ual all all of the game object which is pretty handy that means that this refers to the game object itself now jump here is offered by capl it allows you to automatically Implement jumping and I realized I forgot to add the body components so this jump method comes from the fact that we used the jump the body component which we didn't so now it's time to add it so the body component allows us to make our game object um susceptible to gravity and also allows us to uh have the jump method so which implements jumping automatically for us you can modify various properties either within here the jump or within the body component itself here I'm going to set the jump Force to being 600 and there's the mass that you can modify Etc by the way go to the kj.com go to kls.com which is the where you're going to find the document ation for K so we have jump Force everything is fine and then let's actually Implement our jumping so here I'm going to use this. key controllers and I'm going to push to it the various uh event listeners we're going to create so here we have access to the following so this on key press well actually you can use a global K on key press and I don't remember why I did this this way but I think it's more performant to actually I don't see any reason to to use this here so use K here and then on key press which is offered by K play you can have an example here you pass as the first Pam the key you want to use and the second param is the function that is going to run when this is pressed there is another way of doing it where you only have one Pam and you have the key param here is going to give you every key which is a more handy way and better way to do it but in because in this project we only have one input really then this way is fine watch my previous Adventure platformer tutorial to know how to use more advanced feature of Klay it was called Kaboom then but everything is applicable the same yeah the same knowledge basically so here space and then we're going to call the jump logic so we're going to pass the function here so this this is going to result in an event listener controller and this controller is when space key runs it uses it runs it fires off the Jump logic function now as I said in the beginning of the the tutorial we will have more than one input method the other one is the click so this this um key controllers push maybe key controllers is not the the the right word here maybe I should call it input control input controllers would be a better name because it's not only for keys in the keyboard so here we can use the onclick method from C play and you can just pass in the jump logic here it's going to fire the function you pass in when the player klicks and then finally I'm going to push the the one for the game pad so for Gamepad you have K playay offers you the on game what's the name on Gamepad button press on Gamepad button press and then you specify the South as I've explained earlier you're on South come from the fact that if you look at the controller this button is to the South basically and now here the second param is the actual logic so jump logic that is going to fire off all right now we're almost done I'm going to call up the set controls here I'm going to call the disable controls which is going to be called not not dispat Advance disable controls which is a method I created I decided to create those function it it's not from K just making making sure that you understand that here disable here disable controls what it's going to do is just going to iterate through the key controllers actually now it's called input input controllers and then for each uh you could use a more performant for Loop but it it's only three elements so it's not that useful so key controllers and then arrow and then key actually key controller for each key controller it's going to we're going to call the cancel method which is available on each of those controls so if you look at the documentation I click on e h oops ah there's no intellisense it seems anyway these return these calls return in event controller all right so now in main.js I'm going going to right below here let's add the player so const player and then we're going to call the add function and within we're going to call the make player function that we defined earlier on that now should be imported from the play.js file here so now what I'm going to do here is remove uh first pass in the K here the context so that we can have access to the various Kaboom methods and then in here you can modify the position like this and as a vector 2 like that so you can use the vector 2 method to create a vector two on the Fly and then here we're going to put it at the following coordinates so I'm going to copy and paste this because it's not really that relevant I'm just going to explain one thing here so here k. Center gives you the center position and you have access to the X and Y coordinates of it and here we just make our creb character relative to the center position by a few given offsets here this is what looked good so if I look at the result it's here wait a minute so something went wrong I'm just GNA do F12 and here I have the let's go to the console and then the body require okay we didn't use the positional component so I forgot to add this to our def definition of the player so now if I run this again you can see that the crey character is here which is what we want actually by the way and now the last thing we have for this start menu scene is the start button and when it is clicked or when the player presses enter or when the player presses the South button on the game pad we should start the game so here in main.js we're going to have to create a play button so here we're going to do it the same way so I'm going to create a constant called play button I'm going to create a game object out of it and here there's no new Concepts so I'm going to copy and paste the code feel free to pause there's actually there's one New Concept is the radius so when using creating a rectangle by the way don't this is the rectangle component creates a visible rectangle do not um confuse this with the hit but k. rect this is not a component this is just creating a rectangle hitbox so there's a difference between the two so once when you want to create a rectangle that is visible you use the rect component from kipa when you want to create a rectangular hit boox in the shape use the k. rect here all right so radius of three so it's well rounded and then here we're going to add a child to the play button so right below here and it's going to use a new component that you not familiar with if you haven't used K playay before it's the text component it takes as the first Pam the text you actually want to display and the second param can take the size the font Etc here we just want the size so the size is going to be 24 with a this given color so it's a darkish color which follows the palette I used for the assets all right so now everything should be here should be fine let's look at the result we have the play button but if we click nothing happens if we press space nothing happens so here I'm going to use the same pattern we used in the for the um set controls for the player so I'm going to copy and paste create a disposable I guess small reusable piece of logic function here using this convention it will play the confirm sound and then go to main main is the other scene which is actual game and then we hook this up to the various input methods so on click on key press on game button press all right so now it's time to write the logic for the actual game here I'm going to create a constant I'm going to call it score it's going to be initially have zero so Y and by the way one thing is we're going to implement the save system right now actually instead of writing logic here in our start scene so let me just collapse it just to have a clearer picture so yeah I'm writing in a very big font so that you can be like really see the code but it's kind of inconvenient so we're going to have to Define our save system so I'm going to create a file called save dogs which I'm going to write the logic for that how we're going to go about save saving our score so the pattern I used for this is something very simple what I do is I create a function called make save system it takes a save file name you want to use for the game and then within it returns a an object this object has a first a data property which contains the data we're going to SA save it's going to contain an async method called save it's going to contain another async method that is going to be load the reason those are in async is because we're going to call the Tory API within and the Tory API is a synchronous so here in our save function what we're going to do is we're going to call the right text file method from or function from the Tori API this is something from Tori it takes three params it takes the save file name so actual name the the path or actually the yeah the save file name not the path and then here actually it's two yeah three the content and then the sorry so it takes the the name of the file the content which is just going to be a Json stringify so we're going to convert our data here so we can use this. data into text and then it the final one is going to be the base directory so the D deer it's an object that you need to specify the base directory and then app local data this is how going to be able to write the data here to the save file name which is going to be save. Jon and along the base directory app local data if you weren to not use this it wouldn't allow it and here base directory is imported from here it's a an enom and app local data is basically like the the thing the folder I've shown you earlier on all right that's it that's how you write to a file and if the file didn't exist before it's just going to create it and if it already existed it's going to override it so you might need to append in certain situation but for our project we can just overwrite when the score that the player has acquired in the current game is higher than what was written on disk and then the load function here is we're going to have a try catch because we might attempt to try to read a file that doesn't exist especially when the player first opened the game the goal of this is that we will store into the data property that we created here the the actual data so J from the the file so we going to use Json parse which is going to parse the text uh the string that we stored inside of our save. Json file so here we're going to call the await read text file API from Tori pass in the say file name and then the second param is just a deer so deer directory base directory and then app local data and then if for some reason it's not possible and this occurs when the file doesn't exist and it happens when the player first install install the game for the first time or they installed the game in the past uninstall it and then removed the save file from the local folder then what we're going to do in this case we're just going to set the data property from within the game to an empty object and then when we're going to save we just going to write to a new file to the to the file basically to a new file because it didn't exist all right we have everything we go here uh we want here so now we're just going to EXP Port our safe system so I'm going to have a constant call it safe system which is going to be we're going to call the make safe system and we're going to pass in that we want to store this in save. Json so when the player opens up the game they go to the start scene and at the end of the start scene we're going to call our save system this should be imported from our our file just to make sure save system has been imported and then here what we're going to do is we have save system and then we're going to load so initially if the file didn't exist then we're going to have an if statement which is going to make sure that if the save system dot um data Max score which is a property that doesn't exist yet um by the way the it doesn't exist yet so I'm I'm assuming like we have the the the player they open up the game for the first time that means there's no data so we load the data from our safe system and this is called going to go into the try catch is going to be catched because it doesn't exist you cannot read a file that does not exist that means that this the data is going to be set to basically the the default so when we arrive here for the first time after having loaded the the the data then the max score property doesn't exist and this is where we're going to actually set it so save system. data. Max score we're going to initially set it to zero then we're going to save that data that we just wrote Into the data object to disk by calling the save method and then reloading it to actually this is not necessary to reload it here but because we just write the same thing and then we we don't need to reload it so I'm going to not need that so here we go and uh the reason I'm doing this is just to make sure that if the player opens up the game for the first time we have actually a Max score property that is created in that save. Json file all right so now let's write the meat of the game which is the main scene here I'm going to have a variable I'm going to call it score which is going to increment as the player is surviving and avoiding the obstacles now the next thing I want to do is I'm going to import the colliders data so I'm going to use an await and then an await and then fetch and then the reason I'm doing this is to fetch this colliders data so here I'm just going to do. colliders data. Json and then once you receive once you receive a response here you need to await the response and then you need to await again while it is converted to Json usually people do this in two calls they first store this into a response constant and then call Json on it but I prefer to have it on one line here for con for conciseness and then here I'm going to create colliders data and it's going to be the colliders object. data and the reason it's do data is that if you look at the colliders data Json it's a data property with an array and we were only interested in the array so that's why I'm storing it as its own uh constant and then I'm going to call make Background by the way this should probably be called call at the top the first thing we want to do because the background we set here is is dependent on each scene so you cannot have a global background that you can set but actually you could you can use the set background but the issue with the set background is doesn't respect the aspect ratio the letter box that means that if you call this method from KL it's going to color even in the the place where it shouldn't be like the black bars so it doesn't in respect the aspect ratio all right so we have the make background here and yep so now what comes next is we're going to use set gravity so that the player is going to be affected by gravity the value the G value that was uh that felt nice was 20 2,500 uh set gravity is a method from Kay so yeah by the way if you see still Kaboom context here it's because it was previously called Kaboom all right and then here the logic is going to be very similar to what we had initially I could have abstracted this into a function by the way I noticed something is I called this map you could have called it level and then later on in my or source code on GitHub I used level here which is inconsistent and I should probably do better so I'm going to just copy and paste here so this first part and just for the sake of consistency let's use map everywhere because it's the same logic copy and paste it basically so here you could create a function that takes care of all of this uh I'm not going to do this just to go faster because the the the main draw of this tutorial is really to teach you how to have this all as a desktop app not necessarily the game itself if you're interested in more like code organization and tutorials where I take care more of that you can see my other tuto watch my other tutorials so here we have okay so I replaced it with map and then here for we going to have the platforms like we did initially here and instead of level it's going to be map and then here it's the different logic so actually never mind uh yeah yeah this is a different logic so here we also had the platforms if you go to the logic we had for the start menu we had clouds we had actually yeah we had the platforms here but now we need to actually do something with the platforms that's why I store them inside their own constant and then here below we're going to use the on update on update methods that is called every frame and here I'm going to make all the platforms move by the way the platforms are just a single Big Image so it can be treated as a single entity it's not multiple Sprites so here the move function we're going to move to the speed platforms. speed here and then zero and and then here is going to be something else so we're going to use the same logic that we used for the clouds so we're going to have as long as the position is inferior to certain value well as soon as the the platform's position is inferior to a certain value we're going to replace the platforms to being to the right and then we progressively increas the speed so that it is a challenge for the player so here's the comment I left here by the way the source code is available on GitHub might be a slightly different from what I'm writing here but you can use it as a reference and then here we have this now and we can have the loop method something from K so every second it's going to fire run the function past as a second peram and here we're just going to increment the score by one simple way to uh calculate the score and then here is where we're going to have add the hitbox to all the platforms or the obstacles maybe obstacles would have been a better name since it's the the name of the Sprites here but initially I wanted to make a Kirby like and then teach you how to use Tory but I thought would be like too complicated and it's better to isolate and do something simple that so that you can be familiar with how to make like desktop games all right so here we as I said our obstacles are a single image and by using the collider's data we're going to know where to draw the hitbox for each of those obstacles within that image so we're going to create child game objects of the platform's game object so here for going to use a for Loop or const collider of colliders data we're GNA add for each of them to the platforms game object we're gonna add so the platforms is a child of the map and every collider here is going to be a child of the platform so that their position is relative to the platform the obstacle image that means when this image moves the all the colliders are going to move at the same time without any extra logic from our part and then here uh it's the same thing so I'm just going to copy and paste actually there's one thing different is static so here we create a hitbox with a rectangle with a collider width and collider height this comes from the Json file which has these these values we place the X the position X and Y this is going to be relative to the platform the obstacle image which is what we want and then here the body by calling the is stat by setting the is static property to being true what will happen happen is it's going to be solid so that our player cannot pass through and it's going to act as obstacles all right now we're going to need to create two other game objects that are going to sit at the top and bottom of the screen and those two game objects outside of the for Loop but still in the main scene are going to act as walls up and above so here it's the width the rectangle is going to be the width of the whole screen one is going to be placed at the top of the screen but not visible and the other as well and we don't need them to be fixed since we're not going to modify their position the player positions play the player position isn't moving at all anyway oh by the way never mind I think it uh actually might might need this anyway let's keep it for now and then going to remove it if it's not necessary I'm think thinking of an edge case but it might not be actually a case all right so now if I look at the result you can see that we have nothing for now and but the the platforms are slightly increasing in speed so now let's call our player so const player make player pass in the K and then right below player position the position that sounded nice looked nice was 600 by 250 we're going to set the player control so that the player can start start moving and then we're going to have going to use Cap's On Collide logic so when this on Collide method available on game object is that when the player on collides with this so by the way I forgot to explain what is this this is a tag you can set it so that you can use them later on in on Collide calls to know to check for collisions so here on Collide when the player on collides with the tag here the tag here is going to be the obstacle obstacle so every game object that has this tag is concerned by this uh this um method that is going to is going to fire so basically when the player collides with the obstacle this runs what will run here is first we check if the player is not already dead so player is dead make sure that this is if it's true that means we don't run the logic that comes afterwards and then we play the her sound then we set the platform's speed to being zero and because of that because we set the platform I don't think fixed is necessary because the player is not moving so the camera is not moving at all so let's set it to like that so platform speed is going to be set to zero then we're going to disable the player controls so disable controls of the player and then here I'm going to have to do and create score box and then set player is dead true so let's play our game okay where's the player by the way you can use the F1 key to open the debug mode oh I think I know because we called the make player we didn't add it to the screen so you need to call it within a add because make player uses the make function which creates the game object but doesn't actually added to the scene so now it should work so if I go here here we go go we have our game so let's uh on purpose hit and then nothing happens okay now if I refresh again using F5 and I go to the top yeah so those walls that are not visible are here to prevent the player from going out of bounds so yep and here where are there yep so those are the the walls those two game objects here okay so the last part is really to create the scoreboard so I'm going to the scorebox not board well it could be a board scored box. JS so here we're going to have an export function and then make score box takes the context K but it's going to also take a position I think yep it's going to take a position which is going to be a vector 2 which going to have X and Y coordinates and that's it and oh of course one last thing is the actual current score and now here we're going to use the save system and we want it want to load from the file the save system because we're going to have to compare to the actual uh Max score so making sure to read the file that we have saved so that we can do the comparison here here so if the score is superior the current score is superior to the save system. data do Max score Max score if that's the case then we're going to put it in the save system Max score the new score the new maximum score and then we're going to call await and then save system and here is actually where we do the saving so we can call it save by the way this should be a sync so we can use a away and this is the actual thing that writes to dis so maybe I should have call it save system. write and read but I think load and save are pretty understandable terms so now let's create our box and here I'm going to use the make function as well so here the make function and the reason I want this fixed though is yeah because here it's important to have it fixed independent from the camera camera because depending on where the player is on but actually never mind the camera shouldn't even be moved in the first place so there's no need for that so here nothing new uh except for the outline component which creates an outline and we can give it a particular color as the second param this is going to be the outermost container and then I'm going to add as child game object the various text we need so this is something I'm going to just copy and paste because it's tedious to write here we go uh let me just go up so you can copy so this is the previous best score text which we take from the Save system and a given position Etc here same thing for the current score and then current rank which actually we didn't write the compute rank method function so yeah let's just copy this for now those two hit pause and maybe like that can see everything now I'm going to go in utils and the rank compute rank is just going to give a rank depending on the score value so here export function compute rank in utils and then you pass in the score and then depending on the score we're just going to give it a letter based grade so the rank and here I'm just going to copy and paste the logic just a bunch of if statements maybe you should have used them maybe I should have used a switch case here but yeah so if the score is superior to 30 S rank Superior to 20 a rank Superior to 10 B rank Superior to two c Rank and D if you have zero one or zero and and that's it so now if I go back to the scoreboard uh scorebox let's import the compute rank import compute Rank and uh yep so now it should compute it so if I play the game uh by the way I did not call this score boards but but we haven't finish who haven't finished we need to do the following we need to create the restart button and the same logic for the restart button and then return the container which is the whole parent of the box so here we have this restart button that as a child of the container as well which is going to be a rectangle with this color and then it's going to be uh drawn from the center nothing new here no new Concepts and then here as a child of the restart button going to have the text play again again with the following size Etc and then here I should have followed this is just a real reusable piece of logic that isn't used elsewhere actually it is used elsewhere it's not the first time that we have something like that uh but I think it was a different every case right here it's jump logic and I think it was used where it was used it was used here right go to game so maybe this should go so we have this here let's take this let's go to utils Let's create another utils let's write it as a proper function well well they're both proper function I mean like with a function syntax let's go back to main let's just ah the issue now is that we need need to use an arrow here and then call and passing the K and then an arrow here and then pass in K and then an arrow here and then pass in K because we don't want the function to be called immediately if you were to pass it and it would be called with the parenthesis it would call it immediately but we still need to pass the context so that we need to wrap it inside of an aror function definition so that's that and then the above let's go to U Tails here and add it go to game that means in our score box I can just remove that I can go above I can import it go to G here we go and uh here we go so we have the on click Etc so on key press the various inputs this again again could be abstracted away but I want to keep things simple for this project and then finally we return the container which contains everything so the whole score box and then in main.js if I scroll down in the todo we're going to call k. add score make scorebox pass in the context pass in the following position I don't remember the actual position I used at the end of the day we just pass in the center k. Center here position which is well I should have probably hardcoded it here in scorebox if it's the center but imagine in a future use case where we want to display more components like that score box at in various different places so it doesn't hurt I guess and then finally has this third peram the score that we had in Main and here we had to find it above here in our main scene all right so that's basically it and uh now I think our game is done yeah I think our game is done uh so let me check okay we have a mistake uh does not provide a goto games core box just utils does not pro if I go to utils go to game and then if I go to the score box ah okay because we need to wrap it under a arrow function I'm just going to copy and paste this save all right now things should work um yeah so I didn't read the the proper error message so what's the issue syntax error the requested module source u.j does not provide an export name go to game is that true yes export sorry I missed I missed that now if I go here we have our game and then let's die and okay what what's what is that W trigger is not a function what do you mean uh okay I made a mistake somewhere oh I know why if I go back to main here remember this was an await here we return a promise so it's trying to add a promise as a game object doesn't work like that so we need to use a wait here uh okay wait a minute only allowed within a sync function but this needs to be a sync so the scene itself needs to be a sync uh not not the same the um the UN Collide call back so that means we don't need to have here as a oh we need because we need we needed to make a fetch call to the Json file which contains the collider data all right so I think that's it previous best score three current score one previous best rank C so let's try beating our score here we go we have CC as the rank okay let's try let's try for 20 at the same time we're we're going to test a few things so all right 15 current rank B so next time if I die here previous best score 10 ah okay it's not doing it right that's probably due to the fact that I here I did not load it in the main in the start sorry scene if I go to where I set up the safe system I did not load the safe system here I need to load here as well now the last part of the tutorial H it's basically getting the executables getting ready to distribute the project so I'm going to close the project and then you're going to write npm run build so now it's going to build the project it's going to compile and this is going to take a maybe a lot of time at first when you do it for the first time it's the first time building the project so let's wait all right it's almost done compiling and as I said this compilation step takes a lot of time the first time you do it but then uh it's relatively quick afterwards so now there's only one thing left and here we go running and then producing the MSI which is what is useful to distribute all right the project has been built after a long time now to get the executable you can go here to source. tari Target and release and then in bundle this is what you want to distribute either the MSI or the the NIS so either one of those two should be fine the reason I want you to distribute these instead of the C kirby.exe file is that this these are installers and if you uh if the player is is either playing on an older machine and doesn't have the web view2 system installed on their machine then the installer is going to take care of installing it for them all right uh so yeah just distribute that on h. or steam either one of them and that's it this is how you make a desktop game in JavaScript all right thanks for watching I hope this tutorial was useful for you and yep that's it uh feel free to subscribe for more JavaScript Game Dev related content bye I forgot to mention something very important in the project is that if you want your um executable so once uh the Tor app is installed so when the your game is installed on the user machine if they hover over it and this short description property is not defined is is going to display a Tory app and I would assume you want a description of your project to appear and not a Tori app so to have this description you need to go to tori. conf. Json and then under the bundle add the short description and your description here so that's all
